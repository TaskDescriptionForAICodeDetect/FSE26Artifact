[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 998'244'353, INV2 = 499'122'177;\nint difference(int a, int b) {\n    return (a -= b) < 0 ? a += P : a;\n}\nint sum(int a, int b) {\n    return (a += b) >= P ? a -= P : a;\n}\nint power(int a, int b) {\n    int result = 1;\n    while (b > 0) {\n        if (b % 2 == 1)\n            result = 1LL * result * a % P;\n        a = 1LL * a * a % P;\n        b /= 2;\n    }\n    return result;\n}\nvoid fwt(vector<int> &a) {\n    for (int i = 1; i < a.size(); i *= 2) {\n        for (int j = 0; j < a.size(); j += 2 * i) {\n            for (int k = 0; k < i; ++k) {\n                int u = sum(a[j + k], a[i + j + k]);\n                int v = difference(a[j + k], a[i + j + k]);\n                a[j + k] = u;\n                a[i + j + k] = v;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> p(1 << n);\n    for (int i = 0; i < (1 << n); ++i)\n        cin >> p[i];\n    int s = accumulate(p.begin(), p.end(), 0);\n    s = power(s, P - 2);\n    for (int i = 0; i < (1 << n); ++i)\n        p[i] = 1LL * p[i] * s % P;\n    --p[0];\n    fwt(p);\n    for (int i = 1; i < (1 << n); ++i)\n        p[i] = power(p[i], P - 2);\n    p[0] = (P - accumulate(p.begin() + 1, p.end(), 0LL) % P + P) % P;\n    fwt(p);\n    for (int i = 0; i < (1 << n); ++i)\n        cout << p[i] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N, a, b, c, d;\n  cin >> N >> a >> b >> c >> d;\n  int ans = 0;\n  int x = 0;\n  int y = 0;\n  string S;\n  cin >> S;\n  string T = S;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int l = 0;\n  int m = 0;\n  if(c < b){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else if(b < c && c < d){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else{\n    S[b+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        e++;\n        break;\n      }\n    }\n    S[b+1] = '.';\n    for(int i = b+1; i <= d; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        f++;\n        break;\n      }\n    }\n    if(e == 0 && f == 0){\n      cout << \"Yes\";\n      return 0;\n    }\n    l = 0;\n    m = 0;\n    T[c+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(T[i] == '#' && T[i+1] == '#'){\n        g++;\n        break;\n      }\n    }\n    for(int i = a+1; i <= c; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n    for(int i = b; i <= d; i++){\n      if(T[i] == '#' && T[i+1] == '#'){\n        h++;\n        break;\n      }\n    }\n    if(g == 0 && h == 0){\n      cout << \"Yes\";\n      return 0;\n    }\n    cout << \"No\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 600050\nconst int mod=998244353,inv2=mod+1>>1;\nusing namespace std;\nint n,al,a[N],b[N],bin[30];\ninline int qpow(int d,int z){\n\tint ret=1;\n\tfor(;z;z>>=1,d=1ll*d*d%mod)\n\t\tif(z&1)ret=1ll*ret*d%mod;\n\treturn ret;\n}\ninline void fwt(int *a,int n,int tag){\n\tfor(int i=1;i<n;i<<=1){\n\t\tfor(int j=0,I=i<<1;j<n;j+=I){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)%mod;\n\t\t\t\ta[j+k+i]=(x+mod-y)%mod;\n\t\t\t\tif(tag==-1)a[j+k]=1ll*inv2*a[j+k]%mod,a[j+k+i]=1ll*inv2*a[j+k+i]%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tfor(int i=0;i<=25;++i)bin[i]=1<<i;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<bin[n];++i)scanf(\"%d\",&a[i]),al+=a[i];\n\tal=qpow(al,mod-2);\n\tfor(int i=0;i<bin[n];++i)a[i]=1ll*al*a[i]%mod;a[0]=(a[0]+mod-1)%mod;\n\tfor(int i=1;i<bin[n];++i)b[i]=mod-1;b[0]=bin[n]-1;\n\tfwt(a,bin[n],1);fwt(b,bin[n],1);\n\tfor(int i=0;i<bin[n];++i)a[i]=1ll*qpow(a[i],mod-2)*b[i]%mod;\n\tfwt(a,bin[n],-1);a[0]=mod-a[0];\n\tputs(\"0\");\n\tfor(int i=1;i<bin[n];++i)printf(\"%d\\n\",(a[i]+a[0])%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>    \n#include<map>    \n#include<stack>    \n#include<ctime>    \n#include<cstdio>    \n#include<queue>    \n#include<cmath>    \n#include<vector>    \n#include<cstring>   \n#include<climits>    \n#include<iostream>   \n#include<algorithm>\nusing namespace std;\n#define LL long long\nLL read(){\n    LL f=1,x=0;char c=getchar();\n    while(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=-1;c=getchar();}\n    while('0'<=c&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return f*x;\n}\n#define MAXN 1000000\n#define INF 0x3f3f3f3f\n#define  Mod 998244353\n#define inv2 499122177\n//LL Mul(LL x,LL y){return (x*y-(LL)((long double)x*y/Mod)*Mod+Mod)%Mod;}\nLL Pow(LL x,LL y){\n\tLL ret=1;\n\twhile(y){\n\t\tif(y&1) ret=ret*x%Mod;\n\t\tx=x*x%Mod,y>>=1;\n\t}\n\treturn ret;\n}\nint Len(int n){int len=1;while(len<=n)len<<=1;return len;}\nvoid FWT_or(LL *A,int n,int opt){\n\tfor(int i=1;i<n;i<<=1)\n\t\tfor(int j=0,s=i<<1;j<n;j+=s)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t\tA[i+j+k]=(A[i+j+k]+(Mod+1ll*opt*A[j+k])%Mod)%Mod;\n\treturn ;\n}\nvoid FWT_and(LL *A,int n,int opt){\n\tfor(int i=1;i<n;i<<=1)\n\t\tfor(int j=0,s=i<<1;j<n;j+=s)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t\tA[j+k]=(A[j+k]+(Mod+1ll*opt*A[i+j+k])%Mod)%Mod;\n\treturn ;\n}\nvoid FWT_xor(LL *A,int n,int opt){\n\tfor(int i=1;i<n;i<<=1)\n\t\tfor(int j=0,s=i<<1;j<n;j+=s)\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tLL x=A[j+k],y=A[i+j+k];\n\t\t\t\tA[j+k]=(x+y)%Mod,A[i+j+k]=(x-y+Mod)%Mod;\n\t\t\t\tif(opt==-1) A[j+k]=1ll*A[j+k]*inv2%Mod,A[i+j+k]=1ll*A[i+j+k]*inv2%Mod;\n\t\t\t}\n\treturn ;\n}\nLL p[MAXN+5],h[MAXN+5],f[MAXN+5];\nint main(){\n\tLL sum=0;\n\tint n=read();\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=read(),sum=(sum+p[i])%Mod;\n\tsum=Pow(sum,Mod-2);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=p[i]*sum%Mod;\n\tp[0]=(p[0]+Mod-1)%Mod;\n\th[0]=(1<<n)-1;\n\tfor(int i=1;i<(1<<n);i++)\n\t\th[i]=Mod-1;\n\tFWT_xor(h,(1<<n),1),FWT_xor(p,(1<<n),1);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tf[i]=h[i]*Pow(p[i],Mod-2)%Mod;\n\tFWT_xor(f,(1<<n),-1);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tprintf(\"%lld\\n\",((f[i]-f[0])%Mod+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1<<18|1 , mod = 998244353 , G = 3 , Ginv = (mod + 1) / 3 , inv2 = (mod + 1) / 2;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , len;\nint p[N] , q[N] , F[N];\n\ninline int add(int a , int b) { a += b; return a >= mod ? a - mod : a; }\ninline int mul(int a , int b) { return (LL)a * b % mod; }\ninline int ksm(int a , int k) { int ans = 1; a %= mod; for( ; k ; k >>= 1 , a = mul(a , a)) if(k & 1) ans = mul(ans , a); return ans; }\n\nvoid FWT(int *A , int opt)\n{\n\tfor(int mid = 1 ; mid < len ; mid <<= 1)\n\t{\n\t\tint siz = mid << 1;\n\t\tfor(int j = 0 ; j < len ; j += siz)\n\t\t{\n\t\t\tfor(int k = 0 ; k < mid ; ++k)\n\t\t\t{\n\t\t\t\tint a = A[j + k] , b = A[j + k + mid];\n\t\t\t\tif(opt == 1) \n\t\t\t\t\tA[j + k] = add(a , b) , A[j + k + mid] = add(a , mod - b);\n\t\t\t\telse\n\t\t\t\t\tA[j + k] = mul(inv2 , add(a , b)) , A[j + k + mid] = mul(inv2 , add(a , mod - b));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tn = read(); len = 1 << n; int sum = 0;\n\tfor(int i = 0 ; i < len ; ++i) sum += (p[i] = read());\n\tsum = ksm(sum , mod - 2);\n\tfor(int i = 0 ; i < len ; ++i) p[i] = mul(p[i] , sum);\n\tfor(int i = 1 ; i < len ; ++i) q[i] = mod - 1;\n\tq[0] = len - 1; p[0] = add(p[0] , mod - 1);\n\tFWT(q , 1); FWT(p , 1);\n\tfor(int i = 1 ; i < len ; ++i) F[i] = mul(q[i] , ksm(p[i] , mod - 2));\n\tFWT(F , -1);\n\tint tmp = mod - F[0];\n\tfor(int i = 0 ; i < len ; ++i) cout << add(tmp , F[i]) << '\\n';\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define inv 499122177\n#define maxn 1000010\n#define mod 998244353\nusing namespace std;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,N,len,lim=1;\nint p[maxn],a[maxn];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nvoid FWT(int A[maxn],int type)\n{\n    for(int mid=1;mid<lim;mid<<=1)\n    {\n        for(int j=0;j<lim;j+=(mid<<1))\n        {\n            for(int k=0;k<mid;k++)\n            {\n                int x=A[j+k],y=A[j+k+mid];\n                if(type==1)  A[j+k]=(x+y)%mod,A[j+k+mid]=(x-y+mod)%mod;\n                else         A[j+k]=1ll*(x+y)*inv%mod,A[j+k+mid]=1ll*(x-y+mod)*inv%mod;\n            }\n        }\n    }\n}\nint main()\n{\n    n=read();\n    N=(1<<n);\n    for(int i=0;i<N;i++)  p[i]=read();\n    int sum=0;\n    for(int i=0;i<N;i++)  sum+=p[i];\n    sum=quick_pow(sum,mod-2);\n    for(int i=0;i<N;i++)  p[i]=1ll*p[i]*sum%mod;\n    p[0]=(p[0]-1+mod)%mod;\n    for(int i=0;i<N;i++)  a[i]=mod-1;\n    a[0]=N-1;\n    while(lim<2*N)  lim<<=1,len++;\n    FWT(p,1);\n    for(int i=0;i<lim;i++)  p[i]=quick_pow(p[i],mod-2); \n\n    FWT(a,1);\n    for(int i=0;i<lim;i++)  p[i]=1ll*p[i]*a[i]%mod;\n    FWT(p,-1);\n    for(int i=1;i<lim;i++)  p[i]=(p[i]-p[0]+mod)%mod;\n    p[0]=0;\n    for(int i=0;i<N;i++)  printf(\"%d\\n\",p[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = (1 << 18) + 5, mod = 998244353;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nint n, sum, a[max_n], b[max_n], ans[max_n];\n\nvoid product(int *a, int *b, int *c) {\n    for (int i = 0; i < (1 << n); ++i) {\n        for (int j = 0; j < (1 << n); ++j) {\n            c[i ^ j] += mul(a[i], b[j]);\n            c[i ^ j] %= mod;\n        }\n    }\n}\n\nint inv2 = inv(2);\n\ntemplate<bool inverse>\nvoid convolve(int n, int *a) {\n    if (n == 1) {\n        return;\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        int a0 = a[i], a1 = a[i + n / 2];\n        a[i] = (a0 + a1) % mod;\n        a[i + n / 2] = (a0 + mod - a1) % mod;\n        if (inverse) {\n            a[i] = mul(a[i], inv2);\n            a[i + n / 2] = mul(a[i + n / 2], inv2);\n        }\n    }\n    convolve<inverse>(n / 2, a);\n    convolve<inverse>(n / 2, a + n / 2);\n}\n\nvoid fast_product(int n, int *a, int *b, int *c) {\n    if (n == 1) {\n        c[0] = mul(a[0], b[0]);\n        return;\n    }\n    for (int i = 0; i < n / 2; ++i) {\n        int a0 = a[i], a1 = a[i + n / 2];\n        a[i] = (a0 + a1) % mod;\n        a[i + n / 2] = (a0 + mod - a1) % mod;\n\n        int b0 = b[i], b1 = b[i + n / 2];\n        b[i] = (b0 + b1) % mod;\n        b[i + n / 2] = (b0 + mod - b1) % mod;\n    }\n    fast_product(n / 2, a, b, c);\n    fast_product(n / 2, a + n / 2, b + n / 2, c + n / 2);\n    for (int i = 0; i < n / 2; ++i) {\n        int c0 = c[i], c1 = c[i + n / 2];\n        c[i] = mul(c0 + c1, inv2);\n        c[i + n / 2] = mul(c0 + mod - c1, inv2);\n    }\n}\n\nvoid write(int *a) {\n    for (int i = 0; i < (1 << n); ++i) {\n        printf(\"%d \", a[i]);\n    }\n    puts(\"\");\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < (1 << n); ++i) {\n        scanf(\"%d\", &a[i]);\n        sum += a[i];\n    }\n    sum = inv(sum);\n    for (int i = 0; i < (1 << n); ++i) {\n        a[i] = mul(a[i], sum);\n    }\n    a[0] = (a[0] + mod - 1) % mod;\n    b[0] = (1 << n) - 1;\n    for (int i = 1; i < (1 << n); ++i) {\n        b[i] = mod - 1;\n    }\n    convolve<false>(1 << n, b);\n    convolve<false>(1 << n, a);\n    for (int i = 0; i < (1 << n); ++i) {\n        ans[i] = mul(inv(a[i]), b[i]);\n        ans[0] += mod - ans[i];\n        ans[0] %= mod;\n    }\n    convolve<true>(1 << n, ans);\n    for (int i = 0; i < (1 << n); ++i) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 << 18;\nconst int P = 998244353;\nconst int inv2 = (P + 1) / 2;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nvoid FWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = tmp, a[k] = tnp;\n\t}\n}\nvoid UFWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = 1ll * tmp * inv2 % P, a[k] = 1ll * tnp * inv2 % P;\n\t}\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint n, goal, p[MAXN], q[MAXN], res[MAXN];\nint main() {\n\tread(n), goal = 1 << n;\n\tint sum = 0;\n\tfor (int i = 0; i < goal; i++)\n\t\tread(p[i]), sum += p[i];\n\tsum = power(sum, P - 2);\n\tfor (int i = 0; i < goal; i++) {\n\t\tp[i] = 1ll * p[i] * sum % P;\n\t\tq[i] = P - 1;\n\t}\n\tp[0] -= 1;\n\tq[0] = goal - 1;\n\tFWT(p, goal);\n\tFWT(q, goal);\n\tfor (int i = 1; i < goal; i++)\n\t\tres[i] = 1ll * q[i] * power(p[i], P - 2) % P;\n\tUFWT(res, goal);\n\tfor (int i = 0; i < goal; i++)\n\t\twriteln((res[i] - res[0] + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 5555555\nconst int MOD=998244353;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint n,a[SZ];\nconst int r2=(MOD+1)/2;\nvoid fwt(int*t)\n{\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<(1<<n);++j) if(j&(1<<i))\n\t\t{\n\t\t\tint p=(t[j^(1<<i)]+t[j])%MOD,\n\t\t\tq=(t[j^(1<<i)]-t[j])%MOD;\n\t\t\tt[j^(1<<i)]=p;\n\t\t\tt[j]=q;\n\t\t}\n}\nint w0[SZ];\nll f0[SZ],f1[SZ];\nint main()\n{\n\tscanf(\"%d\",&n); int ss=0;\n\tfor(int i=0;i<(1<<n);++i)\n\t\tscanf(\"%d\",a+i),ss+=a[i];\n\tss=qp(ss,MOD-2);\n\tfor(int i=0;i<(1<<n);++i)\n\t\ta[i]=a[i]*(ll)ss%MOD;\n\tfor(int i=0;i<(1<<n);++i)\n\t\tw0[i]=-a[i];\n\tfwt(w0);\n\tfor(int i=0;i<(1<<n);++i)\n\t\tif(i==0) w0[i]=0;\n\t\telse w0[i]=qp(1+w0[i],MOD-2);\n\tfwt(w0);\n\tfor(int i=0;i<(1<<n);++i)\n\t{\n\t\tll t=w0[0]-w0[i];\n\t\tt=(t%MOD+MOD)%MOD;\n\t\tprintf(\"%d\\n\",int(t));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[1<<18],S;\nconst ll mo=998244353;\nvector<ll> V,W;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvector<ll> hoge(vector<ll>& A,vector<ll>& B) {\n\tint n=A.size();\n\tvector<ll> R(n);\n\t\n\tif(n==1) {\n\t\tif(A[0]==0) {\n\t\t\tR[0]=0;\n\t\t}\n\t\telse {\n\t\t\tR[0]=B[0]*modpow(A[0])%mo;\n\t\t}\n\t}\n\telse {\n\t\tvector<ll> C[2],D[2],E[2];\n\t\tint i;\n\t\tFOR(i,2) C[i].resize(n/2),D[i].resize(n/2);\n\t\tFOR(i,n) {\n\t\t\tif(i%2==0) {\n\t\t\t\tC[0][i/2]+=A[i];\n\t\t\t\tD[0][i/2]+=B[i];\n\t\t\t\tC[1][i/2]+=A[i];\n\t\t\t\tD[1][i/2]+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC[0][i/2]+=A[i];\n\t\t\t\tD[0][i/2]+=B[i];\n\t\t\t\tC[1][i/2]+=mo-A[i];\n\t\t\t\tD[1][i/2]+=mo-B[i];\n\t\t\t\tC[0][i/2]%=mo;\n\t\t\t\tD[0][i/2]%=mo;\n\t\t\t\tC[1][i/2]%=mo;\n\t\t\t\tD[1][i/2]%=mo;\n\t\t\t}\n\t\t}\n\t\tE[0]=hoge(C[0],D[0]);\n\t\tE[1]=hoge(C[1],D[1]);\n\t\tFOR(i,n) {\n\t\t\tif(i%2==0) {\n\t\t\t\tR[i]=(E[0][i/2]+E[1][i/2])*(mo+1)/2%mo;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR[i]=(E[0][i/2]+mo-E[1][i/2])*(mo+1)/2%mo;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn R;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,1<<N) {\n\t\tcin>>x;\n\t\tV.push_back(x);\n\t\tS+=x;\n\t\tif(i==0) {\n\t\t\tW.push_back((1<<N)-1);\n\t\t}\n\t\telse {\n\t\t\tW.push_back(mo-1);\n\t\t}\n\t}\n\tFOR(i,1<<N) {\n\t\tV[i]=V[i]*modpow(S)%mo;\n\t\tif(i==0) V[i]=(V[i]+mo-1)%mo;\n\t}\n\t\n\tauto R=hoge(V,W);\n\tFOR(i,1<<N) if(i) R[i]=(R[i]+mo-R[0])%mo;\n\tR[0]=0;\n\t\n\tFOR(i,1<<N) cout<<R[i]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=18,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint inv2=(mod+1)>>1;\nint n;\nint a[1<<N];\nvoid FWT(int *a,int n,int flag){\n\tfor (int d=1;d<n;d<<=1)\n\t\tfor (int i=0;i<n;i+=d<<1)\n\t\t\tfor (int j=0;j<d;j++){\n\t\t\t\tint x=a[i+j],y=a[i+j+d];\n\t\t\t\ta[i+j]=Add(x+y);\n\t\t\t\ta[i+j+d]=Del(x-y);\n\t\t\t\tif (flag<0){\n\t\t\t\t\ta[i+j]=(LL)a[i+j]*inv2%mod;\n\t\t\t\t\ta[i+j+d]=(LL)a[i+j+d]*inv2%mod;\n\t\t\t\t}\n\t\t\t}\n}\nint main(){\n\tn=read(),n=1<<n;\n\tint s=0;\n\tFor(i,0,n-1)\n\t\ta[i]=read(),s+=a[i];\n\ts=Pow(s,mod-2);\n\tFor(i,0,n-1)\n\t\ta[i]=(LL)a[i]*s%mod;\t\n\tFWT(a,n,1);\n\tFod(i,n-1,0){\n\t\tif (a[i]==1){\n\t\t\ta[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\ta[i]=Pow((a[i]-1+mod)%mod,mod-2);\n\t}\n\tFWT(a,n,1);\n\tFor(i,0,n-1)\n\t\tprintf(\"%d\\n\",Del(a[i]-a[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 301000\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar();\n\twhile (!isdigit(c))\tc = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n}\nusing namespace std;\nconst int P = 998244353;\nconst int inv2 = 499122177;\ninline ll quickpow(ll x, int k) {\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1)\tres = res * x % P;\n\t\tx = x * x % P;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\nint n, nn;\nll p[N], I[N], f[N];\ninline void FWT(ll *a, int type) {\n\tfor (int i = 1; i < nn; i <<= 1) {\n\t\tfor (int j = 0; j < nn; j += (i << 1)) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tif (type == 1) {\n\t\t\t\t\tint nx = a[j + k], ny = a[i + j + k];\n\t\t\t\t\ta[j + k] = (nx + ny) % P;\n\t\t\t\t\ta[i + j + k] = (nx - ny + P) % P;\n\t\t\t\t} else {\n\t\t\t\t\tint nx = a[j + k], ny = a[i + j + k];\n\t\t\t\t\ta[j + k] = 1ll * inv2 * (nx + ny) % P;\n\t\t\t\t\ta[i + j + k] = 1ll * inv2 * (nx - ny + P) % P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tread(n); nn = (1 << n);\n\tll tot = 0;\n\tfor (int i = 0; i < nn; ++i)\tread(p[i]), tot += p[i];\n\ttot = quickpow(tot % P, P - 2);\n\tfor (int i = 0; i < nn; ++i)\tp[i] = p[i] * tot % P;\n\tp[0] = (p[0] - 1 + P) % P;\n\tI[0] = nn - 1;\n\tfor (int i = 1; i < nn; ++i)\tI[i] = P - 1;\n\tFWT(p, 1); FWT(I, 1);\n\ttot = 0;\n\tfor (int i = 1; i < nn; ++i)\tf[i] = I[i] * quickpow(p[i], P - 2) % P, tot += f[i];\n\tf[0] = P - tot % P;\n\tFWT(f, -1);\n\tfor (int i = 0; i < nn; ++i)\tprintf(\"%lld\\n\", f[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define maxn 300000\n#define ll long long\n#define ld double\n#define mod 998244353\n#define MOD 998244353\nusing namespace std;\nll inv = (mod + 1) / 2; \nll ksm(ll a, ll b)\n{\n\tif(!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif(b & 1) ns = ns * a % mod;\n\treturn ns;\n}\nvoid FWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                long long x=a[i+j],y=a[i+j+d];\n                a[i+j]=(x+y)%MOD;\n                a[i+j+d]=(x-y+MOD)%MOD;\n            }\n}\nvoid IFWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                long long x=a[i+j],y=a[i+j+d];\n                a[i+j]=(x+y)%MOD;\n                a[i+j+d]=(x-y+MOD)%MOD;\n                a[i+j]=(ll)a[i+j]*inv%MOD;\n                a[i+j+d]=(ll)a[i+j+d]*inv%MOD;\n            }\n}\nint a[maxn];\nint b[maxn];\nint c[maxn];\nint main()\n{\n\tint N;\n\tcin>>N;\n\tint n = 1 << N;\n\tll s = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tcin>>a[i], s += a[i];\t\n//\tcout<<s<<endl;\n\ts = ksm(s, mod - 2);\n\n\tfor(int i = 0; i < n; i++)\n\t\ta[i] = 1ll * a[i] * s % mod;\n\tfor(int i = 0; i < n; i++)\n\t\tb[i] = 1;\n\tb[0] -= n;\n\tFWT(a, n);\n//\tfor(int i = 0; i < n; i++)\n//\t\tcout<<a[i]<<\" \";\n//\tcout<<endl;\n\tFWT(b, n);\n\tfor(int i = 0; i < n; i++)\n\t\tc[i] = 1ll * b[i] * ksm(1 - a[i], mod - 2) % mod;\n\tIFWT(c, n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll ns = 1ll * c[i] * a[i] + b[i] - c[i];\n\t\tns %= mod;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll ans = c[i] - c[0];\n\t\tans %= mod;\n\t\tif(ans < 0) ans += mod;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n    x=0; char c=getchar(); int f=1;\n    while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n    while(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=(1<<18)+10,mod=998244353;\nint Pow(int x,int y) {\n    int res=1;\n    while(y) {\n        if(y&1) res=res*(ll)x%mod;\n        x=x*(ll)x%mod,y>>=1;\n    }\n    return res;\n}\nint A[N],B[N],C[N];\nint m,n;\nvoid FWT(int *A,int f) {\n    for(int l=1;l<n;l<<=1)\n        for(int p=l<<1,i=0;i<n;i+=p)\n            for(int j=0;j<l;++j) {\n                int t1=A[i+j],t2=A[i+l+j];\n                A[i+j]=(t1+t2)%mod;\n                A[i+l+j]=(t1-t2+mod)%mod;\n            }\n    if(f==1) {\n        int inv=Pow(n,mod-2);\n        for(int i=0;i<n;++i) A[i]=A[i]*(ll)inv%mod;\n    }\n}\nint main() {\n    rd(m); n=(1<<m);\n    int sum=0;\n    for(int i=0;i<n;++i)\n        rd(A[i]),sum+=A[i];\n    sum=Pow(sum,mod-2);\n    for(int i=0;i<n;++i)\n        A[i]=A[i]*(ll)sum%mod;\n    A[0]=(A[0]-1+mod)%mod;\n    FWT(A,0);\n//  for(int i=0;i<n;++i) printf(\"%d \",A[i]); puts(\"\");\n    B[0]=n-1;\n    for(int i=1;i<n;++i)\n        B[i]=mod-1;\n    FWT(B,0);\n    C[0]=0;\n    for(int i=1;i<n;++i)\n        C[i]=B[i]*(ll)Pow(A[i],mod-2)%mod;\n    FWT(C,1);\n    int tmp=C[0];\n    for(int i=0;i<n;++i) C[i]=(C[i]-tmp+mod)%mod;\n    for(int i=0;i<n;++i) printf(\"%d\\n\",C[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(ll i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst ll N=262227;\nconst ll INF=1e9+7;\nconst ll mod=998244353;\nll Pow(ll x,ll y){\n\tll ans=1,now=x;\n\twhile(y){\n\t\tif(y&1)ans=ans*now%mod;\n\t\tnow=now*now%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nll f[N],g[N],d[N],u[N];\nll n,m,s=0;\nint main(){\n\tscanf(\"%lld\",&n);\n\tm=1ll<<n;\n\trep0(i,m)scanf(\"%lld\",&g[i]);\n\trep0(i,m)s=(s+g[i])%mod;\n\ts=Pow(s,mod-2);\n\trep0(i,m)g[i]=g[i]*s%mod;\n\trep0(i,m){\n\t\td[i]=mod-1;\n\t\tif(!i)d[i]=(d[i]+m)%mod;\n\t}\n\tg[0]=(g[0]-1+mod)%mod;\n\tfor(ll i=1;i<m;i<<=1){\n\t\tfor(ll j=0;j<m;j+=i*2){\n\t\t\trep0(k,i){\n\t\t\t\tll x=g[j+k],y=g[i+j+k];\n\t\t\t\tg[j+k]=(x+y<mod)?x+y:x+y-mod;\n\t\t\t\tg[i+j+k]=(x-y<0)?x-y+mod:x-y;\n\t\t\t\tx=d[j+k],y=d[i+j+k];\n\t\t\t\td[j+k]=(x+y<mod)?x+y:x+y-mod;\n\t\t\t\td[i+j+k]=(x-y<0)?x-y+mod:x-y;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m-1)f[i]=Pow(g[i],mod-2)*d[i]%mod;\n\tfor(ll i=1;i<m;i<<=1){\n\t\tfor(ll j=0;j<m;j+=i*2){\n\t\t\trep0(k,i){\n\t\t\t\tll x=f[j+k],y=f[i+j+k];\n\t\t\t\tf[j+k]=(x+y<mod)?x+y:x+y-mod;\n\t\t\t\tf[i+j+k]=(x-y<0)?x-y+mod:x-y;\n\t\t\t}\n\t\t}\n\t}\n\tll in=Pow(m,mod-2);\n\trep0(i,m)printf(\"%lld\\n\",(f[i]-f[0]+mod)*in%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nint getmi(int a,int x)\n{\n    int rt=1;\n    while(x)\n    {\n        if(x&1) rt=(LL)rt*a%mod;\n        a=(LL)a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=x+y,a[i+j+k]=x-y;\n            }\n}\n\nvoid IFWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod = 998244353LL;\nint64 exgcd(int64 a,int64 b,int64 &c,int64 &d)\n{\n\tif(b == 0) {\n\t\tc = 1, d = 0;\n\t\treturn a;\n\t}\n\tint64 k = exgcd(b, a % b, d, c);\n\td -= c * (a / b);\n\treturn k;\n}\nint64 finv(int64 v)\n{\n\tint64 c,d;\n\texgcd(v,mod,c,d);\n\tif(c < 0) c += mod;\n\treturn c;\n}\nint64 f[4][262144];\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint64 sum = 0;\n\tfor(int i = 0;i < (1<<n);++i) {\n\t\tscanf(\"%lld\",&f[0][i]);\n\t\tsum += f[0][i];\n\t}\n\tsum = finv(sum);\n\tfor(int i = 0;i < (1<<n);++i) {\n\t\tf[0][i] = f[0][i] * sum % mod;\n\t\tf[1][i] = mod-1;\n\t}\n\t--f[0][0];\n\tif(f[0][0] < 0) f[0][0] += mod;\n\tf[1][0] = (1<<n)-1;\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = 0;j < (1<<n);++j) if((j&(1<<i))==0) {\n\t\t\tint64 p = f[0][j], q = f[0][j|(1<<i)];\n\t\t\tf[0][j] = (p+q)%mod;\n\t\t\tf[0][j|(1<<i)] = (p-q+mod)%mod;\n\t\t\tp = f[1][j], q = f[1][j|(1<<i)];\n\t\t\tf[1][j] = (p+q)%mod;\n\t\t\tf[1][j|(1<<i)] = (p-q+mod)%mod;\n\t\t}\n\t}\n\tfor(int i = 0;i < (1<<n);++i) {\n\t\tf[0][i] = finv(f[0][i]) * f[1][i] % mod;\n\t}\n\tint64 inv2 = finv(2);\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = 0;j < (1<<n);++j) if((j&(1<<i))==0) {\n\t\t\tint64 p = f[0][j], q = f[0][j|(1<<i)];\n\t\t\tf[0][j] = (p+q)%mod*inv2%mod;\n\t\t\tf[0][j|(1<<i)] = (p-q+mod)%mod*inv2%mod;\n\t\t}\n\t}\n\tfor(int i = 0;i < (1<<n);++i) {\n\t\tint64 val= (f[0][i]-f[0][0])%mod;\n\t\tif(val < 0) val += mod;\n\t\tprintf(\"%lld\\n\", val);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1001000,P=998244353,iv2=(P+1)>>1;\nint n,L,x,t,S,p[N],a[N];\nint qpw(int x,int y){int z=1;for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;return z;}\nvoid FWT(int *A,int o){\n\tfor(int i=1;i<L;i<<=1)for(int j=0,s=i<<1;j<L;j+=s)FOR(k,0,i-1){\n\t\tx=j+k,t=A[i+x],A[i+x]=(A[x]+P-t)%P,(A[x]+=t)%=P;\n\t\tif(o<0) A[i+x]=1ll*A[i+x]*iv2%P,A[x]=1ll*A[x]*iv2%P;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);L=1<<n;\n\tFOR(i,0,L-1) scanf(\"%d\",&a[i]),S=1ll*(S+a[i])%P;\n\tS=qpw(S,P-2);\n\tFOR(i,0,L-1) a[i]=1ll*a[i]*S%P,p[i]=P-1;\n\t(a[0]+=P-1)%=P;(p[0]+=L)%=P;\n\tFWT(a,+1);FWT(p,+1);\n\tFOR(i,0,L-1) a[i]=1ll*p[i]*qpw(a[i],P-2)%P;FWT(a,-1);\n\tFOR(i,0,L-1) cout<<(a[i]-a[0]+P)%P<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n    int x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n    return x*f;\n}\ninline ll readll(){\n    ll x;\n    char c;\n    int f=1;\n    while((c=getchar())!='-' && (c>'9' || c<'0'));\n    if(c=='-') f=-1,c=getchar();\n    x=c^'0';\n    while((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n    return x*f;\n}\nconst int maxn=(1<<18),mod=998244353,inv2=(mod+1)/2;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint n,a[maxn],N,b[maxn];\ninline void fwt(int *y,int flag){\n\tfor(int k=2;k<=N+1;k<<=1)\n\t\tfor(int i=0;i<=N;i+=k)\n\t\t\tfor(int j=0;j<(k>>1);++j){\n\t\t\t\tint y1=y[i+j],y2=y[i+j+(k>>1)];\n\t\t\t\tif(flag) y[i+j]=(y1+y2)%mod,y[i+j+(k>>1)]=(y1-y2+mod)%mod;\n\t\t\t\telse y[i+j]=(ll)(y1+y2)*inv2%mod,y[i+j+(k>>1)]=(ll)(y1-y2+mod)*inv2%mod;\n\t\t\t}\n}\nint main(){\n\tn=read();\n\tN=(1<<n)-1;\n\tint sum=0;\n\tREP(i,0,N) a[i]=read(),sum+=a[i];\n\tsum=ksm(sum,mod-2);\n\tREP(i,0,N) a[i]=(ll)a[i]*sum%mod,b[i]=(i==0?N:mod-1);\n\ta[0]=(a[0]+mod-1)%mod;\n\tfwt(a,1),fwt(b,1);\n\tREP(i,0,N) a[i]=(ll)ksm(a[i],mod-2)*b[i]%mod;  \n\tfwt(a,0);\n\tREP(i,0,N) printf(\"%d\\n\",(a[i]+mod-a[0])%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=400010,P=998244353;\nint n,m,inv,sum,a[MAXN],b[MAXN],e[MAXN];\nint qpow (int a,int b) {\n\tint res=1;\n\twhile (b) {\n\t\tif (b&1) {res=(1ll*res*a)%P;}\n\t\ta=(1ll*a*a)%P,b>>=1;\n\t}\n\treturn res;\n}\nvoid fwt (int a[],int lim,int type) {\n\tfor (int i=1;i<lim;i<<=1) {\n\t\tfor (int j=0;j<lim;j+=(i<<1)) {\n\t\t\tfor (int k=0;k<i;k++) {\n\t\t\t\tint x=(a[j+k]+a[j+k+i])%P,y=(a[j+k]-a[j+k+i]+P)%P;\n\t\t\t\ta[j+k]=(1ll*x*(type==1?1:inv))%P,a[j+k+i]=(1ll*y*(type==1?1:inv))%P;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main () {\n\tscanf(\"%d\",&n);\n\tm=(1<<n),inv=(P+1)/2;\n\tfor (int i=0;i<m;i++) {scanf(\"%d\",&a[i]);sum=(sum+a[i])%P;}\n\tfor (int i=1;i<m;i++) {b[i]=P-1;}\n\tb[0]=m-1,sum=qpow(sum,P-2);\n\tfor (int i=0;i<m;i++) {a[i]=(1ll*a[i]*sum)%P;}\n\ta[0]=(a[0]-1+P)%P;\n\tfwt(b,m,1),fwt(a,m,1);\n\tfor (int i=1;i<m;i++) {e[i]=(1ll*b[i]*qpow(a[i],P-2))%P;}\n\tfwt(e,m,-1);\n\tint delt=P-e[0];\n\tfor (int i=0;i<m;i++) {printf(\"%d\\n\",(e[i]+delt)%P);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 18\n#define ll long long\n#define mo 998244353\nll qpow(ll x,int y=mo-2){\n\tll r=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\t\tif (y&1)\n\t\t\tr=r*x%mo;\n\treturn r;\n}\nint n;\nint a[1<<N],p[1<<N],e[1<<N],f[1<<N];\nvoid fwt(int F[]){\n\tfor (int i=1;i<1<<n;i<<=1)\n\t\tfor (int j=0;j<1<<n;j+=i<<1)\n\t\t\tfor (int k=j;k<j+i;++k){\n\t\t\t\tint x=F[k],y=F[k+i];\n\t\t\t\tF[k]=(x+y)%mo;\n\t\t\t\tF[k+i]=(x-y+mo)%mo;\n\t\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tfor (int i=0;i<1<<n;++i)\n\t\tscanf(\"%d\",&a[i]),sum+=a[i];\n\tsum=qpow(sum);\n\tfor (int i=0;i<1<<n;++i)\n\t\tp[i]=a[i]*sum%mo;\n\t\n\tfor (int i=0;i<1<<n;++i)\n\t\tf[i]=-1+mo;\n\t(f[0]+=1<<n)%=mo;\n\tfwt(f);\n\t(p[0]=p[0]-1+mo)%=mo;\n\tfwt(p);\n\t\n\tsum=0;\n\tfor (int i=1;i<1<<n;++i){\n\t\te[i]=(ll)f[i]*qpow(p[i])%mo;\n\t\tsum+=e[i];\n\t}\n\te[0]=(mo-sum%mo)%mo;\n\tfwt(e);\n\tll inv=qpow(1<<n);\n\tfor (int i=0;i<1<<n;++i)\n\t\te[i]=e[i]*inv%mo;\n\tfor (int i=0;i<1<<n;++i)\n\t\tprintf(\"%d\\n\",e[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int N = 18, M = (1 << N) + 5,\n  P = 998244353, I2 = (P + 1) / 2;\n \ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n \nint n, f[M], p[M], s;\n \ninline void FWT(int A[], int o) {\n  for (int i = 1; i < n; i <<= 1)\n    for (int j = 0; j < n; j += i << 1)\n      for (int k = 0; k < i; ++k) {\n        int nx = A[j + k], ny = A[i + j + k];\n        A[j + k] = (nx + ny) % P;\n        A[i + j + k] = (nx - ny + P) % P;\n        if (o == -1) {\n          A[j + k] = 1ll * A[j + k] * I2 % P;\n          A[i + j + k] = 1ll * A[i + j + k] * I2 % P;\n        }\n      }\n}\n \nint main() {\n  scanf(\"%d\", &n); n = 1 << n;\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", p + i), s += p[i];\n  s = fpow(s, P - 2);\n  for (int i = 0; i < n; ++i)\n    p[i] = 1ll * p[i] * s % P;\n  p[0] = (p[0] - 1 + P) % P;\n  for (int i = 0; i < n; ++i)\n    f[i] = P - 1;\n  f[0] += n;\n  FWT(p, 1), FWT(f, 1);\n  for (int i = 0; i < n; ++i)\n    f[i] = 1ll * f[i] * fpow(p[i], P - 2) % P;\n  FWT(f, -1);\n  for (int i = 0; i < n; ++i)\n    printf(\"%d\\n\", (f[i] - f[0] + P) % P);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <set>\n#include <map>\n#include <random>\n#include <bitset>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 1 << 18, MOD = 998244353;\nll x[N], p[N], r[N], pp;\n\nll pw(ll x, ll k) {\n\tll res = 1;\n\tfor (int i = 30; i >= 0; i--) {\n\t\tres = res * res % MOD;\n\t\tif (k & (1 << i))\n\t\t\tres = res * x % MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, sum = 0;\n\tcin >> n;\n\tpp = 1 << n;\n\trep(i, pp) {\n\t\tcin >> p[i];\n\t\tsum += p[i];\n\t}\n\tsum = pw(sum, MOD - 2);\n\trep(i, pp) {\n\t\tp[i] = p[i] * sum % MOD;\n\t\tr[i] = MOD - 1;\n\t}\n\tp[0] = (p[0] + MOD - 1) % MOD;\n\tr[0] = pp - 1;\n\trep(i, n)\n\t\trep(j, pp) {\n\t\t\tif (j & (1 << i))\n\t\t\t\tcontinue;\n\t\t\tint j1 = j | (1 << i);\n\t\t\tp[j] = (p[j] + p[j1]) % MOD;\n\t\t\tp[j1] = (p[j] + (MOD - p[j1]) * 2) % MOD;\n\t\t\tr[j] = (r[j] + r[j1]) % MOD;\n\t\t\tr[j1] = (r[j] + (MOD - r[j1]) * 2) % MOD;\n\t\t}\n\trep(i, pp)\n\t\tx[i] = r[i] * pw(p[i], MOD - 2) % MOD;\n\tll r2 = pw(2, MOD - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\trep(j, pp) {\n\t\t\tif (j & (1 << i))\n\t\t\t\tcontinue;\n\t\t\tint j1 = j | (1 << i);\n\t\t\tx[j] = (x[j] + x[j1]) % MOD * r2 % MOD;\n\t\t\tx[j1] = (x[j] + MOD - x[j1]) % MOD;\n\t\t}\n\tfor (int i = pp - 1; i >= 0; i--)\n\t\tx[i] = (x[i] + MOD - x[0]) % MOD;\n\trep(i, pp)\n\t\tcout << x[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1<<18|3,mo=998244353,inv2=(mo+1)/2;\nint n,a[N],all,g[N],f[N];\nint power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\ninline void fwt(int *a, int n){\n\tfor(int j=2;j<=n;j<<=1)\n\t\tfor(int k=0;k<n;k+=j)rep(i,0,(j>>1)-1){\n\t\t\tint x=a[k+i],y=a[k+i+(j>>1)];\n\t\t\ta[k+i]=x+y<mo?x+y:x+y-mo;a[k+i+(j>>1)]=x-y>=0?x-y:x-y+mo;\n\t\t}\n}\nint main() {\n\tread(n);all=(1<<n)-1;\n\tint tot=0;rep(i,0,all)read(a[i]),tot=(tot+a[i])%mo;\n\ttot=power(tot,mo-2);rep(i,0,all)a[i]=1LL*a[i]*tot%mo;\n\tfwt(a,1<<n);rep(i,0,all)g[i]=power(1-a[i]+mo,mo-2);\n//\trep(i,0,all)printf(\"%d:%d %d\\n\",i,a[i],g[i]);\n\ttot=0;rep(i,0,all)tot=(tot+g[i])%mo;\n\tfwt(g,1<<n);rep(i,0,all)f[i]=1LL*(tot-g[i]+mo)*inv2%mo;\n\trep(i,0,all)f[i]=2LL*f[i]%mo,printf(\"%d\\n\",(f[i]+mo)%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n1\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int mod = 998244353;\n\ninline int add(int a, int b) {\n\ta += b;\n\treturn a >= mod ? a - mod : a;\n}\n\ninline int sub(int a, int b) {\n\ta -= b;\n\treturn a < 0 ? a + mod : a;\n}\n\ninline int mul(int a, int b) { return (LL)a * b % mod; }\n\ninline int ksm(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\t\nconst int inv2 = ksm(2, mod - 2);\n\nint n, s;\n\ninline void FWT(int *t, int n, int type) {\t\n\tfor (int step = 1; step < n; step <<= 1) {\n\t\tfor (int i = 0; i < n; i += step << 1) {\n\t\t\tfor (int j = 0; j < step; ++ j) {\n\t\t\t\tint x = t[i + j], y = t[i + j + step];\n\t\t\t\tt[i + j] = add(x, y), t[i + j + step] = sub(x, y);\n\t\t\t\tif (type == -1) {\n\t\t\t\t\tt[i + j] = mul(t[i + j], inv2);\n\t\t\t\t\tt[i + j + step] = mul(t[i + j + step], inv2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int N = 1 << 18;\nint p[N], a[N];\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < 1 << n; ++ i) read(p[i]), s = add(s, p[i]);\n\ts = ksm(s, mod - 2);\n\tfor (int i = 0; i < 1 << n; ++ i) p[i] = mul(p[i], s);\n\tfor (int i = 1; i < 1 << n; ++ i) a[i] = mod - 1;\n\ta[0] = (1 << n) - 1;\n\tp[0] = sub(p[0], 1); \n\tFWT(a, 1 << n, 1), FWT(p, 1 << n, 1);\n\tfor (int i = 0; i < 1 << n; ++ i) a[i] = mul(a[i], ksm(p[i], mod - 2));\n\tFWT(a, 1 << n, -1);\n\tfor (int i = 0; i < 1 << n; ++ i) {\n\t\tprintf(\"%d\\n\", sub(a[i], a[0]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int P=998244353;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\nint qsm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint n,a[1048576],lim,S,b[1048576];\nvoid FWT(int *a){\n\tfor(int i=1;i<lim;i<<=1)\n\t\tfor(int j=0;j<lim;j+=(i<<1))\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tconst int Ny=a[i+j+k];\n\t\t\t\ta[i+j+k]=sub(a[j+k],Ny);\n\t\t\t\ta[j+k]=add(a[j+k],Ny);\n\t\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tlim=1<<n;\n\tfor(int i=0;i<lim;i++)scanf(\"%d\",a+i),S=add(S,a[i]);\n\tS=qsm(S,P-2);\n\tfor(int i=0;i<lim;i++)a[i]=mul(sub(0,a[i]),S);\n\ta[0]=add(a[0],1);\n\tFWT(a);\n\tfor(int i=0;i<lim;i++)a[i]=qsm(a[i],P-2);\n\ta[0]=0;\n\tFWT(a);\n\tfor(int i=0;i<lim;i++)a[i]=sub(0,a[i]);\n\tfor(int i=0;i<lim;i++)printf(\"%d\\n\",sub(a[i],a[0]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1 << 18, mod = 998244353, i2 = (mod + 1) / 2;\n\ntypedef long long LL;\n\ninline int Pow(int x, int y) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\ninline void FWT(int a[], int len, int type) {\n    for (int mid = 2; mid <= len; mid <<= 1)\n        for (int i = 0; i < len; i += mid)\n            for (int j = i; j < i + (mid >> 1); j++) {\n                int t = a[j]; a[j] = (t + a[j + (mid >> 1)]) % mod, a[j + (mid >> 1)] = (t - a[j + (mid >> 1)] + mod) % mod;\n                if (!type) a[j] = (LL)a[j] * i2 % mod, a[j + (mid >> 1)] = (LL)a[j + (mid >> 1)] * i2 % mod;\n            }\n}\n\nint A[N], B[N];\n\nint main() {\n    int n, sum = 0; scanf(\"%d\", &n), n = 1 << n;\n    for (int i = 0; i < n; i++) scanf(\"%d\", &A[i]), B[i] = mod - 1, sum = (sum + A[i]) % mod;\n    sum = Pow(sum, mod - 2);\n    for (int i = 0; i < n; i++) A[i] = (LL)A[i] * sum % mod;\n    B[0] = n - 1, A[0] = (A[0] + mod - 1) % mod;\n    FWT(A, n, 1), FWT(B, n, 1);\n    for (int i = 0; i < n; i++) B[i] = (LL)B[i] * Pow(A[i], mod - 2) % mod;\n    FWT(B, n, 0);\n    for (int i = 0; i < n; i++) printf(\"%d\\n\", (B[i] - B[0] + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n#define int long long\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;\n            }\n}\n\nvoid IFWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nsigned main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n#define int lld\nint pw(int a,int m,int p){\n    int res=1;\n    while(m)m&1?res=1ll*res*a%p:0,a=1ll*a*a%p,m>>=1;\n    return res;\n}\nconst int N=20,NN=1<<18,P=998244353;\n\nint n,nn;\nint p[NN],s;\nint c[NN];\n\nvoid fwt(int *f,int len){\n    for(int j=1;j<len;j<<=1)\n        for(int i=0;i<len;i+=j<<1)\n            for(int k=i,u,v;k<i+j;k++)\n                u=f[k],v=f[k+j],f[k]=(u+v)%P,f[k+j]=(u-v+P)%P;\n}\nvoid ifwt(int *f,int len){\n    for(int j=1;j<len;j<<=1)\n        for(int i=0;i<len;i+=j<<1)\n            for(int k=i,u,v;k<i+j;k++)\n                u=f[k],v=f[k+j],f[k]=(u+v)%P,f[k+j]=(u-v+P)%P;\n    int ilen=pw(len,P-2,P);\n    FOR(i,0,len-1)f[i]=1ll*f[i]*ilen%P;\n}\nsigned main(){\n    scanf(\"%lld\",&n);\n    nn=1<<n;\n    FOR(i,0,nn-1)scanf(\"%lld\",&p[i]),s=(s+p[i])%P;\n    s=pw(s,P-2,P);\n    FOR(i,0,nn-1)p[i]=1ll*p[i]*s%P;\n    p[0]--;\n    c[0]=nn-1;\n    FOR(i,1,nn-1)c[i]=P-1;\n    fwt(p,nn),fwt(c,nn);\n    FOR(i,0,nn-1)c[i]=1ll*c[i]*pw(p[i],P-2,P)%P;\n    ifwt(c,nn);\n    FOR(i,0,nn-1)printf(\"%lld\\n\",(c[i]-c[0]+P)%P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Unlucky_Glass*/\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=2e3,inf=(1<<29);\n\nint n;\nint siz[N+3],mx[N+3],mn[N+3];\nchar gnu[N+3];\nvector<int> lnk[N+3];\n\nvoid DFS(int u,int fa){\n\tsiz[u]=mx[u]=mn[u]=0;\n\tfor(auto v : lnk[u]){\n\t\tif(v==fa) continue;\n\t\tDFS(v,u);\n\t\tmx[v]+=siz[v];mn[v]+=siz[v];\n\t\tsiz[u]+=siz[v];\n\t\tif(max(mn[u],mn[v])<=min(mx[u],mx[v])) mn[u]=((mn[u]&1)^(mn[v]&1));\n\t\telse mn[u]=max(mn[u],mn[v])-min(mx[u],mx[v]);\n\t\tmx[u]+=mx[v];\n\t}\n\tif(gnu[u]=='1') siz[u]++;\n}\nint main(){\n\tscanf(\"%d%s\",&n,gnu+1);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tlnk[u].push_back(v);\n\t\tlnk[v].push_back(u);\n\t}\n\tint ans=inf;\n\tfor(int i=1;i<=n;i++){\n\t\tDFS(i,0);\n\t\tif(!mn[i]) ans=min(ans,mx[i]/2);\n\t}\n\tif(ans==inf) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=1000005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint X[MAXN],p[MAXN],Y[MAXN],inv,Invlim,Lim,n,sum;\nint upd(int x,int y){ return x+y>=mods?x+y-mods:(x+y<0?x+y+mods:x+y); }\nint quick_pow(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mods;\n\t\tx=1ll*x*x%mods;\n\t}\n\treturn ret;\n}\nvoid Fwt_xor(int *a,int opt)\n{\n\tfor (int l=2;l<=Lim;l<<=1)\n\t\tfor (int i=l>>1,j=0;j<Lim;j+=l)\n\t\t\tfor (int k=j;k<j+i;k++) \n\t\t\t{\n\t\t\t\tint x=a[k],y=a[k+i];\n\t\t\t\ta[k]=upd(x,y),a[k+i]=upd(x,-y);\n\t\t\t}\n\tif (opt!=1) \n\t\tfor (int i=0;i<Lim;i++) a[i]=1ll*a[i]*Invlim%mods;\n}\nint main()\n{\n\tn=read(),Lim=1<<n;\n\tfor (int i=0;i<Lim;i++) sum+=(p[i]=read());\n\tinv=quick_pow(sum,mods-2);\n\tInvlim=quick_pow(Lim,mods-2);\n\tfor (int i=0;i<Lim;i++) \n\t{\n\t\tp[i]=1ll*inv*p[i]%mods;\n\t\tY[i]=mods-1;\n\t}\n\tp[0]=upd(p[0],-1);\n\tY[0]=(1<<n)-1;\n\tFwt_xor(p,1),Fwt_xor(Y,1);\n\tfor (int i=0;i<Lim;i++) X[i]=1ll*Y[i]*quick_pow(p[i],mods-2)%mods;\n\tFwt_xor(X,-1);\n\tfor (int i=0;i<Lim;i++) printf(\"%d\\n\",upd(X[i],-X[0]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=1<<19;\nint n;\nll S,a[maxn],b[maxn],iv2;\nll ksm(ll x,ll y) {\n\tll res=1;\n\twhile (y) {\n\t\tif (y&1) res=res*x%mod;\n\t\tx=x*x%mod; y>>=1;\n\t} return res;\n}\nvoid FWT(ll *a,int flag) {\n\tfor (int i=1;i<n;i*=2)\n\tfor (int j=0;j<n;j+=i*2)\n\tfor (int k=0;k<i;k++) {\n\t\tint x=a[j+k],y=a[i+j+k];\n\t\ta[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;\n\t\tif (flag==-1) a[j+k]=a[j+k]*iv2%mod,a[i+j+k]=a[i+j+k]*iv2%mod;\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tiv2=ksm(2,mod-2);\n\t\n\tread(n); n=1<<n;\n\tfor (int i=0;i<n;i++) read(b[i]),S=(S+b[i])%mod;\n\tS=ksm(S,mod-2);\n\tfor (int i=0;i<n;i++) b[i]=b[i]*S%mod;\n\tb[0]=(b[0]-1+mod)%mod;\n\t\n\ta[0]=n-1;\n\tfor (int i=1;i<n;i++) a[i]=mod-1;\n\t\n\tFWT(a,1);\n\tFWT(b,1);\n\t\n\tint pos=0;\n\tfor (int i=0;i<n;i++) {\n\t\tif (b[i]) a[i]=a[i]*ksm(b[i],mod-2)%mod;\n\t\telse a[i]=0,pos=i;\n\t}\n\tFWT(a,-1);\n\t\n\tll tmp=(mod-a[0])*n%mod;\n\t\n\tFWT(a,1);\n\ta[pos]=tmp;\n\tFWT(a,-1);\n\tfor (int i=0;i<n;i++) printf(\"%lld\\n\",a[i]);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << (x) << endl;\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid wri(ll x){write(x),pc(' ');}\nvoid writeln(ll x){write(x),pc('\\n');}\nconst int maxn = 1e6+233;\nll mod=998244353;\nll qpow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nll inv2=(mod+1)/2;\nint n,m;\nll p[maxn],a[maxn],b[maxn];\nvoid fwt(ll a[]){\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int j=0;j<m;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tll x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)%mod;\n\t\t\t\ta[j+k+i]=(x-y+mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid ifwt(ll a[]){\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int j=0;j<m;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tll x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)*inv2%mod;\n\t\t\t\ta[j+k+i]=(x-y+mod)*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tn = read(),m = 1 << n;\n\tll sum = 0;\n\trep(i,0,m){\n\t\tp[i] = read();\n\t\tsum = (sum + p[i]) % mod;\n\t}sum = qpow(sum,mod-2);\n\ta[0] = m-1;rep(i,1,m) a[i] = mod - 1;\n\trep(i,0,m) b[i] = p[i] * sum % mod;b[0] = (b[0]+mod-1)%mod;\n\tfwt(a);fwt(b);\n\trep(i,0,m) a[i]=1ll*a[i]*qpow(b[i],mod-2)%mod;\n\tifwt(a);\n\trep(i,0,1<<n) writeln((a[i]-a[0]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst int N=300005,mod=998244353;\nint a[N],b[N],g[N],f[N];\nint n;\n\nnamespace{\n\tinline int power(int x,int p){\n\t\tint res=1;\n\t\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\t\tif(p&1)res=(ll)res*x%mod;\n\t\treturn res;\n\t}\n\t#define inv(x) (power(x,mod-2))\n\tinline int fix(int x){\n\t\treturn x>=mod?x-mod:x;\n\t}\n}\n\nvoid fwt(int a[],int b[]){\n\tREP(i,1<<n)b[i]=a[i];\n\tfor(int k=0,d=1;k<n;k++,d<<=1)\n\t\tfor(int i=0;i<(1<<n);i+=d<<1){\n\t\t\tint *l=b+i,*r=b+i+d,x,y;\n\t\t\tfor(int j=0;j<d;j++,l++,r++){\n\t\t\t\tx=*l,y=*r;\n\t\t\t\t*l=fix(x+y);\n\t\t\t\t*r=fix(x+mod-y);\n\t\t\t}\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint s=0;\n\tREP(i,1<<n){\n\t\tscanf(\"%d\",&a[i]);\n\t\ts=fix(s+a[i]);\n\t}\n\ts=inv(s);\n\tREP(i,1<<n)a[i]=(ll)a[i]*s%mod;\n\tfwt(a,b);\n\tREP(i,1<<n)g[i]=inv(b[i]+mod-1);\n\tfwt(g,f);\n\tint t=f[0];\n\tREP(i,1<<n){\n\t\tf[i]=fix(f[i]+mod-t);\n\t\tprintf(\"%d\\n\",f[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=(1<<18)+5;\nconst int mo=998244353;\nint a[N],b[N],c[N],n,S;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nvoid check(int *a,int *b,int *c,int n){\n\tif (n==1){\n\t\tif (!b[0]) c[0]=0;\n\t\telse c[0]=1ll*b[0]*power(a[0],mo-2)%mo;\n\t\treturn;\n\t}\n\tint nn=n/2,x,y;\n\tFor(i,0,nn-1){\n\t\tx=a[i]; y=a[i+nn];\n\t\ta[i]=(x+y)%mo; a[i+nn]=(x+mo-y)%mo;\n\t\tx=b[i]; y=b[i+nn];\n\t\tb[i]=(x+y)%mo; b[i+nn]=(x+mo-y)%mo;\n\t}\n\tcheck(a,b,c,nn);\n\tcheck(a+nn,b+nn,c+nn,nn);\n\tFor(i,0,nn-1){\n\t\tx=c[i],y=c[i+nn];\n\t\tc[i]=1ll*(x+y)*(mo+1)/2%mo;\n\t\tc[i+nn]=1ll*(x+mo-y)*(mo+1)/2%mo;\n\t}\n}\n/*\n3 -1 -1 -1\n2 -2 4 0\n0 4 4 4\n*/\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,0,(1<<n)-1){\n\t\tscanf(\"%d\",&a[i]);\n\t\tS+=a[i];\n\t}\n\tS=power(S,mo-2);\n\tFor(i,0,(1<<n)-1) a[i]=1ll*a[i]*S%mo;\n\tFor(i,0,(1<<n)-1) printf(\"%d \",a[i]); puts(\"\");\n\tFor(i,0,(1<<n)-1) b[i]=mo-1;\n\ta[0]=(a[0]+mo-1)%mo;\n\tb[0]=(1<<n)-1;\n\tcheck(a,b,c,(1<<n));\n\tint dif=(mo-c[0])%mo;\n\tFor(i,0,(1<<n)-1) c[i]=(c[i]+dif)%mo;\n\tFor(i,0,(1<<n)-1) printf(\"%d\\n\",c[i]);\n}\n/*\n(x0,x1,x2,x3)opt(p0,p1,p2,p3)=(x0+2^n-1,x1-1,x2-1,x3-1)\n(x0,x1,x2,x3)opt(p0-1,p1,p2,p3)=(2^n-1,-1,-1,-1)\n*/"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nvoid fwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD, f[j | i] = (x+MOD - y)%MOD;\n            }\n        }\n    }\n}\ntemplate <typename T>\nvoid ifwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD * INV2%MOD, f[j | i] = (x+MOD - y)%MOD*INV2%MOD;\n            }\n        }\n    }\n}\n\n     signed main(){\n\n  int n;\n  cin>>n;\n vector<int> a(1ll<<n),b(1ll<<n,1),c(1ll<<n,0);\n  for(int i=0;i<(1ll<<n);i++)cin>>a[i];\n c[0]=1;\n int al=0;\n for(int i=0;i<(1ll<<n);i++)al=(al+a[i])%MOD;\n al=modpow(al,MOD-2,MOD);\n for(int i=0;i<(1ll<<n);i++)a[i]=(a[i]*al)%MOD;\n  fwt(a);fwt(b);fwt(c);\n   //  for(int i=0;i<(1ll<<n);i++)cerr<<a[i]<<' '<<b[i]<<' '<<c[i]<<endl;\n     if(a[0]!=1){\n    \n  for(int i=0;i<(1ll<<n);i++)b[i]=(b[i]*modpow((1+MOD-a[i])%MOD,MOD-2,MOD))%MOD;\n    for(int i=0;i<(1ll<<n);i++)c[i]=(c[i]*modpow((1+MOD-a[i])%MOD,MOD-2,MOD))%MOD;\n    //  for(int i=0;i<(1ll<<n);i++)cerr<<b[i]<<' '<<c[i]<<endl;\n    ifwt(b),ifwt(c);\n    int t=b[0]*modpow(c[0],MOD-2,MOD)%MOD;\n\n    for(int i=0;i<(1ll<<n);i++)cout<<(b[i]+MOD-c[i]*t%MOD)%MOD<<endl;\n     }else{\n     c[0]=0;\n       for(int i=1;i<(1ll<<n);i++){\n         c[i]=(MOD - (1ll<<n)%MOD*modpow((1+MOD-a[i])%MOD,MOD-2,MOD)%MOD);\n         c[0]=(c[0]+MOD-c[i])%MOD;\n       }\n       // for(int i=0;i<(1ll<<n);i++)cout<<c[i]<<endl;\n       ifwt(c);\n       for(int i=0;i<(1ll<<n);i++)cout<<c[i]<<endl;\n     }\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst ll inv=(mod+1)/2;\n\nint n, m;\n\nll dziel(ll a, ll b)\n{\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nvll raz(vll wek)\n{\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tif (!(j&(1<<i)))\n\t\t\t{\n\t\t\t\tll a=wek[j];\n\t\t\t\tll b=wek[j^(1<<i)];\n\t\t\t\twek[j]=(a+b)%mod;\n\t\t\t\twek[j^(1<<i)]=(a-b+mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn wek;\n}\n\nvll dwa(vll wek)\n{\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tif (!(j&(1<<i)))\n\t\t\t{\n\t\t\t\tll a=wek[j];\n\t\t\t\tll b=wek[j^(1<<i)];\n\t\t\t\twek[j]=(a+b)%mod;\n\t\t\t\twek[j^(1<<i)]=(a-b+mod)%mod;\n\t\t\t\twek[j]=(wek[j]*inv)%mod;\n\t\t\t\twek[j^(1<<i)]=(wek[j^(1<<i)]*inv)%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn wek;\n}\n\nvll mno(vll a, vll b)\n{\n\tfor (int i=0; i<m; i++)\n\t\ta[i]=(a[i]*b[i])%mod;\n\treturn a;\n}\n\nvll dziel(vll a, vll b)\n{\n\tfor (int i=0; i<m; i++)\n\t\ta[i]=dziel(a[i], b[i])%mod;\n\treturn a;\n}\n\nvll dod(vll a, vll b)\n{\n\tfor (int i=0; i<m; i++)\n\t\ta[i]=(a[i]+b[i])%mod;\n\treturn a;\n}\n\nvll odj(vll a, vll b)\n{\n\tfor (int i=0; i<m; i++)\n\t\ta[i]=(a[i]-b[i]+mod)%mod;\n\treturn a;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tm=(1<<n);\n\tvll in(m);\n\tll s=0;\n\tfor (ll &i : in)\n\t{\n\t\tscanf(\"%lld\", &i);\n\t\ts+=i;\n\t}\n\tfor (ll &i : in)\n\t\ti=dziel(i, s);\n\tin[0]=(in[0]-1+mod)%mod;\n\tvll trz(m);\n\ttrz[0]=m;\n\tfor (ll &i : trz)\n\t\ti=(i-1+mod)%mod;\n\t\n\tvll wez=dwa(dziel(raz(trz), raz(in)));\n\tfor (int i=0; i<m; i++)\n\t\tprintf(\"%lld\\n\", (wez[i]-wez[0]+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\n\ninline int read(){\n\tchar c=getchar(); int x=0,ft=1;\n\tfor(;c<'0'||c>'9';c=getchar()) if(c=='-') ft=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) x=x*10+c-'0';\n\treturn x*ft;\n}\n\nconst int mod=998244353;\n\ninline int fpow(int x,int k){\n\tint res=1;\n\tfor(;k;k>>=1,x=(ll)x*x%mod) if(k&1) res=(ll)res*x%mod;\n\treturn res;\n}\n\nconst int N=(1<<18)+10;\n\nint m,n,a[N],b[N],c[N];\n\nvoid fwt(int *a,int op){\n\tfor(int i=1;i<n;i<<=1){\n\t\tfor(int j=0,len=i<<1;j<n;j+=len){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint p=a[j+k],q=a[j+i+k];\n\t\t\t\ta[j+k]=(p+q)%mod; a[j+i+k]=(p+mod-q)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(op==-1){\n\t\tint inv_n=fpow(n,mod-2);\n\t\tfor(int i=0;i<n;++i) a[i]=(ll)a[i]*inv_n%mod;\n\t}\n}\n\nint main(){\n\tm=read(); n=1<<m; int sum=0;\n\tfor(int i=0;i<n;++i) sum+=(a[i]=read());\n\tsum=fpow(sum,mod-2);\n\tfor(int i=0;i<n;++i) a[i]=(ll)a[i]*sum%mod;\n\ta[0]=(a[0]+mod-1)%mod;\n\tfwt(a,1);\n\tb[0]=n-1; for(int i=1;i<n;++i) b[i]=mod-1;\n\tfwt(b,1);\n\tfor(int i=1;i<n;++i) c[i]=(ll)b[i]*fpow(a[i],mod-2)%mod;\n\tfwt(c,-1);\n\tint tmp=c[0];\n\tfor(int i=0;i<n;++i) c[i]=(c[i]+mod-tmp)%mod;\n\tfor(int i=0;i<n;++i) printf(\"%d\\n\",c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1<<18|3,mo=998244353,inv2=(mo+1)/2;\nint n,a[N],all,g[N],f[N];\nint power(int a, int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1)res=1LL*res*a%mo;a=1LL*a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\ninline void fwt(int *a, int n){\n\tfor(int j=2;j<=n;j<<=1)\n\t\tfor(int k=0;k<n;k+=j)rep(i,0,(j>>1)-1){\n\t\t\tint x=a[k+i],y=a[k+i+(j>>1)];\n\t\t\ta[k+i]=x+y<mo?x+y:x+y-mo;a[k+i+(j>>1)]=x-y>=0?x-y:x-y+mo;\n\t\t}\n}\ninline void ifwt(int *a, int n){\n\tfwt(a,n);int ni=power(n,mo-2);\n\trep(i,0,n-1)a[i]=1LL*a[i]*ni%mo;\n}\nint main() {\n\tread(n);all=(1<<n)-1;\n\tint tot=0;rep(i,0,all)read(a[i]),tot=(tot+a[i])%mo;\n\ttot=power(tot,mo-2);rep(i,0,all)a[i]=1LL*a[i]*tot%mo;\n\trep(i,0,all)a[i]=mo-a[i];a[0]++;\n\trep(i,0,all)g[i]=1;g[0]=(g[0]-(1<<n)+mo)%mo;\n\tfwt(g,1<<n);fwt(a,1<<n);\n//\trep(i,0,all)printf(\"%d:%d %d\\n\",i,g[i],a[i]);\n\trep(i,0,all)g[i]=1LL*g[i]*power(a[i],mo-2)%mo;\n\tg[0]=0;rep(i,1,all)g[0]=(g[0]-g[i]+mo)%mo;\n\tifwt(g,1<<n);\n\trep(i,0,all)printf(\"%d\\n\",(g[i]+mo)%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=(1<<19),p=998244353,q=(p+1)/2;\nint n,l,w[N],f[N];\ninline int read(){\n\tint num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n\twhile(47<g&&g<58) num=(num<<1)+(num<<3)+g-48,g=getchar(); return num;\n}\ninline long long pows(long long u,int v){\n\tlong long ans=1; while(v>0) {if(v&1) ans=ans*u%p; u=u*u%p,v=v>>1;} return ans;\n}\ninline void fwt(int *s){\n\tfor(int d=1;d<l;d=d<<1)\n\t\tfor(int i=0,r=d<<1;i<l;i=i+r)\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tint a=s[i+j],b=s[i+j+d];\n\t\t\t\ts[i+j]=(a+b)%p,s[i+j+d]=(a-b+p)%p;\n\t\t\t}\n}\nint main(){\n\tn=read(),l=(1<<n); int cnt=0;\n\tfor(int i=0;i<l;i++) w[i]=read(),cnt+=w[i];\n\tfor(int i=0;i<l;i++) w[i]=w[i]*pows(cnt,p-2)%p; fwt(w),w[0]=0;\n\tfor(int i=1;i<l;i++) w[i]=pows(w[i]-1,p-2); fwt(w);\n\tfor(int i=0;i<l;i++) printf(\"%d\\n\",(w[i]-w[0]+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=18,p=998244353,inv2=(p+1)/2;\nint read(){\n    int f=1,g=0;char ch=getchar();\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n    for (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n    return f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,L,s,a[1<<N],b[1<<N],g[1<<N];\ninline int pl(int x,int y){return (x+y<p) ? (x+y) : (x+y-p);}\nvoid FWT(int *a,int L,int typ){\n\tfor (int k=1;k<L;k<<=1)\n\tfor (int i=0;i<L;i+=k*2)\n\tfor (int j=0;j<k;j++){\n\t\tint x=a[i+j],y=a[i+j+k];\n\t\ta[i+j]=pl(x,y);a[i+j+k]=pl(x,p-y);\n\t}\n\tif (typ==1){\n\t\tint R=qpow(L,p-2);\n\t\tfor (int i=0;i<L;i++) a[i]=(ll)a[i]*R%p;\n\t}\n}\nint main(){\n\tn=read();L=1<<n;\n\tfor (int i=0;i<L;i++)\n\t\ta[i]=read(),s+=a[i];\n\ts=qpow(s,p-2);\n\tfor (int i=0;i<=L;i++) a[i]=(ll)a[i]*s%p,b[i]=(i==0) ? (L-1) : (p-1);\n\ta[0]-=1;\n\tFWT(a,L,0);FWT(b,L,0);\n\tint pos=0;\n\tfor (int i=0;i<L;i++)\n\tif (!a[i]) pos=i;\n\telse a[i]=(ll)b[i]*qpow(a[i],p-2)%p;\n\tFWT(a,L,1);\n\tint val=(ll)(p-a[0])*L%p;\n\tFWT(a,L,0);\n\ta[pos]=val;\n\tFWT(a,L,1);\n\tfor (int i=0;i<L;i++) printf(\"%d\\n\",a[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint M(int x) { return x >= mod ? x - mod : x; }\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\nint n, len, sp;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t + mod), Add(x[j], t);\n    }\n    void ifwt(int len) {\n        fwt(len);\n        int ny = fsp(len, mod - 2);\n        for (int i = 0; i < len; ++i) x[i] = 1ll * x[i] * ny % mod;\n    }\n} E, P, S;\n\nint main() {\n    n = read(), len = 1 << n;\n    for (int i = 0; i < len; ++i) sp += (P[i] = read());\n    sp = fsp(sp, mod - 2);\n    for (int i = 0; i < len; ++i) P[i] = 1ll * P[i] * sp % mod;\n    (--P[0]) < 0 ? P[0] += mod : 0, S[0] = len - 1;\n    for (int i = 1; i < len; ++i) S[i] = mod - 1;\n    P.fwt(len), S.fwt(len);\n    for (int i = 1; i < len; ++i) E[i] = 1ll * S[i] * fsp(P[i], mod - 2) % mod;\n    E.ifwt(len);\n    int x = mod - E[0];\n    for (int i = 0; i < len; ++i) printf(\"%d\\n\", M(x + E[i]));\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nstruct Hadamard{\n\tvoid TF(vector<long long>&a){\n\t\tint n=a.size();\n\t\tfor(int i=1;i<n;i=i+i){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((j&i)==0){\n\t\t\t\t\tlong long x=a[j];\n\t\t\t\t\tlong long y=a[j|i];\n\t\t\t\t\ta[j]=(x+y)%mod;\n\t\t\t\t\ta[j|i]=(x+mod-y)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid UTF(vector<long long>&a){\n\t\tint n=a.size();\n\t\tfor(int i=1;i<n;i=i+i){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((j&i)==0){\n\t\t\t\t\tlong long x=a[j];\n\t\t\t\t\tlong long y=a[j|i];\n\t\t\t\t\ta[j]=(x+y)*d2%mod;\n\t\t\t\t\ta[j|i]=(x+mod-y)*d2%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nlong long p[1<<18];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tlong long S=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tscanf(\"%lld\",p+i);\n\t\tS+=p[i];\n\t}\n\tlong long IS=pw(S,mod-2);\n\tfor(int i=0;i<(1<<a);i++){\n\t\tp[i]=p[i]*IS%mod;\n\t\tif(i==0)p[i]=(p[i]+mod-1)%mod;\n\t}\n\tvector<long long>A;\n\tvector<long long>Y;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tA.push_back(p[i]);\n\t\tif(i==0)Y.push_back((1<<a)-1);\n\t\telse Y.push_back(mod-1);\n\t}\n\tHadamard hm;\n\thm.TF(A);\n\thm.TF(Y);\n\tvector<long long>X;\n\tfor(int i=0;i<A.size();i++){\n\t\tX.push_back(Y[i]*pw(A[i],mod-2)%mod);\n\t}\n\n\thm.UTF(X);\n\tfor(int i=0;i<X.size();i++)printf(\"%lld\\n\",(X[i]+mod-X[0])%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <ctime>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 998244353 //1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n\n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 1<<18\n\ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n\n//FILE* outFile;\n\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\ninline int gcd(int a, int b){if(b == 0)return a; return gcd(b, a%b);}\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nint a[N], b[N], c[N];\nvoid dwt(int a[], int l, int r){\n    if(l+1 >= r)return;\n    int m = (l+r) >> 1;\n    dwt(a, l, m);\n    dwt(a, m, r);\n    int n = (r - l) >> 1;\n    rep(i, 0, n){\n        int u = (a[l + i] + a[m + i]) % mod;\n        int v = (a[l + i] - a[m + i] + mod) % mod;\n        a[l + i] = u;\n        a[m + i] = v;\n    }\n}\nconst ll inv2 = (mod + 1) / 2;\nvoid idwt(int a[], int l, int r){\n    if(l+1 >= r)return;\n    int m = (l+r) >> 1;\n    idwt(a, l, m);\n    idwt(a, m, r);\n    int n = (r - l) >> 1;\n    rep(i, 0, n){\n        int u = (a[l + i] + a[m + i]) * inv2 % mod;\n        int v = (a[l + i] - a[m + i] + mod) * inv2 % mod;\n        a[l + i] = u;\n        a[m + i] = v;\n    }\n}\n\nint main(){\n    int j,k,i,T,ca=0, n, m, K = 0;\n    scanf(\"%d\", &n);\n    m = (1<<n);\n    int s = 0;\n    rep(i, 0, m)scanf(\"%d\", &a[i]), add(s, a[i]);   \n    s = pow(s, mod-2);\n    rep(i, 0, m)a[i] = 1LL * a[i] * s % mod;\n    dwt(a, 0, m);\n    rep(i, 1, m)b[i] = mod - 1;\n    b[0] = m - 1;\n    dwt(b, 0, m);\n    rep(i, 1, m){\n        c[i] = 1LL * b[i] * pow(a[i] - 1, mod - 2) % mod;\n    }\n    idwt(c, 0, m);\n    printf(\"0\\n\");\n    rep(i, 1, m){\n        c[i] = (c[i] - c[0] + mod) % mod;\n        printf(\"%d\\n\", c[i]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst i64 MOD = 998244353;\nconst i64 Inv2 = -MOD / 2;\n\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1)\n\t\tif (k & 1) t = t * a % MOD;\n\treturn t;\n}\n\nconst int N = 1 << 18 | 7;\n\nint n;\ni64 p[N], s, q[N];\n\nvoid fwt_xor(i64 f[], int n, int on) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 1 << n; ++j)\n\t\t\tif (j >> i & 1)\n\t\t\t\t( f[j ^ 1 << i] += f[j] ) %= MOD, ( f[j] = f[j ^ 1 << i] - 2 * f[j] ) %= MOD;\n\t\tif (on == 1) continue;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\t( f[i] *= Inv2 ) %= MOD;\n\t}\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tscanf(\"%lld\", p + i), s += p[i];\n\ts = pow(s, MOD - 2);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tp[i] = p[i] * s % MOD;\n\t--p[0];\n\tstd::fill(q, q + (1 << n), -1);\n\tq[0] += 1 << n;\n\n\tfwt_xor(p, n, 1), fwt_xor(q, n, 1);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tq[i] = q[i] * pow(p[i], MOD - 2) % MOD;\n\tfwt_xor(q, n, -1);\n\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tprintf(\"%lld\\n\", (q[i] - q[0] + MOD * 2) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n\tx %= p;\n\tll ans = 1;\n\twhile(y) {\n\t\tif(y & 1) ans = ans * x % p;\n\t\tx = x * x % p;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nll A[1 << 18];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tll tot = 0;\n\tfor(int i = 0; i < (1 << n); i++) scanf(\"%lld\", &A[i]), tot += A[i];\n\tll rtot = powmod(tot);\n\tfor(int i = 0; i < (1 << n); i++) A[i] = A[i] * rtot % P;\n\tfor(int i = 1; i < (1 << n); i *= 2)\n\t\tfor(int j = 0; j < (1 << n); j += i + i)\n\t\t\tfor(int k = 0; k < i; k++) {\n\t\t\t\tll a = A[j + k], b = A[j + i + k];\n\t\t\t\tA[j + k] = (a + b) % P;\n\t\t\t\tA[j + i + k] = (a - b) % P;\n\t\t\t}\n\tfor(int i = 0; i < (1 << n); i++) A[i] = powmod(1 - A[i]);\n\tfor(int i = 1; i < (1 << n); i *= 2)\n\t\tfor(int j = 0; j < (1 << n); j += i + i)\n\t\t\tfor(int k = 0; k < i; k++) {\n\t\t\t\tll a = A[j + k], b = A[j + i + k];\n\t\t\t\tA[j + k] = (a + b) % P;\n\t\t\t\tA[j + i + k] = (a - b) % P;\n\t\t\t}\n\tfor(int i = 0; i < (1 << n); i++) printf(\"%lld\\n\", ((A[0] - A[i]) % P + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 1 << 18 ; \nconst int P = 998244353 ; \nconst int I = 499122177 ;\nint n, limit, A[N] ; \nint fpow( int x, int k ) {\n\tint ans = 1, base = x ; \n\twhile(k) {\n\t\tif( k & 1 ) ans = ans * base % P ; \n\t\tbase = base * base % P, k >>= 1 ;  \n\t} return ans ; \n}\nvoid FWT( int *a ) {\n\tfor( re int k = 1; k < limit; k <<= 1 ) \n\tfor( re int i = 0; i < limit; i += ( k << 1 ) )\n\tfor( re int j = i; j < i + k; ++ j )  {\n\t\tint nx = a[j], ny = a[j + k] ;\n\t\ta[j] = ( nx + ny ) % P, a[j + k] = ( nx - ny + P ) % P ; \n\t}\n}\nvoid IFWT( int *a ) {\n\tfor( re int k = 1; k < limit; k <<= 1 ) \n\tfor( re int i = 0; i < limit; i += ( k << 1 ) )\n\tfor( re int j = i; j < i + k; ++ j )  {\n\t\tint nx = a[j], ny = a[j + k] ;\n\t\ta[j] = ( nx + ny ) * I % P, a[j + k] = ( nx - ny + P ) * I % P ; \n\t}\n}\nsigned main()\n{\n\tn = gi(), limit = ( 1 << n ) ; int S = 0 ;\n\trep( i, 1, limit ) A[i - 1] = gi(), S += A[i - 1] ; \n\tS = fpow( S, P - 2 ) ;\n\trep( i, 1, limit ) A[i - 1] = A[i - 1] * S % P ; \n\tFWT( A ), A[0] = 0 ; \n\tfor( re int i = 1; i < limit; ++ i ) \n\t\tA[i] = ( P - limit ) * fpow( 1 - A[i] + P, P - 2 ) % P,\n\t\tA[0] = ( A[0] + P - A[i] ) % P ; \n\tIFWT( A ) ;\n\trep( i, 1, limit ) printf(\"%lld\\n\", A[i - 1] % P ) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 << 18;\nconst int P = 998244353;\nconst int inv2 = (P + 1) / 2;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nvoid FWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = tmp, a[k] = tnp;\n\t}\n}\nvoid UFWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = 1ll * tmp * inv2 % P, a[k] = 1ll * tnp * inv2 % P;\n\t}\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint n, goal, p[MAXN], q[MAXN], res[MAXN];\nint main() {\n\tread(n), goal = 1 << n;\n\tint sum = 0;\n\tfor (int i = 0; i < goal; i++)\n\t\tread(p[i]), sum += p[i];\n\tsum = power(sum, P - 2);\n\tfor (int i = 0; i < goal; i++) {\n\t\tp[i] = 1ll * p[i] * sum % P;\n\t\tq[i] = P - 1;\n\t}\n\tp[0] -= 1;\n\tq[0] = goal - 1;\n\tFWT(p, goal);\n\tFWT(q, goal);\n\tfor (int i = 1; i < goal; i++)\n\t\tres[i] = 1ll * q[i] * power(p[i], P - 2) % P;\n\tUFWT(res, goal);\n\tfor (int i = 0; i < goal; i++)\n\t\twriteln((res[i] - res[0] + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 3e5 + 5, mod = 998244353;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, len, sp;\nint ksm(int x, int y) {\n\tint res = 1;\n\tfor( ; y; x = x * x % mod, y >>= 1) {\n\t\tif(y & 1) res = res * x % mod;\n\t}\n\treturn res;\n}\nstruct poly {\n\tint v[N];\n\tint & operator [] (int x) {return v[x];}\n\tvoid fwt(int len) {\n\t\tfor(int l = 2; l <= len; l <<= 1)\n\t\t\tfor(int i = 0, m = l >> 1; i < len; i += l)\n\t\t\t\tfor(int j = i, t; j < i + m; ++ j) \n\t\t\t\t\tt = v[j + m], v[j + m] = (v[j] - t + mod) % mod, v[j] = (v[j] + t) % mod;\n\t}\n\tvoid ifwt(int len) {\n\t\tfwt(len);\n\t\tint inv = ksm(len, mod - 2);\n\t\tfor(int i = 0; i < len; ++ i) v[i] = v[i] * inv % mod;\n\t}\n} e, p, s;\nsigned main() {\n\tn = read(); len = 1 << n;\n\tfor(int i = 0; i < len; ++ i) sp += (p[i] = read());\n\tsp = ksm(sp, mod - 2);\n\tfor(int i = 0; i < len; ++ i) p[i] = p[i] * sp % mod;\n\tp[0] --;\n\tif(p[0] < 0) p[0] += mod;\n\ts[0] = len - 1;\n\tfor(int i = 1; i < len; ++ i) s[i] = mod - 1;\n\tp.fwt(len); s.fwt(len);\n\tfor(int i = 1; i < len; ++ i) e[i] = s[i] * ksm(p[i], mod - 2) % mod;\n\te.ifwt(len);\n\tint x = mod - e[0];\n\tfor(int i = 0; i < len; ++ i) printf(\"%lld\\n\", (x + e[i]) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int N = 18, M = (1 << N) + 5,\n  P = 998244353, I2 = (P + 1) / 2;\n \ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n \nint n, f[M], p[M], s;\n \ninline void FWT(int A[], int o) {\n  for (int i = 1; i < n; i <<= 1)\n    for (int j = 0; j < n; j += i << 1)\n      for (int k = 0; k < i; ++k) {\n        int nx = A[j + k], ny = A[i + j + k];\n        A[j + k] = (nx + ny) % P;\n        A[i + j + k] = (nx - ny + P) % P;\n        if (o == -1) {\n          A[j + k] = 1ll * A[j + k] * I2 % P;\n          A[i + j + k] = 1ll * A[i + j + k] * I2 % P;\n        }\n      }\n}\n \nint main() {\n  scanf(\"%d\", &n); n = 1 << n;\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", p + i), s += p[i];\n  s = fpow(s, P - 2);\n  for (int i = 0; i < n; ++i)\n    p[i] = 1ll * p[i] * s % P;\n  p[0] = (p[0] - 1 + P) % P;\n  for (int i = 0; i < n; ++i)\n    f[i] = P - 1;\n  f[0] += n;\n  FWT(p, 1), FWT(f, 1);\n  for (int i = 0; i < n; ++i)\n    f[i] = 1ll * f[i] * fpow(p[i], P - 2) % P;\n  FWT(f, -1);\n  for (int i = 0; i < n; ++i)\n    printf(\"%d\\n\", (f[i] - f[0] + P) % P);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define mod 998244353\n#define inv2 499122177\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint Add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t\tc -= mod;\n\treturn c;\n}\nint Sub(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += mod;\n\treturn c;\n}\nint Pow(int a, int k)\n{\n\tif (!k)\n\t\treturn 1;\n\tint p = Pow(a, k / 2);\n\tif (k & 1)\n\t\treturn (ll)p * p % mod * a % mod;\n\treturn (ll)p * p % mod;\n}\nint A[1 << 18], B[1 << 18], C[1 << 18], D[1 << 18];\nint n, s;\nvoid FWT(int *A, int w)\n{\n\tif (w == 1)\n\t\treturn;\n\tFWT(A, w >> 1);\n\tFWT(A + (w >> 1), w >> 1);\n\tfor (int i = 0; i < (w >> 1); i++)\n\t{\n\t\tint x = A[i], y = A[i + (w >> 1)];\n\t\tA[i] = Add(x, y);\n\t\tA[i + (w >> 1)] = Sub(x, y);\n\t}\n}\nvoid IFWT(int *A, int w)\n{\n\tif (w == 1)\n\t\treturn;\n\tIFWT(A, w >> 1);\n\tIFWT(A + (w >> 1), w >> 1);\n\tfor (int i = 0; i < (w >> 1); i++)\n\t{\n\t\tint x = A[i], y = A[i + (w >> 1)];\n\t\tA[i] = (ll)Add(x, y) * inv2 % mod;\n\t\tA[i + (w >> 1)] = (ll)Sub(x, y) * inv2 % mod;\n\t}\n}\nint main()\n{\n\tRead(n);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tRead(D[i]), s = Add(s, D[i]);\n\ts = Pow(s, mod - 2);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tA[i] = D[i] = (ll)D[i] * s % mod;\n\tB[0] = (1 << n) - 1;\n\tfor (int i = 1; i < (1 << n); i++)\n\t\tB[i] = mod - 1;\n\tA[0] = Sub(A[0], 1);\n\tFWT(A, 1 << n);\n\tFWT(B, 1 << n);\n\tint x = 0, p = 0;\n\tfor (int i = 0; i < (1 << n); i++)\n\t{\n\t\tif (A[i] == 0)\n\t\t\tx = i;\n\t\tC[i] = (ll)Pow(A[i], mod - 2) * B[i] % mod;\n\t}\n\tIFWT(C, 1 << n);\n\tp = (ll)Sub(0, C[0]) * (1 << n) % mod;\n\tFWT(C, 1 << n);\n\tC[x] = p;\n\tIFWT(C, 1 << n);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tprintf(\"%d\\n\", C[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=18,M=998244353;\nusing namespace std;\nint n,l,a[N],b[N],t0,t1,sum;\ninline int inv(int x){\n\tint y=1,t=M-2;\n\tfor(;t;t>>=1)\n\tt&1?y=1ll*y*x%M:0,x=1ll*x*x%M;\n\treturn y;\n}\ninline void fwt(int*c,int t){\n\tfor(int i=1;i<l;i<<=1)\n\tfor(int j=0;j<l;j++)\n\tif(j&i)\n\tt0=(c[j^i]+c[j])%M,t1=(c[j^i]-c[j])%M,\n\tc[j]=t1*1ll*t%M,c[j^i]=t0*1ll*t%M;\n}\nint main(){\n\tscanf(\"%d\",&n),b[0]=l=1<<n;\n\tfor(int i=0;i<l;i++)\n\tscanf(\"%d\",a+i),sum=(sum+a[i])%M,b[i]--;\n\tsum=inv(sum);\n\tfor(int i=0;i<l;i++)\n\ta[i]=1ll*a[i]*sum%M;\n\ta[0]--;/*\n\tfor(int i=0;i<l;i++)\n\tcerr<<a[i]<<' ';cerr<<endl;*/\n\tfwt(a,1),fwt(b,1);/*\n\tfor(int i=0;i<l;i++)\n\tcerr<<a[i]<<' ';cerr<<endl;\n\tfor(int i=0;i<l;i++)\n\tcerr<<b[i]<<' ';cerr<<endl;*/\n\tfor(int i=1;i<l;i++)\n\ta[i]=b[i]=1ll*b[i]*inv(a[i])%M;\n\tfwt(a,M+1>>1);\n\tb[0]=-a[0]*1ll*l%M;\n\tfwt(b,M+1>>1);\n\tfor(int i=0;i<l;i++)\n\tprintf(\"%d\\n\",(b[i]+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353,M=(1<<18)+10;\nll ksm(ll x,ll k){ll re=1;for(;k;k>>=1,x=x*x%mod)if(k&1)re=re*x%mod;return re;}\nint pls(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint mns(int x,int y){return x-y<0?x-y+mod:x-y;}\n\n\nint n,p[M],bin[20];ll s,x,y;ll inv2=ksm(2,mod-2);\nvoid fwt(int *a){\n\tfor(int i=1;i<bin[n];i<<=1)\n\t\tfor(int j=0;j<bin[n];j+=2*i)\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tx=a[j+k];y=a[j+k+i];a[j+k]=pls(x,y);a[j+k+i]=mns(x,y);\n\t\t\t}\n}\nvoid ifwt(int *a){\n\tfor(int i=1;i<bin[n];i<<=1)\n\t\tfor(int j=0;j<bin[n];j+=2*i)\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tx=a[j+k];y=a[j+k+i];a[j+k]=pls(x,y)*inv2%mod;a[j+k+i]=mns(x,y)*inv2%mod;\n\t\t\t}\n}\nint A[M];\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tbin[0]=1;for(int i=1;i<=n;i++)bin[i]=bin[i-1]<<1;\n\tfor(int i=0;i<bin[n];i++)scanf(\"%d\",&p[i]),s=pls(s,p[i]);s=ksm(s,mod-2);\n\tfor(int i=0;i<bin[n];i++)p[i]=p[i]*s%mod;\n\tA[0]=bin[n]-1;for(int i=1;i<bin[n];i++)A[i]=mod-1;\n\tfwt(A);p[0]=mns(p[0],1);\n\tfwt(p);\n\tfor(int i=0;i<bin[n];i++)A[i]=A[i]*ksm(p[i],mod-2)%mod;\n\tifwt(A);\n\tfor(int i=0;i<bin[n];i++)printf(\"%d\\n\",(A[i]-A[0]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;\n            }\n}\n\nvoid IFWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nlong long sum=0;\nconst int mod=998244353;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nint n,sta;\nlong long a[1<<18],p[1<<18],f[1<<18];\nvoid FWT(long long a[],int n,int ty)\n{\n\tfor(int i=1;i<n;i<<=1)\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tif(j&i)\n\t\t{\n\t\t\tlong long t0=a[j-i],t1=a[j];\n\t\t\ta[j-i]=(t0+t1)%mod;a[j]=(t0-t1+mod)%mod;\n\t\t}\n\t}\n\tif(ty==-1)\n\t{\n\t\tlong long rev=ksm(n,mod-2);\n\t\tfor(int i=0;i<n;i++) a[i]=a[i]*rev%mod;\n\t}\n}\nint main()\n{\n\tn=read();sta=1<<n;\n\tfor(int i=0;i<sta;i++) a[i]=p[i]=read(),sum=(sum+p[i])%mod;\n\tsum=ksm(sum,mod-2);\n\tfor(int i=0;i<sta;i++) p[i]=p[i]*sum%mod;\n\tFWT(p,sta,1);\n\tfor(int i=1;i<sta;i++) f[i]=-sta*ksm(1-p[i],mod-2)%mod;\n\tFWT(f,sta,-1);\n\tfor(int i=0;i<sta;i++) printf(\"%lld\\n\",(f[i]-f[0]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT x=0,f=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=(1<<18)+9,mod=998244353,inv2=(mod+1)/2;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*ret*x%mod;\n\t\t\tx=1LL*x*x%mod;y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\tint limit,bit;\n\tinline void fwt(int *a,int inv){\n\t\tfor(int mid=1;mid<limit;mid<<=1)\n\t\t\tfor(int i=0,R=mid<<1;i<limit;i+=R)\n\t\t\t\tfor(int j=0;j<mid;j++){\n\t\t\t\t\tint x=1LL*a[i+j]*(~inv?1:inv2)%mod,y=1LL*a[i+j+mid]*(~inv?1:inv2)%mod;\n\t\t\t\t\ta[i+j]=add(x,y),a[i+j+mid]=sub(x,y);\n\t\t\t\t}\n\t}\n\n\tint n,a[N],f[N];\n\tint main(){\n\t\tn=read<int>(),bit=n,limit=1<<n;\n\n\t\tint sum=0;\n\t\tfor(int i=0;i<limit;i++) sum=(a[i]=read<int>())+sum;\n\t\tsum=qpow(sum,mod-2);\n\t\tfor(int i=0;i<limit;i++) a[i]=1LL*a[i]*sum%mod;\n\n\t\tfwt(a,1);\n\t\tfor(int i=1;i<limit;i++)\n\t\t\tf[i]=1LL*qpow(sub(1,a[i]),mod-2)*(i?(mod-limit):0)%mod;\n\t\tfwt(f,-1);\n\n\t\tint x=sub(0,f[0]);\n\t\tfor(int i=0;i<limit;i++) printf(\"%d\\n\",add(f[i],x));\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod (998244353)\n#define inv2 (499122177) \n#define N 300000\nusing namespace std;\ntypedef long long ll;\nint n,s,p[N],A[N];\nvoid fwt(int *a,int n,int ops){\n\tfor(int mid=1;mid<n;mid<<=1)\n\t\tfor(int i=0;i<n;i+=mid<<1)\n\t\t\tfor(int j=0;j<mid;j++){\n\t\t\t\tint x=a[i+j],y=a[i+j+mid];\n\t\t\t\ta[i+j]=(x+y)%mod;\n\t\t\t\ta[i+j+mid]=(x-y+mod)%mod;\n\t\t\t\tif(ops==-1){\n\t\t\t\t\ta[i+j]=(1ll*a[i+j]*inv2)%mod;\n\t\t\t\t\ta[i+j+mid]=(1ll*a[i+j+mid]*inv2)%mod;\n\t\t\t\t}\n\t\t\t}\n}\ninline int ksm(int x,int y){\n    int res=1;\n\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"test.txt\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tscanf(\"%d\",&p[i]);\n\t\ts=(s+p[i])%mod;\n\t}\n\ts=ksm(s,mod-2);\n\t\n\tfor(int i=0;i<1<<n;i++)p[i]=(1ll*p[i]*s)%mod;\n\tp[0]=(p[0]+mod-1)%mod;\n\t\n\tA[0]=(1<<n)-1;\n\tfor(int i=1;i<1<<n;i++)A[i]=mod-1;\n\t\n\tfwt(A,1<<n,1);fwt(p,1<<n,1);\n\tfor(int i=0;i<1<<n;i++)\n\t\tA[i]=(1ll*A[i]*ksm(p[i],mod-2))%mod;\n\tfwt(A,1<<n,-1);\n\t\n\tfor(int i=0;i<1<<n;i++)\n\t\tprintf(\"%d\\n\",(A[i]-A[0]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nconst int inv=P-P/2;\nvoid FWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t}\n}\nvoid UFWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t\ta[i+j]=1ll*inv*a[i+j]%P;\n\t\t\t\ta[i+j+d]=1ll*inv*a[i+j+d]%P;\n\t\t\t}\n}\nconst int N=1<<18;\nint a[N],b[N];\nint qpow(int a,int b=P-2){\n\tint res=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1){\n\t\t\tres=1ll*res*a%P;\n\t\t}\n\t\ta=1ll*a*a%P;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint sum=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcin>>a[i];\n\t\tsum=(sum+a[i])%P;\n\t}\n\tsum=qpow(sum);\n\tfor(int i=0;i<(1<<n);i++){\n\t\ta[i]=1ll*sum*a[i]%P;\n\t\tb[i]=1;\n\t}\n\tb[0]=0;\n\tFWT(a,n);\n\tFWT(b,n);\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++){\n\t\ta[i]=1ll*qpow((P+1-a[i])%P)*b[i]%P;\n\t}\n\tFWT(a,n);\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcout<<(P+a[i]-a[0])%P<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<iostream>\n#include<bits/stdc++.h>\n#include<cstdio>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define inf 99999999\n#define dl double\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) ((a)>0?(a):-(a))\n#define re register\n#define FOR(i,a,b) for(re int i=(a) ; i<=(b) ; ++i)\n#define AFOR(i,a,b) for(re int i=(a) ; i>=(b) ; --i)\n#define REP(i,u) for(re int i=head[u],v=edge[i].to;i!=-1;i=edge[i].nxt,v=edge[i].to)\n//#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),fs==ft))?0:*fs++\n#define gc getchar()\nusing namespace std;\nconst int N=1e5+10;\nconst ll mod=998244353;\nchar buf[1<<18],*fs,*ft;\ninline ll read() {\n\tll w=0,p=0;\n\tchar ch=gc;\n\twhile(!isdigit(ch)) w=ch=='-'?1:0,ch=gc;\n\twhile(isdigit(ch)) p=p*10+ch-'0',ch=gc;\n\treturn w?-p:p;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn ;\n}\nint n,limit;\nll S,f[N],b[N],g[N];\ninline ll mul(ll x,ll y){\n\tll as=1;\n\twhile(y){\n\t\tif(y&1) as=as*x%mod;\n\t\tx=x*x%mod,y>>=1;\n\t}\n\treturn as;\n}\ninline void FWT(ll a[],int limit,int type){\n\tll x,y,inv=mul(2,mod-2);\n\tfor(re int i=1 ; i<limit ; i*=2 )\n\t\tfor(re int j=0 ; j<limit ; j+=2*i) \n\t\t\tfor(re int k=j ; k<i+j ; ++k)\n\t\t\t\tx=a[k],y=a[k+i],a[k]=(x+y+mod)%mod*(type==-1?inv:1)%mod,a[k+i]=(x-y+mod)%mod*(type==-1?inv:1)%mod;\n}\nint main(){\n\tll inv=0;\n\tn=read();\n\tlimit=1<<n;\n\tFOR(i,0,limit-1) b[i]=read(),g[i]=mod-1,S=(S+b[i])%mod;\n\tinv=mul(S,mod-2);\n\tFOR(i,0,limit-1) b[i]=(b[i]*inv)%mod;\n\t--b[0],g[0]+=limit;\n\tFWT(b,limit,1),FWT(g,limit,1);\n\tFOR(i,0,limit-1) f[i]=g[i]*mul(b[i],mod-2)%mod;\n\tFWT(f,limit,-1);\n\tFOR(i,0,limit-1) write((f[i]-f[0]+mod)%mod),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ninline int read(){\n\tchar ch=getchar();int x=0,op=0;\n\twhile(!isdigit(ch))op|=(ch=='-'),ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn op?-x:x;\n}\n\nconst int N=100005,M=N*15;\nconst ll inf=1e18;\nnamespace G{\n\tstruct edge{\n\t\tint u,v,f,c;ll w;int id;\n\t}e[M];\n\tll f[N],d[N];\n\tint n,m,s,t,flag;\n\tvi g[N];\n\tinline void init(int _n,int _s,int _t,int _flag=1){\n\t\tn=_n,m=0,s=_s,t=_t,flag=_flag;\n\t\trep(i,1,n)f[i]=0;\n\t}\n\tinline void add(int u,int v,int c,ll w){\n\t\tg[u].pb(m),w*=flag;\n\t\te[m++]=(edge){u,v,0,c,w,(int)g[v].size()};\n\t\tg[v].pb(m);\n\t\te[m++]=(edge){v,u,0,0,-w,(int)g[u].size()-1};\n\t}\n\tstruct node{\n\t\tint u;ll d;\n\t\tinline friend bool operator < (node a,node b){\n\t\t\treturn a.d>b.d;\n\t\t}\n\t};\n\tpriority_queue<node> Q;\n\tint dij(){\n\t\trep(i,1,n)d[i]=inf;\n\t\td[s]=0,Q.push((node){s,0});\n\t\twhile(!Q.empty()){\n\t\t\tnode t=Q.top();Q.pop();\n\t\t\tif(d[t.u]!=t.d){\n\t\t\t\tassert(d[t.u]<=t.d);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=t.u;\n\t\t\tfor(auto k:g[u]){\n\t\t\t\tint v=e[k].v;\n\t\t\t\tif(e[k].f<e[k].c&&d[u]+e[k].w+f[u]-f[v]<d[v]){\n\t\t\t\t\td[v]=d[u]+e[k].w+f[u]-f[v];\n\t\t\t\t\tQ.push((node){v,d[v]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t]<inf;\n\t}\n\tint in[N],r[N];\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tll res=0;in[u]=1;\n\t\tfor(int &p=r[u];p<g[u].size();p++){\n\t\t\tint k=g[u][p],v=e[k].v;\n\t\t\tif(e[k].f<e[k].c&&d[u]+e[k].w+f[u]-f[v]==d[v]&&!in[v]){\n\t\t\t\tint tmp=dfs(v,min(a,e[k].c-e[k].f));\n\t\t\t\tres+=tmp,a-=tmp;\n\t\t\t\te[k].f+=tmp,\n\t\t\t\te[g[e[k].v][e[k].id]].f-=tmp;\n\t\t\t}\n\t\t\tif(!a)break;\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tvoid mcmf(ll &flow,ll &cost){\n\t\twhile(dij()){\n\t\t\trep(i,1,n)r[i]=0;\n\t\t\tll owo=dfs(s,2e9);\n\t\t\tflow+=owo,cost+=owo*(d[t]+f[t]);\n\t\t\trep(i,1,n)f[i]=min(f[i]+d[i],inf);\n\t\t}\n\t}\n}\n\nint n,x,y,c,p0,p1,p2,p3,s,t,bas;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tG::init(n*2+6,s=1,t=2,-1);\n\tp0=3,p1=4,p2=5,p3=6,bas=6;\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tG::add(s,bas+i,c,0);\n\t\tG::add(bas+i,p0,c,+x+y);\n\t\tG::add(bas+i,p1,c,+x-y);\n\t\tG::add(bas+i,p2,c,-x+y);\n\t\tG::add(bas+i,p3,c,-x-y);\n\t}\n\tbas+=n;\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tG::add(bas+i,t,c,0);\n\t\tG::add(p3,bas+i,c,+x+y);\n\t\tG::add(p2,bas+i,c,+x-y);\n\t\tG::add(p1,bas+i,c,-x+y);\n\t\tG::add(p0,bas+i,c,-x-y);\n\t}\n\tll flow=0,cost=0;\n\tG::mcmf(flow,cost);\n\tcout<<-cost<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=3e5+5;\nconst int mod=998244353;\nint n,len,p[N],sum,a[N];\nint fastpow(int x,int y){\n\tint res=1;\n\twhile(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}\n\treturn res;\n}\nvoid fwt(int *p,int op){\n\tfor(int i=1;i<len;i<<=1)\n\t\tfor(int j=0;j<len;j+=i<<1)\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint x=p[j+k],y=p[j+k+i];\n\t\t\t\tp[j+k]=(x+y)%mod;\n\t\t\t\tp[j+k+i]=(x-y+mod)%mod;\n\t\t\t}\n\tif(!op){\n\t\tint inv_len=fastpow(len,mod-2);\n\t\tfor(int i=0;i<1<<n;++i)p[i]=1ll*p[i]*inv_len%mod;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);len=1<<n;\n\tfor(int i=0;i<len;++i)scanf(\"%d\",&p[i]),sum+=p[i];\n\tsum=fastpow(sum,mod-2);\n\tfor(int i=0;i<len;++i)p[i]=1ll*p[i]*sum%mod,a[i]=mod-1;\n\tp[0]=(p[0]+mod-1)%mod;a[0]=(1<<n)-1;\n\tfwt(p,1);fwt(a,1);\n\tfor(int i=0;i<len;++i)a[i]=1ll*a[i]*fastpow(p[i],mod-2)%mod;\n\tfwt(a,0);\n\tfor(int i=0;i<1<<n;++i)printf(\"%d\\n\",(a[i]-a[0]+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=18;\nconst int MOD=998244353;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nvoid dec(int &a,int b) { if((a-=b)<0) a+=MOD; }\nint pw(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%MOD; if((n>>=1)==0) return ret; x=(ll)x*x%MOD; } }\nint inv(int x) { assert(x!=0); return pw(x,MOD-2); }\n\nvoid wht(int *a,int nbits) {\n\tREP(bit,nbits) for(int off=0;off<(1<<nbits);off+=2<<bit) REP(i,1<<bit) { int x=a[off+i],y=a[off+(1<<bit)+i]; a[off+i]=a[off+(1<<bit)+i]=x; inc(a[off+i],y); dec(a[off+(1<<bit)+i],y); }\n}\n\nint n;\nint a[1<<MAXN];\nint x[1<<MAXN];\n\nint p[1<<MAXN];\nint lhs[1<<MAXN];\nint rhs[1<<MAXN];\n\n\nvoid solve() {\n\tint asum=0; REP(i,1<<n) asum+=a[i];\n\tint pmlt=inv(asum); REP(i,1<<n) p[i]=(ll)a[i]*pmlt%MOD;\n\tREP(i,1<<n) lhs[i]=p[i]; lhs[0]=(lhs[0]+MOD-1)%MOD;\n\tREP(i,1<<n) rhs[i]=MOD-1; rhs[0]=(rhs[0]+(1<<n))%MOD;\n\twht(lhs,n);\n\twht(rhs,n);\n\t//printf(\"lhs:\"); REP(i,1<<n) printf(\" %d\",lhs[i]); puts(\"\");\n\t//printf(\"rhs:\"); REP(i,1<<n) printf(\" %d\",rhs[i]); puts(\"\");\n\tx[0]=0; FOR(i,1,1<<n) { assert(lhs[i]!=0); x[i]=(ll)rhs[i]*inv(lhs[i])%MOD; }\n\twht(x,n);\n\tint offset=MOD-x[0]; REP(i,1<<n) inc(x[i],offset);\n\tint xmlt=inv(1<<n); REP(i,1<<n) x[i]=(ll)x[i]*xmlt%MOD;\n\t//printf(\"x:\"); REP(i,1<<n) printf(\" %d\",x[i]); puts(\"\");\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,1<<n) scanf(\"%d\",&a[i]);\n\tsolve();\n\tREP(i,1<<n) printf(\"%d\\n\",x[i]);\n\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const md = 998244353;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline int pw(int x, int p){\n\tint an = 1;\n\twhile (p){\n\t\tif (p & 1)an = (ll)an * x % md;\n\t\tx = (ll)x * x % md;\n\t\tp >>= 1;\n\t}\n\treturn an;\n}\n\nvoid xc(vector<int> &v, bool inv){\n\tfor (int w = 1; w < v.size(); w <<= 1)for (int l = 0; l < v.size(); l += w << 1)f(i, 0, w){\n\t\tint a = v[l + i], b = v[l + w + i];\n\t\tad(v[l + i] = a, b);\n\t\tsb(v[l + w + i] = a, b);\n\t}\n\tif (inv)f(i, 0, v.size())v[i] = (ll)v[i] * pw(v.size(), md - 2) % md;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tn = 1 << n;\n\tvector<int> pr(n), z(n);\n\tf(i, 0, n)scanf(\"%d\", &pr[i]);\n\tint s = 0;\n\tf(i, 0, n)s += pr[i];\n\tint inv = pw(s, md - 2);\n\tf(i, 0, n)pr[i] = (ll)pr[i] * inv % md;\n\tpr[0] -= 1;\n\tz[0] = n - 1;\n\tf(i, 1, n)z[i] = md - 1;\n\txc(pr, false);\n\txc(z, false);\n\tf(i, 0, n)z[i] = (ll)z[i] * pw(pr[i], md - 2) % md;\n\txc(z, true);\n\tf(i, 1, n)sb(z[i], z[0]);\n\tprintf(\"0\\n\");\n\tf(i, 1, n)printf(\"%d\\n\", z[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000,mod = 998244353;\nll n,sum,A[N],S[N];\nll ksm(ll x,ll y)\n{\n\tll res = 1; \n\tfor(;y;y >>= 1,x = x * x % mod) \n\t\tif(y & 1) res = res * x % mod; \n\treturn res;\n}\nvoid Xor(ll *f,ll opt)\n{\n\tll a,b;\n\tfor(int len = 2,mid = 1;len <= n;len <<= 1,mid <<= 1)\n\t\tfor(int i = 0;i < n;i += len)\n\t\t\tfor(int j = 0;j < mid;j ++)\n\t\t\t{\n\t\t\t\ta = f[i + j]; b = f[i + j + mid];\n\t\t\t\tf[i + j] = (a + b) % mod * opt % mod;\n\t\t\t\tf[i + j + mid] = (a - b) % mod * opt % mod;\n\t\t\t}\n\tfor(int i = 0;i < n;i ++) f[i] = (f[i] + mod) % mod;\n}\nint main()\n{\n\tn = read(); n = (1 << n);\n\tfor(int i = 0;i < n;i ++) sum = (sum + (A[i] = read())) % mod;\n\tsum = ksm(sum,mod - 2); \n\tfor(int i = 0;i < n;i ++) A[i] = A[i] * sum % mod;\n\tA[0] --; if(A[0] < 0) A[0] += mod; \n\tS[0] = n - 1; for(int i = 1;i < n;i ++) S[i] = mod - 1;\n\tXor(S,1); Xor(A,1);\n\tfor(int i = 0;i < n;i ++) A[i] = ksm(A[i],mod - 2) * S[i] % mod;\n\tXor(A,(mod + 1) >> 1);\n\tll x = mod - A[0];\n\tfor(int i = 0;i < n;i ++) cout << ((x + A[i]) % mod + mod) % mod << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define mod 998244353\n#define inv2 499122177\n#define M 1000005\nint n,I[M],P[M];\nint read(){\n\tchar c=getchar();int ans=0;\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=ans*10+c-'0',c=getchar();\n\treturn ans;\n}\nvoid Write(int x){\n\tif (x<10) putchar(x^48);\n\telse Write(x/10),putchar((x%10)^48);\n\treturn;\n}\nint invs(int x){return x==1?1:(mod-mod/x+0ll)*invs(mod%x)%mod;}\nint add(int u,int v){return (u+=v)>=mod?u-mod:u;}\nint sub(int u,int v){return (u-=v)<0?u+mod:u;}\nvoid FWT(int *A,int len,int flag){\n\tint tmp;\n\tfor (register int l=1;l<len;l<<=1)\n\t\tfor (register int i=0;i<len;i+=(l<<1))\n\t\t\tfor (register int j=0;j<l;j++)\n\t\t\t\ttmp=A[i|j|l],A[i|j|l]=sub(A[i|j],tmp),A[i|j]=add(A[i|j],tmp);\n\tif (flag==-1)\n\t\tfor (register int i=0,tmp=invs(len);i<len;i++) A[i]=(A[i]+0ll)*tmp%mod;\n\treturn;\n}\nint main(){\n\tn=read();\n\tfor (register int i=0;i<(1<<n);i++) P[i]=read(),P[1<<n]+=P[i];\n\tP[1<<n]=invs(P[1<<n]);\n\tfor (register int i=0;i<(1<<n);i++) P[i]=P[i]*(P[1<<n]+0ll)%mod,I[i]=mod-1;I[0]=(1<<n)-1;\n\tP[1<<n]=0;P[0]=sub(P[0],1),FWT(P,1<<n,1),FWT(I,1<<n,1);\n\tfor (register int i=1;i<(1<<n);i++) P[i]=(I[i]+0ll)*invs(P[i])%mod;P[0]=0;FWT(P,1<<n,-1);\n\tfor (register int i=0,tmp=sub(0,*P);i<(1<<n);i++) Write(add(P[i],tmp)),putchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 18\n#define X 998244353\n#define I2 499122177LL\nusing namespace std;\nint n,P,p[1<<N],_[1<<N];\nI int QP(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nI void FWT(int *s,CI op)\n{\n\tfor(RI i=1,j,k,x,y;i^P;i<<=1) for(j=0;j^P;j+=i<<1) for(k=0;k^i;++k) x=s[j+k],y=s[i+j+k],\n\t\ts[j+k]=(x+y)%X,s[i+j+k]=(x-y+X)%X,!~op&&(s[j+k]=I2*s[j+k]%X,s[i+j+k]=I2*s[i+j+k]%X);\n}\nint main()\n{\n\tRI i,s=0;for(scanf(\"%d\",&n),P=1<<n,i=0;i^P;++i) scanf(\"%d\",p+i),s+=p[i];\n\tfor(s=QP(s,X-2),i=0;i^P;++i) p[i]=1LL*p[i]*s%X;p[0]?--p[0]:(p[0]=X-1);\n\tfor(_[0]=P-1,i=1;i^P;++i) _[i]=X-1;\n\tFWT(p,1),FWT(_,1);for(RI i=0;i^P;++i) _[i]=1LL*_[i]*QP(p[i],X-2)%X;FWT(_,-1);\n\tfor(i=0;i^P;++i) printf(\"%d%c\",(_[i]-_[0]+X)%X,\" \\n\"[i==P-1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=998244353;\nint n,m,i,j,a[262145],b[262145],sum;\nint pw(int x,int y){\n\tint z=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\tz=1ll*z*x%mod;\n\t\t}\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn z;\n}\nvoid fwt(int *a,int op){\n\tint i,j;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<m;j++)if(!((j>>i)&1)){\n\t\t\tint x=a[j],y=a[j|(1<<i)];\n\t\t\ta[j]=(x+y)%mod;\n\t\t\ta[j|(1<<i)]=(x-y+mod)%mod;\n\t\t\tif(op==-1){\n\t\t\t\ta[j]=1ll*a[j]*(mod+1)/2%mod;\n\t\t\t\ta[j|(1<<i)]=1ll*a[j|(1<<i)]*(mod+1)/2%mod;\n\t\t\t}\n\t\t}\n\t} \n}\nint main(){\n\tcin>>n;m=(1<<n);\n\tfor(i=0;i<m;i++){\n\t\tcin>>a[i];\n\t\tsum+=a[i];\n\t}\n\tsum=pw(sum,mod-2);\n\tfor(i=0;i<m;i++){\n\t\ta[i]=1ll*a[i]*sum%mod;\n\t\tb[i]=mod-1;\n\t}\n\tb[0]=m-1;\n\ta[0]=(a[0]-1+mod)%mod;\n\tfwt(a,1);fwt(b,1);\n\tfor(i=0;i<m;i++){\n\t\ta[i]=1ll*b[i]*pw(a[i],mod-2)%mod;\n\t}\n\tfwt(a,-1);\n\tfor(i=0;i<m;i++){\n\t\tcout<<(a[i]-a[0]+mod)%mod<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\nusing namespace std;\nll add(ll x,ll y){x+=y;if(x>mod)x-=mod;return x;}\nll sub(ll x,ll y){x-=y;if(x<0)x+=mod;return x;}\nll mul(ll x,ll y){x%=mod;y%=mod;return x*y%mod;}\nll power(ll n,ll x){\n    ll sp=1ll;\n    while(x){\n        if(x&1) sp=mul(sp,n);\n        n=mul(n,n);x>>=1;\n    }return sp;\n}\nll inv2=(mod+1)>>1;\nvoid FWT(ll *a,int n,int opt){\n    for(int i=1;i<n;i<<=1)\n    for(int j=0;j<n;j+=(i<<1))\n    for(int k=0;k<i;k++){\n        ll X=a[j+k],Y=a[i+j+k];\n        a[j+k]=add(X,Y);a[i+j+k]=sub(X,Y);\n        if(opt==-1) a[j+k]=mul(a[j+k],inv2),a[i+j+k]=mul(a[i+j+k],inv2);\n    }\n}\nll n,m;\nll a[300000],b[300000],p[300000],sum,inv;\nint main(){\n    scanf(\"%lld\",&n);m=1<<n;\n    for(int i=0;i<m;i++) scanf(\"%lld\",&p[i]),sum=add(sum,p[i]);\n    inv=power(sum,mod-2);\n    for(int i=0;i<m;i++) a[i]=mul(p[i],inv);a[0]=sub(a[0],1);\n    for(int i=1;i<m;i++) b[i]=mod-1;b[0]=m-1;\n    FWT(a,m,1);FWT(b,m,1);\n    for(int i=0;i<m;i++) b[i]=mul(b[i],power(a[i],mod-2));\n    FWT(b,m,-1);\n    for(int i=0;i<m;i++) printf(\"%lld\\n\",sub(b[i],b[0]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem Source : agc-034F\nAuthor : oier_hzy\nTime : Nov 24 2019\n*/\n\n/*\nf[i]: i -> 0\nf[0] = 0\nf[i] = 1 + ∑ f[j] * p[i^j]\n<f> * <p> = <?, f[i] - 1>\n\n∑<p> = 1, so ∑<f> = ∑<?, f[i] - 1>\n? = f[0] + 2^n - 1;\n\n<f> * <p> = <f[0] + 2^n - 1, f[i] - 1>\n<f> * <p[0] - 1, p[i]> = <2^n - 1, -1, -1, ...>\n\nifwt\n\nsquare up : ? * 0 = 0\n? = 0 / 0 is not feasible\n\nbut we know that f[0] = 0, so not to consider the issue, calculate a[0]' out\nthen modify <f> to eliminate the bias to make a[0] = 0\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x) {\n\tchar ch = getchar(), sgn = 0; x = 0;\n\twhile(ch != '-' and !isdigit(ch)) ch = getchar(); if(ch == '-') ch = getchar(), sgn = 1;\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if(sgn) x = -x;\n}\n\nconst int mod = 998244353, inv2 = mod + 1 >> 1;\n\ninline int qm(const int x) {return x < mod ? x : x - mod;}\ninline int qpow(int A, int B) {\n\tint r = 1;\n\tfor(; B; A = (ll)A * A%mod, B >>= 1)\n\t\tif(B&1) r = (ll)r * A%mod;\n\treturn r;\n}\n\nvoid fwt(int*a, int n) {\n\tfor(int i = 1; i < n; i <<= 1)\n\tfor(int j = 0; j < n; j += (i << 1))\n\tfor(int k = 0; k < i; ++ k) {\n\t\tconst int x = a[j+k], y = a[j+k+i];\n\t\ta[j+k] = qm(x + y), a[j+k+i] = qm(x - y+mod);\n\t}\n}\n\nvoid ifwt(int*a, int n) {\n\tfor(int i = 1; i < n; i <<= 1)\n\tfor(int j = 0; j < n; j += (i << 1))\n\tfor(int k = 0; k < i; ++ k) {\n\t\tconst int x = a[j+k], y = a[j+k+i];\n\t\ta[j+k] = (ll)qm(x + y) * inv2%mod;\n\t\ta[j+k+i] = (ll)qm(x - y+mod) * inv2%mod;\n\t}\n}\n\nconst int N = 1 << 18 | 3;\nint p[N], f[N];\nint n;\n\nint main() {\n\tread(n), n = 1 << n;\n\tint sum = 0;\n\tfor(int i = 0; i < n; ++ i) read(p[i]), sum += p[i];\n\tsum = qpow(sum, mod-2);\n\tfor(int i = 0; i < n; ++ i) p[i] = (ll)p[i] * sum%mod;\n\tp[0] = qm(p[0] - 1+mod);\n\t\n\tfor(int i = 1; i < n; ++ i) f[i] = mod - 1;\n\tf[0] = n - 1;\n\t\n\tfwt(f, n), fwt(p, n);\n\tfor(int i = 0; i < n; ++ i) f[i] = (ll)f[i] * qpow(p[i], mod-2)%mod;\n\tifwt(f, n);\n\t\n\tif(f[0]) {\n\t\tint bias = (ll)(mod - f[0]) * n%mod;\n\t\tfwt(f, n);\n\t\tfor(int i = 0; i < n; ++ i)\n\t\t\tif(!p[i]) {\n\t\t\t\tf[i] = bias;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tifwt(f, n);\n\t}\n\t\n\tfor(int i = 0; i < n; ++ i)\n\t\tprintf(\"%d\\n\", f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 02.06.2019 16:33:34       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nnamespace fwht {\n\ntemplate<typename T>\nvoid hadamard(vector<T> &a) {\n  int n = a.size();\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        T x = a[i + j];\n        T y = a[i + j + k];\n        a[i + j] = x + y;\n        a[i + j + k] = x - y;\n      }\n    }\n  }\n}\n\ntemplate<typename T>\nvector<T> multiply(vector<T> a, vector<T> b) {\n  int eq = (a == b);\n  int n = 1;\n  while (n < (int) max(a.size(), b.size())) {\n    n <<= 1;\n  }\n  a.resize(n);\n  b.resize(n);\n  hadamard(a);\n  if (eq) b = a; else hadamard(b);\n  for (int i = 0; i < n; i++) {\n    a[i] *= b[i];\n  }\n  hadamard(a);\n  T q = 1 / static_cast<T>(n);\n  for (int i = 0; i < n; i++) {\n    a[i] *= q;\n  }\n  return a;\n}\n\n}  // namespace fwht\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<Mint> a(1 << n);\n  Mint sum = 0;\n  for (int i = 0; i < (1 << n); i++) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  for (int i = 0; i < (1 << n); i++) {\n    a[i] /= sum;\n  }\n  vector<Mint> b = a;\n  fwht::hadamard(b);\n//  debug(b);\n  vector<Mint> c(1 << n);\n  Mint all = 0;\n  for (int i = 1; i < (1 << n); i++) {\n    c[i] = (1 - b[i]) / 2;\n    c[i] = 1 / c[i];\n    all += c[i];\n  }\n//  debug(c);\n  fwht::hadamard(c);\n  cout << 0 << '\\n';\n  for (int i = 1; i < (1 << n); i++) {\n    Mint res = (all - c[i]) / 2;\n/*    for (int j = 1; j < (1 << n); j++) {\n      if (__builtin_popcount(i & j) % 2 == 1) {\n        res += c[j];\n      }\n    }*/\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\n#define ljc2 (998244354/2) \nusing namespace std;\n/*\n*/\n#ifdef emm\n#define gc getchar\n#endif\n#ifndef emm\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\n#endif\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\ninline ll fast_pow(ll a,ll b,ll p){\n\tll t=1;\n\twhile (b){\n\t\tif (b&1ll) t=t*a%p;\n\t\tb>>=1;a=a*a%p; \n\t}\n\treturn t;\n}\ninline void FWT(ll *f,ll lim,ll id){\n\tfor (int len=1;len<lim;len<<=1){\n\t\tfor (int i=0;i<lim;i+=len<<1){\n\t\t\tll *f1=f+i,*f2=f1+len;\n\t\t\tfor (int j=0;j<len;j++){\n\t\t\t\tll x=f1[j],y=f2[j];\n\t\t\t\tf1[j]=(x+y)*(~id?1:ljc2)%ljc;\n\t\t\t\tf2[j]=(x-y+ljc)*(~id?1:ljc2)%ljc;\n\t\t\t}\n\t\t}\n\t}\n}\nll n,lim,a[1048577],S,b[1048577];\nsigned main(){\n\tn=read(),lim=1<<n;\n\tfor (int i=0;i<lim;i++) a[i]=read(),S+=a[i];\n\tS=fast_pow(S%ljc,ljc-2,ljc);\n\tfor (int i=1;i<lim;i++) b[i]=ljc-1;\n\tb[0]=lim-1;\n\tfor (int i=1;i<lim;i++) a[i]=a[i]*S%ljc;\n\ta[0]=(a[0]*S%ljc+ljc-1)%ljc;\n\tFWT(b,lim,1),FWT(a,lim,1);\n\tfor (int i=1;i<lim;i++) a[i]=fast_pow(a[i],ljc-2,ljc)*b[i]%ljc;\n\ta[0]=0;\n\tFWT(a,lim,-1);\n\tll tmp=a[0];\n\tfor (int i=0;i<lim;i++){\n\t\tprintf(\"%lld\\n\",(a[i]-tmp+ljc)%ljc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int mod=998244353;\ninline int add(int a,int b)\n{\n\treturn (a+=b)>=mod?a-mod:a;\n}\ninline int sub(int a,int b)\n{\n\treturn (a-=b)<0?a+mod:a;\n}\ninline int mul(int a,int b)\n{\n\treturn (long long)a*b%mod;\n}\ninline int qpow(int a,int b)\n{\n\tint res=1;\n\tfor(;b;a=mul(a,a),b>>=1)\n\t\tif(b&1)\n\t\t\tres=mul(res,a);\n\treturn res;\n}\nconst int N=18;\ninline void fwt(int *f,int n,int p)\n{\n\tint w,u,t;\n\tregister int i,j,k;\n\tfor(i=1;i<<1<=n;i<<=1)\n\t\tfor(j=0;j<n;j+=i<<1)\n\t\t\tfor(k=0;k<i;k++)\n\t\t\t\tu=f[j+k],t=f[j+k+i],f[j+k]=add(u,t),f[j+k+i]=sub(u,t);\n\tif(!~p)\n\t\tfor(w=qpow(n,mod-2),i=0;i<n;i++)\n\t\t\tf[i]=mul(w,f[i]);\n\treturn;\n}\nint n,sum;\nint f[1<<N],g[1<<N];\nsigned main()\n{\n\tregister int i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<1<<n;i++)\n\t\tscanf(\"%d\",&g[i]),sum=add(sum,g[i]);\n\tsum=qpow(sum,mod-2);\n\tfor(i=0;i<1<<n;i++)\n\t\tg[i]=mul(g[i],sum);\n\tsum=0;\n\tfwt(g,1<<n,1);\n\tfor(i=1;i<1<<n;i++)\n\t\tf[i]=qpow(sub(g[i],1),mod-2),sum=add(sum,f[i]);\n\tf[0]=sub(0,sum);\n\tfwt(f,1<<n,1);\n\tfor(i=0;i<1<<n;i++)\n\t\tprintf(\"%d\\n\",f[i]);\n//\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define ll long long\n#define mod 998244353\nusing namespace std;\nll add(ll x,ll y){x+=y;if(x>mod)x-=mod;return x;}\nll sub(ll x,ll y){x-=y;if(x<0)x+=mod;return x;}\nll mul(ll x,ll y){x%=mod;y%=mod;return x*y%mod;}\nll power(ll n,ll x){\n    ll sp=1ll;\n    while(x){\n        if(x&1) sp=mul(sp,n);\n        n=mul(n,n);x>>=1;\n    }return sp;\n}\nll inv2=(mod+1)>>1;\nvoid FWT(ll *a,int n,int opt){\n    for(int i=1;i<n;i<<=1)\n    for(int j=0;j<n;j+=(i<<1))\n    for(int k=0;k<i;k++){\n        ll X=a[j+k],Y=a[i+j+k];\n        a[j+k]=add(X,Y);a[i+j+k]=sub(X,Y);\n        if(opt==-1) a[j+k]=mul(a[j+k],inv2),a[i+j+k]=mul(a[i+j+k],inv2);\n    }\n}\nll n,m;\nll a[300000],b[300000],p[300000],sum,inv;\nint main(){\n    scanf(\"%lld\",&n);m=1<<n;\n    for(int i=0;i<m;i++) scanf(\"%lld\",&p[i]),sum=add(sum,p[i]);\n    inv=power(sum,mod-2);\n    for(int i=0;i<m;i++) a[i]=mul(p[i],inv);a[0]=sub(a[0],1);\n    for(int i=1;i<m;i++) b[i]=mod-1;b[0]=m-1;\n    FWT(a,m,1);FWT(b,m,1);\n    for(int i=0;i<m;i++) b[i]=mul(b[i],power(a[i],mod-2));\n    FWT(b,m,-1);\n    for(int i=0;i<m;i++) printf(\"%lld\\n\",sub(b[i],b[0]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nvoid inc(int &a,int b) { a=a+b>=mod?a+b-mod:a+b; }\nvoid dec(int &a,int b) { a=a-b<0?a-b+mod:a-b; }\n\nint n,a[N];\n\nint qpow(int a,int b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nvoid fwt() {\n\tfor(int i=1;i<n;i<<=1)\n\t\tfor(int p=i<<1,j=0;j<n;j+=p)\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tint x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=x,inc(a[j+k],y);\n\t\t\t\ta[j+k+i]=x,dec(a[j+k+i],y);\n\t\t\t}\n}\n\nint main() {\n\tcin>>n;n=1<<n;int s=0;\n\tfor(int i=0;i<n;i++) a[i]=gi(),s+=a[i];\n\ts=qpow(s,mod-2);\n\tfor(int i=0;i<n;i++) a[i]=1ll*a[i]*s%mod;\n\tfwt();a[0]=0;\n\tfor(int i=1;i<n;i++) a[i]=qpow(a[i]-1,mod-2);\n\tfwt();\n\tputs(\"0\");\n\tfor(int i=1;i<n;i++) dec(a[i],a[0]),cout<<a[i]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int Mod=998244353,Inv2=(Mod+1)/2;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,len,P[1<<18],S[1<<18],F[1<<18],Sump;\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline void Div(int&x){if(x&1)x=1ll*x*Inv2%Mod;else x>>=1;}\ninline int Add(int x,int y){return x+y>=Mod?x+y-Mod:x+y;}\ninline int Sub(int x,int y){return x<y?x-y+Mod:x-y;}\ninline void FWT(int*F,int len,int opt){\n\tfor(int i=1;i<len;i<<=1)for(int j=0;j<len;j+=i<<1)for(int k=0;k<i;k++){\n\t\tint x=F[i+j+k],y=F[j+k];F[j+k]=Add(x,y),F[i+j+k]=Sub(y,x);if(opt==-1)Div(F[j+k]),Div(F[i+j+k]);\n\t}\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),len=1<<n;\n\tRep(i,0,len-1)P[i]=read(),Sump=(Sump+P[i]);Sump=Fp(Sump,Mod-2);\n\tRep(i,0,len-1)P[i]=1ll*P[i]*Sump%Mod;P[0]==0?P[0]=Mod-1:P[0]--;\n\tRep(i,0,len-1)S[i]=Mod-1;S[0]=len-1;FWT(S,len,0),FWT(P,len,0);\n\tRep(i,0,len-1)F[i]=1ll*S[i]*Fp(P[i],Mod-2)%Mod;FWT(F,len,-1);\n\tint tmp=Mod-F[0];Rep(i,0,len-1)cout<<(tmp+F[i])%Mod<<\"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1 << 18, mod = 998244353;\nint n, x[N], p[N];\nint qpow(int b, int p) {int r = 1; for (; p; p >>= 1, b = (ll) b * b % mod) if (p & 1) r = (ll) r * b % mod; return r;}\nvoid FWT(int *a, int fl) {\n  for (int k = 1; k < 1 << n; k <<= 1) {\n    for (int i = 0; i < 1 << n; i += k << 1) {\n      for (int j = 0; j < k; j++) {\n        int x = a[i + j], y = a[i + j + k];\n        a[i + j] = (x + y) % mod;\n        a[i + j + k] = (x - y + mod) % mod;\n        if (fl) {\n          a[i + j] = (ll) a[i + j] * (mod + 1) / 2 % mod;\n          a[i + j + k] = (ll) a[i + j + k] * (mod + 1) / 2 % mod;\n        }\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  int s = 0;\n  for (int i = 0; i < 1 << n; i++) {\n    scanf(\"%d\", &p[i]);\n    s += p[i];\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    p[i] = (ll) p[i] * qpow(s, mod - 2) % mod;\n    x[i] = i == 0 ? (1 << n) - 1 : mod - 1;\n  }\n  p[0] = (p[0] - 1 + mod) % mod;\n  FWT(x, 0);\n  FWT(p, 0);\n  for (int i = 0; i < 1 << n; i++) {\n    x[i] = (ll) x[i] * qpow(p[i], mod - 2) % mod;\n  }\n  FWT(x, 1);\n  for (int i = 0; i < 1 << n; i++) {\n    printf(\"%d\\n\", (x[i] - x[0] + mod) % mod);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 18, M = (1 << N) + 5,\n  P = 998244353, I2 = (P + 1) / 2;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, f[M], p[M], s;\n\ninline void FWT(int A[], int o) {\n  for (int i = 1; i < n; i <<= 1)\n    for (int j = 0; j < n; j += i << 1)\n      for (int k = 0; k < i; ++k) {\n        int nx = A[j + k], ny = A[i + j + k];\n        A[j + k] = (nx + ny) % P;\n        A[i + j + k] = (nx - ny + P) % P;\n        if (o == -1) {\n          A[j + k] = 1ll * A[j + k] * I2 % P;\n          A[i + j + k] = 1ll * A[i + j + k] * I2 % P;\n        }\n      }\n}\n\nint main() {\n  scanf(\"%d\", &n); n = 1 << n;\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", p + i), s += p[i];\n  s = fpow(s, P - 2);\n  for (int i = 0; i < n; ++i)\n    p[i] = 1ll * p[i] * s % P;\n  p[0] = (p[0] - 1 + P) % P;\n  for (int i = 0; i < n; ++i)\n    f[i] = P - 1;\n  f[0] += n;\n  FWT(p, 1), FWT(f, 1);\n  for (int i = 0; i < n; ++i)\n    f[i] = 1ll * f[i] * fpow(p[i], P - 2) % P;\n  FWT(f, -1);\n  for (int i = 0; i < n; ++i)\n    printf(\"%d\\n\", (f[i] - f[0] + P) % P);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define ll long long \nusing namespace std;\nconst int mod=998244353;\nconst int inv2=499122177;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\t\n}\nint n,u;\nll g[1<<18],f[1<<18],all;\nll qp(ll x,ll k){\n\tll res=1;\n\twhile(k){\n\t\tif(k&1) res=res*x%mod;\n\t\tk>>=1,x=x*x%mod;\n\t}\n\treturn res;\n}\nvoid fwt(ll *tmp,int tp){\n\tfor(re int mid=1;mid<=u;mid<<=1){\n\t\tfor(re int i=0;i<=u;i+=(mid<<1)){\n\t\t\tinc(j,0,mid-1){\n\t\t\t\tll x=tmp[i+j],y=tmp[i+j+mid];\n\t\t\t\ttmp[i+j]=(x+y)%mod;\n\t\t\t\ttmp[i+j+mid]=(x-y+mod)%mod;\n\t\t\t\tif(tp==-1) tmp[i+j]=tmp[i+j]*inv2%mod,tmp[i+j+mid]=tmp[i+j+mid]*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tn=read();u=(1<<n)-1;\n\tinc(i,0,u) f[i]=read(),all+=f[i];\n\tall=qp(all,mod-2);\n\tinc(i,0,u) f[i]=f[i]*all%mod;\n\tg[0]=u;inc(i,1,u) g[i]=mod-1;\n\tf[0]=(f[0]+mod-1)%mod;\n\tfwt(f,1),fwt(g,1);\n\tinc(i,0,u) f[i]=g[i]*qp(f[i],mod-2)%mod;\n\tfwt(f,-1);\n\tinc(i,1,u) f[i]=(f[i]-f[0]+mod)%mod;\n\tputs(\"0\");\n\tinc(i,1,u) printf(\"%lld\\n\",f[i]);\n}\n/*\n2 \n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\nnamespace pb_ds {   \n\tnamespace io {\n\t\tconst int MaxBuff = 1 << 15;\n\t\tconst int Output = 1 << 23;\n\t\tchar B[MaxBuff], *S = B, *T = B;\n#define getc() ((S == T) && (T = (S = B) + fread(B, 1, MaxBuff, stdin), S == T) ? 0 : *S++)\n\t\tchar Out[Output], *iter = Out;\n\t\tinline void flush() {\n\t\t\tfwrite(Out, 1, iter - Out, stdout);\n\t\t\titer = Out;\n\t\t}\n\t}\n\n\ttemplate<class Type = int> inline Type read() {\n\t\tusing namespace io;\n\t\tregister char ch; register Type ans = 0; register bool neg = 0;\n\t\twhile(ch = getc(), (ch < '0' || ch > '9') && ch != '-')     ;\n\t\tch == '-' ? neg = 1 : ans = ch - '0';\n\t\twhile(ch = getc(), '0' <= ch && ch <= '9') ans = ans * 10 + ch - '0';\n\t\treturn neg ? -ans : ans;\n\t}\n\n\ttemplate<class Type> inline void Print(register Type x, register char ch = '\\n') {\n\t\tusing namespace io;\n\t\tif(!x) *iter++ = '0';\n\t\telse {\n\t\t\tif(x < 0) *iter++ = '-', x = -x;\n\t\t\tstatic int s[100]; register int t = 0;\n\t\t\twhile(x) s[++t] = x % 10, x /= 10;\n\t\t\twhile(t) *iter++ = '0' + s[t--];\n\t\t}\n\t\t*iter++ = ch;\n\t}\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 18, S = 1 << N, Mod = 998244353;\n\ninline int fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nint n, len, p[S], s[S], sum, pre[S + 1], inv[S + 1];\n\nvoid FWT(int *P, int opt) {\n\tfor (int i = 2, p; p = i >> 1, i <= len; i <<= 1)\n\t\tfor (int j = 0; j < len; j += i) Rep (k, p) {\n\t\t\tint u = P[j + k], v = P[j + k + p];\n\t\t\tP[j + k] = (u + v) % Mod; P[j + k + p] = (u + Mod - v) % Mod;\n\t\t}\n\tif (!~opt) {\n\t\tint invn = fpm(len, Mod - 2);\n\t\tRep (i, len) P[i] = 1ll * P[i] * invn % Mod;\n\t}\n}\n\nusing namespace pb_ds;\n\nint main() {\n\n\tFile();\n\n\tlen = 1 << (n = read());\n\tRep (i, len) (sum += p[i] = read()) %= Mod;\n\tsum = fpm(sum, Mod - 2);\n\tRep (i, len) p[i] = 1ll * sum * p[i] % Mod; -- p[0];\n\tRep (i, len) s[i] = (i ? 0 : len) - 1;\n\n\tFWT(p, 1); FWT(s, 1); \n\n\tpre[0] = 1;\n\tFor (i, 1, len)\n\t\tpre[i] = 1ll * max(1, p[i - 1]) * pre[i - 1] % Mod;\n\tinv[len] = fpm(pre[len], Mod - 2);\n\tFordown (i, len - 1, 0)\n\t\tinv[i] = 1ll * inv[i + 1] * max(1, p[i]) % Mod;\n\tRep (i, len) if (p[i])\n\t\tp[i] = 1ll * s[i] * inv[i + 1] % Mod * pre[i] % Mod; \n\n\tFWT(p, -1);\n\n\tRep (i, len) \n\t\tPrint((p[i] - p[0] + Mod) % Mod);\n\tio :: flush();\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nconst int inv=P-P/2;\nvoid FWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t}\n}\nvoid UFWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t\ta[i+j]=1ll*inv*a[i+j]%P;\n\t\t\t\ta[i+j+d]=1ll*inv*a[i+j+d]%P;\n\t\t\t}\n}\nconst int N=1<<18;\nint a[N],b[N];\nint qpow(int a,int b=P-2){\n\tint res=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1){\n\t\t\tres=1ll*res*a%P;\n\t\t}\n\t\ta=1ll*a*a%P;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint sum=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcin>>a[i];\n\t\tsum=(sum+a[i])%P;\n\t}\n\tsum=qpow(sum);\n\tfor(int i=0;i<(1<<n);i++){\n\t\ta[i]=1ll*sum*a[i]%P;\n\t\tb[i]=1;\n\t}\n\tb[0]=-(1<<n)+1;\n\tFWT(a,n);\n\tFWT(b,n);\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++){\n\t\ta[i]=1ll*qpow((P+1-a[i])%P)*b[i]%P;\n\t}\n\tUFWT(a,n);\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcout<<(P+a[i]-a[0])%P<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int N=1<<20;\nconst int MOD=998244353;\nconst int Inv=499122177;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nint n,sum;\nint a[N];\nint p[N],q[N];\nint tmp[N];\nvoid FWT (int *a,int nn,int o)\n{\n    for (int u=1;u<=nn;u<<=1)\n    {\n        for (int i=0;i<=nn;i++) tmp[i]=0;\n        for (int i=0;i<=nn;i++)\n        {\n            if (i&u) tmp[i]=dec(tmp[i],a[i]),tmp[i^u]=add(tmp[i^u],a[i]);\n            else tmp[i]=add(tmp[i],a[i]),tmp[i^u]=add(tmp[i^u],a[i]);\n        }\n        for (int i=0;i<=nn;i++)  {a[i]=tmp[i];if (o==-1) a[i]=mul(a[i],Inv);}\n    }\n}\nint main()\n{\n\tscanf(\"%d\",&n);n=(1<<n);\n\tfor (int u=0;u<n;u++) \t{scanf(\"%d\",&a[u]);sum=add(sum,a[u]);}\n\tsum=Pow(sum,MOD-2);\n\tfor (int u=0;u<n;u++)\n\t{\n\t\tp[u]=mul(a[u],sum);\n\t\tq[u]=MOD-1;\n\t}\n\tq[0]=n-1;p[0]=dec(p[0],1);\n\tFWT(p,n-1,1);FWT(q,n-1,1);\n\tfor (int u=1;u<n;u++) \tp[u]=mul(q[u],Pow(p[u],MOD-2));\n\tFWT(p,n-1,-1);\n\tfor (int u=0;u<n;u++) printf(\"%d\\n\",dec(p[u],p[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nint LOG;\nclass Hadamard\n{\npublic:\n\tll d[2][1 << 19];\n\tvector<ll>conv(vector<ll>v)\n\t{\n\t\tfor (int i = 0; i < v.size(); i++)d[0][i] = v[i];\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < LOG; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < (1 << LOG); j += (1 << (LOG - i)))\n\t\t\t{\n\t\t\t\tint s = 1 << (LOG - i - 1);\n\t\t\t\tfor (int k = 0; k < s; k++)d[1 - cur][j + k] = (d[cur][j + k] + d[cur][j + s + k]) % mod, d[1 - cur][j + s + k] = d[cur][j + s + k];\n\t\t\t}\n\t\t\tcur = 1 - cur;\n\t\t}\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = 0; j < (1 << LOG); j += (1 << (LOG - i)))\n\t\t\t{\n\t\t\t\tint s = 1 << (LOG - i - 1);\n\t\t\t\tfor (int k = 0; k < s; k++)d[1 - cur][j + k] = d[cur][j + k], d[1 - cur][j + s + k] = (d[cur][j + k] + mod + mod - d[cur][j + s + k] * 2) % mod;\n\t\t\t}\n\t\t\tcur = 1 - cur;\n\t\t}\n\t\tvector<ll>r;\n\t\tfor (int i = 0; i < (1 << LOG); i++)r.push_back(d[cur][i]);\n\t\treturn r;\n\t}\n};\nHadamard had;\nll po(ll a, ll b)\n{\n\tif (b == 0)return 1;\n\tll z = po(a, b / 2);\n\tz = z*z%mod;\n\tif (b & 1)z = z*a%mod;\n\treturn z;\n}\nll inv(ll a)\n{\n\treturn po(a, mod - 2);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tLOG = num;\n\tvector<ll>a;\n\tll s = 0;\n\tfor (int i = 0; i < (1 << num); i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\", &z);\n\t\ta.push_back(z);\n\t\ts += z;\n\t}\n\tll iv = inv(s);\n\tfor (int i = 0; i < (1 << num); i++)a[i] = a[i] * iv%mod;\n\ta = had.conv(a);\n\tfor (int i = 1; i < (1 << num); i++)a[i] = inv(1 + mod - a[i]);\n\ta[0] = 0;\n\ta = had.conv(a);\n\tfor (int i = 0; i < (1 << num); i++)printf(\"%lld\\n\", (a[0] + mod - a[i]) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tregister int x=0;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9')\tch=getchar();\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=1e6+5;\nconst int P=998244353;\nconst int Gi=(P+1)>>1;\nlong long a[N],f[N],sum,inv;\nlong long fsp(long long x,int y){\n\tlong long ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint n;\nvoid fwt(long long *d,int f){\n\tfor(int i=1;i<n;i<<=1)\n\t\tfor(int j=0;j<n;j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tlong long x=(d[j+k]+d[i+j+k])%P;\n\t\t\t\tlong long y=(d[j+k]-d[i+j+k]+P)%P;\n\t\t\t\tif(f)\tx=x*Gi%P,y=y*Gi%P;\n\t\t\t\td[j+k]=x,d[i+j+k]=y;\n\t\t\t}\n}\nint main(){\n\tn=1<<read();\n\tfor(int i=0;i<n;i++)\ta[i]=read(),sum+=a[i];\n\ta[0]=P-sum+a[0],sum=fsp(sum,P-2),f[0]=n-1;\n\tfor(int i=0;i<n;i++)\ta[i]=a[i]*sum%P;\n\tfor(int i=1;i<n;i++)\tf[i]=P-1;\n\n\tfwt(f,0),fwt(a,0),inv=fsp(n,P-2);\n\tfor(int i=0;i<n;i++)\tf[i]=f[i]*fsp(a[i],P-2)%P;\n\tfwt(f,1);\n\tlong long k=P-f[0];\n\tfor(int i=0;i<n;i++)\tprintf(\"%lld\\n\",(f[i]+k)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long LL;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = (1<<18)+5;\nconst int mo = 998244353;\n\nLL quickmi(LL x,LL tim){\n\tLL ret=1;\n\tfor(;tim;tim/=2,x=x*x%mo)\n\t\tif (tim&1)ret=ret*x%mo;\n\treturn ret;\n}\n\nint n;\nLL f[N],g[N],ans[N];\n\nint main(){\n\tn=get();\n\tLL s=0;\n\tfo(i,0,(1<<n)-1)s+=(f[i]=get());\n\tLL NY=quickmi(s,mo-2);\n\tfo(i,0,(1<<n)-1)f[i]=f[i]*NY%mo;\n\tfor(int i=1;i<(1<<n);i<<=1)\n\t\tfor(int j=0;j<(1<<n);j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tLL l=f[j+k],r=f[i+j+k];\n\t\t\t\tf[i+j+k]=l<r?l-r+mo:l-r;\n\t\t\t\tf[j+k]=l+r>=mo?l+r-mo:l+r;\n\t\t\t}\n\tLL all=1,v=0;\n\tfo(i,1,(1<<n)-1){\n\t\tv=(v*(mo+1-f[i])+all*f[i])%mo;\n\t\tall=all*(mo+1-f[i])%mo;\n\t}\n\tv=(mo-v)%mo;\n\tLL A=v;\n\tg[0]=v;\n\tfo(i,1,(1<<n)-1){\n\t\tg[i]=all*quickmi((mo+1-f[i])%mo,mo-2)%mo*f[0]%mo;\n\t\tg[i]=(mo-g[i])%mo;\n\t\tA=(A+g[i])%mo;\n\t}\n\tfor(int i=1;i<(1<<n);i<<=1)\n\t\tfor(int j=0;j<(1<<n);j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tLL l=g[j+k],r=g[i+j+k];\n\t\t\t\tg[i+j+k]=l<r?l-r+mo:l-r;\n\t\t\t\tg[j+k]=l+r>=mo?l+r-mo:l+r;\n\t\t\t}\n\tLL na=quickmi(all,mo-2)%mo;\n\tfo(i,0,(1<<n)-1){\n\t\tLL B=g[i];\n\t\tans[i]=B<A?B-A+mo:B-A;\n\t\tans[i]=ans[i]*na%mo;\n\t}\n\tans[0]=0;\n\tfo(i,0,(1<<n)-1)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=1<<18,mod=998244353;\nint a[Maxn],p[Maxn],A[Maxn],B[Maxn];\nint ksm(int x,int k){\n    int ret=1,tmp=x;\n    while(k){\n        if(k&1)ret=1ll*ret*tmp%mod;\n        tmp=1ll*tmp*tmp%mod;k>>=1;\n    }\n    return ret;\n}\nint inv(int x){return ksm(x,mod-2);}\nvoid FWT(int*a,int n,int type){\n    for(int l=2;l<=n;l<<=1)\n        for(int*p=a,m=l>>1;p!=a+n;p+=l)\n            for(int i=0;i<m;i++){\n                int x=p[i],y=p[i+m];\n                p[i]=(x+y)%mod;\n                p[i+m]=(x-y)%mod;\n                if(type==-1){\n                    p[i]=1ll*p[i]*((mod+1)/2)%mod;\n                    p[i+m]=1ll*p[i+m]*((mod+1)/2)%mod;\n                }\n            }\n}\nint main(){\n    int n,sum=0;scanf(\"%d\",&n);\n    for(int i=0;i<1<<n;i++)scanf(\"%d\",&p[i]);\n    for(int i=0;i<1<<n;i++)sum=(sum+p[i])%mod;\n    for(int i=0;i<1<<n;i++)p[i]=1ll*p[i]*inv(sum)%mod;\n    for(int i=0;i<1<<n;i++)A[i]=p[i]-(i==0),B[i]=-1+(i==0)*(1<<n);\n    FWT(A,1<<n,1);FWT(B,1<<n,1);\n    for(int i=0;i<1<<n;i++)A[i]=1ll*B[i]*inv(A[i])%mod;\n    FWT(A,1<<n,-1);\n    for(int i=0;i<1<<n;i++)\n        cout<<((A[i]-A[0])%mod+mod)%mod<<\" \\n\"[i==(1<<n)-1];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = 119 << 23 | 1;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid XORFFT(vector<int>& a, int n, int p, int invert) {\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j += i << 1) {\n            for (int k = 0; k < i; k++) {\n                int u = a[j + k], v = a[i + j + k];\n                a[j + k] = u + v;\n                if (a[j + k] >= p) a[j + k] -= p;\n                a[i + j + k] = u - v;\n                if (a[i + j + k] < 0) a[i + j + k] += p;\n            }\n        }\n    }\n    if (invert) {\n        long long inv = fpow(n, p - 2, p);\n        for (int i = 0; i < n; i++) a[i] = a[i] * inv % p;\n    }\n}\n\nvoid chemthan() {\n    int n; cin >> n;\n    vi a(1 << n);\n    int sum = 0;\n    for (int& x : a) cin >> x, addmod(sum, x);\n    db(sum) endln;\n    for (int& x : a) x = mult(x, inv(sum));\n    vi b(1 << n);\n    FOR(i, 0, 1 << n) submod(b[i], 1);\n    b[0] = fpow(2, n);\n    submod(b[0], 1);\n    XORFFT(a, 1 << n, MOD, 0);\n    XORFFT(b, 1 << n, MOD, 0);\n    FOR(i, 0, 1 << n) a[i] = mult(b[i], inv(a[i] - 1 + MOD));\n    XORFFT(a, 1 << n, MOD, 1);\n    FOR(i, 0, 1 << n) cout << (a[i] - a[0] + MOD) % MOD << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int P=998244353;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\nint qsm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint n,a[1048576],lim,S;\nvoid FWT(int *a){\n\tfor(register int i=1;i<lim;i<<=1)\n\t\tfor(register int j=0;j<lim;j+=(i<<1))\n\t\t\tfor(register int k=0;k<i;++k){\n\t\t\t\tconst int Ny=a[i+j+k];\n\t\t\t\ta[i+j+k]=sub(a[j+k],Ny);\n\t\t\t\ta[j+k]=add(a[j+k],Ny);\n\t\t\t}\n}\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar((x%10)+'0');\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tlim=1<<n;\n\tfor(register int i=0;i<lim;++i)S=add(S,a[i]=read()),a[i]=sub(0,a[i]);\n\ta[0]=add(a[0],S);\n\tFWT(a);\n\tfor(register int i=1;i<lim;++i)a[i]=mul(qsm(a[i],P-2),S),a[0]=0;\n\tFWT(a);\n\tfor(register int i=0;i<lim;++i)write(sub(a[0],a[i])),putchar('\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N, a, b, c, d;\n  cin >> N >> a >> b >> c >> d;\n  int ans = 0;\n  int x = 0;\n  int y = 0;\n  string S;\n  cin >> S;\n  string T = S;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int l = 0;\n  int m = 0;\n  if(c < b){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else if(b < c && c < d){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else{\n    S[b+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        e++;\n        break;\n      }\n    }\n    S[b+1] = '.';\n    for(int i = b+1; i <= d; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        f++;\n        break;\n      }\n    }\n    if(e == 0 && f == 0){\n      cout << \"Yes\";\n      return 0;\n    }\n    l = 0;\n    m = 0;\n    T[c+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(T[i] == '#' && T[i+1] == '#'){\n        g++;\n        break;\n      }\n    }\n    for(int i = a+1; i <= c; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n   \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = (1 << 18) + 5;\nconst LL MOD = 998244353;\nconst LL INV2 = (MOD + 1) >> 1;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, len;\nLL p[MAXN], psum, a[MAXN];\n\ninline LL ksm(LL x, LL k) {\n\tLL ret = 1;\n\twhile (k) {\n\t\tif (k & 1) ret = ret * x % MOD;\n\t\tx = x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid FWT(LL *a) {\n\tfor (int i=1;i<len;i<<=1) {\n\t\tint p = i << 1;\n\t\tfor (int j=0;j<len;j+=p) {\n\t\t\tfor (int k=0;k<i;++k) {\n\t\t\t\tLL x = a[j+k], y = a[j+k+i];\n\t\t\t\ta[j+k] = (x + y) % MOD;\n\t\t\t\ta[j+k+i] = (x - y + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid IFWT(LL *a) {\n\tfor (int i=1;i<len;i<<=1) {\n\t\tint p = i << 1;\n\t\tfor (int j=0;j<len;j+=p) {\n\t\t\tfor (int k=0;k<i;++k) {\n\t\t\t\tLL x = a[j+k], y = a[j+k+i];\n\t\t\t\ta[j+k] = (x + y) * INV2 % MOD;\n\t\t\t\ta[j+k+i] = (x - y + MOD) * INV2 % MOD;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init() {\n\tread(n); len = 1 << n;\n\tfor (int i=0;i<len;++i) {\n\t\tread(p[i]);\n\t\tpsum += p[i];\n\t}\n\tpsum = ksm(psum, MOD - 2);\n\tfor (int i=0;i<len;++i) {\n\t\tp[i] = p[i] * psum % MOD;\n\t\ta[i] = MOD - 1;\n\t}\n\tp[0] = (p[0] - 1 + MOD) % MOD;\n\ta[0] = len - 1;\n}\n\nvoid solve() {\n\tFWT(a); FWT(p);\n\tfor (int i=0;i<len;++i) {\n\t\ta[i] = a[i] * ksm(p[i], MOD - 2) % MOD;\n\t}\n\tIFWT(a);\n\tfor (int i=0;i<len;++i) {\n\t\tprintf(\"%lld\\n\", (a[i] - a[0] + MOD) % MOD);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << (x) << endl;\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid wri(ll x){write(x),pc(' ');}\nvoid writeln(ll x){write(x),pc('\\n');}\nconst int maxn = 1e5+233;\nll mod=998244353;\nll qpow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nll inv2=(mod+1)/2;\nint n,m;\nll p[maxn],a[maxn],b[maxn];\nvoid fwt(ll a[]){\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int j=0;j<m;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tll x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)%mod;\n\t\t\t\ta[j+k+i]=(x-y+mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid ifwt(ll a[]){\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int j=0;j<m;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tll x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)*inv2%mod;\n\t\t\t\ta[j+k+i]=(x-y+mod)*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tn = read(),m = 1 << n;\n\tll sum = 0;\n\trep(i,0,m){\n\t\tp[i] = read();\n\t\tsum = (sum + p[i]) % mod;\n\t}sum = qpow(sum,mod-2);\n\ta[0] = m-1;rep(i,1,m) a[i] = mod - 1;\n\trep(i,0,m) b[i] = p[i] * sum % mod;b[0] = (b[0]+mod-1)%mod;\n\tfwt(a);fwt(b);\n\trep(i,0,m) a[i]=1ll*a[i]*qpow(b[i],mod-2)%mod;\n\tifwt(a);\n\trep(i,0,1<<n) writeln((a[i]-a[0]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nint n,m,i,j,a[262144],p[262144],sum,mod=998244353,i2=(mod+1)/2;;\nint qp(int x,int y)\n{\n\tint z=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\tz=1ll*z*x%mod;\n\t\t}\n\t\ty/=2;\n\t\tx=1ll*x*x%mod;\n\t}\n\treturn z;\n}\nvoid fwt(int *a,int len)\n{\n\tint i,j;\n\tfor(i=1;i<len;i*=2){\n\t\tfz0k(j,len)if(!(i&j)){\n\t\t\tint x=a[j],y=a[j+i];\n\t\t\ta[j]=x+y;if(a[j]>=mod)a[j]-=mod;\n\t\t\ta[j+i]=x-y;if(a[j+i]<0)a[j+i]+=mod;\n\t\t}\n\t}\n}\nvoid ifwt(int *a,int len)\n{\n\tint i,j;\n\tfor(i=1;i<len;i*=2){\n\t\tfz0k(j,len)if(!(i&j)){\n\t\t\tint x=a[j],y=a[j+i];\n\t\t\ta[j]=x+y;if(a[j]>=mod)a[j]-=mod;\n\t\t\ta[j+i]=x-y;if(a[j+i]<0)a[j+i]+=mod;\n\t\t\ta[j]=1ll*a[j]*i2%mod;a[j+i]=1ll*a[j+i]*i2%mod;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);m=(1<<n);\n\tfz0k(i,m){\n\t\tscanf(\"%d\",&p[i]);\n\t\tsum=(sum+p[i])%mod;\n\t}\n\tsum=qp(sum,mod-2);\n\tfz0k(i,m){\n\t\tp[i]=1ll*p[i]*sum%mod;\n\t}\n\tdec(p[0],1)\n\ta[0]=m-1;\n\tfz1(i,m-1){\n\t\ta[i]=mod-1;\n\t}\n\tfwt(a,m);fwt(p,m);\n\tfz0k(i,m){\n\t\ta[i]=1ll*a[i]*qp(p[i],mod-2)%mod;\n\t}\n\tifwt(a,m);\n\tint t=a[0];\n\tfz0k(i,m){\n\t\tdec(a[i],t);\n\t\tprintf(\"%d\\n\",a[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=998244353;\nconst int N=300000;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint n,S,a[N],b[N],c[N];\nvoid divide(int *a,int *b,int *c,int n){\n\tif (n==1){\n\t\tc[0]=b[0]*1ll*power(a[0],mo-2)%mo;\n\t\treturn;\n\t}\n\tn>>=1;\n\tFor(i,0,n-1){\n\t\tint x,y;\n\t\tx=a[i],y=a[i+n];\n\t\ta[i]=(x+y)%mo; a[i+n]=(x+mo-y)%mo;\n\t\tx=b[i],y=b[i+n];\n\t\tb[i]=(x+y)%mo; b[i+n]=(x+mo-y)%mo;\n\t}\n\tdivide(a,b,c,n);\n\tdivide(a+n,b+n,c+n,n);\n\tFor(i,0,n-1){\n\t\tint x,y;\n\t\tx=c[i],y=c[i+n];\n\t\tc[i]=(x+y)%mo; c[i+n]=(x+mo-y)%mo;\n\t\tc[i]=1ll*c[i]*(mo+1)/2%mo;\n\t\tc[i+n]=1ll*c[i+n]*(mo+1)/2%mo;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,0,(1<<n)-1){\n\t\tscanf(\"%d\",&a[i]);\n\t\tS=(S+a[i])%mo;\n\t}\n\tS=power(S,mo-2);\n\tFor(i,0,(1<<n)-1) a[i]=1ll*a[i]*S%mo;\n\tFor(i,0,(1<<n)-1) b[i]=(i?mo-1:(1<<n)-1);\n\ta[0]=(a[0]+mo-1)%mo;\n\tdivide(a,b,c,1<<n);\n\tFor(i,0,(1<<n)-1)\n\t\tprintf(\"%d\\n\",(c[i]+mo-c[0])%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1)r = r * a % P;\n    a = a * a % P;\n    w/=2;\n  }\n  return r;\n}\nint mul(int a,int b){\n  return a * b % P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)\n    a += P;\n}\nvector<int> licz(vector<int> a, vector<int> b, int n){\n  if(n == 1){\n    return {mul(b[0], pot(a[0], P-2))};\n  }\n  vector<int> a1(n/2),b1(n/2);\n  R(i,n/2){\n    a1[i] = a[i*2];\n    add(a1[i], a[i*2+1]);\n    b1[i] = b[i*2];\n    add(b1[i], b[i*2+1]);\n  }\n  vector<int> r1 = licz(a1,b1,n/2);\n  vector<int> a2(n/2),b2(n/2);\n  R(i,n/2){\n    a2[i] = a[i*2];\n    sub(a2[i], a[i*2+1]);\n    b2[i] = b[i*2];\n    sub(b2[i], b[i*2+1]);\n  }\n  vector<int> r2 = licz(a2,b2,n/2);\n  vector<int> res(n);\n  R(i,n/2){\n    res[i*2] = mul(r1[i] + r2[i],(P+1)/2);\n    res[i*2+1] = mul(r1[i] + P - r2[i], (P+1)/2);\n  }\n  return res;\n}\nint n;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  vector<int> a(1 << n);\n  int sum = 0;\n  R(i,1 << n){\n    cin >> a[i];\n    sum += a[i];\n  }\n  int odw = pot(sum, P-2);\n  R(i,1 << n){\n    a[i] = mul(a[i], odw);\n  }\n  add(a[0], P-1);\n  vector<int> b(1 << n, P - 1);\n  b[0] = (1 << n) - 1;\n  vector<int> res = licz(a,b,1 << n);\n  int pom = res[0];\n  R(i,1 << n){\n    sub(res[i],pom);\n    cout << res[i] << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inver(a) power(a, mod - 2)\nusing namespace std; \ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f; \n}\ntypedef long long ll;\nconst int mod = 998244353;\nconst int maxn = 1 << 18;\nint r2;\nint n, p[maxn];\nint a[maxn];\ninline int add(int x) {\n\treturn x >= mod ? x - mod : x;\n}\ninline int dec(int x) {\n\treturn x < 0 ? x + mod : x;\n}\nll power(ll x, ll y) {\n\tll re = 1;\n\twhile(y) {\n\t\tif(y & 1) re = re * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\nvoid FWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = add(x + y);\n\t\t\t\t*v = dec(x - y);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid IFWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = (ll)(x + y) * r2 % mod;\n\t\t\t\t*v = (ll)(x - y) * r2 % mod; *v = dec(*v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid init() {\n\tr2 = inver(2);\n\tint sum = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tsum += p[i];\n\t}\n\tsum = inver(sum);\n\tfor(int i = 0; i < n; ++i) {\n\t\tp[i] = (ll)p[i] * sum % mod;\n\t}\n}\nvoid solve() {\n\tinit();\n\tp[0] = dec(p[0] - 1);\n\ta[0] = n - 1;\n\tfor(int i = 1; i < n; ++i) {\n\t\ta[i] = mod - 1;\n\t}\n\tFWT(a, n), FWT(p, n);\n\tfor(int i = 0; i < n; ++i) {\n\t\ta[i] = a[i] * inver(p[i]) % mod;\n\t}\n\tIFWT(a, n);\n\tll rec = a[0];\n\tFWT(a, n);\n\ta[0] = (ll)(mod - rec) * n % mod;\n\tIFWT(a, n);\n}\nint main() {\n\tread(n), n = 1 << n;\n\tfor(int i = 0; i < n; ++i) {\n\t\tread(p[i]);\n\t}\n\tsolve();\n\tfor(int i = 0; i < n; ++i) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1<<18;\nconst int mod=998244353;\nconst int inv2=mod+1>>1;\n\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(ll)ans*a%mod;\n\t\tb>>=1;\n\t\ta=(ll)a*a%mod;\n\t}\n\treturn ans;\n}\n\nint A[maxn],B[maxn],C[maxn];\nint n,M;\n\ninline void FWT(int *p)\n{\n\tfor(int i=1;i<M;i<<=1)\n\t\tfor(int j=0;j<M;j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tint x=p[j+k],y=p[i+j+k];\n\t\t\t\tp[j+k]=(x+y)%mod;\n\t\t\t\tp[i+j+k]=(x-y)%mod;\n\t\t\t}\n}\n\ninline void IFWT(int *p)\n{\n\tfor(int i=1;i<M;i<<=1)\n\t\tfor(int j=0;j<M;j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tint x=p[j+k],y=p[i+j+k];\n\t\t\t\tp[j+k]=(ll)(x+y)%mod;\n\t\t\t\tp[i+j+k]=(ll)(x-y+mod)%mod;\n\t\t\t}\n}\n\ninline void init()\n{\n\tn=read();M=1<<n;\n\tint sum=0;\n\tREP(i,0,M-1)A[i]=read(),sum+=A[i];\n\tsum=power(sum,mod-2);\n\tREP(i,0,M-1)A[i]=(ll)(A[i])*sum%mod;\n\tFWT(A); \n\tREP(i,0,M-1)A[i]=(ll)power(1-A[i]+mod,mod-2)%mod;\n\tIFWT(A);\n}\n\ninline void doing()\n{\n\tputs(\"0\");\n\tREP(i,1,M-1)\n\t{\n\t\tint res=(A[0]-A[i]+mod)%mod;\n\t\tprintf(\"%d\\n\",res);\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid fwt(int n, int to[])\n{\n\trep(i, n) rep(j, 1 << n)\n\tif(j >> i & 1) {\n\t\tint lj = j ^ 1 << i;\n\t\tint d0 = to[lj], d1 = to[j];\n\t\tto[lj] = (d0 + d1) % MOD;\n\t\tto[j] = (d0 - d1 + MOD) % MOD;\n\t}\n}\n\nint n, a[262144];\nint dat[2][262144], datd[2][262144];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, 1 << n) scanf(\"%d\", &a[i]);\n\t\n\tint sum = 0;\n\trep(i, 1 << n) sum = (sum + a[i]) % MOD;\n\tsum = power(sum, MOD - 2);\n\trep(i, 1 << n) a[i] = 1LL * a[i] * sum % MOD;\n\tfwt(n, a);\n\t\n\trep(i, 1 << n) {\n\t\tif(a[i] == 1) dat[1][i] = 1;\n\t\telse dat[0][i] = power((1 - a[i] + MOD) % MOD, MOD - 2);\n\t\tif(a[i] == 1) datd[1][i] = 1;\n\t\telse datd[1][i] = 1LL * a[i] * power((1 - a[i] + MOD) % MOD, MOD - 3) % MOD;\n\t}\n\t\n\tfwt(n, dat[0]);\n\tfwt(n, dat[1]);\n\tfwt(n, datd[0]);\n\tfwt(n, datd[1]);\n\t\n\trep(i, 1 << n) {\n\t\tint hv = (dat[0][0] - dat[0][i] + MOD) % MOD;\n\t\tprintf(\"%d\\n\", hv);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define Int register int\n\nconst int MAXN = 18, MAXL = 1 << 18, MOD = 998244353, Inv2 = MOD + 1 >> 1;\nint n, m, a[MAXL + 5], F[MAXL + 5], G[MAXL + 5], H[MAXL + 5];\n\ninline int qkpow ( int a, int b, const int p = MOD ) {\n\tint ret = 1;\n\tfor ( ; b; a = 1LL * a * a % p, b >>= 1 ) ret = 1LL * ret * ( b & 1 ? a : 1 ) % p;\n\treturn ret;\n}\n\ninline void FWT_XOR ( int* A, const int n, const int tp ) {\n\tfor ( Int i = 2, stp = 1; i <= n; i <<= 1, stp <<= 1 ) {\n\t\tfor ( Int j = 0; j < n; j += i ) {\n\t\t\tfor ( Int k = j, t; k < j + stp; ++ k ) {\n\t\t\t\tt = A[k];\n\t\t\t\tA[k] = ( A[k] + A[k + stp] ) % MOD;\n\t\t\t\tA[k + stp] = ( ( t - A[k + stp] ) % MOD + MOD ) % MOD;\n\t\t\t\tif ( ! ~ tp ) {\n\t\t\t\t\tA[k] = 1LL * A[k] * Inv2 % MOD;\n\t\t\t\t\tA[k + stp] = 1LL * A[k + stp] * Inv2 % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void Work () {\n\tscanf ( \"%d\", &n ), m = 1 << n;\n\tint s = 0;\n\tfor ( Int i = 0; i ^ m; ++ i ) {\n\t\tscanf ( \"%d\", &a[i] );\n\t\ts = ( s + a[i] ) % MOD;\n\t}\n\tfor ( Int i = 0, invs = qkpow ( s, MOD - 2 ); i ^ m; ++ i ) {\n\t\tG[i] = 1LL * a[i] * invs % MOD;\n\t\tH[i] = MOD - 1;\n\t}\n\tG[0] = ( G[0] - 1 + MOD ) % MOD, H[0] = ( H[0] + m ) % MOD;\n\tFWT_XOR ( G, m, 1 ), FWT_XOR ( H, m, 1 );\n\tfor ( Int i = 1; i ^ m; ++ i ) F[i] = 1LL * H[i] * qkpow ( G[i], MOD - 2 ) % MOD;\n\tFWT_XOR ( F, m, -1 );\n\tfor ( Int i = 0; i ^ m; ++ i ) printf ( \"%d\\n\", ( ( F[i] - F[0] ) % MOD + MOD ) % MOD );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N, a, b, c, d;\n  cin >> N >> a >> b >> c >> d;\n  int ans = 0;\n  int x = 0;\n  int y = 0;\n  string S;\n  cin >> S;\n  string T = S;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int l = 0;\n  int m = 0;\n  if(c < b){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else if(b < c && c < d){\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        cout << \"No\";\n        return 0;\n      }\n    }\n    cout << \"Yes\";\n  }\n  else{\n    S[b+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        e++;\n        break;\n      }\n    }\n    S[b+1] = '.';\n    for(int i = b+1; i <= d; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n    for(int i = b; i <= d; i++){\n      if(S[i] == '#' && S[i+1] == '#'){\n        f++;\n        break;\n      }\n    }\n    if(e == 0 && f == 0){\n      cout << \"Yes\";\n      return 0;\n    }\n    l = 0;\n    m = 0;\n    T[c+1] = '#';\n    for(int i = a; i <= c; i++){\n      if(T[i] == '#' && T[i+1] == '#'){\n        g++;\n        break;\n      }\n    }\n    for(int i = a+1; i <= c; i++){\n     if(S[i] == '#'){\n       l++;\n     }\n     else{\n       m++;\n     }\n    }\n    if(l > m){\n      cout << \"No\";\n      return 0;\n    }\n    for(int i = b; i <= d; i++){\n      if(T[i] == '#' && T[i+1] == '#'){\n        h++;\n        break;\n      }\n    }\n    if(g == 0 && h == 0){\n      cout << \"Yes\";\n      return 0;\n    }\n    cout << \"No\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 301000\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar();\n\twhile (!isdigit(c))\tc = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n}\nusing namespace std;\nconst int P = 998244353;\nconst int inv2 = 499122177;\ninline ll quickpow(ll x, int k) {\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1)\tres = res * x % P;\n\t\tx = x * x % P;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\nint n, nn;\nll p[N], I[N], f[N];\ninline void FWT(ll *a, int type) {\n\tfor (int i = 1; i < nn; i <<= 1) {\n\t\tfor (int j = 0; j < nn; j += (i << 1)) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tif (type == 1) {\n\t\t\t\t\tint nx = a[j + k], ny = a[i + j + k];\n\t\t\t\t\ta[j + k] = (nx + ny) % P;\n\t\t\t\t\ta[i + j + k] = (nx - ny + P) % P;\n\t\t\t\t} else {\n\t\t\t\t\tint nx = a[j + k], ny = a[i + j + k];\n\t\t\t\t\ta[j + k] = 1ll * inv2 * (nx + ny) % P;\n\t\t\t\t\ta[i + j + k] = 1ll * inv2 * (nx - ny + P) % P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tread(n); nn = (1 << n);\n\tll tot = 0;\n\tfor (int i = 0; i < nn; ++i)\tread(p[i]), tot += p[i];\n\ttot = quickpow(tot % P, P - 2);\n\tfor (int i = 0; i < nn; ++i)\tp[i] = p[i] * tot % P;\n\tp[0] = (p[0] - 1 + P) % P;\n\tI[0] = nn - 1;\n\tfor (int i = 1; i < nn; ++i)\tI[i] = P - 1;\n\tFWT(p, 1); FWT(I, 1);\n\ttot = 0;\n\tfor (int i = 1; i < nn; ++i)\tf[i] = I[i] * quickpow(p[i], P - 2) % P, tot += f[i];\n\tf[0] = P - tot % P;\n\tFWT(f, -1);\n\tfor (int i = 0; i < nn; ++i)\tprintf(\"%lld\\n\", f[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int INV2 = (MOD+1)/2;\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nvoid fwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD, f[j | i] = (x+MOD - y)%MOD;\n            }\n        }\n    }\n}\ntemplate <typename T>\nvoid ifwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD * INV2%MOD, f[j | i] = (x+MOD - y)%MOD*INV2%MOD;\n            }\n        }\n    }\n}\n\n     signed main(){\n\n  int n;\n  cin>>n;\n vector<int> a(1ll<<n),b(1ll<<n,1),c(1ll<<n,0);\n  for(int i=0;i<(1ll<<n);i++)cin>>a[i];\n c[0]=1;\n int al=0;\n for(int i=0;i<(1ll<<n);i++)al=(al+a[i])%MOD;\n al=modpow(al,MOD-2,MOD);\n for(int i=0;i<(1ll<<n);i++)a[i]=(a[i]*al)%MOD;\n  fwt(a);fwt(b);fwt(c);\n   //  for(int i=0;i<(1ll<<n);i++)cerr<<a[i]<<' '<<b[i]<<' '<<c[i]<<endl;\n     if(a[0]!=1){\n  for(int i=0;i<(1ll<<n);i++)b[i]=(b[i]*modpow((1+MOD-a[i])%MOD,MOD-2,MOD))%MOD;\n    for(int i=0;i<(1ll<<n);i++)c[i]=(c[i]*modpow((1+MOD-a[i])%MOD,MOD-2,MOD))%MOD;\n    //  for(int i=0;i<(1ll<<n);i++)cerr<<b[i]<<' '<<c[i]<<endl;\n    ifwt(b),ifwt(c);\n    int t=b[0]*modpow(c[0],MOD-2,MOD)%MOD;\n\n    for(int i=0;i<(1ll<<n);i++)cout<<(b[i]+MOD-c[i]*t%MOD)%MOD<<endl;\n     }else{\n     c[0]=0;\n       for(int i=1;i<(1ll<<n);i++){\n         c[i]=(MOD - (1ll<<n)%MOD*modpow((1+MOD-a[i])%MOD,MOD-2,MOD));\n         c[0]=(c[0]+MOD-c[i])%MOD;\n       }\n       // for(int i=0;i<(1ll<<n);i++)cout<<c[i]<<endl;\n       ifwt(c);\n       for(int i=0;i<(1ll<<n);i++)cout<<c[i]<<endl;\n     }\n \n\n\n\n\n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1<<18,mo=998244353,inv2=(mo+1>>1);\nll a[N],b[N],n,c[N];\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nvoid fwt(ll *a,int M=1<<n){\n\tfor (int n=1;n<M;n<<=1)\n\t\tfor (int i=n;i<M;i=(i+1)|n){\n\t\t\tll z=a[i^n];\n\t\t\ta[i^n]=(a[i]+a[i^n])%mo;\n\t\t\ta[i]=(z-a[i]+mo)%mo;\n\t\t}\n}\nvoid ifwt(ll *a,int M=1<<n){\n\tfor (int n=1;n<M;n<<=1)\n\t\tfor (int i=n;i<M;i=(i+1)|n){\n\t\t\tll z=a[i^n];\n\t\t\ta[i^n]=(a[i]+a[i^n])*inv2%mo;\n\t\t\ta[i]=(z-a[i]+mo)*inv2%mo;\n\t\t}\n}\nint main(){\n\tcin>>n;\n\tll sum=0;\n\tfor (int i=0;i<1<<n;i++)scanf(\"%lld\",&a[i]),sum+=a[i],b[i]=mo-1;\n\tsum=power(sum);\n\tfor (int i=0;i<1<<n;i++)a[i]=a[i]*sum%mo;\n\tfwt(a);fwt(b);\n\tsum=0;\n\tll G=(1<<n)-1;\n\tfor (int i=1;i<1<<n;i++)c[i]=(G+1)*power(a[i]-1)%mo,c[0]=(c[0]+(mo-c[i]))%mo;\n\tifwt(c);\n\tfor (int i=0;i<1<<n;i++)printf(\"%lld\\n\",(c[i]%mo+mo)%mo);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = (1 << 18) + 3;\nint n;\nll a[N];\nll b[N];\nll c[N];\nll S;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tS += a[i];\n\t}\n\tS = rev(S);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\ta[i] = mult(a[i], S);\n\tS = rev(1 << n);\n\tb[0] = sub(S, 1);\n\tfor (int i = 1; i < (1 << n); i++)\n\t\tb[i] = S;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tif ((mask >> k) & 1) continue;\n\t\t\tll x = a[mask], y = a[mask ^ (1 << k)];\n\t\t\ta[mask] = add(x, y);\n\t\t\ta[mask ^ (1 << k)] = sub(x, y);\n\t\t\tx = b[mask];\n\t\t\ty = b[mask ^ (1 << k)];\n\t\t\tb[mask] = add(x, y);\n\t\t\tb[mask ^ (1 << k)] = sub(x, y);\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tc[i] = mult(mult(b[i], 1), rev(sub(a[i], 1)));\n\t}\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t\tif ((mask >> k) & 1) continue;\n\t\t\tll x = c[mask], y = c[mask ^ (1 << k)];\n\t\t\tc[mask] = add(x, y);\n\t\t\tc[mask ^ (1 << k)] = sub(x, y);\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tprintf(\"%lld\\n\", sub(c[0], c[i]));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 262154, mod = 998244353;\n\nint n, ALL;\nint f[N], p[N];\n\ninline int & reduce(int &x) {return x += x >> 31 & mod;}\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid FWT(int *a) {\n\tint i, j, k, r, len = 1;\n\tfor (i = 0; i < n; ++i, len <<= 1)\n\t\tfor (j = 0; j <= ALL; j += len << 1)\n\t\t\tfor (k = j; k < j + len; ++k)\n\t\t\t\tr = a[k + len], reduce(a[k + len] = a[k] - r), add(a[k], r);\n}\n\nint main() {\n\tint i; ll s = 0;\n\tscanf(\"%d\", &n), ALL = ~(-1 << n);\n\tfor (i = 0; i <= ALL; ++i) scanf(\"%d\", p + i), s += p[i];\n\ts = PowerMod(s, mod - 2);\n\tfor (i = 0; i <= ALL; ++i) p[i] = p[i] * s % mod;\n\ts = 0, FWT(p);\n\tfor (i = 1; i <= ALL; ++i) s += f[i] = PowerMod(mod + 1 - p[i], mod - 2, mod - 1);\n\treduce(*f = -s % mod), FWT(f);\n\tfor (i = 0; i <= ALL; ++i) printf(\"%d\\n\", f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nusing std::complex;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\ntypedef complex<double> cd;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst long long MOD = 998244353;\nconst long long rev2 = (MOD + 1) / 2;\n\nint n, s;\nint a[500000];\n\nll inq(ll x, ll y)\n{\n    if (!y) return 1;\n    ll l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nvector<int> solve(vector<int> b, vector<int> z)\n{\n    int n = b.size();\n    if (n == 1)\n    {\n        if (b[0] == 0 && z[0] == 0)\n        {\n            return {1};\n        }\n        return {z[0] * inq(b[0], MOD - 2) % MOD};\n    }\n    vector<int> b0(n / 2), b1(n / 2), z0(n / 2), z1(n / 2);\n    for (int i = 0; i < n / 2; i++)\n    {\n        b0[i] = (b[2 * i] + b[2 * i + 1]) % MOD;\n        z0[i] = (z[2 * i] + z[2 * i + 1]) % MOD;\n        b1[i] = (b[2 * i] - b[2 * i + 1] + MOD) % MOD;\n        z1[i] = (z[2 * i] - z[2 * i + 1] + MOD) % MOD;\n    }\n    vector<int> x0 = solve(b0, z0), x1 = solve(b1, z1);\n    vector<int> x(n);\n    for (int i = 0; i < n / 2; i++)\n    {\n        x[2 * i] = (x0[i] + x1[i]) * rev2 % MOD;\n        x[2 * i + 1] = (x0[i] + MOD - x1[i]) * rev2 % MOD;\n    }\n    return x;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < (1 << n); i++)\n    {\n        cin >> a[i];\n        s += a[i];\n    }\n    vector<int> p(1 << n), z(1 << n);\n    for (int i = 0; i < (1 << n); i++)\n    {\n        p[i] = a[i] * inq(s, MOD - 2) % MOD;\n        z[i] = MOD - 1;\n    }\n    z[0] = (1 << n) - 1;\n    p[0] = (p[0] + MOD - 1) % MOD;\n    vector<int> x = solve(p, z);\n    for (int i = 0; i < (1 << n); i++)\n    {\n        cout << (x[i] - x[0] + MOD) % MOD << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 18\n#define mod 998244353\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,tot,a[1<<MN],b[1<<MN];pa f[1<<MN];\ninline int Div2(int x){return (x&1)?(x+mod>>1):(x>>1);}\ninline pa Div2(pa y){return make_pair(Div2(y.first),Div2(y.second));}\npa operator + (const pa&x,const pa&y){return make_pair((x.first+y.first)%mod,(x.second+y.second)%mod);}\npa operator - (const pa&x,const pa&y){return make_pair((x.first-y.first+mod)%mod,(x.second-y.second+mod)%mod);}\npa operator * (const pa&x,int y){return make_pair(1LL*x.first*y%mod,1LL*x.second*y%mod);}\ninline int pw(int x,int k)\n{\n    int res=1;\n    for(;k;k>>=1,x=1LL*x*x%mod) if(k&1) res=1LL*res*x%mod;\n    return res;\n}\nvoid FWT(int*x)\n{\n    for(int i=2;i<=1<<n;i<<=1) for(int j=0;j<1<<n;j+=i) for(int k=0;k<(i>>1);++k)\n    {\n        int l=j+k,r=j+k+(i>>1),A=x[l],B=x[r];\n        x[l]=(A+B)%mod;x[r]=(A-B+mod)%mod;\n    }\n}\nvoid IFWT(pa*x)\n{\n    for(int i=2;i<=1<<n;i<<=1) for(int j=0;j<1<<n;j+=i) for(int k=0;k<(i>>1);++k)\n    {\n        int l=j+k,r=j+k+(i>>1);pa A=x[l],B=x[r];\n        x[l]=A+B;x[r]=A-B;\n        x[l]=Div2(x[l]),x[r]=Div2(x[r]);\n    }\n}\nint main()\n{\n    n=read();\n    for(int i=0;i<1<<n;++i) a[i]=read(),tot+=a[i];\n    tot=pw(tot,mod-2); \n    for(int i=0;i<1<<n;++i) b[i]=a[i]=1LL*a[i]*tot%mod;\n    FWT(a);f[0].first=1;b[0]=0;\n    for(int i=1;i<1<<n;++i) f[i].second=(1LL<<n)*pw(a[i]-1,mod-2)%mod;\n    IFWT(f);pa F(0,1);\n    for(int i=0;i<1<<n;++i) F=F+f[i]*b[i];\n    assert(F.first!=0);\n    int num=1LL*((1<<n)+mod-F.second)*pw(F.first,mod-2)%mod;\n    puts(\"0\");\n    for(int i=1;i<1<<n;++i) printf(\"%d\\n\",(1LL*num*f[i].first+f[i].second)%mod);\n\treturn 0;\n}\n/*\nf1+1 f2+1 ... fn+1\np1 p2 ... pn     FWT(^)->\nf1+y f2 ... fn   (y=sigma fipi)\nF:对f数组FWT\nF1+(2^n) F2 ... Fn\nP1 P2 ... Pn\nF1+y F2+y ... Fn+y\n可发现y=2^n\n知道Fn之后，P1是1没法求F1,用F1表示F2...Fn，带着变量做fwt，解出F1\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int MOD(998244353);\nconst int Max_N(18);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int squ(int x)\n{\n\treturn Mult(x, x);\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nint N, A[1 << Max_N], E[1 << Max_N], SumA;\n\nvoid FWT(int F[1 << Max_N], bool inv = false)\n{\n\tfor (int i = 0;i <= N - 1;++i)\n\t\tfor (int S = 0, x, y;S < (1 << N);++S)\n\t\t\tif ((S & (1 << i)) == 0)\n\t\t\t{\n\t\t\t\tx = F[S], y = F[S + (1 << i)];\n\t\t\t\tF[S] = Add(x, y), F[S + (1 << i)] = Sub(x, y);\n\t\t\t}\n\tif (inv)\n\t\tfor (int S = 0, invL = inverse(1 << N);S < (1 << N);++S)\n\t\t\tF[S] = Mult(F[S], invL);\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int S = 0;S < (1 << N);++S)\n\t\tgi(A[S]), SumA += A[S];\n\tfor (int S = 0, inv = inverse(SumA);S < (1 << N);++S)\n\t\tA[S] = Mult(A[S], inv);\n\tFWT(A);\n\tE[0] = 0;\n\tfor (int S = 1;S < (1 << N);++S)\n\t\tE[S] = inverse(Sub(A[S], 1));\n\tFWT(E, true);\n\tfor (int S = 0, G1, _G1, H1, _H1, inv = inverse(1 << N);S < (1 << N);++S)\n\t{\n\t\tG1 = inv, _G1 = E[S], H1 = inv, _H1 = E[0];\n\t\tprint(Mult(Sub(Mult(_G1, H1), Mult(G1, _H1)), inverse(squ(H1)))), putc('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nint n;\nvector<ll> a;\nvoid FWT(vector<ll> &v){\n\tint m=v.size();\n\tfor(int i=1; i<m; i<<=1){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i&j)==0){\n\t\t\t\tll x=v[j], y=v[j^i];\n\t\t\t\tv[j]=x+y, v[j^i]=x-y+MOD;\n\t\t\t\tif(v[j]>=MOD) v[j]-=MOD;\n\t\t\t\tif(v[j^i]>=MOD) v[j^i]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n;\n\ta.resize(1<<n);\n\tll s=0;\n\tfor(int i=0; i<(1<<n); i++){\n\t\tcin>>a[i];\n\t\ts+=a[i];\n\t}\n\ts=inv(s);\n\tfor(int i=0; i<(1<<n); i++){\n\t\ta[i]=a[i]*s%MOD;\n\t}\n\tvector<ll> a1=a;\n\tFWT(a);\n\tvector<ll> ans(1<<n);\n\tll t=0;\n\tfor(int i=1; i<(1<<n); i++){\n\t\tans[i]=inv((a[i]-1+MOD)%MOD);\n\t\t(t+=ans[i])%=MOD;\n\t}\n\tans[0]=(MOD-t)%MOD;\n\tFWT(ans);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tcout<<ans[i]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = 998244353;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nconst int MAXN = 18;\n\ninline void FWT(int *f, int N, int type)\n{\n\tfor(int i = 0; i < N; ++i)\n\t\tfor(int S = 0; S < 1 << N; ++S) if(!(S >> i & 1))\n\t\t{\n\t\t\tint X = f[S], Y = f[S | 1 << i];\n\t\t\tf[S] = (X + Y) % MOD;\n\t\t\tf[S | 1 << i] = (X - Y) % MOD;\n\t\t}\n\n\tif(type == -1)\n\t{\n\t\tint inv2N = inv(1 << N);\n\t\tfor(int S = 0; S < 1 << N; ++S) f[S] = (LL) f[S] * inv2N % MOD;\n\t}\n}\n\nint n;\n\nint g[1 << MAXN];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int S = 0; S < 1 << n; ++S) g[S] = read<int>();\n\n\tint sum = 0;\n\tfor(int S = 0; S < 1 << n; ++S) (sum += g[S]) %= MOD;\n\tsum = inv(sum);\n\tfor(int S = 0; S < 1 << n; ++S) g[S] = (LL) g[S] * sum % MOD;\n}\n\ninline void solve()\n{\n\tstatic int f[1 << MAXN], h[1 << MAXN];\n\n\t(g[0] -= 1) %= MOD;\n\n\tfor(int S = 0; S < 1 << n; ++S) h[S] = -1;\n\t(h[0] += 1 << n) %= MOD;\n\n\tFWT(h, n, +1);\n\tFWT(g, n, +1);\n\n\tfor(int S = 1; S < 1 << n; ++S) f[S] = (LL) h[S] * inv(g[S]) % MOD;\n\tf[0] = 0;\n\tFWT(f, n, -1);\n\n\tfor(int S = 1; S < 1 << n; ++S) (f[S] -= f[0]) %= MOD;\n\tf[0] = 0;\n\n\tfor(int S = 0; S < 1 << n; ++S) printf(\"%d\\n\", (f[S] + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\ttypedef long long ll;\n\ttypedef pair<int, int> pii;\n\tconst int N = 1 << 18 | 10, P = 998244353, INV2 = (P + 1) / 2;\n\tint n, p[N], A[N];\n\tpii f[N];\n\tint power(int a, int b)\n\t{\n\t\tint ans = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t\tans = (ll)ans * a % P;\n\t\t\ta = (ll)a * a % P;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint inv(const int a)\n\t{\n\t\treturn power(a, P - 2);\n\t}\n\tpii operator + (const pii &a, const pii &b)\n\t{\n\t\treturn pii((a.first + b.first) % P, (a.second + b.second) % P);\n\t}\n\tpii operator - (const pii &a, const pii &b)\n\t{\n\t\treturn pii((a.first - b.first + P) % P, (a.second - b.second + P) % P);\n\t}\n\tpii operator * (const pii &a, const int &b)\n\t{\n\t\treturn pii(int((ll)a.first * b % P), int((ll)a.second * b % P));\n\t}\n\tnamespace FWT\n\t{\n\t\tvoid fwt(int *const a, const int n)\n\t\t{\n\t\t\tfor (int l = 1; l < n; l <<= 1)\n\t\t\t\tfor (int i = 0; i < n; i += (l << 1))\n\t\t\t\t\tfor (int k = 0; k < l; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint x = a[i + k], y = a[i + l + k];\n\t\t\t\t\t\ta[i + k] = (x + y) % P;\n\t\t\t\t\t\ta[i + l + k] = (x - y + P) % P;\n\t\t\t\t\t}\n\t\t}\n\t\tvoid ifwt(pii *const a, const int n)\n\t\t{\n\t\t\tfor (int l = 1; l < n; l <<= 1)\n\t\t\t\tfor (int i = 0; i < n; i += (l << 1))\n\t\t\t\t\tfor (int k = 0; k < l; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpii x = a[i + k], y = a[i + l + k];\n\t\t\t\t\t\ta[i + k] = (x + y) * INV2;\n\t\t\t\t\t\ta[i + l + k] = (x - y) * INV2;\n\t\t\t\t\t} \n\t\t}\n\t}\n\tint work()\n\t{\n\t\tusing namespace FWT;\n\t\tread(n);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < (1 << n); i++)\n\t\t\tread(p[i]), sum += p[i];\n\t\tsum = inv(sum);\n\t\tfor (int i = 0; i < (1 << n); i++)\n\t\t{\n\t\t\tp[i] = (ll)p[i] * sum % P;\n\t\t\tA[i] = P - 1;\n\t\t}\n\t\tA[0] = (1 << n) - 1;\n\t\tp[0] = (p[0] - 1 + P) % P;\n\t\tfwt(p, 1 << n), fwt(A, 1 << n);\n\t\tf[0] = pii(1, 0);\n\t\tfor (int i = 1; i < (1 << n); i++)\n\t\t\tf[i] = pii(0, (ll)A[i] * inv(p[i]) % P);\n\t\tifwt(f, 1 << n);\n\t\tint x = ll(P - f[0].second) * inv(f[0].first) % P;\n\t\tfor (int i = 0; i < (1 << n); i++)\n\t\t\twrite(((ll)f[i].first * x + f[i].second) % P), putchar('\\n');\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint n,m,i,j,t,k,s,len,sump,p[20];\ninline int Pow(int x,int y)\n{\n\tint ret=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ninline int Mod(int x)\n{\n\treturn x>=mod ? x-mod : x;\n}\nstruct Poly\n{\n\tint e[300005];\n\tint& operator[](int x)\n\t{\n\t\treturn e[x];\n\t}\n\tvoid FWT(int len)\n\t{\n\t\tfor (int le=2;le<=len;le<<=1)\n\t\t for (int i=0,m=le>>1;i<len;i+=le)\n\t\t  for (int j=i,tmp;j<i+m;++j)\n\t\t   tmp=e[j+m],e[j+m]=Mod(e[j]-tmp+mod),e[j]=Mod(e[j]+tmp);\n\t}\n\tvoid IFWT(int len)\n\t{\n\t\tFWT(len);\n\t\tint tmp=Pow(len,mod-2);\n\t\tfor (int i=0;i<len;++i)\n\t\t e[i]=1ll*e[i]*tmp%mod;\n\t}\n}E,P,S;\n\nint main()\n{\n\tscanf(\"%d\",&n);len=(1<<n);\n\tfor (i=0;i<len;++i) scanf(\"%d\",&P[i]),sump+=P[i];\n\tsump=Pow(sump,mod-2);\n\tfor (i=0;i<len;++i) P[i]=1ll*P[i]*sump%mod;\n\t//--P[0];if (P[0]<0) P[0]+=mod;else P[0]=0;\n\t(--P[0])<0 ? P[0]+=mod : 0,S[0]=len-1;\n\t//S[0]=len-1;\n\tfor (i=1;i<len;++i) S[i]=mod-1;\n\tP.FWT(len);S.FWT(len);\n\tfor (i=1;i<len;++i) E[i]=1ll*S[i]*Pow(P[i],mod-2)%mod;\n\tE.IFWT(len);\n\tint tmp=mod-E[0];\n\tfor (i=0;i<len;++i) printf(\"%d\\n\",Mod(tmp+E[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define C(x,y) memset(x,y,sizeof(x))\n#define STS system(\"pause\")\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nconst int N=(1<<18)+10,Mod=998244353,inv2=499122177;\nint n,m,p[N],s,S,a[N],b[N];\nI add(int &x,int y){(x+=y)>=Mod?x-=Mod:0;}\nIN Plus(int x,int y){(x+=y)>=Mod?x-=Mod:0;return x;}\nIN Pow(int x,int y=Mod-2){\n\tre res=1;\n\twhile(y){\n\t\tif(y&1)res=(ll)res*x%Mod;\n\t\tx=(ll)x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nI fwt(int *f,int sn){\n\tfor(re i=1;i<S;i<<=1){\n\t\tfor(re p=i<<1,j=0;j<S;j+=p){\n\t\t\tF(k,0,i-1){\n\t\t\t\tre X=f[j+k],Y=f[i+j+k];\n\t\t\t\tf[j+k]=Plus(X,Y);f[i+j+k]=Plus(X,Mod-Y);\n\t\t\t\tif(sn==-1)f[j+k]=(ll)f[j+k]*inv2%Mod,f[i+j+k]=(ll)f[i+j+k]*inv2%Mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tread(n);S=1<<n;\n\tF(i,0,S-1)read(p[i]),add(s,p[i]);\n\ts=Pow(s);F(i,0,S-1)p[i]=(ll)p[i]*s%Mod;add(p[0],Mod-1);\n\tF(i,1,S-1)b[i]=Mod-1;b[0]=S-1;\n\tfwt(b,1);fwt(p,1);\n\tF(i,0,S-1)b[i]=(ll)b[i]*Pow(p[i])%Mod;\n\tfwt(b,-1);\n\tF(i,0,S-1)printf(\"%d\\n\",Plus(b[i],Mod-b[0]));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\nusing namespace std;\nconst int mod=998244353,i2=499122177;\nint n,s;\nvi a,b,ans;\nint POW(int x,int y){\n\tint ret=1;\n\twhile(y)y&1?ret=1ll*ret*x%mod:0,x=1ll*x*x%mod,y>>=1;\n\treturn ret;\n}\nvi Solve(vi x,vi y){\n\tif(x.size()==1){\n\t\tvi ret(1);\n\t\treturn ret[0]=(x[0]?1ll*y[0]*POW(x[0],mod-2)%mod:114514),ret;\n\t}\n\tvi t1(x.size()>>1),t2(y.size()>>1),a1,a2;\n\tfor(int i=0;i<t1.size();++i)(t1[i]=x[i<<1]+x[i<<1|1])>=mod?t1[i]-=mod:0,(t2[i]=y[i<<1]+y[i<<1|1])>=mod?t2[i]-=mod:0;\n\ta1=Solve(t1,t2);\n\tfor(int i=0;i<t1.size();++i)(t1[i]=x[i<<1]-x[i<<1|1])<0?t1[i]+=mod:0,(t2[i]=y[i<<1]-y[i<<1|1])<0?t2[i]+=mod:0;\n\ta2=Solve(t1,t2);\n\tfor(int i=0;i<a1.size();++i)x[i<<1]=1ll*(a1[i]+a2[i])*i2%mod,x[i<<1|1]=1ll*(a1[i]-a2[i]+mod)*i2%mod;\n\treturn x;\n}\nint main(){\n\tscanf(\"%d\",&n),a.resize(1<<n),b.resize(1<<n);\n\tfor(int i=0;i<(1<<n);++i)scanf(\"%d\",&a[i]),s+=a[i];\n\ts=POW(s,mod-2);\n\tfor(int i=0;i<(1<<n);++i)a[i]=1ll*a[i]*s%mod,b[i]=mod-1;\n\t--a[0],b[0]+=(1<<n)-mod;\n\tans=Solve(a,b);\n\tfor(int i=1;i<ans.size();++i)(ans[i]-=ans[0])<0?ans[i]+=mod:0;\n\tputs(\"0\");\n\tfor(int i=1;i<ans.size();++i)printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint int\nusing namespace std;\n     \ntypedef long long lo;\n     \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\nnamespace {\n    const int mo = 998244353;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\nconst int N = (1 << 18) + 3;\nint n, m, p[N], sum, r[N];\n\ninline void FWT(int *p, int f) {\n\tint n = ::m;\n\tfor (int l = 2; l <= n; l <<= 1)\n\t\tfor (int *a = p, m = l >> 1; a != p + n; a += l)\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tint x = a[k], y = a[k + m];\n\t\t\t\ta[k] = add(x, y); a[k + m] = sub(x, y);\n\t\t\t}\n\tif (f == -1) {\n\t\tint mult = power((mo + 1) / 2, ::n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = mul(p[i], mult);\n\t}\n}\n\nint main(void) {\n\tread(n); m = 1 << n;\n\tfor (int i = 0; i < m; i++) {\n\t\tread(p[i]); sum += p[i];\n\t}\n\tsum = power(sum);\n\tfor (int i = 0; i < m; i++) {\n\t\tp[i] = mul(p[i], sum);\n\t\tr[i] = mo - 1;\n\t}\n\tr[0] = m - 1;\n\tp[0] = sub(p[0], 1);\n\t// for (int i = 0; i < m; i++) {\n\t// \tcout << p[i] << \" \\n\"[i + 1 == m];\n\t// }\n\t// for (int i = 0; i < m; i++) {\n\t// \tcout << r[i] << \" \\n\"[i + 1 == m];\n\t// }\n\tFWT(r, 1); FWT(p, 1);\n\tfor (int i = 0; i < m; i++) \n\t\tr[i] = mul(r[i], power(p[i]));\n\tFWT(r, -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tcout << sub(r[i], r[0]) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 1<<18 , mo = 998244353;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a){return powa(a,mo-2);}\n\nconst int inv2 = inva(2);\n\ninline void fwtxor(lint a[],int nn,int dir)\n{\n\tfor(int i=1;i<nn;i<<=1)\n\t\tfor(int j=0;j<nn;j+=i+i)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tlint x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=(x+y)%mo,a[j+k+i]=(x-y+mo)%mo;\n\t\t\t\tif(dir<0)a[j+k]=a[j+k]*inv2%mo,a[j+k+i]=a[j+k+i]*inv2%mo;\n\t\t\t}\n}\n\nint n,nn;\nlint gai[_]={0},sgai=0;\nlint f[_],g[_],h[_]={0};\n\nint main()\n{\n\tn=ty(),nn=1<<n;\n\tfor(int i=0;i<nn;i++)gai[i]=ty(),sgai=(sgai+gai[i])%mo;\n\tfor(int i=0,x=inva(sgai);i<nn;i++)gai[i]=gai[i]*x%mo;\n\n\tf[0]=(gai[0]-1+mo)%mo;\n\tfor(int i=1;i<nn;i++)f[i]=gai[i];\n\th[0]=(powa(2,n)-1+mo)%mo;\n\tfor(int i=1;i<nn;i++)h[i]=mo-1;\n\n\tfwtxor(f,nn,1),fwtxor(h,nn,1);\n\tfor(int i=0;i<nn;i++)g[i]=h[i]*inva(f[i])%mo;\n\tfwtxor(g,nn,-1);\n\n\tfor(int i=0;i<nn;i++)printf(\"%lld\\n\",(g[i]-g[0]+mo)%mo);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\t\n\tconst int N = 1 << 18 | 5, mod = 998244353;\n\n\tint n, A[N], B[N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tint inv(const int x) { return x == 1 ? 1 : int((ll)inv(mod % x) * (mod - mod / x) % mod); }\n\n\tvoid FWT(int *a)\n\t{\n\t\tfor (int len = 1; len < n; len <<= 1)\n\t\t\tfor (int i = 0; i < n; i += len << 1)\n\t\t\t\tfor (int k = 0; k < len; k++)\n\t\t\t\t{\n\t\t\t\t\tint x = a[i + k], y = a[i + len + k];\n\t\t\t\t\ta[i + k] = (x + y) % mod;\n\t\t\t\t\ta[i + len + k] = (x - y + mod) % mod;\n\t\t\t\t}\n\t}\n\n\tvoid IFWT(int *a)\n\t{\n\t\tstatic const int INV2 = (mod + 1) >> 1;\n\t\tfor (int len = 1; len < n; len <<= 1)\n\t\t\tfor (int i = 0; i < n; i += len << 1)\n\t\t\t\tfor (int k = 0; k < len; k++)\n\t\t\t\t{\n\t\t\t\t\tint x = a[i + k], y = a[i + len + k];\n\t\t\t\t\ta[i + k] = int((ll)(x + y) * INV2 % mod);\n\t\t\t\t\ta[i + len + k] = int((ll)(x - y + mod) * INV2 % mod);\n\t\t\t\t}\n\t}\n\n\tvoid work()\n\t{\n\t\tn = 1 << read();\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum = (sum + (A[i] = read())) % mod;\n\t\tfor (int i = 0, tmp = inv(sum); i < n; i++)\n\t\t\tA[i] = int((ll)A[i] * tmp % mod);\n\t\tA[0] = (A[0] - 1 + mod) % mod;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tB[i] = mod - 1;\n\t\tB[0] = (n - 1 + mod) % mod;\n\t\tFWT(A), FWT(B);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tA[i] = int((ll)B[i] * inv(A[i]) % mod);\n\t\tIFWT(A);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d\\n\", (A[i] - A[0] + mod) % mod);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<string>\n\n#define maxn 3000005\n#define MOD 998244353\n#define inv2 499122177\n\nusing namespace std;\n\ninline int getint()\n{\n\tint num=0,flag=1;char c;\n\twhile((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;\n\twhile(c>='0'&&c<='9')num=num*10+c-48,c=getchar();\n\treturn num*flag;\n}\n\nint n,N;\nint E[maxn],P[maxn],I[maxn];\n\ninline int ksm(int num,int k)\n{\n\tint ret=1;\n\tfor(;k;k>>=1,num=1ll*num*num%MOD)if(k&1)ret=1ll*ret*num%MOD;\n\treturn ret;\n}\ninline void FWT_xor(int *a,int opt,int N)\n{\n\tfor(int i=1;i<N;i<<=1)for(int j=0;j<N;j+=(i<<1))\n\t\tfor(int k=0;k<i;k++)\n\t\t{\n\t\t\tint x=a[j+k],y=a[i+j+k];\n\t\t\ta[j+k]=(x+y)%MOD,a[i+j+k]=(x-y+MOD)%MOD;\n\t\t\tif(!~opt)a[j+k]=1ll*a[j+k]*inv2%MOD,a[i+j+k]=1ll*a[i+j+k]*inv2%MOD;\n\t\t}\n}\n\nint main()\n{\n\tn=getint(),N=1<<n;int s=0;\n\tfor(int i=0;i<N;i++)s+=P[i]=getint(),s%=MOD;\n\ts=ksm(s,MOD-2);\n\tfor(int i=0;i<N;i++)P[i]=1ll*P[i]*s%MOD;P[0]--;\n\tI[0]=N-1,s=0;\n\tfor(int i=1;i<N;i++)I[i]=MOD-1;\n\tFWT_xor(P,1,N),FWT_xor(I,1,N);\n\tfor(int i=1;i<N;i++)E[i]=1ll*I[i]*ksm(P[i],MOD-2)%MOD,s=(s+E[i])%MOD;\n\tE[0]=MOD-s;\n\tFWT_xor(E,-1,N);\n\tfor(int i=0;i<N;i++)printf(\"%d\\n\",E[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1<<18|1,mod=998244353;\ninline int _add(ri x,ri y){\n\treturn (x+=y)>=mod?x-mod:x;\n}\ninline int _sub(ri x,ri y){\n\treturn (x-=y)<0?x+mod:x;\n}\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1)\n\t\t\tans=(ll)ans*a%mod;\n\treturn ans;\n}\nint inv;\ninline void fwt_xor(int *a,ri n,ri opt){\n\tri i,j,k,p,x,y;\n\tfor(i=1;i<n;i<<=1)\n\t\tfor(p=i<<1,j=0;j<n;j+=p)\n\t\t\tfor(k=0;k<i;++k){\n\t\t\t\tint *b=a+j+k;\n\t\t\t\tx=_add(b[0],b[i]);\n\t\t\t\ty=_sub(b[0],b[i]);\n\t\t\t\tb[0]=x;b[i]=y;\n\t\t\t}\n\tif(opt==-1)\n\t\tfor(i=0;i<n;++i)\n\t\t\ta[i]=(ll)a[i]*inv%mod;\n}\nint a[N],b[N];\nint main(){\n\tri n,m,i,s;\n\tgi(n);\n\tm=1<<n;\n\tinv=fpow(m,mod-2);\n\ts=0;\n\tfor(i=0;i^m;++i) gi(a[i]),s+=a[i];\n\ts=fpow(s,mod-2);\n\tfor(i=0;i^m;++i) a[i]=(ll)a[i]*s%mod;\n\ta[0]=_sub(a[0],1);\n\tb[0]=m-1;\n\tfor(i=1;i^m;++i) b[i]=mod-1;\n\tfwt_xor(a,m,1);\n\tfwt_xor(b,m,1);\n\tfor(i=0;i^m;++i) b[i]=(ll)b[i]*fpow(a[i],mod-2)%mod;\n\tfwt_xor(b,m,-1);\n\tfor(i=0;i^m;++i) print(_sub(b[i],b[0])),putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 18, S = 1 << N, Mod = 998244353;\n\ninline int fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nint n, len, p[S], s[S], sum;\n\nvoid FWT(int *P, int opt) {\n\tfor (int i = 2, p; p = i >> 1, i <= len; i <<= 1)\n\t\tfor (int j = 0; j < len; j += i) Rep (k, p) {\n\t\t\tint u = P[j + k], v = P[j + k + p];\n\t\t\tP[j + k] = (u + v) % Mod; P[j + k + p] = (u + Mod - v) % Mod;\n\t\t}\n\tif (!~opt) {\n\t\tint invn = fpm(len, Mod - 2);\n\t\tRep (i, len) P[i] = 1ll * P[i] * invn % Mod;\n\t}\n}\n\nint main() {\n\n\tFile();\n\n\tlen = 1 << (n = read());\n\tRep (i, len) (sum += p[i] = read()) %= Mod;\n\tsum = fpm(sum, Mod - 2);\n\tRep (i, len) p[i] = 1ll * sum * p[i] % Mod; -- p[0];\n\tRep (i, len) s[i] = (i ? 0 : len) - 1;\n\n\tFWT(p, 1); FWT(s, 1); Rep (i, len) p[i] = 1ll * s[i] * fpm(p[i], Mod - 2) % Mod; FWT(p, -1);\n\n\tRep (i, len) printf (\"%d\\n\", (p[i] - p[0] + Mod) % Mod);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,m,sum;\nconst int N=1<<18|5,mod=998244353;\nLL ksm(LL a,LL b,LL mod)\n{\n\tLL res=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)res=res*a%mod;\n\treturn res;\n}\nstruct DXS\n{\n\tint v[N];\n\tvoid FWT(int lim,int opt)\n\t{\n\t\tint a,b;\n\t\tfor(int mid=1,len=2;len<=lim;mid<<=1,len<<=1)\n\t\t\tfor(int i=0;i<lim;i+=len)\n\t\t\t\tfor(int j=i;j<i+mid;++j)\n\t\t\t\t\ta=v[j],b=v[j+mid],v[j]=(LL)(a+b)*opt%mod,v[j+mid]=(LL)(a-b)*opt%mod;\n\t}\n}E,P,S;\nint main()\n{\n\tcin>>m;n=1<<m;\n\tfor(int i=0;i<n;++i)scanf(\"%d\",&P.v[i]),sum+=P.v[i];\n\tsum=ksm(sum,mod-2,mod);\n\tfor(int i=0;i<n;++i)P.v[i]=(LL)P.v[i]*sum%mod;\n\t--P.v[0];if(P.v[0]<0)P.v[0]+=mod;\n\tS.v[0]=n-1;\n\tfor(int i=1;i<n;++i)S.v[i]=mod-1;\n\tP.FWT(n,1);S.FWT(n,1);\n\tfor(int i=1;i<n;++i)E.v[i]=(LL)S.v[i]*ksm(P.v[i],mod-2,mod)%mod;\n\tE.FWT(n,(mod+1)/2);\n\t\n\tfor(int i=0,x=E.v[0];i<n;++i)printf(\"%d\\n\",((E.v[i]-x)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst i64 MOD = 998244353;\nconst i64 Inv2 = -MOD / 2;\n\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1)\n\t\tif (k & 1) t = t * a % MOD;\n\treturn t;\n}\n\nconst int N = 1 << 18 | 7;\n\nint n;\ni64 p[N], s, q[N];\n\nvoid fwt_xor(i64 f[], int n, int on) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 1 << n; ++j)\n\t\t\tif (j >> i & 1)\n\t\t\t\t( f[j ^ 1 << i] += f[j] ) %= MOD, ( f[j] = f[j ^ 1 << i] - 2 * f[j] ) %= MOD;\n\t\tif (on == 1) continue;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\t( f[i] *= Inv2 ) %= MOD;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tscanf(\"%lld\", p + i), s += p[i];\n\ts = pow(s, MOD - 2);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tp[i] = p[i] * s % MOD;\n\t--p[0];\n\tstd::fill(q, q + (1 << n), -1);\n\tq[0] += 1 << n;\n\t\n\tfwt_xor(p, n, 1), fwt_xor(q, n, 1);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tq[i] = q[i] * pow(p[i], MOD - 2) % MOD;\n\tfwt_xor(q, n, -1);\n  \n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tprintf(\"%lld\\n\", (q[i] - q[0] + MOD * 2) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\ntemplate <typename T=mint>\nstruct Boly : vector<T> {\n    using vector<T>::vector;\n    Boly() {}\n    Boly(initializer_list<T> list) : vector<T>(list) {}\n\n};\n\n\ntemplate <typename T=mint>\ninline Boly<T>& fwht(Boly<T>& a, bool is_inv=false) {\n    int n = a.size();\n    assert((n&(n-1)) == 0);\n    if (is_inv) {\n        T i_n = T(1)/n;\n        for (int i = 0; i < n; i++) {\n            a[i] *= i_n;\n        }\n    }\n    for (int m = 1; m < n; m<<=1) {\n        int l = m<<1;\n        for (int i = 0; i < n; i+=l) {\n            for (int j = 0; j < m; j++) {\n                T x = a[i+j];\n                T y = a[i+j+m];\n                a[i+j] = x + y;\n                a[i+j+m] = x - y;\n            }\n        }\n    }\n    return a;\n}\ntemplate <typename T=mint>\nBoly<T>& operator*=(Boly<T>& a, const Boly<T>& _b) {\n    int n = max(a.size(), _b.size());\n    int _n = 1 << (31 - __builtin_clz(n));\n    if (_n < n) n = _n<<1;\n    auto b = _b;\n    a.resize(n); b.resize(n);\n    fwht(a); fwht(b);\n    for (int i = 0; i < n; i++) {\n        a[i] *= b[i];\n    }\n    return fwht(a, true);\n}\ntemplate <typename T=mint>\nBoly<T>& operator/=(Boly<T>& a, const Boly<T>& _b) {\n    int n = max(a.size(), _b.size());\n    int _n = 1 << (31 - __builtin_clz(n));\n    if (_n < n) n = _n<<1;\n    auto b = _b;\n    a.resize(n); b.resize(n);\n    fwht(a); fwht(b);\n    for (int i = 0; i < n; i++) {\n        a[i] /= b[i];\n    }\n    return fwht(a, true);\n}\ntemplate <typename T=mint> inline Boly<T> operator*(const Boly<T>& a, const Boly<T>& _b) { Boly<T> res(a); return res *= _b; }\ntemplate <typename T=mint> inline Boly<T> operator/(const Boly<T>& a, const Boly<T>& _b) { Boly<T> res(a); return res /= _b; }\n\n\nusing boly=Boly<mint>;\n\nvoid solve() {\n    int n; cin >> n;\n    boly p(1<<n), c(1<<n, -1);\n    mint sum = 0;\n    for (auto& x: p) {\n        cin >> x;\n        sum += x;\n    }\n    sum = 1/sum;\n    for (auto& x: p) {\n        x *= sum;\n    }\n    p[0] -= 1; c[0] += 1<<n;\n    auto res = c/p;\n    for (auto& x: res) {\n        cout << (x-res[0]) << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n\n#ifndef DUMP\n#define DUMP(...) (void)0\n#endif\n\nusing namespace std;\n\ntemplate <class T, class Op = multiplies<>>\nconstexpr T power(T a, uint64_t n, T init = 1, Op op = Op{}) {\n  while (n) {\n    if (n & 1) init = op(init, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return init;\n}\n\ntemplate <uint32_t M>\nstruct modular {\n  using T = modular;\n  static constexpr uint32_t mod = M;\n  uint32_t v;\n  modular(int64_t x = 0) : v((x %= mod) < 0 ? x + mod : x) {}\n  T operator-() const { return T() -= *this; }\n  T& operator+=(T b) { return (int)(v += b.v - mod) < 0 ? v += mod : v, *this; }\n  T& operator-=(T b) { return (int)(v -= b.v) < 0 ? v += mod : v, *this; }\n  T& operator*=(T b) { return v = (uint64_t)v * b.v % mod, *this; }\n  T& operator/=(T b) { return *this *= power(b, mod - 2); }\n  friend T operator+(T a, T b) { return a += b; }\n  friend T operator-(T a, T b) { return a -= b; }\n  friend T operator*(T a, T b) { return a *= b; }\n  friend T operator/(T a, T b) { return a /= b; }\n  friend bool operator==(T a, T b) { return a.v == b.v; }\n};\n\nusing mint = modular<998244353>;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> a(1 << n);\n  for (auto&& e : a) cin >> e;\n  auto inv = mint(1) / accumulate(begin(a), end(a), 0);\n  vector<mint> f(1 << n);\n  auto fwht = [&] {\n    for (int s = 0; s < n; ++s)\n      for (int i = 0; i < 1 << n; ++i) {\n        if (i >> s & 1) continue;\n        int j = i | 1 << s;\n        auto x = f[i], y = f[j];\n        f[i] = x + y;\n        f[j] = x - y;\n      }\n  };\n  for (int i = 1; i < 1 << n; ++i) f[i] = -a[i] * inv;\n  f[0] = -accumulate(begin(f), end(f), mint());\n  fwht();\n  for (int i = 1; i < 1 << n; ++i) f[i] = -1 / f[i];\n  f[0] = -accumulate(begin(f), end(f), mint());\n  fwht();\n  for (auto&& e : f) cout << e.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1<<18|5\n#define mod 998244353\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\nusing namespace std;\n\nint n,N;\nint a[maxn],b[maxn];\n\nint Pow(int b,int k){ int r=1;for(;k;k>>=1,b=1ll*b*b%mod) if(k&1) r=1ll*r*b%mod; return r; }\nvoid FWT(int *a){\n\trep(i,0,n-1) rep(j,0,N-1) if(!(j>>i&1)){\n\t\tint v = j ^ (1 << i) , x = (a[j] + a[v]) % mod , y = (a[j] - a[v]) % mod;\n\t\ta[j] = x , a[v] = y;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);N = 1 << n;int S=0;\n\trep(i,0,N-1) scanf(\"%d\",&a[i]),S+=a[i];\n\tS = Pow(S , mod-2);\n\trep(i,0,N-1) a[i] = 1ll * a[i] * S % mod;\n\ta[0]-- , b[0] = 1 << n;\n\trep(i,0,N-1) b[i]--;\n\tFWT(a),FWT(b);\n\trep(i,0,N-1) a[i] = 1ll * Pow(a[i],mod-2) * b[i] % mod;\n\tFWT(a);int ivN = Pow(N , mod-2);\n\trep(i,0,N-1) a[i] = 1ll * a[i] * ivN % mod;\n\tper(i,N-1,0) a[i] = (a[i] - a[0]) % mod;\n\trep(i,0,N-1) printf(\"%d\\n\",(a[i]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nconst int mod = 998244353;\nusing namespace std;\nint sum(int a, int b){\n    if (a+b<0) return a+b+mod;\n    if (a+b >= mod) return a+b-mod;\n    return a+b;\n}\nint mult(int a, int b){\n    return ((ll) a * (ll) b) % (ll) mod;\n}\nint pw(int a, int b){\n    if (b==0) return 1;\n    if (b==1) return a;\n    if (b % 2 != 0) return mult(a, pw(a, b-1));\n    int R = pw(a, b/2);\n    return mult(R, R);\n}\nint dv(int a, int b){\n    return mult(a, pw(b, mod-2));\n}\nvector<int> solve(vector<int> a, vector<int> b){\n    if (a.size() == 1){\n        if (a[0] == 0) return {0};\n        return {dv(b[0], a[0])};\n    }\n    vector<int> a1, b1;\n    for (int i=0; i < a.size()/2; i++){\n        a1.push_back(sum(a[2*i], a[2*i+1]));\n        b1.push_back(sum(b[2*i], b[2*i+1]));\n    }\n    vector<int> F = solve(a1, b1);\n    a1.clear(), b1.clear();\n    for (int i=0; i < a.size()/2; i++){\n        a1.push_back(sum(a[2*i], -a[2*i+1]));\n        b1.push_back(sum(b[2*i], -b[2*i+1]));\n    }\n    vector<int> S = solve(a1, b1);\n    vector<int> res;\n    for (int i=0; i < a.size()/2;i++){\n        res.push_back(dv(sum(F[i], S[i]), 2));\n        res.push_back(sum(F[i], -res.back()));\n    }\n    return res;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    vector<int> v((1<<n));\n    for (int i=0;i<(1<<n);i++) cin >> v[i];\n    int S = 0;\n    for (int i=0; i < (1<<n); i++) S += v[i];\n    for (int i=0;i<(1<<n);i++) v[i] = dv(v[i], S);\n    v[0] = sum(v[0], -1);\n    vector<int> res = {sum(pw(2, n), -1)};\n    for (int i=0; i < (1<<n)-1; i++) res.push_back(sum(0, -1));\n    vector<int> ans = solve(v, res);\n    for (int i=(1<<n)-1; i >= 0; i--){\n        ans[i] = sum(ans[i], -ans[0]);\n    }\n    for (int i=0;i<(1<<n);i++) cout << ans[i] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;\n            }\n}\n\nvoid IFWT(LL a[],LL n)\n{\n    for(LL i=1; i<n; i<<=1)\n        for(LL j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 2005\n#define ba 47\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 998244353,inv2 = (MOD + 1) / 2;\nint N,A[(1 << 18) + 5],S;\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nvector<int> trans(vector<int> p,vector<int> m) {\n    if(p.size() == 1) {\n\tif(p[0] == 0 && m[0] == 0) return (vector<int>){1};\n\telse return (vector<int>){mul(m[0],fpow(p[0],MOD - 2))};\n    }\n    vector<int> p0,p1,m0,m1;\n    for(int i = 0 ; i < p.size() ; i += 2) {\n\tp0.pb(inc(p[i],p[i + 1]));\n\tp1.pb(inc(p[i],MOD - p[i + 1]));\n\tm0.pb(inc(m[i],m[i + 1]));\n\tm1.pb(inc(m[i],MOD - m[i + 1]));\n    }\n    p0 = trans(p0,m0);p1 = trans(p1,m1);\n    vector<int> res;\n    for(int i = 0 ; i < p0.size() ; ++i) {\n\tres.pb(mul(inc(p0[i],p1[i]),inv2));\n\tres.pb(mul(inc(p0[i],MOD - p1[i]),inv2));\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 0 ; i < (1 << N) ; ++i) {\n\tread(A[i]);\n\tupdate(S,A[i]);\n    }\n    S = fpow(S,MOD - 2);\n    for(int i = 0 ; i < (1 << N) ; ++i) {\n\tA[i] = mul(A[i],S);\n    }\n    vector<int> a,b;\n    b.pb((1 << N) - 1);\n    for(int i = 1 ; i < (1 << N) ; ++i) b.pb(-1);\n    for(int i = 0 ; i < (1 << N) ; ++i) {\n\tint t = A[i];\n\tif(i == 0) t = inc(t,MOD - 1);\n\ta.pb(t);\n    }\n    vector<int> ans = trans(a,b);\n    for(int i = 0 ; i < (1 << N) ; ++i) {\n\tout(inc(ans[i],MOD - ans[0]));enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=998244353;\nconst int maxn=1<<18;\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint rv;\nvoid fwt(int *a,int n,bool f=0)\n{\n\tint sz=(1<<n);\n\tfor(int k=1;k<sz;k<<=1)\n\t{\n\t\tfor(int i=0;i<sz;i+=(k<<1))for(int j=0;j<k;j++)\n\t\t{\n\t\t\tint u=a[i+j],v=a[i+j+k];\n\t\t\ta[i+j]=u+v;if(a[i+j]>=mod)a[i+j]-=mod;\n\t\t\ta[i+j+k]=u-v;if(a[i+j+k]<0)a[i+j+k]+=mod;\n\t\t}\n\t}\n\tif(f)for(int i=0;i<sz;i++)a[i]=1ll*a[i]*rv%mod;\n}\nint f[maxn],n,g[maxn];\n\nint main()\n{\n\tget1(n);\n\tint sum=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tget1(f[i]);\n\t\tsum+=f[i];\n\t}\n\t\n\tsum=qpow(sum,mod-2);\n\tfor(int i=0;i<(1<<n);i++)f[i]=(LL)f[i]*sum%mod;\n\tif(f[0])f[0]--;else f[0]=mod-1;\n\tfwt(f,n);\n\t\n\trv=qpow(1<<n,mod-2);\n\tfor(int i=1;i<(1<<n);i++)f[i]=((LL)qpow(f[i],mod-2)<<n)%mod;\n\t\n\tint k0,k1;\n\tmemcpy(g,f,sizeof(f));g[0]=0;fwt(g,n,1);k0=g[0];\n\tmemcpy(g,f,sizeof(f));g[0]=1;fwt(g,n,1);k1=g[0];\n\tf[0]=(LL)k0*qpow((k0-k1+mod)%mod,mod-2)%mod;fwt(f,n,1);\n\tfor(int i=0;i<(1<<n);i++)printendl(f[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define re register\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define fi first\n#define se second\n#define bg begin\ncs int RLEN=1<<20|1;\ninline char gc(){\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n    char ch=gc();\n    int res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline ll readll(){\n    char ch=gc();\n    ll res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\ntemplate<typename tp>inline void chemx(tp &a,tp b){a<b?a=b:0;}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a>b?a=b:0;}\ncs int mod=998244353;\ninline int add(int a,int b){return (a+=b)>=mod?(a-mod):a;}\ninline int dec(int a,int b){a-=b;return a+(a>>31&mod);}\ninline int mul(int a,int b){static ll r;r=1ll*a*b;return (r>=mod)?(r%mod):r;}\ninline void Add(int &a,int b){(a+=b)>=mod?(a-=mod):0;}\ninline void Dec(int &a,int b){a-=b,a+=a>>31&mod;}\ninline void Mul(int &a,int b){static ll r;r=1ll*a*b;a=(r>=mod)?(r%mod):r;}\ninline int ksm(int a,int b,int res=1){if(a==0&&b==0)return 0;for(;b;b>>=1,Mul(a,a))(b&1)&&(Mul(res,a),1);return res;}\ninline int Inv(int x){return ksm(x,mod-2);}\ninline int fix(ll x){return x%=mod,(x<0)?x+mod:x;}\ncs int N=19,M=(1<<N)|1;\nint f[M],p[M],n,m,s;\ninline void fwt(int *f,int lim,int kd){\n\tfor(int mid=1,a0,a1;mid<lim;mid<<=1)\n\tfor(int i=0;i<lim;i+=mid<<1)\n\tfor(int j=0;j<mid;j++)\n\ta0=f[i+j],a1=f[i+j+mid],f[i+j]=add(a0,a1),f[i+j+mid]=dec(a0,a1);\n\tif(kd==-1)\n\tfor(int i=0,iv=Inv(lim);i<lim;i++)Mul(f[i],iv);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read(),m=1<<n;\n\tfor(int i=0;i<m;i++){\n\t\tp[i]=read(),Add(s,p[i]);\n\t}s=Inv(s);\n\tfor(int i=0;i<m;i++)Mul(p[i],s);\n\tDec(p[0],1),f[0]=m-1;\n\tfor(int i=1;i<m;i++)f[i]=mod-1;\n\tfwt(f,m,1),fwt(p,m,1);\n\tfor(int i=1;i<m;i++)Mul(f[i],Inv(p[i]));\n\tf[0]=0,fwt(f,m,-1);\n\tfor(int i=0;i<m;i++)cout<<dec(f[i],f[0])<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=(1<<18)+5,Mo=998244353;\n\nll pwr(ll x,ll y) {\n\tll z=1;\n\tfor(;y;y>>=1,x=x*x%Mo)\n\t\tif (y&1) z=z*x%Mo;\n\treturn z;\n}\n\nint n;\nll p[N],q[N];\n\nvoid FWT(ll *a,int len,int flag) {\n\tfor(int i=1;i<len;i<<=1)\n\t\tfor(int j=0;j<len;j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++) {\n\t\t\t\tll u=a[j+k],v=a[j+k+i];\n\t\t\t\ta[j+k]=(u+v)%Mo;a[j+k+i]=(u-v)%Mo;\n\t\t\t}\n\tif (flag==-1) {\n\t\tll inv=pwr(len,Mo-2);\n\t\tfor(int i=0;i<len;i++) a[i]=a[i]*inv%Mo;\n\t}\n}\n\nint main() {\n\tn=read();\n\tll sum=0;\n\tfo(s,0,(1<<n)-1) p[s]=read(),sum+=p[s];\n\tll inv=pwr(sum,Mo-2);\n\tfo(s,0,(1<<n)-1) p[s]=p[s]*inv%Mo;p[0]--;\n\tfo(s,1,(1<<n)-1) q[s]=-1;q[0]=(1<<n)-1;\n\tFWT(q,(1<<n),1);FWT(p,(1<<n),1);\n\tfo(s,1,(1<<n)-1) q[s]=q[s]*pwr(p[s],Mo-2)%Mo;\n\tFWT(q,(1<<n),-1);\n\tfo(i,1,(1<<n)-1) (q[i]-=q[0])%=Mo;q[0]=0;\n\tfo(i,0,(1<<n)-1) printf(\"%lld\\n\",(q[i]+Mo)%Mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 18, mod = 998244353, inv2 = 499122177;\nint n, a[N], b[N], len, m, s;\nvoid fwt(int * a, int op) {\n    for(int i = 1; i < len; i <<= 1) {\n        int s = i << 1;\n        for(int j = 0; j < len; j += s)\n            for(int k = 0; k < i; ++k) {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (x + y) % mod; a[i + j + k] = (x - y + mod) % mod;\n                if(op == -1) a[j + k] = 1ll * a[j + k] * inv2 % mod, a[i + j + k] = 1ll * a[i + j + k] * inv2 % mod;\n            }\n    }\n}\nint qpow(int a, int b) {\n    int c = 1;\n    while(b) {\n        if(b & 1) c = 1ll * c * a % mod;\n        a = 1ll * a * a % mod;\n        b >>= 1;\n    } return c;\n}\nint main() {\n    scanf(\"%d\", &n); m = (1 << n) - 1;\n    for(int i = 0; i <= m; ++i) scanf(\"%d\", &a[i]), s = (s + a[i]) % mod;\n    s = qpow(s, mod - 2);\n    for(int i = 0; i <= m; ++i) a[i] = 1ll * a[i] * s % mod;\n    for(int i = 1; i <= m; ++i) b[i] = mod - 1;\n    b[0] = m; a[0] = (a[0] - 1 + mod) % mod;\n    len = 1 << n;\n    fwt(a, 1); fwt(b, 1);\n    for(int i = 0; i < len; ++i)\n        a[i] = 1ll * qpow(a[i], mod - 2) * b[i] % mod;\n    fwt(a, -1);\n    for(int i = 0; i <= m; ++i) printf(\"%d\\n\", (a[i] - a[0] + mod) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\nusing namespace std;\n\ntypedef long long li;\ntypedef unsigned long long lu;\nconst li infl = ~0LLU >> 2;\n\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void Max(T &x, T y) {\n  if (y > x) x = y;\n}\n\nconst int mod = 998244353;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\nint Inv(int x) {\n  return Pow(x, mod - 2);\n}\n\n// ----------------------------------------\n\ntypedef vector<int> Poly;\n\nconst int maxn = 18;\n\nPoly Fwt(Poly f) {\n  int n = f.size();\n  for (int x = 1; x < n; x <<= 1) {\n    for (int s = 0; s < n; ++s) {\n      if (s & x) continue;\n      int t = f[s | x];\n      f[s | x] = Sub(f[s] - t);\n      Add(f[s], t);\n    }\n  }\n  return f;\n}\n\nPoly Ifwt(Poly f) {\n  int n = f.size();\n  int inv = Inv(n);\n  f = Fwt(f);\n  for (int i = 0; i < n; ++i) {\n    f[i] = Mul(f[i], inv);\n  }\n  return f;\n}\n\nint main(void) {\n  int n, sum = 0;\n  scanf(\"%d\", &n);\n  n = 1 << n;\n  Poly p(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &p[i]);\n    Add(sum, p[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    p[i] = Mul(p[i], Inv(sum));\n  }\n\n  Poly p_hat = Fwt(p);\n  Poly f(n), f_der(n);\n  for (int i = 0; i < n; ++i) {\n    int k = p_hat[i];\n    if (k == 1) {\n      f[i] = 1;\n      f_der[i] = 0;\n    } else {\n      f[i] = 0;\n      f_der[i] = Inv(Sub(k - 1));\n    }\n  }\n  f = Ifwt(f);\n  f_der = Ifwt(f_der);\n\n  Poly ans(n);\n  for (int i = 0; i < n; ++i) {\n    ans[i] = Mul(Sub(Mul(f_der[i], f[0]) - Mul(f_der[0], f[i])),\n                 Inv(Mul(f[0], f[0])));\n    printf(\"%d\\n\", ans[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353 , _ = 1 << 18;\n\nint poww(long long a , int b){\n\tint times = 1;\n\twhile(b){\n\t\tif(b & 1) times = times * a % MOD;\n\t\ta = a * a % MOD; b >>= 1;\n\t}\n\treturn times;\n}\n\nint A[_] , B[_] , N , invn;\nvoid FWT(int *arr , int tp){\n\tfor(int i = 1 ; i < N ; i <<= 1)\n\t\tfor(int j = 0 ; j < N ; j += i << 1)\n\t\t\tfor(int k = 0 ; k < i ; ++k){\n\t\t\t\tint x = arr[j + k] , y = arr[i + j + k];\n\t\t\t\tarr[j + k] = x + y >= MOD ? x + y - MOD : x + y;\n\t\t\t\tarr[i + j + k] = x < y ? x + MOD - y : x - y;\n\t\t\t}\n\tif(tp == -1) for(int i = 0 ; i < N ; ++i) arr[i] = 1ll * arr[i] * invn % MOD;\n}\n\nint main(){\n\tcin >> N; N = 1 << N; int sum = 0; invn = poww(N , MOD - 2);\n\tfor(int i = 0 ; i < N ; ++i){cin >> A[i]; sum += A[i];}\n\tsum = poww(sum , MOD - 2); for(int i = 0 ; i < N ; ++i) A[i] = (1ll * A[i] * sum - (i == 0)) % MOD;\n\tfor(int i = 0 ; i < N ; ++i) B[i] = i == 0 ? N - 1 : MOD - 1;\n\tFWT(A , 1); FWT(B , 1);\n\tfor(int i = 1 ; i < N ; ++i) A[0] = (A[0] + (A[i] = 1ll * poww(A[i] , MOD - 2) * B[i] % MOD)) % MOD;\n\tA[0] = (MOD - A[0]) % MOD; FWT(A , -1);\n\tfor(int i = 0 ; i < N ; ++i) printf(\"%d\\n\" , A[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define ROF(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) ROF(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define reach cerr<<\"reached\"<<endl\nvoid dmpr(decltype(cerr)&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(decltype(cerr)&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp(...) dmpr(cerr,##__VA_ARGS__)\n#define zero(x) memset(x,0,sizeof(x))\n#define one(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n#define bg begin()\n#define ed end()\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> uni(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid mkuni(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\n//ayasii\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\n#define SMOD\n\n#ifdef SMOD\ntemplate<uint mod>\n#else\nuint mod;\n#endif\nstruct ModInt{\n\t#ifdef SMOD\n\tstatic constexpr uint base=mod;\n\t#else\n\tstatic constexpr uint& base=mod;\n\t#endif\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\ts(vv%mod+mod);\n\t}\n\tModInt& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt()-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\treturn s(v+rhs.v);\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\treturn s(v+mod-rhs.v);\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\treturn *this*=rhs.inv();\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\n#ifdef SMOD\ntemplate<uint mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<uint mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n#else\nostream& operator<<(ostream&os,const ModInt&m){\n\treturn os<<m.v;\n}\nvoid print(const ModInt&m,int suc=1){\n\tprint(m.v,suc);\n}\n#endif\n\n#ifdef SMOD\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n#else\nusing mint=ModInt;\n#endif\n\nconst int Vmax=2000010;\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\n#ifdef SMOD\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\n#endif\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\n//the size of f must be a power of 2\ntemplate<class T>\nvoid inplace_xor_transform(vector<T>&f){\n\tint n=f.size();\n\tfor(int b=1;b<=n/2;b*=2){\n\t\tfor(int i=0;i<n;i+=b*2){\n\t\t\tfor(int j=i;j<i+b;j++){\n\t\t\t\ttie(f[j],f[j+b])=make_tuple(f[j]+f[j+b],f[j]-f[j+b]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint n=1<<read();\n\tV<mint> a(n);\n\trep(i,n)\n\t\ta[i]=read();\n\tint s=0;\n\trep(i,n)\n\t\ts+=a[i].v;\n\trep(i,n)\n\t\ta[i]/=s;\n\t\n\tinplace_xor_transform(a);\n\t\n\tV<mint> v(n,-1);\n\tv[0]+=n;\n\tinplace_xor_transform(v);\n\t\n\tV<mint> h(n);\n\tFOR(i,1,n){\n\t\tassert(a[i]!=1);\n\t\th[i]=v[i]/(a[i]-1);\n\t}\n\tinplace_xor_transform(h);\n\t\n\tmint w=h[0];\n\tfor(auto&x:h){\n\t\tx-=w;\n\t\tx/=n;\n\t}\n\tfor(auto x:h)\n\t\tprint(x);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 998'244'353, INV2 = 499'122'177;\nint difference(int a, int b) {\n    return (a -= b) < 0 ? a += P : a;\n}\nint sum(int a, int b) {\n    return (a += b) >= P ? a -= P : a;\n}\nint power(int a, int b) {\n    int result = 1;\n    while (b > 0) {\n        if (b % 2 == 1)\n            result = 1LL * result * a % P;\n        a = 1LL * a * a % P;\n        b /= 2;\n    }\n    return result;\n}\nvoid fwt(vector<int> &a) {\n    for (int i = 1; i < a.size(); i *= 2) {\n        for (int j = 0; j < a.size(); j += 2 * i) {\n            for (int k = 0; k < i; ++k) {\n                int u = sum(a[j + k], a[i + j + k]);\n                int v = difference(a[j + k], a[i + j + k]);\n                a[j + k] = u;\n                a[i + j + k] = v;\n            }\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> p(1 << n);\n    for (int i = 0; i < (1 << n); ++i)\n        cin >> p[i];\n    int s = accumulate(p.begin(), p.end(), 0);\n    s = power(s, P - 2);\n    for (int i = 0; i < (1 << n); ++i)\n        p[i] = 1LL * p[i] * s % P;\n    --p[0];\n    fwt(p);\n    for (int i = 1; i < (1 << n); ++i)\n        p[i] = power(p[i], P - 2);\n    p[0] = (P - accumulate(p.begin() + 1, p.end(), 0LL) % P + P) % P;\n    fwt(p);\n    for (int i = 0; i < (1 << n); ++i)\n        cout << p[i] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=998244353;\nconst int inv2=499122177;\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid fwt(int* a,int n,int dft)\n{\n\tfor(int step=1;step<n;step<<=1)\n\t\tfor(int i=0;i<n;i+=step<<1)\n\t\t\tfor(int j=i;j<i+step;j++)\n\t\t\t{\n\t\t\t\tint x=a[j],y=a[j+step];\n\t\t\t\ta[j]=(x+y)%Mod;a[j+step]=(x-y+Mod)%Mod;\n\t\t\t\tif(dft==-1)a[j]=1ll*a[j]*inv2%Mod,a[j+step]=1ll*a[j+step]*inv2%Mod;\n\t\t\t}\n\treturn ;\n}\nint f[300010],p[300010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tn=1<<n;\n\tint S=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t\tS+=p[i];\n\t}\n\tS=fpow(S,Mod-2);\n\tfor(int i=0;i<n;i++)p[i]=1ll*p[i]*S%Mod;\n\tp[0]=(p[0]-1+Mod)%Mod;\n\tfor(int i=1;i<n;i++)f[i]=Mod-1;\n\tf[0]=n-1;\n\tfwt(f,n,1);fwt(p,n,1);\n\tfor(int i=1;i<n;i++)\n\t\tf[i]=1ll*f[i]*fpow(p[i],Mod-2)%Mod;\n\tf[0]=0;\n\tfwt(f,n,-1);\n\tint add=(Mod-f[0])%Mod;\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d\\n\",(f[i]+add)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fir first\n#define sec second\n#define tct template<class type>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int maxn = 1 << 18, mod = 998244353;\nint n, m, p[maxn + 5], a[maxn + 5], f[maxn + 5];\n\ninline int& red(int &x) { return x += x >> 31 & mod; }\ntct inline void cmax(type &x, type y) { x < y ? x = y : 0; }\ntct inline void cmin(type &x, type y) { x > y ? x = y : 0; }\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = ll(a) * a % mod) if (b & 1) c = ll(a) * c % mod;\n\treturn c;\n}\n\nvoid fwt(int a[], int n, int t) {\n\tfor (int k = 0, l = 1, p; l < n; k++, l <<= 1) {\n\t\trep(i, 0, n - 1) if (~i >> k & 1) {\n\t\t\tp = a[i];\n\t\t\tred(a[i] += a[i + l] - mod);\n\t\t\tred(a[i + l] = p - a[i + l]);\n\t\t}\n\t}\n\tif (t == -1) {\n\t\tint x = qpow(n, mod - 2);\n\t\trep(i, 0, n - 1) a[i] = ll(x) * a[i] % mod;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n), m = 1 << n;\n\tfill(a, a + m, 1), red(a[0] -= m);\n\tint s = 0;\n\trep(i, 0, m - 1) scanf(\"%d\", &p[i]), s += p[i];\n\ts = qpow(s, mod - 2);\n\trep(i, 0, m - 1) p[i] = ll(mod - s) * p[i] % mod;\n\tred(p[0] += 1 - mod);\n\tfwt(a, m, 1), fwt(p, m, 1);\n\tint t = 0;\n\trep(i, 1, m - 1) f[i] = ll(a[i]) * qpow(p[i], mod - 2) % mod, red(t -= f[i]);\n\tf[0] = t;\n\tfwt(f, m, -1);\n\trep(i, 0, m - 1) printf(\"%d\\n\", f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.7.26 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=5e2+10;\nnamespace MAIN{\n    int n,kcz;\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    Pair a[N];\n    int buc[N],top,ans;\n    inline int F(const res &x,const res &y){\n        res i=0;\n        while(i<(n<<1)&&i*i+y*y<x*x)i++;\n        return i;\n    }\n    inline int G(const res &x,const res &y){\n        res i=0;\n        while(i<(n<<1)&&i*i+y*y<=x*x)i++;\n        return i;\n    }\n    int dp[N];\n    inline void MAIN(){\n        n=read(),kcz=read();\n        for(res i=0;i<n;i++)a[++top]=mp(F(n,i),-i);\n        for(res i=n;i<n<<1;i++)a[++top]=mp(G(n<<1,i),1);\n        for(res i=0;i<n;i++)buc[i]=G(n<<1,i);\n        sort(a+1,a+top+1);\n        for(res k=0;k<=n;k++){\n            for(res i=0;i<=k;i++)dp[i]=0;\n            dp[0]=1;\n            res s1=0,s2=0;\n            for(res i=1;i<=top;i++)\n                if(a[i].se==1){\n                    for(res j=0;j<=min(k,s2);j++)dp[j]=mul(dp[j],Add(a[i].fi,kcz-s1-j));\n                    s1++;\n                }\n                else {\n                    for(res j=min(k,s2);~j;j--)add(dp[j+1],mul(dp[j],Add(a[i].fi,kcz-s1-j))),dp[j]=mul(dp[j],Add(buc[-a[i].se],kcz-n-k-s2+j));\n                    s2++;\n                }\n            add(ans,(k&1)?kcz-dp[k]:dp[k]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\nint main(){\n//    freopen(\"compound1.in\",\"r\",stdin);\n//    freopen(\"compound.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\ntemplate<class T> inline void read(T &x){\n\tx=0;register char c=getchar();register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\tif(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1<<18,mod=998244353;\nint n,s,inv_s,lim,a[N],f[N],g[N];\ninline int mid(int x){return x&1?(x+mod)>>1:x>>1;}\ninline int dec(int a,int b){return (a-=b)<0?a+mod:a;}\ninline int inc(int a,int b){return (a+=b)>=mod?a-mod:a;}\ninline int fpow(int a,int b){int s=1;for(;b;b>>=1,a=(ll)a*a%mod)if(b&1)s=(ll)s*a%mod;return s;}\nvoid fwt(int *a,void foo(int&,int&)){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=len<<1){\n\t\t\tfor(int j=0;j<len;j++)foo(a[i+j],a[i+j+len]);\n\t\t}\n}\nvoid trans(int &a,int &b){int x=a;a=inc(a,b),b=dec(x,b);}\nvoid i_trans(int &a,int &b){int x=a;a=mid(inc(a,b)),b=mid(dec(x,b));}\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=1<<n;\n\tfor(int i=0;i<lim;i++)read(a[i]),s=inc(s,a[i]);\n\tinv_s=fpow(s,mod-2);\n\tfor(int i=0;i<lim;i++)a[i]=(ll)a[i]*inv_s%mod,f[i]=lim-1;\n\tf[0]=mod-1,a[0]=dec(a[0],1);\n\tfwt(f,trans),fwt(a,trans);\n\tfor(int i=0;i<lim;i++)g[i]=(ll)f[i]*fpow(a[i],mod-2)%mod;\n\tfwt(g,i_trans);\n\t// for(int i=0;i<lim;i++)print(g[i],\" \\n\"[i==lim-1]);\n\tfor(int i=lim-1;i>=0;i--)g[i]=dec(g[0],g[i]);\n\tfor(int i=0;i<lim;i++)print(g[i],'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=(1<<18)+5;\nconst int mo=998244353;\nint a[N],b[N],c[N],n,S;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nvoid check(int *a,int *b,int *c,int n){\n\tif (n==1){\n\t\tif (!b[0]) c[0]=0;\n\t\telse c[0]=1ll*b[0]*power(a[0],mo-2)%mo;\n\t\treturn;\n\t}\n\tint nn=n/2,x,y;\n\tFor(i,0,nn-1){\n\t\tx=a[i]; y=a[i+nn];\n\t\ta[i]=(x+y)%mo; a[i+nn]=(x+mo-y)%mo;\n\t\tx=b[i]; y=b[i+nn];\n\t\tb[i]=(x+y)%mo; b[i+nn]=(x+mo-y)%mo;\n\t}\n\tcheck(a,b,c,nn);\n\tcheck(a+nn,b+nn,c+nn,nn);\n\tFor(i,0,nn-1){\n\t\tx=c[i],y=c[i+nn];\n\t\tc[i]=1ll*(x+y)*(mo+1)/2%mo;\n\t\tc[i+nn]=1ll*(x+mo-y)*(mo+1)/2%mo;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,0,(1<<n)-1){\n\t\tscanf(\"%d\",&a[i]);\n\t\tS+=a[i];\n\t}\n\tS=power(S,mo-2);\n\tFor(i,0,(1<<n)-1) a[i]=1ll*a[i]*S%mo;\n\tFor(i,0,(1<<n)-1) b[i]=mo-1;\n\ta[0]=(a[0]+mo-1)%mo;\n\tb[0]=(1<<n)-1;\n\tcheck(a,b,c,(1<<n));\n\tint dif=(mo-c[0])%mo;\n\tFor(i,0,(1<<n)-1) c[i]=(c[i]+dif)%mo;\n\tFor(i,0,(1<<n)-1) printf(\"%d\\n\",c[i]);\n}\n/*\n(x0,x1,x2,x3)opt(p0,p1,p2,p3)=(x0+2^n-1,x1-1,x2-1,x3-1)\n(x0,x1,x2,x3)opt(p0-1,p1,p2,p3)=(2^n-1,-1,-1,-1)\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 << 18;\nconst int P = 998244353;\nconst int inv2 = (P + 1) / 2;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nvoid FWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = tmp, a[k] = tnp;\n\t}\n}\nvoid UFWT(int *a, int N) {\n\tfor (int len = 2; len <= N; len <<= 1)\n\tfor (int i = 0; i < N; i += len)\n\tfor (int j = i, k = i + len / 2; k < i + len; j++, k++) {\n\t\tint tmp = (a[j] + a[k]) % P, tnp = (a[j] - a[k] + P) % P;\n\t\ta[j] = 1ll * tmp * inv2 % P, a[k] = 1ll * tnp * inv2 % P;\n\t}\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint n, goal, p[MAXN], q[MAXN], res[MAXN];\nint main() {\n\tread(n), goal = 1 << n;\n\tint sum = 0;\n\tfor (int i = 0; i < goal; i++)\n\t\tread(p[i]), sum += p[i];\n\tsum = power(sum, P - 2);\n\tfor (int i = 0; i < goal; i++) {\n\t\tp[i] = 1ll * p[i] * sum % P;\n\t\tq[i] = P - 1;\n\t}\n\tp[0] -= 1;\n\tq[0] = goal - 1;\n\tFWT(p, goal);\n\tFWT(q, goal);\n\tfor (int i = 0; i < goal; i++)\n\t\tres[i] = 1ll * q[i] * power(p[i], P - 2) % P;\n\tUFWT(res, goal);\n\tfor (int i = 0; i < goal; i++)\n\t\twriteln((res[i] + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 1000500;\nconst int P = 998244353;\nll fpw(ll x, ll mi) {\n    ll res = 1;\n    for (; mi; mi >>= 1, x = x * x % P)\n        if (mi & 1) res = res * x % P;\n    return res;\n}\ninline int add(int x, int y) {\n    return x + y >= P ? x + y - P : x + y; \n}\nint A[N], lim, n, inv2 = (P + 1) / 2;\nvoid FWT_xor(int *A, int ty) {\n    for (int i = 1;i < lim; i <<= 1) {\n        for (int j = 0;j < lim; j += (i << 1)) {\n            int *f = A + j, *g = f + i;\n            for (int k = 0;k < i; k++) {\n                int x = f[k], y = g[k];\n                f[k] = add(x, y),  g[k] = add(x, P - y);\n                if (ty == -1) f[k] = 1ll * f[k] * inv2 % P,\n                    g[k] = 1ll * inv2 * g[k] % P;\n            }\n        }\n    }\n}\n\nint p[N], S;\nint main() {\n    read(n), lim = 1 << n;\n    for (int i = 0;i < lim; i++) read(p[i]), S += p[i];\n    S = fpw(S, P - 2);\n    for (int i = 0;i < lim; i++) p[i] = 1ll * p[i] * S % P;\n        /* write(p[i], ' '); */\n    /* puts(\"\"); */\n    FWT_xor(p, 1);\n    for (int i = 0;i < lim; i++) {\n        /* write(g[i], ' '), write(p[i]); */\n        ll up = i == 0 ? 0 : lim, dw = (p[i] + P - 1) % P;\n        /* write(up, ' '), write(dw); */\n        A[i] = up * fpw(dw, P - 2) % P;\n    }\n    FWT_xor(A, -1);\n    for (int i = 0;i < lim; i++) write(add(A[i], -A[0] + P));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int P=998244353;\nconst int inv=P-P/2;\nvoid FWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t}\n}\nvoid UFWT(int* a,const int n){\n\tfor(int d = 1; d != 1 << n; d <<= 1)\n    \tfor(int i = 0; i != 1 << n; i += d << 1)\n        \tfor(int j = 0; j != d; ++j){\n\t        \tint l=a[i+j],r=a[i+j+d];\n\t            a[i+j]=l+r>=P?l+r-P:l+r;\n\t\t\t\ta[i+j+d]=l-r<0?l-r+P:l-r;\n\t\t\t\ta[i+j]=1ll*inv*a[i+j]%P;\n\t\t\t\ta[i+j+d]=1ll*inv*a[i+j+d]%P;\n\t\t\t}\n}\nconst int N=1<<18;\nint a[N],b[N];\nint qpow(int a,int b=P-2){\n\tint res=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1){\n\t\t\tres=1ll*res*a%P;\n\t\t}\n\t\ta=1ll*a*a%P;\n\t}\n\treturn res;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tint sum=0;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcin>>a[i];\n\t\tsum=(sum+a[i])%P;\n\t}\n\tsum=qpow(sum);\n\tfor(int i=0;i<(1<<n);i++){\n\t\ta[i]=1ll*sum*a[i]%P;\n\t\tb[i]=1;\n\t}\n\tb[0]=0;\n\tFWT(a,n);\n\tFWT(b,n);\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++){\n\t\ta[i]=1ll*qpow((P+1-a[i])%P)*b[i]%P;\n\t}\n\tFWT(a,n);\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcout<<(P+a[i]-a[0])%P<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint n, w, a[1 << 18], b[1 << 18], c[1 << 18];\n\ninline int add(int x, int y) {\n\tx += y; return x < mod ? x : x - mod;\n}\ninline int dec(int x, int y) {\n\tx -= y; return x < 0 ? x + mod : x;\n}\ninline int mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\ninline int fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1; x = mul(x, x);\n\t}\n\treturn ans;\n}\n\nvoid fwt(int *a) {\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < 1 << n; ++j)\n\t\t\tif (j >> i & 1) {\n\t\t\t\tint x = a[j ^ (1 << i)], y = a[j];\n\t\t\t\ta[j ^ (1 << i)] = add(x, y); a[j] = dec(x, y);\n\t\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; ++i) {\n\t\tscanf(\"%d\", &a[i]); w += a[i];\n\t}\n\tw = fpow(w, mod - 2);\n\tfor (int i = 0; i < 1 << n; ++i) {\n\t\ta[i] = dec(0, mul(a[i], w));\n\t\tb[i] = 1;\n\t}\n\tc[0] = dec(0, 1 << n); \n\ta[0] = add(a[0], 1);\n\tfwt(a); fwt(b); fwt(c);\n\tfor (int i = 1; i < 1 << n; ++i) {\n\t\ta[i] = mul(add(b[i], c[i]), fpow(a[i], mod - 2));\n\t\ta[0] = dec(a[0], a[i]);\n\t}\n\tfwt(a);\n\tw = fpow(1 << n, mod - 2);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tprintf(\"%d\\n\", mul(a[i], w));\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint64 inv2 = (MOD + 1) / 2;\nvoid fwt(vector<int>& a, int flag) {\n  int n = a.size();\n  for (int h = 1; h < n; h <<= 1) {\n    for (int step = h << 1, i = 0; i < n; i += step) {\n      for (int j = i; j < i + h; ++j) {\n        int x = a[j], y = a[j + h];\n        if (flag > 0) {\n          a[j] = (x + y) % MOD;\n          a[j + h] = (x - y + MOD) % MOD;\n        } else {\n          a[j] = (x + y) * inv2 % MOD;\n          a[j + h] = (x - y + MOD) * inv2 % MOD;\n        }\n      }\n    }\n  }\n}\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\n\nint64 power_mod(int64 a, int64 n, int p = MOD) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % p;\n    a = a * a % p;\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> p(1 << n);\n  int sum = 0;\n  for (int i = 0; i < (1 << n); ++i) {\n    scanf(\"%d\", &p[i]);\n    add(sum, p[i]);\n  }\n  sum = power_mod(sum, MOD - 2);\n  for (int i = 0; i < (1 << n); ++i) {\n    p[i] = (int64)sum * p[i] % MOD;\n  }\n  add(p[0], MOD - 1);\n  fwt(p, 1);\n  vector<int> q(1 << n);\n  for (int i = 0; i < (1 << n); ++i) {\n    q[i] = MOD - 1;\n  }\n  add(q[0], 1 << n);\n  fwt(q, 1);\n  for (int i = 0; i < (1 << n); ++i) {\n    q[i] = p[i] == 0 ? 0 : q[i] * power_mod(p[i], MOD - 2) % MOD;\n  }\n  fwt(q, -1);\n  for (int i = (1 << n) - 1; i >= 0; --i) {\n    add(q[i], MOD - q[0]);\n  }\n  for (int i = 0; i < (1 << n); ++i) {\n    printf(\"%d\\n\", q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define ri register int\nusing namespace std;\n#define y2 cyktxdy\ntypedef long long ll;\ntypedef vector<int> poly;\ntypedef vector<ll> Poly;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define fi first\n#define se second\nconst int rlen=1<<18|1,inf=0x3f3f3f3f;\nconst ll Inf=1e18;\nchar buf[rlen],*ib=buf,*ob=buf;\n#define gc() (((ib==ob)&&(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)\ninline int read() {\n  int ans=0;\n  char ch=gc();\n  while(!isdigit(ch)) ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return ans;\n}\ninline ll readl() {\n  ll ans=0;\n  char ch=gc();\n  while(!isdigit(ch)) ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return ans;\n}\nnamespace modular {\n  const int mod=998244353;\n  inline int add(int a,int b) { return a+b<mod?a+b:a+b-mod; }\n  inline int dec(int a,int b) { return a<b?a-b+mod:a-b; }\n  inline int mul(int a,int b) { return (ll)a*b%mod; }\n  inline void Add(int&a,int b) { a=a+b<mod?a+b:a+b-mod; }\n  inline void Dec(int&a,int b) { a=a<b?a-b+mod:a-b; }\n  inline void Mul(int&a,int b) { a=(ll)a*b%mod; }\n  inline int ksm(int a,int p) { int ret=1;for(;p;p>>=1,Mul(a,a)) (p&1)&&(Mul(ret,a),1);return ret; }\n  inline int Ksm(int a,int p) {\n    int ret=1;\n    for(;p;p>>=1,a=(ll)a*a%(mod-1)) (p&1)&&(ret=(ll)ret*a%(mod-1));\n    return ret;\n  }\n  inline int Inv(int a) { return ksm(a,mod-2); }\n}\nusing namespace modular;\ntemplate<typename T>inline void ckmax(T&a,T b) { a<b?a=b:0; }\ntemplate<typename T>inline void ckmin(T&a,T b) { a>b?a=b:0; }\ntemplate<typename T>inline T gcd(T a,T b) { T t;while(b) t=a,a=b,b=t-t/a*a;return a; }\nint a[1<<18],p[1<<18],lim;\ninline void fwt(int*a,int typ) {\n  for(ri i=1,a0,a1,iv=(mod+1)>>1;i<lim;i<<=1) for(ri j=0;j<lim;j+=i<<1) for(ri k=0;k<i;++k) {\n    a0=a[j+k],a1=a[j+k+i],a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1);\n    if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv);\n  }\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\",\"r\",stdin);\n  #endif\n  lim=1<<read();\n  int ss=0;\n  for(ri i=0;i<lim;++i) Add(ss,p[i]=read()),a[i]=i?mod-1:lim-1;\n  ss=Inv(ss);\n  for(ri i=0;i<lim;++i) Mul(p[i],ss);\n  Dec(p[0],1);\n  fwt(a,1),fwt(p,1);\n  for(ri i=1;i<lim;++i) Mul(a[i],Inv(p[i]));\n  fwt(a,-1);\n  for(ri i=0;i<lim;++i) cout<<dec(a[i],a[0])<<'\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\n\nconst int MaxN = 18, MaxS = 1 << MaxN;\nconst int cIz = 998244353;\n\ninline int add(int a, int b) {\n\treturn (a += b) < cIz ? a : a - cIz;\n}\ninline int sub(int a, int b) {\n\treturn (a -= b) < 0 ? a + cIz : a;\n}\n\ninline int Pow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = (ll)res * a % cIz;\n\t\ta = (ll)a * a % cIz;\n\t}\n\treturn res;\n}\ninline int Inv(int a) {\n\treturn Pow(a, cIz - 2);\n}\n\nvoid FWT(int *f, int n) {\n\tfor (int i = 1; i < n; i <<= 1) {\n\t\tfor (int j = 0; j < n; j += i << 1) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint a = f[j + k], b = f[j + k + i];\n\t\t\t\tf[j + k] = add(a, b);\n\t\t\t\tf[j + k + i] = sub(a, b);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n, A[MaxS], B[MaxS];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tint N = 1 << n;\n\tint sum = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\tsum += A[i];\n\t}\n\tint inv_sum = Inv(sum);\n\tfor (int i = 0; i < N; ++i) A[i] = (ll)A[i] * inv_sum % cIz;\n\tA[0] = sub(A[0], 1);\n\tFWT(A, N);\n\tB[0] = 1;\n\tfor (int i = 1; i < N; ++i) B[i] = (ll)B[i - 1] * A[i] % cIz;\n\tint imul = Inv(B[N - 1]);\n\tfor (int i = N; --i; ) {\n\t\tB[i] = (ll)imul * B[i - 1] % cIz;\n\t\timul = (ll)imul * A[i] % cIz;\n\t}\n\tFWT(B, N);\n\tint delta = B[0];\n\tfor (int i = 0; i < N; ++i) printf(\"%d\\n\", sub(B[i], delta));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 18;\nconst int P = 998244353;\nconst llong INV2 = 499122177ll;\nllong p[(1<<N)+3];\nllong a[(1<<N)+3],b[(1<<N)+3];\nint n,sum;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong mulinv(llong x) {return quickpow(x,P-2);}\n\nvoid fwt(int dgr,int coe,llong poly[],llong ret[])\n{\n\tmemcpy(ret,poly,sizeof(llong)*(1<<dgr));\n\tfor(int i=0; i<dgr; i++)\n\t{\n\t\tfor(int j=0; j<(1<<dgr); j+=(1<<i+1))\n\t\t{\n\t\t\tfor(int k=0; k<(1<<i); k++)\n\t\t\t{\n\t\t\t\tllong x = poly[k+j],y = poly[k+(1<<i)+j];\n\t\t\t\tpoly[k+j] = x+y>=P?x+y-P:x+y; poly[k+(1<<i)+j] = x-y<0?x-y+P:x-y;\n\t\t\t}\n\t\t}\n\t}\n\tif(coe==-1) {llong tmp = mulinv(1<<dgr); for(int i=0; i<(1<<dgr); i++) ret[i] = ret[i]*tmp%P;}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n); for(int i=0; i<(1<<n); i++) {scanf(\"%lld\",&p[i]); sum += p[i];} sum = mulinv(sum);\n\tfor(int i=0; i<(1<<n); i++) p[i] = p[i]*sum%P; p[0] = (p[0]-1+P)%P;\n\ta[0] = (1<<n)-1; for(int i=1; i<(1<<n); i++) a[i] = P-1;\n\tfwt(n,1,a,a); fwt(n,1,p,p);\n\tb[0] = 0ll; for(int i=1; i<(1<<n); i++) b[i] = a[i]*mulinv(p[i])%P;\n\tfwt(n,-1,b,b);\n\tllong tmp = b[0]; for(int i=0; i<(1<<n); i++) b[i] = (b[i]-tmp+P)%P;\n\tfor(int i=0; i<(1<<n); i++) printf(\"%lld\\n\",b[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nnamespace IO\n{\n\tchar buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];\n\t#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)\n\t#define gt() getchar()\n\tinline int read()\n\t{\n\t\tint x = 0 , f = 1; char ch = gt();\n\t\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = gt();}\n\t\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}\n\t\treturn x * f;\n\t}\n\ttemplate <class T> inline void write(T x)\n\t{\n\t\tif(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');\n\t\tif(x < 0) *f3 ++ = '-' , x = ~x + 1;\n\t\tchar *top = sta;\n\t\twhile(x) *top ++ = x % 10 + 48 , x /= 10;\n\t\twhile(top != sta) *f3 ++ = *-- top;\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void put(std::string s)\n\t{\n\t\tint len = s.length();\n\t\tfor(int i = 0;i < len;i ++) *f3 ++ = s[i];\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void endline() { *f3 ++ = '\\n';}\n\t#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)\n\ttemplate <class T> inline T abs(T a) { return a < 0 ? -a : a;}\n\ttemplate <class T> inline T max(T a,T b) { return a > b ? a : b;}\n\ttemplate <class T> inline T min(T a,T b) { return a < b ? a : b;}\n\ttemplate <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}\n}\nusing namespace IO;\nconst int N = 1e6 + 5 , mod = 998244353;\nint n;\nll P[N] , E[N] , S[N];\ninline int ksm(ll a,int b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * a % mod;\n\t\ta = a * a % mod; b >>= 1;\n\t}\n\treturn res;\n}\ninline void fwt(ll *f,int x) { for(int len = 2 , k = 1;len <= n;len <<= 1 , k <<= 1) for(int i = 0;i < n;i += len) for(int j = 0;j < k;j ++) f[i + j] = (f[i + j] + f[i + j + k]) % mod , f[i + j + k] = (f[i + j] - f[i + j + k] - f[i + j + k] + mod + mod) % mod , f[i + j] = f[i + j] * x % mod , f[i + j + k] = f[i + j + k] * x % mod;}\nint main()\n{\n\tn = 1 << read(); int sum = 0;\n\tfor(int i = 0;i < n;i ++) sum += (P[i] = read()); sum %= mod; sum = ksm(sum,mod - 2);\n\tfor(int i = 0;i < n;i ++) P[i] = P[i] * sum % mod;\n\tP[0] = (P[0] - 1 + mod) % mod; S[0] = n - 1;\n\tfor(int i = 1;i < n;i ++) S[i] = mod - 1;\n\tfwt(S,1); fwt(P,1);\n\tfor(int i = 1;i < n;i ++) E[i] = S[i] * ksm(P[i],mod - 2) % mod;\n\tfwt(E,(mod + 1) / 2);\n\tint x = mod - E[0];\n\tfor(int i = 0;i < n;i ++) printf(\"%lld\\n\",(E[i] + x) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300010\n#define mod 998244353\n#define ll long long\nusing namespace std;\nint p[maxn], x[maxn], res[maxn], INV;\nvoid fwt(int *a, int n, int opt)\n{\n\tfor (int l = 2; l <= n; l *= 2)\n\t{\n\t\tint m = l / 2;\n\t\tfor (int *p = a; p != a + n; p += l)\n\t\t\tfor (int i = 0; i <= m - 1; i++)\n\t\t\t{\n\t\t\t\tint x = p[i], y = p[i + m];\n\t\t\t\tp[i] = ((ll)x + y) * INV % mod;\n\t\t\t\tp[i + m] = ((ll)x - y + mod) % mod * INV % mod;\n\t\t\t}\n\t}\n}\nint calc(int a, int k)\n{\n\tint ans = 1;\n\twhile (k)\n\t{\n\t\tif (k % 2) ans = (ll)ans * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk /= 2;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n, full;\n\tscanf(\"%d\", &n);\n\tINV = calc(2, mod - 2);\n\tfull = 1 << n;\n\tint sum = 0;\n\tfor (int i = 0; i <= full - 1; i++)\n\t{\n\t\tscanf(\"%d\", &p[i]);\n\t\tsum = (sum + p[i]) % mod;\n\t}\n\tsum = calc(sum, mod - 2);\n\tfor (int i = 0; i <= full - 1; i++)\n\t\tp[i] = (ll)p[i] * sum % mod;\n\tp[0] = (p[0] - 1 + mod) % mod;\n\tx[0] = full - 1;\n\tfor (int i = 1; i <= full - 1; i++)\n\t\tx[i] = mod - 1;\n\tfwt(x, full, 1);\n\tfwt(p, full, 1);\n\tfor (int i = 0; i <= full - 1; i++)\n\t\tres[i] = (ll)x[i] * calc(p[i], mod - 2) % mod;\n\tfwt(res, full, -1);\n\tfor (int i = 0; i <= full - 1; i++)\n\t\tprintf(\"%d\\n\", (res[i] - res[0] + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=1000000 +117;\nconst int MM=1000000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN]={},p[NN]={};\nint len;\nconst int mod=998244353;\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\nvoid fwt(LL a[],int len,int sym){\n\tfor(int d=1;d<len;d<<=1){\n\t\tfor(int st=0;st<len;st+=d<<1){\n\t\t\tfor(int k=0;k<d;++k){\n\t\t\t\tLL x=a[st+k],y=a[st+d+k];\n\t\t\t\ta[st+k]=(x+y)%mod;\n\t\t\t\ta[st+d+k]=(x-y)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(sym==-1){\n\t\tLL bas=ksm(len,mod-2);\n\t\tfor(int i=0;i<len;++i){\n\t\t\ta[i]=a[i]*bas%mod;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tlen=1<<n;\n\tLL s=0;\n\tfor(int i=0;i<len;++i){\n\t\ts+=(p[i]=read());\n\t}\n\ts=ksm(s,mod-2);\n\tfor(int i=0;i<len;++i){\n\t\tp[i]=p[i]*s%mod;\n\t}\n\t(p[0]-=1)%=mod;\n\tfor(int i=0;i<len;++i){\n\t\ta[i]=-1;\n\t}\n\ta[0]+=len;\n\tfwt(a,len,1);\n\tfwt(p,len,1);\n\tfor(int i=0;i<len;++i)a[i]=a[i]*ksm(p[i],mod-2)%mod;\n\tfwt(a,len,-1);\n\tfor(int i=len-1;i>=0;--i){\n\t\t(a[i]-=a[0])%=mod;\n\t\ta[i]=(a[i]+mod)%mod;\n\t}\n\tfor(int i=0;i<len;++i){\n\t\tprintf(\"%lld\\n\",a[i]);\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<num> vn;\n\nvoid FST(vn& a, bool inv) {\n\tfor (int n = sz(a), step = 1; step < n; step *= 2) {\n\t\tfor (int i = 0; i < n; i += 2 * step) rep(j,i,i+step) {\n\t\t\tnum &u = a[j], &v = a[j + step]; tie(u, v) =\n\t\t\t\tpii(u + v, u - v);                   // XOR\n\t\t}\n\t}\n\tif (inv) trav(x, a) x /= sz(a); // XOR only\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tvector<num> a(N), b(N);\n\tnum asum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tint r;\n\t\tcin >> r;\n\t\ta[i] = r;\n\t\tb[i] = -1;\n\t\tasum += a[i];\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\ta[i] /= asum;\n\t}\n\ta[0] -= 1;\n\tb[0] += N;\n\tFST(a, 0); FST(b, 0);\n\tfor(int i = 1; i < N; i++) b[i] /= a[i];\n\tFST(b, 1);\n\tfor(int i = 0; i < N; i++){\n\t\tcout << (int) (b[i] - b[0]) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nnamespace fwht {\n\ntemplate<typename T>\nvoid hadamard(vector<T> &a) {\n  int n = a.size();\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        T x = a[i + j];\n        T y = a[i + j + k];\n        a[i + j] = x + y;\n        a[i + j + k] = x - y;\n      }\n    }\n  }\n}\n\ntemplate<typename T>\nvector<T> multiply(vector<T> a, vector<T> b) {\n  int eq = (a == b);\n  int n = 1;\n  while (n < (int) max(a.size(), b.size())) {\n    n <<= 1;\n  }\n  a.resize(n);\n  b.resize(n);\n  hadamard(a);\n  if (eq) b = a; else hadamard(b);\n  for (int i = 0; i < n; i++) {\n    a[i] *= b[i];\n  }\n  hadamard(a);\n  T q = 1 / static_cast<T>(n);\n  for (int i = 0; i < n; i++) {\n    a[i] *= q;\n  }\n  return a;\n}\n\n}\n\nint n;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  vector<Mint> a(1 << n);\n  Mint sum = 0;\n  range(i, 0, 1 << n) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  range(i, 0, 1 << n) a[i] /= sum;\n  a[0]--;\n  fwht::hadamard(a);\n  vector<Mint> b(1 << n, Mint(-1));\n  b[0] = (1 << n) - 1;\n  fwht::hadamard(b);\n  Mint all = 0;\n  range(i, 1, 1 << n) {\n    b[i] /= a[i];\n    all += b[i];\n  }\n  b[0] = -all;\n  fwht::hadamard(b);\n  range(i, 0, 1 << n) cout << b[i] / Mint(1 << n) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-01-21 18:55:57\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=(1<<18)|10,mod=998244353;\ni64 power(i64 a,i64 b,i64 p)\n{\n\ti64 r=1; a%=p;\n\twhile(b)\n\t{\n\t\tif(b&1) r=r*a%p;\n\t\ta=a*a%p; b>>=1;\n\t}\n\treturn r;\n}\ni64 inv(i64 a){ return power(a,mod-2,mod); }\ni64 n,f[N],g[N],s;\nvoid fwt(i64 *a,i64 n,i64 opt)\n{\n\tfr(i,0,n-1) for(int j=0;j<(1<<n);j+=(1<<(i+1))) fr(k,0,(1<<i)-1)\n\t{\n\t\ti64 x=a[j+k],y=a[j+k+(1<<i)];\n\t\ta[j+k]=(x+y)%mod; a[j+k+(1<<i)]=(x-y+mod)%mod;\n\t}\n\tif(opt==-1)\n\t{\n\t\ti64 I=inv(1<<n);\n\t\tfr(i,0,(1<<n)-1) a[i]=a[i]*I%mod;\n\t}\n}\nint main()\n{\n\tn=read();\n\tfr(i,0,(1<<n)-1) s=(s+(g[i]=read()))%mod;\n\tfr(i,0,(1<<n)-1) g[i]=g[i]*inv(s)%mod;\n\tg[0]=g[0]?g[0]-1:mod-1;\n\tfwt(g,n,1);\n/*\tfr(i,0,(1<<n)-1) f[i]=read();\n//\tfr(i,0,(1<<n)-1) printf(\"%d%c\",int(f[i]),i==end_i?'\\n':' '); // 0 4 4 4\n\tfwt(f,n,1);\n\tfr(i,0,(1<<n)-1) printf(\"%d%c\",int(f[i]),i==end_i?'\\n':' '); // 12 -4 -4 -4\n\tfr(i,0,(1<<n)-1) f[i]=f[i]*g[i]%mod;\n//\tfwt(f,n,-1);\n//\tfr(i,0,(1<<n)-1) printf(\"%d%c\",int(f[i]),i==end_i?'\\n':' '); // 0 4 4 4\n\treturn 0;*/\n\tfr(i,1,(1<<n)-1) f[0]=(f[0]-(f[i]=(1<<n)*inv(g[i])%mod)+mod)%mod;\n\tfwt(f,n,-1);\n\tfr(i,0,(1<<n)-1) printf(\"%d\\n\",int(f[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1 << 18, mod = 998244353;\ntypedef long long LL;\nint n, s, lim, a[N];\n\nvoid reduce(int &x) { x += x >> 31 & mod; }\nint pow(int x, int y, int ans = 1) {\n\tfor (; y; y >>= 1, x = (LL) x * x % mod)\n\t\tif (y & 1) ans = (LL) ans * x % mod;\n\treturn ans;\n}\nvoid fwt(int *A) {\n\tfor (int i = 1; i < lim; i <<= 1)\n\t\tfor (int j = 0; j < lim; j += i << 1)\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tconst int x = A[k + j], y = A[k + j + i];\n\t\t\t\treduce(A[k + j] += y - mod), reduce(A[k + j + i] = x - y);\n\t\t\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, lim = 1 << n;\n\tfor (int i = 0; i < lim; ++i) std::cin >> a[i], s += a[i];\n\ts = pow(s, mod - 2);\n\tfor (int i = 0; i < lim; ++i) a[i] = (LL) a[i] * s % mod;\n\tfwt(a), s = a[0] = 0;\n\tfor (int i = 1; i < lim; ++i)\n\t\ta[i] = pow(mod + 1 - a[i], mod - 2), reduce(s += a[i] - mod);\n\tfwt(a), a[0] = 0;\n\tfor (int i = 1; i < lim; ++i)\n\t\treduce(a[i] = s - a[i]);\n\tfor (int i = 0; i < lim; ++i)\n\t\tstd::cout << a[i] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define N 2000009\n#define mod 998244353\nusing namespace std;\n\nint n,m,a[N];\nvoid fwt(int *a){\n\tint i,j,k,x;\n\tfor (k=1; k<m; k<<=1)\n\t\tfor (i=0; i<m; i+=k<<1)\n\t\t\tfor (j=i; j<i+k; j++){\n\t\t\t\tx=a[j];\n\t\t\t\ta[j]=(a[j]+a[j+k])%mod; a[j+k]=(x-a[j+k]+mod)%mod;\n\t\t\t}\n}\nint ksm(int x,int y){\n\tint ans=1; for (; y; y>>=1,x=(ll)x*x%mod) if (y&1) ans=(ll)ans*x%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n); m=1<<n;\n\tint i,sum=0;\n\tfor (i=0; i<m; i++){ scanf(\"%d\",&a[i]); ad(sum,a[i]); }\n\tsum=ksm(sum,mod-2);\n\tfor (i=0; i<m; i++) a[i]=(ll)a[i]*sum%mod;\n\tfwt(a);\n\ta[0]=0; for (i=1; i<m; i++) a[i]=ksm(a[i]-1+mod,mod-2);\n\tfwt(a);\n\tfor (i=0; i<m; i++) printf(\"%d\\n\",(a[i]-a[0]+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 19, MAX_M = 1 << MAX_N;\nconst ll MOD = 998244353, INV2 = (MOD + 1) / 2;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll x, ll y) { return y ? sq(qpow(x, y / 2)) * (y & 1 ? x : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nint N;\nll A[MAX_M];\n\nvector<ll> solve(const vector<ll> &a, const vector<ll> &b) {\n    if (a.size() == 1) {\n        return {a[0] ? b[0] * inv(a[0]) % MOD : 0};\n    } else {\n        vector<ll> al, ar, bl, br;\n        for (int i = 0; i < a.size(); i += 2) {\n            al.push_back((a[i] + a[i + 1]) % MOD);\n            bl.push_back((b[i] + b[i + 1]) % MOD);\n            ar.push_back((a[i] - a[i + 1] + MOD) % MOD);\n            br.push_back((b[i] - b[i + 1] + MOD) % MOD);\n        }\n        vector<ll> resl = solve(al, bl), resr = solve(ar, br), res;\n        for (int i = 0; i < al.size(); i++) {\n            res.push_back((resl[i] + resr[i]) * INV2 % MOD);\n            res.push_back((resl[i] - resr[i] + MOD) * INV2 % MOD);\n        }\n        return res;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    ll s = 0;\n    for (int i = 0; i < 1 << N; i++) scanf(\"%lld\", &A[i]), s += A[i];\n    s = inv(s);\n    vector<ll> a, b;\n    for (int i = 0; i < 1 << N; i++) a.push_back(A[i] * s % MOD - (i == 0));\n    for (int i = 0; i < 1 << N; i++) b.push_back((MOD - 1 + (i == 0 ? 1 << N : 0)) % MOD);\n    vector<ll> res = solve(a, b);\n    ll t = res[0];\n    for (ll &i : res) (i += MOD - t) %= MOD;\n    for (ll i : res) printf(\"%lld\\n\", i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=270005;\nconst int mod=998244353;\nint n,sum;\nint a[maxn],F[maxn],G[maxn];\n\nint quickpow(int x,int pow){\n\tint res=1;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t}\n\treturn res;\n}\n\nvoid fwt(int *x,int tp){\n\tfor(int m=1;m<(1<<n);m<<=1){\n\t\tfor(int i=0;i<(1<<n);i+=(m<<1)){\n\t\t\tfor(int j=i;j<i+m;j++){\n\t\t\t\tint u=x[j],v=x[j+m];\n\t\t\t\tx[j]=(u+v)%mod;\n\t\t\t\tx[j+m]=(u-v+mod)%mod;\n\t\t\t\tif(tp<0){\n\t\t\t\t\tx[j]=1LL*x[j]*(mod+1)/2%mod;\n\t\t\t\t\tx[j+m]=1LL*x[j+m]*(mod+1)/2%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1<<n){\n\t\tscanf(\"%d\",&F[i]);\n\t\tsum+=F[i];\n\t}\n\tsum=quickpow(sum,mod-2);\n\trep(i,1<<n){\n\t\tF[i]=1LL*F[i]*sum%mod;\n\t\tG[i]=mod-1;\n\t}\n\tF[0]=(F[0]-1+mod)%mod;\n\tG[0]=(1<<n)-1;\n\tfwt(F,1);\n\tfwt(G,1);\n\trep(i,1<<n)F[i]=1LL*quickpow(F[i],mod-2)*G[i]%mod;\n\tfwt(F,-1);\n\trep(i,1<<n)printf(\"%d\\n\",(F[i]-F[0]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inver(a) power(a, mod - 2)\nusing namespace std; \ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f; \n}\ntypedef long long ll;\nconst int mod = 998244353;\nconst int maxn = 1 << 18;\nint r2;\nint n, p[maxn];\nint a[maxn];\ninline int add(int x) {\n\treturn x >= mod ? x - mod : x;\n}\ninline int dec(int x) {\n\treturn x < 0 ? x + mod : x;\n}\nll power(ll x, ll y) {\n\tll re = 1;\n\twhile(y) {\n\t\tif(y & 1) re = re * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\nvoid FWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = add(x + y);\n\t\t\t\t*v = dec(x - y);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid IFWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = (ll)(x + y) * r2 % mod;\n\t\t\t\t*v = (ll)(x - y) * r2 % mod; *v = dec(*v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid init() {\n\tr2 = inver(2);\n\tint sum = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tsum += p[i];\n\t}\n\tsum = inver(sum);\n\tfor(int i = 0; i < n; ++i) {\n\t\tp[i] = (ll)p[i] * sum % mod;\n\t}\n}\nvoid solve() {\n\tinit();\n\tp[0] = dec(p[0] - 1);\n\ta[0] = n - 1;\n\tfor(int i = 1; i < n; ++i) {\n\t\ta[i] = mod - 1;\n\t}\n\tFWT(a, n), FWT(p, n);\n\tfor(int i = 0; i < n; ++i) {\n\t\ta[i] = a[i] * inver(p[i]) % mod;\n\t}\n\tIFWT(a, n);\n\tll rec = a[0];\n\tFWT(a, n);\n\ta[0] = (ll)(mod - rec) * n % mod;\n\tIFWT(a, n);\n}\nint main() {\n\tread(n), n = 1 << n;\n\tfor(int i = 0; i < n; ++i) {\n\t\tread(p[i]);\n\t}\n\tsolve();\n\tfor(int i = 0; i < n; ++i) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1 << 18, mod = 998244353, i2 = (mod + 1) / 2;\n\ntypedef long long LL;\n\ninline int Pow(int x, int y) {\n\tint res = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n\treturn res;\n}\n\ninline void FWT(int a[], int len, int type) {\n\tfor (int mid = 2; mid <= len; mid <<= 1)\n\t\tfor (int i = 0; i < len; i += mid)\n\t\t\tfor (int j = i; j < i + (mid >> 1); j++) {\n\t\t\t\tint t = a[j]; a[j] = (t + a[j + (mid >> 1)]) % mod, a[j + (mid >> 1)] = (t - a[j + (mid >> 1)] + mod) % mod;\n\t\t\t\tif (!type) a[j] = (LL)a[j] * i2 % mod, a[j + (mid >> 1)] = (LL)a[j + (mid >> 1)] * i2 % mod;\n\t\t\t}\n}\n\nint A[N], B[N];\n\nint main() {\n\tint n, sum = 0; scanf(\"%d\", &n), n = 1 << n;\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &A[i]), B[i] = mod - 1, sum = (sum + A[i]) % mod;\n\tsum = Pow(sum, mod - 2);\n\tfor (int i = 0; i < n; i++) A[i] = (LL)A[i] * sum % mod;\n\tB[0] = n - 1, A[0] = (A[0] + mod - 1) % mod;\n\tFWT(A, n, 1), FWT(B, n, 1);\n\tfor (int i = 0; i < n; i++) B[i] = (LL)B[i] * Pow(A[i], mod - 2) % mod;\n\tFWT(B, n, 0);\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", (B[i] - B[0] + mod) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],LL n)\n{\n    for(LL i=1; i<n; i<<=1)\n        for(LL j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;\n            }\n}\n\nvoid IFWT(LL a[],LL n)\n{\n    for(LL i=1; i<n; i<<=1)\n        for(LL j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst i64 MOD = 998244353;\nconst i64 Inv2 = -MOD / 2;\n\ni64 pow(i64 a, i64 k) {\n\ti64 t = 1;\n\tfor (; k; a = a * a % MOD, k >>= 1)\n\t\tif (k & 1) t = t * a % MOD;\n\treturn t;\n}\n\nconst int N = 1 << 18 | 7;\n\nint n;\ni64 p[N], s, q[N];\n\nvoid fwt_xor(i64 f[], int n, int on) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 1 << n; ++j)\n\t\t\tif (j >> i & 1)\n\t\t\t\t( f[j ^ 1 << i] += f[j] ) %= MOD, ( f[j] = f[j ^ 1 << i] - 2 * f[j] ) %= MOD;\n\t\tif (on == 1) continue;\n\t\tfor (int i = 0; i < 1 << n; ++i)\n\t\t\t( f[i] *= Inv2 ) %= MOD;\n\t}\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tscanf(\"%lld\", p + i), s += p[i];\n\ts = pow(s, MOD - 2);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tp[i] = p[i] * s % MOD;\n\t--p[0];\n\tstd::fill(q, q + (1 << n), -1);\n\tq[0] += 1 << n;\n\t\n\tfwt_xor(p, n, 1), fwt_xor(q, n, 1);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tq[i] = q[i] * pow(p[i], MOD - 2) % MOD;\n\tfwt_xor(q, n, -1);\n\t\n\tprintf(\"%lld\\n\", q[0]);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tprintf(\"%lld\\n\", (q[i] - q[0] + MOD * 2) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1 << 20;\nconst int mod = 998244353;\n\nint n;\nint a[N], b[N], p[N], sum;\n\ninline int add( int a, int b ) { return ( a + b ) % mod; }\ninline int mul( int a, int b ) { return ( 1LL * a * b ) % mod; }\ninline void add_eq( int &a, int b ) { a = ( a + b ) % mod; }\ninline void mul_eq( int &a, int b ) { a = ( 1LL * a * b ) % mod; }\n\nint ksm( int a, int p ) {\n\tint res = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) \n\t\t\tres = mul( res, a );\n\t\ta = mul( a, a );\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\ninline int inv( int a ) { return ksm( a, mod - 2 ); }\n\nvoid XOR( int *f, int len, int x = 1 ) {\n\tfor( int o = 2, k = 1; o <= len; o <<= 1, k <<= 1 ) {\n\t\tfor( int i = 0; i < len; i += o ) {\n\t\t\tfor( int j = 0; j < k; j ++ ) {\n\t\t\t\tadd_eq( f[ i + j ], f[ i + j + k ] );\n\t\t\t\tf[ i + j + k ] = add( f[ i + j ], add( - f[ i + j + k ], - f[ i + j + k ] ) );\n\t\t\t\tmul_eq( f[ i + j ], x ); mul_eq( f[ i + j + k ], x );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef woshiluo\n\tfreopen( \"F.in\", \"r\", stdin );\n\tfreopen( \"F.out\", \"w\", stdout );\n#endif\n\tscanf( \"%d\", &n );\n\tn = 1 << n;\n\tfor( int i = 0; i < n; i ++ ) {\n\t\tscanf( \"%d\", &a[i] );\n\t\tsum += a[i];\n\t\tb[i] = mod - 1;\n\t}\n\tsum = inv(sum);\n\tfor( int i = 0; i < n; i ++ ) {\n\t\tp[i] = mul( a[i], sum );\n\t}\n\n\tb[0] = n - 1; p[0] -= 1;\n\tXOR( b, n ); XOR( p, n );\n\tfor( int i = 0; i < n; i ++ ){ \n\t\tmul_eq( b[i], inv( p[i] ) );\n\t}\n\tXOR( b, n, inv(2) );\n\tfor( int i = 0; i < n; i ++ ) {\n\t\tprintf( \"%d\\n\", ( ( add( b[i], -b[0] ) + mod ) % mod ) );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=x+y,a[i+j+k]=x-y;\n            }\n}\n\nvoid IFWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 1 << 18 ; \nconst int P = 998244353 ; \nconst int I = 499122177 ;\nint n, limit, A[N] ; \nint fpow( int x, int k ) {\n\tint ans = 1, base = x ; \n\twhile(k) {\n\t\tif( k & 1 ) ans = ans * base % P ; \n\t\tbase = base * base % P, k >>= 1 ;  \n\t} return ans ; \n}\nvoid FWT( int *a ) {\n\tfor( re int k = 1; k < limit; k <<= 1 ) \n\tfor( re int i = 0; i < limit; i += ( k << 1 ) )\n\tfor( re int j = i; j < i + k; ++ j )  {\n\t\tint nx = a[j], ny = a[j + k] ;\n\t\ta[j] = ( nx + ny ) % P, a[j + k] = ( nx - ny + P ) % P ; \n\t}\n}\nvoid IFWT( int *a ) {\n\tfor( re int k = 1; k < limit; k <<= 1 ) \n\tfor( re int i = 0; i < limit; i += ( k << 1 ) )\n\tfor( re int j = i; j < i + k; ++ j )  {\n\t\tint nx = a[j], ny = a[j + k] ;\n\t\ta[j] = ( nx + ny ) * I % P, a[j + k] = ( nx - ny + P ) * I % P ; \n\t}\n}\nsigned main()\n{\n\tn = gi(), limit = ( 1 << n ) ; int S = 0 ;\n\trep( i, 1, limit ) A[i - 1] = gi(), S += A[i - 1] ; \n\tS = fpow( S, P - 2 ) ;\n\trep( i, 1, limit ) A[i - 1] = A[i - 1] * S % P ; \n\tFWT( A ), A[0] = 0 ; \n\tfor( re int i = 1; i < limit; ++ i ) \n\t\tA[i] = ( P - limit ) * fpow( 1 - A[i] + P, P - 2 ) % P,\n\t\tA[0] = ( A[0] + P - A[i] ) % P ; \n\tIFWT( A ) ;\n\trep( i, 1, limit ) printf(\"%lld\\n\", A[i - 1] % P ) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 998244353\n#define inv2 499122177\n#define eps 1e-8\nint n;\nll a[1001000],f[1001000],g[1001000];\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nvoid fwt_xor(int lim,ll *a,int typ)\n{\n    int mid;\n    for (mid=1;mid<lim;mid<<=1)\n    {\n        int len=(mid<<1),sta,j;\n        for (sta=0;sta<lim;sta+=len)\n        {\n            for (j=0;j<mid;j++)\n            {\n                ll x=a[sta+j],y=a[sta+j+mid];\n                a[sta+j]=(x+y)%maxd;\n                a[sta+j+mid]=(x+maxd-y)%maxd;\n                if (typ==-1) {a[sta+j]=a[sta+j]*inv2%maxd;a[sta+j+mid]=a[sta+j+mid]*inv2%maxd;}\n            }\n        }\n    }\n}\n\nll qpow(ll x,int y)\n{\n    ll ans=1;\n    while (y)\n    {\n        if (y&1) ans=ans*x%maxd;\n        x=x*x%maxd;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    n=read();int lim=(1<<n);\n    ll sum=0;\n    rep(i,0,lim-1) {a[i]=read();sum=(a[i]+sum)%maxd;}\n    sum=qpow(sum,maxd-2);\n    rep(i,0,lim-1) {f[i]=maxd-1;g[i]=a[i]*sum%maxd;}\n    f[0]=lim-1;g[0]=(g[0]+maxd-1)%maxd;\n    fwt_xor(lim,f,1);fwt_xor(lim,g,1);\n    rep(i,0,lim-1) f[i]=f[i]*qpow(g[i],maxd-2)%maxd;\n    fwt_xor(lim,f,-1);\n    rep(i,0,lim-1)\n        printf(\"%lld\\n\",(f[i]-f[0]+maxd)%maxd);\n    return 0;\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int mod = 998244353;\nconst int inv = (mod + 1) / 2;\n\nint n, a[1<<maxn], b[1<<maxn];\n\nint qpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1LL * ret * x % mod;\n\t\tx = 1LL * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid fwt(int *a, int l, int r) {\n\tif (l == r) return;\n\tint m = (l + r) >> 1, t = (r-l+1) >> 1;\n\tfwt(a, l, m);\n\tfwt(a, m+1, r);\n\tfor (int i = l; i <= m; i++) {\n\t\tint v0 = (a[i] + a[i+t]) % mod, v1 = (a[i] + mod - a[i+t]) % mod;\n\t\ta[i] = v0; a[i+t] = v1;\n\t}\n}\n\nvoid ifwt(int *a, int l, int r) {\n\tif (l == r) return;\n\tint m = (l + r) >> 1, t = (r-l+1) >> 1;\n\tfor (int i = l; i <= m; i++) {\n\t\tint v0 = 1LL * inv * (a[i] + a[i+t]) % mod, v1 = 1LL * inv * (a[i] + mod - a[i+t]) % mod;\n\t\ta[i] = v0; a[i+t] = v1;\n\t}\n\tifwt(a, l, m);\n\tifwt(a, m+1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (1<<n); i++) scanf(\"%d\", &a[i]);\n\tint s = 0;\n\tfor (int i = 0; i < (1<<n); i++) s = (s + a[i]) % mod;\n\tfor (int i = 0; i < (1<<n); i++) a[i] = 1LL * qpow(s, mod-2) * a[i] % mod;\n\tfor (int i = 0; i < (1<<n); i++) a[i] = (mod - a[i]) % mod;\n\ta[0] = (a[0] + 1) % mod;\n\tfwt(a, 0, (1<<n)-1);\n\tfor (int i = 1; i < (1<<n); i++) a[i] = 1LL * qpow(a[i], mod-2) * (mod - (1<<n)) % mod;\n\tifwt(a, 0, (1<<n)-1);\n\tfor (int i = 1; i < (1<<n); i++) a[i] = (a[i] + mod - a[0]) % mod;\n\ta[0] = 0;\n\tfor (int i = 0; i < (1<<n); i++) printf(\"%d\\n\", a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nnamespace Convolusion{\n    /*\n     Aのサイズは2^nとなっていること。\n     \n     R_k=sum_(i&j=k),A_i B_j\n     R=mobius(zeta(A),zeta(B))\n     上位集合の畳み込みの積をとって逆変換\n     \n     R_k=sum_(i|j=k),A_i B_j\n     R=mobius(zeta(A),zeta(B))\n     下位集合の畳み込みの積をとって逆変換\n     */\n    \n    //R_i=sum_(j in i),A_j\n    //下位集合の畳み込み　上位集合の畳み込みはif文のなかの等号の左右を反対にする。\n    template<typename T>\n    vector<T> zeta(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((j&i)==0){ret[j|i]+=ret[j];}\n            }\n        }\n        return ret;\n    }\n    \n    //R_i=sum_(j in i),(-1)^(|i\\j|) A_j\n    //ゼータ変換の逆変換\n    template<typename T>\n    vector<T> mobius(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((j&i)==0){ret[j|i]-=ret[j];}\n            }\n        }\n        return ret;\n    }\n    \n    //R_i=sum_(j),(-1)^(|i&j|) A_j\n    //オーバーフローに注意,sqrt(|A|)で割ると直交かつ対称な変換になる\n    template<typename T>\n    vector<T> hadamard(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((i&j)==0){\n                    T P=ret[j],Q=ret[j|i];\n                    ret[j]=P+Q;\n                    ret[j|i]=P-Q;\n                }\n            }\n        }\n        return ret;\n    }\n    \n    //R_i=sum_(j),r^(ij) A_j\n    //オーバーフローに注意,sqrt(|A|)で割るとユニタリかつエルミートな変換になる,rは1の原始|A|乗根\n    template<typename T>\n    vector<T> fourier(const vector<T> &A,int n,T r){\n        vector<T> ret=A;\n        vector<T> E(1<<n,1);\n        for(int i=1;i<1<<n;i++){E[i]=E[i-1]*r;}\n        for(int i=0,j=1;j<1<<n;j++){\n            for(int k=1<<(n-1);k>(i^=k);k>>=1);\n            if(i>j){swap(ret[i],ret[j]);}\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<1<<n;j+=2<<i){\n                for(int k=0;k<1<<i;k++){\n                    T P=ret[j|k],Q=ret[j|1<<i|k]*E[(1<<n-i-1)*k];\n                    ret[j|k]=P+Q;\n                    ret[j|1<<i|k]=P-Q;\n                }\n            }\n        }\n        return ret;\n    }\n};\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\n\ntemplate<long long MOD>istream & operator >> (istream &i,Mod_Int<MOD> &A){ll a; cin>>a; A=Mod_Int<MOD>(a); return i;}\ntemplate<long long MOD>ostream & operator << (ostream &i,Mod_Int<MOD> &A){i<<A.a; return i;}\n\nusing namespace Convolusion;\ntypedef Mod_Int<998244353> Int;\n\nint main(){\n    ll n;\n    cin>>n;\n    Int sum=0;\n    vector<Int> A(1<<n);\n    Int X=1<<n;\n    cin>>A;\n    for(auto &I:A){sum+=I;}\n    for(auto &I:A){I/=sum;}\n    A[0]-=1;\n    A=hadamard<Int>(A,n);\n    sum=0;\n    for(int i=1;i<1<<n;i++){A[i]=X/A[i]; sum-=A[i];}\n    A[0]=sum;\n    A=hadamard(A,n);\n    for(auto &I:A){I/=1<<n; cout<<I<<endl;}\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nconst int N=262150;\nint n;\nint p[N],f[N];\ninline ll qpow(ll x,int k,ll r=1){\n\tfor(;k;k>>=1,x=x*x%mod) if(k&1) r=r*x%mod;\n\treturn r;\n}\ninline void fwt(int *a,int len,int opt){\n\tfor(int i=1;i<len;i<<=1) for(int j=0;j<len;j+=i<<1) for(int k=0;k<i;++k){\n\t\tint x=a[j+k],y=a[j+k+i];\n\t\ta[j+k]=(x+y)%mod; a[j+k+i]=(x-y+mod)%mod;\n\t}\n\tif(~opt) return ;\n\tint inv=qpow(len,mod-2);\n\tfor(int i=0;i<len;++i) a[i]=1ll*a[i]*inv%mod;\n}\nint main(){\n\tscanf(\"%d\",&n); int len=1<<n,sum=0;\n\tfor(int i=0;i<len;++i) scanf(\"%d\",&p[i]),sum+=p[i]; sum=qpow(sum,mod-2);\n\tfor(int i=0;i<len;++i) p[i]=1ll*p[i]*sum%mod; (p[0]+=mod-1)%=mod;\n\tfor(int i=0;i<len;++i) f[i]=mod-1; (f[0]+=len)%=mod;\n\tfwt(f,len,1); fwt(p,len,1); sum=0;\n\tfor(int i=1;i<len;++i) f[i]=f[i]*qpow(p[i],mod-2)%mod,(sum+=f[i])%=mod;\n\tf[0]=mod-sum; fwt(f,len,-1);\n\tfor(int i=0;i<len;++i) printf(\"%d\\n\",f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define rnt re int\n#define re register\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) ('0'<=ch&&ch<='9')\n#define FOR(i,a,b) for(rnt i=a;i<=b;i++)\n#define ROF(i,a,b) for(rnt i=a;i>=b;i--)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\trnt _s=0;re char _ch=gc;\n\twhile(!isnum(_ch))_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s;\n}\nconst int N=1<<19,mod=998244353,inv2=mod+1>>1;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nI Pow(ll t,rnt x){\n\tll s=1;\n\tfor(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;\n\treturn s;\n}\nint n,a[N],p[N];\nV input(){\n\tn=getint();rnt l=1<<n;\n\tFOR(i,0,l-1)a[i]=getint();\n}\nV FWT(int*a,rnt l){\n\tfor(rnt i=1;i<l;i<<=1)for(rnt j=0,d=i<<1;j<l;j+=d)FOR(k,0,i-1){\n\t\trnt Nx=a[j+k],Ny=a[i+j+k];\n\t\tcheck(a[j+k]=Nx+Ny),check(a[i+j+k]=Nx-Ny+mod);\n\t}\n}\nV IFWT(int*a,rnt l){\n\tfor(rnt i=1;i<l;i<<=1)for(rnt j=0,d=i<<1;j<l;j+=d)FOR(k,0,i-1){\n\t\trnt Nx=a[j+k],Ny=a[i+j+k];\n\t\tcheck(a[j+k]=Nx+Ny),check(a[i+j+k]=Nx-Ny+mod);\n\t\ta[j+k]=1ll*a[j+k]*inv2%mod;\n\t\ta[i+j+k]=1ll*a[i+j+k]*inv2%mod;\n\t}\n}\nV init(){\n\trnt sum=0,l=1<<n;\n\tFOR(i,0,l-1)sum+=a[i];sum=Pow(sum,mod-2);\n\tFOR(i,0,l-1)a[i]=1ll*a[i]*sum%mod;\n\ta[0]--;\n}\nV work(){\n\trnt l=1<<n;p[0]=l-1;\n\tFOR(i,1,l-1)p[i]=mod-1;\n\tFWT(a,l),FWT(p,l);\n\tFOR(i,0,l-1)\n\t\ta[i]=1ll*p[i]*Pow(a[i],mod-2)%mod;\n\tIFWT(a,l);\n\tFOR(i,0,l-1)\n\t\tcout<<(a[i]+mod-a[0])%mod<<' ';\n}\nint main(){\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MOD = 998244353;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\nvoid adamar(vector<int> &x) {\n  size_t n = x.size();\n  for (size_t i = 1; i < n; i *= 2) {\n    for (size_t j = 0; j < n; j++) {\n      if (!(j & i)) {\n        int a = x[j];\n        int b = x[j ^ i];\n//        eprintf(\"%d %d -> \", x[j], x[j ^ i]);\n        x[j] = a;\n        add(x[j], b);\n        x[j ^ i] = a;\n        sub(x[j ^ i], b);\n//        eprintf(\"%d %d\\n\", x[j], x[j ^ i]);\n      }\n    }\n  }\n}\n\nvoid out(int n) {\n  for (int i = 1; i < 100; i++) {\n    int x = mul(n, i);\n    if (x < 100) {\n      eprintf(\"%d/%d\\n\", x, i);\n      return;\n    } else if (x > MOD - 100) {\n      eprintf(\"-%d/%d\\n\", MOD - x, i);\n      return;\n    }\n  }\n  eprintf(\"??[%d]\", n);\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    n = (1 << n);\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n      add(s, a[i]);\n    }\n    adamar(a);\n\n    vector<int> result(n);\n    int n2 = mul(s, n);\n    result[0] = n2;\n    for (int i = 1; i < n; i++) {\n      int t = a[i];\n      sub(t, a[0]);\n      result[i] = mul(s, minv(t));\n      sub(result[0], mul(a[i], result[i]));\n    }\n    result[0] = mul(result[0], minv(a[0]));\n\n    int temp = 0;\n    for (int i = 0; i < n; i++) {\n      add(temp, mul(result[i], a[i]));\n    }\n    assert(temp == n2);\n\n    adamar(result);\n    for (int i = 0; i < n; i++) {\n      sub(result[i], 1);\n      printf(\"%d\\n\", result[i]);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\n\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\n\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\n\n#pragma endregion\n\nconstexpr long long MOD = /** 1000000007;  //*/ 998244353;\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n\n  static constexpr int get_mod() { return mod; }\n};\nusing mint = ModInt<MOD>;\nusing vm = vector<mint>;\n\ntemplate <typename T>\nvoid fwt(vector<T> &f) {\n  int n = f.size();\n  for (int i = 1; i < n; i <<= 1) {\n    for (int j = 0; j < n; j++) {\n      if ((j & i) == 0) {\n        T x = f[j], y = f[j | i];\n        f[j] = x + y, f[j | i] = x - y;\n      }\n    }\n  }\n}\n\nvoid solve() {\n  ini(n);\n  int N = 1 << n;\n  vl a(N);\n  in(a);\n  ll s = accumulate(all(a), 0LL);\n  mint invs = mint(1) / s;\n  vm A(N);\n  rep(i, N) A[i] = mint(a[i]) * invs;\n  A[0] -= 1;\n  vm F(N);\n  rep1(i, N - 1) F[i] = -1;\n  F[0] = N - 1;\n\n  fwt(A);\n  fwt(F);\n  rep1(i, N - 1) F[i] /= A[i];\n  fwt(F);\n  rep(i, N) F[i] /= N;\n  repr(i,N) F[i]-=F[0];\n  rep(i,N) out(F[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MAX_N 18\n#define MAX_POWN ( 1 << MAX_N )\n#define MOD 998244353\n\nusing namespace std;\n\nnamespace mod\n{\ntemplate <uint_fast64_t mod>\nstruct Modint\n{\nprivate:\n    uint_fast64_t val;\n\npublic:\n    constexpr Modint( const uint_fast64_t val = 0 ) : val( val % mod ) {}\n\n    constexpr uint_fast64_t &value() noexcept { return val; }\n\n    constexpr const uint_fast64_t &value() const noexcept { return val; }\n\n    constexpr Modint operator+( const Modint &rhs ) const noexcept\n    {\n        return Modint( *this ) += rhs;\n    }\n\n    constexpr Modint operator-( const Modint &rhs ) const noexcept\n    {\n        return Modint( *this ) -= rhs;\n    }\n\n    constexpr Modint operator*( const Modint &rhs ) const noexcept\n    {\n        return Modint( *this ) *= rhs;\n    }\n\n    constexpr Modint operator/( const Modint &rhs ) const noexcept\n    {\n        return Modint( *this ) /= rhs;\n    }\n\n    constexpr Modint &operator+=( const Modint &rhs ) noexcept\n    {\n        val += rhs.val;\n        if ( val > mod ) val -= mod;\n        return *this;\n    }\n\n    constexpr Modint &operator-=( const Modint &rhs ) noexcept\n    {\n        if ( val < rhs.val ) val += mod;\n        val -= rhs.val;\n        return *this;\n    }\n\n    constexpr Modint &operator*=( const Modint &rhs ) noexcept\n    {\n        val *= rhs.val;\n        val %= mod;\n        return *this;\n    }\n\n    constexpr Modint &operator/=( const Modint &rhs ) noexcept\n    {\n        uint_fast64_t a = rhs.val;\n        uint_fast64_t b = mod;\n        uint_fast64_t x = 1;\n        uint_fast64_t y = 0;\n\n        while ( b > 0 )\n        {\n            uint_fast64_t q = a / b;\n            a -= q * b;\n            x -= q * y;\n\n            swap( a, b );\n            swap( x, y );\n        }\n\n        val *= ( x + mod ) % mod;\n        val %= mod;\n\n        return *this;\n    }\n\n    friend constexpr ostream &operator<<( ostream &o, const Modint &m )\n    {\n        return ( o << ( m.val ) );\n    }\n\n    friend constexpr istream &operator>>( istream &i, Modint &m )\n    {\n        return ( i >> ( m.val ) );\n    }\n};\n\n// Modint Womparer\n\ntemplate <uint_fast64_t mod>\ninline bool const operator<( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return l.value() < r.value();\n}\n\ntemplate <uint_fast64_t mod>\ninline bool operator>( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return r < l;\n}\n\ntemplate <uint_fast64_t mod>\ninline bool operator<=( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return !( l > r );\n}\n\ntemplate <uint_fast64_t mod>\ninline bool operator>=( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return !( l < r );\n}\n\n// Modint Equality Womparer\n\ntemplate <uint_fast64_t mod>\ninline bool operator==( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return l.value() == r.value();\n}\n\ntemplate <uint_fast64_t mod>\ninline bool operator!=( const Modint<mod> &l, const Modint<mod> &r )\n{\n    return !( l == r );\n}\n} // namespace mod\n\nusing mint = mod::Modint<MOD>;\n\nmint A[MAX_POWN];\nmint B[MAX_POWN];\n\nvoid f( mint *A, int size )\n{\n    for ( int n = size, step = 1; step < n; step *= 2 )\n    {\n        for ( int i = 0; i < n; i += 2 * step )\n        {\n            for ( int j = i; j < i + step; j++ )\n            {\n                mint u = A[j];\n                mint v = A[j + step];\n                A[j] = u + v;\n                A[j + step] = u - v;\n            }\n        }\n    }\n}\n\nint main( int argc, char **argv )\n{\n    int N;\n    cin >> N;\n\n    N = ( 1 << N );\n\n    mint S = 0;\n    for ( int i = 0; i < N; i++ ) cin >> A[i];\n    for ( int i = 0; i < N; i++ ) B[i] = -1;\n    for ( int i = 0; i < N; i++ ) S += A[i];\n    for ( int i = 0; i < N; i++ ) A[i] /= S;\n\n    A[0] -= 1;\n    B[0] += N;\n\n    f( A, N );\n    f( B, N );\n\n    for ( int i = 1; i < N; i++ ) B[i] /= A[i];\n\n    f( B, N );\n\n    for ( int i = 0; i < N; i++ ) B[i] /= N;\n\n    for ( int i = 0; i < N; i++ ) cout << B[i] - B[0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//it's nice to stick a fork into an open socket\n//clock says it's time to sleep\n//our getppid() in heaven, hallowed by ttyname\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define FOR(i,b,e)for(urs((b)+(e))i=(b);i<=(e);++i)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define FORD(i,b,e)for(urs((b)+(e))i=(b);i>=(int)(e);--i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define FS(r)r.first,r.second\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim>using ordered_set=tree<c,null_type,less<c>,rb_tree_tag,tree_order_statistics_node_update>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#ifdef LOCAL\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=a*(ld)b/m;ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\n#define q31 (8 * sizeof(c) - 1)\nsim> typename enable_if<is_signed<c>::value, c>::type FastMax(c x, c y) { return ((x - y) >> q31 & (x ^ y)) ^ x; }\nsim> typename enable_if<is_signed<c>::value, c>::type FastMin(c x, c y) { return ((x - y) >> q31 & (x ^ y)) ^ y; }\nsim> typename enable_if<is_signed<c>::value, c>::type FastAbs(c x)        { return (x ^ x >> q31) - (x >> q31); }\nsim> typename enable_if<is_signed<c>::value, c>::type gcd(c a, c b) {\n\tloc(assert(a > 0 && b > 0));\n\tint aa = ctz(a), bb = ctz(b);\n\tint r = FastMin(aa, bb);\n\ta >>= aa;\n\twhile (a && b) {\n\t\tb >>= ctz(b);\n\t\tc x = FastAbs(a - b);\n\t\ta = FastMin(a, b);\n\t\tb = x;\n\t}\n\treturn (a + b) << r;\n}\nsim> c lcm(c a, c b) {return a / gcd(a, b) * b;}\nsim>typename enable_if<is_integral<c>::value,ull>::type my_hash(c x){\n\tif(sizeof(c)>8) return mix((ull)x^SALT)^mix((ull)(x>>64)^SALT);\n\treturn mix(x^SALT);\n}\ntemplate<size_t N>ull my_hash(const bitset<N>&x){\n\treturn mix(hash<bitset<N>>()(x)^SALT);\n}\nsim,class n>ull my_hash(const pair<c,n>&);\nsim>gyv<ull,typename c::value_type>my_hash(const c&x){\n\tull o=SALT;\n\tfor(auto&d:x)o=mix(o^my_hash(d));\n\tros;\n}\nsim,class n>ull my_hash(const pair<c,n>&x){return mix(my_hash(x.first))^my_hash(x.second);}\nsim>struct my_hasher{size_t operator()(const c&o)const{return my_hash(o);}};\nsim, class m>\n#ifdef LOCAL\nusing _un0rDer3d_M4P=unordered_map<c,m,my_hasher<c>>;\nsim> using _un0rDer3d_5et = unordered_set<c, my_hasher<c>>;\n#else\nstruct _un0rDer3d_M4P : public cc_hash_table<c,m,my_hasher<c>>{bool count(const c&x)const{return this->find(x) != this->end();}};\nsim> using _un0rDer3d_5et = _un0rDer3d_M4P<c, null_type>;\n#endif\n#define unordered_map _un0rDer3d_M4P\n#define unordered_set _un0rDer3d_5et\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n#define rer(o,f) zet_p operator o(zet_p y)const{return zet_p(v f loc(,w o y.w));}zet_p&operator o##=(zet_p y){return*this=*this o y;}\n#define ycc(o) sim>typename enable_if<is_integral<c>::value,zet_p>::type operator o(c a, zet_p b){return zet_p(a) o b;}\nconst int mod = 119 << 23 | 1;\nll inv(ll b){assert(b);int e=mod-2;ll o=1;while(e){if(e&1)o=o*b%mod;b=b*b%mod;e>>=1;}ros;}struct zet_p{int v;loc(ld w;)sim=int,typename=typename enable_if<is_integral<c>::value>::type>zet_p(c r=0):v(r%mod)loc(,w(r)){}loc(sim>zet_p(c a, ld b):v(a%mod),w(b){})rer(+,+y.v)rer(-,-y.v)rer(*,*1ll*y.v)rer(/,*inv(y.v))int get()const{return ((unt)v+mod)%mod;}zet_p operator-()const{return zet_p(-v loc(,-w));}bool operator==(zet_p y)const{return(v-y.v)%mod==0;}};ycc(+)ycc(-)ycc(*)ycc(/)sim>bool operator==(c a, zet_p b){return zet_p(a)==b;}loc(ostream&operator<<(ostream &o,zet_p y){ros<<\"[\"<<y.get()<<\"~\"<<y.w<<\"]\";})\nconst int nax = 1 << 18;\nzet_p a[nax], v[nax], ans[nax];\nvoid transform(zet_p a[], int n, bool inv) {\n\tconst int N = 1 << n;\n\tdebug(range(a, a + N), imie(inv));\n\tREP(i, n) REP(m, N) if (m >> i & 1) {\n\t\tzet_p x = a[m ^ (1 << i)], y = a[m];\n\t\ta[m ^ (1 << i)] = x + y;\n\t\ta[m] = x - y;\n\t}\n\tif (inv) {\n\t\tzet_p d = zet_p(1) / N;\n\t\tREP(i, N) a[i] *= d;\n\t}\n\tdebug(range(a, a + N));\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tconst int N = 1 << n;\n\tint s = 0;\n\tREP(i, N) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\ts += p;\n\t\ta[i] = p;\n\t}\n\tzet_p inv = zet_p(1) / s;\n\tREP(i, N) a[i] *= inv;\n\tREP(i, N) v[i] = 1;\n\tv[0] -= N;\n\ta[0] -= 1;\n\tdebug(range(a, 0, N));\n\ttransform(a, n, false);\n\ttransform(v, n, false);\n\tdebug(range(a, 0, N), range(v, 0, N));\n\tREP(i, N) {\n\t\tif (i) ans[i] = -v[i] / a[i];\n\t}\n\ttransform(ans, n, true);\n\tzet_p sub = ans[0];\n\tREP(i, N) ans[i] -= sub;\n\tdebug(range(ans, 0, N));\n\tREP(i, N) printf(\"%d\\n\", ans[i].get());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MOD = 998244353;\nconst int INV2 = (MOD + 1) >> 1;\n\nint add(int x, int y) {return (x + y >= MOD ? x + y - MOD : x + y);}\nint sub(int x, int y) {return (x - y < 0 ? x - y + MOD : x - y);}\nint mul(int x, int y) {return 1LL*x*y%MOD;}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret,b);\n\treturn ret;\n}\n\nstruct node{\n\tint k, b;\n\tnode() : k(0), b(0) {}\n\tnode(int _k, int _b) : k(_k), b(_b) {}\n\tint get(int x) {return add(mul(k, x), b);}\n\tfriend node operator + (node a, node b) {\n\t\treturn node(add(a.k, b.k), add(a.b, b.b));\n\t}\n\tfriend node operator - (node a, node b) {\n\t\treturn node(sub(a.k, b.k), sub(a.b, b.b));\n\t}\n\tfriend node operator * (node a, int k) {\n\t\treturn node(mul(a.k, k), mul(a.b, k));\n\t}\n\tfriend node operator / (node a, int k) {\n\t\treturn a * pow_mod(k, MOD - 2);\n\t}\n};\n\nvoid fwt(node *A, int m, int type) {\n\tint n = (1 << m), f = (type == 1 ? 1 : INV2);\n\tfor(int i=1;i<=m;i++) {\n\t\tint s = (1 << i), t = (s >> 1);\n\t\tfor(int j=0;j<n;j+=s)\n\t\t\tfor(int k=0;k<t;k++) {\n\t\t\t\tnode x = A[j+k], y = A[j+k+t];\n\t\t\t\tA[j+k] = (x + y)*f, A[j+k+t] = (x - y)*f;\n\t\t\t}\n\t}\n}\n\nnode A[1<<18], B[1<<18], C[1<<18], f[1<<18];\n\nint main() {\n\tint N, M, S = 0; scanf(\"%d\", &N), M = (1 << N);\n\tfor(int i=0;i<M;i++) scanf(\"%d\", &A[i].b), S = add(S, A[i].b);\n\tS = pow_mod(S, MOD - 2);\n\tfor(int i=0;i<M;i++) A[i].b = sub(i == 0 ? 1 : 0, mul(A[i].b, S));\n\tfor(int i=0;i<M;i++) B[i].b = 1;\n\tC[0].b = MOD - 1;\n\tfwt(A, N, 1), fwt(B, N, 1), fwt(C, N, 1);\n\tint tmp = mul(B[0].b, pow_mod(C[0].b, MOD-2));\n\tfor(int i=1;i<M;i++)\n\t\tf[i] = (B[i] - C[i]*tmp) / A[i].b;\n\tf[0].k = 1; fwt(f, N, -1);\n\tint x = sub(0, mul(pow_mod(f[0].k, MOD-2), f[0].b));\n\tfor(int i=0;i<M;i++) printf(\"%d\\n\", f[i].get(x));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int inv2=(mod+1)/2;\ninline int qpow(int d,int z,int t=0,int a=1){\n\tfor(;z;z>>=1,d=1ll*d*d%(mod-t))\n\t\tif(z&1) a=1ll*a*d%(mod-t); return a;\n}\nconst int N=20;\n\nint n,s,a[1<<N],b[1<<N];\ninline void fwt(int *a){\n\tfor(int i=0;i<(1<<n);++i) if(a[i]<0) a[i]+=mod;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int len=1<<i,j=0;j<(1<<n);j+=2*len){\n\t\t\tfor(int p=0;p<len;++p){\n\t\t\t\tint x=a[j+p],y=a[j+len+p];\n\t\t\t\ta[j+p]=(x+y)%mod;\n\t\t\t\ta[j+p+len]=(x-y+mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n}\ninline void ifwt(int *a){\n\tfor(int i=0;i<n;++i){\n\t\tfor(int len=1<<i,j=0;j<(1<<n);j+=2*len){\n\t\t\tfor(int p=0;p<len;++p){\n\t\t\t\tint x=a[j+p],y=a[j+len+p];\n\t\t\t\ta[j+p]=1ll*inv2*(x+y)%mod;\n\t\t\t\ta[j+p+len]=1ll*inv2*(x-y+mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n); b[0]=1<<n;\n\tfor(int i=0;i<(1<<n);++i) --b[i],scanf(\"%d\",&a[i]),s+=a[i];\n\tfor(int i=0;i<(1<<n);++i) a[i]=1ll*a[i]*qpow(s,mod-2)%mod;\n\t--a[0]; fwt(a); fwt(b);\n\tfor(int i=1;i<(1<<n);++i) a[i]=1ll*b[i]*qpow(a[i],mod-2)%mod;\n\ta[0]=0; ifwt(a);\n\tint x=mod-a[0];\n\tfor(int i=0;i<(1<<n);++i) printf(\"%d\\n\",(a[i]+x)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 998244353;\ninline int Sum(int x, int y) { return (x += y) >= MOD ? (x - MOD) : x; }\ninline int Sub(int x, int y) { return (x -= y) < 0 ? (x + MOD) : x; }\ninline int quick_pow(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nvoid solve(int *ans, int *arr, int *goal, int n)\n{\n\tif (!n)\n\t{\n\t\tif (!arr[0])\n\t\t\tans[0] = 0;\n\t\telse\n\t\t\tans[0] = (ll)goal[0] * quick_pow(arr[0], MOD - 2) % MOD;\n\t\treturn;\n\t}\n\tauto trans = [&] (int &x, int &y)\n\t{\n\t\tint a = x, b = y;\n\t\tx = Sum(a, b);\n\t\ty = Sub(a, b);\n\t};\n\tint len = 1 << n - 1;\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\ttrans(arr[i], arr[i + len]);\n\t\ttrans(goal[i], goal[i + len]);\n\t}\n\tsolve(ans, arr, goal, n - 1);\n\tsolve(ans + len, arr + len, goal + len, n - 1);\n\tfor (int i = 0; i < len; i++)\n\t\ttrans(ans[i], ans[i + len]);\n\tfor (int i = 0; i < len << 1; i++)\n\t\tans[i] = (ll)ans[i] * (MOD + 1) / 2 % MOD;\n}\nint ans[300005], arr[300005], goal[300005];\nint main()\n{\n\t// freopen(\"AGC034-F.in\", \"r\", stdin);\n\tint n, sum = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\t\tsum += arr[i];\n\t}\n\tsum = quick_pow(sum, MOD - 2);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tarr[i] = (ll)arr[i] * sum % MOD;\n\tarr[0] = Sub(arr[0], 1);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tgoal[i] = MOD - 1;\n\tgoal[0] = Sum(goal[0], 1 << n);\n\tsolve(ans, arr, goal, n);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tprintf(\"%d\\n\", Sub(ans[i], ans[0]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 18, S = 1 << N, Mod = 998244353;\n\ninline int fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nint n, len, p[S], s[S], sum;\n\nvoid FWT(int *P, int opt) {\n\tfor (int i = 2, p; p = i >> 1, i <= len; i <<= 1)\n\t\tfor (int j = 0; j < len; j += i) Rep (k, p) {\n\t\t\tint u = P[j + k], v = P[j + k + p];\n\t\t\tP[j + k] = (u + v) % Mod; P[j + k + p] = (u + Mod - v) % Mod;\n\t\t}\n\tif (!~opt) {\n\t\tint invn = fpm(len, Mod - 2);\n\t\tRep (i, len) P[i] = 1ll * P[i] * invn % Mod;\n\t}\n}\n\nint main() {\n\n\tFile();\n\n\tlen = 1 << (n = read());\n\tRep (i, len) (sum += p[i] = read()) %= Mod;\n\tsum = fpm(sum, Mod - 2);\n\tRep (i, len) p[i] = 1ll * sum * p[i] % Mod; -- p[0];\n\tRep (i, len) s[i] = (i ? 0 : len) - 1;\n\n\tFWT(p, 1); FWT(s, 1); Rep (i, len) p[i] = 1ll * s[i] * fpm(p[i], Mod - 2) % Mod; FWT(p, -1);\n\n\tRep (i, len) printf (\"%d\\n\", (p[i] - p[0] + Mod) % Mod);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=18,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint inv2=(mod+1)>>1;\nint n;\nint a[N];\nvoid FWT(int *a,int n,int flag){\n\tfor (int d=1;d<n;d<<=1)\n\t\tfor (int i=0;i<n;i+=d<<1)\n\t\t\tfor (int j=0;j<d;j++){\n\t\t\t\tint x=a[i+j],y=a[i+j+d];\n\t\t\t\ta[i+j]=Add(x+y);\n\t\t\t\ta[i+j+d]=Del(x-y);\n\t\t\t\tif (flag<0){\n\t\t\t\t\ta[i+j]=(LL)a[i+j]*inv2%mod;\n\t\t\t\t\ta[i+j+d]=(LL)a[i+j+d]*inv2%mod;\n\t\t\t\t}\n\t\t\t}\n}\nint main(){\n\tn=read(),n=1<<n;\n\tint s=0;\n\tFor(i,0,n-1)\n\t\ta[i]=read(),s+=a[i];\n\ts=Pow(s,mod-2);\n\tFor(i,0,n-1)\n\t\ta[i]=(LL)a[i]*s%mod;\t\n\tFWT(a,n,1);\n\toutarr(a,0,n-1);\n\tFod(i,n-1,0){\n\t\tif (a[i]==1){\n\t\t\ta[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\ta[i]=Pow((a[i]-1+mod)%mod,mod-2);\n\t}\n\toutarr(a,0,n-1);\n\tFWT(a,n,1);\n\toutarr(a,0,n-1);\n\tFor(i,0,n-1)\n\t\tprintf(\"%d\\n\",Del(a[i]-a[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000,mod = 98244353;\nll n,sum,A[N],S[N];\nll ksm(ll x,ll y){ll res = 1; for(;y;y >>= 1,x = x * x % mod) if(y & 1) res = res * x % mod; return (res % mod + mod) % mod;}\nvoid Xor(ll *f,ll opt)\n{\n\tll a,b;\n\tfor(int len = 2,mid = 1;len <= n;len <<= 1,mid <<= 1)\n\t\tfor(int i = 0;i < n;i += len)\n\t\t\tfor(int j = 0;j < mid;j ++)\n\t\t\t{\n\t\t\t\ta = f[i + j]; b = f[i + j + mid];\n\t\t\t\tf[i + j] = (a + b) % mod * opt % mod;\n\t\t\t\tf[i + j + mid] = (a - b) % mod * opt % mod;\n\t\t\t}\n}\nint main()\n{\n\tn = read(); n = (1 << n);\n\tfor(int i = 0;i < n;i ++) sum = sum + (A[i] = read());\n\tsum = ksm(sum,mod - 2);\n\tfor(int i = 0;i < n;i ++) A[i] = A[i] * sum % mod;\n\tA[0] --; if(A[0] < 0) A[0] += mod; S[0] = n - 1;\n\tfor(int i = 1;i < n;i ++) S[i] = mod - 1;\n\tXor(S,1); Xor(A,1);\n\tfor(int i = 0;i < n;i ++) A[i] = ksm(A[i],mod - 2) * S[i] % mod;\n\tXor(A,(mod + 1) >> 1);\n\tll x = mod - A[0];\n\tfor(int i = 0;i < n;i ++) cout << ((x + A[i]) % mod + mod) % mod << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1 << 18, mod = 998244353;\nint n, x[N], p[N];\nint qpow(int b, int p) {int r = 1; for (; p; p >>= 1, b = (ll) b * b % mod) if (p & 1) r = (ll) r * b % mod; return r;}\nvoid FWT(int *a, int fl) {\n  for (int k = 1; k < 1 << n; k <<= 1) {\n    for (int i = 0; i < 1 << n; i += k << 1) {\n      for (int j = 0; j < k; j++) {\n        int x = a[i + j], y = a[i + j + k];\n        a[i + j] = (x + y) % mod;\n        a[i + j + k] = (x - y + mod) % mod;\n        if (fl) {\n          a[i + j] = (ll) a[i + j] * (mod + 1) / 2 % mod;\n          a[i + j + k] = (ll) a[i + j + k] * (mod + 1) / 2 % mod;\n        }\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  int s = 0;\n  for (int i = 0; i < 1 << n; i++) {\n    scanf(\"%d\", &p[i]);\n    s += p[i];\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    p[i] = (ll) p[i] * qpow(s, mod - 2) % mod;\n    x[i] = i == 0 ? (1 << n) - 1 : mod - 1;\n  }\n  p[0] = (p[0] - 1 + mod) % mod;\n  FWT(x, 0);\n  FWT(p, 0);\n  for (int i = 0; i < 1 << n; i++) {\n    x[i] = (ll) x[i] * qpow(p[i], mod - 2) % mod;\n  }\n  FWT(x, 1);\n  for (int i = 0; i < 1 << n; i++) {\n    printf(\"%d\\n\", (x[i] - x[0] + mod) % mod);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 300005\nusing namespace std;\nconst int mod = 998244353;\nint n,N,p[maxn],E[maxn];\nint Pow(int a,int b){int s=1;for(;b;b>>=1,a=1ll*a*a%mod) b&1&&(s=1ll*s*a%mod); return s;}\nint upd(int x){return x+(x>>31&mod);}\nvoid FWT(int *a,int len,int flg){\n\tfor(int i=2,l=1,v;i<=len;l=i,i<<=1)\n\t\tfor(int j=0;j<len;j+=i)\n\t\t\tfor(int k=j;k<j+l;k++)\n\t\t\t\tv=a[k],a[k]=upd(v+a[k+l]-mod),a[k+l]=upd(v-a[k+l]);\n\tif(flg^1) for(int i=0,Inv=Pow(len,mod-2);i<len;i++) a[i]=1ll*a[i]*Inv%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n),N=1<<n; int s=0;\n\tfor(int i=0;i<N;i++) scanf(\"%d\",&p[i]),s=upd(s+p[i]-mod);\n\ts=Pow(s,mod-2);\n\tfor(int i=0;i<N;i++) p[i]=1ll*p[i]*s%mod;\n\tFWT(p,N,1);\n\tfor(int i=1;i<N;i++) E[i]=1ll*N*Pow(upd(p[i]-1),mod-2)%mod;\n\tFWT(E,N,-1);\n\tint x=mod-E[0];\n\tfor(int i=0;i<N;i++) printf(\"%d\\n\",upd(E[i]+x-mod));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1<<18|2,mod=998244353;\nll a[N],f[N];\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nvoid FWT(ll *a,int n){\n\tFor(i,0,n-1){\n\t\tFor(j,0,(1<<n)-1)if(j>>i&1){\n\t\t\tll x=a[j-(1<<i)],y=a[j]; //cout<<j<<\" \"<<a[j]<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\ta[j-(1<<i)]=(x+y)%mod; a[j]=(x-y)%mod;\n\t\t}\n\t}\n}\nint main(){\n\tint n=read(); ll sum=0;\n\tFor(i,0,(1<<n)-1)a[i]=read();\n\tFor(i,0,(1<<n)-1)sum=(sum+a[i])%mod;\n\tsum=ksm(sum,mod-2); \n\tFor(i,0,(1<<n)-1)a[i]=a[i]*sum%mod;\n\tFWT(a,n);\n\tFor(i,0,(1<<n)-1){\n\t\tif(i==0)f[i]=1; \n\t\telse f[i]=ksm(a[i]-1,mod-2); \n\t}\n\tFWT(f,n);\n\tFor(i,0,(1<<n)-1){\n\t\twriteln(((f[i]-f[0])%mod+mod)%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\nusing namespace std;\nconst int mod=998244353;\ninline int qpow(int a,int b,int ans=1){\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\ninline void fwt(int *A,cri bin,cri opt){\n\tfor(int i=1;i<bin;i<<=1)\n\t\tfor(int j=0;j<bin;j+=i<<1)\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tcri x=A[j+k],y=A[j+k+i];\n\t\t\t\tA[j+k]=(x+y)%mod;A[j+k+i]=(x-y+mod)%mod;\n\t\t\t}\n\tif(opt) return;\n\tcri pw=qpow(bin,mod-2);\n\tfor(int i=0;i<bin;i++) A[i]=1ll*A[i]*pw%mod;\n}\nint F[1<<18],n,A[1<<18],sum=0;\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<1<<n;i++) scanf(\"%d\",&A[i]),sum=(sum+A[i])%mod;\n\tsum=qpow(sum,mod-2);\n\tfor(int i=0;i<1<<n;i++) A[i]=1ll*A[i]*sum%mod;\n\tA[0]=(A[0]+mod-1)%mod;F[0]=(1<<n)-1;\n\tfor(int i=1;i<1<<n;i++) F[i]=mod-1;\n\tfwt(A,1<<n,1);fwt(F,1<<n,1);\n\tsum=0;\n\tfor(int i=1;i<1<<n;i++) F[i]=1ll*F[i]*qpow(A[i],mod-2)%mod,sum=(sum+F[i])%mod;\n\tF[0]=mod-sum;\n\tfwt(F,1<<n,0);\n\tfor(int i=0;i<1<<n;i++) printf(\"%d\\n\",F[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define mod 998244353\n#define maxn 1000\nusing namespace std;\ntypedef long long ll; \ninline ll qpow(ll x,ll k)\n{\n\tll ans=1;\n\twhile(k)\n\t{\n\t\tif(k&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tk>>=1;\n\t} \n\treturn ans;\n}\ninline ll inv(ll x)\n{\n\treturn qpow(x,mod-2); \n} \nll fact[maxn+5],invfact[maxn+5],invx[maxn+5];\nvoid ini_inv(int n)\n{\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++) fact[i]=fact[i-1]*i%mod;\n\tinvfact[n]=inv(fact[n]);\n\tfor(int i=n-1;i>=0;i--) invfact[i]=invfact[i+1]*(i+1)%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tinvx[i]=invfact[i]*fact[i-1]%mod;\n\t}\n}\ninline ll C(ll n,ll m)\n{\n\tll ans=1;\n\tfor(int i=n;i>=n-m+1;i--) ans=ans*i%mod;\n\tfor(int i=1;i<=m;i++) ans=ans*invx[i]%mod;\n\treturn ans;\n}\nint n;\nstruct seg\n{\n\tint l;\n\tint r;\n}a[maxn+5];\nint dn=0;\nint tmp[maxn+5];\nvoid discrete()\n{\n\tdn=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttmp[++dn]=a[i].l;\n\t\ttmp[++dn]=a[i].r+1;\n\t}\n\tsort(tmp+1,tmp+1+dn);\n\tdn=unique(tmp+1,tmp+1+dn)-tmp-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i].l=lower_bound(tmp+1,tmp+1+dn,a[i].l)-tmp;\n\t\ta[i].r=lower_bound(tmp+1,tmp+1+dn,a[i].r+1)-tmp;\n\t}\n}\nll dp[maxn+5][maxn+5];\nll sum[maxn+5];\nint main()\n{\n\tini_inv(maxn);\n\tscanf(\"%d\",&n);\n\tll all=1; \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d %d\",&a[i].l,&a[i].r);\n\t\tall=all*(a[i].r-a[i].l+1)%mod;\n\t} \n\tdiscrete();\n\tfor(int j=1;j<=dn;j++) dp[0][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=a[i].l;j<a[i].r;j++)\n\t\t{\n\t\t\tfor(int k=i;k>0;k--)\n\t\t\t{\n\t\t\t\tif(j<a[k].l||j>=a[k].r) break;\n\t\t\t\tdp[i][j]+=dp[k-1][j+1]*C(i-k+tmp[j+1]-tmp[j],i-k+1)%mod;\n\t\t\t\tdp[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j=dn-1;j>=1;j--)\n\t\t{\n\t\t\tdp[i][j]+=dp[i][j+1];\n\t\t\tdp[i][j]%=mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][1]*inv(all)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000,mod = 998244353;\nll n,sum,A[N],S[N];\nll ksm(ll x,ll y)\n{\n\tll res = 1; \n\tfor(;y;y >>= 1,x = x * x % mod) \n\t\tif(y & 1) res = res * x % mod; \n\treturn res;\n}\nvoid Xor(ll *f,ll opt)\n{\n\tll a,b;\n\tfor(int len = 2,mid = 1;len <= n;len <<= 1,mid <<= 1)\n\t\tfor(int i = 0;i < n;i += len)\n\t\t\tfor(int j = 0;j < mid;j ++)\n\t\t\t{\n\t\t\t\ta = f[i + j]; b = f[i + j + mid];\n\t\t\t\tf[i + j] = (a + b) % mod * opt % mod;\n\t\t\t\tf[i + j + mid] = (a - b) % mod * opt % mod;\n\t\t\t}\n\tfor(int i = 0;i < n;i ++) f[i] = (f[i] + mod) % mod;\n}\nint main()\n{\n\tn = read(); n = (1 << n);\n\tfor(int i = 0;i < n;i ++) sum = sum + (A[i] = read());\n\tsum = ksm(sum,mod - 2); \n\tfor(int i = 0;i < n;i ++) A[i] = A[i] * sum % mod;\n\tA[0] --; if(A[0] < 0) A[0] += mod; \n\tS[0] = n - 1; for(int i = 1;i < n;i ++) S[i] = mod - 1;\n\tXor(S,1); Xor(A,1);\n\tfor(int i = 0;i < n;i ++) A[i] = ksm(A[i],mod - 2) * S[i] % mod;\n\tXor(A,(mod + 1) >> 1);\n\tll x = mod - A[0];\n\tfor(int i = 0;i < n;i ++) cout << ((x + A[i]) % mod + mod) % mod << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nint a[1<<18],b[1<<18];\ninline int pow(int x,int y){\n\tint z=1;\n\twhile(y){\n\t\tif(y&1)z=1ll*z*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn z;\n}\ninline void fwt(int *a,int n,int opt){\n\tfor(int i=0;i<(1<<n);i++)printf(\"%d \",a[i]); puts(\"\");\n\tint inv=pow(2,mod-2);\n\tfor(int i=1;i<n;i<<=1){\n\t\tfor(int j=0;j<n;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tint x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=1ll*(x+y)*(opt==-1?inv:1)%mod;\n\t\t\t\ta[j+k+i]=1ll*(x-y+mod)*(opt==-1?inv:1)%mod;\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<(1<<n);i++)printf(\"%d \",a[i]); puts(\"\");\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s=0;\n\tfor(int i=0;i<(1<<n);i++)scanf(\"%d\",&a[i]),s+=a[i];\n\ts=pow(s,mod-2);\n\tfor(int i=0;i<(1<<n);i++)a[i]=mod-1ll*a[i]*s%mod;\n\ta[0]++;\n\tif(a[0]>=mod)a[0]-=mod;\n\tfor(int i=0;i<(1<<n);i++)b[i]=1;\n\tb[0]=(b[0]-(1<<n)+mod)%mod;\n\tfwt(a,(1<<n),1);\n\tfwt(b,(1<<n),1);\n\tfor(int i=0;i<(1<<n);i++)a[i]=1ll*pow(a[i],mod-2)*b[i]%mod;\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++)a[0]=(a[0]-a[i]+mod)%mod;\n\tfwt(a,(1<<n),-1);\n\tfor(int i=0;i<(1<<n);i++)printf(\"%d \",a[i]); puts(\"\");\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1<<18|5\n#define mod 998244353\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\nusing namespace std;\n\nint n,N;\nint a[maxn],b[maxn];\n\nint Pow(int b,int k){ int r=1;for(;k;k>>=1,b=1ll*b*b%mod) if(k&1) r=1ll*r*b%mod; return r; }\nvoid FWT(int *a){\n\trep(i,0,n-1) rep(j,0,N-1) if(!(j>>i&1)){\n\t\tint v = j ^ (1 << i) , x = (a[j] + a[v]) % mod , y = (a[j] - a[v]) % mod;\n\t\ta[j] = x , a[v] = y;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);N = 1 << n;int S=0;\n\trep(i,0,N-1) scanf(\"%d\",&a[i]),S+=a[i];\n\tS = Pow(S , mod-2);\n\trep(i,0,N-1) a[i] = 1ll * a[i] * S % mod;\n\ta[0]-- , b[0] = 1 << n;\n\trep(i,0,N-1) b[i]--;\n\tFWT(a),FWT(b);\n\trep(i,0,N-1) a[i] = 1ll * Pow(a[i],mod-2) * b[i] % mod;\n\tFWT(a);int ivN = Pow(N , mod-2);\n\trep(i,0,N-1) a[i] = 1ll * a[i] * ivN % mod;\n\tper(i,N-1,0) a[i] = (a[i] - a[0]) % mod;\n\trep(i,0,N-1) printf(\"%d\\n\",(a[i]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 998244353;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator-(mint a) { return a.n == 0 ? a : MOD - a.n; }\nmint operator+(mint a, mint b) { a.n += b.n; if (a.n >= MOD) a.n -= MOD; return a; }\nmint operator-(mint a, mint b) { a.n -= b.n; if (a.n < 0) a.n += MOD; return a; }\nmint operator*(mint a, mint b) { return a.n == 0 || b.n == 0 ? 0 : (long long)a.n * b.n % MOD; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nistream &operator>>(istream &i, mint &a) { return i >> a.n; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nmint modpow(mint a, long long b) {\n  mint res = 1;\n  while (b > 0) {\n    if (b & 1) res *= a;\n    a *= a;\n    b >>= 1;\n  }\n  return res;\n}\n\nmint modinv(mint n) {\n  int a = n.n;\n  int b = MOD;\n  int s = 1;\n  int t = 0;\n  while (b != 0) {\n    int q = a / b;\n    a -= q * b;\n    s -= q * t;\n    swap(a, b);\n    swap(s, t);\n  }\n  if (s < 0) s += MOD;\n  return s;\n}\n\nmint operator/(mint a, mint b) { return a * modinv(b); }\nmint operator/=(mint &a, mint b) { return a = a / b; }\n\n\nnamespace {\n  ll read() {\n    ll x;\n    cin >> x;\n    return x;\n  }\n\n  string reads() {\n    string s;\n    cin >> s;\n    return s;\n  }\n\n  template<class T>\n  void writeln(T x) {\n    cout << x << '\\n';\n  }\n\n  template<class T, class... TS>\n  void writeln(T x, TS... xs) {\n    cout << x << ' ';\n    writeln(xs...);\n  }\n\n  template<class T>\n  void write(T x) {\n    cout << x << ' ';\n  }\n\n  void newline() {\n    cout << '\\n';\n  }\n}\n\ntemplate<class T>\nvoid H(T *a, int l, int r) {\n  if (r - l == 1) return;\n  int n = r - l;\n  int m = (l + r) / 2;\n  H(a, l, m);\n  H(a, m, r);\n  for (int i = l; i < m; i++) {\n    int j = i + n / 2;\n    T x = a[i];\n    T y = a[j];\n    a[i] = x + y;\n    a[j] = x - y;\n  }\n}\n\nint main() {\n  int N = read();\n  vector<int> A(1<<N);\n  mint s = 0;\n  REP(i, 1<<N) A[i] = read(), s += A[i];\n  vector<mint> P(1<<N);\n  REP(i, 1<<N) P[i] = A[i] / s;\n  vector<mint> U(1<<N, MOD - 1);\n  U[0] = (1<<N) - 1;\n  H(P.data(), 0, 1<<N);\n  H(U.data(), 0, 1<<N);\n  vector<mint> B(1<<N);\n  for (int i = 0; i < 1<<N; i++) {\n    B[i] = U[i] / (P[i] - 1);\n  }\n  H(B.data(), 0, 1<<N);\n  mint d = -B[0] / (1<<N);\n  REP(i, 1<<N) {\n    B[i] /= 1<<N;\n    B[i] += d;\n    writeln(B[i]);\n  }\n}\n\n   \nstruct init {\n  init() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n  }\n} init_;\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1<<18\n#define p 998244353\n#define ll long long\nusing namespace std;\n\nint n,m,a[N],b[N],S;\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline int add(int x,int y){return x+y<p?x+y:x+y-p;}\n\ninline int mul(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ll)ans*a%p;\n\t\ta=(ll)a*a%p;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\ninline void fwt(int a[],int n,int dft)\n{\n\tfor(int stp=1;stp<n;stp<<=1)\n\t\tfor(int i=0;i<n;i+=(stp<<1))\n\t\t\tfor(int j=i;j<i+stp;++j)\n\t\t\t{\n\t\t\t\tint x=a[j],y=a[j+stp];\n\t\t\t\ta[j]=add(x,y),a[j+stp]=add(x,p-y);\n\t\t\t}\n\tif(dft==-1)\n\t{\n\t\tint inv=mul(n,p-2);\n\t\tfor(int i=0;i<n;++i) a[i]=(ll)a[i]*inv%p;\n\t}\n}\n\nint main()\n{\n\tn=read();n=1<<n;\n\tfor(int i=0;i<n;++i) a[i]=read(),S+=a[i];\n\tS=mul(S,p-2);\n\tfor(int i=0;i<n;++i) a[i]=(ll)a[i]*S%p;\n\ta[0]--;\n\tb[0]=n-1;\n\tfor(int i=1;i<n;++i) b[i]=p-1;\n\tfwt(a,n,1),fwt(b,n,1);\n//\tfor(int i=0;i<n;++i) printf(\"%d \",a[i]);\n\tfor(int i=1;i<n;++i) a[i]=(ll)b[i]*mul(a[i],p-2)%p;\n\tfwt(a,n,-1);\n\tint val=(ll)(p-a[0])*n%p;\n\tfwt(a,n,0);\n\ta[0]=val;\n\tfwt(a,n,-1);\n\tfor(int i=0;i<n;++i) printf(\"%d\\n\",a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 2e6 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, lim;\n\nll p[maxn], q;\n\nll s[maxn];\n\nll power(ll a, ll b)\n{\n\tll ret = 1;\n\tfor(; b; b >>= 1, (a *= a) %= mod) if(b & 1) (ret *= a) %= mod;\n\treturn ret;\n}\n\nvoid fwt_xor(ll *a, ll lim, ll opt)\n{\n\tfor(ll i = 1; i < lim; i <<= 1)\n\t{\n\t\tfor(ll j = 0; j < lim; j += (i << 1))\n\t\t{\n\t\t\trep(k, 0, i - 1)\n\t\t\t{\n\t\t\t\tll x = a[j + k], y = a[i + j + k];\n\t\t\t\tif(opt) a[j + k] = (x + y) % mod, a[i + j + k] = (x + mod - y) % mod;\n\t\t\t\telse a[j + k] = (x + y) % mod * ((mod + 1) / 2) % mod, a[i + j + k] = (x + mod - y) % mod * ((mod + 1) / 2) % mod;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tn = read();\n\tlim = 1 << n;\n\trep(i, 0, lim - 1) q += (p[i] = read());\n\tq = power(q, mod - 2);\n\trep(i, 0, lim - 1) (p[i] *= q) %= mod;\n\t(p[0] += mod - 1) %= mod;\n\ts[0] = lim;\n\trep(i, 0, lim - 1) (s[i] += mod - 1) %= mod;\n\tfwt_xor(s, lim, 1), fwt_xor(p, lim, 1);\n\ts[0] = 0;\n\trep(i, 1, lim - 1) (s[i] *= power(p[i], mod - 2)) %= mod;\n\tfwt_xor(s, lim, 0);\n\tll d = mod - s[0];\n\trep(i, 0, lim - 1) (s[i] += d) %= mod;\n\trep(i, 0, lim - 1) printf(\"%lld\\n\", s[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=18,p=998244353;\nint read(){\n    int f=1,g=0;char ch=getchar();\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n    for (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n    return f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,L,s,a[1<<N],b[1<<N];\ninline int pl(int x,int y){return (x+y<p) ? (x+y) : (x+y-p);}\nvoid FWT(int *a,int L,int typ){\n\tfor (int k=1;k<L;k<<=1)\n\tfor (int i=0;i<L;i+=k*2)\n\tfor (int j=0;j<k;j++){\n\t\tint x=a[i+j],y=a[i+j+k];\n\t\ta[i+j]=pl(x,y);a[i+j+k]=pl(x,p-y);\n\t}\n\tif (typ==1){\n\t\tint R=qpow(L,p-2);\n\t\tfor (int i=0;i<L;i++) a[i]=(ll)a[i]*R%p;\n\t}\n}\nint main(){\n\tn=read();L=1<<n;\n\tfor (int i=0;i<L;i++)\n\t\ta[i]=read(),s+=a[i];\n\ts=qpow(s,p-2);\n\tfor (int i=0;i<L;i++) a[i]=(ll)a[i]*s%p,b[i]=(i==0) ? (L-1) : (p-1);\n\ta[0]-=1;\n\tFWT(a,L,0);FWT(b,L,0);\n\tint pos=0;\n\tfor (int i=0;i<L;i++)\n\tif (!a[i]) pos=i;\n\telse a[i]=(ll)b[i]*qpow(a[i],p-2)%p;\n\tFWT(a,L,1);\n\tint val=(ll)(p-a[0])*L%p;\n\tFWT(a,L,0);\n\ta[pos]=val;\n\tFWT(a,L,1);\n\tfor (int i=0;i<L;i++) printf(\"%d\\n\",a[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,s,a[262144],g[262144],g1[262144];\nvoid fwt(int f[])\n{\n\tint x,y;\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<1<<n;++j)\n\t\t\tif(j>>i&1)\n\t\t\t{\n\t\t\t\tx=f[j^(1<<i)],y=f[j];\n\t\t\t\tf[j^(1<<i)]=pl(x,y);\n\t\t\t\tf[j]=pl(x,mod-y);\n\t\t\t}\n}\nint main()\n{\n//\tprintf(\"%d\\n\",468683018ll*kpow(700939337,mod-2)%mod);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<1<<n;++i)scanf(\"%d\",&a[i]),s+=a[i];\n\ts=kpow(s,mod-2);\n\tfor(int i=0;i<1<<n;++i)a[i]=1ll*a[i]*s%mod;\n\tfwt(a);\n//\tfor(int i=0;i<1<<n;++i)printf(\"%d \",a[i]);printf(\"\\n\");\n\tfor(int i=0;i<1<<n;++i)g[i]=kpow(mod+1-a[i],mod-2);//,g1[i]=1ll*a[i]*g[i]%mod*g[i]%mod;\n//\tfor(int i=0;i<1<<n;++i)printf(\"%d \",g[i]);printf(\"\\n\");\n//\tfor(int i=0;i<1<<n;++i)printf(\"%d \",g1[i]);printf(\"\\n\");\n\tfwt(g);//fwt(g1);\n//\tfor(int i=0;i<1<<n;++i)printf(\"%d \",g[i]);printf(\"\\n\");\n//\tprintf(\"0\\n\");\n//\tint c=kpow(1<<n+1,mod-2);\n\tfor(int i=0;i<1<<n;++i)printf(\"%d\\n\",pl(g[0],mod-g[i]));\n//\tint g0v=kpow(g[0],mod-2);\n//\tfor(int i=0;i<1<<n;++i)printf(\"%d\\n\",(1ll*g1[i]*g[0]+1ll*(mod-g[i])*g1[0])%mod*g0v%mod*g0v%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define mo 998244353\nvoid fwxo(int *a,int l,int r){\n\tif(l==r)return;\n\tint md=(l+r)/2;\n\tfwxo(a,l,md);fwxo(a,md+1,r);\n\tfor(int i=l;i<=md;i++){\n\t\tint c=a[i],d=a[md+i-l+1];\n\t\ta[md+i-l+1]=(c-d+mo)%mo;\n\t\ta[i]=(c+d)%mo;\n\t}\n}\nint qp(int x,int y){\n\tint r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nint n,a[10000010],s,f[10000010];\nsigned main(){\n\tcin>>n;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcin>>a[i];\n\t\ts=(s+a[i])%mo;\n\t}\n\tfor(int i=0;i<(1<<n);i++)\n\t\ta[i]=a[i]*qp(s,mo-2)%mo;\n\tfwxo(a,0,(1<<n)-1);\n\ts=0;\n\tfor(int i=1;i<(1<<n);i++){\n\t\tf[i]=qp(a[i]-1,mo-2);\n\t\ts=(s+f[i])%mo;\n\t}\n\tf[0]=(-s+mo)%mo;\n\tfwxo(f,0,(1<<n)-1);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tcout<<f[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1000010;\nconst int mod=998244353;\nconst int inv=499122177;\nint n,s,p[N],a[N];\nint poww(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\tans=ans*x%mod;\n\t\t}\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nvoid fwt(int *a,int n,int x){\n\tfor(int o=1,k=2;k<=n;o<<=1,k<<=1){\n\t\tfor(int i=0;i<n;i+=k){\n\t\t\tfor(int j=0;j<o;j++){\n\t\t\t\ta[i+j]+=a[i+j+o];\n\t\t\t\ta[i+j]%=mod;\n\t\t\t\ta[i+j+o]=a[i+j]+a[i+j+o]*(mod-2)%mod;\n\t\t\t\ta[i+j+o]%=mod;\n\t\t\t\t(a[i+j]*=x)%=mod;\n\t\t\t\t(a[i+j+o]*=x)%=mod;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=0;i<(1<<n);i++){\n\t\tscanf(\"%lld\",&p[i]);\n\t\t(s+=p[i])%=mod;\n\t}\n\ts=poww(s,mod-2);\n\tfor(int i=0;i<(1<<n);i++){\n\t\t(p[i]*=s)%=mod;\n\t}\n\ta[0]=(1<<n)-1;\n\tfor(int i=1;i<(1<<n);i++){\n\t\ta[i]=mod-1;\n\t}\n\t(p[0]+=mod-1)%=mod;\n\tfwt(a,1<<n,1);\n\tfwt(p,1<<n,1);\n\tfor(int i=0;i<(1<<n);i++){\n\t\t(a[i]*=poww(p[i],mod-2))%=mod;\n\t}\n\tfwt(a,1<<n,inv);\n\tfor(int i=0;i<(1<<n);i++){\n\t\tprintf(\"%lld\\n\",(a[i]-a[0]+mod)%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define inf 99999999\n#define dl double\n#define ll long long\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) ((a)>0?(a):-(a))\n#define re register\n#define FOR(i,a,b) for(re int i=(a) ; i<=(b) ; ++i)\n#define AFOR(i,a,b) for(re int i=(a) ; i>=(b) ; --i)\n#define REP(i,u) for(re int i=head[u],v=edge[i].to;i!=-1;i=edge[i].nxt,v=edge[i].to)\n//#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),fs==ft))?0:*fs++\n#define gc getchar()\nusing namespace std;\nconst int N=3e5+10;\nconst ll mod=998244353;\nchar buf[1<<18],*fs,*ft;\ninline ll read() {\n\tll w=0,p=0;\n\tchar ch=gc;\n\twhile(!isdigit(ch)) w=ch=='-'?1:0,ch=gc;\n\twhile(isdigit(ch)) p=p*10+ch-'0',ch=gc;\n\treturn w?-p:p;\n}\ninline void write(ll x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn ;\n}\nint n,limit;\nll S,f[N],b[N],g[N];\ninline ll mul(ll x,ll y){\n\tll as=1;\n\twhile(y){\n\t\tif(y&1) as=as*x%mod;\n\t\tx=x*x%mod,y>>=1;\n\t}\n\treturn as;\n}\ninline void FWT(ll a[],int limit,int type){\n\tll x,y,inv=mul(2,mod-2);\n\tfor(re int i=1 ; i<limit ; i*=2 )\n\t\tfor(re int j=0 ; j<limit ; j+=2*i) \n\t\t\tfor(re int k=j ; k<i+j ; ++k)\n\t\t\t\tx=a[k],y=a[k+i],a[k]=(x+y+mod)%mod*(type==-1?inv:1)%mod,a[k+i]=(x-y+mod)%mod*(type==-1?inv:1)%mod;\n}\nint main(){\n\tll inv=0;\n\tn=read();\n\tlimit=1<<n;\n\tFOR(i,0,limit-1) b[i]=read(),g[i]=mod-1,S=(S+b[i])%mod;\n\tinv=mul(S,mod-2);\n\tFOR(i,0,limit-1) b[i]=(b[i]*inv)%mod;\n\t--b[0],g[0]+=limit;\n\tFWT(b,limit,1),FWT(g,limit,1);\n\tFOR(i,0,limit-1) f[i]=g[i]*mul(b[i],mod-2)%mod;\n\tFWT(f,limit,-1);\n\tFOR(i,0,limit-1) write((f[i]-f[0]+mod)%mod),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) / 2;\ninline int inc(int x, int y) {x += y; return x >= mod ? x - mod : x;}\ninline int mul(int x, int y) {return (ll)x * y % mod;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nvoid fwt(int n, int *a)\n{\n\tfor (int i = 1; i < n; i <<= 1)\n\t\tfor (int j = 0; j < n; j += i << 1)\n\t\t\tfor (int k = 0; k < i; k ++)\n\t\t\t{\n\t\t\t\tint x = a[j + k], y = a[i + j + k];\n\t\t\t\ta[j + k] = inc(x, y);\n\t\t\t\ta[i + j + k] = inc(x, mod - y);\n\t\t\t}\n}\n\nvoid ifwt(int n, int *a)\n{\n\tfor (int i = 1; i < n; i <<= 1)\n\t\tfor (int j = 0; j < n; j += i << 1)\n\t\t\tfor (int k = 0; k < i; k ++)\n\t\t\t{\n\t\t\t\tint x = a[j + k], y = a[i + j + k];\n\t\t\t\ta[j + k] = mul(inc(x, y), inv2);\n\t\t\t\ta[i + j + k] = mul(inc(x, mod - y), inv2);\n\t\t\t}\n}\n\nconst int maxn = (1 << 18) + 5;\nint n, a[maxn], b[maxn], p[maxn];\n\nint main()\n{\n\tn = read(), n = 1 << n;\n\tfor (int i = 0; i < n; i ++) p[i] = read();\n\tint s = 0;\n\tfor (int i = 0; i < n; i ++) s = inc(s, p[i]);\n\ts = qpow(s, mod - 2);\n\tfor (int i = 0; i < n; i ++) p[i] = mul(s, p[i]);\n\tfor (int i = 0; i < n; i ++) a[i] = p[i]; a[0] = inc(a[0], mod - 1);\n\tfor (int i = 0; i < n; i ++) b[i] = mod - 1; b[0] = inc(b[0], n);\n\tfwt(n, a), fwt(n, b);\n\tfor (int i = 0; i < n; i ++) a[i] = mul(b[i], qpow(a[i], mod - 2));\n\tifwt(n, a); int delta = mod - a[0];\n\tfor (int i = 0; i < n; i ++) a[i] = inc(a[i], delta);\n\tfor (int i = 0; i < n; i ++)\n\t\tprintf(\"%d\\n\", a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Never let them see you bleed...\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = (1<<18) + 10, mod = 998244353, inf = 1e9 + 10;\n\nint Pow(int a, int b){\n    int ans = 1;\n    for(; b; b>>=1, a = 1ll * a * a % mod)\n\tif(b&1)\n\t    ans = 1ll * ans * a % mod;\n    return ans;\n}\nvoid ntt(int *a, int n, bool rev){\n    int N = 1<<n;\n    for(int stp = 0; stp < n; stp++){\n\tint ln = 1<<stp;\n\tfor(int l = 0; l < N; l+= ln + ln){\n\t    for(int i = 0; i < ln; i++){\n\t\tint A = a[l + i], B = a[l + ln + i];\n\t\ta[l + i] = (A + B) % mod;\n\t\ta[l + ln + i] = (A - B) % mod;\n\t    }\n\t}\n    }\n    if(rev){\n\tint x = Pow(1<<n, mod-2);\n\tfor(int i = 0; i < N; i++){\n\t    a[i] = 1ll * a[i] * x % mod;\n\t}\n    }\n}\n\nint p[maxn];\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n, sm = 0;\n    cin >> n;\n    for(int i = 0; i < (1<<n); i++){\n\tcin >> p[i];\n\tsm+= p[i];\n    }\n    for(int i = 0; i < (1<<n); i++){\n\tp[i] = 1ll * p[i] * Pow(sm, mod-2) % mod;\n    }\n    p[0]--;\n    sm = 0;\n    ntt(p, n, 0);\n    for(int i = 1; i < (1<<n); i++){\n\tp[i] = 1ll * Pow(p[i], mod-2) * (1<<n) % mod;\n\tsm = (sm + p[i]) % mod;\n    }\n    p[0] = -sm;\n\n    ntt(p, n, 1);\n    for(int i = 0; i < (1<<n); i++){\n\tcout << (p[i] + mod) % mod << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\ntypedef long long ll;\ncpnst ll mod=998244353,inv2=(mod+1)>>1;\nll qpow(ll x,ll k)\n{ll r=1;for(;k;k>>=1,(x*=x)%=mod)if(k&1)(r*=x)%=mod;return r;}\nll N,A[1111111];\nvoid FWT(ll*x,int op)\n{\n\tfor(register int i=1,ii,iii;i<N;i<<=1)\n\t\tfor(ii=0;ii<N;ii+=(i<<1))\n\t\t\tfor(iii=0;iii<i;iii++)\n\t\t\t{\n\t\t\t\tint px=ii+iii,py=px+i;\n\t\t\t\tll vx=x[px]+x[py],vy=x[px]-x[py]+mod;\n\t\t\t\tif(op<0)vx*=inv2,vy*=inv2;\n\t\t\t\tx[px]=vx%mod,x[py]=vy%mod;\n\t\t\t}\n}\nll C[1111111];\nint main()\n{\n\tscanf(\"%lld\",&N),N=1<<N;\n\tregister int i;\n\tll S=0;\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%lld\",A+i),S+=A[i];\n\tS=qpow(S,mod-2);\n\tfor(i=0;i<N;i++)(A[i]*=S)%=mod; \n\tC[0]=N-1,A[0]=(mod-1+A[0])%mod;\n\tfor(i=1;i<N;i++)C[i]=mod-1;\n\tFWT(C,1),FWT(A,1);\n\tfor(i=0;i<N;i++)C[i]=qpow(A[i],mod-2)*C[i]%mod;\n\tFWT(C,-1);\n\tfor(i=0;i<N;i++)printf(\"%lld\\n\",(C[i]-C[0]+mod)%mod);\n}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n#define ll long long\nll K(ll x,ll y=mod-2){\n\tll t=1;\n\tfor (;y;y>>=1,x=x*x%mod)\n\t\tif (y&1) t=t*x%mod;\n\treturn t;\n}\n\nint n, a[303000], b[303000], sum;\n\nvoid fwt(int *a){\n\tfor (int i=0;i<n;++i)\n\t\tfor (int j=0;j<(1<<n);++j)\n\t\t\tif (!(j>>i&1)){\n\t\t\t\tint &x=a[j], &y=a[j|1<<i];\n\t\t\t\ttie(x,y)=make_tuple((x+y)%mod,(x-y+mod)%mod);\n\t\t\t}\n}\n\nint main(){\n\tcin>>n;\n\tfor (int i=0;i<(1<<n);++i){\n\t\tscanf(\"%d\",&a[i]); sum+=a[i];\n\t}\n\tfor (int i=0;i<(1<<n);++i){\n\t\ta[i]=a[i]*K(sum)%mod;\n\t}\n\tfwt(a);\n\tmemcpy(b,a,sizeof a);\n\tfor (int i=0;i<(1<<n);++i){\n\t\tif (a[i]==1){\n\t\t\ta[i]=0; b[i]=1;\n\t\t\tcontinue;\n\t\t}\n\t\ta[i]= (ll)(a[i]-1+mod)*K((1ll-a[i])*(1ll-a[i])%mod)%mod;\n\t\tb[i]= 0;\n\t}\n\tfwt(a);\n\tfwt(b);\n\tll inv=K(1<<n);\n\tfor (int i=0;i<(1<<n);++i){\n\t\tif (i==0){\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tll f1=a[i]*inv%mod, f0=b[i]*inv%mod, g1=a[0]*inv%mod, g0=b[0]*inv%mod;\n\t\tint ans= (f1*g0%mod-f0*g1%mod+mod)*K(g0*g0%mod)%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N (530010)\n#define P (998244353)\nint n,S,INV,Lim,p[N],q[N];\nint ksm(int a,int p){\n\tint res=1;\n\tfor(;p;p>>=1,a=1ll*a*a%P)if(p&1)res=1ll*res*a%P;\n\treturn res;\n}\nvoid FWT(int *a,int tp){\n\tfor(int i=1;i<Lim;i<<=1)\n\tfor(int R=i<<1,j=0;j<Lim;j+=R)\n\tfor(int k=j;k<j+i;k++){\n\t\tint x=a[k],y=a[k+i];\n\t\ta[k]=(x+y)%P,a[k+i]=(x-y+P)%P;\n\t}\n\tif(tp==-1)for(int i=0;i<Lim;i++)a[i]=1ll*a[i]*INV%P;\n}\nint main(){\n\tscanf(\"%d\",&n),Lim=1<<n,INV=ksm(Lim,P-2);\n\tfor(int i=0;i<Lim;i++)scanf(\"%d\",&p[i]),S+=p[i]; S=ksm(S,P-2);\n\tfor(int i=0;i<Lim;i++)p[i]=1ll*p[i]*S%P,q[i]=P-1;q[0]=Lim-1,p[0]--,FWT(p,1),FWT(q,1);\n\tfor(int i=1;i<Lim;i++)q[i]=1ll*q[i]*ksm(p[i],P-2)%P; FWT(q,-1);\n\tfor(int i=0;i<Lim;i++)printf(\"%d\\n\",(q[i]-q[0]+P)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\t\n\tconst int N = 1 << 18 | 5, mod = 998244353;\n\n\tint n, A[N], B[N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tint inv(const int x) { return x == 1 ? 1 : int((ll)inv(mod % x) * (mod - mod / x) % mod); }\n\n\tvoid FWT(int *a)\n\t{\n\t\tfor (int len = 1; len < n; len <<= 1)\n\t\t\tfor (int i = 0; i < n; i += len << 1)\n\t\t\t\tfor (int k = 0; k < len; k++)\n\t\t\t\t{\n\t\t\t\t\tint x = a[i + k], y = a[i + len + k];\n\t\t\t\t\ta[i + k] = (x + y) % mod;\n\t\t\t\t\ta[i + len + k] = (x - y + mod) % mod;\n\t\t\t\t}\n\t}\n\n\tvoid IFWT(int *a)\n\t{\n\t\tstatic const int INV2 = (mod + 1) >> 1;\n\t\tfor (int len = 1; len < n; len <<= 1)\n\t\t\tfor (int i = 0; i < n; i += len << 1)\n\t\t\t\tfor (int k = 0; k < len; k++)\n\t\t\t\t{\n\t\t\t\t\tint x = a[i + k], y = a[i + len + k];\n\t\t\t\t\ta[i + k] = int((ll)(x + y) * INV2 % mod);\n\t\t\t\t\ta[i + len + k] = int((ll)(x - y + mod) * INV2 % mod);\n\t\t\t\t}\n\t}\n\n\tvoid work()\n\t{\n\t\tn = 1 << read();\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum = (sum + (A[i] = read())) % mod;\n\t\tfor (int i = 0, tmp = inv(sum); i < n; i++)\n\t\t\tA[i] = int((ll)A[i] * tmp % mod);\n\t\tA[0] = (A[0] - 1 + mod) % mod;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tB[i] = mod - 1;\n\t\tB[0] = (n - 1 + mod) % mod;\n\t\tFWT(A), FWT(B);\n\t\tsum = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tA[i] = i == 0 ? B[i] : int((ll)B[i] * inv(A[i]) % mod);\n\t\t\tsum = (sum + A[i]) % mod;\n\t\t}\n\t\tA[0] = sum;\n\t\tIFWT(A);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d\\n\", (A[i] - A[0] + mod) % mod);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nconst int mod=998244353,inv2=(mod+1)/2; \nint p[(1<<18)+1],x[(1<<18)+1];\nint ex(re int a,re int b)\n{\n\tre int ans=1;\n\tfor(;b;b>>=1,a=(long long)a*a%mod)if(b&1)ans=(long long)ans*a%mod;\n\treturn ans;\n}\nvoid FWT(re int*a,re int n,re int op)\n{\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tfor(re int i1=1<<i-1,j=0;j<(1<<n);j+=1<<i)\n\t\t{\n\t\t\tfor(re int k=j;k<j+i1;k++)\n\t\t\t{\n\t\t\t\tre int x=a[k],y=a[k+i1];\n\t\t\t\ta[k]=(x+y)%mod;a[k+i1]=(x-y+mod)%mod;\n\t\t\t\tif(op)a[k]=1ll*inv2*a[k]%mod,a[k+i1]=1ll*inv2*a[k+i1]%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tre int n,S=0;\n\tscanf(\"%d\",&n);\n\tfor(re int i=0;i<(1<<n);i++)\n\t\tscanf(\"%d\",&p[i]),S=(S+p[i])%mod;\n\tS=ex(S,mod-2);\n\tfor(re int i=0;i<(1<<n);i++)p[i]=(long long)p[i]*S%mod;\n\tp[0]=(p[0]-1+mod)%mod;\n\tfor(re int i=1;i<(1<<n);i++)x[i]=mod-1;\n\tx[0]=(1<<n)-1;\n\tFWT(x,n,0);\n\tFWT(p,n,0);\n\tfor(re int i=0;i<(1<<n);i++)x[i]=(long long)x[i]*ex(p[i],mod-2)%mod;//,printf(\"%d %d\\n\",i,p[i]);\n\tFWT(x,n,1);\n\tfor(re int i=0;i<(1<<n);i++)printf(\"%d\\n\",(x[i]-x[0]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 998244353\n#define inv2 499122177\n#define eps 1e-8\nint n;\nll a[1001000],f[1001000],g[1001000];\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nvoid fwt_xor(int lim,ll *a,int typ)\n{\n    int mid;\n    for (mid=1;mid<lim;mid<<=1)\n    {\n        int len=(mid<<1),sta,j;\n        for (sta=0;sta<lim;sta+=len)\n        {\n            for (j=0;j<mid;j++)\n            {\n                ll x=a[sta+j],y=a[sta+j+mid];\n                a[sta+j]=(x+y)%maxd;\n                a[sta+j+mid]=(x+maxd-y)%maxd;\n                if (typ==-1) {a[sta+j]=a[sta+j]*inv2%maxd;a[sta+j+mid]=a[sta+j+mid]*inv2%maxd;}\n            }\n        }\n    }\n}\n\nll qpow(ll x,int y)\n{\n    ll ans=1;\n    while (y)\n    {\n        if (y&1) ans=ans*x%maxd;\n        x=x*x%maxd;y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    n=read();int lim=(1<<n);\n    ll sum=0;\n    rep(i,0,lim-1) {a[i]=read();sum=(a[i]+sum)%maxd;}\n    sum=qpow(sum,maxd-2);\n    rep(i,0,lim-1) {f[i]=maxd-1;g[i]=a[i]*sum%maxd;}\n    f[0]=lim-1;g[0]=(g[0]+maxd-1)%maxd;\n    fwt_xor(lim,f,1);fwt_xor(lim,g,1);\n    rep(i,0,lim-1) f[i]=f[i]*qpow(g[i],maxd-2)%maxd;\n    fwt_xor(lim,f,-1);\n    rep(i,0,lim-1)\n        printf(\"%lld\\n\",(f[i]-f[0]+maxd)%maxd);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\nint a[1<<18],b[1<<18];\ninline int pow(int x,int y){\n\tint z=1;\n\twhile(y){\n\t\tif(y&1)z=1ll*z*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn z;\n}\ninline void fwt(int *a,int n,int opt){\n\t// for(int i=0;i<(1<<n);i++)printf(\"%d \",a[i]); puts(\"\");\n\tint inv=pow(2,mod-2);\n\tfor(int i=1;i<n;i<<=1){\n\t\tfor(int j=0;j<n;j+=(i<<1)){\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tint x=a[j+k],y=a[j+k+i];\n\t\t\t\ta[j+k]=1ll*(x+y)*(opt==-1?inv:1)%mod;\n\t\t\t\ta[j+k+i]=1ll*(x-y+mod)*(opt==-1?inv:1)%mod;\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<(1<<n);i++)printf(\"%d \",a[i]); puts(\"\");\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint s=0;\n\tfor(int i=0;i<(1<<n);i++)scanf(\"%d\",&a[i]),s+=a[i];\n\ts=pow(s,mod-2);\n\tfor(int i=0;i<(1<<n);i++)a[i]=mod-1ll*a[i]*s%mod;\n\ta[0]++;\n\tif(a[0]>=mod)a[0]-=mod;\n\tfor(int i=0;i<(1<<n);i++)b[i]=1;\n\tb[0]=(b[0]-(1<<n)+mod)%mod;\n\tfwt(a,(1<<n),1);\n\tfwt(b,(1<<n),1);\n\tfor(int i=0;i<(1<<n);i++)a[i]=1ll*pow(a[i],mod-2)*b[i]%mod;\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++)a[0]=(a[0]-a[i]+mod)%mod;\n\tfwt(a,(1<<n),-1);\n\tfor(int i=0;i<(1<<n);i++)printf(\"%d\\n\",a[i]);\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\ntemplate<class T> inline void read(T &x){\n\tx=0;register char c=getchar();register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\tif(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1<<18,mod=998244353;\nint n,s,inv_s,lim,a[N],f[N],g[N];\ninline int mid(int x){return x&1?(x+mod)>>1:x>>1;}\ninline int dec(int a,int b){return (a-=b)<0?a+mod:a;}\ninline int inc(int a,int b){return (a+=b)>=mod?a-mod:a;}\ninline int fpow(int a,int b){int s=1;for(;b;b>>=1,a=(ll)a*a%mod)if(b&1)s=(ll)s*a%mod;return s;}\nvoid fwt(int *a,void foo(int&,int&)){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=len<<1){\n\t\t\tfor(int j=0;j<len;j++)foo(a[i+j],a[i+j+len]);\n\t\t}\n}\nvoid trans(int &a,int &b){int x=a;a=inc(a,b),b=dec(x,b);}\nvoid i_trans(int &a,int &b){int x=a;a=mid(inc(a,b)),b=mid(dec(x,b));}\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=1<<n;\n\tfor(int i=0;i<lim;i++)read(a[i]),s=inc(s,a[i]);\n\tinv_s=fpow(s,mod-2);\n\tfor(int i=0;i<lim;i++)a[i]=(ll)a[i]*inv_s%mod,f[i]=lim-1;\n\tf[0]=mod-1,a[0]=dec(a[0],1);\n\tfwt(f,trans),fwt(a,trans);\n\tfor(int i=0;i<lim;i++)g[i]=(ll)f[i]*fpow(a[i],mod-2)%mod;\n\tfwt(g,i_trans);\n\t// for(int i=0;i<lim;i++)print(g[i],\" \\n\"[i==lim-1]);\n\tfor(int i=lim-1;i>=0;i--)g[i]=dec(g[0],g[i]);\n\tfor(int i=0;i<lim;i++)print(g[i],'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& [k, v] : a) { out << (first ? \"\" : \", \"); out << k << \":\" << v; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint64 inv2 = (MOD + 1) / 2;\nvoid fwt(vector<int>& a, int flag) {\n  int n = a.size();\n  for (int h = 1; h < n; h <<= 1) {\n    for (int step = h << 1, i = 0; i < n; i += step) {\n      for (int j = i; j < i + h; ++j) {\n        int x = a[j], y = a[j + h];\n        if (flag > 0) {\n          a[j] = (x + y) % MOD;\n          a[j + h] = (x - y + MOD) % MOD;\n        } else {\n          a[j] = (x + y) * inv2 % MOD;\n          a[j + h] = (x - y + MOD) * inv2 % MOD;\n        }\n      }\n    }\n  }\n}\n\nvoid add(int& x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\n\nint64 power_mod(int64 a, int64 n, int p = MOD) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % p;\n    a = a * a % p;\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> p(1 << n);\n  int sum = 0;\n  for (int i = 0; i < (1 << n); ++i) {\n    scanf(\"%d\", &p[i]);\n    add(sum, p[i]);\n  }\n  sum = power_mod(sum, MOD - 2);\n  for (int i = 0; i < (1 << n); ++i) {\n    p[i] = (int64)sum * p[i] % MOD;\n  }\n  add(p[0], MOD - 1);\n  fwt(p, 1);\n  vector<int> q(1 << n);\n  for (int i = 0; i < (1 << n); ++i) {\n    q[i] = MOD - 1;\n  }\n  add(q[0], 1 << n);\n  fwt(q, 1);\n  for (int i = 0; i < (1 << n); ++i) {\n    q[i] = p[i] == 0 ? 0 : q[i] * power_mod(p[i], MOD - 2) % MOD;\n  }\n  fwt(q, -1);\n  for (int i = (1 << n) - 1; i >= 0; --i) {\n    add(q[i], MOD - q[0]);\n  }\n  for (int i = 0; i < (1 << n); ++i) {\n    printf(\"%d\\n\", q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=(1<<18)+10,mod=998244353;\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint A[N],B[N],C[N];\nint m,n;\nvoid FWT(int *A,int f) {\n\tfor(int l=1;l<n;l<<=1)\n\t\tfor(int p=l<<1,i=0;i<n;i+=p)\n\t\t\tfor(int j=0;j<l;++j) {\n\t\t\t\tint t1=A[i+j],t2=A[i+l+j];\n\t\t\t\tA[i+j]=(t1+t2)%mod;\n\t\t\t\tA[i+l+j]=(t1-t2+mod)%mod;\n\t\t\t}\n\tif(f==1) {\n\t\tint inv=Pow(n,mod-2);\n\t\tfor(int i=0;i<n;++i) A[i]=A[i]*(ll)inv%mod;\n\t}\n}\nint main() {\n\trd(m); n=(1<<m);\n\tint sum=0;\n\tfor(int i=0;i<n;++i)\n\t\trd(A[i]),sum+=A[i];\n\tsum=Pow(sum,mod-2);\n\tfor(int i=0;i<n;++i)\n\t\tA[i]=A[i]*(ll)sum%mod;\n\tA[0]=(A[0]-1+mod)%mod;\n\tFWT(A,0);\n//\tfor(int i=0;i<n;++i) printf(\"%d \",A[i]); puts(\"\");\n\tB[0]=n-1;\n\tfor(int i=1;i<n;++i)\n\t\tB[i]=mod-1;\n\tFWT(B,0);\n\tC[0]=0;\n\tfor(int i=1;i<n;++i)\n\t\tC[i]=B[i]*(ll)Pow(A[i],mod-2)%mod;\n\tFWT(C,1);\n\tint tmp=C[0];\n\tfor(int i=0;i<n;++i) C[i]=(C[i]-tmp+mod)%mod;\n\tfor(int i=0;i<n;++i) printf(\"%d\\n\",C[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 998244353;\nvoid transform(ll* a, int n) {\n\tfor (int len = 1; len < n; len <<= 1)\n\t\tfor (int i = 0; i < n; i += 2 * len)\n\t\t\tfor (int j = 0; j < len; ++j) {\n\t\t\t\tll u = a[i + j], v = a[i + j + len];\n\t\t\t\ta[i + j] = (u + v) % MOD;\n\t\t\t\ta[i + j + len] = (u - v) % MOD;\n\t\t\t}\n}\nll modex(ll a, ll p, ll m = MOD) {\n\tif (!p) return 1;\n\tif (p & 1) return a * modex(a, p - 1, m) % m;\n\tll v = modex(a, p >> 1, m);\n\treturn v * v % m;\n}\nint main() {\n\tint k;\n\tscanf(\"%d\", &k);\n\tint n = 1 << k;\n\tvector<ll> a(n), b(n);\n\tll sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\tsum = modex(sum, MOD - 2);\n\tfor (int i = 0; i < n; ++i) a[i] = a[i] * sum % MOD;\n\tb[0] = n - 1;\n\tfill(b.begin() + 1, b.end(), -1);\n\ttransform(a.data(), n);\n\ttransform(b.data(), n);\n\ta[0] = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\ta[i] = b[i] * modex(a[i] - 1, MOD - 2) % MOD;\n\t\ta[0] -= a[i];\n\t}\n\ta[0] %= MOD;\n\ttransform(a.data(), n);\n\tassert(a[0] == 0);\n\tll div = modex(n, MOD - 2);\n\tfor (int i = 0; i < n; ++i) printf(\"%lld\\n\", (a[i] + MOD) % MOD * div % MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1<<18,mod=998244353;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\ninline int dic(int a,int b){return a-b<0?a-b+mod:a-b;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b,int c=1){for(;b;b>>=1,a=mul(a,a)) if(b&1) c=mul(c,a);return c;}\nconst int inv2=qpow(2,mod-2);\nint p[maxn],n,c[maxn],len,e[maxn];\nvoid FWT(int *f,bool typ){\n\tfor(int i=2;i<=len;i<<=1)\n\t\tfor(int j=0;j<len;j+=i)\n\t\t\tfor(int k=j;k<j+i/2;++k){\n\t\t\t\tint u=f[k],t=f[k+i/2];\n\t\t\t\tif(!typ) f[k]=add(u,t),f[k+i/2]=dic(u,t);\n\t\t\t\telse f[k]=mul(add(u,t),inv2),f[k+i/2]=mul(dic(u,t),inv2);\n\t\t\t}\n\treturn ;\n}\nint main(){\n\tint inv=0;cin>>n;len=1<<n;for(int i=0;i<1<<n;++i) scanf(\"%d\",&p[i]),inv=add(inv,p[i]);\n\tinv=qpow(inv,mod-2);for(int i=0;i<1<<n;++i) p[i]=mul(p[i],inv),c[i]=mod-1;p[0]=dic(p[0],1);\n\tc[0]=add(len,c[0]);\n\tFWT(p,0),FWT(c,0);\n\tfor(int i=1;i<len;++i) e[i]=mul(c[i],qpow(p[i],mod-2));\n\tFWT(e,1);\n\tfor(int i=0;i<len;++i) printf(\"%d\\n\",dic(e[i],e[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int mod = 998244353;\nint n,maxn,a[1<<18];\nll f[1<<18],P[1<<18],ans[1<<18];\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nvoid fwt(ll *f,int tag){\n\tll inv=fp(maxn,mod-2);\n\tfor(int mid=1;mid<maxn;mid<<=1)\n\t\tfor(int l=0;l<maxn;l+=mid<<1)\n\t\t\tfor(int i=l;i<l+mid;i++){\n\t\t\t\tll x=f[i],y=f[i+mid];\n\t\t\t\tf[i]=(x+y)%mod;\n\t\t\t\tf[i+mid]=(x-y)%mod;\n\t\t\t}\n\tif(tag<0)\n\tfor(int i=0;i<maxn;i++)\n\t\tf[i]=f[i]*inv%mod;\n}\nint main(){\n\tread(n);maxn=1<<n;\n\tll S=0;\n\tfor(int i=0;i<maxn;i++)\n\t\tread(a[i]),S+=a[i];\n\tfor(int i=0;i<maxn;i++)\n\t\tP[i]=a[i]*fp(S,mod-2)%mod;\n\tP[0]--;\n\tfor(int i=0;i<maxn;i++)\n\t\tf[i]=-1;\n\tf[0]=maxn-1;\n\tfwt(f,1);fwt(P,1);\n\tfor(int i=0;i<maxn;i++)\n\t\tans[i]=f[i]*fp(P[i],mod-2)%mod;\n\tfwt(ans,-1);\n\tfor(int i=0;i<maxn;i++)\n\t\tcout<<((ans[i]-ans[0])%mod+mod)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint mt(int a,int b)\n{\n\tif(b==0)\n\t{\n\t\treturn 1;\n\t}\n\tint c=mt(a,b>>1);\n\tc=(long long)c*c%998244353;\n\tif(b&1)\n\t{\n\t\tc=(long long)c*a%998244353;\n\t}\n\treturn c;\n}\nint n;\nint a[262144];\nvoid fwt()\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<(1<<n);j++)\n\t\t{\n\t\t\tif(j&(1<<i))\n\t\t\t{\n\t\t\t\tint t=a[j];\n\t\t\t\ta[j]=a[j-(1<<i)]-t;\n\t\t\t\tif(a[j]<0)\n\t\t\t\t{\n\t\t\t\t\ta[j]+=998244353;\n\t\t\t\t}\n\t\t\t\ta[j-(1<<i)]+=t;\n\t\t\t\tif(a[j-(1<<i)]>=998244353)\n\t\t\t\t{\n\t\t\t\t\ta[j-(1<<i)]-=998244353;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint val[262144];\nint tmp[262144];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint s=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tscanf(\"%d\",&val[i]);\n\t\ts+=val[i];\n\t}\n\ts=mt(s,998244351);\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tval[i]=(long long)val[i]*s%998244353;\n\t}\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\ta[i]=1;\n\t}\n\ta[0]-=(1<<n);\n\tif(a[0]<0)\n\t{\n\t\ta[0]+=998244353;\n\t}\n\tfwt();\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\ttmp[i]=a[i];\n\t\ta[i]=-val[i];\n\t\tif(a[i]<0)\n\t\t{\n\t\t\ta[i]+=998244353;\n\t\t}\n\t}\n\ta[0]++;\n\tif(a[0]>=998244353)\n\t{\n\t\ta[0]-=998244353;\n\t}\n\tfwt();\n\ta[0]=0;\n\tfor(int i=1;i<(1<<n);i++)\n\t{\n\t\ta[i]=(long long)tmp[i]*mt(a[i],998244351)%998244353;\n\t\ta[0]-=a[i];\n\t\tif(a[0]<0)\n\t\t{\n\t\t\ta[0]+=998244353;\n\t\t}\n\t}\n\tfwt();\n\tint invn=mt(1<<n,998244351);\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tint answer=(long long)a[i]*invn%998244353;\n\t\tprintf(\"%d\\n\",answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint M(int x) { return x >= mod ? x - mod : x; }\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\nint n, len, sp;\nint fsp(long long bs, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = bs * rt % mod;\n        bs = bs * bs % mod, p >>= 1;\n    }\n    return rt;\n}\n\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t + mod), Add(x[j], t);\n    }\n    void ifwt(int len) {\n        fwt(len);\n        int ny = fsp(len, mod - 2);\n        for (int i = 0; i < len; ++i) x[i] = 1ll * x[i] * ny % mod;\n    }\n} E, P, S;\n\nint main() {\n    n = read(), len = 1 << n;\n    for (int i = 0; i < len; ++i) sp += (P[i] = read());\n    sp = fsp(sp, mod - 2);\n    for (int i = 0; i < len; ++i) P[i] = 1ll * P[i] * sp % mod;\n    (--P[0]) < 0 ? P[0] += mod : 0, S[0] = len - 1;\n    for (int i = 1; i < len; ++i) S[i] = mod - 1;\n    P.fwt(len), S.fwt(len);\n    for (int i = 1; i < len; ++i) E[i] = 1ll * S[i] * fsp(P[i], mod - 2) % mod;\n    E.ifwt(len);\n    int x = mod - E[0];\n    for (int i = 0; i < len; ++i) printf(\"%d\\n\", M(x + E[i]));\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\n\ntemplate<long long MOD>istream & operator >> (istream &i,Mod_Int<MOD> &A){ll a; cin>>a; A=Mod_Int<MOD>(a); return i;}\ntemplate<long long MOD>ostream & operator << (ostream &i,Mod_Int<MOD> &A){i<<A.a; return i;}\n\n\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nnamespace Convolusion{\n    /*\n     Aのサイズは2^nとなっていること。\n     \n     R_k=sum_(i&j=k),A_i B_j\n     R=mobius(zeta(A),zeta(B))\n     上位集合の畳み込みの積をとって逆変換\n     \n     R_k=sum_(i|j=k),A_i B_j\n     R=mobius(zeta(A),zeta(B))\n     下位集合の畳み込みの積をとって逆変換\n     */\n    \n    //R_i=sum_(j in i),A_j\n    //下位集合の畳み込み　上位集合の畳み込みはif文のなかの等号の左右を反対にする。\n    template<typename T>\n    vector<T> zeta(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((j&i)==0){ret[j|i]+=ret[j];}\n            }\n        }\n        return ret;\n    }\n    \n    //R_i=sum_(j in i),(-1)^(|i\\j|) A_j\n    //ゼータ変換の逆変換\n    template<typename T>\n    vector<T> mobius(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((j&i)==0){ret[j|i]-=ret[j];}\n            }\n        }\n        return ret;\n    }\n    \n    //R_i=sum_(j),(-1)^(|i&j|) A_j\n    //オーバーフローに注意,sqrt(|A|)で割ると直交かつ対称な変換になる\n    template<typename T>\n    vector<T> hadamard(const vector<T> &A,int n){\n        vector<T> ret=A;\n        for(int i=1;i<1<<n;i<<=1){\n            for(int j=0;j<1<<n;j++){\n                if((i&j)==0){\n                    T P=ret[j],Q=ret[j|i];\n                    ret[j]=P+Q;\n                    ret[j|i]=P-Q;\n                }\n            }\n        }\n        return ret;\n    }\n    \n    /*\n    //R_i=sum_(j),r^(ij) A_j\n    //オーバーフローに注意,sqrt(|A|)で割るとユニタリかつエルミートな変換になる,rは1の原始|A|乗根\n    template<typename T>\n    vector<T> fourier(const vector<T> &A,int n,T r){\n        vector<T> ret=A;\n        vector<T> E(1<<n,1);\n        for(int i=1;i<1<<n;i++){E[i]=E[i-1]*r;}\n        for(int i=0,j=1;j+1<1<<n;j++){\n            for(int k=n>>1;k>(i^k);k>>=1);\n            \n            for(int k=n>>1;k>(i^=k);k>>=1);\n            if(i>j) swap(ret[i],ret[j]);\n        }\n        for(int i=1<<(n-1);i>0;i>>=1){\n            for(int j=0;j<1<<n;j++){\n                if((i&j)==0){\n                    T P=ret[j],Q=ret[i|j];\n                    ret[j]=P+Q;\n                    ret[i|j]=P+Q*E[i];\n                }\n            }\n        }\n        return ret;\n    }\n     */\n};\n\n\nusing namespace Convolusion;\ntypedef Mod_Int<998244353> Int;\n\nint main(){\n    ll n;\n    cin>>n;\n    Int sum=0;\n    vector<Int> A(1<<n);\n    Int X=1<<n;\n    cin>>A;\n    for(auto &I:A){sum+=I;}\n    for(auto &I:A){I/=sum;}\n    A[0]-=1;\n    A=hadamard<Int>(A,n);\n    sum=0;\n    for(int i=1;i<1<<n;i++){A[i]=X/A[i]; sum-=A[i];}\n    A[0]=sum;\n    A=hadamard(A,n);\n    for(auto &I:A){I/=1<<n; cout<<I<<endl;}\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    // Your code here!\n    cout<<\"にゃーん\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=998244353;\ninline int poww(int x,int y){\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mo)if(y&1)ans=1ll*ans*x%mo;\n\treturn ans;\n}\nint n,a[1<<18|5],i,s,b[1<<18|5];\ninline void FWT(){\n\tfor(int i=2,j,k,m,x,y;i<=1<<n;i<<=1)for(j=0,m=i>>1;j<1<<n;j+=i)\n\t\tfor(k=0;k<m;++k)x=a[j+k],y=a[j+k+m],a[j+k]=(x+y)%mo,a[j+k+m]=(x+mo-y)%mo;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<1<<n;++i)a[i]=1;FWT();memcpy(b,a,sizeof b);\n\tfor(i=0;i<1<<n;++i)scanf(\"%d\",a+i),s+=a[i];s=poww(s,mo-2);\n\tfor(i=0;i<1<<n;++i)a[i]=1ll*a[i]*s%mo;\n\tFWT();for(s=0,i=1;i<1<<n;++i)a[i]=1ll*b[i]*poww(1+mo-a[i],mo-2)%mo,s=(s+a[i])%mo;a[0]=mo-s;\n\tFWT();s=poww(1<<n,mo-2);for(i=0;i<1<<n;++i)printf(\"%lld \",1ll*a[i]%mo);puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pi;\ntypedef long long LL;   \n\nconst int P = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst LL INFLL = 0x3f3f3f3f3f3f3f3fll;\nconst int N = 1e6 + 1e5;\n\nint n, m, inv_n;\nLL a[N], b[N], c[N], S, inv_S;\n\ninline LL ksm(LL base, LL x) {\n    LL res = 1;\n    while(x) {\n        if(x & 1) res *= base, res %= P;\n        x >>= 1, base *= base, base %= P;\n    }\n    return res;\n}\n\ninline void fwt_xor(LL a[], int type) {\n    for(int i = 1; i < n; i <<= 1)\n        for(int j = 0; j < n; j += i << 1)\n            for(int k = j; k < j + i; k++)\n                a[k] = (a[k] + a[k + i]) % P,\n                a[k + i] = (a[k] - a[k + i] * 2 + P * 2) % P;\n    if(type == -1)\n        for(int i = 0; i < n; i++) a[i] = (a[i] * inv_n) % P;\n}\n\nvoid init() {\n    int len;\n    cin >> len;\n    n = 1 << len;\n    inv_n = ksm(n, P - 2);\n    for(int i = 0; i < n; i++) scanf(\"%lld\", &a[i]), S = (S + a[i]) % P;\n    inv_S = ksm(S, P - 2);\n    for(int i = 0; i < n; i++) a[i] = (a[i] * inv_S) % P;\n    fwt_xor(a, 1);\n    for(int i = 0; i < n; i++) b[i] = c[i] = 1;\n    b[0] = 0;\n    fwt_xor(b, 1), fwt_xor(c, 1);\n    \n    /*\n    for(int i = 0; i < n; i++) {\n        LL tmp = ksm((1 - a[i] + P) % P, P - 2);\n        b[i] = (b[i] * tmp) % P;\n        c[i] = (c[i] * tmp) % P;\n    }\n    fwt_xor(b, -1), fwt_xor(c, -1);\n    */\n    \n    for(int i = 0; i < n; i++) c[i] = (c[i] - b[i] + P) % P;\n    LL x = (P - b[0]) * ksm(c[0], P - 2) % P;\n    for(int i = 0; i < n; i++) c[i] = (b[i] + c[i] * x) % P;\n    for(int i = 0; i < n; i++) {\n        LL tmp = ksm((1 - a[i] + P) % P, P - 2);\n        c[i] = (c[i] * tmp) % P;\n    }\n    for(int i = 0; i < n; i++) b[i] = c[i];\n    c[0] = 1;\n    fwt_xor(b, -1), fwt_xor(c, -1);\n\n    \n    for(int i = 0; i < n; i++) c[i] = (c[i] - b[i] + P) % P;\n    x = (P - b[0]) * ksm(c[0], P - 2) % P;\n    for(int i = 0; i < n; i++) c[i] = (b[i] + c[i] * x) % P;\n    for(int i = 0; i < n; i++) printf(\"%lld\\n\", c[i]);\n}\n\nint main() {\n    init();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline int addmod(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int submod(int x)\n{\n\treturn x<0?x+mod:x;\n}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nint n,a[1000005],f[1000005],g[1000005],tans[1000005],inv2;\nvoid fwt(int *a)\n{\n\tfor(int k=1;k<(1<<n);k<<=1)\n\t\tfor(int i=0,r=k*2;i<(1<<n);i+=r)\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint x=a[i+j],y=a[i+j+k];\n\t\t\t\ta[i+j]=addmod(x+y);\n\t\t\t\ta[i+j+k]=submod(x-y);\n\t\t\t}\n}\nint main()\n{\n\tinv2=fpow(2,mod-2);\n\tscanf(\"%d\",&n);\n\tint sum=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tsum=addmod(sum+a[i]);\n\t}\n\tsum=fpow(sum,mod-2);\n\tfor(int i=0;i<(1<<n);i++)\n\t\ta[i]=1ll*a[i]*sum%mod;\n\tfwt(a);\n\tint ct=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tf[i]=fpow(submod(1-a[i]),mod-2);\n\t\tif(a[i]==1) ct++;\n\t}\n\tfwt(f);\n\tprintf(\"0\\n\");\n\tfor(int i=1;i<(1<<n);i++)\n\t{\n\t\tint ans=1ll*submod(f[0]-f[i])*fpow(ct,mod-2)%mod;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define ll long long \nusing namespace std;\nconst int mod=998244353;\nconst int inv2=499122177;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\t\n}\nint n,u;\nll g[1<<18],f[1<<18],all;\nll qp(ll x,ll k){\n\tll res=1;\n\twhile(k){\n\t\tif(k&1) res=res*x%mod;\n\t\tk>>=1,x=x*x%mod;\n\t}\n\treturn res;\n}\nvoid fwt(ll *tmp,int tp){\n\tfor(re int mid=1;mid<=u;mid<<=1){\n\t\tfor(re int i=0;i<=u;i+=(mid<<1)){\n\t\t\tinc(j,0,mid-1){\n\t\t\t\tll x=tmp[i+j],y=tmp[i+j+mid];\n\t\t\t\ttmp[i+j]=(x+y)%mod;\n\t\t\t\ttmp[i+j+mid]=(x-y+mod)%mod;\n\t\t\t\tif(tp==-1) tmp[i+j]=tmp[i+j]*inv2%mod,tmp[i+j+mid]=tmp[i+j+mid]*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tn=read();u=(1<<n)-1;\n\tinc(i,0,u) f[i]=read(),all+=f[i];\n\tall=qp(all,mod-2);\n\tinc(i,0,u) f[i]=f[i]*all%mod;\n\tg[0]=u;inc(i,1,u) g[i]=mod-1;\n\tf[0]=(f[0]+mod-1)%mod;\n\tfwt(f,1),fwt(g,1);\n\tinc(i,0,u) f[i]=g[i]*qp(f[i],mod-2)%mod;\n\tfwt(f,-1);\n\tinc(i,1,u) f[i]=(f[i]-f[0]+mod)%mod;\n\tputs(\"0\");\n\tinc(i,1,u) printf(\"%lld\\n\",f[i]);\n}\n/*\n2 \n1 1 1 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define rg register\n#define In inline\n\nconst int N = 262144;\nconst ll mod = 998244353;\nconst ll iv2 = 499122177;\n\nIn ll read(){\n\tll s = 0,ww = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9'){if(ch == '-')ww = -1;ch = getchar();}\n\twhile('0' <= ch && ch <= '9'){s = 10 * s + ch - '0';ch = getchar();}\n\treturn s * ww;\n}\n\nIn void write(ll x){\n\tif(x < 0)putchar('-'),x = -x;\n\tif(x > 9)write(x / 10);\n\tputchar('0' + x % 10);\n}\n\nnamespace ModCalc{\n\tIn void Inc(ll &x,ll y){\n\t\tx += y;if(x >= mod)x -= mod;\n\t}\n\tIn void Dec(ll &x,ll y){\n\t\tx -= y;if(x < 0)x += mod;\n\t}\n\tIn ll Add(ll x,ll y){\n\t\tInc(x,y);return x;\n\t}\n\tIn ll Sub(ll x,ll y){\n\t\tDec(x,y);return x;\n\t}\n}\nusing namespace ModCalc;\n\nIn ll power(ll a,ll n){\n\tll s = 1,x = a;\n\twhile(n){\n\t\tif(n & 1)s = s * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn s;\n}\n\nll n,deg;\nll p[N+5],q[N+5],temp[N+5];\n\nIn void calc(ll &x,ll &y,int opt){\n\tif(opt == 1){\n\t\tll X = Add(x,y),Y = Sub(x,y);\n\t\tx = X,y = Y;\n\t}\n\telse{\n\t\tll X = Add(x,y) * iv2 % mod,Y = Sub(x,y) * iv2 % mod; \n\t\tx = X,y = Y;\n\t}\n}\n\nvoid FWT(ll a[],ll deg,int opt){\n\tfor(rg int n = 2;n <= deg;n <<= 1){\n\t\tint m = n >> 1;\n\t\tfor(rg int i = 0;i < deg;i += n){\n\t\t\tfor(rg int j = 0;j < m;j++)calc(a[i+j],a[i+j+m],opt);\n\t\t}\n\t}\n}\n\nint main(){\n//\tfreopen(\"AGC034F.in\",\"r\",stdin);\n//\tfreopen(\"AGC034F.out\",\"w\",stdout);\n\tn = read();\n\tdeg = 1ll << n;\n\tll s = 0;\n\tfor(rg int i = 0;i < deg;i++)p[i] = read(),s += p[i];\n\tll iv = power(s,mod - 2);\n\tfor(rg int i = 0;i < deg;i++)p[i] = p[i] * iv % mod;\n\tDec(p[0],1);\n//for(rg int i = 0;i < deg;i++)cout<<p[i]<<\" \";cout<<endl;\n\tFWT(p,deg,1);\n//cout<<\"p[]:\"<<endl;\n//for(rg int i = 0;i < deg;i++)cout<<p[i]<<\" \";cout<<endl;\n\tfor(rg int i = 0;i < deg;i++)q[i] = (i == 0 ? deg - 1 : -1);\n\tFWT(q,deg,1);\n//cout<<\"q[]:\"<<endl;\n//for(rg int i = 0;i < deg;i++)cout<<q[i]<<\" \";cout<<endl;\n\tfor(rg int i = 1;i < deg;i++)q[i] = q[i] * power(p[i],mod - 2) % mod;\n//cout<<\"q[]:\"<<endl;\n//for(rg int i = 0;i < deg;i++)cout<<q[i]<<\" \";cout<<endl;\t\n\tmemcpy(temp,q,sizeof(temp));\n\tFWT(temp,deg,-1);\n\tDec(q[0],temp[0] * deg % mod);\n//cout<<endl;\n\tFWT(q,deg,-1);\n\tfor(rg int i = 0;i < deg;i++)write(q[i]),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = 998244353;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 18;\nint a[1 << N], b[1 << N], c[1 << N], d[1 << N], n;\nvoid fwt(int *v,int sgn) {\n  rep (i, 0, n-1) rep (s, 0, (1 << n)-1) if ((s >> i)&1) {\n    int l = v[s ^ (1 << i)];\n    int r = v[s];\n    v[s ^ (1 << i)] = (l + r >= MOD ? l + r - MOD : l + r);\n    v[s] = (l - r < 0 ? l - r + MOD : l - r);\n  }\n  if (sgn) {\n    int tmp = power(1 << n, MOD - 2);\n    rep (s, 0, (1 << n)-1) v[s] = 1ll * v[s] * tmp % MOD;\n  }\n}\nint main() {\n  read(n);\n  int tmp = 0;\n  rep (i, 0, (1 << n) - 1) read(a[i]), Add(tmp, a[i]);\n  tmp = power(tmp, MOD - 2);\n  rep (i, 0, (1 << n) - 1) a[i] = 1ll * a[i] * tmp % MOD;\n  fwt(a, 0);\n  rep (s, 0, (1 << n) - 1) {\n    if (a[s] == 1) b[s] = 0;\n    else {\n      b[s] = a[s]; Sub(b[s], 1);\n      b[s] = power(b[s], MOD - 2);\n    }\n\n    if (a[s] == 1) c[s] = 1;\n    else c[s] = 0;\n  }\n  fwt(b, 1);\n  fwt(c, 1);\n  d[0] = 0;\n  rep (s, 1, (1 << n) - 1) {\n    // (a' b - b' a) / (b*b)\n    d[s] = (1ll * b[s] * c[0] - 1ll * b[0] * c[s]) % MOD;\n    if (d[s] < 0) d[s] = d[s] + MOD;\n    d[s] = 1ll * d[s] * power(1ll * c[0] * c[0] % MOD, MOD - 2) % MOD;\n  }\n  rep (s, 0, (1 << n) - 1)\n    printf(\"%d\\n\", d[s]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint int\nusing namespace std;\n     \ntypedef long long lo;\n     \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\nnamespace {\n    const int mo = 998244353;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\nconst int N = (1 << 18) + 3;\nint n, m, p[N], sum, r[N];\n\ninline void FWT(int *p, int f) {\n\tint n = ::m;\n\tfor (int l = 2; l <= n; l <<= 1)\n\t\tfor (int *a = p, m = l >> 1; a != p + n; a += l)\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tint x = a[k], y = a[k + m];\n\t\t\t\ta[k] = add(x, y); a[k + m] = sub(x, y);\n\t\t\t}\n\tif (f == -1) {\n\t\tint mult = power(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i] = mul(p[i], mult);\n\t}\n}\n\nint main(void) {\n\tread(n); m = 1 << n;\n\tfor (int i = 0; i < m; i++) {\n\t\tread(p[i]); sum += p[i];\n\t}\n\tsum = power(sum);\n\tfor (int i = 0; i < m; i++) {\n\t\tp[i] = mul(p[i], sum);\n\t\tr[i] = mo - 1;\n\t}\n\tr[0] = m - 1;\n\tp[0] = sub(p[0], 1);\n\tFWT(r, 1); FWT(p, 1);\n\tfor (int i = 0; i < m; i++) \n\t\tr[i] = mul(r[i], power(p[i]));\n\tFWT(r, -1);\n\tfor (int i = 0; i < m; i++) {\n\t\tcout << sub(r[i], r[0]) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\n\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int mod = 998244353;\n\ninline int add(int a, int b) {\n\ta += b;\n\treturn a >= mod ? a - mod : a;\n}\n\ninline int sub(int a, int b) {\n\ta -= b;\n\treturn a < 0 ? a + mod : a;\n}\n\ninline int mul(int a, int b) { return (LL)a * b % mod; }\n\ninline int ksm(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\t\nconst int inv2 = ksm(2, mod - 2);\n\nint n, s;\n\ninline void FWT(int *t, int n, int type) {\t\n\tfor (int step = 1; step < n; step <<= 1) {\n\t\tfor (int i = 0; i < n; i += step << 1) {\n\t\t\tfor (int j = 0; j < step; ++ j) {\n\t\t\t\tint x = t[i + j], y = t[i + j + step];\n\t\t\t\tt[i + j] = add(x, y), t[i + j + step] = sub(x, y);\n\t\t\t\tif (type == -1) {\n\t\t\t\t\tt[i + j] = mul(t[i + j], inv2);\n\t\t\t\t\tt[i + j + step] = mul(t[i + j + step], inv2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int N = 1 << 18;\nint p[N], a[N];\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < 1 << n; ++ i) read(p[i]), s = add(s, p[i]);\n\ts = ksm(s, mod - 2);\n\tfor (int i = 0; i < 1 << n; ++ i) p[i] = mul(p[i], s);\n\tfor (int i = 1; i < 1 << n; ++ i) a[i] = mod - 1;\n\ta[0] = (1 << n) - 1;\n\tp[0] = sub(p[0], 1); \n\tFWT(a, 1 << n, 1), FWT(p, 1 << n, 1);\n\tfor (int i = 0; i < 1 << n; ++ i) a[i] = mul(a[i], ksm(p[i], mod - 2));\n\tFWT(a, 1 << n, -1);\n\tfor (int i = 0; i < 1 << n; ++ i) {\n\t\tprintf(\"%d\\n\", sub(a[i], a[0]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ % P\nconst int N = 262144, P = 998244353;\nint ri() {\n\tchar c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f  = -1;\n\tfor(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;\n}\nint a[N], p[N], sum, m, n;\nint Pow(int x, int k) {\n\tint r = 1;\n\tfor(;k; x = 1LL * x * x _ , k >>= 1)\n\t\tif(k & 1)\n\t\t\tr = 1LL * r * x _;\n\treturn r;\n}\nint Inv(int x) {return Pow(x, P - 2);}\nvoid FWT(int *F) {\n\tfor(int d = 1;d < m; d <<= 1)\n\t\tfor(int i = 0;i < m; i += d << 1)\n\t\t\tfor(int j = 0;j < d; ++j) {\n\t\t\t\tint tp = F[i + j + d];\n\t\t\t\tF[i + j + d] = (F[i + j] - tp) _;\n\t\t\t\tF[i + j] = (F[i + j] + tp) _;\n\t\t\t}\n}\nint main() {\n\tn = ri(); m = 1<< n;\n\tfor(int i = 0;i < m; ++i)\n\t\tp[i] = ri(), sum = (sum + p[i]) _;\n\tsum = Inv(sum);\n\tfor(int i = 0;i < m; ++i)\n\t\tp[i] = 1LL * p[i] * sum % P;\n\t--p[0];\n\tfor(int i = 1;i < m; ++i)\n\t\ta[i] = -1;\n\ta[0] = m - 1;\n\tFWT(p); FWT(a);\n\tfor(int i = 0;i < m; ++i)\n\t\ta[i] = 1LL * a[i] * Inv(p[i]) _;\n\tFWT(a); int ivm = Inv(m);\n\tfor(int i = 0;i < m; ++i) {\n\t\ta[i] = 1LL * a[i] * ivm _;\n\t\tprintf(\"%d\\n\", ((a[i] - a[0]) _ + P) _);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nvoid fwt(int *p,int len) {\n  for(int i=1;i<len;i<<=1)\n    for(int j=0;j<len;j++)\n      if (j&i) {\n      \tint u=p[j^i],v=p[j];\n      \tp[j^i]=(u+v)%MOD;\n      \tp[j]=(u-v+MOD)%MOD;\n\t  }\n}\n\nint p[1<<18],q[1<<18],ans[1<<18];\nll l[(1<<18)+1],r[(1<<18)+1];\n\nvoid solve(int n) {\n  fwt(p,1<<n);\n  l[0]=r[(1<<n)]=1;\n  for(int i=1;i<(1<<n);i++) l[i]=l[i-1]*(1LL-p[i]+MOD)%MOD;\n  for(int i=(1<<n)-1;i>0;i--) r[i]=r[i+1]*(1LL-p[i]+MOD)%MOD;\n  for(int i=1;i<(1<<n);i++) {\n  \tll s=l[i-1]*r[i+1]%MOD;\n  \tq[0]=(q[0]-p[i]*s%MOD+MOD)%MOD;\n  \tq[i]=(q[i]-p[0]*s%MOD+MOD)%MOD;\n  }\n  ll s=0;\n  for(int i=0;i<(1<<n);i++) s=(s+q[i])%MOD;\n  fwt(q,1<<n);\n  ll inv=pow_mod((ll)r[1]*r[1]%MOD,MOD-2);\n  for(int i=0;i<(1<<n);i++) ans[i]=r[1]*(q[i]-s+MOD)%MOD*inv%MOD;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  ll s=0;\n  for(int i=0;i<(1<<n);i++) {\n  \tscanf(\"%d\",&p[i]);\n  \ts+=p[i];\n  }\n  s=pow_mod(s,MOD-2);\n  for(int i=0;i<(1<<n);i++) p[i]=p[i]*s%MOD;\n  solve(n);\n  for(int i=0;i<(1<<n);i++) printf(\"%d\\n\",ans[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (int) ((long long) x * y % md);\n}\n\ninline int inv(int a) {\n  if (a < 0) {\n    a += md;\n  }\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += md;\n  }\n  return u;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(1 << n);\n  int sum = 0;\n  for (int i = 0; i < 1 << n; ++i) {\n    cin >> a[i];\n    sum += a[i];\n  }\n  sum = inv(sum);\n  for (int i = 0; i < 1 << n; ++i) {\n    a[i] = mul(a[i], sum);\n  }\n  for (int i = 1; i < 1 << n; i <<= 1) {\n    for (int j = 0; j < 1 << n; j += i << 1) {\n      for (int k = 0; k < i; ++k) {\n        int u = a[j + k], v = a[j + k + i];\n        a[j + k] = (u + v) % md;\n        a[j + k + i] = (u - v + md) % md;\n      }\n    }\n  }\n  a[0] = 0;\n  for (int i = 1; i < 1 << n; ++i) {\n    a[i] = inv(a[i] - 1);\n  }\n  for (int i = 1; i < 1 << n; i <<= 1) {\n    for (int j = 0; j < 1 << n; j += i << 1) {\n      for (int k = 0; k < i; ++k) {\n        int u = a[j + k], v = a[j + k + i];\n        a[j + k] = (u + v) % md;\n        a[j + k + i] = (u - v + md) % md;\n      }\n    }\n  }\n  cout << 0 << \"\\n\";\n  for (int i = 1; i < 1 << n; ++i) {\n    sub(a[i], a[0]);\n    cout << a[i] << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=(1<<18)+10,mod=998244353;\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint A[N],B[N],C[N];\nint m,n;\nvoid FWT(int *A,int f) {\n\tfor(int l=1;l<n;l<<=1)\n\t\tfor(int p=l<<1,i=0;i<n;i+=p)\n\t\t\tfor(int j=0;j<l;++j) {\n\t\t\t\tint t1=A[i+j],t2=A[i+l+j];\n\t\t\t\tA[i+j]=(t1+t2)%mod;\n\t\t\t\tA[i+l+j]=(t1-t2+mod)%mod;\n\t\t\t}\n\tif(f==1) {\n\t\tint inv=Pow(n,mod-2);\n\t\tfor(int i=0;i<n;++i) A[i]=A[i]*(ll)inv%mod;\n\t}\n}\nint main() {\n\trd(m); n=(1<<m);\n\tint sum=0;\n\tfor(int i=0;i<n;++i)\n\t\trd(A[i]),sum+=A[i];\n\tsum=Pow(sum,mod-2);\n\tfor(int i=0;i<n;++i)\n\t\tA[i]=A[i]*(ll)sum%mod;\n\tA[0]=(A[0]-1+mod)%mod;\n\tFWT(A,0);\n//\tfor(int i=0;i<n;++i) printf(\"%d \",A[i]); puts(\"\");\n\tB[0]=n-1;\n\tfor(int i=1;i<n;++i)\n\t\tB[i]=mod-1;\n\tFWT(B,0);\n\tC[0]=0;\n\tfor(int i=1;i<n;++i)\n\t\tC[i]=B[i]*(ll)Pow(A[i],mod-2)%mod;\n\tfor(int i=1;i<n;++i)\n\t\tC[0]=(C[0]+mod-C[i])%mod;\n\tFWT(C,1);\n\tint tmp=C[0];\n\tfor(int i=0;i<n;++i) printf(\"%d\\n\",C[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int p = 998244353;\ninline int qpow(int value, int n) {\n  int result = 1;\n  for (; n; n >>= 1, value = (ll)value * value % p) {\n    if (n & 1) {\n      result = (ll)result * value % p;\n    }\n  }\n  return result;\n}\nvoid fwt(vector<int> &arr) {\n  for (int gap = 1; gap < arr.size(); gap <<= 1) {\n    for (int start = 0; start < arr.size(); start += gap * 2) {\n      for (int i = start; i < start + gap; i++) {\n        int x = arr[i], y = arr[i + gap];\n        arr[i] = (x + y) % p;\n        arr[i + gap] = (x - y + p) % p;\n      }\n    }\n  }\n}\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, sum = 0;\n  cin >> n;\n  vector<int> prob(1 << n);\n  for (int i = 0; i < 1 << n; i++) {\n    cin >> prob[i];\n    sum = (sum + prob[i]) % p;\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    prob[i] = (ll)prob[i] * qpow(sum, p - 2) % p;\n  }\n  prob[0] = (prob[0] - 1 + p) % p;\n  fwt(prob);\n  vector<int> arr(1 << n, p - 1);\n  arr[0] = (1 << n) - 1;\n  fwt(arr);\n  for (int i = 0; i < 1 << n; i++) {\n    arr[i] = (ll)arr[i] * qpow(prob[i], p - 2) % p;\n  }\n  fwt(arr);\n  for (int i = 0; i < 1 << n; i++) {\n    arr[i] = (ll)arr[i] * qpow(1 << n, p - 2) % p;\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    cout << (arr[i] - arr[0] + p) % p << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 1/15/2020, 2:31:58 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\n// constexpr ll MOD{1000000007LL};\nconstexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> const &V)\n{\n  os << \"{\";\n  for (auto const &v : V)\n  {\n    os << \"{\";\n    for (auto x : v)\n    {\n      os << x << \", \";\n    }\n    os << \"}, \";\n  }\n  return os << \"}\";\n}\n\nvector<vector<mint>> next_line(vector<vector<mint>> const &V)\n{\n  vector<vector<mint>> W;\n  for (auto const &v : V)\n  {\n    vector<mint> v0, v1;\n    for (auto i = 0; i + 1 < static_cast<int>(v.size()); i += 2)\n    {\n      v0.push_back(v[i] + v[i + 1]);\n      v1.push_back(v[i] - v[i + 1]);\n    }\n    W.push_back(v0);\n    W.push_back(v1);\n  }\n  return W;\n}\n\nvector<vector<mint>> divide(vector<vector<mint>> const &B, vector<vector<mint>> const &C)\n{\n  assert(B.size() == C.size());\n  vector<vector<mint>> W(B.size(), vector<mint>(1));\n  for (auto i = 0; i < static_cast<int>(B.size()); i++)\n  {\n    assert(B[i].size() == 1);\n    assert(C[i].size() == 1);\n    if (B[i][0] == 0)\n    {\n      assert(C[i][0] == 0);\n      W[i][0] = 0;\n    }\n    else\n    {\n      W[i][0] = C[i][0] / B[i][0];\n    }\n  }\n  return W;\n}\n\nvector<vector<mint>> prev_line(vector<vector<mint>> const &V)\n{\n  vector<vector<mint>> W;\n  for (auto i = 0; i + 1 < static_cast<int>(V.size()); i += 2)\n  {\n    vector<mint> w;\n    assert(V[i].size() == V[i + 1].size());\n    for (auto j = 0; j < static_cast<int>(V[i].size()); j++)\n    {\n      w.push_back((V[i][j] + V[i + 1][j]) / 2);\n      w.push_back((V[i][j] - V[i + 1][j]) / 2);\n    }\n    W.push_back(w);\n  }\n  return W;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  int B{1};\n  for (auto i = 0; i < N; i++)\n  {\n    B *= 2;\n  }\n  vector<mint> A(B);\n  for (auto i = 0; i < B; i++)\n  {\n    cin >> A[i];\n  }\n  mint S{accumulate(A.begin(), A.end(), mint{0})};\n  vector<mint> P(B);\n  for (auto i = 0; i < B; i++)\n  {\n    P[i] = A[i] / S;\n  }\n  vector<mint> X(B, -1);\n  X[0] = B - 1;\n  vector<vector<vector<mint>>> a(N + 1), b(N + 1), c(N + 1);\n  b[0].push_back(P);\n  b[0][0][0] -= 1;\n  c[0].push_back(X);\n  cerr << \"b[\" << 0 << \"] = \" << b[0] << endl;\n  for (auto k = 0; k < N; k++)\n  {\n    b[k + 1] = next_line(b[k]);\n    cerr << \"b[\" << k + 1 << \"] = \" << b[k + 1] << endl;\n  }\n  cerr << \"c[\" << 0 << \"] = \" << c[0] << endl;\n  for (auto k = 0; k < N; k++)\n  {\n    c[k + 1] = next_line(c[k]);\n    cerr << \"c[\" << k + 1 << \"] = \" << c[k + 1] << endl;\n  }\n  a[0] = divide(b[N], c[N]);\n  cerr << \"a[\" << 0 << \"] = \" << a[0] << endl;\n  for (auto k = 0; k < N; k++)\n  {\n    a[k + 1] = prev_line(a[k]);\n    cerr << \"a[\" << k + 1 << \"] = \" << a[k + 1] << endl;\n  }\n  auto &v{a[N][0]};\n  auto C{v[0]};\n  for (auto &x : v)\n  {\n    x -= C;\n  }\n  for (auto x : v)\n  {\n    cout << x << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll p=998244353ll,p1=998244352ll;\ninline ll add(ll a){return a<p  ?a:a-p;}\ninline ll sub(ll a){return a<0ll?a+p:a;}\ninline ll e(ll a,int b=998244351){\n\tll c=1ll;\n\twhile(b){\n\t\tif(b&1)c=c*a%p;\n\t\tb>>=1; a=a*a%p;\n\t}\n\treturn c;\n}\nll a[1<<18],b[1<<18],c[1<<18];\nint n,k;\ninline void hdminit(int _,int __){n=_;k=__;}\ninline void hdm(ll *a){\n\tint i,j,k;ll e,o;\n\tfor(i=1;i!=n;i<<=1){\n\t\tfor(j=0;j!=n;j+=i<<1){\n\t\t\tfor(k=j;k<j+i;++k){\n\t\t\t\te=a[k  ];\n\t\t\t\to=a[k+i];\n\t\t\t\ta[k  ]=add(e+o);\n\t\t\t\ta[k+i]=sub(e-o);\n\t\t\t}\n\t\t}\n\t}\n}\nint f[1<<18];\nint main(){\n\tint k,n,i,x,t=0;ll t1;\n\tscanf(\"%d\",&k);n=1<<k;\n\tfor(i=1;i!=n;++i)f[i]=f[i&(i-1)]^1;\n\tfor(i=0;i!=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\ta[i]=x;\n\t\tt+=x;\n\t}\n\tt1=e(t);\n\ta[0]=(a[0]*t1+p1)%p;\n\tfor(i=1;i!=n;++i)a[i]=a[i]*t1%p;\n\tb[0]=n-1;\n\tfor(i=1;i!=n;++i)b[i]=p1;\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",a[i]);printf(\"\\n\");\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",(a[i]<<2)%p);printf(\"\\n\");\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",b[i]);printf(\"\\n\");\n\thdminit(n,k);\n\thdm(a);\n\thdm(b);\n//\tprintf(\"hdm\\n\");\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",a[i]);printf(\"\\n\");\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",b[i]);printf(\"\\n\");\n\tfor(i=1;i!=n;++i)b[i]=e(a[i])*b[i]%p;\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",b[i]);printf(\"\\n\");\n\thdm(b);\n//\tprintf(\"ihdm\\n\");\n//\tfor(i=0;i!=n;++i)printf(\"%lld \",b[i]);printf(\"\\n\");\n\tputchar('0');\n\tt1=e(n);\n\tfor(i=1;i!=n;++i)printf(\"\\n%lld\",sub(b[i]-b[0])*t1%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=600010,mod=998244353;\nint n,lmt=1;\nlong long sum=0ll;\nlong long p[N],f[N],a[N];\ninline long long add(long long x,long long y)\n{\n    return x+y>=mod?x+y-mod:x+y;\n}\ninline long long sub(long long x,long long y)\n{\n    return x-y<0?x-y+mod:x-y;\n}\ninline long long po(long long x,long long y)\n{\n    long long u=1ll;\n    while(y)\n    {\n        if(y&1) (u*=x)%=mod;\n        (x*=x)%=mod;\n        y>>=1;\n    }\n    return u;\n}\ninline void fwt(long long *x,long long op)\n{\n    for(int mid=1;mid<lmt;mid<<=1)\n    {\n        int len=mid<<1;\n        for(int k=0;k<lmt;k+=len)\n        {\n            for(int i=0;i<mid;i++)\n            {\n                long long wx=x[k+i],wy=x[k+mid+i];\n                x[k+i]=add(wx,wy);\n                x[k+mid+i]=sub(wx,wy);\n                if(op^1) (x[k+i]*=op)%=mod,(x[k+mid+i]*=op)%=mod;\n            }\n        }\n    }\n    return;\n}\ninline void out(long long x)\n{\n    for(int k=0;k<=1000;k++)\n    {\n        for(int i=0;i<=1000;i++)\n        {\n            if(k*po(i,mod-2)%mod==x)\n            {\n                cout<<k<<\"/\"<<i<<endl;\n                return ;\n            }\n            if(mod-k*po(i,mod-2)%mod==x)\n            {\n                cout<<\"-\"<<k<<\"/\"<<i<<endl;\n                return;\n            }\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    n=(1<<n)-1;\n    for(int k=0;k<=n;k++)\n        scanf(\"%lld\",&p[k]),sum+=p[k];\n    long long inv=po(sum,mod-2);\n    for(int k=0;k<=n;k++)\n        (p[k]*=inv)%=mod;\n    for(int k=0;k<=n;k++)\n        a[k]=p[k];\n    a[0]=sub(a[0],1);\n    for(int k=1;k<=n;k++)\n        f[k]=mod-1;\n    f[0]=n;\n    while(lmt<=n) lmt<<=1;\n    fwt(a,1);\n    fwt(f,1);\n    for(int k=0;k<lmt;k++)\n        (f[k]*=po(a[k],mod-2))%=mod;\n    fwt(f,po(2,mod-2));\n    fwt(a,po(2,mod-2));\n    for(int k=1;k<=n;k++)\n        f[k]=sub(f[k],f[0]);\n    f[0]=0ll;\n    for(int k=0;k<=n;k++)\n        printf(\"%lld\\n\",f[k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ninline int read(){\n\tchar ch=getchar();int x=0,op=0;\n\twhile(!isdigit(ch))op|=(ch=='-'),ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn op?-x:x;\n}\n\nconst int N=100005,M=N*15;\nconst ll inf=1e18;\nnamespace G{\n\tstruct edge{\n\t\tint u,v,f,c;ll w;int id;\n\t}e[M];\n\tll f[N],d[N];\n\tint n,m,s,t,flag;\n\tvi g[N];\n\tinline void init(int _n,int _s,int _t,int _flag=1){\n\t\tn=_n,m=0,s=_s,t=_t,flag=_flag;\n\t\trep(i,1,n)f[i]=0;\n\t}\n\tinline void add(int u,int v,int c,ll w){\n\t\tg[u].pb(m),w*=flag;\n\t\te[m++]=(edge){u,v,0,c,w,(int)g[v].size()};\n\t\tg[v].pb(m);\n\t\te[m++]=(edge){v,u,0,0,-w,(int)g[u].size()-1};\n\t}\n\tstruct node{\n\t\tint u;ll d;\n\t\tinline friend bool operator < (node a,node b){\n\t\t\treturn a.d>b.d;\n\t\t}\n\t};\n\tpriority_queue<node> Q;\n\tint dij(){\n\t\trep(i,1,n)d[i]=inf;\n\t\td[s]=0,Q.push((node){s,0});\n\t\twhile(!Q.empty()){\n\t\t\tnode t=Q.top();Q.pop();\n\t\t\tif(d[t.u]<t.d)continue;\n\t\t\tint u=t.u;\n\t\t\tfor(auto k:g[u]){\n\t\t\t\tint v=e[k].v;\n\t\t\t\tif(e[k].f<e[k].c&&d[u]+e[k].w+f[u]-f[v]<d[v]){\n\t\t\t\t\td[v]=d[u]+e[k].w+f[u]-f[v];\n\t\t\t\t\tQ.push((node){v,d[v]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t]<inf;\n\t}\n\tint in[N],r[N];\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tll res=0;in[u]=1;\n\t\tfor(int &p=r[u];p<g[u].size();p++){\n\t\t\tint k=g[u][p],v=e[k].v;\n\t\t\tif(e[k].f<e[k].c&&d[u]+e[k].w+f[u]-f[v]==d[v]&&!in[v]){\n\t\t\t\tint tmp=dfs(v,min(a,e[k].c-e[k].f));\n\t\t\t\tres+=tmp,a-=tmp;\n\t\t\t\te[k].f+=tmp,\n\t\t\t\te[g[e[k].v][e[k].id]].f-=tmp;\n\t\t\t}\n\t\t\tif(!a)break;\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tvoid mcmf(ll &flow,ll &cost){\n\t\twhile(dij()){\n\t\t\trep(i,1,n)r[i]=0;\n\t\t\tll owo=dfs(s,2e9);\n\t\t\tflow+=owo,cost+=owo*(d[t]+f[t]);\n\t\t\trep(i,1,n)f[i]=min(f[i]+d[i],inf);\n\t\t}\n\t}\n}\n\nint n,x,y,c,p0,p1,p2,p3,s,t,bas;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tG::init(n*2+6,s=1,t=2,-1);\n\tp0=3,p1=4,p2=5,p3=6,bas=6;\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tG::add(s,bas+i,c,0);\n\t\tG::add(bas+i,p0,c,+x+y);\n\t\tG::add(bas+i,p1,c,+x-y);\n\t\tG::add(bas+i,p2,c,-x+y);\n\t\tG::add(bas+i,p3,c,-x-y);\n\t}\n\tbas+=n;\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tG::add(bas+i,t,c,0);\n\t\tG::add(p3,bas+i,c,+x+y);\n\t\tG::add(p2,bas+i,c,+x-y);\n\t\tG::add(p1,bas+i,c,-x+y);\n\t\tG::add(p0,bas+i,c,-x-y);\n\t}\n\tll flow=0,cost=0;\n\tG::mcmf(flow,cost);\n\tcout<<-cost<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int   mod = 998244353;\nconst int   N   = (1 << 18);\n\ntypedef vector<int> vi;\n\nint add(int a,int b)    {\n    a += b;\n    if(a >= mod)a -= mod;\n    if(a <  0)  a += mod;\n    return  a;\n}\nint mul(int a,int b)    {\n    return (long long)a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nvoid fwt(int *a,int n,int upd)  {\n    upd = (mod + 1) / (upd + 1);\n    upd =  upd % mod;\n    for(int i = 1 ; i < n ; i <<= 1)\n    for(int j = 0 ; j < n ; j += (i << 1))\n    for(int k = j ; k < j + i ; ++k)    {\n        int x = a[k];\n        int y = a[k + i];\n        a[k]     = mul(add(x, y),upd);\n        a[k + i] = mul(add(x,-y),upd);\n    }\n}\n\nint a[N], b[N];\nint n, Sum = 0;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    \n    cin >> n;   n = (1 << n);\n    \n    for(int i = 0 ; i < n ; ++i)    cin >> a[i], Sum += a[i];\n    for(int i = 0 ; i < n ; ++i)    a[i] = mul(a[i],Pow(Sum,mod - 2));\n    for(int i = 0 ; i < n ; ++i)    b[i] = mod - 1;\n    \n    a[0] = add(a[0],-1);\n    b[0] = add(b[0], n);\n    \n    fwt(a,n,0);\n    fwt(b,n,0);\n    \n    for(int i = 0 ; i < n ; ++i)    a[i] = mul(b[i],Pow(a[i],mod - 2));\n    \n    fwt(a,n,1);\n    \n    for(int i = 0 ; i < n ; ++i)    cout << add(a[i],-a[0]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 270001\n#define mod 998244353\nint a[N],b[N],n,su;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint fwt(int *a,int n,int f)\n{\n\tfor(int l=2;l<=n;l<<=1)\n\tfor(int j=0;j<n;j+=l)\n\tfor(int k=j;k<j+(l>>1);k++)\n\tif(f)\n\t{\n\t\tint t1=a[k],t2=a[k+(l>>1)];\n\t\ta[k]=(t1+t2)%mod;\n\t\ta[k+(l>>1)]=(t1-t2+mod)%mod;\n\t}\n\telse\n\t{\n\t\tint t1=a[k],t2=a[k+(l>>1)];\n\t\ta[k]=1ll*(t1+t2)*(mod+1)/2%mod;\n\t\ta[k+(l>>1)]=1ll*(t1-t2+mod)*(mod+1)/2%mod;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<1<<n;i++)scanf(\"%d\",&a[i]),su+=a[i];\n\tfor(int i=0;i<1<<n;i++)a[i]=1ll*a[i]*pw(su,mod-2)%mod-(i==0),b[i]=i==0?(1<<n)-1:mod-1;\n\tfwt(a,1<<n,1);fwt(b,1<<n,1);\n\tfor(int i=0;i<1<<n;i++)a[i]=1ll*b[i]*pw(a[i],mod-2)%mod;\n\tfwt(a,1<<n,0);\n\tint tp=a[0];\n\tfwt(a,1<<n,1);\n\ta[0]=(a[0]+mod-1ll*tp*(1<<n)%mod)%mod;\n\tfwt(a,1<<n,0);\n\tfor(int i=0;i<1<<n;i++)printf(\"%d\\n\",a[i]);\n}//orz_zyw"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand()%x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nint a[N],b[N],n,m,c[N];\nll s;\nvoid dft(int *a,int l,int r) {\n\tif (l==r) return;\n\tint md=(l+r)>>1,len=(r-l+1)>>1;\n\tdft(a,l,md);dft(a,md+1,r);\n\trep(i,0,len) {\n\t\tint x1=a[l+i],x2=a[l+len+i];\n\t\ta[l+i]=(x1+x2)%mod;\n\t\ta[l+len+i]=(x1-x2)%mod;\n\t}\n}\nll inv2=(mod+1)/2;\n\nvoid idft(int *a,int l,int r) {\n\tif (l==r) return;\n\tint md=(l+r)>>1,len=(r-l+1)>>1;\n\trep(i,0,len) {\n\t\tint x1=a[l+i],x2=a[l+len+i];\n\t\ta[l+i]=(x1+x2)*inv2%mod;\n\t\ta[l+len+i]=(x1-x2)*inv2%mod;\n\t}\n\tidft(a,l,md);idft(a,md+1,r);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tm=1<<n;\n\tfor (int i=0;i<m;i++) {\n\t\tscanf(\"%d\",a+i);\n\t\ts+=a[i];\n\t}\n\ts=powmod(s,mod-2);\n\trep(i,0,m) a[i]=a[i]*s%mod;\n\tdft(a,0,m-1);\n\trep(i,0,m) b[i]=1;\n\tb[0]=(mod-m+1);\n\tdft(b,0,m-1);\n//\trep(i,0,m) printf(\"%d \",a[i]); puts(\"\");\n//\trep(i,0,m) printf(\"%d \",b[i]); puts(\"\");\n\trep(i,1,m) c[i]=b[i]*powmod(mod+1-a[i],mod-2)%mod;\n\tidft(c,0,m-1);\n\t// c[0]+ 1/2^n f0 = 0\n\tll f0=(mod-c[0])%mod;\n\trep(i,0,m) {\n\t\tc[i]=(c[i]+f0)%mod;\n\t\tif (c[i]<0) c[i]+=mod;\n\t\tprintf(\"%d\\n\",c[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1<<18|2,mod=998244353;\nll a[N],f[N],fd[N],A[N];\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nvoid FWT(ll *a,int n){\n\tFor(i,0,n-1){\n\t\tFor(j,0,(1<<n)-1)if(j>>i&1){\n\t\t\tll x=a[j-(1<<i)],y=a[j]; //cout<<j<<\" \"<<a[j]<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\ta[j-(1<<i)]=(x+y)%mod; a[j]=(x-y)%mod;\n\t\t}\n\t}\n}\nvoid UFWT(ll *a,int n){\n\tFWT(a,n);\n\tll inv=ksm(1<<n,mod-2);\n\t//For(i,0,(1<<n)-1)a[i]=a[i]*inv%mod;\n}\nint main(){\n\tint n=read(); ll sum=0;\n\tFor(i,0,(1<<n)-1)a[i]=read();\n\tFor(i,0,(1<<n)-1)sum=(sum+a[i])%mod;\n\tsum=ksm(sum,mod-2); \n\tFor(i,0,(1<<n)-1)a[i]=a[i]*sum%mod;\n\tFWT(a,n); //cout<<a[0]<<endl;\n\tmemcpy(A,a,sizeof(A)); UFWT(A,n);\n\tFor(i,0,(1<<n)-1){\n\t\tif(i==0){f[i]=1; }\n\t\telse f[i]=ksm(a[i]-1,mod-2); \n\t\t//cout<<a[i]<<\" \"<<A[i]<<\" \"<<f[i]<<\" \"<<fd[i]<<endl;\n\t}\n\tUFWT(f,n);\n\tFor(i,0,(1<<n)-1){\n\t\t//cout<<xs<<\" \"<<f[0]<<\" \"<<fd[0]<<\" \"<<f[i]<<\" \"<<fd[i]<<endl;\n\t\twriteln(((f[i]-f[0])%mod+mod)%mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\n#define FF first\n#define SS second\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\nusing namespace std;\nconst int mod = 998244353;\nint qpow(int x, int k) {return k==0?1:1ll*qpow(1ll*x*x%mod, k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 1<<18;\nint n;\nvoid FWT(int a[])\n{\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif (((j>>i)&1)) continue;\n\t\t\tint tmp = a[j+(1<<i)];\n\t\t\ta[j+(1<<i)] = (a[j]-tmp)%mod;\n\t\t\ta[j] = (a[j]+tmp)%mod;\n\t\t}\n\t}\n}\nvoid IFWT(int a[])\n{\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif (((j>>i)&1)) continue;\n\t\t\tint tmp = a[j+(1<<i)];\n\t\t\ta[j+(1<<i)] = (a[j]-tmp)%mod;\n\t\t\ta[j] = (a[j]+tmp)%mod;\n\t\t}\n\t}\n\tint inv = qpow(1<<n, mod-2);\n\tfor (int i=0; i<(1<<n); i++) a[i] = 1ll*a[i]*inv%mod;\n}\n\nint a[maxn];\nint b[maxn];\nint ans[maxn];\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i=0; i<(1<<n); i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tint inv_sum = qpow(sum, mod-2);\n\tfor (int i=0; i<(1<<n); i++) a[i] = 1ll*a[i]*inv_sum%mod;\n\tFWT(a);\n\tll Qd = 0;\n\tfor (int i=1; i<(1<<n); i++)\n\t{\n\t\tQd = (Qd+qpow(a[i]-1, mod-2))%mod;\n\t}\n\tfor (int i=1; i<(1<<n); i++)\n\t{\n\t\tassert((a[i]-1)%mod!=0);\n\t\tans[i] = qpow(a[i]-1, mod-2);\n//\t\t1ll*qpow((1-a[i]), mod-2)*Qd%mod;\n\t}\n\tfor (int i=1; i<(1<<n); i++) ans[0] = (ans[0]-ans[i])%mod;\n\tFWT(ans);\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tprintf(\"%d\\n\", (ans[i]%mod+mod)%mod);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mov(x) (1<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nconst int MX = 262144;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nll qpow(ll x, ll t)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans * x % MOD;\n\t\tx = x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x)\n{\n\treturn qpow(x, MOD-2);\n}\n\nvoid fwt(ll *f, int bit)\n{\n\tfor(int i=1; i<mov(bit); i<<=1)\n\t\tfor(int j=0; j<mov(bit); j+=(i<<1))\n\t\t\tfor(int k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tll x = f[j+k], y = f[j+k+i];\n\t\t\t\tf[j+k] = (x+y) % MOD;\n\t\t\t\tf[j+k+i] = (x-y+MOD) % MOD;\n\t\t\t}\n}\n\nint n;\nll p[MX], rgt[MX], lft[MX];\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=0; i<mov(n); i++) read(p[i]);\n}\n\nvoid work()\n{\n\tll sum_i = inv(accumulate(p, p+mov(n), 0));\n\tfor_each(p, p+mov(n), [=](ll &x){x = x*sum_i%MOD;}), p[0] = (p[0]-1+MOD) % MOD;\n\tfill(rgt, rgt+mov(n), MOD-1), rgt[0] = mov(n)-1;\n\tfwt(rgt, n), fwt(p, n);\n\tfor_each(p, p+mov(n), [=](ll &x){x = inv(x);});\n\tfor(int i=0; i<mov(n); i++) lft[i] = rgt[i] * p[i] % MOD;\n\tfwt(lft, n);\n\tll iv = inv(mov(n));\n\tfor_each(lft, lft+mov(n), [=](ll &x){x = x*iv%MOD;});\n\tfor_each(lft, lft+mov(n), [=](ll x){printf(\"%lld\\n\", (x-lft[0]+MOD)%MOD);});\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define N 400102\nconst int p=998244353,iv=499122177;\nint n,ps[N],m,a[N];\ninline int ksm(int d,int k){int ret=1;while(k){if(k&1)ret=1ll*ret*d%p;d=1ll*d*d%p;k>>=1;}return ret;}\ninline void fwt(int x[],int len,int mde)\n{\n    for(int i=2;i<=len;i<<=1)for(int j=0,stp=i>>1;j<len;j+=i)for(int k=j;k<j+stp;k++)\n    {\n        int t1=x[k],t2=x[k+stp];x[k]=(t1+t2)%p,x[k+stp]=(t1-t2+p)%p;\n        if(mde<0)x[k]=1ll*x[k]*iv%p,x[k+stp]=1ll*x[k+stp]*iv%p;\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);m=(1<<n);int sum=0;\n    for(int i=0;i<m;i++)scanf(\"%d\",&ps[i]),sum=(sum+ps[i])%p;sum=ksm(sum,p-2)%p;\n    for(int i=0;i<m;i++)ps[i]=1ll*ps[i]*sum%p;\n    a[0]=m-1;for(int i=1;i<m;i++)a[i]=p-1;\n    ps[0]=(ps[0]+p-1)%p;\n    fwt(a,m,1);fwt(ps,m,1);\n    for(int i=0;i<m;i++)a[i]=1ll*a[i]*ksm(ps[i],p-2)%p;\n    a[0]=0;\n    fwt(a,m,-1);\n    for(int i=1;i<m;i++)a[i]=(a[i]-a[0]+p)%p;\n    a[0]=0;\n    for(int i=0;i<m;i++)printf(\"%d\\n\",a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define ll long long\nusing namespace std;\nconst int N=(1<<18)+5,mo=998244353;\nint n,s;\nint a[N],f[N];\nint ksm(int x,int y){\n\tint t=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo)if(y&1)t=(ll)t*x%mo;\n\treturn t;\n}\nvoid up(int &x){x+=(x>>31)&mo;}\nvoid fwt(int *a,int sig){\n\tint A;\n\tfor(int i=1;i<1<<n;i<<=1)for(int j=0;j<1<<n;j+=i*2)\n\t\tfo(k,0,i-1)A=a[j+k],up(a[j+k]+=a[i+j+k]-mo),up(a[i+j+k]=A-a[i+j+k]);\n\tif(sig){\n\t\tint y=ksm(1<<n,mo-2);\n\t\tfo(i,0,(1<<n)-1)a[i]=(ll)a[i]*y%mo;\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfo(i,0,(1<<n)-1)cin>>a[i],s+=a[i];\n\ts=ksm(s,mo-2);\n\tf[0]=(1<<n)-1;\n\tfo(i,1,(1<<n)-1)f[i]=mo-1;\n\tfo(i,0,(1<<n)-1)a[i]=(ll)a[i]*s%mo;\n\tup(a[0]-=1);\n\tfwt(a,0);fwt(f,0);\n\tfo(i,0,(1<<n)-1)a[i]=(ll)f[i]*ksm(a[i],mo-2)%mo;\n\tfwt(a,1);\n\tint dt=a[0];\n\tfo(i,0,(1<<n)-1)up(a[i]-=dt),printf(\"%d\\n\",a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e6 + 1000,mod = 998244353;\nll n,sum,A[N],S[N];\nll ksm(ll x,ll y)\n{\n\tll res = 1; \n\tfor(;y;y >>= 1,x = x * x % mod) \n\t\tif(y & 1) res = res * x % mod; \n\treturn res;\n}\nvoid Xor(ll *f,ll opt)\n{\n\tll a,b;\n\tfor(int len = 2,mid = 1;len <= n;len <<= 1,mid <<= 1)\n\t\tfor(int i = 0;i < n;i += len)\n\t\t\tfor(int j = 0;j < mid;j ++)\n\t\t\t{\n\t\t\t\ta = f[i + j]; b = f[i + j + mid];\n\t\t\t\tf[i + j] = (a + b) % mod * opt % mod;\n\t\t\t\tf[i + j + mid] = (a - b) % mod * opt % mod;\n\t\t\t}\n\tfor(int i = 0;i < n;i ++) f[i] = (f[i] + mod) % mod;\n}\nint main()\n{\n\tn = read(); n = (1 << n);\n\tfor(int i = 0;i < n;i ++) sum = sum + (A[i] = read());\n\tsum = ksm(sum,mod - 2); \n\tfor(int i = 0;i < n;i ++) A[i] = A[i] * sum % mod;\n\tA[0] --; if(A[0] < 0) A[0] += mod; \n\tS[0] = n - 1; for(int i = 1;i < n;i ++) S[i] = mod - 1;\n\tXor(S,1); Xor(A,1);\n\tfor(int i = 0;i < n;i ++) A[i] = ksm(A[i],mod - 2) * S[i] % mod;\n\tXor(A,(mod + 1) >> 1);\n\tll x = mod - A[0];\n\tfor(int i = 0;i < n;i ++) cout << ((x + A[i]) % mod + mod) % mod << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 262144\n#define p 998244353\n#define ll long long\ninline int mod(int x){return x>=p?x-p:x;}\ninline int calc(int x,int y)\n{\n\tint z=1;\n\tfor(;y;x=(ll)x*x%p,y>>=1)if(y&1)z=(ll)x*z%p;\n\treturn z;\n}\nint a[N],i,j,k,n,x,y;\ninline void FWT(){for(i=1;i<n;i<<=1)for(j=0,k=i;k<n;j+=i,k+=i)while(k&i)x=a[j],y=a[k],a[j++]=mod(x+y),a[k++]=mod(p+x-y);}\nint main()\n{\n\tscanf(\"%d\",&n),n=1<<n;\n\tfor(i=0;i<n;i++)scanf(\"%d\",a+i),x+=a[i];\n\tfor(i=0,x=mod(p-calc(x,p-2));i<n;i++)a[i]=(ll)a[i]*x%p;\n\tfor(FWT(),i=0;i<n;i++)a[i]=calc(p-1-a[i],p-2);\n\tfor(FWT(),i=0;i<n;i++)printf(\"%d\\n\",mod(p+a[i]-*a));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 998244353, inv2 = 499122177;\nconst int MAXN = 20, MAXL = ( 1 << 18 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint F[MAXN], p[MAXN], h[MAXN];\nint N, len;\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nint fix( const int x ) { return ( x % mod + mod ) % mod; }\n\nvoid FWT( int *f, const int mode )\n{\n\tint t1, t2;\n\tfor( int s = 2 ; s <= len ; s <<= 1 )\n\t\tfor( int i = 0, t = s >> 1 ; i < len ; i += s )\n\t\t\tfor( int j = i ; j < i + t ; j ++ )\n\t\t\t{\n\t\t\t\tt1 = f[j], t2 = f[j + t];\n\t\t\t\tif( mode > 0 ) f[j] = ( t1 + t2 ) % mod, f[j + t] = fix( t1 - t2 );\n\t\t\t\telse f[j] = 1ll * ( t1 + t2 ) * inv2 % mod, f[j + t] = 1ll * fix( t1 - t2 ) * inv2 % mod;\n\t\t\t}\n}\n\nint main()\n{\n\tint s = 0;\n\tread( N ); len = 1 << N;\n\tfor( int i = 0 ; i < len ; i ++ ) read( p[i] ), s = ( s + p[i] ) % mod;\n\ts = inv( s );\n\tfor( int i = 0 ; i < len ; i ++ ) p[i] = 1ll * p[i] * s % mod;\n\tfor( int i = 1 ; i < len ; i ++ ) h[i] = mod - 1;\n\th[0] = len - 1, p[0] = fix( p[0] - 1 );\n\tFWT( h, 1 ), FWT( p, 1 );\n\tfor( int i = 1 ; i < len ; i ++ ) F[i] = 1ll * h[i] * inv( p[i] ) % mod;\n\tFWT( F, -1 );\n\tint tmp = mod - F[0];\n\tfor( int i = 0 ; i < len ; i ++ ) write( ( tmp + F[i] ) % mod ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=300005,P=998244353,iv2=499122177;\n#define ll long long\nint n,m,s,a[N],b[N],p[N];\ninline ll pw(ll a,ll b){ll r=1;for(;b;b>>=1,a=a*a%P)if(b&1)r=r*a%P;return r;}\ninline void fwt(int *a){for(int i=1;i<m;i<<=1)for(int j=0;j<m;j++)if(j&i){int u=a[j^i],v=a[j];a[j^i]=(u+v)%P;a[j]=(u-v+P)%P;}}\ninline void ifwt(int *a){for(int i=1;i<m;i<<=1)for(int j=0;j<m;j++)if(j&i){int u=a[j^i],v=a[j];a[j^i]=1ll*iv2*(u+v)%P;a[j]=1ll*iv2*(u-v+P)%P;}}\nint main()\n{\n\tscanf(\"%d\",&n);m=1<<n;\n\tfor(int i=0;i<m;i++)scanf(\"%d\",&p[i]),s=(s+p[i])%P;\n\ta[0]=m-1;for(int i=1;i<m;i++)a[i]=P-1;\n\ts=pw(s,P-2);for(int i=0;i<m;i++)b[i]=1ll*p[i]*s%P;b[0]=(b[0]-1+P)%P;\n\tfwt(a);fwt(b);a[0]=0;\n\tfor(int i=1;i<m;i++)a[i]=1ll*a[i]*pw(b[i],P-2)%P;\n\tifwt(a);int t=1ll*(P-a[0])*m%P;fwt(a);a[0]=t;ifwt(a);\n\tfor(int i=0;i<m;i++)printf(\"%d\\n\",a[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nvi A;\n\nvmi solve(vmi a, vmi b) {\n    if (sz(a) == 1) {\n        if (a[0] == 0) return {0};\n        return {b[0]/a[0]};\n    }\n    vmi a0, a1, b0, b1;\n    F0R(i,sz(a)/2) {\n        a0.pb(a[2*i]+a[2*i+1]);\n        a1.pb(a[2*i]-a[2*i+1]);\n        b0.pb(b[2*i]+b[2*i+1]);\n        b1.pb(b[2*i]-b[2*i+1]);\n    }\n    auto x = solve(a0,b0), y = solve(a1,b1);\n    vmi res;\n    F0R(i,sz(x)) {\n        res.pb((x[i]+y[i])/2);\n        res.pb((x[i]-y[i])/2);\n    }\n    return res;\n}\n\nint main() {\n\tsetIO(); re(N); A.resz(1<<N); re(A);\n\tint sum = 0; trav(t,A) sum += t;\n\tvmi p(1<<N); F0R(i,1<<N) p[i] = mi(A[i])/sum;\n\tp[0] -= 1;\n\tvmi res(1<<N); F0R(i,1<<N) res[i] -= 1;\n\tres[0] += (1<<N);\n\tauto z = solve(p,res); FOR(i,1,1<<N) z[i] -= z[0];\n\tz[0] = 0;\n\tF0R(i,1<<N) ps(z[i]);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define L 19\n#define M 262144\nconst int mo=998244353;\ntypedef long long LL;\nusing namespace std;\nint n,m;\nint a[M+1],b[M+1];\nLL ksm(LL k,LL n)\n{\n\tLL s=1;\n\tfor(;n;n>>=1,k=k*k%mo) if(n&1) s=s*k%mo;\n\treturn s;\n}\nconst LL ny2=499122177;\nvoid FWT(int *a,bool pd)\n{\n\tfor(int h=1;h<m;h<<=1)\n\t\tfor(int j=0;j<M;j+=h*2)\n\t\t\tfo(i,0,h-1)\n\t\t\t{\n\t\t\t\tint v=a[i+j+h];\n\t\t\t\ta[i+j+h]=(a[i+j]-v+mo)%mo,a[i+j]=(a[i+j]+v)%mo;\n\t\t\t\tif(pd) a[i+j]=(LL)a[i+j]*ny2%mo,a[i+j+h]=(LL)a[i+j+h]*ny2%mo;\n\t\t\t}\n}\nLL pr[M];\nint main()\n{\n\tcin>>n;\n\tm=1<<n;\n\tLL sum=0;\n\tfo(i,0,m-1) scanf(\"%lld\",&pr[i]),sum=(sum+pr[i])%mo;\n\tsum=ksm(sum,mo-2);\n\ta[0]=m-1;\n\tfo(i,1,m-1) a[i]=mo-1;\n\tfo(i,0,m-1) b[i]=pr[i]*sum%mo;\n\tb[0]=(b[0]-1+mo)%mo;\n\tFWT(a,0),FWT(b,0);\n\tint wz=0;\n\tfo(i,0,m-1)\n\t{\n\t\tif(b[i]!=0) a[i]=(LL)a[i]*ksm(b[i],mo-2)%mo;\n\t\telse a[i]=0,wz=i;\n\t}\n\tFWT(a,1);\n\tLL wp=(LL)(mo-a[0])*m%mo;\n\tFWT(a,0);\n\ta[wz]=wp;\n\tFWT(a,1);\n\tfo(i,0,m-1) printf(\"%d\\n\",a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define mo 998244353\nvoid fwxo(int *a,int l,int r){\n\tif(l==r)return;\n\tint md=(l+r)/2;\n\tfwxo(a,l,md);fwxo(a,md+1,r);\n\tfor(int i=l;i<=md;i++){\n\t\tint c=a[i],d=a[md+i-l+1];\n\t\ta[md+i-l+1]=(c-d+mo)%mo;\n\t\ta[i]=(c+d)%mo;\n\t}\n}\nint qp(int x,int y){\n\tint r=1;\n\tfor(;y;y>>=1,x=x*x%mo)\n\t\tif(y&1)r=r*x%mo;\n\treturn r;\n}\nint n,a[10000010],s,f[10000010];\nsigned main(){\n\tcin>>n;\n\tfor(int i=0;i<(1<<n);i++){\n\t\tcin>>a[i];\n\t\ts=(s+a[i])%mo;\n\t}\n\tfor(int i=0;i<(1<<n);i++)\n\t\ta[i]=a[i]*qp(s,mo-2)%mo;\n\tfwxo(a,0,(1<<n)-1);\n\ts=0;\n\tfor(int i=1;i<(1<<n);i++){\n\t\tf[i]=qp(a[i]-1,mo-2);\n\t\ts=(s+f[i])%mo;\n\t}\n\tf[0]=(-s+mo)%mo;\n\tfwxo(f,0,(1<<n)-1);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tcout<<f[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<num, num> pii;\ntypedef vector<int> vi;\ntypedef vector<num> vn;\n\nvoid FST(vn& a, bool inv) {\n\tfor (int n = sz(a), step = 1; step < n; step *= 2) {\n\t\tfor (int i = 0; i < n; i += 2 * step) rep(j,i,i+step) {\n\t\t\tnum &u = a[j], &v = a[j + step]; tie(u, v) =\n\t\t\t\tpii(u + v, u - v);                   // XOR\n\t\t}\n\t}\n\tif (inv) trav(x, a) x /= sz(a); // XOR only\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tvector<num> a(N), b(N);\n\tnum asum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tint r;\n\t\tcin >> r;\n\t\ta[i] = r;\n\t\tb[i] = -1;\n\t\tasum += a[i];\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\ta[i] /= asum;\n\t}\n\ta[0] -= 1;\n\tb[0] += N;\n\tFST(a, 0); FST(b, 0);\n\tfor(int i = 1; i < N; i++) b[i] /= a[i];\n\tFST(b, 1);\n\tfor(int i = 0; i < N; i++){\n\t\tcout << (int) (b[i] - b[0]) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\nconst int N=1<<18;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int mod=998244353;\nconst int N2=(mod+1)/2;\nint n,a[N],e[N],b[N],c[N];\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)\n\t\tif(b&1)s=1LL*s*a%mod;\n\treturn s;\n}\nvoid fwt(int*a,int n){\n\tfor(int i=1;i<(1<<n);i<<=1)\n\t\tfor(int j=0;j<(1<<n);j+=(i<<1))\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint A=a[j+k],B=a[j+k+i];\n\t\t\t\ta[j+k]=(A+B)%mod;\n\t\t\t\ta[j+k+i]=(mod+A-B)%mod;\n\t\t\t}\n}\nvoid ifwt(int*a,int n){\n\tfor(int i=1;i<(1<<n);i<<=1)\n\t\tfor(int j=0;j<(1<<n);j+=(i<<1))\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint A=a[j+k],B=a[j+k+i];\n\t\t\t\ta[j+k]=1LL*(A+B)*N2%mod;\n\t\t\t\ta[j+k+i]=1LL*(mod+A-B)*N2%mod;\n\t\t\t}\n}\nint main(){\n\tn=read();\n\tint sum=0;\n\tref(i,0,(1<<n)-1)a[i]=read(),sum+=a[i];\n\tsum=mi(sum,mod-2);\n\tref(i,0,(1<<n)-1)e[i]=1LL*a[i]*sum%mod;\n\tfwt(e,n);\n\tref(i,0,(1<<n)-1)b[i]=mi(mod+1-e[i],mod-2);\n\tref(i,1,(1<<n)-1)c[i]=1;\n\tfwt(c,n);\n\tref(i,1,(1<<n)-1)c[i]-=c[0];c[0]=0;\n\tref(i,0,(1<<n)-1)c[i]=1LL*b[i]*c[i]%mod;\n\tifwt(c,n);\n\tref(i,1,(1<<n)-1)c[i]=(c[i]+mod-c[0])%mod;c[0]=0;\n\tref(i,0,(1<<n)-1)cout<<c[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 1000010\n#define mo 998244353\n#define ni (mo+1)/2\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char ch=getchar();int fh=1;\n\twhile (ch<'0'||ch>'9'){if (ch=='-')fh=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx*=fh;\n}\nll n,v[N],su,a[N];\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nvoid fwt(ll *a,int fh){\n\tfor (int i=1;i<(1<<n);i*=2){\n\t\tfor (int j=0;j<(1<<n);j+=i*2){\n\t\t\tfor (int k=0;k<i;k++){\n\t\t\t\tll x=a[j+k],y=a[j+k+i];\n\t\t\t\tif (fh==1){a[j+k]=(x+y)%mo;a[j+k+i]=(x-y+mo)%mo;}\n\t\t\t\telse{a[j+k]=(x+y)*ni%mo;a[j+k+i]=(x-y+mo)*ni%mo;}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tread(n);\n\tfor (int i=0;i<(1<<n);i++){read(v[i]);su+=v[i];}\n\tfor (int i=0;i<(1<<n);i++)v[i]=v[i]*po(su,mo-2)%mo;\n\tv[0]=(v[0]-1+mo)%mo;\n\tfor (int i=0;i<(1<<n);i++)if (i==0)a[i]=(1<<n)-1;else a[i]=mo-1;\n\tfwt(a,1);fwt(v,1);\n\tfor (int i=0;i<(1<<n);i++)a[i]=a[i]*po(v[i],mo-2)%mo;\n\tfwt(a,-1);\n\tfor (int i=(1<<n)-1;i>=0;i--)a[i]=(a[i]-a[0]+mo)%mo;\n\tfor (int i=0;i<(1<<n);i++)cout<<a[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i , n) for (int i = 0; i < (int)(n); i++)\n#define INF 1e9;\nusing namespace std;\nusing ll = long long;\nint main() {\n    int N , A , B , C , D;\n    cin >> N >> A >> B >> C >> D;\n    string S;\n    cin >> S;\n    string T = S;\n    T[A - 1] = 'A';\n    T[B - 1] = 'B';\n    int X = A;\n    int Y = B;\n    while(A <= C){\n        if(S[A - 1] == '#' || T[A - 1] == 'B' || A >= N - 1){\n            if(!(S[A] == '#' || T[A] == 'B' || A >= N)){\n                T[A - 1] = S[A - 1];\n                A+=2;\n                T[A - 1] = 'A';\n            }\n            else{\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n        if(S[A] == '#' || T[A] == 'B' || A >= N){\n            if(!(S[A - 1] == '#' || T[A - 1] == 'B' || A >= N - 1)){\n                T[A] = S[A];\n                A++;\n                T[A] = 'A';\n            }\n            else{\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    while(B <= D){\n        if(S[B - 1] == '#' || T[B - 1] == 'A' || B >= N - 1){\n            if(!(S[B] == '#' || T[B] == 'A' || B >= N)){\n                T[B - 1] = S[B - 1];\n                B+=2;\n                T[B - 1] = 'B';\n            }\n            else{\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n        if(S[B] == '#' || T[B] == 'A' || B >= N){\n            if(!(S[B - 1] == '#' || T[B - 1] == 'A' || B >= N - 1)){\n                T[B - 1] = S[B - 1];\n                B++;\n                T[B - 1] = 'B';\n            }\n            else{\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  for (int i = 0; i < v.size(); ++i)\n    os << v[i] << '\\n';\n  return os;\n}\n\nconst int P = 998244353;\n\nint mpow(int x, int k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % p;\n    x = x * (ll)x % p;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint norm(int x) { return x >= P ? x - P : x; }\n\nstruct NumberTheory {\n\n  typedef pair<int, int> _P2_Field;\n\n  mt19937 rng;\n\n  NumberTheory() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n\n  void _exGcd(int a, int b, int& x, int& y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  int inv(int a, int p = P) {\n    int x, y;\n    _exGcd(a, p, x, y);\n    if (x < 0)\n      x += p;\n    return x;\n  }\n\n  template <class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1)\n      return true;\n    while (a % 4 == 0)\n      a /= 4;\n    if (a % 2 == 0)\n      return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n\n  // assume p in prime, x in quadratic residue\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1)\n      return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (ll)w - x + p) % p), p));\n    _P2_Field res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = _P2_Field((res.first * (ll)a.first + res.second * (ll)a.second % p * v) % p, (res.first * (ll)a.second + res.second * (ll)a.first) % p);\n      if (k >>= 1)\n        a = _P2_Field((a.first * (ll)a.first + a.second * (ll)a.second % p * v) % p, (a.first * (ll)a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n\n} nt;\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nvoid fwt(int* a, int n) {\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < 1 << n; ++j)\n      if ((j >> i) & 1) {\n        int a0 = norm(a[j ^ (1 << i)] + a[j]);\n        a[j] = norm(P + a[j ^ (1 << i)] - a[j]);\n        a[j ^ (1 << i)] = a0;\n      }\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<int> a(1 << n);\n  cin >> a;\n  int s = accumulate(a.begin(), a.end(), 0);\n  int is = nt.inv(s);\n  for (int i = 0; i < 1 << n; ++i)\n    a[i] = a[i] * (ll)is % P;\n  vector<int> fwa = a;\n  fwt(fwa.begin().base(), n);\n  vector<int> f(1 << n);\n  for (int i = 1; i < 1 << n; ++i)\n    f[i] = nt.inv(norm(P + 1 - fwa[i]));\n  fwt(f.begin().base(), n);\n  vector<int> ans(1 << n);\n  for (int i = 0; i < 1 << n; ++i)\n    ans[i] = norm(P + f[0] - f[i]);\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1<<18,mo=998244353,inv2=(mo+1>>1);\nll a[N],b[N],n,c[N];\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nvoid fwt(ll *a,int M=1<<n){\n\tfor (int n=1;n<M;n<<=1)\n\t\tfor (int i=n;i<M;i=(i+1)|n){\n\t\t\tll z=a[i^n];\n\t\t\ta[i^n]=(a[i]+a[i^n])%mo;\n\t\t\ta[i]=(z-a[i]+mo)%mo;\n\t\t}\n}\nvoid ifwt(ll *a,int M=1<<n){\n\tfor (int n=1;n<M;n<<=1)\n\t\tfor (int i=n;i<M;i=(i+1)|n){\n\t\t\tll z=a[i^n];\n\t\t\ta[i^n]=(a[i]+a[i^n])*inv2%mo;\n\t\t\ta[i]=(z-a[i]+mo)*inv2%mo;\n\t\t}\n}\nint main(){\n\tcin>>n;\n\tll sum=0;\n\tfor (int i=0;i<1<<n;i++)scanf(\"%lld\",&a[i]),sum+=a[i],b[i]=mo-1;\n\tsum=power(sum);\n\tfor (int i=0;i<1<<n;i++)a[i]=a[i]*sum%mo;\n\tfwt(a);fwt(b);\n\tsum=0;\n\tll G=(1<<n)-1;\n\tfor (int i=1;i<1<<n;i++)c[i]=(G+1)*power(a[i]-1)%mo,c[0]=c[0]+(mo-c[i]);\n\tifwt(c);\n\tfor (int i=0;i<1<<n;i++)printf(\"%lld\\n\",c[i]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=998244353,iv2=(mod+1>>1);\nint n,A[262147],F[262147],sA;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nvoid FWT(int a[])\n{\n\tfor (int i=1; i<(1<<n); i<<=1)\n\t\tfor (int j=0; j<(1<<n); j+=(i<<1))\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tint t1=a[j+k],t2=a[i+j+k];\n\t\t\t\ta[j+k]=(t1+t2>=mod?t1+t2-mod:t1+t2);\n\t\t\t\ta[i+j+k]=(t1<t2?t1-t2+mod:t1-t2);\n\t\t\t}\n}\n\nvoid IFWT(int a[])\n{\n\tfor (int i=1; i<(1<<n); i<<=1)\n\t\tfor (int j=0; j<(1<<n); j+=(i<<1))\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tint t1=1ll*a[j+k]*iv2%mod,t2=1ll*a[i+j+k]*iv2%mod;\n\t\t\t\ta[j+k]=(t1+t2>=mod?t1+t2-mod:t1+t2);\n\t\t\t\ta[i+j+k]=(t1<t2?t1-t2+mod:t1-t2);\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),sA=0;\n\tfor (int i=0; i<(1<<n); i++) scanf(\"%d\",&A[i]),sA+=A[i];\n\tsA=quickmi(sA,mod-2);\n\tfor (int i=0; i<(1<<n); i++) A[i]=1ll*sA*A[i]%mod;\n\tFWT(A),sA=0;\n\tfor (int i=1; i<(1<<n); i++) \n\t\tF[i]=(1ll<<n)*quickmi(A[i]+mod-1,mod-2)%mod,\n\t\tsA=(sA+F[i]>=mod?sA+F[i]-mod:sA+F[i]);\n\tF[0]=(sA==0?0:mod-sA),IFWT(F);\n\tfor (int i=0; i<(1<<n); i++) printf(\"%d\\n\",F[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define mod 998244353\n#define G2 499122177\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn=1<<19;\nint n;\nll a[maxn],p[maxn];\ninline ll qpow(ll x,ll y)\n{\n\tll ans=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\ninline void FWT(ll*A,int limit)\n{\n\tfor(int len=2;len<=limit;len<<=1)\n\t\tfor(int i=0;i<limit/len;++i)\n\t\t\tfor(int j=0;j<len/2;++j)\n\t\t\t{\n\t\t\t\tll x=A[i*len+j],y=A[i*len+j+len/2];\n\t\t\t\tA[i*len+j]=(x+y)%mod;\n\t\t\t\tA[i*len+j+len/2]=(x-y+mod)%mod;\n\t\t\t}\n}\ninline void IFWT(ll*A,int limit)\n{\n\tfor(int len=2;len<=limit;len<<=1)\n\t\tfor(int i=0;i<limit/len;++i)\n\t\t\tfor(int j=0;j<len/2;++j)\n\t\t\t{\n\t\t\t\tll x=A[i*len+j],y=A[i*len+j+len/2];\n\t\t\t\tA[i*len+j]=(x+y)%mod*G2%mod;\n\t\t\t\tA[i*len+j+len/2]=(x-y+mod)%mod*G2%mod;\n\t\t\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tll s=0;\n\tfor(int i=0;i<(1<<n);++i)\n\t{\n\t\tcin>>p[i];\n\t\ts+=p[i];\n\t}\n\ts=qpow(s%mod,mod-2);\n\tfor(int i=0;i<(1<<n);++i)\n\t\tp[i]=p[i]*s%mod;\n\ta[0]=(1<<n)-1;\n\tfor(int i=1;i<(1<<n);++i)\n\t\ta[i]=mod-1;\n\tp[0]=(p[0]-1+mod)%mod;\n\tFWT(p,1<<n),FWT(a,1<<n);\n\tfor(int i=0;i<(1<<n);++i)\n\t\ta[i]=a[i]*qpow(p[i],mod-2)%mod;\n\tIFWT(a,1<<n);\n\tfor(int i=0;i<(1<<n);++i)\n\t\tcout<<(a[i]-a[0]+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef unsigned long long u64;\nconst u32 P=998244353;\nint n, m;\nu32 p[1<<18], f[1<<18], d[1<<18];\nu32 inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b>>=1) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\nvoid wt(u32 *a) {\n\tfor(int i=1; i<m; i<<=1)\n\t\tfor(int j=i; j<m; j=j+1|i) {\n\t\t\tu32 s=a[j-i], t=a[j];\n\t\t\ta[j-i]=sum(s, t);\n\t\t\ta[j]=dif(s, t);\n\t\t}\n}\nvoid iwt(u32 *a) {\n\tu64 inv=power(m, P-2);\n\twt(a);\n\tfor(int i=0; i<m; ++i) a[i]=a[i]*inv%P;\n}\nint main() {\n\tassert(scanf(\"%d\", &n)==1);\n\tm=1<<n;\n\tfor(int i=0; i<m; ++i) assert(scanf(\"%d\", p+i)==1);\n\tu64 inv=power(std::accumulate(p, p+m, 0), P-2);\n\tfor(int i=0; i<m; ++i) p[i]=(u64)inv*p[i]%P;\n\twt(p);\n\tf[0]=1;\n\tiwt(f);\n\tfor(int i=1; i<m; ++i) d[i]=power(P+1-p[i], P-2);\n\tiwt(d);\n\tinv=power(f[0], P-3);\n\tfor(int i=0; i<m; ++i) printf(\"%llu\\n\", ((u64)f[i]*d[0]+(u64)(P-f[0])*d[i])%P*inv%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint fastpow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint remod(LL x) { x %= mod; return x + (x >> 63 & mod); }\nconst int MAXN = 1 << 18;\nint n, A[MAXN], tar[MAXN];\nvoid FWT(int * A, int typ) {\n\tconst int U = 1 << n;\n\tfor (int mid = 1; mid != U; mid <<= 1)\n\t\tfor (int k = 0; k != U; k += mid << 1)\n\t\t\tfor (int l = 0; l != mid; ++l) {\n\t\t\t\tconst int X = A[l + k], Y = A[l + k + mid];\n\t\t\t\treduce(A[l + k] += Y - mod);\n\t\t\t\treduce(A[l + k + mid] = X - Y);\n\t\t\t}\n\tif (typ == -1) {\n\t\tconst int liminv = fastpow(U, mod - 2);\n\t\tfor (int i = 0; i != U; ++i) A[i] = mul(A[i], liminv);\n\t}\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tconst int U = 1 << n;\n\ttar[0] = U;\n\tfor (int i = 0; i != U; ++i) reduce(tar[i] -= 1);\n\tfor (int i = 0; i != U; ++i) std::cin >> A[i];\n\tint sa = fastpow(std::accumulate(A, A + U, 0ll) % mod, mod - 2);\n\tfor (int i = 0; i != U; ++i) A[i] = mul(A[i], sa);\n\treduce(A[0] -= 1);\n\tFWT(A, 1); FWT(tar, 1);\n\tfor (int i = 0; i != U; ++i)\n\t\tA[i] = fastpow(A[i], mod - 2, tar[i]);\n\tFWT(A, -1);\n\tfor (int i = U - 1; ~i; --i) reduce(A[i] -= A[0]);\n\tfor (int i = 0; i != U; ++i)\n\t\tstd::cout << A[i] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=998244353,inv2=499122177;\nint n;\nll p[1<<18],a[1<<18],b[1<<18],c[1<<18];\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nvoid solve(int n,ll*p,ll*a,ll*b,ll*c,int t)\n{\n\tif(n==1)\n\t{\n\t\tll inv=quick_pow(1+MOD-p[0],MOD-2);\n\t\ta[1]=inv*p[1]%MOD;\n\t\tc[1]=inv*t%MOD;\n\t\ta[0]=1;\n\t\treturn;\n\t}\n\tint m=1<<(n-1);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tp[i]=(p[i]+p[i+m])%MOD;\n\t\tp[i+m]=(p[i]+2*MOD-2*p[i+m])%MOD;\n\t}\n\tsolve(n-1,p,a,b,c,t);\n\tsolve(n-1,p+m,a+m,b+m,c+m,0);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\ta[i]=b[i]=a[i]*inv2%MOD;\n\t\ta[i+m]=a[i+m]*inv2%MOD,b[i+m]=MOD-a[i+m];\n\t\ta[i]+=a[i+m],a[i+m]=a[i]+MOD-2*a[i+m];\n\t\tb[i]+=b[i+m],b[i+m]=b[i]+MOD-2*b[i+m];\n\t\tc[i]+=c[i+m],c[i+m]=c[i]+MOD-2*c[i+m];\n\t\tll p1=(p[i]+p[i+m])*inv2%MOD;\n\t\tll p2=(p[i]-p[i+m]+MOD)*inv2%MOD;\n\t\tp[i]=p1,p[i+m]=p2;\n\t}\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\ta[m]=(a[m]+p[i]*a[m^i])%MOD;\n\t\tb[m]=(b[m]+p[i]*b[m^i])%MOD;\n\t\tc[m]=(c[m]+p[i]*c[m^i])%MOD;\n\t}\n\tb[m]--;\n\tll inv=quick_pow(1+MOD-b[m],MOD-2);\n\ta[m]=a[m]*inv%MOD;\n\tb[m]=0;\n\tc[m]=(c[m]+t)*inv%MOD;\n\tfor(int i=1;i<(1<<n);i++)\n\t{\n\t\ta[i]=(a[i]+b[i]*a[m])%MOD;\n\t\tc[i]=(c[i]+b[i]*c[m])%MOD;\n\t\tb[i]=0;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tll s=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tscanf(\"%lld\",&p[i]);\n\t\ts+=p[i];\n\t}\n\ts=quick_pow(s,MOD-2);\n\tfor(int i=0;i<(1<<n);i++)p[i]=p[i]*s%MOD;\n\tsolve(n,p,a,b,c,1);\n\tfor(int i=0;i<(1<<n);i++)printf(\"%lld\\n\",c[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=18,mod=998244353;\nint n,lim,cur,inv2,g[1<<N],f[1<<N],h[1<<N]; //f*g=h\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\ninline int sub(CI x,CI y)\n{\n\tint t=x-y; return t<0?t+mod:t;\n}\ninline void FWT(int* f,CI opt)\n{\n\tfor (RI i=1,j,k,x,y;i<lim;i<<=1) for (j=0;j<lim;j+=(i<<1)) for (k=0;k<i;++k) \n\tx=f[j+k],y=f[i+j+k],f[j+k]=sum(x,y),f[i+j+k]=sub(x,y),\n\t!~opt&&(f[j+k]=1LL*f[j+k]*inv2%mod,f[i+j+k]=1LL*f[i+j+k]*inv2%mod);\n}\nint main()\n{\n\tRI i; for (scanf(\"%d\",&n),lim=1<<n,i=0;i<lim;++i)\n\tscanf(\"%d\",&g[i]),cur=sum(cur,g[i]);\n\tfor (cur=quick_pow(cur),i=0;i<lim;++i) g[i]=1LL*g[i]*cur%mod;\n\tfor (inv2=quick_pow(2),g[0]=sub(g[0],1),i=1;i<lim;++i) h[i]=mod-1;\n\tfor (h[0]=lim-1,FWT(g,1),FWT(h,1),i=0;i<lim;++i)\n\tf[i]=1LL*h[i]*quick_pow(g[i])%mod; for (FWT(f,-1),i=0;i<lim;++i)\n\tprintf(\"%d\\n\",sub(f[i],f[0])); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MOD = 998244353;\nconst int INV2 = (MOD + 1) >> 1;\n\nint add(int x, int y) {return (x + y >= MOD ? x + y - MOD : x + y);}\nint sub(int x, int y) {return (x - y < 0 ? x - y + MOD : x - y);}\nint mul(int x, int y) {return 1LL*x*y%MOD;}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret,b);\n\treturn ret;\n}\n\nstruct node{\n\tint k, b;\n\tnode() : k(0), b(0) {}\n\tnode(int _k, int _b) : k(_k), b(_b) {}\n\tint get(int x) {return add(mul(k, x), b);}\n\tfriend node operator + (node a, node b) {\n\t\treturn node(add(a.k, b.k), add(a.b, b.b));\n\t}\n\tfriend node operator - (node a, node b) {\n\t\treturn node(sub(a.k, b.k), sub(a.b, b.b));\n\t}\n\tfriend node operator * (node a, int k) {\n\t\treturn node(mul(a.k, k), mul(a.b, k));\n\t}\n\tfriend node operator / (node a, int k) {\n\t\treturn a * pow_mod(k, MOD - 2);\n\t}\n};\n\nvoid fwt(node *A, int m, int type) {\n\tint n = (1 << m), f = (type == 1 ? 1 : INV2);\n\tfor(int i=1;i<=m;i++) {\n\t\tint s = (1 << i), t = (s >> 1);\n\t\tfor(int j=0;j<n;j+=s)\n\t\t\tfor(int k=0;k<t;k++) {\n\t\t\t\tnode x = A[j+k], y = A[j+k+t];\n\t\t\t\tA[j+k] = (x + y)*f, A[j+k+t] = (x - y)*f;\n\t\t\t}\n\t}\n}\n\nnode A[1<<18], B[1<<18], C[1<<18], f[1<<18];\n\nint main() {\n\tint N, M, S = 0; scanf(\"%d\", &N), M = (1 << N);\n\tfor(int i=0;i<M;i++) scanf(\"%d\", &A[i].b), S = add(S, A[i].b);\n\tS = pow_mod(S, MOD - 2);\n\tfor(int i=0;i<M;i++) A[i].b = sub(i == 0 ? 1 : 0, mul(A[i].b, S));\n\tfor(int i=0;i<M;i++) B[i].b = 1;\n\tC[0].b = MOD - 1;\n\tfwt(A, N, 1), fwt(B, N, 1), fwt(C, N, 1);\n\tint tmp = mul(B[0].b, pow_mod(C[0].b, MOD-2));\n\tfor(int i=1;i<M;i++)\n\t\tf[i] = (B[i] - C[i]*tmp) / A[i].b;\n\tf[0].k = 1; fwt(f, N, -1);\n\tint x = sub(0, mul(pow_mod(f[0].k, MOD-2), f[0].b));\n\tfor(int i=0;i<M;i++) printf(\"%d\\n\", f[i].get(x));\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n\tint x;\n\tinline modint(int x = 0) : x(x) {}\n\tinline modint &operator = (int o) { return x = o, *this; }\n\tinline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n\tinline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n\tinline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n\ttemplate <class I>\n\tinline modint &operator ^= (I b) {\n\t\tmodint a = *this, c;\n\t\tif (!~b) b = P - 2;\n\t\tc.x = 1 % P;\n\t\twhile (b) {\n\t\t\tif (b & 1) c *= a;\n\t\t\ta *= a, b >>= 1;\n\t\t}\n\t\treturn x = c.x, *this;\n\t}\n\tinline modint &operator /= (modint o) { return *this *= o ^ -1; }\n\tinline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n\tinline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n\tinline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n\tinline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n\ttemplate <class I>\n\tinline friend modint operator + (modint a, I b) { return a += b; }\n\ttemplate <class I>\n\tinline friend modint operator - (modint a, I b) { return a -= b; }\n\ttemplate <class I>\n\tinline friend modint operator * (modint a, I b) { return a *= b; }\n\ttemplate <class I>\n\tinline friend modint operator ^ (modint a, I b) { return a ^= b; }\n\ttemplate <class I>\n\tinline friend modint operator / (modint a, I b) { return a /= b; }\n\tinline friend bool operator == (modint a, int b) { return a.x == b; }\n\tinline friend bool operator != (modint a, int b) { return a.x != b; }\n\tinline friend bool operator < (modint a, int b) { return a.x < b; }\n\tinline friend bool operator <= (modint a, int b) { return a.x <= b; }\n\tinline friend bool operator > (modint a, int b) { return a.x > b; }\n\tinline friend bool operator >= (modint a, int b) { return a.x >= b; }\n\tinline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n\tinline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n\tinline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n\tinline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n\tinline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n\tinline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n\tinline bool operator ! () { return !x; }\n\tinline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1 << 18 | 1;\nint n;\nmodint a[N], b[N], s;\n\ninline void XOR(modint *f, modint x) {\n\tfor (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)\n\t\tfor (int i = 0; i < n; i += o)\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tmodint p = f[i+j] * x, q = f[i+j+k] * x;\n\t\t\t\tf[i+j] = p + q, f[i+j+k] = p - q;\n\t\t\t}\n}\n\nint main() {\n\trd(n), n = 1 << n;\n\tfor (int i = 0; i < n; i++) rd(a[i]), b[i] = P - 1, s += a[i];\n\tmodint vs = 1 / s;\n\tfor (int i = 0; i < n; i++) a[i] *= vs;\n\ta[0] -= 1, b[0] = n - 1;\n\tXOR(a, 1), XOR(b, 1);\n\tfor (int i = 0; i < n; i++) b[i] /= a[i];\n\tXOR(b, (modint)1 / 2);\n\tfor (int i = 0; i < n; i++) print(b[i] - b[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\nusing namespace std;\ntemplate<class T1, class T2> inline void chkmin(T1 &x, const T2 &y) {if (x > y) x = y;}\ntemplate<class T1, class T2> inline void chkmax(T1 &x, const T2 &y) {if (x < y) x = y;}\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define mp make_pair\n#define pb push_back\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout);\nconst int MAXN = 270228;\nconst int Mod = 998244353;\n\n\nint add(const int &a, const int &b) {\n\treturn (a + b >= Mod ? a + b - Mod: a + b);\n}\n\n\nint dec(const int &a, const int &b) {\n\treturn (a >= b ? a - b: a - b + Mod); \n}\n\n\nint mul(const int &a, const int &b) {\n\treturn (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\t\n\treturn res;\n}\n\n\n\n\nint n, w;\nint a[MAXN], b[MAXN], c[MAXN];\n\n\nvoid bpf(int *a) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 1 << n; j++) {\n\t\t\tif (j >> i & 1) {\n\t\t\t\tint x = a[j ^ (1 << i)];\n\t\t\t\tint y = a[j];\n\t\t\t\ta[j ^ (1 << i)] = add(x, y); \n\t\t\t\ta[j] = dec(x, y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(\"input\");\n\tcin >> n;\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tcin >> a[i]; \n\t\tw += a[i];\n\t}\n\tw = powm(w, Mod - 2);\n\tfor (int i = 0; i < 1 << n; i++) {\n\t\ta[i] = dec(0, mul(a[i], w));\n\t\tb[i] = 1;\n\t}\n\tc[0] = dec(0, 1 << n); \n\ta[0] = add(a[0], 1);\n\tbpf(a); \n\tbpf(b); \n\tbpf(c);\n\tfor (int i = 1; i < 1 << n; ++i) {\n\t\ta[i] = mul(add(b[i], c[i]), powm(a[i], Mod - 2));\n\t\ta[0] = dec(a[0], a[i]);\n\t}\n\tbpf(a);\n\tw = powm(1 << n, Mod - 2);\n\tfor (int i = 0; i < 1 << n; i++) {\n\t\tcout << mul(a[i], w) << '\\n';\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n    uint32_t a;\n    ModInt& s(uint32_t vv){\n        a=vv<mod?vv:vv-mod;\n        return *this;\n    }\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n    ModInt& operator+=(const ModInt &x){return s(a+x.a);}\n    ModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n    ModInt& operator*=(const ModInt &x){\n        a=uint64_t(a)*x.a%mod;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt &x){\n        *this*=x.inv();\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n    ModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n    ModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n    ModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n    bool operator==(const ModInt &x)const{return a==x.a;}\n    bool operator!=(const ModInt &x)const{return a!=x.a;}\n    bool operator<(const ModInt &x)const{return a<x.a;}\n\n    ModInt operator-()const{return ModInt()-*this;}\n    ModInt pow(int64_t n)const{\n        ModInt res(1),x(*this);\n        while(n){\n            if(n&1)res*=x;\n            x*=x;\n            n>>=1;\n        }\n        return res;\n    }\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n    return (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n    return (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\n\ntemplate<class T>\nvector<T>FWHT(vector<T>f){\n    for(int len=1;2*len<=f.size();len<<=1){\n        for(int i=0;i<f.size();i+=2*len){\n            for(int j=0;j<len;j++){\n                T u=f[i+j];\n                T v=f[i+j+len];\n                f[i+j]=u+v;\n                f[i+j+len]=u-v;\n            }\n        }\n    }\n    return f;\n}\n\nvector<mint>conv(vector<mint>A,vector<mint>B){\n    A=FWHT(A);\n    B=FWHT(B);\n    rep(i,A.size())A[i]*=B[i];\n    A=FWHT(A);\n    rep(i,A.size())A[i]/=A.size();\n    return A;\n}\n\nsigned main(){\n    int N;scanf(\"%lld\",&N);\n    vint A(1<<N);\n    rep(i,1<<N)scanf(\"%lld\",&A[i]);\n\n    int S=accumulate(all(A),0ll);\n\n    vector<mint>r(1<<N);\n    mint in=mint(S).inv();\n    rep(i,1<<N)r[i]=in*A[i];\n\n    vector<mint>t=r;\n    t[0]-=1;\n\n    vector<mint>e(1<<N);\n    e[0]=(1<<N)-1;\n    for(int i=1;i<1<<N;i++)e[i]=-1;\n\n    t=FWHT(t);\n    e=FWHT(e);\n    for(int i=1;i<1<<N;i++)e[i]/=t[i];\n    \n    //v=a+xb\n    auto a=FWHT(e);\n    rep(i,1<<N)a[i]/=1<<N;\n    \n\n\n\n    mint az;\n    rep(i,1<<N)az+=r[i]*a[i];\n\n    mint x=mint(1<<N)-1-az;\n\n    rep(i,1<<N){\n        mint tmp=a[i]+x;\n        printf(\"%lld\\n\",(int)tmp.a);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inver(a) power(a, mod - 2)\nusing namespace std; \ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x) {\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f; \n}\ntypedef long long ll;\nconst int mod = 998244353;\nconst int maxn = 1 << 18;\nint r2;\nint n, p[maxn];\nint a[maxn];\ninline int add(int x) {\n\treturn x >= mod ? x - mod : x;\n}\ninline int dec(int x) {\n\treturn x < 0 ? x + mod : x;\n}\nll power(ll x, ll y) {\n\tll re = 1;\n\twhile(y) {\n\t\tif(y & 1) re = re * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn re;\n}\nvoid FWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = add(x + y);\n\t\t\t\t*v = dec(x - y);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid IFWT(int *a, int n) {\n\tfor(int i = 1; i < n; i <<= 1) {\n\t\tfor(int j = 0, p = i << 1; j < n; j += p) {\n\t\t\tint *u = a + j;\n\t\t\tint *v = a + j + i;\n\t\t\tfor(int k = 0; k < i; ++k, ++u, ++v) {\n\t\t\t\tint x = *u;\n\t\t\t\tint y = *v;\n\t\t\t\t*u = (ll)(x + y) * r2 % mod;\n\t\t\t\t*v = (ll)(x - y) * r2 % mod; *v = dec(*v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid init() {\n\tr2 = inver(2);\n\tint sum = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tsum += p[i];\n\t}\n\tsum = inver(sum);\n\tfor(int i = 0; i < n; ++i) {\n\t\tp[i] = (ll)p[i] * sum % mod;\n\t}\n}\nvoid solve() {\n\tinit();\n\tp[0] = dec(p[0] - 1);\n\ta[0] = n - 1;\n\tfor(int i = 1; i < n; ++i) {\n\t\ta[i] = mod - 1;\n\t}\n\tFWT(a, n), FWT(p, n);\n\tfor(int i = 0; i < n; ++i) {\n\t\ta[i] = a[i] * inver(p[i]) % mod;\n\t}\n\tIFWT(a, n);\n\tll rec = a[0];\n\tFWT(a, n);\n\ta[0] = (ll)(mod - rec) * n % mod;\n\tIFWT(a, n);\n}\nint main() {\n\tread(n), n = 1 << n;\n\tfor(int i = 0; i < n; ++i) {\n\t\tread(p[i]);\n\t}\n\tsolve();\n\tfor(int i = 0; i < n; ++i) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MOD = 998244353;\nconst int INV2 = (MOD + 1) >> 1;\n\nint add(int x, int y) {return (x + y >= MOD ? x + y - MOD : x + y);}\nint sub(int x, int y) {return (x - y < 0 ? x - y + MOD : x - y);}\nint mul(int x, int y) {return 1LL*x*y%MOD;}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret,b);\n\treturn ret;\n}\n\nstruct node{\n\tint k, b;\n\tnode() : k(0), b(0) {}\n\tnode(int _k, int _b) : k(_k), b(_b) {}\n\tint get(int x) {return add(mul(k, x), b);}\n\tfriend node operator + (node a, node b) {\n\t\treturn node(add(a.k, b.k), add(a.b, b.b));\n\t}\n\tfriend node operator - (node a, node b) {\n\t\treturn node(sub(a.k, b.k), sub(a.b, b.b));\n\t}\n\tfriend node operator * (node a, int k) {\n\t\treturn node(mul(a.k, k), mul(a.b, k));\n\t}\n\tfriend node operator / (node a, int k) {\n\t\treturn a * pow_mod(k, MOD - 2);\n\t}\n};\n\nvoid fwt(node *A, int m, int type) {\n\tint n = (1 << m), f = (type == 1 ? 1 : INV2);\n\tfor(int i=1;i<=m;i++) {\n\t\tint s = (1 << i), t = (s >> 1);\n\t\tfor(int j=0;j<n;j+=s)\n\t\t\tfor(int k=0;k<t;k++) {\n\t\t\t\tnode x = A[j+k], y = A[j+k+t];\n\t\t\t\tA[j+k] = (x + y)*f, A[j+k+t] = (x - y)*f;\n\t\t\t}\n\t}\n}\n\nnode A[1<<18], B[1<<18], C[1<<18], f[1<<18];\n\nint main() {\n\tint N, M, S = 0; scanf(\"%d\", &N), M = (1 << N);\n\tfor(int i=0;i<M;i++) scanf(\"%d\", &A[i].b), S = add(S, A[i].b);\n\tS = pow_mod(S, MOD - 2);\n\tfor(int i=0;i<M;i++) A[i].b = sub(i == 0 ? 1 : 0, mul(A[i].b, S));\n\tfor(int i=0;i<M;i++) B[i].b = 1;\n\tC[0].b = MOD - 1;\n\tfwt(A, N, 1), fwt(B, N, 1), fwt(C, N, 1);\n\tint tmp = mul(B[0].b, pow_mod(C[0].b, MOD-2));\n\tfor(int i=1;i<M;i++)\n\t\tf[i] = (B[i] - C[i]*tmp) / A[i].b;\n\tf[0].k = 1; fwt(f, N, -1);\n\tint x = sub(0, mul(pow_mod(f[0].k, MOD-2), f[0].b));\n\tfor(int i=0;i<M;i++) printf(\"%d\\n\", f[i].get(x));\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=1<<18,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n;\nLL tot,p[N],f[N],_f[N];\nLL L[N],R[N],_L[N],_R[N],ans[N];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nLL getmi(LL a,LL x)\n{\n    LL rt=1;\n    while(x)\n    {\n        if(x&1) rt=rt*a%mod;\n        a=a*a%mod,x>>=1;\n    }\n    return rt;\n}\n\nvoid FWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;\n            }\n}\n\nvoid IFWT(LL a[],int n)\n{\n    for(int i=1; i<n; i<<=1)\n        for(int j=0; j<n; j+=i<<1)\n            rep(k,0,i-1)\n            {\n                LL x=a[j+k],y=a[i+j+k];\n                a[j+k]=inv2*(x+y)%mod;\n                a[i+j+k]=inv2*(x-y)%mod;\n            }\n}\n\nint main()\n{\n\tn=getint();\n\trep(i,0,(1<<n)-1) tot+=(p[i]=getint());\n\ttot=getmi(tot,mod-2);\n\trep(i,0,(1<<n)-1) p[i]=p[i]*tot%mod;\n\tFWT(p,1<<n);\n\n\trep(i,0,(1<<n)-1) L[i]=R[i]=1-p[i];\n\trep(i,1,(1<<n)-1) L[i]=L[i]*L[i-1]%mod;\n\trepd(i,(1<<n)-2,0) R[i]=R[i]*R[i+1]%mod;\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=1;\n\t\tif(i>0) x=L[i-1],_L[i]=_L[i-1]*(1-p[i])%mod;\n\t\t_L[i]=(_L[i]+x*(-p[i]))%mod;\n\t}\n\n\trepd(i,(1<<n)-1,0)\n\t{\n\t\tLL x=1;\n\t\tif(i<(1<<n)-1) x=R[i+1],_R[i]=_R[i+1]*(1-p[i])%mod;\n\t\t_R[i]=(_R[i]+x*(-p[i]))%mod;\n\t}\n\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL l=i>0?L[i-1]:1;\n\t\tLL _l=i>0?_L[i-1]:0;\n\t\tLL r=i<(1<<n)-1?R[i+1]:1;\n\t\tLL _r=i<(1<<n)-1?_R[i+1]:0;\n\t\tf[i]=l*r%mod,_f[i]=(l*_r+_l*r)%mod;\n\t}\n\t\n\tIFWT(f,1<<n),IFWT(_f,1<<n);\n\trep(i,0,(1<<n)-1)\n\t{\n\t\tLL x=(_f[i]*f[0]-f[i]*_f[0])%mod;\n\t\tLL y=getmi(f[0]*f[0]%mod,mod-2);\n\t\tans[i]=(x*y%mod+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lower_Rating*/\n/*dianfenzhi*/\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<set>\nusing namespace std;\n\n#define LL long long\n#define DB double\n#define MOD 998244353\n#define Pr pair<int,int>\n#define X first\n#define Y second\n#define MAXN (1<<18)\n#define eps 1e-10\n#define INF 2147483647\n#define mem(x,p) memset(x,p,sizeof(x))\n\nLL read(){\n  LL x=0,F=1;char c=getchar();\n  while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n  while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n  return x*F;\n}\nint add(int a,int b){return (a+b>=MOD)?a+b-MOD:a+b;}\nint dec(int a,int b){return (a-b<0)?a-b+MOD:a-b;}\nint mul(LL a,int b){return a*b%MOD;}\nint fst_pow(int a,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=mul(res,a);\n        a=mul(a,a);\n        b>>=1;\n    }return res;\n}\n\nint inv2;\nint FWT(int len,int *a,int x){\n    for(int i=1;i<len;i<<=1)\n        for(int j=0;j<len;j+=(i<<1))\n            for(int k=0;k<i;k++){\n                int X=a[j+k],Y=a[i+j+k];\n                a[j+k]=add(X,Y),a[i+j+k]=dec(X,Y);\n                if(x==-1)a[j+k]=mul(a[j+k],inv2),a[i+j+k]=mul(a[i+j+k],inv2);\n            }\n}\n\nint n,m,p[MAXN+5],f[MAXN+5],sum;\nint main(){\n    n=read(),m=1<<n,inv2=(MOD+1)>>1;\n    for(int i=0;i<m;i++)\n    p[i]=read(),sum=add(sum,p[i]);\n    sum=fst_pow(sum,MOD-2);\n    for(int i=0;i<m;i++)p[i]=mul(p[i],sum);\n    p[0]=dec(p[0],1),f[0]=m-1;\n    for(int i=1;i<m;i++)f[i]=MOD-1;\n    FWT(m,p,1),FWT(m,f,1);\n    for(int i=1;i<m;i++)f[i]=mul(f[i],fst_pow(p[i],MOD-2));\n    f[0]=0;FWT(m,f,-1);\n    for(int i=0;i<m;i++)\n    printf(\"%d\\n\",dec(f[i],f[0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define mod 998244353\n#define inv2 499122177\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint Add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t\tc -= mod;\n\treturn c;\n}\nint Sub(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t\tc += mod;\n\treturn c;\n}\nint Pow(int a, int k)\n{\n\tif (!k)\n\t\treturn 1;\n\tint p = Pow(a, k / 2);\n\tif (k & 1)\n\t\treturn (ll)p * p % mod * a % mod;\n\treturn (ll)p * p % mod;\n}\nint A[1 << 18], B[1 << 18], C[1 << 18], D[1 << 18];\nint n, s;\nvoid FWT(int *A, int w)\n{\n\tif (w == 1)\n\t\treturn;\n\tFWT(A, w >> 1);\n\tFWT(A + (w >> 1), w >> 1);\n\tfor (int i = 0; i < (w >> 1); i++)\n\t{\n\t\tint x = A[i], y = A[i + (w >> 1)];\n\t\tA[i] = Add(x, y);\n\t\tA[i + (w >> 1)] = Sub(x, y);\n\t}\n}\nvoid IFWT(int *A, int w)\n{\n\tif (w == 1)\n\t\treturn;\n\tIFWT(A, w >> 1);\n\tIFWT(A + (w >> 1), w >> 1);\n\tfor (int i = 0; i < (w >> 1); i++)\n\t{\n\t\tint x = A[i], y = A[i + (w >> 1)];\n\t\tA[i] = (ll)Add(x, y) * inv2 % mod;\n\t\tA[i + (w >> 1)] = (ll)Sub(x, y) * inv2 % mod;\n\t}\n}\nint main()\n{\n\tRead(n);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tRead(D[i]), s = Add(s, D[i]);\n\ts = Pow(s, mod - 2);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tA[i] = D[i] = (ll)D[i] * s % mod;\n\tB[0] = (1 << n) - 1;\n\tfor (int i = 1; i < (1 << n); i++)\n\t\tB[i] = mod - 1;\n\tA[0] = Sub(A[0], 1);\n\tFWT(A, 1 << n);\n\tFWT(B, 1 << n);\n\tint x = 0, p = 0;\n\tfor (int i = 0; i < (1 << n); i++)\n\t{\n\t\tif (A[i] == 0)\n\t\t\tx = i;\n\t\tC[i] = (ll)Pow(A[i], mod - 2) * B[i] % mod;\n\t}\n\tIFWT(C, 1 << n);\n\tp = (ll)Sub(0, C[0]) * (1 << n) % mod;\n\tFWT(C, 1 << n);\n\tC[x] = p;\n\tIFWT(C, 1 << n);\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tprintf(\"%d\\n\", C[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353LL\n\nll f[262144],g[262144],pre[622144],suf[262144],num[262144];\nint n;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void print(ll x)\n{\n\tstatic char s[233];\n\tif (!x) { putchar('0');putchar('\\n');return; }\n\tint tot=0;\n\tfor (;x;x/=10) s[++tot]=x%10+'0';\n\tfor (;tot;tot--) putchar(s[tot]);\n\tputchar('\\n');\n}\n\ninline ll pls(const ll &x,const ll &y) { return (x+y<mod)?x+y:x+y-mod; }\ninline ll mns(const ll &x,const ll &y) { return (x-y<0)?x-y+mod:x-y; }\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\ninline void fwt(ll *a,int n)\n{\n\tfor (int w=2;w<=n;w<<=1) for (int k=0;k<n;k+=w) for (int j=k;j<k+(w>>1);j++)\n\t{\n\t\tll u=a[j],t=a[j+(w>>1)];\n\t\ta[j]=pls(u,t);a[j+(w>>1)]=mns(u,t);\n\t}\n}\n\nint main()\n{\n\tn=rd();\n\tfor (int i=0;i<(1<<n);i++) num[i]=rd();\n\tll sum=0;\n\tfor (int i=0;i<(1<<n);i++) sum+=num[i];\n\tll Inv=ksm(sum,mod-2);\n\tfor (int i=0;i<(1<<n);i++) f[i]=num[i]*Inv%mod;\n\tfwt(f,1<<n);\n\tpre[0]=1;\n\tfor (int i=1;i<(1<<n);i++) pre[i]=pre[i-1]*mns(1,f[i])%mod;\n\tsuf[1<<n]=1;\n\tfor (int i=(1<<n)-1;i;i--) suf[i]=suf[i+1]*mns(1,f[i])%mod;\n\tfor (int i=1;i<(1<<n);i++) g[i]=mns(0,pre[i-1]*suf[i+1]%mod);\n\tfor (int i=1;i<(1<<n);i++) g[0]=mns(g[0],pre[i-1]*suf[i+1]%mod*f[i]%mod);\n\tll now=1;\n\tfor (int i=1;i<(1<<n);i++) now=now*mns(1,f[i])%mod;\n\tfwt(g,1<<n);\n\tll now1=ksm(now,mod-2);\n\tfor (int i=0;i<(1<<n);i++) print(mns(g[i],g[0])*now1%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 18, mod = 998244353, inv2 = 499122177;\nint n, a[N], b[N], len, m, s;\nvoid fwt(int * a, int op) {\n    for(int i = 1; i < len; i <<= 1) {\n        int s = i << 1;\n        for(int j = 0; j < len; j += s)\n            for(int k = 0; k < i; ++k) {\n                int x = a[j + k], y = a[i + j + k];\n                a[j + k] = (x + y) % mod; a[i + j + k] = (x - y + mod) % mod;\n                if(op == -1) a[j + k] = 1ll * a[j + k] * inv2 % mod, a[i + j + k] = 1ll * a[i + j + k] * inv2 % mod;\n            }\n    }\n}\nint qpow(int a, int b) {\n    int c = 1;\n    while(b) {\n        if(b & 1) c = 1ll * c * a % mod;\n        a = 1ll * a * a % mod;\n        b >>= 1;\n    } return c;\n}\nint main() {\n    scanf(\"%d\", &n); m = (1 << n) - 1; s = 1;\n    for(int i = 0; i <= m; ++i) scanf(\"%d\", &a[i]), s = (s + a[i]) % mod;\n    s = qpow(s, mod - 2);\n    for(int i = 0; i <= m; ++i) a[i] = 1ll * a[i] * s % mod;\n    for(int i = 1; i <= m; ++i) b[i] = -1;\n    b[0] = m; len = 1; --a[0];\n    while(len <= m) len <<= 1;\n    fwt(a, 1); fwt(b, 1);\n    for(int i = 0; i < len; ++i)\n        a[i] = 1ll * qpow(a[i], mod - 2) * b[i] % mod;\n    fwt(a, -1);\n    for(int i = 0; i <= m; ++i) printf(\"%d\\n\", (a[i] - a[0] + mod) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mod = 998244353, inv2 = 499122177;\nconst int MAXN = 20, MAXL = ( 1 << 18 ) + 5;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nint F[MAXL], p[MAXL], h[MAXL];\nint N, len;\n\nint qkpow( int base, int indx )\n{\n\tint ret = 1;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret = 1ll * ret * base % mod;\n\t\tbase = 1ll * base * base % mod, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nint inv( const int a ) { return qkpow( a, mod - 2 ); }\nint fix( const int x ) { return ( x % mod + mod ) % mod; }\n\nvoid FWT( int *f, const int mode )\n{\n\tint t1, t2;\n\tfor( int s = 2 ; s <= len ; s <<= 1 )\n\t\tfor( int i = 0, t = s >> 1 ; i < len ; i += s )\n\t\t\tfor( int j = i ; j < i + t ; j ++ )\n\t\t\t{\n\t\t\t\tt1 = f[j], t2 = f[j + t];\n\t\t\t\tif( mode > 0 ) f[j] = ( t1 + t2 ) % mod, f[j + t] = fix( t1 - t2 );\n\t\t\t\telse f[j] = 1ll * ( t1 + t2 ) * inv2 % mod, f[j + t] = 1ll * fix( t1 - t2 ) * inv2 % mod;\n\t\t\t}\n}\n\nint main()\n{\n\tint s = 0;\n\tread( N ); len = 1 << N;\n\tfor( int i = 0 ; i < len ; i ++ ) read( p[i] ), s = ( s + p[i] ) % mod;\n\ts = inv( s );\n\tfor( int i = 0 ; i < len ; i ++ ) p[i] = 1ll * p[i] * s % mod;\n\tfor( int i = 1 ; i < len ; i ++ ) h[i] = mod - 1;\n\th[0] = len - 1, p[0] = fix( p[0] - 1 );\n\tFWT( h, 1 ), FWT( p, 1 );\n\tfor( int i = 1 ; i < len ; i ++ ) F[i] = 1ll * h[i] * inv( p[i] ) % mod;\n\tFWT( F, -1 );\n\tint tmp = mod - F[0];\n\tfor( int i = 0 ; i < len ; i ++ ) write( ( tmp + F[i] ) % mod ), putchar( '\\n' );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[1<<18|5];\nconst int p=998244353;\nint fpm(int a,int b){\n\tint c=1;for(;b;b>>=1,a=a*a%p)if(b&1)c=c*a%p;\n\treturn c;\n}\nint Mod(int x){return x>=p?x-p:x;}\npii f[1<<18|5],g[1<<18|5],h[1<<18|5];\npii tp(int x){return make_pair(x,0);}\npii operator +(pii a,pii b){\n\treturn make_pair(Mod(a.x+b.x),Mod(a.y+b.y));\n}\npii operator -(pii a,pii b){\n\treturn make_pair(Mod(a.x+p-b.x),Mod(a.y+p-b.y));\n}\npii operator *(pii a,int b){\n\treturn make_pair(a.x*b%p,a.y*b%p);\n}\nvoid FWT(pii *a,int n){\n\tfor(int i=1;i<1<<n;i<<=1){\n\t\tfor(int j=0;j<1<<n;++j)if(!(j&i)){\n\t\t\tpii u=a[j],v=a[j|i];\n\t\t\ta[j]=u+v;\n\t\t\ta[j|i]=u-v;\n\t\t}\n\t}\n}\nvoid iFWT(pii *a,int n){\n\tfor(int i=1;i<1<<n;i<<=1){\n\t\tfor(int j=0;j<1<<n;++j)if(!(j&i)){\n\t\t\tpii u=a[j],v=a[j|i];\n\t\t\ta[j]=(u+v)*((p+1)>>1);\n\t\t\ta[j|i]=(u-v)*((p+1)>>1);\n\t\t}\n\t}\n}\n\n\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(n);\n\tint s=0;\n\tfor(int i=0;i<1<<n;++i){read(a[i]);s+=a[i];}\n\ts=fpm(s,p-2);\n\tfor(int i=0;i<1<<n;++i)a[i]=a[i]*s%p;\n\tfor(int i=1;i<1<<n;++i){\n\t\tg[i].x=p-1;\n\t\th[i].x=a[i];\n\t}\n\tg[0].x=(1<<n)-1;\n\th[0].x=a[0]-1;\n\tif(h[0].x<0)h[0].x+=p;\n\tFWT(g,n);\n\tFWT(h,n);\n\tfor(int i=1;i<1<<n;++i){\n\t\tf[i].x=g[i].x*fpm(h[i].x,p-2)%p;\n\t}\n\tf[0].y=1;\n\tiFWT(f,n);\n\tint w=(p-f[0].x)*fpm(f[0].y,p-2)%p;\n\t// f[0].x+f[0].y*x=0\n\twrite(0,'\\n');\n\tfor(int i=1;i<1<<n;++i){\n\t\twrite((f[i].x+f[i].y*w)%p,'\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 1 << 18, mod = 998244353;\nint n, len, sum, p[N], A[N];\ninline int kasumi(int a, int b){\n\tint res = 1;\n\twhile(b){\n\t\tif(b & 1) res = (LL) res * a % mod;\n\t\ta = (LL) a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\ninline int add(int a, int b){int c = a + b; if(c >= mod) c -= mod; return c;}\ninline int sub(int a, int b){int c = a - b; if(c < 0) c += mod; return c;}\ninline void div2(int &x){if(x & 1) x += mod; x >>= 1;}\ninline void FWT(int *A, int type){\n\tfor(Rint mid = 1;mid < len;mid <<= 1)\n\t\tfor(Rint j = 0;j < len;j += (mid << 1))\n\t\t\tfor(Rint k = 0;k < mid;k ++){\n\t\t\t\tint x = A[j + k], y = A[j + k + mid];\n\t\t\t\tA[j + k] = add(x, y); A[j + k + mid] = sub(x, y);\n\t\t\t\tif(type) div2(A[j + k]), div2(A[j + k + mid]);\n\t\t\t}\n}\nint main(){\n\tscanf(\"%d\", &n); len = 1 << n;\n\tfor(Rint i = 0;i < len;i ++) scanf(\"%d\", p + i), sum += p[i];\n\tsum = kasumi(sum, mod - 2);\n\tfor(Rint i = 0;i < len;i ++) p[i] = (LL) p[i] * sum % mod; -- p[0];\n\tA[0] = len - 1;\n\tfor(Rint i = 1;i < len;i ++) A[i] = mod - 1;\n\tFWT(A, 0); FWT(p, 0);\n\tfor(Rint i = 0;i < len;i ++)\n\t\tA[i] = (LL) A[i] * kasumi(p[i], mod - 2) % mod;\n\tFWT(A, 1);\n\tfor(Rint i = 0;i < len;i ++)\n\t\tprintf(\"%d\\n\", sub(A[i], A[0]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (530010)\n#define P (998244353)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,S,INV,Lim,p[N],q[N];\nint ksm(int a,int p){\n\tint res=1;\n\tfor(;p;p>>=1,a=1ll*a*a%P)if(p&1)res=1ll*res*a%P;\n\treturn res;\n}\nvoid FWT(int *a,int tp){\n\tfor(int i=1;i<Lim;i<<=1)\n\tfor(int R=i<<1,j=0;j<Lim;j+=R)\n\tfor(int k=j;k<j+i;k++){\n\t\tint x=a[k],y=a[k+i];\n\t\ta[k]=(x+y)%P,a[k+i]=(x-y+P)%P;\n\t}\n\tif(tp==-1)for(int i=0;i<Lim;i++)a[i]=1ll*a[i]*INV%P;\n}\nint main(){\n\tread(n),Lim=1<<n,INV=ksm(Lim,P-2);\n\tfor(int i=0;i<Lim;i++)read(p[i]),S+=p[i]; S=ksm(S,P-2);\n\tfor(int i=0;i<Lim;i++)p[i]=1ll*p[i]*S%P,q[i]=P-1;q[0]=Lim-1,p[0]--,FWT(p,1),FWT(q,1);\n\tfor(int i=1;i<Lim;i++)q[i]=1ll*q[i]*ksm(p[i],P-2)%P; FWT(q,-1);\n\tfor(int i=0;i<Lim;i++)printf(\"%d\\n\",(q[i]-q[0]+P)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nvi solve(vi a, vi b)\n{\n\tint n=a.size();\n\tif(n==1)\n\t{\n\t\tif(a[0]==0) return {0};\n\t\telse return {mult(b[0],inverse(a[0]))};\n\t}\n\tvi a1,a2,b1,b2;\n\tfor(int i=0;i<n;i+=2)\n\t{\n\t\ta1.pb(add(a[i],a[i+1]));\n\t\tb1.pb(add(b[i],b[i+1]));\n\t\ta2.pb(add(a[i],MOD-a[i+1]));\n\t\tb2.pb(add(b[i],MOD-b[i+1]));\n\t}\n\tvi c1 = solve(a1,b1);\n\tvi c2 = solve(a2,b2);\n\tvi x(n);\n\tfor(int i=0;i<n/2;i++)\n\t{\n\t\tx[i*2]=add(c1[i],c2[i]);\n\t\tx[i*2+1]=add(c1[i],MOD-c2[i]);\n\t\tx[i*2]=mult(x[i*2],inv[2]);\n\t\tx[i*2+1]=mult(x[i*2+1],inv[2]);\n\t}\n\treturn x;\n}\n\t\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tint N = (1<<n);\n\tinit(355555);\n\tvi a(N); int s=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>a[i];s+=a[i];\n\t}\n\tint iS=inverse(s);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ta[i]=mult(a[i],iS);\n\t}\n\ta[0]=add(a[0],MOD-1);\n\tvi nw;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==0) nw.pb(N-1);\n\t\telse nw.pb(MOD-1);\n\t}\n\tvi c = solve(a,nw);\n\tint ss = c[0];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tc[i]=add(c[i],MOD-ss);\n\t\tcout<<c[i]<<'\\n';\n\t}\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=998244353,inv2=(p+1)/2;\nint qpow(int a,int k){\n\tint ans=1;\n\twhile(k){\n\t\tif(k&1) ans=1LL*ans*a%p;\n\t\ta=1LL*a*a%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\n\nint FWT_xor(int d[],int n0,int flg){\n\tfor(int i=1;i<(1<<n0);i<<=1)\n\tfor(int j=0;j<(1<<n0);j+=(i<<1))\n\tfor(int k=0;k<i;k++){\n\t\tint a0=d[j|k],a1=d[i|j|k];\n\t\td[j|k]=(a0+a1)%p,d[i|j|k]=(a0-a1+p)%p;\n\t\tif(flg==-1) d[j|k]=1LL*d[j|k]*inv2%p,d[i|j|k]=1LL*d[i|j|k]*inv2%p;\n\t}\n}\nint F[1<<18],Q[1<<18],P[1<<18],SP;\n\nint N;\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<(1<<N);i++) scanf(\"%d\",&P[i]),SP=(SP+P[i])%p;\n\tSP=qpow(SP,p-2);\n\tfor(int i=0;i<(1<<N);i++) P[i]=1LL*P[i]*SP%p;\n\tP[0]=(P[0]-1+p)%p;\n\tQ[0]=(1<<N)-1;\n\tfor(int i=1;i<(1<<N);i++) Q[i]=p-1;\n\tFWT_xor(P,N,1);FWT_xor(Q,N,1);\n\tfor(int i=1;i<(1<<N);i++) F[i]=1LL*Q[i]*qpow(P[i],p-2)%p;\n\tFWT_xor(F,N,-1);\n\tint ans=p-F[0];\n\tfor(int i=0;i<(1<<N);i++) printf(\"%d\\n\",(ans+F[i])%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1<<18;\nconst int mod = 998244353;\nint x[maxn],p[maxn],b[maxn];\nconst int inv2 = mod/2+1;\nint add(int a,int b)\n{\n    a+=b;\n    if(a>=mod)  return a-mod;\n    return a;\n}\nint sub(int a,int b)\n{\n    a-=b;\n    if(a<0) return a+mod;\n    return a;\n}\nint mul(int a,int b)\n{\n    long long t=1ll*a*b;\n    return t-t/mod*mod;\n}\nint qp(int a,int b)\n{\n    int ans=1;\n    while(b)\n    {\n        if(b&1) ans=mul(ans,a);\n        a=mul(a,a);\n        b>>=1;\n    }\n    return ans;\n}\nint inv(int a)\n{\n    return qp(a,mod-2);\n}\nvoid fwt(int x[],int n,int opt=1)\n{\n    for(int i=1;i<n;i<<=1)\n        for(int p=i<<1,j=0;j<n;j+=p)\n            for(int k=0,a,b;k<i;++k)\n            {\n                a=x[j+k],b=x[i+j+k];\n                x[j+k]=add(a,b);    if(opt==-1) x[j+k]=mul(x[j+k],inv2);\n                x[j+k+i]=sub(a,b);  if(opt==-1) x[j+k+i]=mul(x[j+k+i],inv2);\n            }\n}\nint main()\n{\n    int n;\n    int s=0;\n    ios::sync_with_stdio(false);\n    cin>>n; n=1<<n;\n    for(int i=0;i<n;++i)\n        cin>>p[i];\n    for(int i=0;i<n;++i)\n        s+=p[i];\n    s=inv(s);\n    for(int i=0;i<n;++i)\n        p[i]=mul(p[i],s);\n    p[0]=sub(p[0],1);\n    for(int i=1;i<n;++i)\n        b[i]=sub(0,1);\n    b[0]=sub(n,1);\n    fwt(p,n);\n    fwt(b,n);\n    x[0]=s;\n    for(int i=1;i<n;++i)\n        x[i]=mul(b[i],inv(p[i]));\n    fwt(x,n,-1);\n    for(int i=n-1;i>=0;--i)\n        x[i]=sub(x[i],x[0]);\n    for(int i=0;i<n;++i)\n        cout<<x[i]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst ll mod = 998244353;\n\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll rev2 = (mod+1)/2;\nvoid FWT(ll *a,int n){\n    for (int d = 1 ; d < n ; d <<= 1){\n        for (int m = d << 1 ,i = 0;i < n ; i+=m){\n            for (int j = 0 ; j < d ; j++){\n                int x = a[i+j],y = a[i+j+d];\n                //xor;\n                a[i+j] = (x+y) % mod,a[i+j+d] = (x-y+mod)%mod;\n            }\n        }\n    }\n}\nvoid UFWT(ll *a,int n){\n    for (int d = 1 ; d < n ; d<<=1){\n        for (int m = d <<1, i = 0; i < n; i+=m){\n            for (int j = 0 ; j < d ; j++){\n                int x = a[i+j],y = a[i+j+d];\n                //xor\n                a[i+j] = 1LL*(x+y)*rev2%mod,a[i+j+d] = (1LL*(x-y)*rev2%mod + mod) % mod;\n            }\n        }\n    }\n}\nint n;\nll p[(1<<18)];\nll v[(1<<18)];\nll hadamard_ans[(1<<18)];\nint main(){\n\tscanf(\"%d\",&n); n = (1<<n);\n\tll sum = 0;\n\trep(i,n){\n\t\tscanf(\"%lld\",&p[i]);\n\t\tsum += p[i];\n\t}\n\tll rev = modpow(sum,mod-2);\n\trep(i,n){\n\t\tp[i] = p[i] * rev % mod;\n\t\tif(i == 0) p[i] --;\n\t}\n\t\n\t//2^N-1, -1 ... -1\n\tmemset(v,-1,sizeof(v));\n\tv[0] = n-1;\n\t\n\tFWT(p,n);\n\tFWT(v,n);\n\tll hoge = 0;\n\trep(i,n){\n\t\thadamard_ans[i] = v[i] * modpow(p[i],mod-2)%mod;\n\t\thoge -= hadamard_ans[i];\n\t\t//cout << i << \" \" << hadamard_ans[i] << endl;\n\t}\n\thadamard_ans[0] = (hoge%mod+mod)%mod;\n\tUFWT(hadamard_ans,n);\n\trep(i,n){\n\t\tprintf(\"%lld\\n\", (hadamard_ans[i]%mod+mod)%mod );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ninline int power(int a, int b) {\n    long long res = a, ans = 1;\n    for (; b; b >>= 1, res = res * res % mod) if (b & 1) ans = ans * res % mod;\n    return ans;\n}\nvoid fwt(int *a, int n, int type) {\n    for (int p = 0; p < n; p++) {\n        for (int i = 0; i < 1 << n; i++) {\n            if ((i >> p) & 1) {\n                int x = a[i ^ (1 << p)], y = a[i];\n                a[i ^ (1 << p)] = (x + y) % mod;\n                a[i] = (x - y + mod) % mod;\n            }\n        }\n    }\n    if (type == -1) {\n        int inv = power(1 << n, mod - 2);\n        for (int i = 0; i < 1 << n; i++) a[i] = 1ll * a[i] * inv % mod;\n    }\n}\nint n, p[1 << 18], sum, a[1 << 18], b[1 << 18];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < 1 << n; i++) {\n        scanf(\"%d\", p + i);\n        sum += p[i];\n    }\n    sum = power(sum, mod - 2);\n    for (int i = 0; i < 1 << n; i++) {\n        p[i] = 1ll * p[i] * sum % mod;\n    }\n    p[0]--;\n    for (int i = 1; i < 1 << n; i++) a[i] = mod - 1;\n    a[0] = (1 << n) - 1;\n    fwt(a, n, 1);\n    fwt(p, n, 1);\n    for (int i = 1; i < 1 << n; i++) b[i] = 1ll * a[i] * power(p[i], mod - 2) % mod;\n    fwt(b, n, -1);\n    for (int i = 1 << n; i --> 0; ) b[i] = (b[i] + mod - b[0]) % mod;\n    for (int i = 0; i < 1 << n; i++) printf(\"%d\\n\", b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=300005,P=998244353,iv2=499122177;\n#define ll long long\nint n,m,s,a[N],b[N],p[N];\ninline ll pw(ll a,ll b){ll r=1;for(;b;b>>=1,a=a*a%P)if(b&1)r=r*a%P;return r;}\ninline void fwt(int *a){for(int i=1;i<m;i<<=1)for(int j=0;j<m;j++)if(j&i){int u=a[j^i],v=a[j];a[j^i]=(u+v)%P;a[j]=(u-v+P)%P;}}\ninline void ifwt(int *a){for(int i=1;i<m;i<<=1)for(int j=0;j<m;j++)if(j&i){int u=a[j^i],v=a[j];a[j^i]=1ll*iv2*(u+v)%P;a[j]=1ll*iv2*(u-v+P)%P;}}\nint main()\n{\n\tscanf(\"%d\",&n);m=1<<n;\n\tfor(int i=0;i<m;i++)scanf(\"%d\",&p[i]),s=(s+p[i])%P;\n\ta[0]=m-1;for(int i=1;i<m;i++)a[i]=P-1;\n\ts=pw(s,P-2);for(int i=0;i<m;i++)b[i]=1ll*p[i]*s%P;b[0]=(b[0]-1+P)%P;\n\tfwt(a);fwt(b);a[0]=0;\n\tfor(int i=1;i<m;i++)a[i]=1ll*a[i]*pw(b[i],P-2)%P;\n\tifwt(a);int t=1ll*(P-a[0])*m%P;fwt(a);a[0]=t;ifwt(a);\n\tfor(int i=0;i<m;i++)printf(\"%d\\n\",a[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define N 400102\nconst int p=998244353,iv=499122177;\nint n,ps[N],m,a[N];\ninline int ksm(int d,int k){int ret=1;while(k){if(k&1)ret=1ll*ret*d%p;d=1ll*d*d%p;k>>=1;}return ret;}\ninline void fwt(int x[],int len,int mde)\n{\n    for(int i=2;i<=len;i<<=1)for(int j=0,stp=i>>1;j<len;j+=i)for(int k=j;k<j+stp;k++)\n    {\n        int t1=x[k],t2=x[k+stp];x[k]=(t1+t2)%p,x[k+stp]=(t1-t2+p)%p;\n        if(mde<0)x[k]=1ll*x[k]*iv%p,x[k+stp]=1ll*x[k+stp]*iv%p;\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);m=(1<<n);int sum=0;\n    for(int i=0;i<m;i++)scanf(\"%d\",&ps[i]),sum=(sum+ps[i])%p;sum=ksm(sum,p-2)%p;\n    for(int i=0;i<m;i++)ps[i]=1ll*ps[i]*sum%p;\n    a[0]=m-1;for(int i=1;i<m;i++)a[i]=p-1;\n    ps[0]=(ps[0]+p-1)%p;\n    fwt(a,m,1);fwt(ps,m,1);\n    for(int i=0;i<m;i++)a[i]=1ll*a[i]*ksm(ps[i],p-2)%p;\n    a[0]=0;\n    fwt(a,m,-1);\n    for(int i=1;i<m;i++)a[i]=(a[i]-a[0]+p)%p;\n    a[0]=0;\n    for(int i=0;i<m;i++)printf(\"%d\\n\",a[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=18,M=998244353;\nusing namespace std;\nint n,l,a[1<<N],b[1<<N],t0,t1,sum;\ninline int inv(int x){\n\tint y=1,t=M-2;\n\tfor(;t;t>>=1)\n\tt&1?y=1ll*y*x%M:0,x=1ll*x*x%M;\n\treturn y;\n}\ninline void fwt(int*c,int t){\n\tfor(int i=1;i<l;i<<=1)\n\tfor(int j=0;j<l;j++)\n\tif(j&i)\n\tt0=(c[j^i]+c[j])%M,t1=(c[j^i]-c[j])%M,\n\tc[j]=t1*1ll*t%M,c[j^i]=t0*1ll*t%M;\n}\nint main(){\n\tscanf(\"%d\",&n),b[0]=l=1<<n;\n\tfor(int i=0;i<l;i++)\n\tscanf(\"%d\",a+i),sum=(sum+a[i])%M,b[i]--;\n\tsum=inv(sum);\n\tfor(int i=0;i<l;i++)\n\ta[i]=1ll*a[i]*sum%M;\n\ta[0]--;/*\n\tfor(int i=0;i<l;i++)\n\tcerr<<a[i]<<' ';cerr<<endl;*/\n\tfwt(a,1),fwt(b,1);/*\n\tfor(int i=0;i<l;i++)\n\tcerr<<a[i]<<' ';cerr<<endl;\n\tfor(int i=0;i<l;i++)\n\tcerr<<b[i]<<' ';cerr<<endl;*/\n\tfor(int i=1;i<l;i++)\n\ta[i]=b[i]=1ll*b[i]*inv(a[i])%M;\n\tfwt(a,M+1>>1);\n\tb[0]=-a[0]*1ll*l%M;\n\tfwt(b,M+1>>1);\n\tfor(int i=0;i<l;i++)\n\tprintf(\"%d\\n\",(b[i]+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 270001\n#define mod 998244353\nint a[N],b[N],n,su;\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint fwt(int *a,int n,int f)\n{\n\tfor(int l=2;l<=n;l<<=1)\n\tfor(int j=0;j<n;j+=l)\n\tfor(int k=j;k<j+(l>>1);k++)\n\tif(f)\n\t{\n\t\tint t1=a[k],t2=a[k+(l>>1)];\n\t\ta[k]=(t1+t2)%mod;\n\t\ta[k+(l>>1)]=(t1-t2+mod)%mod;\n\t}\n\telse\n\t{\n\t\tint t1=a[k],t2=a[k+(l>>1)];\n\t\ta[k]=1ll*(t1+t2)*(mod+1)/2%mod;\n\t\ta[k+(l>>1)]=1ll*(t1-t2+mod)*(mod+1)/2%mod;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<1<<n;i++)scanf(\"%d\",&a[i]),su+=a[i];\n\tfor(int i=0;i<1<<n;i++)a[i]=1ll*a[i]*pw(su,mod-2)%mod-(i==0),b[i]=i==0?(1<<n)-1:mod-1;\n\tfwt(a,1<<n,1);fwt(b,1<<n,1);\n\tfor(int i=0;i<1<<n;i++)a[i]=1ll*b[i]*pw(a[i],mod-2)%mod;\n\tfwt(a,1<<n,0);\n\tint tp=a[0];\n\tfwt(a,1<<n,1);\n\ta[0]=(a[0]+mod-1ll*tp*(1<<n)%mod)%mod;\n\tfwt(a,1<<n,0);\n\tfor(int i=0;i<1<<n;i++)printf(\"%d\\n\",a[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\nconst int inv2=qpow(2,mod-2);\n/* math */\nint n,s;\ninline void FWT(int *t,int n,int type){//xor\n\tfor(int step=1;step<n;step<<=1)\n\t\tfor(int i=0;i<n;i+=step<<1)\n\t\t\tfor(int j=0;j<step;j++){\n\t\t\t\tint x=t[i+j],y=t[i+j+step];\n\t\t\t\tt[i+j]=add(x,y),t[i+j+step]=sub(x,y);\n\t\t\t\tif(type==-1)t[i+j]=mul(t[i+j],inv2),t[i+j+step]=mul(t[i+j+step],inv2);\n\t\t\t}\n}\nconst int N=1<<18;\nint p[N],a[N];\n\nint main()\n{\n\tcin >> n;\n\tfor(int i=0;i<1<<n;i++)scanf(\"%d\",&p[i]),s=add(s,p[i]);\n\ts=qpow(s,mod-2);for(int i=0;i<1<<n;i++)p[i]=mul(p[i],s);\n\tfor(int i=1;i<1<<n;i++)a[i]=mod-1;a[0]=(1<<n)-1;\n\tp[0]=sub(p[0],1);\n\tFWT(a,1<<n,1),FWT(p,1<<n,1);\n\tfor(int i=0;i<1<<n;i++)a[i]=mul(a[i],qpow(p[i],mod-2));\n\tFWT(a,1<<n,-1);\n\tfor(int i=0;i<1<<n;i++){\n\t\tprintf(\"%d\\n\",sub(a[i],a[0]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nconst int N=200005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nlong long qpow(long long a,long long b)\n{\n\tlong long ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*a%M;\n\t\ta=a*a%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid FWT(long long *a,int n,int f)\n{\n\tint i,j;\n\tint T=(1<<n);\n\tfor(i=0;i<n;++i)\n\t\tfor(j=0;j<T;++j)\n\t\t\tif((j>>i)&1)\n\t\t\t{\n\t\t\t\tlong long u=a[j^(1<<i)],v=a[j];\n\t\t\t\ta[j^(1<<i)]=u+v;\n\t\t\t\ta[j]=u-v;\n\t\t\t}\n\tfor(i=0;i<T;++i)\n\t\ta[i]%=M;\n\tif(f==-1)\n\t{\n\t\tlong long inv=qpow(T,M-2);\n\t\tfor(i=0;i<T;++i)\n\t\t\ta[i]=a[i]*inv%M;\n\t}\n}\nlong long a[E],b[E],s;\nint n,i,T;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tT=1<<n;\n\tfor(i=0;i<T;++i)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\ts+=a[i];\n\t}\n\ts=qpow(s,M-2);\n\tfor(i=0;i<T;++i)\n\t\ta[i]=a[i]*s%M;\n\t--a[0];\n\tb[0]=qpow(2,n)-1;\n\tfor(i=1;i<T;++i)\n\t\tb[i]=-1;\n\tFWT(a,n,1);\n\tFWT(b,n,1);\n\tfor(i=0;i<T;++i)\n\t\ta[i]=qpow(a[i],M-2)*b[i]%M;\n\tFWT(a,n,-1);\n\tfor(i=0;i<T;++i)\n\t\tprintf(\"%lld\\n\",((a[i]-a[0])%M+M)%M);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int mod = 998244353;\nint n, len, sp;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint ksm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = x * x % mod)\n\t\tif(y & 1) res = res * x % mod;\n\treturn res;\n}\nstruct Poly\n{\n\tint x[300005];\n\tint & operator[] (int p) {return x[p];}\n\tvoid fwt(int len)\n\t{\n\t\tfor(int l = 2; l <= len; l <<= 1)\n\t\t\tfor(int i = 0, m = l >> 1; i < len; i += l)\n\t\t\t\tfor(int j = i, t; j < i + m; j ++)\n\t\t\t\t\tt = x[j + m], x[j + m] = (x[j] - t + mod) % mod, x[j] = (x[j] + t) % mod;\n\t}\n\tvoid ifwt(int len)\n\t{\n\t\tfwt(len); int ny = ksm(len, mod - 2);\n\t\tfor(int i = 0; i < len; i ++) x[i] = x[i] * ny % mod;\n\t}\n}E, P, S;\nsigned main()\n{\n\tn = read(); len = (1 << n);\n\tfor(int i = 0; i < len; i ++) sp += (P[i] = read());\n\tsp = ksm(sp, mod - 2);\n\tfor(int i = 0; i < len; i ++) P[i] = P[i] * sp % mod;\n\t(-- P[0]) < 0 ? P[0] += mod : 0, S[0] = len - 1;\n\tfor(int i = 1; i < len; i ++) S[i] = mod - 1;\n\tP.fwt(len); S.fwt(len);\n\tfor(int i = 1; i < len; i ++) E[i] = S[i] * ksm(P[i], mod - 2) % mod;\n\tE.ifwt(len); int x = mod - E[0];\n\tfor(int i = 0; i < len; i ++) printf(\"%lld\\n\", (x + E[i]) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1 << 18;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\n\nint a[N];\nint b[N];\n\nvoid fft(int n,int *f)  {\n    for(int k = 1 ; k < n ; k <<= 1)\n    for(int i = 0 ; i < n ; i += 2 * k)\n    for(int j = 0 ; j < k ; ++j)    {\n        int x = f[i + j];\n        int y = f[i + j + k];\n\n        f[i + j]     = (x + y) % mod;\n        f[i + j + k] = (x - y + mod) % mod;\n    }\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int S = 0;\n\n    n = (1 << n);\n\n    for(int i = 0 ; i < n ; ++i)    {\n        cin >> a[i];\n        S +=   a[i];\n    }\n    for(int i = 0 ; i < n ; ++i)\n        a[i] = mul(a[i],inv(S,mod));\n\n    a[0]--;\n    b[0] = n;\n\n    for(int i = 0 ; i < n ; ++i)\n        sub(b[i],1);\n\n    fft(n,a);\n    fft(n,b);\n\n    for(int i = 0 ; i < n ; ++i)    {\n        a[i] = mul(b[i],Pow(a[i],mod - 2));\n        a[i] = mul(a[i],Pow(n,mod - 2));\n    }\n    S = 0;\n\n    for(int i = 0 ; i < n ; ++i)\n        sub(S,a[i]);\n\n    a[0] = S;\n\n    fft(n,a);\n\n    for(int i = 0 ; i < n ; ++i)\n        cout << a[i] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\nbool B(int x,int i){return (x>>i)&1;}\n\nV<mint> hadamard(V<mint> a){\n\tint n = 0;\n\twhile((1<<n) < (int)a.size()) n++;\n\tassert((1<<n) == (int)a.size());\n\trep(i,n){\n\t\trep(x,1<<n) if(!B(x,i)){\n\t\t\tint y = x | (1<<i);\n\t\t\tmint s = a[x] + a[y], t = a[x] - a[y];\n\t\t\ta[x] = s, a[y] = t;\n\t\t}\n\t}\n\treturn a;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N;\n\tcin >> N;\n\tV<mint> a(1<<N);\n\trep(i,1<<N) cin >> a[i];\n\t{\n\t\tmint S = 0;\n\t\trep(i,1<<N) S += a[i];\n\t\trep(i,1<<N) a[i] /= S;\n\t\ta[0] -= 1;\n\t}\n\tV<mint> b = hadamard(a);\n\trep(i,1<<N) b[i] = b[i].inv();\n\t{\n\t\tmint S = 0;\n\t\trep(i,1<<N) if(i) S += b[i];\n\t\tb[0] = -S;\n\t}\n\tV<mint> c = hadamard(b);\n\trep(i,1<<N) cout << c[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N (1<<19)\n\nconst LL mod=998244353;\nLL n,nn,sum,isum,a[N],ans;\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nLL inv(LL x){\n\treturn x==1?1:(mod-mod/x)*inv(mod%x)%mod;\n}\n\nvoid fwt(LL f[],LL n){\n\tfor (LL i=0;i<n;++i){\n\t\tLL t=1<<i;\n\t\tfor (LL j=0;j<1<<n;j+=t<<1){\n\t\t\tLL *f1=f+j,*f2=f+j+t;\n\t\t\tfor (LL k=0;k<t;++k){\n\t\t\t\tLL x=(f1[k]+f2[k])%mod,y=(f1[k]-f2[k]+mod)%mod;\n\t\t\t\tf1[k]=x; f2[k]=y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=0;i<1<<n;++i){\n\t\tscanf(\"%lld\",a+i);\n\t\tupd(sum,a[i]);\n\t}\n\tisum=inv(sum);\n\tfor (LL i=0;i<1<<n;++i) a[i]=a[i]*isum%mod;\n\tfwt(a,n);\n\ta[0]=0; for (LL i=1;i<1<<n;++i) a[i]=inv((1-a[i]+mod)%mod);\n\tfwt(a,n); nn=inv(1<<n);\n\tfor (LL i=0;i<1<<n;++i){\n\t\tans=(a[0]-a[i]+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N (1<<19)\n\nconst LL mod=998244353;\nLL n,sum,isum,a[N],ans;\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nLL inv(LL x){\n\treturn x==1?1:(mod-mod/x)*inv(mod%x)%mod;\n}\n\nvoid fwt(LL f[],LL n){\n\tfor (LL i=0;i<n;++i){\n\t\tLL t=1<<i;\n\t\tfor (LL j=0;j<1<<n;j+=t<<1){\n\t\t\tLL *f1=f+j,*f2=f+j+t;\n\t\t\tfor (LL k=0;k<t;++k){\n\t\t\t\tLL x=(f1[k]+f2[k])%mod,y=(f1[k]-f2[k]+mod)%mod;\n\t\t\t\tf1[k]=x; f2[k]=y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor (LL i=0;i<1<<n;++i){\n\t\tscanf(\"%lld\",a+i);\n\t\tupd(sum,a[i]);\n\t}\n\tisum=inv(sum);\n\tfor (LL i=0;i<1<<n;++i) a[i]=a[i]*isum%mod;\n\tfwt(a,n);\n\ta[0]=0; for (LL i=1;i<1<<n;++i) a[i]=inv((1-a[i]+mod)%mod);\n\tfwt(a,n);\n\tfor (LL i=0;i<1<<n;++i){\n\t\tans=(a[0]-a[i]+mod)%mod;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : F.cpp\n * Author  : Kazune Takahashi\n * Created : 1/15/2020, 2:31:58 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing namespace std;\nusing ll = long long;\n// ----- constexpr for Mint and Combination -----\n// constexpr ll MOD{1000000007LL};\nconstexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> const &V)\n{\n  os << \"{\";\n  for (auto const &v : V)\n  {\n    os << \"{\";\n    for (auto x : v)\n    {\n      os << x << \", \";\n    }\n    os << \"}, \";\n  }\n  return os << \"}\";\n}\n\nvector<vector<mint>> next_line(vector<vector<mint>> const &V)\n{\n  vector<vector<mint>> W;\n  for (auto const &v : V)\n  {\n    vector<mint> v0, v1;\n    for (auto i = 0; i + 1 < static_cast<int>(v.size()); i += 2)\n    {\n      v0.push_back(v[i] + v[i + 1]);\n      v1.push_back(v[i] - v[i + 1]);\n    }\n    W.push_back(v0);\n    W.push_back(v1);\n  }\n  return W;\n}\n\nvector<vector<mint>> divide(vector<vector<mint>> const &B, vector<vector<mint>> const &C)\n{\n  assert(B.size() == C.size());\n  vector<vector<mint>> W(B.size(), vector<mint>(1));\n  for (auto i = 0; i < static_cast<int>(B.size()); i++)\n  {\n    assert(B[i].size() == 1);\n    assert(C[i].size() == 1);\n    if (B[i][0] == 0)\n    {\n      assert(C[i][0] == 0);\n      W[i][0] = 0;\n    }\n    else\n    {\n      W[i][0] = C[i][0] / B[i][0];\n    }\n  }\n  return W;\n}\n\nvector<vector<mint>> prev_line(vector<vector<mint>> const &V)\n{\n  vector<vector<mint>> W;\n  for (auto i = 0; i + 1 < static_cast<int>(V.size()); i += 2)\n  {\n    vector<mint> w;\n    assert(V[i].size() == V[i + 1].size());\n    for (auto j = 0; j < static_cast<int>(V[i].size()); j++)\n    {\n      w.push_back((V[i][j] + V[i + 1][j]) / 2);\n      w.push_back((V[i][j] - V[i + 1][j]) / 2);\n    }\n    W.push_back(w);\n  }\n  return W;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  int B{1};\n  for (auto i = 0; i < N; i++)\n  {\n    B *= 2;\n  }\n  vector<mint> A(B);\n  for (auto i = 0; i < B; i++)\n  {\n    cin >> A[i];\n  }\n  mint S{accumulate(A.begin(), A.end(), mint{0})};\n  vector<mint> P(B);\n  for (auto i = 0; i < B; i++)\n  {\n    P[i] = A[i] / S;\n  }\n  vector<mint> X(B, -1);\n  X[0] = B - 1;\n  vector<vector<vector<mint>>> a(N + 1), b(N + 1), c(N + 1);\n  b[0].push_back(P);\n  b[0][0][0] -= 1;\n  c[0].push_back(X);\n#if DEBUG == 1\n  cerr << \"b[\" << 0 << \"] = \" << b[0] << endl;\n#endif\n  for (auto k = 0; k < N; k++)\n  {\n    b[k + 1] = next_line(b[k]);\n#if DEBUG == 1\n    cerr << \"b[\" << k + 1 << \"] = \" << b[k + 1] << endl;\n#endif\n  }\n#if DEBUG == 1\n  cerr << \"c[\" << 0 << \"] = \" << c[0] << endl;\n#endif\n  for (auto k = 0; k < N; k++)\n  {\n    c[k + 1] = next_line(c[k]);\n#if DEBUG == 1\n    cerr << \"c[\" << k + 1 << \"] = \" << c[k + 1] << endl;\n#endif\n  }\n  a[0] = divide(b[N], c[N]);\n#if DEBUG == 1\n  cerr << \"a[\" << 0 << \"] = \" << a[0] << endl;\n#endif\n  for (auto k = 0; k < N; k++)\n  {\n    a[k + 1] = prev_line(a[k]);\n#if DEBUG == 1\n    cerr << \"a[\" << k + 1 << \"] = \" << a[k + 1] << endl;\n#endif\n  }\n  auto &v{a[N][0]};\n  auto C{v[0]};\n  for (auto &x : v)\n  {\n    x -= C;\n  }\n  for (auto x : v)\n  {\n    cout << x << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 998244353;\nint n, A[1 << 18], f[1 << 18], g[1 << 18];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nvoid fwt(int *A) {\n\tfor (int d = 1; d < 1 << n; d <<= 1)\n\t\tfor (int i = 0; i < 1 << n; i += d << 1)\n\t\t\tfor (int j = 0; j < d; ++j) {\n\t\t\t\tint a = A[i + j], b = A[i + d + j];\n\t\t\t\tA[i + j] = (a + b) % P;\n\t\t\t\tA[i + d + j] = (a + P - b) % P;\n\t\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tscanf(\"%d\", A + i), sum += A[i];\n\tsum = power(sum, P - 2);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tA[i] = 1ll * A[i] * sum % P;\n\tfwt(A);\n\tA[0] = 0;\n\tfor (int i = 1; i < 1 << n; ++i)\n\t\tA[i] = power(A[i] + P - 1, P - 2);\n\tfwt(A);\n\tfor (int i = 0; i < 1 << n; ++i)\n\t\tprintf(\"%d\\n\", (A[i] + P - A[0]) % P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\nconst int N=1<<18,P=998244353;\nint n,m;\ninline uint norm(uint x){return x<P?x:x-P;}\nstruct Z{\n    uint x;\n    Z(uint _x=0):x(_x){}\n}a[N],c,sum;\ninline Z operator +(const Z a,const Z b){return norm(a.x+b.x);}\ninline Z operator -(const Z a,const Z b){return norm(a.x+P-b.x);}\ninline Z operator *(const Z a,const Z b){return static_cast<uint64>(a.x)*b.x%P;}\ninline Z operator -(const Z a){return norm(P-a.x);}\ninline Z operator +=(Z &a,const Z b){return a=a+b;}\ninline Z operator -=(Z &a,const Z b){return a=a-b;}\ninline Z operator *=(Z &a,const Z b){return a=a*b;}\ninline Z ksm(Z a,int b){\n    Z ans(1);\n    for(;b;b>>=1,a=a*a) if(b&1) ans*=a;\n    return ans;\n}\ninline Z inv(Z a){return ksm(a,P-2);}\nvoid fwt(Z *a,int k){\n    for(int mid=1;mid<m;mid<<=1)\n        for(int R=mid<<1,j=0;j<m;j+=R){\n            Z *l=a+j,*r=a+j+mid,x;\n            for(int k=0;k<mid;++k,++l,++r)\n                x=*r,*r=*l-x,*l+=x;\n        }\n    if(k==-1){\n        Z iv=inv(m);\n        rep(i,0,m-1) a[i]*=iv;\n    }\n}\nint main(){\n    scanf(\"%d\",&n);m=1<<n;\n    rep(i,0,m-1) scanf(\"%d\",&a[i].x),sum+=a[i];\n    Z iv=inv(sum);a[0]=(sum-a[0])*iv;\n    rep(i,1,m-1) a[i]*=-iv;fwt(a,1);c=Z(P-m);\n    rep(i,1,m-1) a[i]=inv(a[i])*c,a[0]-=a[i];\n    fwt(a,-1);\n    rep(i,0,m-1) printf(\"%d\\n\",a[i].x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 19\n#define M (1<<N)\n#define ll long long\n#define mod 998244353\nint n,m;\nll ksm(ll a,ll b=mod-2)\n{\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tll q=ksm(a,b>>1);\n\tif(b&1) return q*q%mod*a%mod;\n\treturn q*q%mod;\n}\nll inv2=499122177;\nvoid fwt(ll f[],int opt)\n{\n\tfor(int l=1;l<m;l<<=1)\n\t\tfor(int j=0;j<M;j+=l<<1)\n\t\t\tfor(int i=0;i<l;i++)\n\t\t\t{\n\t\t\t\tll v=f[i+j+l];\n\t\t\t\tf[i+j+l]=(f[i+j]-v+mod)%mod;\n\t\t\t\tf[i+j]=(f[i+j]+v)%mod;\n\t\t\t\tif(opt==-1)\n\t\t\t\t{\n\t\t\t\t\tf[i+j]=f[i+j]*inv2%mod;\n\t\t\t\t\tf[i+j+l]=f[i+j+l]*inv2%mod;\n\t\t\t\t}\n\t\t\t}\n}\nll num[M];\nll f[M+10],g[M+10];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tm=1<<n;\n\tll sum=0;\n\tfor(int i=0;i<m;i++) scanf(\"%lld\",&num[i]),sum=(sum+num[i])%mod;\n\tsum=ksm(sum);\n\tf[0]=m-1;\n\tfor(int i=1;i<m;i++) f[i]=mod-1;\n\tfor(int i=0;i<m;i++) g[i]=num[i]*sum%mod;\n\tg[0]=(g[0]-1+mod)%mod;\n\tfwt(f,1);\n\tfwt(g,1);\n\tint id=0;\n\tfor(int i=0;i<m;i++)\n\tif(g[i]) f[i]=f[i]*ksm(g[i])%mod;\n\telse f[i]=0,id=i;\n\tfwt(f,-1);\n\tll v=f[0];\n\tfwt(f,1);\n\tf[id]=(mod-v)*m%mod;\n\tfwt(f,-1);\n\tfor(int i=0;i<m;i++) printf(\"%lld\\n\",f[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=998244353,inv2=(p+1)/2;\nint qpow(int a,int k){\n\tint ans=1;\n\twhile(k){\n\t\tif(k&1) ans=1LL*ans*a%p;\n\t\ta=1LL*a*a%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\n\nvoid FWT_xor(int d[],int n0,int flg){\n\tfor(int i=1;i<(1<<n0);i<<=1)\n\tfor(int j=0;j<(1<<n0);j+=(i<<1))\n\tfor(int k=0;k<i;k++){\n\t\tint a0=d[j|k],a1=d[i|j|k];\n\t\td[j|k]=(a0+a1)%p,d[i|j|k]=(a0-a1+p)%p;\n\t\tif(flg==-1) d[j|k]=1LL*d[j|k]*inv2%p,d[i|j|k]=1LL*d[i|j|k]*inv2%p;\n\t}\n}\nint F[1<<18],Q[1<<18],P[1<<18],SP;\n\nint N;\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<(1<<N);i++) scanf(\"%d\",&P[i]),SP=(SP+P[i])%p;\n\tSP=qpow(SP,p-2);\n\tfor(int i=0;i<(1<<N);i++) P[i]=1LL*P[i]*SP%p;\n\tP[0]=(P[0]-1+p)%p;\n\tQ[0]=(1<<N)-1;\n\tfor(int i=1;i<(1<<N);i++) Q[i]=p-1;\n\tFWT_xor(P,N,1);FWT_xor(Q,N,1);\n\tfor(int i=1;i<(1<<N);i++) F[i]=1LL*Q[i]*qpow(P[i],p-2)%p;\n\tFWT_xor(F,N,-1);\n\tint ans=p-F[0];\n\tfor(int i=0;i<(1<<N);i++) printf(\"%d\\n\",(ans+F[i])%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 998244353;\ninline int Sum(int x, int y) { return (x += y) >= MOD ? (x - MOD) : x; }\ninline int Sub(int x, int y) { return (x -= y) < 0 ? (x + MOD) : x; }\ninline int quick_pow(int a, int n)\n{\n\tint res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD;\n\t\ta = (ll)a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\ninline void FWT(int *arr, int n, bool flg)\n{\n\tint coef = flg ? (MOD + 1) / 2 : 1;\n\tfor (int len = 1; len < n; len <<= 1)\n\t{\n\t\tfor (int i = 0; i < n; i += len << 1)\n\t\t{\n\t\t\tfor (int j = i; j < i + len; j++)\n\t\t\t{\n\t\t\t\tint x = arr[j], y = arr[j + len];\n\t\t\t\tarr[j] = (ll)(x + y) * coef % MOD;\n\t\t\t\tarr[j + len] = (ll)(x - y + MOD) * coef % MOD;\n\t\t\t}\n\t\t}\n\t}\n}\nint ans[300005], arr[300005], goal[300005];\nint main()\n{\n\t// freopen(\"AGC034-F.in\", \"r\", stdin);\n\tint n, sum = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 1 << n; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\t\tsum += arr[i];\n\t}\n\tsum = quick_pow(sum, MOD - 2);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tarr[i] = (ll)arr[i] * sum % MOD;\n\tarr[0] = Sub(arr[0], 1);\n\tFWT(arr, 1 << n, false);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tgoal[i] = MOD - 1;\n\tgoal[0] = Sum(goal[0], 1 << n);\n\tFWT(goal, 1 << n, false);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tans[i] = (ll)goal[i] * quick_pow(arr[i], MOD - 2) % MOD;\n\tFWT(ans, 1 << n, true);\n\tfor (int i = 0; i < 1 << n; i++)\n\t\tprintf(\"%d\\n\", Sub(ans[i], ans[0]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 262145\n#define mod 998244353\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nstruct num{\n\tint a,b;\n\tinline num(int aa=0,int bb=0){a=aa;b=bb;}\n\tinline num operator+(const num &y)const{return num(M(a+y.a),M(b+y.b));}\n\tinline num operator-(const num &y)const{return num(M1(a-y.a),M1(b-y.b));}\n\tinline num operator*(const int &y)const{return num(1ll*a*y%mod,1ll*b*y%mod);}\n}f[N];\ninline void FWT(int f[],int len)\n{\n\tint i,j,x,y;\n\tfor(j=1;j<len;j<<=1)\n\tfor(i=0;i<len;i++)if(i&j){x=f[i^j];y=f[i];f[i^j]=M(x+y);f[i]=M1(x-y);}\n}\ninline void IFWT(num f[],int len)\n{\n\tint i,j,iv;num x,y;\n\tfor(j=1;j<len;j<<=1)\n\tfor(i=0;i<len;i++)if(i&j){x=f[i^j];y=f[i];f[i^j]=x+y;f[i]=x-y;}iv=ksm(len,mod-2);\n\tfor(i=0;i<len;i++)f[i]=f[i]*iv;\n}\nint n,len,A[N],all=0,X,ans;\nint main(){\n\tscanf(\"%d\",&n);len=1<<n;int i;\n\tfor(i=0;i<len;i++)scanf(\"%d\",&A[i]),all=M(all+A[i]);all=ksm(all,mod-2);\n\tfor(i=0;i<len;i++)A[i]=1ll*A[i]*all%mod;A[0]=M1(A[0]-1);FWT(A,len);\n\tfor(i=1;i<len;i++)f[i].b=1ll*len*ksm(A[i],mod-2)%mod;f[0].a=1;IFWT(f,len);\n\tX=1ll*M1(-f[0].b)*ksm(f[0].a,mod-2)%mod;\n\tfor(i=0;i<len;i++)ans=(1ll*f[i].a*X+f[i].b)%mod,printf(\"%d\\n\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\ntypedef long long ll;\n\nconst int mod = 998244353;\n\n\nint sub(int a, int b) {\n\ta -= b;\n\tif(a < 0) {\n\t\ta += mod;\n\t}\n\treturn a;\n}\nint add(int a, int b) {\n\ta += b;\n\tif(a >= mod) {\n\t\ta -= mod;\n\t}\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn (ll) a * b % mod;\n}\nint my_pow(int a, int b) {\n\tint r = 1;\n\twhile(b) {\n\t\tif(b % 2) {\n\t\t\tr = mul(r, a);\n\t\t}\n\t\ta = mul(a, a);\n\t\tb /= 2;\n\t}\n\treturn r;\n}\nint my_inv(int a) {\n\treturn my_pow(a, mod - 2);\n}\n#define div div_compile\nint div(int a, int b) {\n\tif(b == 0) {\n\t\tdebug() << \"div \" imie(a) imie(b);\n\t}\n\tif(b == 0) {\n\t\treturn 0;\n\t\t// int ple = 0;\n\t\t// for(int x : {0,\n// 468683018,\n// 635850749,\n// 96019779,\n// 657074071,\n// 24757563,\n// 745107950,\n// 665159588,\n// 551278361,\n// 143136064,\n// 557841197,\n// 185790407,\n// 988018173,\n// 247117461,\n// 129098626,\n// 789682908}) ple = add(ple, x);\n\t\t// return ple%mod;\n\t}\n\treturn mul(a, my_inv(b));\n}\n\n\nint Z;\n\nconst int INV_TWO = my_inv(2);\n\npair<int,int> add(const pair<int,int>& a, const pair<int,int>& b) {\n\treturn make_pair(add(a.first, b.first), add(a.second, b.second));\n}\n\npair<int,int> sub(const pair<int,int>& a, const pair<int,int>& b) {\n\treturn make_pair(sub(a.first, b.first), sub(a.second, b.second));\n}\n\nvector<pair<int,int>> solve(int c, vector<int> p, bool spec = false) {\n\tdebug() << imie(c) imie(p);\n\tint n = p.size();\n\t/*\n\tif(n == 2 && spec) {\n\t\tdebug() << \"hacku hacku\" imie(p) imie(c);\n\t\t// x[1] = A*x[0] + B\n\t\tint A = div(p[1], sub(1, p[0]));\n\t\tint B = div(c, sub(1, p[0]));\n\t\tdebug() << imie(A) imie(B);\n\t\t// x[0] = C + p[0]*x[0] + p[1]*(A*x[0]+B) - Z\n\t\tint C = sub(1, add(p[0], mul(p[1], A)));\n\t\tint D = add(1, mul(p[1], B));\n\t\tD = sub(D, Z);\n\t\tdebug() << imie(C) imie(D);\n\t\t// C * x[0] = D\n\t\tvector<int> x(2);\n\t\tx[0] = div(D, C);\n\t\tx[1] = add(mul(A, x[0]), B);\n\t\treturn x;\n\t}\n\t*/\n\tif(n == 1) {\n\t\tvector<pair<int,int>> v;\n\t\tif(1 == p[0]) {\n\t\t\tv.emplace_back(0, 1);\n\t\t}\n\t\telse {\n\t\t\tv.emplace_back(div(sub(c, Z), sub(1, p[0])), 0);\n\t\t}\n\t\treturn v;\n\t}\n\tvector<int> p_sum(n / 2), p_diff(n / 2);\n\tfor(int i = 0; i < n / 2; ++i) {\n\t\tp_sum[i] = add(p[2*i], p[2*i+1]);\n\t\tp_diff[i] = sub(p[2*i], p[2*i+1]);\n\t}\n\tvector<pair<int,int>> x_sum = solve(add(c, c), p_sum, spec);\n\tvector<pair<int,int>> x_diff = solve(0, p_diff);\n\t\n\tvector<pair<int,int>> x(n);\n\tfor(int i = 0; i < n / 2; ++i) {\n\t\tpair<int,int> sum = x_sum[i];\n\t\tpair<int,int> diff = x_diff[i];\n\t\tx[2*i] = add(sum, diff);\n\t\tx[2*i+1] = sub(sum, diff);\n\t\tfor(int j : {2*i, 2*i+1}) {\n\t\t\tif(x[j].first) {\n\t\t\t\tx[j].first = mul(x[j].first, INV_TWO);\n\t\t\t}\n\t\t\tif(x[j].second) {\n\t\t\t\tx[j].second = mul(x[j].second, INV_TWO);\n\t\t\t}\n\t\t}\n\t}\n\tdebug() << imie(n) imie(x_sum) imie(x_diff) imie(x);\n\t\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tZ = (1 << n);\n\tvector<int> p(1 << n);\n\tint sum = 0;\n\tfor(int& x : p) {\n\t\tscanf(\"%d\", &x);\n\t\tsum = add(sum, x);\n\t}\n\tint inv_sum = my_inv(sum);\n\tfor(int& x : p) {\n\t\tx = mul(x, inv_sum);\n\t}\n\tdebug() << imie(p);\n\tvector<pair<int,int>> answer = solve(1, p, true);\n\tdebug() << imie(answer);\n\tint one = 0, two = 0;\n\tfor(pair<int,int> p : answer) {\n\t\tone = add(one, p.first);\n\t\ttwo = add(two, p.second);\n\t}\n\tdebug() << imie(one) imie(two);\n\t// 0 = answer[0].first * S + answer[0].second\n\tint S = div(sub(0, answer[0].first), answer[0].second);\n\t// int S = (499122180*2+4)%mod; //div(one, sub(1, two));\n\tfor(pair<int,int> p : answer) {\n\t\tprintf(\"%d\\n\", add(p.first, mul(p.second, S)));\n\t}\n\t// for(int x : answer) {\n\t\t// printf(\"%d\\n\", x);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=18,M=998244353,Inv=M/2+1;\nint p[1<<N],s,n;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans%M;\n}\nvoid FWT(int y[],int m,int opt){\n\tfor (int i=1;i<1<<m;i<<=1)\n\t\tfor (int j=0,p=i<<1;j<1<<m;j+=p)\n\t\t\tfor (int k=j;k<j+i;k++){\n\t\t\t\tint u=y[k],v=y[k+i];\n\t\t\t\ty[k]=(u+v)%M;\n\t\t\t\ty[k+i]=(M+u-v)%M;\n\t\t\t\tif (opt==-1)y[k]=y[k]*Inv%M,y[k+i]=y[k+i]*Inv%M;\n\t\t\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=0;i<1<<n;i++)scanf(\"%lld\",&p[i]),(s+=p[i])%=M;\n\ts=ksm(s,M-2);\n\tfor (int i=0;i<1<<n;i++)(p[i]*=s)%=M; \n\tFWT(p,n,1);s=0;\n\tfor (int i=0;i<1<<n;i++)p[i]=(M+1-p[i])*Inv%M;\n\tfor (int i=0;i<1<<n;i++)p[i]=ksm(p[i],M-2),(s+=p[i])%=M;\n\tFWT(p,n,1);\n\tfor (int i=0;i<1<<n;i++)p[i]=(M+s-p[i])*Inv%M;\n\tfor (int i=0;i<1<<n;i++)printf(\"%lld\\n\",p[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    char c;\n    while (!isdigit(c = getChar())) {}\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return f;\n}\n\nconst int maxN = 262147, mod = 998244353;\nint p[maxN];\n\ninline int power(int x, int y) {\n    int o = 1;\n    while (y) {\n        if (y & 1)\n            o = 1ll * o * x % mod;\n        x = 1ll * x * x % mod, y >>= 1;\n    }\n    return o;\n}\n\nint A[maxN], B[maxN];\ninline void FWT(int* f, int n) {\n    int len = 1 << n, i, j, l, r;\n    for (i = 0; i < n; ++i)\n        for (j = 0; j < len; ++j)\n            if (j & (1 << i)) {\n                l = f[j ^ (1 << i)], r = f[j];\n                f[j ^ (1 << i)] = (l + r) % mod, f[j] = (l - r) % mod;\n            }\n}\n\nint main() {\n    int n = read(), lim = (1 << n) - 1, i, sum = 0, d;\n    for (i = 0; i <= lim; ++i)\n        p[i] = read(), sum += p[i];\n    sum = power(sum, mod - 2);\n    for (i = 0; i <= lim; ++i)\n        p[i] = 1ll * p[i] * sum % mod;\n    \n    A[0] = lim;\n    for (i = 1; i <= lim; ++i)\n        A[i] = -1;\n    B[0] = p[0] - 1;\n    for (i = 1; i <= lim; ++i)\n        B[i] = p[i];\n    FWT(A, n), FWT(B, n);\n    for (i = 0; i <= lim; ++i)\n        B[i] = power(B[i], mod - 2);\n    for (i = 0; i <= lim; ++i)\n        A[i] = 1ll * A[i] * B[i] % mod;\n    FWT(A, n);\n    d = power(lim + 1, mod - 2);\n    for (i = 0; i <= lim; ++i)\n        A[i] = 1ll * A[i] * d % mod;\n    d = -A[0];\n    for (i = 0; i <= lim; ++i)\n        A[i] = (A[i] + d) % mod;\n    \n    for (i = 0; i <= lim; ++i)\n        printf(\"%d\\n\", (A[i] + mod) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=18,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint inv2=(mod+1)>>1;\nint n;\nint a[N];\nvoid FWT(int *a,int n,int flag){\n\tfor (int d=1;d<n;d<<=1)\n\t\tfor (int i=0;i<n;i+=d<<1)\n\t\t\tfor (int j=0;j<d;j++){\n\t\t\t\tint x=a[i+j],y=a[i+j+d];\n\t\t\t\ta[i+j]=Add(x+y);\n\t\t\t\ta[i+j+d]=Del(x-y);\n\t\t\t\tif (flag<0){\n\t\t\t\t\ta[i+j]=(LL)a[i+j]*inv2%mod;\n\t\t\t\t\ta[i+j+d]=(LL)a[i+j+d]*inv2%mod;\n\t\t\t\t}\n\t\t\t}\n}\nint main(){\n\tn=read(),n=1<<n;\n\tint s=0;\n\tFor(i,0,n-1)\n\t\ta[i]=read(),s+=a[i];\n\ts=Pow(s,mod-2);\n\tFor(i,0,n-1)\n\t\ta[i]=(LL)a[i]*s%mod;\t\n\tFWT(a,n,1);\n\tFod(i,n-1,0){\n\t\tif (a[i]==1){\n\t\t\ta[i]=0;\n\t\t\tcontinue;\n\t\t}\n\t\ta[i]=Pow((a[i]-1+mod)%mod,mod-2);\n\t}\n\tFWT(a,n,1);\n\tFor(i,0,n-1)\n\t\tprintf(\"%d\\n\",Del(a[i]-a[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=3e5+5;\nconst int mod=998244353;\nint n,sum,inv2,A[N],p[N],g[N];\n\nnamespace _ {\t\n\tinline int mul(int x,int y) {return 1ll*x*y%mod;}\n\tinline int dec(int x,int y) {x-=y;if(x<0) x+=mod;return x;}\n\tinline int add(int x,int y) {x+=y;if(x>=mod) x-=mod;return x;}\n\tinline int modpow(int x,int y,int res=1) {\n\t\tfor(;y;y>>=1,x=mul(x,x)) if(y&1) res=mul(res,x);\n\t\treturn res;\n\t}\n\ttemplate <typename _Tp> inline void IN(_Tp&x) {\n\t\tchar ch;bool flag=0;x=0;\n\t\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\t\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\t\tif(flag) x=-x;\n\t}\n}using namespace _;\n\ninline void FWT(int*f,short inv) {\n\tfor(int p=2;p<=n;p<<=1)\n\t\tfor(int len=p>>1,k=0;k<n;k+=p)\n\t\t\tfor(int l=k;l<k+len;++l) {\n\t\t\t\tint X=f[l],Y=f[l+len],tmp=inv^1?inv2:1;\n\t\t\t\tf[l]=mul(tmp,add(X,Y)),f[l+len]=mul(tmp,dec(X,Y));\n\t\t\t}\n}\n\nint main() {\n\tIN(n),n=1<<n,inv2=modpow(2,mod-2);\n\tfor(int i=0;i<n;++i) IN(A[i]),sum=add(sum,A[i]);\n\tsum=modpow(sum,mod-2);\n\tfor(int i=0;i<n;++i) p[i]=mul(A[i],sum),g[i]=mod-1;\n\tg[0]=dec(n,1),p[0]=dec(p[0],1),FWT(g,1),FWT(p,1);\n\tfor(int i=0;i<n;++i) g[i]=mul(g[i],modpow(p[i],mod-2));\n\tFWT(g,-1);\n\tfor(int i=0;i<n;++i) printf(\"%d\\n\",dec(g[i],g[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define ll long long\n#define MaxN 270000\nusing namespace std;\nconst int mod=998244353;\nint read(){\n  int X=0;char ch=0;\n  while(ch<'0'||'9'<ch)ch=getchar();\n  while('0'<=ch&&ch<='9')X=X*10+(ch^48),ch=getchar();\n  return X;\n}\nll powM(ll a,int t=mod-2){\n  ll ret=1;\n  while(t){\n    if (t&1)ret=ret*a%mod;\n    a=a*a%mod;t>>=1;\n  }return ret;\n}\nvoid FWT(ll *f,int n)\n{\n  for (int l=1;l<n;l<<=1)\n    for (int p=0;p<n;p+=l+l)\n      for (int k=0;k<l;k++){\n        ll sav=f[p|k];\n        f[p|k]+=f[p|l|k];\n        f[p|l|k]=sav-f[p|l|k];\n      }\n  for (int i=0;i<n;i++)f[i]%=mod;\n}\nll R[MaxN],sR,F[MaxN],sF;\nint main()\n{\n  int n=1<<read();\n  for (int i=0;i<n;i++)sR+=(R[i]=read());\n  sR=powM(sR);\n  for (int i=0;i<n;i++)R[i]=R[i]*sR%mod;\n  R[0]--;FWT(R,n);\n  for (int i=1;i<n;i++)F[i]=mod-1;\n  F[0]=n-1;FWT(F,n);\n  for (int i=1;i<n;i++){\n    F[i]=F[i]*powM(R[i])%mod;\n    sF+=F[i];\n  }F[0]=mod-sF%mod;\n  FWT(F,n);\n  ll inv=powM(n);\n  for (int i=0;i<n;i++){\n    F[i]=F[i]*inv%mod;\n    printf(\"%lld\\n\",(F[i]+mod)%mod);\n  }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353,M=(1<<18)+5;\nint a[M],n,m,sum;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\nvoid fwt(int*f){\n\tfor(int i=1;i<m;i<<=1)\n\t\tfor(int j=0;j<m;j+=i<<1){\n\t\t\tint*f1=f+j,*f2=f+j+i;\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tf1[k]+=f2[k]-mod;f1[k]+=f1[k]>>31&mod;\n\t\t\t\tf2[k]=f1[k]-f2[k]*2;f2[k]+=f2[k]>>31&mod;f2[k]+=f2[k]>>31&mod;\n\t\t\t}\n\t\t}\n}\nint main(){\n#ifdef ONLINE_JUDGE\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#endif\n\tcin>>n;m=1<<n;\n\tfor(int i=0;i<m;++i)cin>>a[i],sum+=a[i];\n\tsum=ksm(sum,mod-2);\n\tfor(int i=0;i<m;++i)a[i]=(ll)a[i]*sum%mod;\n\tfwt(a);a[0]=0;\n\tfor(int i=1;i<m;++i)a[i]=ksm((a[i]-1+mod)%mod,mod-2),a[0]=(a[0]-a[i]+mod)%mod;\n\tfwt(a);\n\tfor(int i=0;i<m;++i)cout<<a[i]<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "-- https://github.com/minoki/my-atcoder-solutions\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\nimport Data.Char (isSpace)\nimport Data.Bits (xor)\nimport Control.Monad (forM_,when)\nimport Control.Monad.ST\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport qualified Data.Vector.Generic as G\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.IntSet as IntSet\n---\nimport Data.Coerce\nimport qualified Data.Vector.Generic\nimport qualified Data.Vector.Generic.Mutable\n\ntype NN = N\ntype Vec = U.Vector NN\n{-\ntype NN = Rational\ntype Vec = V.Vector NN\n-}\n\nbuildIxMap :: U.Vector Int -> (U.Vector Int, V.Vector IntSet.IntSet)\nbuildIxMap xs =\n  let !classify = V.create $ do\n        vec <- VM.replicate 1000 IntSet.empty\n        flip U.imapM_ xs $ \\i x -> do\n          -- 1 <= x <= 1000\n          VM.modify vec (IntSet.insert i) (x - 1)\n        return vec\n      !classify' = V.filter (not . IntSet.null) classify\n      !ixToReducedIx = U.create $ do\n        vec <- UM.new (U.length xs)\n        flip V.imapM_ classify' $ \\j s -> do\n          forM_ (IntSet.toList s) $ \\i -> do\n            UM.write vec i j\n        return vec\n  in (ixToReducedIx, classify')\n\nmain = do\n  n :: Int <- readLn -- 1 <= n <= 18\n  as <- U.unfoldrN (2^n) (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine\n  let s = U.sum as :: Int\n      !as' = G.map fromIntegral (V.convert as) :: Vec\n      !s' = recip (fromIntegral s) :: NN\n      toReducedIx :: U.Vector Int\n      fromReducedIx :: V.Vector IntSet.IntSet\n      (toReducedIx, fromReducedIx) = buildIxMap (U.tail as)\n      m = V.length fromReducedIx\n      coeffMatV :: V.Vector Vec\n      coeffMatV = V.generate m $ \\l -> -- 0 <= l < m\n        let i = IntSet.findMin (fromReducedIx V.! l) -- 0 <= i < U.length as - 1 = 2^n-1\n        in G.generate (m + 1) $ \\k ->\n          if k == m\n          then 1\n          else -- 0 <= k < m\n            if l == k\n            then 1 - s' * sum [ as' G.! ((i+1) `xor` (j+1))\n                              | j <- IntSet.toList (fromReducedIx V.! l)\n                              -- toReducedIx ! j == l\n                              -- 0 <= j < U.length as - 1 = 2^n-1\n                              ]\n            else - s' * sum [ as' G.! ((i+1) `xor` (j+1))\n                            | j <- IntSet.toList (fromReducedIx V.! k)\n                            -- toReducedIx ! j == l\n                            -- 0 <= j < U.length as - 1 = 2^n-1\n                            ]\n  let resultV = solveV coeffMatV\n  print 0\n  U.forM_ toReducedIx $ \\i -> do\n    let row = resultV V.! i\n    print $ row G.! m\n\n-- Gaussian elimination\nsolveV :: forall vector k. (Eq k, Fractional k, G.Vector vector k) => V.Vector (vector k) -> V.Vector (vector k)\nsolveV m = runST $ do\n  m' <- V.mapM G.thaw m\n  m'' <- V.thaw m'\n  elim 0 m''\n  subst (n-2) m''\n  m''' <- V.unsafeFreeze m''\n  V.mapM G.unsafeFreeze m'''\n  -- V.createT is not available on AtCoder😢\n  where\n    !n = V.length m\n    elim :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    elim !i !m\n      | i >= n = return ()\n      | otherwise = do\n          let findK k | k >= n = error \"singular matrix\"\n                      | otherwise = do\n                          row <- VM.read m k\n                          w <- GM.read row i\n                          if w == 0\n                            then findK (k + 1)\n                            else return (k,row,w)\n          (k,rowK,w) <- findK i -- i <= k\n          let !r = recip w -- r == recip (m!(k,i))\n          forM_ [i..GM.length rowK - 1] $ \\j -> do\n            GM.modify rowK (\\x -> x * r) j\n          -- GM.set (GM.take i rowK) 0\n          forM_ [i..n-1] $ \\i' -> do\n            row' <- VM.read m i'\n            when (i' /= k) $ do\n              y <- GM.read row' i -- m!(i',i)\n              let !yy = y\n              forM_ [i..GM.length row' - 1] $ \\j -> do\n                z <- GM.read rowK j\n                GM.modify row' (\\x -> x - z * yy) j\n          VM.swap m i k\n          elim (i+1) m\n    subst :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    subst !i !m\n      | i < 0 = return ()\n      | otherwise = do\n          row <- VM.read m i\n          let loop !j !x | j >= n = GM.write row n x\n                         | otherwise = do\n                             c <- GM.read row j\n                             y <- VM.read m j >>= (`GM.read` n)\n                             loop (j+1) (x - c * y)\n          rhs <- GM.read row n\n          loop (i + 1) rhs\n          -- GM.set (GM.drop (i+1) $ GM.take n row) 0\n          subst (i - 1) m\n\n---\n\nexEuclid :: (Eq a, Integral a) => a -> a -> (a, a, a)\nexEuclid !f !g = loop 1 0 0 1 f g\n  where loop !u0 !u1 !v0 !v1 !f 0 = (f, u0, v0)\n        loop !u0 !u1 !v0 !v1 !f g =\n          case divMod f g of\n            (q,r) -> loop u1 (u0 - q * u1) v1 (v0 - q * v1) g r\n\nmodulo = 998244353 :: Int\naddMod, subMod, mulMod, divM :: Int -> Int -> Int\naddMod !x !y = (x + y) `rem` modulo\nsubMod !x !y = (x - y) `mod` modulo\nmulMod !x !y = (x * y) `rem` modulo\nrecipM :: Int -> Int\nrecipM !x = case exEuclid x modulo of\n             (1,a,_) -> a `mod` modulo\n             (-1,a,_) -> (-a) `mod` modulo\ndivM !x !y = x `mulMod` recipM y\n\nnewtype N = N { unwrapN :: Int } deriving (Eq)\ninstance Show N where\n  show (N x) = show x\ninstance Num N where\n  N x + N y = N ((x + y) `rem` modulo)\n  N x - N y = N ((x - y) `mod` modulo)\n  N x * N y = N ((x * y) `rem` modulo)\n  fromInteger n = N (fromInteger (n `mod` fromIntegral modulo))\n  abs = undefined; signum = undefined\n\ninstance Fractional N where\n  N x / N y = N (divM x y)\n  recip (N x) = N (recipM x)\n  fromRational = undefined\n\n---\n\nnewtype instance UM.MVector s N = MV_N (UM.MVector s Int)\nnewtype instance U.Vector N = V_N (U.Vector Int)\n\ninstance Data.Vector.Generic.Mutable.MVector UM.MVector N where -- needs MultiParamTypeClasses here\n  basicLength (MV_N mv) = Data.Vector.Generic.Mutable.basicLength mv\n  basicUnsafeSlice i l (MV_N mv) = MV_N (Data.Vector.Generic.Mutable.basicUnsafeSlice i l mv)\n  basicOverlaps (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicOverlaps mv mv'\n  basicUnsafeNew l = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeNew l\n  basicInitialize (MV_N mv) = Data.Vector.Generic.Mutable.basicInitialize mv\n  basicUnsafeReplicate i x = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeReplicate i (coerce x)\n  basicUnsafeRead (MV_N mv) i = coerce <$> Data.Vector.Generic.Mutable.basicUnsafeRead mv i\n  basicUnsafeWrite (MV_N mv) i x = Data.Vector.Generic.Mutable.basicUnsafeWrite mv i (coerce x)\n  basicClear (MV_N mv) = Data.Vector.Generic.Mutable.basicClear mv\n  basicSet (MV_N mv) x = Data.Vector.Generic.Mutable.basicSet mv (coerce x)\n  basicUnsafeCopy (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeCopy mv mv'\n  basicUnsafeMove (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeMove mv mv'\n  basicUnsafeGrow (MV_N mv) n = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeGrow mv n\n\ninstance Data.Vector.Generic.Vector U.Vector N where -- needs MultiParamTypeClasses here\n  basicUnsafeFreeze (MV_N mv) = V_N <$> Data.Vector.Generic.basicUnsafeFreeze mv\n  basicUnsafeThaw (V_N v) = MV_N <$> Data.Vector.Generic.basicUnsafeThaw v\n  basicLength (V_N v) = Data.Vector.Generic.basicLength v\n  basicUnsafeSlice i l (V_N v) = V_N (Data.Vector.Generic.basicUnsafeSlice i l v)\n  basicUnsafeIndexM (V_N v) i = coerce <$> Data.Vector.Generic.basicUnsafeIndexM v i\n  basicUnsafeCopy (MV_N mv) (V_N v) = Data.Vector.Generic.basicUnsafeCopy mv v\n  elemseq (V_N v) x y = Data.Vector.Generic.elemseq v (coerce x) y\n\ninstance U.Unbox N\n"
  },
  {
    "language": "Haskell",
    "code": "-- https://github.com/minoki/my-atcoder-solutions\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\nimport Data.Char (isSpace)\nimport Data.Bits (xor)\nimport Control.Monad (forM_)\nimport qualified Data.Vector.Unboxed as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray\n---\nimport Data.Coerce\nimport qualified Data.Vector.Generic\nimport qualified Data.Vector.Generic.Mutable\nimport qualified Data.Array.Base\nimport qualified Unsafe.Coerce\n\ntype NN = N -- Rational\ntype Mat = UArray (Int,Int) NN\n\nmain = do\n  n :: Int <- readLn -- 1 <= n <= 18\n  as <- U.unfoldrN (2^n) (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine\n  let s = U.sum as :: Int\n      !as' = U.map fromIntegral as :: U.Vector NN\n      !s' = recip (fromIntegral s) :: NN\n      coeffMat :: Mat\n      coeffMat = array ((1,1),(2^n-1,2^n)) $\n        [ ((i,j),v)\n        | i <- [1..2^n-1]\n        , j <- [1..2^n-1]\n        , let v | i == j = 1 - (as' U.! 0) * s'\n                | otherwise = - (as' U.! (i `xor` j)) * s'\n        ]\n        ++ [((i,2^n),1) | i <- [1..2^n-1]]\n  let result = solve coeffMat\n  print 0\n  forM_ [1..2^n-1] $ \\j -> do\n    print $ result!(j,2^n) / result!(j,j)\n\n-- 行基本変形を行う\nsolve :: (Eq k, Fractional k, IArray arr k) => arr (Int,Int) k -> arr (Int,Int) k\nsolve m | i0 == j0 = loop i0 m\n        | otherwise = error \"not supported\"\n  where\n    b@((i0,j0),(iN,_)) = bounds m\n    loop !i !m\n      | i > iN = m\n      | otherwise = case [(k,w) | k <- [i..iN], let w = m!(k,i), w /= 0] of\n          (!k,!w):_ -> let !r = recip w -- r == recip (m!(k,i))\n                       in loop (i+1) $ array b\n                          [ ((if i' == k then i else if i' == i then k else i',j),v)\n                          | (i',j) <- indices m\n                          , let v | i' == k = m!(i',j)\n                                  | otherwise = m!(i',j) - m!(k,j)*m!(i',i)*r\n                          ]\n          [] -> error \"singular matrix\"\n\n---\n\nexEuclid :: (Eq a, Integral a) => a -> a -> (a, a, a)\nexEuclid !f !g = loop 1 0 0 1 f g\n  where loop !u0 !u1 !v0 !v1 !f 0 = (f, u0, v0)\n        loop !u0 !u1 !v0 !v1 !f g =\n          case divMod f g of\n            (q,r) -> loop u1 (u0 - q * u1) v1 (v0 - q * v1) g r\n\nmodulo = 998244353 :: Int\naddMod, subMod, mulMod, divM :: Int -> Int -> Int\naddMod !x !y = (x + y) `rem` modulo\nsubMod !x !y = (x - y) `mod` modulo\nmulMod !x !y = (x * y) `rem` modulo\nrecipM :: Int -> Int\nrecipM !x = case exEuclid x modulo of\n             (1,a,_) -> a `mod` modulo\n             (-1,a,_) -> (-a) `mod` modulo\ndivM !x !y = x `mulMod` recipM y\n\nnewtype N = N { unwrapN :: Int } deriving (Eq)\ninstance Show N where\n  show (N x) = show x\ninstance Num N where\n  N x + N y = N ((x + y) `rem` modulo)\n  N x - N y = N ((x - y) `mod` modulo)\n  N x * N y = N ((x * y) `rem` modulo)\n  fromInteger n = N (fromInteger (n `mod` fromIntegral modulo))\n  abs = undefined; signum = undefined\n\ninstance Fractional N where\n  N x / N y = N (divM x y)\n  recip (N x) = N (recipM x)\n  fromRational = undefined\n\n---\n\nnewtype instance UM.MVector s N = MV_N (UM.MVector s Int)\nnewtype instance U.Vector N = V_N (U.Vector Int)\n\ninstance Data.Vector.Generic.Mutable.MVector UM.MVector N where -- needs MultiParamTypeClasses here\n  basicLength (MV_N mv) = Data.Vector.Generic.Mutable.basicLength mv\n  basicUnsafeSlice i l (MV_N mv) = MV_N (Data.Vector.Generic.Mutable.basicUnsafeSlice i l mv)\n  basicOverlaps (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicOverlaps mv mv'\n  basicUnsafeNew l = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeNew l\n  basicInitialize (MV_N mv) = Data.Vector.Generic.Mutable.basicInitialize mv\n  basicUnsafeReplicate i x = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeReplicate i (coerce x)\n  basicUnsafeRead (MV_N mv) i = coerce <$> Data.Vector.Generic.Mutable.basicUnsafeRead mv i\n  basicUnsafeWrite (MV_N mv) i x = Data.Vector.Generic.Mutable.basicUnsafeWrite mv i (coerce x)\n  basicClear (MV_N mv) = Data.Vector.Generic.Mutable.basicClear mv\n  basicSet (MV_N mv) x = Data.Vector.Generic.Mutable.basicSet mv (coerce x)\n  basicUnsafeCopy (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeCopy mv mv'\n  basicUnsafeMove (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeMove mv mv'\n  basicUnsafeGrow (MV_N mv) n = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeGrow mv n\n\ninstance Data.Vector.Generic.Vector U.Vector N where -- needs MultiParamTypeClasses here\n  basicUnsafeFreeze (MV_N mv) = V_N <$> Data.Vector.Generic.basicUnsafeFreeze mv\n  basicUnsafeThaw (V_N v) = MV_N <$> Data.Vector.Generic.basicUnsafeThaw v\n  basicLength (V_N v) = Data.Vector.Generic.basicLength v\n  basicUnsafeSlice i l (V_N v) = V_N (Data.Vector.Generic.basicUnsafeSlice i l v)\n  basicUnsafeIndexM (V_N v) i = coerce <$> Data.Vector.Generic.basicUnsafeIndexM v i\n  basicUnsafeCopy (MV_N mv) (V_N v) = Data.Vector.Generic.basicUnsafeCopy mv v\n  elemseq (V_N v) x y = Data.Vector.Generic.elemseq v (coerce x) y\n\ninstance U.Unbox N\n\nunsafeCoerce_UArray_N_Int :: UArray i N -> UArray i Int\nunsafeCoerce_UArray_N_Int = Unsafe.Coerce.unsafeCoerce\nunsafeCoerce_UArray_Int_N :: UArray i Int -> UArray i N\nunsafeCoerce_UArray_Int_N = Unsafe.Coerce.unsafeCoerce\n\ninstance Data.Array.Base.IArray UArray N where\n  bounds arr = Data.Array.Base.bounds (unsafeCoerce_UArray_N_Int arr)\n  numElements arr = Data.Array.Base.numElements (unsafeCoerce_UArray_N_Int arr)\n  unsafeArray lu ies = unsafeCoerce_UArray_Int_N $ Data.Array.Base.unsafeArray lu (coerce ies)\n  unsafeAt arr i = coerce (Data.Array.Base.unsafeAt (unsafeCoerce_UArray_N_Int arr) i)\n  unsafeReplace arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeReplace (unsafeCoerce_UArray_N_Int arr) (coerce ies))\n  unsafeAccum f arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccum (coerce f) (unsafeCoerce_UArray_N_Int arr) ies)\n  unsafeAccumArray f e lu ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccumArray (coerce f) (coerce e) lu ies)\n"
  },
  {
    "language": "Haskell",
    "code": "-- https://github.com/minoki/my-atcoder-solutions\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\nimport Data.Char (isSpace)\nimport Data.Bits (xor)\nimport Control.Monad (forM_,when)\nimport Control.Monad.ST\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport qualified Data.Vector.Generic as G\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray\nimport System.Environment (getArgs)\nimport Debug.Trace\n---\nimport Data.Coerce\nimport qualified Data.Vector.Generic\nimport qualified Data.Vector.Generic.Mutable\nimport qualified Data.Array.Base\nimport qualified Unsafe.Coerce\n\ntype NN = N\ntype Mat = UArray (Int,Int) NN\ntype Vec = U.Vector NN\n{-\ntype NN = Rational\ntype Mat = Array (Int,Int) Rational\ntype Vec = V.Vector NN\n-}\n\nmain = do\n  n :: Int <- readLn -- 1 <= n <= 18\n  as <- U.unfoldrN (2^n) (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine\n  let s = U.sum as :: Int\n      !as' = G.map fromIntegral (V.convert as) :: Vec\n      !s' = recip (fromIntegral s) :: NN\n      coeffMat :: Mat\n      coeffMat = array ((1,1),(2^n-1,2^n)) $\n        [ ((i,j),v)\n        | i <- [1..2^n-1]\n        , j <- [1..2^n-1]\n        , let v | i == j = 1 - (as' G.! 0) * s'\n                | otherwise = - (as' G.! (i `xor` j)) * s'\n        ]\n        ++ [((i,2^n),1) | i <- [1..2^n-1]]\n      coeffMatV :: V.Vector Vec\n      coeffMatV = V.generate (2^n-1) $ \\i ->\n        G.generate (2^n) $ \\j ->\n        if j == 2^n-1\n        then 1\n        else if i == j\n             then 1 - (as' G.! 0) * s'\n             else - (as' G.! ((i+1) `xor` (j+1))) * s'\n  let result = solve coeffMat\n  let resultV = solveV coeffMatV\n  print 0\n  args <- getArgs\n  case args of\n    \"array\":_ -> do\n      forM_ [1..2^n-1] $ \\j -> do\n        print $ result!(j,2^n) / result!(j,j)\n    _ -> do -- print resultV\n            V.imapM_ (\\j row -> print $ row G.! (2^n-1) / row G.! j) resultV\n\n-- 行基本変形を行う\nsolve :: (Eq k, Fractional k, IArray arr k) => arr (Int,Int) k -> arr (Int,Int) k\nsolve m | i0 == j0 = loop i0 m\n        | otherwise = error \"not supported\"\n  where\n    b@((i0,j0),(iN,_)) = bounds m\n    loop !i !m\n      | i > iN = m\n      | otherwise = case [(k,w) | k <- [i..iN], let w = m!(k,i), w /= 0] of\n          (!k,!w):_ -> let !r = recip w -- r == recip (m!(k,i))\n                       in loop (i+1) $ array b\n                          [ ((i'',j),v)\n                          | (i',j) <- indices m\n                          , let !v | i' == k = m!(i',j)\n                                   | otherwise = m!(i',j) - m!(k,j)*m!(i',i)*r\n                                !i''  | i' == k = i\n                                      | i' == i = k\n                                      | otherwise = i'\n                          ]\n          [] -> error \"singular matrix\"\n\nsolveV :: forall vector k. (Eq k, Fractional k, G.Vector vector k, Show k, Show (vector k)) => V.Vector (vector k) -> V.Vector (vector k)\nsolveV m = runST $ do\n  m' <- V.mapM G.thaw m\n  m'' <- V.thaw m'\n  elim 0 m''\n  subst (n-2) m''\n  m''' <- V.unsafeFreeze m''\n  V.mapM G.unsafeFreeze m'''\n  -- V.createT is not available on AtCoder\n  where\n    !n = V.length m\n    elim :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    elim !i !m\n      | i >= n = return ()\n      | otherwise = do\n          let findK k | k >= n = error \"singular matrix\"\n                      | otherwise = do\n                          row <- VM.read m k\n                          w <- GM.read row i\n                          if w == 0\n                            then findK (k + 1)\n                            else return (k,row,w)\n          (k,rowK,w) <- findK i -- i <= k\n          let !r = recip w -- r == recip (m!(k,i))\n          forM_ [i..GM.length rowK - 1] $ \\j -> do\n            GM.modify rowK (\\x -> x * r) j\n          -- GM.set (GM.take i rowK) 0\n          forM_ [i..n-1] $ \\i' -> do\n            row' <- VM.read m i'\n            when (i' /= k) $ do\n              y <- GM.read row' i -- m!(i',i)\n              let !yy = y\n              forM_ [i..GM.length row' - 1] $ \\j -> do\n                z <- GM.read rowK j\n                GM.modify row' (\\x -> x - z * yy) j\n          VM.swap m i k\n          elim (i+1) m\n    subst :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    subst !i !m\n      | i < 0 = return ()\n      | otherwise = do\n          row <- VM.read m i\n          let loop !j !x | j >= n = GM.write row n x\n                         | otherwise = do\n                             c <- GM.read row j\n                             y <- VM.read m j >>= (`GM.read` n)\n                             loop (j+1) (x - c * y)\n          rhs <- GM.read row n\n          loop (i + 1) rhs\n          -- GM.set (GM.drop (i+1) $ GM.take n row) 0\n          subst (i - 1) m\n{-\n    dump :: VM.MVector s (G.Mutable vector s k) -> ST s ()\n    dump m = do m' <- V.freeze m\n                fr <- V.mapM G.freeze m'\n                traceShow fr $ return ()\n-}\n\n---\n\nexEuclid :: (Eq a, Integral a) => a -> a -> (a, a, a)\nexEuclid !f !g = loop 1 0 0 1 f g\n  where loop !u0 !u1 !v0 !v1 !f 0 = (f, u0, v0)\n        loop !u0 !u1 !v0 !v1 !f g =\n          case divMod f g of\n            (q,r) -> loop u1 (u0 - q * u1) v1 (v0 - q * v1) g r\n\nmodulo = 998244353 :: Int\naddMod, subMod, mulMod, divM :: Int -> Int -> Int\naddMod !x !y = (x + y) `rem` modulo\nsubMod !x !y = (x - y) `mod` modulo\nmulMod !x !y = (x * y) `rem` modulo\nrecipM :: Int -> Int\nrecipM !x = case exEuclid x modulo of\n             (1,a,_) -> a `mod` modulo\n             (-1,a,_) -> (-a) `mod` modulo\ndivM !x !y = x `mulMod` recipM y\n\nnewtype N = N { unwrapN :: Int } deriving (Eq)\ninstance Show N where\n  show (N x) = show x\ninstance Num N where\n  N x + N y = N ((x + y) `rem` modulo)\n  N x - N y = N ((x - y) `mod` modulo)\n  N x * N y = N ((x * y) `rem` modulo)\n  fromInteger n = N (fromInteger (n `mod` fromIntegral modulo))\n  abs = undefined; signum = undefined\n\ninstance Fractional N where\n  N x / N y = N (divM x y)\n  recip (N x) = N (recipM x)\n  fromRational = undefined\n\n---\n\nnewtype instance UM.MVector s N = MV_N (UM.MVector s Int)\nnewtype instance U.Vector N = V_N (U.Vector Int)\n\ninstance Data.Vector.Generic.Mutable.MVector UM.MVector N where -- needs MultiParamTypeClasses here\n  basicLength (MV_N mv) = Data.Vector.Generic.Mutable.basicLength mv\n  basicUnsafeSlice i l (MV_N mv) = MV_N (Data.Vector.Generic.Mutable.basicUnsafeSlice i l mv)\n  basicOverlaps (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicOverlaps mv mv'\n  basicUnsafeNew l = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeNew l\n  basicInitialize (MV_N mv) = Data.Vector.Generic.Mutable.basicInitialize mv\n  basicUnsafeReplicate i x = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeReplicate i (coerce x)\n  basicUnsafeRead (MV_N mv) i = coerce <$> Data.Vector.Generic.Mutable.basicUnsafeRead mv i\n  basicUnsafeWrite (MV_N mv) i x = Data.Vector.Generic.Mutable.basicUnsafeWrite mv i (coerce x)\n  basicClear (MV_N mv) = Data.Vector.Generic.Mutable.basicClear mv\n  basicSet (MV_N mv) x = Data.Vector.Generic.Mutable.basicSet mv (coerce x)\n  basicUnsafeCopy (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeCopy mv mv'\n  basicUnsafeMove (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeMove mv mv'\n  basicUnsafeGrow (MV_N mv) n = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeGrow mv n\n\ninstance Data.Vector.Generic.Vector U.Vector N where -- needs MultiParamTypeClasses here\n  basicUnsafeFreeze (MV_N mv) = V_N <$> Data.Vector.Generic.basicUnsafeFreeze mv\n  basicUnsafeThaw (V_N v) = MV_N <$> Data.Vector.Generic.basicUnsafeThaw v\n  basicLength (V_N v) = Data.Vector.Generic.basicLength v\n  basicUnsafeSlice i l (V_N v) = V_N (Data.Vector.Generic.basicUnsafeSlice i l v)\n  basicUnsafeIndexM (V_N v) i = coerce <$> Data.Vector.Generic.basicUnsafeIndexM v i\n  basicUnsafeCopy (MV_N mv) (V_N v) = Data.Vector.Generic.basicUnsafeCopy mv v\n  elemseq (V_N v) x y = Data.Vector.Generic.elemseq v (coerce x) y\n\ninstance U.Unbox N\n\nunsafeCoerce_UArray_N_Int :: UArray i N -> UArray i Int\nunsafeCoerce_UArray_N_Int = Unsafe.Coerce.unsafeCoerce\nunsafeCoerce_UArray_Int_N :: UArray i Int -> UArray i N\nunsafeCoerce_UArray_Int_N = Unsafe.Coerce.unsafeCoerce\n\ninstance Data.Array.Base.IArray UArray N where\n  bounds arr = Data.Array.Base.bounds (unsafeCoerce_UArray_N_Int arr)\n  numElements arr = Data.Array.Base.numElements (unsafeCoerce_UArray_N_Int arr)\n  unsafeArray lu ies = unsafeCoerce_UArray_Int_N $ Data.Array.Base.unsafeArray lu (coerce ies)\n  unsafeAt arr i = coerce (Data.Array.Base.unsafeAt (unsafeCoerce_UArray_N_Int arr) i)\n  unsafeReplace arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeReplace (unsafeCoerce_UArray_N_Int arr) (coerce ies))\n  unsafeAccum f arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccum (coerce f) (unsafeCoerce_UArray_N_Int arr) ies)\n  unsafeAccumArray f e lu ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccumArray (coerce f) (coerce e) lu ies)\n"
  },
  {
    "language": "Haskell",
    "code": "-- https://github.com/minoki/my-atcoder-solutions\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\nimport Data.Char (isSpace)\nimport Data.Bits (xor)\nimport Control.Monad (forM_,when)\nimport Control.Monad.ST\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport qualified Data.Vector.Generic as G\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray\nimport System.Environment (getArgs)\nimport Debug.Trace\n---\nimport Data.Coerce\nimport qualified Data.Vector.Generic\nimport qualified Data.Vector.Generic.Mutable\nimport qualified Data.Array.Base\nimport qualified Unsafe.Coerce\n\ntype NN = N\ntype Mat = UArray (Int,Int) NN\ntype Vec = U.Vector NN\n{-\ntype NN = Rational\ntype Mat = Array (Int,Int) Rational\ntype Vec = V.Vector NN\n-}\n\nmain = do\n  n :: Int <- readLn -- 1 <= n <= 18\n  as <- U.unfoldrN (2^n) (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine\n  let s = U.sum as :: Int\n      !as' = G.map fromIntegral (V.convert as) :: Vec\n      !s' = recip (fromIntegral s) :: NN\n      coeffMat :: Mat\n      coeffMat = array ((1,1),(2^n-1,2^n)) $\n        [ ((i,j),v)\n        | i <- [1..2^n-1]\n        , j <- [1..2^n-1]\n        , let v | i == j = 1 - (as' G.! 0) * s'\n                | otherwise = - (as' G.! (i `xor` j)) * s'\n        ]\n        ++ [((i,2^n),1) | i <- [1..2^n-1]]\n      coeffMatV :: V.Vector Vec\n      coeffMatV = V.generate (2^n-1) $ \\i ->\n        G.generate (2^n) $ \\j ->\n        if j == 2^n-1\n        then 1\n        else if i == j\n             then 1 - (as' G.! 0) * s'\n             else - (as' G.! ((i+1) `xor` (j+1))) * s'\n  let result = solve coeffMat\n  let resultV = solveV coeffMatV\n  print 0\n  args <- getArgs\n  case args of\n    \"array\":_ -> do\n      forM_ [1..2^n-1] $ \\j -> do\n        print $ result!(j,2^n) / result!(j,j)\n    _ -> do -- print resultV\n            V.imapM_ (\\j row -> print $ row G.! (2^n-1) / row G.! j) resultV\n\n-- 行基本変形を行う\nsolve :: (Eq k, Fractional k, IArray arr k) => arr (Int,Int) k -> arr (Int,Int) k\nsolve m | i0 == j0 = loop i0 m\n        | otherwise = error \"not supported\"\n  where\n    b@((i0,j0),(iN,_)) = bounds m\n    loop !i !m\n      | i > iN = m\n      | otherwise = case [(k,w) | k <- [i..iN], let w = m!(k,i), w /= 0] of\n          (!k,!w):_ -> let !r = recip w -- r == recip (m!(k,i))\n                       in loop (i+1) $ array b\n                          [ ((i'',j),v)\n                          | (i',j) <- indices m\n                          , let !v | i' == k = m!(i',j)\n                                   | otherwise = m!(i',j) - m!(k,j)*m!(i',i)*r\n                                !i''  | i' == k = i\n                                      | i' == i = k\n                                      | otherwise = i'\n                          ]\n          [] -> error \"singular matrix\"\n\nsolveV :: forall vector k. (Eq k, Fractional k, G.Vector vector k, Show k, Show (vector k)) => V.Vector (vector k) -> V.Vector (vector k)\nsolveV m = G.createT $ do\n  m' <- V.mapM G.thaw m\n  m'' <- V.thaw m'\n  elim 0 m''\n  subst (n-2) m''\n  V.unsafeFreeze m''\n  where\n    !n = V.length m\n    elim :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    elim !i !m\n      | i >= n = return ()\n      | otherwise = do\n          let findK k | k >= n = error \"singular matrix\"\n                      | otherwise = do\n                          row <- VM.read m k\n                          w <- GM.read row i\n                          if w == 0\n                            then findK (k + 1)\n                            else return (k,row,w)\n          (k,rowK,w) <- findK i -- i <= k\n          let !r = recip w -- r == recip (m!(k,i))\n          forM_ [i..GM.length rowK - 1] $ \\j -> do\n            GM.modify rowK (\\x -> x * r) j\n          -- GM.set (GM.take i rowK) 0\n          forM_ [i..n-1] $ \\i' -> do\n            row' <- VM.read m i'\n            when (i' /= k) $ do\n              y <- GM.read row' i -- m!(i',i)\n              let !yy = y\n              forM_ [i..GM.length row' - 1] $ \\j -> do\n                z <- GM.read rowK j\n                GM.modify row' (\\x -> x - z * yy) j\n          VM.swap m i k\n          elim (i+1) m\n    subst :: Int -> VM.MVector s (G.Mutable vector s k) -> ST s ()\n    subst !i !m\n      | i < 0 = return ()\n      | otherwise = do\n          row <- VM.read m i\n          let loop !j !x | j >= n = GM.write row n x\n                         | otherwise = do\n                             c <- GM.read row j\n                             y <- VM.read m j >>= (`GM.read` n)\n                             loop (j+1) (x - c * y)\n          rhs <- GM.read row n\n          loop (i + 1) rhs\n          -- GM.set (GM.drop (i+1) $ GM.take n row) 0\n          subst (i - 1) m\n{-\n    dump :: VM.MVector s (G.Mutable vector s k) -> ST s ()\n    dump m = do m' <- V.freeze m\n                fr <- V.mapM G.freeze m'\n                traceShow fr $ return ()\n-}\n\n---\n\nexEuclid :: (Eq a, Integral a) => a -> a -> (a, a, a)\nexEuclid !f !g = loop 1 0 0 1 f g\n  where loop !u0 !u1 !v0 !v1 !f 0 = (f, u0, v0)\n        loop !u0 !u1 !v0 !v1 !f g =\n          case divMod f g of\n            (q,r) -> loop u1 (u0 - q * u1) v1 (v0 - q * v1) g r\n\nmodulo = 998244353 :: Int\naddMod, subMod, mulMod, divM :: Int -> Int -> Int\naddMod !x !y = (x + y) `rem` modulo\nsubMod !x !y = (x - y) `mod` modulo\nmulMod !x !y = (x * y) `rem` modulo\nrecipM :: Int -> Int\nrecipM !x = case exEuclid x modulo of\n             (1,a,_) -> a `mod` modulo\n             (-1,a,_) -> (-a) `mod` modulo\ndivM !x !y = x `mulMod` recipM y\n\nnewtype N = N { unwrapN :: Int } deriving (Eq)\ninstance Show N where\n  show (N x) = show x\ninstance Num N where\n  N x + N y = N ((x + y) `rem` modulo)\n  N x - N y = N ((x - y) `mod` modulo)\n  N x * N y = N ((x * y) `rem` modulo)\n  fromInteger n = N (fromInteger (n `mod` fromIntegral modulo))\n  abs = undefined; signum = undefined\n\ninstance Fractional N where\n  N x / N y = N (divM x y)\n  recip (N x) = N (recipM x)\n  fromRational = undefined\n\n---\n\nnewtype instance UM.MVector s N = MV_N (UM.MVector s Int)\nnewtype instance U.Vector N = V_N (U.Vector Int)\n\ninstance Data.Vector.Generic.Mutable.MVector UM.MVector N where -- needs MultiParamTypeClasses here\n  basicLength (MV_N mv) = Data.Vector.Generic.Mutable.basicLength mv\n  basicUnsafeSlice i l (MV_N mv) = MV_N (Data.Vector.Generic.Mutable.basicUnsafeSlice i l mv)\n  basicOverlaps (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicOverlaps mv mv'\n  basicUnsafeNew l = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeNew l\n  basicInitialize (MV_N mv) = Data.Vector.Generic.Mutable.basicInitialize mv\n  basicUnsafeReplicate i x = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeReplicate i (coerce x)\n  basicUnsafeRead (MV_N mv) i = coerce <$> Data.Vector.Generic.Mutable.basicUnsafeRead mv i\n  basicUnsafeWrite (MV_N mv) i x = Data.Vector.Generic.Mutable.basicUnsafeWrite mv i (coerce x)\n  basicClear (MV_N mv) = Data.Vector.Generic.Mutable.basicClear mv\n  basicSet (MV_N mv) x = Data.Vector.Generic.Mutable.basicSet mv (coerce x)\n  basicUnsafeCopy (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeCopy mv mv'\n  basicUnsafeMove (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeMove mv mv'\n  basicUnsafeGrow (MV_N mv) n = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeGrow mv n\n\ninstance Data.Vector.Generic.Vector U.Vector N where -- needs MultiParamTypeClasses here\n  basicUnsafeFreeze (MV_N mv) = V_N <$> Data.Vector.Generic.basicUnsafeFreeze mv\n  basicUnsafeThaw (V_N v) = MV_N <$> Data.Vector.Generic.basicUnsafeThaw v\n  basicLength (V_N v) = Data.Vector.Generic.basicLength v\n  basicUnsafeSlice i l (V_N v) = V_N (Data.Vector.Generic.basicUnsafeSlice i l v)\n  basicUnsafeIndexM (V_N v) i = coerce <$> Data.Vector.Generic.basicUnsafeIndexM v i\n  basicUnsafeCopy (MV_N mv) (V_N v) = Data.Vector.Generic.basicUnsafeCopy mv v\n  elemseq (V_N v) x y = Data.Vector.Generic.elemseq v (coerce x) y\n\ninstance U.Unbox N\n\nunsafeCoerce_UArray_N_Int :: UArray i N -> UArray i Int\nunsafeCoerce_UArray_N_Int = Unsafe.Coerce.unsafeCoerce\nunsafeCoerce_UArray_Int_N :: UArray i Int -> UArray i N\nunsafeCoerce_UArray_Int_N = Unsafe.Coerce.unsafeCoerce\n\ninstance Data.Array.Base.IArray UArray N where\n  bounds arr = Data.Array.Base.bounds (unsafeCoerce_UArray_N_Int arr)\n  numElements arr = Data.Array.Base.numElements (unsafeCoerce_UArray_N_Int arr)\n  unsafeArray lu ies = unsafeCoerce_UArray_Int_N $ Data.Array.Base.unsafeArray lu (coerce ies)\n  unsafeAt arr i = coerce (Data.Array.Base.unsafeAt (unsafeCoerce_UArray_N_Int arr) i)\n  unsafeReplace arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeReplace (unsafeCoerce_UArray_N_Int arr) (coerce ies))\n  unsafeAccum f arr ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccum (coerce f) (unsafeCoerce_UArray_N_Int arr) ies)\n  unsafeAccumArray f e lu ies = unsafeCoerce_UArray_Int_N (Data.Array.Base.unsafeAccumArray (coerce f) (coerce e) lu ies)\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<math.h>\n\n int main()\n{\n    int n,i=0;\n    float A[100000],c=0,sum=0 ,p[1000000],e[100000],total=0,s ;\n    float q;\n    float x=0 ;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%f\",&A[i]);\n        sum=sum+A[i];\n    }\n    q=pow(2,n);\n    for(i=0;i<q;i++)\n    {\n        p[i]=A[i]/sum ;\n        e[i]=p[i]*A[i] ;\n        total=total+e[i];\n        s=total;\n    total=total/998244353 ;\n    s=s-total;\n    printf(\"%f\\n\",s);\n    }\n    \n    \n    \n    \nreturn 0;\n}   \n \n "
  },
  {
    "language": "C",
    "code": "a"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int MODULO = 998244353;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[1 << n];\n            long sa = 0;\n            for (int i = 0; i < a.length; ++i) {\n                a[i] = in.nextInt();\n                sa += a[i];\n            }\n            long mul = pow(sa, MODULO - 2);\n            for (int i = 0; i < a.length; ++i) {\n                a[i] = (int) (a[i] * mul % MODULO);\n            }\n            //int[] savedA = a.clone();\n            fastWalshHadamardTransform(a);\n            int[] minusOne = new int[1 << n];\n            for (int i = 0; i < minusOne.length; ++i) minusOne[i] = MODULO - 1;\n            fastWalshHadamardTransform(minusOne);\n            int[] oneAtZero = new int[1 << n];\n            oneAtZero[0] = 1;\n            fastWalshHadamardTransform(oneAtZero);\n            if (oneAtZero[0] == 0) throw new RuntimeException();\n            long alpha = (MODULO - minusOne[0]) * pow(oneAtZero[0], MODULO - 2) % MODULO;\n            int[] sol1 = new int[1 << n];\n            for (int i = 1; i < a.length; ++i) {\n                long denom = (a[i] - 1 + MODULO) % MODULO;\n                if (denom == 0) {\n                    throw new RuntimeException();\n                }\n                denom = pow(denom, MODULO - 2);\n                sol1[i] = (int) ((minusOne[i] + alpha * oneAtZero[i]) % MODULO * denom % MODULO);\n            }\n            long sum1 = 0;\n            for (int i = 0; i < a.length; ++i) {\n                sum1 += sol1[i];\n            }\n            sum1 %= MODULO;\n            sol1[0] = (int) ((MODULO - sum1) % MODULO);\n            fastWalshHadamardTransform(sol1);\n            long p2 = pow(a.length, MODULO - 2);\n            for (int i = 0; i < a.length; ++i) {\n                sol1[i] = (int) (sol1[i] * p2 % MODULO);\n            }\n            for (int i = 0; i < a.length; ++i) {\n                out.println(sol1[i]);\n            }\n        }\n\n        private long pow(long a, int k) {\n            long res = 1;\n            while (k > 0) {\n                if (k % 2 != 0) {\n                    res = res * a % MODULO;\n                }\n                a = a * a % MODULO;\n                k /= 2;\n            }\n            return res;\n        }\n\n        private void fastWalshHadamardTransform(int[] poly) {\n            int h = 1;\n            while (h < poly.length) {\n                for (int i = 0; i < poly.length; i += h * 2) {\n                    for (int j = i; j < i + h; ++j) {\n                        int p = poly[j];\n                        int q = poly[j + h];\n                        int s = p + q;\n                        if (s >= MODULO) s -= MODULO;\n                        int m = p - q;\n                        if (m < 0) m += MODULO;\n                        poly[j] = s;\n                        poly[j + h] = m;\n                    }\n                }\n                h *= 2;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[] a = tol(na(1<<n));\n\t\tlong S = 0;\n\t\tfor(long v : a)S += v;\n\t\tint mod = 998244353;\n\t\t\n\t\ta[0] = (a[0] + mod - S) % mod;\n\t\tlong[] ha = fwht(a, mod);\n\t\tlong[] b = new long[1<<n];\n\t\tb[0] = S*((1L<<n)-1)%mod;\n\t\tfor(int i = 1;i < 1<<n;i++){\n\t\t\tb[i] = mod-S;\n\t\t}\n\t\tlong[] hb = fwht(b, mod);\n\t\t\n\t\tlong[] hx = new long[1<<n];\n\t\tfor(int i = 0;i < 1<<n;i++){\n\t\t\thx[i] = hb[i] * invl(ha[i], mod) % mod;\n\t\t}\n\t\tlong[] x = fwht(hx, mod);\n\t\t\n\t\tlong u = invl(1<<n, mod);\n\t\tfor(int i = 0;i < 1<<n;i++){\n\t\t\tx[i] = x[i] * u % mod;\n\t\t}\n\t\tout.println(0);\n\t\tfor(int i = 1;i < 1<<n;i++){\n\t\t\tx[i] -= x[0];\n\t\t\tx[i] %= mod;\n\t\t\tif(x[i] < 0)x[i] += mod;\n\t\t\tout.println(x[i]);\n\t\t}\n\t\t// -11 3 5 3\n\t\t// -12 4 4 4\n\t\t// -3 1 1 1\n\t\t\n\t\t// (P0-1)E0 + ... + P(n-1)E(n-1) = -1+?\n\t\t// (P1)E0 + ... + P(n-1^1)E(n-1) = -1\n\t\t\n\t\t// E0=0\n\t\t// (1/6)(-5E0+2E1+E2+2E3) = 3\n\t\t// (1/6)(2E0-5E1+2E2+E3) = -1\n\t\t// (1/6)(E0+2E1-5E2+2E3) = -1\n\t\t// (1/6)(2E0+E1+2E2-5E3) = -1\n\t}\n\t\n\tstatic long[] tol(int[] a)\n\t{\n\t\tlong[] b = new long[a.length];\n\t\tfor(int i = 0;i < a.length;i++)b[i] = a[i];\n\t\treturn b;\n\t}\n\t\n\tpublic static long[] fwht(long[] a, int mod)\n\t{\n\t\tint n = a.length;\n\t\tassert (n&n-1) == 0;\n\t\ta = Arrays.copyOf(a, n);\n\t\tfor(int w = Integer.numberOfTrailingZeros(n)-1;w >= 0;w--){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(i<<~w>=0){\n\t\t\t\t\tlong nal = a[i]+a[i|1<<w];\n\t\t\t\t\tlong nar = a[i]-a[i|1<<w];\n\t\t\t\t\tif(nal >= mod)nal -= mod;\n\t\t\t\t\tif(nar < 0)nar += mod;\n\t\t\t\t\ta[i] = nal; a[i|1<<w] = nar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 998244353;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int inv(int a) {\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint m = 1 << n;\n\t\tint a[] = new int[m];\n\t\tint s = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ts = add(s, a[i] = scanInt());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint mask = m - 1 - (1 << i);\n\t\t\tfor (int j = mask;; j = (j - 1) & mask) {\n\t\t\t\tint x = a[j], y = a[j + (1 << i)];\n\t\t\t\ta[j] = add(x, y);\n\t\t\t\ta[j + (1 << i)] = sub(x, y);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\ta[i] = mul(mul(m, s), inv(sub(a[i], s)));\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint mask = m - 1 - (1 << i);\n\t\t\tfor (int j = mask;; j = (j - 1) & mask) {\n\t\t\t\tint x = a[j], y = a[j + (1 << i)];\n\t\t\t\ta[j] = add(x, y);\n\t\t\t\ta[j + (1 << i)] = sub(x, y);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint norm = inv(m);\n\t\tint sub = mul(a[0], norm);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tout.println(sub(mul(a[i], norm), sub));\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\n// a^-1 (mod m)\nlong modInv(long a, long m)\nin {\n  assert(m > 0, \"modInv: m > 0 must hold\");\n}\ndo {\n  long b = m, x = 1, y = 0, t;\n  for (; ; ) {\n    t = a / b;\n    a -= t * b;\n    if (a == 0) {\n      assert(b == 1 || b == -1, \"modInv: gcd(a, m) != 1\");\n      if (b == -1) {\n        y = -y;\n      }\n      return (y < 0) ? (y + m) : y;\n    }\n    x -= t * y;\n    t = b / a;\n    b -= t * a;\n    if (b == 0) {\n      assert(a == 1 || a == -1, \"modInv: gcd(a, m) != 1\");\n      if (a == -1) {\n        x = -x;\n      }\n      return (x < 0) ? (x + m) : x;\n    }\n    y -= t * x;\n  }\n}\n\nenum long MO = 998244353;\nenum INV2 = modInv(2, MO);\n\nint N;\nlong[] A;\n\nlong[] P;\n\nvoid hadamard(long[] z) {\n  foreach (e; 0 .. N) {\n    foreach (i; 0 .. 1 << N) {\n      const j = i ^ (1 << e);\n      if (i < j) {\n        const t = (z[i] + z[j]) % MO;\n        z[j] = (z[i] - z[j]) % MO;\n        z[i] = t;\n      }\n    }\n  }\n}\n\nvoid main() {\n  debug {\n    enum n = 3;\n    write(\"Det[{{-1\");\n    foreach (j; 1 .. 1 << n) {\n      write(\",0\");\n    }\n    write(\"}\");\n    foreach (i; 1 .. 1 << n) {\n      write(\",{\");\n      foreach (j; 0 .. 1 << n) {\n        if (j > 0) {\n          write(\",\");\n        }\n        if (i == j) {\n          foreach (k; 1 .. 1 << n) {\n            writef(\"-p%s\", k);\n          }\n        } else {\n          writef(\"p%s\", i ^ j);\n        }\n      }\n      write(\"}\");\n    }\n    writeln(\"}]\");\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      A = new long[1 << N];\n      foreach (i; 0 .. 1 << N) {\n        A[i] = readLong();\n      }\n      \n      long sumA;\n      foreach (i; 0 .. 1 << N) {\n        sumA += A[i];\n      }\n      P = new long[1 << N];\n      foreach (i; 0 .. 1 << N) {\n        P[i] = (A[i] * modInv(sumA, MO)) % MO;\n      }\n      \n      debug {\n        foreach (i; 1 .. 1 << N) {\n          long ans;\n          foreach (j; 1 .. 1 << N) {\n            if (popcnt(i & j) & 1) {\n              long sum;\n              foreach (k; 1 .. 1 << N) {\n                if (popcnt(j & k) & 1) {\n                  sum += P[k];\n                  sum %= MO;\n                }\n              }\n              ans += modInv(sum, MO);\n              ans %= MO;\n            }\n          }\n          writeln(\"brute \", i, \": \", ans);\n        }\n      }\n      \n      auto x = P.dup;\n      debug {\n        writeln(\"x = \", x);\n      }\n      x.hadamard;\n      debug {\n        writeln(\"x = \", x);\n      }\n      \n      auto y = new long[1 << N];\n      foreach (i; 1 .. 1 << N) {\n        long tmp = (x[0] - x[i]) % MO;\n        tmp *= INV2;\n        tmp %= MO;\n        y[i] = modInv(tmp, MO);\n      }\n      debug {\n        writeln(\"y = \", y);\n      }\n      y.hadamard;\n      debug {\n        writeln(\"y = \", y);\n      }\n      \n      writeln(0);\n      foreach (i; 1 .. 1 << N) {\n        long ans = (y[0] - y[i]) % MO;\n        ans *= INV2;\n        ans %= MO;\n        ans = (ans % MO + MO) % MO;\n        writeln(ans);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\n// a^-1 (mod m)\nlong modInv(long a, long m)\n/*in {\n  assert(m > 0, \"modInv: m > 0 must hold\");\n}\ndo*/ {\n  long b = m, x = 1, y = 0, t;\n  for (; ; ) {\n    t = a / b;\n    a -= t * b;\n    if (a == 0) {\n      assert(b == 1 || b == -1, \"modInv: gcd(a, m) != 1\");\n      if (b == -1) {\n        y = -y;\n      }\n      return (y < 0) ? (y + m) : y;\n    }\n    x -= t * y;\n    t = b / a;\n    b -= t * a;\n    if (b == 0) {\n      assert(a == 1 || a == -1, \"modInv: gcd(a, m) != 1\");\n      if (a == -1) {\n        x = -x;\n      }\n      return (x < 0) ? (x + m) : x;\n    }\n    y -= t * x;\n  }\n}\n\nenum long MO = 998244353;\nenum INV2 = modInv(2, MO);\n\nint N;\nlong[] A;\n\nlong[] P;\n\nvoid hadamard(long[] z) {\n  foreach (e; 0 .. N) {\n    foreach (i; 0 .. 1 << N) {\n      const j = i ^ (1 << e);\n      if (i < j) {\n        const t = (z[i] + z[j]) % MO;\n        z[j] = (z[i] - z[j]) % MO;\n        z[i] = t;\n      }\n    }\n  }\n}\n\nvoid main() {\n  debug {\n    enum n = 3;\n    write(\"Det[{{-1\");\n    foreach (j; 1 .. 1 << n) {\n      write(\",0\");\n    }\n    write(\"}\");\n    foreach (i; 1 .. 1 << n) {\n      write(\",{\");\n      foreach (j; 0 .. 1 << n) {\n        if (j > 0) {\n          write(\",\");\n        }\n        if (i == j) {\n          foreach (k; 1 .. 1 << n) {\n            writef(\"-p%s\", k);\n          }\n        } else {\n          writef(\"p%s\", i ^ j);\n        }\n      }\n      write(\"}\");\n    }\n    writeln(\"}]\");\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      A = new long[1 << N];\n      foreach (i; 0 .. 1 << N) {\n        A[i] = readLong();\n      }\n      \n      long sumA;\n      foreach (i; 0 .. 1 << N) {\n        sumA += A[i];\n      }\n      P = new long[1 << N];\n      foreach (i; 0 .. 1 << N) {\n        P[i] = (A[i] * modInv(sumA, MO)) % MO;\n      }\n      \n      debug {\n        foreach (i; 1 .. 1 << N) {\n          long ans;\n          foreach (j; 1 .. 1 << N) {\n            if (popcnt(i & j) & 1) {\n              long sum;\n              foreach (k; 1 .. 1 << N) {\n                if (popcnt(j & k) & 1) {\n                  sum += P[k];\n                  sum %= MO;\n                }\n              }\n              ans += modInv(sum, MO);\n              ans %= MO;\n            }\n          }\n          writeln(\"brute \", i, \": \", ans);\n        }\n      }\n      \n      auto x = P.dup;\n      debug {\n        writeln(\"x = \", x);\n      }\n      x.hadamard;\n      debug {\n        writeln(\"x = \", x);\n      }\n      \n      auto y = new long[1 << N];\n      foreach (i; 1 .. 1 << N) {\n        long tmp = (x[0] - x[i]) % MO;\n        tmp *= INV2;\n        tmp %= MO;\n        y[i] = modInv(tmp, MO);\n      }\n      debug {\n        writeln(\"y = \", y);\n      }\n      y.hadamard;\n      debug {\n        writeln(\"y = \", y);\n      }\n      \n      writeln(0);\n      foreach (i; 1 .. 1 << N) {\n        long ans = (y[0] - y[i]) % MO;\n        ans *= INV2;\n        ans %= MO;\n        ans = (ans % MO + MO) % MO;\n        writeln(ans);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define ll long long\ntemplate<class T> inline void read(T &x){\n\tx=0;register char c=getchar();register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\tif(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1<<18,mod=998244353;\nint n,s,inv_s,lim,a[N],f[N],g[N];\ninline int mid(int x){return x&1?(x+mod)>>1:x>>1;}\ninline int dec(int a,int b){return (a-=b)<0?a+mod:a;}\ninline int inc(int a,int b){return (a+=b)>=mod?a-mod:a;}\ninline int fpow(int a,int b){int s=1;for(;b;b>>=1,a=(ll)a*a%mod)if(b&1)s=(ll)s*a%mod;return s;}\nvoid fwt(int *a,void foo(int&,int&)){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=len<<1){\n\t\t\tfor(int j=0;j<len;j++)foo(a[i+j],a[i+j+len]);\n\t\t}\n}\nvoid trans(int &a,int &b){int x=a;a=inc(a,b),b=dec(x,b);}\nvoid i_trans(int &a,int &b){int x=a;a=mid(inc(a,b)),b=mid(dec(x,b));}\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=1<<n;\n\tfor(int i=0;i<lim;i++)read(a[i]),s=inc(s,a[i]);\n\tinv_s=fpow(s,mod-2);\n\tfor(int i=0;i<lim;i++)a[i]=(ll)a[i]*inv_s%mod,f[i]=lim-1;\n\tf[0]=mod-1,a[0]=dec(a[0],1);\n\tfwt(f,trans),fwt(a,trans);\n\tfor(int i=0;i<lim;i++)g[i]=(ll)f[i]*fpow(a[i],mod-2)%mod;\n\tfwt(g,i_trans);\n\t// for(int i=0;i<lim;i++)print(g[i],\" \\n\"[i==lim-1]);\n\tfor(int i=lim-1;i>=0;i--)g[i]=dec(g[0],g[i]);\n\tfor(int i=0;i<lim;i++)print(g[i],'\\n');\n}"
  },
  {
    "language": "Python",
    "code": "# Σ(i ^ j = k) ai * bj = ckという形で式が表されるとき\n# fwht(a)*fwht(b)=fwht(c)が成り立ち高速化できる\n# すごく必死に考えると\n# a = [p0 p1 p2 ... p2^N-1]\n# b = [x0 x1 x2 ... x2^N-1]\n# c = [2^N-1 -1 -1 -1 .... -1]\n# とするとうまいことaとcに変数が入らない形になるのでfwht(c)/fwht(a)を計算し\n# fwht(b)がわかるのでこれを逆変換すればbが求められる\n# なお逆変換は b = fwht(fwht(b)) / 要素数で求められる、なぜかは知らない\n# またまたなぜかは知らないがこうして求めた答えは各要素に定数が足されたものになるらしい\n# 今回はx0 = 0と分かっているのbを[0 x1-x0 ... x2^N-1-x0]と補正してやればよい\n\nN = int(input())\nA = [int(i) for i in input().split()]\nMOD = 998244353\n\nNN = 1 << N\n\ndef fwht(a) :\n    i = 1\n    while i < NN :\n        j = 0\n        while j < NN :\n            for k in range(i) :\n                x, y = a[j+k], a[i+j+k]\n                a[j+k], a[i+j+k] = (x + y) % MOD, (x - y) % MOD\n            j += i << 1\n        i <<= 1\n\ndef inv(x) :\n    return pow(x, MOD - 2, MOD)\n\ns = inv(sum(A) % MOD)\nfor i in range(NN) :\n    A[i] = (A[i] * s) % MOD\nA[0] = (A[0] - 1) % MOD\nfwht(A)\n\nB = [- 1] * (NN)\nB[0] = (NN-1) % MOD\nfwht(B)\n\nC = [(inv(A[i]) * B[i]) % MOD for i in range(NN)]\nfwht(C)\n\nfor i in range(NN) :\n    C[i] = (C[i] * inv(NN)) % MOD\n\nfor i in range(NN) :\n    print((C[i] - C[0]) % MOD)"
  },
  {
    "language": "Python",
    "code": "print(\"wakaranai\")"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nsys.setrecursionlimit(10000)\ninput = sys.stdin.readline\ndef g(l):\n    if not l:\n        return 0, 0\n    m,s = max(l), sum(l)\n    if 2*m > s:\n        return 2*m - s, (s-m)\n    return s % 2, s//2\n\ndef f(v, vs):\n    ks = []\n    r = 0\n    rkoma = 0\n    for u in d[v]:\n        if u in vs:\n            continue\n        vs.add(u)\n        k1, k2, koma = f(u, vs)\n        ks.append(k1)\n        rkoma += koma\n        r += k2\n    r1, r2 = g(ks)\n    # r1 深さの和、r2 操作の回数\n    rkoma += km[v]\n#    print(v, r1 + rkoma, r + r2, rkoma)\n    return r1 + rkoma, r + r2, rkoma\n\nN = int(input())\nkm = [0] + [int(i) for i in str(input().strip())]\nd = [set() for _ in range(N+1)]\n\nfor _ in range(N-1):\n    x, y = map(int, input().split())\n    d[x].add(y)\n    d[y].add(x)\n\nr = 10**10\nfor i in range(N):\n    a, b, c = f(i+1, {i+1})\n    if a == c:\n        r = min(r, b)\nprint(r if r != 10**10 else -1)\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        a: [i64; 1 << n],\n    }\n    let asum: i64 = a.iter().sum();\n    let mut a: Vec<_> = a.into_iter().map(|x| ModInt::new(x) * ModInt::new(asum).inv()).collect();\n    a[0] -= 1;\n    for i in 0..n {\n        for bits in 0..1 << n {\n            if (bits & 1 << i) == 0 {\n                let x = a[bits];\n                let y = a[bits ^ 1 << i];\n                a[bits] = x + y;\n                a[bits ^ 1 << i] = x - y;\n            }\n        }\n    }\n    let rhs = ModInt::new(1 << n);\n    let mut b = vec![ModInt::new(0); 1 << n];\n    for i in 1..1 << n {\n        b[i] = rhs * a[i].inv();\n        b[0] -= b[i];\n    }\n    let inv2 = ModInt::new(2).inv();\n    for i in 0..n {\n        for bits in 0..1 << n {\n            if (bits & 1 << i) == 0 {\n                let x = b[bits];\n                let y = b[bits ^ 1 << i];\n                b[bits] = (x + y) * inv2;\n                b[bits ^ 1 << i] = (x - y) * inv2;\n            }\n        }\n    }\n    for i in 0..1 << n {\n        puts!(\"{}\\n\", b[i]);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]