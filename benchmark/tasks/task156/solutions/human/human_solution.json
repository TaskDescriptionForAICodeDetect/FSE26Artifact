[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n + 1);\n\tvector<pair<pair<ll, pair<ll, ll>>,int>> y;\n\tvector<pair<pair<ll, ll>,int>> ts, te;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1, x2, y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tts.push_back({ { y1, x1 },i });\n\t\t\tte.push_back({ { y2, x2 },i });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({ { y1,{ x1,x2 } },i });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tsort(ALL(ts));\n\tsort(ALL(te));\n\tsort(ALL(y));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\t//vector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tfenwick_tree<int> ft(ax.size());\n\tint tsind = 0,tsend = 0;\n\n\tset<pii> ut;\n\tREP(i, ay.size()) {\n\t\tfor(; ts.size() > tsind; tsind++) {\n\t\t\tif (ts[tsind].first.first == ay[i]) {\n\t\t\t\tauto ind = lower_bound(ALL(ax), ts[tsind].first.second);\n\t\t\t\tft.add(ind-ax.begin(), 1);\n\t\t\t\tut.insert(make_pair( ind - ax.begin(), ts[tsind].second ));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tauto itrs = lower_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>)make_pair(make_pair(ay[i], make_pair(0, 0)), 0)),\n\t\t\titre = upper_bound(ALL(y),(pair<pair<ll, pair<ll, ll>>, int>) make_pair(make_pair(ay[i],make_pair(LLONG_MAX, LLONG_MAX)), INT_MAX));\n\t\tfor (auto itr = itrs; itr != itre; itr++) {\n\t\t\tint s = lower_bound(ALL(ax), itr->first.second.first)-ax.begin(), \n\t\t\t\te = lower_bound(ALL(ax), itr->first.second.second) - ax.begin();\n\t\t\tint tcou = ft.sum(s, e);\n\t\t\tauto sti = upper_bound(ALL(ut), make_pair(e, INT_MAX));\n\t\t\tREP(j, tcou) {\n\t\t\t\tsti--;\n\n\t\t\t\tif (uf.findSet(itr->second, sti->second)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(itr->second, sti->second);\n\t\t\t}\n\t\t}\n\t\tfor (; te.size() > tsend; tsend++) {\n\t\t\tif (te[tsend].first.first == ay[i]) {\n\n\t\t\t\tauto ind = lower_bound(ALL(ax), te[tsend].first.second);\n\t\t\t\tft.add(ind - ax.begin(), -1);\n\t\t\t\tut.erase(make_pair(ind - ax.begin(), te[tsend].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\tif (ST::Query(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(-1); S.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *----S.upper_bound(V.right);\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr);\n\t\t\tST::Insert(ll, rr);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nint target[MAXN*2];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\ttarget[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tDSU::P.PB(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(DSU::Union(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<cmath>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *++S.lower_bound(V.left-1);\n\t\t    int rr = *--S.upper_bound(V.right);\n\n\t\t    if (rr <= ll) continue;\n\n\t\t\tint count = seg.query(ll, rr+1);\n            //cout << \" \" << V.left << \" \"<< V.right << \" \" << count << endl;\n\t\t\t//cout << \" \" << ll << \" \"<< rr << \" \" << count << endl;\n\t\t\t//if(count < 2) continue;\n\t\t\tret += count - 1;\n\t\t\t//cout << V.left << \" \" << V.right << \" \" << *--S.upper_bound(V.right) << endl;\n\t\t\tseg.set_renew(ll, rr);\n\t\t\t//seg.set_renew(V.left, V.right-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <map>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int,int> pi;\n\nstruct line{int s, e, x;};\nbool cmp(line a, line b){return a.x < b.x;}\n\nstruct event{int px, py, num;};\nbool cmp2(event a, event b){return a.px < b.px;}\n\nstruct disj{\n    int pa[100005];\n    void init(int n){\n        for(int i=0; i<=n; i++) pa[i] = i;\n    }\n    int find(int x){\n        return pa[x] = (pa[x] == x ? x : find(pa[x]));\n    }\n    void uni(int p, int q){\n        pa[find(p)] = find(q);\n    }\n}disj;\n\nstruct bit{\n    int tree[200050], lim;\n    void init(int n){\n        lim = n+2;\n        memset(tree,0,sizeof(tree));\n    }\n    void add(int x, int v){\n        x += 2;\n        while(x <= lim){\n            tree[x] += v;\n            x += x & -x;\n        }\n    }\n    int sum(int x){\n        x += 2;\n        int ret = 0;\n        while(x){\n            ret += tree[x];\n            x -= x & -x;\n        }\n        return ret;\n    }\n    int range_sum(int s, int e){\n        return sum(e) - sum(s-1);\n    }\n}bit;\n\nstruct seg{\n    int tree[270000], eraser[270000];\n    void add(int s, int e, int ps, int pe, int p, int v){\n        for (int i=s; i<=e; i++){\n            tree[i] = v;\n        }\n    }\n    void erase(int s, int e, int ps, int pe, int p){\n        for (int i=s; i<=e; i++){\n            tree[i] = -1;\n        }\n    }\n    void fill(int s, int e, int ps, int pe, int p, int v){\n        for(int i=s; i<=e; i++){\n            if(tree[i] != -1) disj.uni(tree[i],v);\n        }\n    }\n}seg;\n\nvector<line> linex, liney;\nvector<int> vx, vy;\nvector<pi> extreme;\n\nvector<pi> sweep_add, sweep_del;\n\nlint vertex(){\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s + 1,i.x));\n        sweep_del.push_back(pi(i.e,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    lint ret = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1);\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    sort(extreme.begin(),extreme.end());\n    extreme.resize(unique(extreme.begin(),extreme.end()) - extreme.begin());\n    ret += extreme.size();\n    //printf(\"vertex = %lld\\n\",ret);\n    return ret;\n}\n\nlint edge(){\n    lint ret = 0;\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    for (auto &i : linex){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vx.size());\n    p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vy.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < liney.size() && liney[p3].x == i) {\n            ret += bit.range_sum(liney[p3].s+1,liney[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n //   printf(\"edge = %lld\\n\",ret);\n    return ret;\n}\n\nmap<int,int> mp;\nvector<event> event_add, event_del;\n\nint component(){\n    int pt = 0;\n    for (auto &i : liney){\n        event_add.push_back({i.s,i.x,pt});\n        event_del.push_back({i.e+1,i.x,pt});\n        pt++;\n    }\n    sort(event_add.begin(),event_add.end(),cmp2);\n    sort(event_del.begin(),event_del.end(),cmp2);\n    int p1 = 0, p2 = 0, p3 = 0;\n    int ret = 1;\n    disj.init((int)liney.size());\n    seg.erase(0,(int)vy.size()-1,0,(int)vy.size()-1,1);\n    for (int i=0; i<=vx.size(); i++) {\n        while (p2 < event_del.size() && event_del[p2].px == i) {\n            int py = event_del[p2].py;\n            seg.erase(py,py,0,(int)vy.size()-1,1);\n            mp.erase(mp.find(py));\n            p2++;\n        }\n        while (p1 < event_add.size() && event_add[p1].px == i) {\n            int py = event_add[p1].py;\n            \n            seg.add(py,py,0,(int)vy.size()-1,1,event_add[p1].num);\n            \n            mp[py] = event_add[p1].num;\n            p1++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            auto t = mp.lower_bound(linex[p3].s);\n            if(t == mp.end() || t->first > linex[p3].e){\n                ret++;\n                p3++;\n                continue;\n            }\n            seg.fill(linex[p3].s,linex[p3].e,0,(int)vy.size()-1,1,t->second);\n            p3++;\n        }\n    }\n    for (int i=1; i<liney.size(); i++) {\n        if(disj.find(0) != disj.find(i)){\n            disj.uni(0,i);\n            ret++;\n        }\n    }\n  //  printf(\"component = %d\\n\",ret);\n    return ret;\n}\n\nint main(){\n    int w,h,n;\n    scanf(\"%d %d %d\",&w,&h,&n);\n    linex.push_back({0,h,0});\n    linex.push_back({0,h,w});\n    liney.push_back({0,w,0});\n    liney.push_back({0,w,h});\n    vx.push_back(0);\n    vy.push_back(0);\n    vx.push_back(w);\n    vy.push_back(h);\n    extreme.push_back(pi(0,0));\n    extreme.push_back(pi(0,h));\n    extreme.push_back(pi(w,0));\n    extreme.push_back(pi(w,h));\n    for (int i=0; i<n; i++) {\n        int a,b,c,d;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n        vx.push_back(a);\n        vx.push_back(c);\n        vy.push_back(b);\n        vy.push_back(d);\n        extreme.push_back(pi(a,b));\n        extreme.push_back(pi(a,d));\n        extreme.push_back(pi(c,b));\n        extreme.push_back(pi(c,d));\n        if(a == c){\n            linex.push_back({b,d,a});\n        }\n        else{\n            liney.push_back({a,c,b});\n        }\n    }\n    sort(vx.begin(),vx.end());\n    sort(vy.begin(),vy.end());\n    vx.resize(unique(vx.begin(),vx.end()) - vx.begin());\n    vy.resize(unique(vy.begin(),vy.end()) - vy.begin());\n    for (auto &i : linex){\n        i.s = (int)(lower_bound(vy.begin(),vy.end(),i.s) - vy.begin());\n        i.e = (int)(lower_bound(vy.begin(),vy.end(),i.e) - vy.begin());\n        i.x = (int)(lower_bound(vx.begin(),vx.end(),i.x) - vx.begin());\n    }\n    for (auto &i : liney){\n        i.s = (int)(lower_bound(vx.begin(),vx.end(),i.s) - vx.begin());\n        i.e = (int)(lower_bound(vx.begin(),vx.end(),i.e) - vx.begin());\n        i.x = (int)(lower_bound(vy.begin(),vy.end(),i.x) - vy.begin());\n    }\n    sort(linex.begin(),linex.end(),cmp);\n    sort(liney.begin(),liney.end(),cmp);\n    printf(\"%lld\",edge() - vertex() + component());\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass unionfind {\npublic:\n\tclass node {\n\tpublic:\n\t\tll r, o, n;\n\t};\n\n\tnode* d;\n\n\tvoid init(ll n) {\n\t\td = new node[n];\n\t\tfor (ll i = 0; i < n; i++) {\n\t\t\td[i].o = i;\n\t\t\td[i].r = 0;\n\t\t\td[i].n = 1;\n\t\t}\n\t}\n\n\tll find(ll a) {\n\t\tif (d[a].o == a) {\n\t\t\treturn a;\n\t\t}\n\t\treturn d[a].o = find(d[a].o);\n\t}\n\n\tvoid unit(ll a, ll b) {\n\t\tif (d[a].r > d[b].r) {\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse if (d[a].r == d[b].r) {\n\t\t\td[a].r++;\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse {\n\t\t\td[a].o = b;\n\t\t\td[a].n = 0;\n\t\t}\n\t}\n};\n\nclass bit {\npublic:\n\tll n;\n\tll* d;\n\t\n\tvoid init(ll nw) {\n\t\tn = nw;\n\t\td = new ll[n];\n\t\tfor (ll i = 0; i < n; i++) {\n\t\t\td[i] = 0;\n\t\t}\n\t}\n\n\tvoid add(ll b, ll x) {\n\t\tfor (ll i = b + 1; i <= n; i += (i & -i)) {\n\t\t\td[i - 1] += x;\n\t\t}\n\t}\n\n\tll sum(ll b) {\n\t\tll all = 0;\n\t\tfor (ll i = b + 1; i > 0; i -= (i & -i)) {\n\t\t\tall += d[i - 1];\n\t\t}\n\t\treturn all;\n\t}\n};\n\nll n1, n2;\n\nclass path {\npublic:\n\tll z, s, t;\n};\n\npath pl1[100100];\npath pl2[100100];\n\npath p1[100100];\npath p2[100100];\n\nll pp[100100];\nll pn;\n\nll bfind(ll a) {\n\tll b = 0;\n\tll e = pn;\n\twhile (e - b > 1) {\n\t\tll m = (b + e) / 2;\n\t\tif (a < pp[m]) {\n\t\t\te = m;\n\t\t}\n\t\telse {\n\t\t\tb = m;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid zpress() {\n\tfor (ll i = 0; i < n1; i++) {\n\t\tpp[i] = pl1[i].z;\n\t}\n\tsort(pp, pp + n1);\n\tpn = unique(pp, pp + n1) - pp;\n\tfor (ll i = 0; i < n1; i++) {\n\t\tp1[i].z = bfind(pl1[i].z);\n\t\tp1[i].s = pl1[i].s;\n\t\tp1[i].t = pl1[i].t;\n\t}\n\tfor (ll i = 0; i < n2; i++) {\n\t\tp2[i].z = pl2[i].z;\n\t\tp2[i].s = bfind(pl2[i].s);\n\t\tif (pp[p2[i].s] < pl2[i].s) {\n\t\t\tp2[i].s++;\n\t\t}\n\t\tp2[i].t = bfind(pl2[i].t);\n\t}\n}\n\npair<ll, pair<ll, pair<ll, ll> > > tmp[1000000];\n\nint main() {\n\tll w, h, n;\n\tscanf(\"%lld%lld%lld\", &w, &h, &n);\n\tn1 = 0;\n\tn2 = 0;\n\tpl1[n1].z = 0;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl1[n1].z = w;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl2[n2].z = 0;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tpl2[n2].z = h;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tfor (ll i = 0; i < n; i++) {\n\t\tll a, b, c, d;\n\t\tscanf(\"%lld%lld%lld%lld\", &a, &b, &c, &d);\n\t\tif (a == c) {\n\t\t\tpl1[n1].z = a;\n\t\t\tpl1[n1].s = b;\n\t\t\tpl1[n1].t = d;\n\t\t\tn1++;\n\t\t}\n\t\telse {\n\t\t\tpl2[n2].z = b;\n\t\t\tpl2[n2].s = a;\n\t\t\tpl2[n2].t = c;\n\t\t\tn2++;\n\t\t}\n\t}\n\tzpress();\n\tll now = 0;\n\tfor (ll i = 0; i < n1; i++) {\n\t\ttmp[now++] = make_pair(p1[i].s, make_pair(0, make_pair(p1[i].z, 0)));\n\t\ttmp[now++] = make_pair(p1[i].t, make_pair(2, make_pair(p1[i].z, 0)));\n\t}\n\tfor (ll i = 0; i < n2; i++) {\n\t\ttmp[now++] = make_pair(p2[i].z, make_pair(1, make_pair(p2[i].s, p2[i].t)));\n\t}\n\tsort(tmp, tmp + now);\n\tll ans = 0;\n\tunionfind uf;\n\tuf.init((n + 10) * 10);\n\tll unow = 0;\n\tmap<ll, ll> ss;\n\tmap<ll, ll> nj;\n\tnj[-1] = unow++;\n\tbit bb;\n\tbb.init(n + 100);\n\tfor (ll i = 0; i < now; i++) {\n\t\t/*for (auto j : nj) {\n\t\t\tprllf(\"%d:%d \", j.first, j.second);\n\t\t}\n\t\tprllf(\"\\n\");*/\n\t\tauto w = tmp[i];\n\t\tif (w.second.first == 0) {\n\t\t\tbb.add(w.second.second.first, 1);\n\t\t\tauto it = nj.lower_bound(w.second.second.first);\n\t\t\tit--;\n\t\t\tif (it != nj.end()) {\n\t\t\t\tll nn;\n\t\t\t\tif ((*it).second < 0) {\n\t\t\t\t\tnn = unow++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn = (*it).second;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = nn;\n\t\t\t\tss[(*it).first] = nn;\n\t\t\t\tnj[w.second.second.first] = nn;\n\t\t\t\tss[w.second.second.first] = nn;\n\t\t\t}\n\t\t}\n\t\telse if (w.second.first == 1) {\n\t\t\tauto it = ss.lower_bound(w.second.second.first);\n\t\t\twhile (1) {\n\t\t\t\tauto itit = nj.find((*it).first);\n\t\t\t\titit++;\n\t\t\t\tif (itit == nj.end() || (*itit).first > w.second.second.second) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = -1;\n\t\t\t\tans--;\n\t\t\t\tauto itw = it;\n\t\t\t\tit++;\n\t\t\t\tss.erase(itw);\n\t\t\t}\n\t\t\tans += max((ll)0, bb.sum(w.second.second.second) - bb.sum(w.second.second.first - 1) - 1);\n\t\t\t//printf(\"%d:%d,%d %d\\n\", w.first, w.second.second.first, w.second.second.second, ans);\n\t\t}\n\t\telse {\n\t\t\tbb.add(w.second.second.first, -1);\n\t\t\tauto it = nj.find(w.second.second.first);\n\t\t\tauto it2 = it;\n\t\t\tit2--;\n\t\t\tif ((*it).second >= 0) {\n\t\t\t\tif ((*it2).second < 0) {\n\t\t\t\t\tnj[(*it2).first] = (*it).second;\n\t\t\t\t\tss[(*it2).first] = (*it).second;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll aw = uf.find((*it).second);\n\t\t\t\t\tll bw = uf.find((*it2).second);\n\t\t\t\t\tif (aw != bw) {\n\t\t\t\t\t\tuf.unit(aw, bw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.erase((*it).first);\n\t\t\tnj.erase(it);\n\t\t}\n\t}\n\tfor (ll i = 0; i < unow; i++) {\n\t\tans += uf.d[i].n;\n\t}\n\tans--;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 4* MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        //cout << \" Insert: \" << a << \" \" << b << \" \" << xs.size() << endl;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE; r += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE; r += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\t//if (ST::Query(p)){\n\tif (seg.is_renew(p)){\n\n        //cout << \"?!\" << endl;\n\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\t//cout << V.left << \" \" << lf << endl;\n\t\t\t//cout << target[V.left] << \" \" << target[lf] << endl;\n\t\t\t//target[V.left] = target[lf];\n\t\t\t//cout << \"Joint: \" <<  target[V.left] << \" \" << target[lf] << endl;\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n        //cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nclass union_find {\nprivate:\n\tvector<int>parent;\n\tvector<int>rank;\n\tvector<int>clump;\npublic:\n\tunion_find(int siz) {\n\t\tparent.resize(siz);\n\t\trank.resize(siz);\n\t\tclump.resize(siz);\n\t\tfor (int i = 0; i < siz; ++i) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tclump[i] = 1;\n\t\t}\n\t}\n\tvoid unite(int x, int y) {\n\t\tint xr = find(x);\n\t\tint yr = find(y);\n\t\tif (xr == yr)return;\n\t\tif (rank[xr] > rank[yr]) {\n\t\t\tparent[yr] = xr;\n\t\t\tclump[xr] += clump[yr];\n\t\t}\n\t\telse if (rank[yr] > rank[xr]) {\n\t\t\tparent[xr] = yr;\n\t\t\tclump[yr] += clump[xr];\n\t\t}\n\t\telse if (xr != yr) {\n\t\t\tparent[yr] = xr;\n\t\t\tclump[xr] += clump[yr];\n\t\t\t++rank[xr];\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\tbool check(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn clump[find(x)];\n\t}\n};\n\nstruct line {\n\tbool dir;//false:横 true:縦\n\tLL pos;\n\tLL b1, b2;\n\tint id;\n\tline(bool dir, LL pos, LL b1, LL b2, int id)\n\t\t:dir(dir), pos(pos), b1(b1), b2(b2), id(id)\n\t{}\n\tbool operator<(const line& o) const {\n\t\tif (pos == o.pos) {\n\t\t\tif (b1 == o.b1) {\n\t\t\t\treturn b2 < o.b2;\n\t\t\t}\n\t\t\treturn b1 < o.b1;\n\t\t}\n\t\treturn pos < o.pos;\n\t}\n};\nvector<line>vec;\nvector<LL>tate;\nLL W, H, N;\n\ntemplate<typename T>\nclass BIT {\nprivate:\n\tvector<T>arr;\n\tint siz;\npublic:\n\tBIT(int n) :siz(1) {\n\t\twhile (siz < n)siz *= 2;\n\t\tarr.resize(siz + 1);\n\t}\n\t//[0,x)までの和を取得する\n\tT query(int x) const {\n\t\tT s = 0;\n\t\twhile (x > 0) {\n\t\t\ts += arr[x];\n\t\t\tx -= (x & -x);\n\t\t}\n\t\treturn s;\n\t}\n\t//xに値kを加算する\n\tvoid add(int x, const T& k) {\n\t\t++x;\n\t\twhile (x <= siz) {\n\t\t\tarr[x] += k;\n\t\t\tx += (x & -x);\n\t\t}\n\t}\n};\n\n\nvector<LL>border;\nvector<vector<pair<pair<LL, LL>, int>>>seg;\nint segwidth = 1;\n\nvoid query(int a, int b, union_find& uf, int id, int yok, int k = 0, int l = 0, int r = -1) {\n\tif (r < 0)r = segwidth;\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\t//マージする\n\t\tif (seg[k].empty())return;\n\t\tint lim = -1;\n\t\tint endid = 0;\n\t\tfor (int xx = seg[k].size() - 1; xx >= 0; --xx) {\n\t\t\tif (seg[k][xx].first.first >= yok) {\n\t\t\t\tlim = xx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (seg[k][xx].first.first < yok && yok < seg[k][xx].first.second) {\n\t\t\t\tuf.unite(id, seg[k][xx].second);\n\t\t\t\tendid = seg[k][xx].second;\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tauto very = seg[k][seg[k].size() - 1];\n\t\tvery.second = endid;\n\t\tfor (int xx = seg[k].size() - 1; xx > lim; --xx) {\n\t\t\tflag = true;\n\t\t\tvery.first.first = min(very.first.first, seg[k][xx].first.first);\n\t\t\tvery.first.second = max(very.first.second, seg[k][xx].first.second);\n\t\t\tseg[k].pop_back();\n\t\t}\n\t\tif (flag) {\n\t\t\tseg[k].push_back(very);\n\t\t}\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tquery(a, b, uf, id, yok, k * 2 + 1, l, mid);\n\tquery(a, b, uf, id, yok, k * 2 + 2, mid, r);\n}\n\nint main(void)\n{\n\tcin >> W >> H >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tLL a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tif (a == c) {\n\t\t\t//縦\n\t\t\tLL up = min(b, d);\n\t\t\tLL dn = max(b, d);\n\t\t\tvec.push_back({ true,a * 2,up * 3 - 1,dn * 3 + 1 ,i });\n\t\t\ttate.push_back(up * 3 - 1);\n\t\t\ttate.push_back(dn * 3 + 1);\n\t\t\tborder.push_back(up * 3 - 1);\n\t\t\tborder.push_back(dn * 3 + 1);\n\t\t}\n\t\telse {\n\t\t\t//横\n\t\t\tLL lf = min(a, c);\n\t\t\tLL rh = max(a, c);\n\t\t\tvec.push_back({ false, b * 3,2 * lf - 1,2 * rh + 1,i });\n\t\t\ttate.push_back(b * 3);\n\t\t}\n\t}\n\tvec.push_back({ true,0,-1,H * 3 + 1 ,(int)N });\n\tvec.push_back({ true,W * 2,-1,H * 3 + 1,(int)N + 1 });\n\tvec.push_back({ false,0,-1,W * 2 + 1 ,(int)N + 2 });\n\tvec.push_back({ false,H * 3,-1,W * 2 + 1 ,(int)N + 3 });\n\ttate.push_back(0);\n\ttate.push_back(H * 3);\n\ttate.push_back(-1);\n\ttate.push_back(H * 3 + 1);\n\tborder.push_back(-1);\n\tborder.push_back(H * 3 + 1);\n\tsort(tate.begin(), tate.end());\n\ttate.erase(unique(tate.begin(), tate.end()), tate.end());\n\tsort(border.begin(), border.end());\n\tborder.erase(unique(border.begin(), border.end()), border.end());\n\tN += 4;\n\tLL M = tate.size();\n\tmap<LL, int>inv;\n\tfor (int i = 0; i < M; ++i) {\n\t\tinv[tate[i]] = i;\n\t}\n\tvector<pair<LL, pair<LL, LL>>>events;\n\tLL crossnum = 0;\n\tfor (auto& elm : vec) {\n\t\tif (elm.dir) {\n\t\t\tevents.push_back({ elm.pos,{ elm.b1,elm.b2 } });\n\t\t}\n\t\telse {\n\t\t\tevents.push_back({ elm.b1,{ elm.pos,elm.pos } });\n\t\t\tevents.push_back({ elm.b2,{ elm.pos,elm.pos } });\n\t\t}\n\t}\n\tBIT<int>bit(M);\n\tsort(events.begin(), events.end());\n\tfor (auto& elm : events) {\n\t\tif (elm.second.first == elm.second.second) {\n\t\t\tint index = inv[elm.second.first];\n\t\t\tif (bit.query(index + 1) - bit.query(index)) {\n\t\t\t\tbit.add(index, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbit.add(index, 1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint rind = inv[elm.second.second];\n\t\t\tint lind = inv[elm.second.first];\n\t\t\tcrossnum += (bit.query(rind) - bit.query(lind));\n\t\t}\n\t}\n\tassert(border.size());\n\tint rawwidth = border.size() - 1;\n\twhile (segwidth < rawwidth) {\n\t\tsegwidth *= 2;\n\t}\n\tseg.resize(segwidth * 2 - 1);\n\t//横の線分をセグ木に入れていく\n\tfor (auto& elm : vec) {\n\t\tif (!elm.dir) {\n\t\t\tLL y = elm.pos;\n\t\t\tint index = lower_bound(border.begin(), border.end(), y) - border.begin();\n\t\t\tif (index != 0 && index != border.size()) {\n\t\t\t\t//index-1番目に格納する\n\t\t\t\tseg[index - 1 + segwidth - 1].push_back({ { elm.b1,elm.b2 } ,elm.id });\n\t\t\t}\n\t\t}\n\t}\n\t//セグ木情報を上に伝播させていく\n\tfor (int k = segwidth - 2; k >= 0; --k) {\n\t\tfor (auto& par : seg[k * 2 + 1]) {\n\t\t\tseg[k].push_back(par);\n\t\t}\n\t\tfor (auto& par : seg[k * 2 + 2]) {\n\t\t\tseg[k].push_back(par);\n\t\t}\n\t}\n\t//セグ木内部の線分を区分ごとにソートする(stack的に後ろから見る)\n\tfor (int k = 0; k < segwidth * 2 - 1; ++k) {\n\t\tsort(seg[k].rbegin(), seg[k].rend());\n\t}\n\t//縦直線をクエリで処理\n\tunion_find uf(N);\n\tsort(vec.begin(), vec.end());\n\tfor (auto&elm : vec) {\n\t\tif (elm.dir) {\n\t\t\tint lef = lower_bound(border.begin(), border.end(), elm.b1) - border.begin();\n\t\t\tint rht = lower_bound(border.begin(), border.end(), elm.b2) - border.begin();\n\t\t\tquery(lef, rht, uf, elm.id, elm.pos);\n\t\t}\n\t}\n\t//親の種類数で断定\n\tset<int>parset;\n\tfor (int i = 0; i < N; ++i) {\n\t\tparset.insert(uf.find(i));\n\t}\n\tLL groupnum = parset.size();\n\tLL answer = crossnum + groupnum - N;\n\tcout << answer << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n+1);\n\tvector<pair<int,pair<ll,pair<ll, ll>>>> y,t;\n\tvector<ll> ax, ay;\n\tREP(i, n) {\n\t\tll x1, y1,x2,y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == x2) {\n\t\t\tt.push_back({ i,{ x1,{y1,y2} } });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({i,{ y1,{x1,x2} } });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\tvector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tREP(i, y.size()) {\n\t\tint yy = lower_bound(ALL(ay), y[i].second.first) - ay.begin();\n\t\tint x1 = lower_bound(ALL(ax), y[i].second.second.first) - ax.begin();\n\t\tint x2 = lower_bound(ALL(ax), y[i].second.second.second) - ax.begin();\n\t\talx[x1][yy] = y[i].first+1;\n\t\talx[x2][yy] = -(y[i].first+1);\n\t}\n\tREP(i, t.size()) {\n\t\tint xx = lower_bound(ALL(ax), t[i].second.first) - ax.begin();\n\t\tint y1 = lower_bound(ALL(ay), t[i].second.second.first) - ay.begin();\n\t\tint y2 = lower_bound(ALL(ay), t[i].second.second.second) - ay.begin();\n\t\taly[xx][y1] = t[i].first+1;\n\t\taly[xx][y2] = -(t[i].first+1);\n\t}\n\tint ans = 1;\n\tREP(i, ax.size()) {\n\t\tREP(j, ay.size()) {\n\t\t\tif (i < ax.size() - 1 && alx[i][j]>0 && !alx[i+1][j]) {\n\t\t\t\talx[i + 1][j] = alx[i][j];\n\t\t\t}\n\t\t\tif (j < ay.size() - 1 && aly[i][j]>0 && !aly[i][j+1]) {\n\t\t\t\taly[i][j + 1] = aly[i][j];\n\t\t\t}\n\n\t\t\tif(alx[i][j] && aly[i][j]){\n\t\t\t\tint a = abs(alx[i][j])-1, b = abs(aly[i][j])-1;\n\t\t\t\tif (uf.findSet(a,b)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(a,b);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int SEG=1<<17;\nint cnt[SEG*2];\nbool put[SEG*2];\nint dat[SEG*2];\n\ninline void push(int k){\n    if(!put[k])return;\n    dat[k]=cnt[k];\n    if(k<SEG-1){\n        put[k*2+1]=put[k*2+2]=1;\n    }\n    put[k]=0;\n}\n\nvoid update(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        put[k]=1;\n        push(k);\n        return;\n    }\n    update(a,b,k*2+1,l,(l+r)/2);\n    update(a,b,k*2+2,(l+r)/2,r);\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n}\n\nvoid pushAll(int k){\n    if(k)pushAll((k-1)/2);\n    else{\n        push(k);\n    }\n    if(k<SEG-1){\n        push(k*2+1);\n        push(k*2+2);\n    }\n}\n\nvoid addLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    cnt[kk]++;\n    while(kk){\n        kk=(kk-1)/2;\n        cnt[kk]++;\n    }\n}\n\nvoid remLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    cnt[kk]--;\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        cnt[kk]--;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nvoid toZero(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nint aggregate(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    return aggregate(a,b,k*2+1,l,(l+r)/2)+aggregate(a,b,k*2+2,(l+r)/2,r);\n}\n\nstruct UF{\n    vint par,cnt;\n    void init(int n){\n        par.resize(n);cnt.resize(n);\n        rep(i,n){\n            par[i]=i;\n            cnt[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        cnt[x]+=cnt[y];\n        par[y]=x;\n    }\n};\n\nint W,H,N;\n\nvint xs;\nset<tuple<int,int,int>>abn;\nset<int>ls;\nUF uf;\nint tail;\n\nset<tuple<int,int,int>>::iterator obtain(int l,int r){\n    if(r==-1){\n        auto it=abn.lower_bound(make_tuple(l,-1,-1));\n        if(it==abn.end()||get<0>(*it)!=l)return abn.end();\n        return it;\n    }\n    else{\n        auto it=abn.lower_bound(make_tuple(r,-1,-1));\n        if(it==abn.begin())return abn.end();\n        it--;\n        if(get<1>(*it)!=r)return abn.end();\n        return it;\n    }\n}\n\nvoid query1(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=ls.lower_bound(x);\n    int r=*it;\n    it--;\n    int l=*it;\n    auto it2=obtain(l,-1);\n    if(it2!=abn.end()){\n        int id;\n        tie(l,r,id)=*it2;\n        abn.erase(it2);\n        abn.insert(make_tuple(l,x,id));\n        abn.insert(make_tuple(x,r,id));\n        uf.cnt[uf.find(id)]++;\n    }\n    else{\n        toZero(l);\n        abn.insert(make_tuple(l,x,tail));\n        abn.insert(make_tuple(x,r,tail));\n        uf.cnt[tail]=2;\n        tail++;\n    }\n    ls.insert(x);\n    addLine(x);\n}\n\nvoid query2(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=obtain(-1,x);\n    auto it2=obtain(x,-1);\n\n    auto itit=ls.lower_bound(x);\n    itit++;int r=*itit;itit--;itit--;int l=*itit;\n\n    if(it!=abn.end()){\n        if(it2!=abn.end()){\n            int id=get<2>(*it),id2=get<2>(*it2);\n            uf.unite(id,id2);uf.cnt[uf.find(id)]--;\n            abn.erase(it);it2=obtain(x,-1);abn.erase(it2);\n            abn.insert(make_tuple(l,r,id));\n        }\n        else{\n            int id=get<2>(*it);\n            abn.erase(it);abn.insert(make_tuple(l,r,id));\n        }\n    }\n    else{\n        if(it2!=abn.end()){\n            int id=get<2>(*it2);\n            toZero(l);\n            abn.erase(it2);abn.insert(make_tuple(l,r,id));\n        }\n        else{\n\n        }\n    }\n    ls.erase(x);remLine(x);\n}\n\nint query3(int x,int xx){\n    //cout<<x<<\" \"<<xx<<\"------------\"<<endl;\n    //each(it,abn)cout<<get<0>(*it)<<\" \"<<get<1>(*it)<<\" \"<<get<2>(*it)<<endl;\n\n    x=lower_bound(all(xs),x)-xs.begin();\n    xx=upper_bound(all(xs),xx)-xs.begin()-1;\n    auto itit=ls.lower_bound(x);\n    if(itit==ls.end())return 0;\n    x=*itit;\n    itit=ls.upper_bound(xx);\n    if(itit==ls.begin())return 0;\n    itit--;\n    xx=*itit;\n    if(x>=xx)return 0;\n\n    int ret=aggregate(x,xx);\n\n    while(true){\n        auto it=abn.lower_bound(make_tuple(x,-1,-1));\n        if(it==abn.end()||get<0>(*it)>=xx)break;\n        int id=get<2>(*it);\n        if(--uf.cnt[uf.find(id)]==0)ret++;\n        abn.erase(it);\n    }\n    update(x,xx);\n    return ret;\n}\n\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&N);\n\n    xs.pb(0);xs.pb(W);\n    vector<tuple<int,int,int>>evs;\n    evs.pb(make_tuple(0*3+1,0,W));\n    evs.pb(make_tuple(H*3+1,0,W));\n\n    rep(i,N){\n        int a,b,c,d;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);\n        if(a==c){\n            evs.pb(make_tuple(b*3,a,114514));\n            evs.pb(make_tuple(d*3+2,a,1919810));\n            xs.pb(a);\n        }\n        else{\n            evs.pb(make_tuple(b*3+1,a,c));\n        }\n    }\n\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    sort(all(evs));\n\n    addLine(0);\n\n    ls.insert(0);ls.insert(xs.size()-1);\n    uf.init(N*3);\n\n    int ans=0;\n    bool flag=false;\n    for(auto &latte:evs){\n        int y,x,xx;\n        tie(y,x,xx)=latte;\n\n        if(y!=0&&!flag){\n            flag=true;\n            abn.clear();\n        }\n\n        if(xx==114514)query1(x);\n        else if(xx==1919810)query2(x);\n        else{\n            ans+=query3(x,xx);\n            //cout<<ans<<endl;\n        }\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\n public:\n  Compression(const std::vector<int>& list) : value_(list) {\n    std::sort(begin(value_), end(value_));\n    value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n    for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n  }\n  int size() const {return value_.size();}\n  int index(const int v) const {return index_.at(v);}\n  int operator[](const int i) const {return value_.at(i);}\n private:\n  std::unordered_map<int, int> index_;\n  std::vector<int> value_;\n};\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node *l_child, *r_child;\n  };\n  inline void push(Node *n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node *n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node *n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node *root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  vector<int> x = {W};\n  for(auto& q: event) {\n    x.emplace_back(q.x1);\n    x.emplace_back(q.x2);\n  }\n  Compression cx(x);\n  for(auto& q: event) {q.x1 = cx.index(q.x1); q.x2 = cx.index(q.x2);}\n\n  SegmentTree flag(cx.index(W));\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, cx.index(W));\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define y1 y233\nusing ll = long long;\nusing pii = pair <int, int>;\n\nconst int N = 1e5L + 11;\nconst int M = N * 4 + 11;\nconst int inf = 2e9L;\n\nint x1[N], y1[N], x2[N], y2[N];\n\nint lowbit(int x) { return x & (-x); }\nstruct BIT {\n\tint b[M];\n\tvoid clear() { fill(b, b + M, 0); }\n\tvoid change(int p, int x) {\n\t\tfor(p += 5; p < M; p += lowbit(p))\n\t\t\tb[p] += x;\n\t}\n\tint query(int p) {\n\t\tint r = 0;\n\t\tfor(p += 5; p; p -= lowbit(p))\n\t\t\tr += b[p];\n\t\treturn r;\n\t}\n}bit;\n\nstruct event {\n\tint p, type, k1, k2, id;\n\tbool operator <(event e) const {\n\t\treturn tie(p, type, k1, k2, id) < tie(e.p, e.type, e.k1, e.k2, e.id);\n\t}\n};\n\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\t\n\t{\n\t\tmap <int, int> mp;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tmp[x1[i]] = 0; mp[y1[i]] = 0;\n\t\t\tmp[x2[i]] = 0; mp[y2[i]] = 0;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(auto &p : mp)\n\t\t\tp.second = ++ cnt;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\t//swap(x1[i], y1[i]); swap(x2[i], y2[i]);\n\t\t\tx1[i] = mp[x1[i]]; y1[i] = mp[y1[i]];\n\t\t\tx2[i] = mp[x2[i]]; y2[i] = mp[y2[i]];\n\t\t}\n\t}\n\t\n\tvector <event> eves; int cnt = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(x1[i] == x2[i]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\teves.pb({y1[i], 0, x1[i], 1, ++ cnt});\n\t\t\teves.pb({y2[i] + 1, 0, x1[i], -1, cnt});\n\t\t} else {\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\teves.pb({y1[i], 1, x1[i], x2[i], 0});\n\t\t}\n\tiota(p, p + cnt + 1, 0);\n\tsort(eves.begin(), eves.end());\n\n\tset <pii> sts, stp;\n\tfor(int i = 0; i < M; i ++)\n\t\tsts.insert({i, i});\n\tstp.insert({M, 0});\n\n\tll m = 0, sp = 0;\n\tbit.clear();\n\tfor(auto e : eves)\n\t\tif(e.type == 0) {\n\t\t\tbit.change(e.k1, e.k2);\n\n\t\t\tif(e.k2 == 1) {\n\t\t\t\tstp.insert({e.k1, e.id});\n\t\t\t\tpii p = *(-- sts.lower_bound({e.k1, inf})); sts.erase(p);\n\t\t\t\tif(p.fi != e.k1) sts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, e.k1});\n\t\t\t\tif(p.se != e.k1) sts.insert({e.k1 + 1, p.se});\n\t\t\t} else\n\t\t\t\tstp.erase({e.k1, e.id});\n\t\t} else {\n\t\t\tm += bit.query(e.k2);\n\t\t\tm -= bit.query(e.k1 - 1);\n\n\t\t\tauto it = stp.lower_bound({e.k1, 0});\n\t\t\tif(it -> first > e.k2) { sp ++; continue; }\n\t\t\tint x = it -> second;\n\n\t\t\tit = -- sts.lower_bound({e.k1, inf});\n\n\t\t\tif(it -> fi != e.k1) {\n\t\t\t\tpii p = *it; sts.erase(it);\n\t\t\t\tsts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, p.se});\n\t\t\t\tit = -- sts.lower_bound({e.k1, inf});\n\t\t\t}\n\t\t\tint l = it -> fi, r;\n\n\t\t\twhile(it -> fi <= e.k2) {\n\t\t\t\tif(it -> se > e.k2) {\n\t\t\t\t\tpii p = *it; sts.erase(it);\n\t\t\t\t\tsts.insert({p.fi, e.k2});\n\t\t\t\t\tsts.insert({e.k2 + 1, p.se});\n\t\t\t\t\tit = -- sts.lower_bound({p.fi, inf});\n\t\t\t\t}\n\n\t\t\t\tr = it -> se;\n\t\t\t\tauto is = stp.lower_bound({it -> fi, 0});\n\t\t\t\tif(is -> fi <= it -> se) {\n\t\t\t\t\tint y = is -> se;\n\t\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\t\tif(a != b) p[b] = a;\n\t\t\t\t}\n\t\t\t\tis = it ++;\n\t\t\t\tsts.erase(is);\n\t\t\t}\n\t\t\tsts.insert({l, r});\n\t\t}\n\tll ans = m - n + sp;\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tif(find(i) == i) ans ++;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n public:\n  int find(int x) {return (p_[x] == x) ? x : find(p_[x]);}\n  void unite(int a, int b) {p_[find(b)] = find(a);}\n  int make() {p_.push_back(p_.size()); return p_.size() - 1;}\n private:\n  vector<int> p_;\n};\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = make_unique<Node>();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    unique_ptr<Node> l_child, r_child;\n  };\n  inline void push(const unique_ptr<Node>& n) {\n    if(not n->l_child) n->l_child = make_unique<Node>();\n    if(not n->r_child) n->r_child = make_unique<Node>();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  unique_ptr<Node> root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int left, right;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.left != r.left) return l.left < r.left;\n    return l.right < r.right;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.left; ++q.right;}\n\n  SegmentTree flag(W);\n  UnionFind group;\n  set<Node> node;\n  node.emplace(group.make(), 0, W);\n  long long ans = 0;\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;\n//     cout<<ans<<endl;\n//     cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.left<<\" \"<<q.right<<endl;\n      auto n = node.upper_bound(q.left);\n      --n;\n      if(n->right == q.left) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? group.make() : n->id;\n      auto j = group.make();\n      ans += f;\n      group.unite(i, j);\n      node.emplace(i, n->left, q.left);\n      node.emplace(j, q.left, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.left<<\" \"<<q.right<<endl;\n      auto l = node.upper_bound(q.left);\n      --l;\n      if(q.left != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      auto i = fl ? group.make() : l->id;\n      auto j = fr ? group.make() : r->id;\n      ans += fl + fr - 1;\n      if(group.find(i) == group.find(j)) ans += 1;\n      group.unite(i, j);\n      node.emplace(j, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.left<<\" \"<<q.right<<endl;\n      auto l = node.upper_bound(q.left);\n      auto r = node.upper_bound(q.right);\n      --l;\n      --r;\n      if(l->left != q.left) ++l;\n      if(r->right != q.right) --r;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;\n//   cout<<endl;\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\n public:\n  Compression(const std::vector<int>& list) : value_(list) {\n    std::sort(begin(value_), end(value_));\n    value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n    for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n  }\n  int size() const {return value_.size();}\n  int index(const int v) const {return index_.at(v);}\n  int operator[](const int i) const {return value_.at(i);}\n private:\n  std::unordered_map<int, int> index_;\n  std::vector<int> value_;\n};\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node *l_child, *r_child;\n  };\n  inline void push(Node *n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node *n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node *n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node *root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  vector<int> x = {0, W};\n  for(auto& q: event) {\n    x.emplace_back(q.x1);\n    x.emplace_back(q.x2);\n  }\n  Compression cx(x);\n  for(auto& q: event) {q.x1 = cx.index(q.x1); q.x2 = cx.index(q.x2);}\n\n  SegmentTree flag(cx.index(W));\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, cx.index(W));\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int SEG=1<<17;\nset<int>st[SEG*2];\nbool put[SEG*2];\nint dat[SEG*2];\n\ninline void push(int k){\n    if(!put[k])return;\n    dat[k]=st[k].size();\n    if(k<SEG-1){\n        put[k*2+1]=put[k*2+2]=1;\n    }\n    put[k]=0;\n}\n\nvoid update(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        put[k]=1;\n        push(k);\n        return;\n    }\n    update(a,b,k*2+1,l,(l+r)/2);\n    update(a,b,k*2+2,(l+r)/2,r);\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n}\n\nvoid pushAll(int k){\n    if(k)pushAll((k-1)/2);\n    push(k);\n    if(k<SEG-1){\n        push(k*2+1);\n        push(k*2+2);\n    }\n}\n\nvoid addLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].insert(k);\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].insert(k);\n    }\n}\n\nvoid remLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].erase(k);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].erase(k);\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nvoid toZero(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nint aggregate(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    return aggregate(a,b,k*2+1,l,(l+r)/2)+aggregate(a,b,k*2+2,(l+r)/2,r);\n}\n\nstruct UF{\n    vint par,cnt;\n    void init(int n){\n        par.resize(n);cnt.resize(n);\n        rep(i,n){\n            par[i]=i;\n            cnt[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        cnt[x]+=cnt[y];\n        par[y]=x;\n    }\n};\n\nint W,H,N;\n\nvint xs;\nset<tuple<int,int,int>>abn;\nset<int>ls;\nUF uf;\nint tail;\n\nset<tuple<int,int,int>>::iterator obtain(int l,int r){\n    if(r==-1){\n        auto it=abn.lower_bound(make_tuple(l,-1,-1));\n        if(it==abn.end()||get<0>(*it)!=l)return abn.end();\n        return it;\n    }\n    else{\n        auto it=abn.lower_bound(make_tuple(r,-1,-1));\n        if(it==abn.begin())return abn.end();\n        it--;\n        if(get<1>(*it)!=r)return abn.end();\n        return it;\n    }\n}\n\nvoid query1(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=ls.lower_bound(x);\n    int r=*it;\n    it--;\n    int l=*it;\n    auto it2=obtain(l,-1);\n    if(it2!=abn.end()){\n        int id;\n        tie(l,r,id)=*it2;\n        abn.erase(it2);\n        abn.insert(make_tuple(l,x,id));\n        abn.insert(make_tuple(x,r,id));\n        uf.cnt[uf.find(id)]++;\n    }\n    else{\n        toZero(l);\n        abn.insert(make_tuple(l,x,tail));\n        abn.insert(make_tuple(x,r,tail));\n        uf.cnt[tail]=2;\n        tail++;\n    }\n    ls.insert(x);\n    addLine(x);\n}\n\nvoid query2(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=obtain(-1,x);\n    auto it2=obtain(x,-1);\n\n    auto itit=ls.lower_bound(x);\n    itit++;int r=*itit;itit--;itit--;int l=*itit;\n\n    if(it!=abn.end()){\n        if(it2!=abn.end()){\n            int id=get<2>(*it),id2=get<2>(*it2);\n            uf.unite(id,id2);uf.cnt[uf.find(id)]--;\n            abn.erase(it);it2=obtain(x,-1);abn.erase(it2);\n            abn.insert(make_tuple(l,r,id));\n        }\n        else{\n            int id=get<2>(*it);\n            abn.erase(it);abn.insert(make_tuple(l,r,id));\n        }\n    }\n    else{\n        if(it2!=abn.end()){\n            int id=get<2>(*it2);\n            toZero(l);\n            abn.erase(it2);abn.insert(make_tuple(l,r,id));\n        }\n        else{\n\n        }\n    }\n    ls.erase(x);remLine(x);\n}\n\nint query3(int x,int xx){\n    x=lower_bound(all(xs),x)-xs.begin();\n    xx=upper_bound(all(xs),xx)-xs.begin()-1;\n    if(x>=xx)return 0;\n\n    int ret=aggregate(x,xx);\n    while(true){\n        auto it=abn.lower_bound(make_tuple(x,-1,-1));\n        if(it==abn.end()||get<0>(*it)>=xx)break;\n        int id=get<2>(*it);\n        if(--uf.cnt[uf.find(id)]==0)ret++;\n        abn.erase(it);\n    }\n    update(x,xx);\n    return ret;\n}\n\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&N);\n\n    xs.pb(0);xs.pb(W);\n    vector<tuple<int,int,int>>evs;\n    evs.pb(make_tuple(H*3+1,0,W));\n\n    rep(i,N){\n        int a,b,c,d;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);\n        if(a==c){\n            evs.pb(make_tuple(b*3,a,114514));\n            evs.pb(make_tuple(d*3+2,a,1919810));\n            xs.pb(a);\n        }\n        else{\n            evs.pb(make_tuple(b*3+1,a,c));\n        }\n    }\n\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    sort(all(evs));\n\n    addLine(0);\n    update(0,xs.size()-1);\n\n    ls.insert(0);ls.insert(W);\n    uf.init(N*3);\n\n    int ans=0;\n    for(auto &latte:evs){\n        int y,x,xx;\n        tie(y,x,xx)=latte;\n        if(xx==114514)query1(x);\n        else if(xx==1919810)query2(x);\n        else ans+=query3(x,xx);\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr == ll) continue;\n\n\t\t\tret += seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\t//cout << V.left << \" \" << lf << endl;\n\t\t\t//cout << target[V.left] << \" \" << target[lf] << endl;\n\t\t\t//target[V.left] = target[lf];\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI Y; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 1, Y.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        y1 = LBD(Y, y1); y2 = LBD(Y, y2); if(y1 == y2){\n            A.PB(Event(x1, 0, y1, y2));\n            A.PB(Event(x2, 2, y1, y2));\n        }else{\n            A.PB(Event(x1, 1, y1, y2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0)); L.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H)); L.PB(Line(0,H,W,H));\n\n\tY.PB(-1); ECH(it, L) Y.PB(it->y1), Y.PB(it->y2); UNQ(Y);\n\tBIT::n = Y.size(); S.insert(0); DSU::P.resize(Y.size(), 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\t//cout << V.left << \" \" << lf << endl;\n\t\t\t//cout << target[V.left] << \" \" << target[lf] << endl;\n\t\t\t//target[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n+1);\n\tvector<pair<int,pair<ll,pair<ll, ll>>>> y,t;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1,x2,y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tt.push_back({ i,{ x1,{y1,y2} } });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({i,{ y1,{x1,x2} } });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\t//vector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\tmap<pii, int> al;\n\tREP(i, y.size()) {\n\t\tint yy = lower_bound(ALL(ay), y[i].second.first) - ay.begin();\n\t\tint x1 = lower_bound(ALL(ax), y[i].second.second.first) - ax.begin();\n\t\tint x2 = lower_bound(ALL(ax), y[i].second.second.second) - ax.begin();\n\t\trep(j, x1, x2 + 1) {\n\t\t\tal[{j, yy}] = y[i].first+1;\n\t\t}\n\t}\n\tREP(i, t.size()) {\n\t\tint xx = lower_bound(ALL(ax), t[i].second.first) - ax.begin();\n\t\tint y1 = lower_bound(ALL(ay), t[i].second.second.first) - ay.begin();\n\t\tint y2 = lower_bound(ALL(ay), t[i].second.second.second) - ay.begin();\n\t\trep(j, y1, y2 + 1) {\n\t\t\tif (al[{xx, j}]) {\n\t\t\t\tif (uf.findSet(al[{xx, j}]-1, t[i].first)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(al[{xx, j}] - 1, t[i].first);\n\t\t\t}\n\t\t\telse \n\t\t\t\tal[{xx, j}] = t[i].first+1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nconst int INF = 1004567890;\n\n//0-based index???????????????????????°??????????????????\nnamespace bit\n{\n\tint arr[234567];\n\tint siz;\n\tvoid init(int n)\n\t{\n\t\t++n;\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t}\n\tvoid add(int ind, int val)\n\t{\n\t\tind++;\n\t\twhile (ind <= siz)\n\t\t{\n\t\t\tarr[ind] += val;\n\t\t\tind += (ind & -ind);\n\t\t}\n\t}\n\tint query(int right)\n\t{\n\t\tint ret = 0;\n\t\twhile (right > 0)\n\t\t{\n\t\t\tret += arr[right];\n\t\t\tright -= (right & -right);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nnamespace uf\n{\n\tvector<int>par, rnk;\n\tint vnum, gnum;\n\tvoid init() { vnum = 1; gnum = 1; par.push_back(0); rnk.push_back(0); }\n\tint addleaf()\n\t{\n\t\tpar.push_back(vnum);\n\t\trnk.push_back(0);\n\t\t++vnum;\n\t\t++gnum;\n\t\treturn vnum - 1;\n\t}\n\tint getpar(int x)\n\t{\n\t\tif (x == par[x])return x;\n\t\treturn par[x] = getpar(par[x]);\n\t}\n\tbool issame(int a, int b)\n\t{\n\t\treturn getpar(a) == getpar(b);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b)return;\n\t\t--gnum;\n\t\tif (rnk[a] < rnk[b])\n\t\t{\n\t\t\tpar[a] = b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tif (rnk[a] == rnk[b])rnk[a]++;\n\t\t}\n\t}\n}\n\nnamespace sgt\n{\n\tbool buf[234567];\n\tint width;\n\tvoid init(int n)\n\t{\n\t\twidth = 1;\n\t\twhile (width < n)width <<= 1;\n\t}\n\tvoid change_raw(int a, int b, int k, int l, int r)\n\t{\n\t\tif (b <= l || r <= a)return;\n\t\tif (l <= a && b <= r)\n\t\t{\n\t\t\tbuf[k] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tchange_raw(a, b, k + k + 1, l, m);\n\t\t\tchange_raw(a, b, k + k + 2, m, r);\n\t\t}\n\t}\n\tvoid change(int a, int b)\n\t{\n\t\tchange_raw(a, b, 0, 0, width);\n\t}\n\tvoid deflag_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return;\n\t\tbuf[k] = false;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return;\n\t\tdeflag_raw(x, k + k + 1, l, m);\n\t\tdeflag_raw(x, k + k + 2, m, r);\n\t}\n\tvoid deflag(int x)\n\t{\n\t\tdeflag_raw(x, 0, 0, width);\n\t}\n\tbool check_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return false;\n\t\tif (buf[k])return true;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return false;\n\t\treturn check_raw(x, k + k + 1, l, m) || check_raw(x, k + k + 2, m, r);\n\t}\n\tbool check(int x)\n\t{\n\t\treturn check_raw(x, 0, 0, width);\n\t}\n}\n\nenum QueryType { SPLIT, MERGE, CHANGE };\nstruct query\n{\n\tQueryType type;\n\tint yval;\n\tint xval1, xval2;\n\tquery(QueryType t, int y, int x1, int x2 = 0)\n\t\t:type(t), yval(y), xval1(x1), xval2(x2)\n\t{}\n};\n\nint w, h, n;\nvector<int>xlist;\nvector<query>que;\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tque.reserve(n * 2);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tif (a == c)\n\t\t{\n\t\t\tif (b > d)swap(b, d);\n\t\t\tque.push_back({ SPLIT, b + b - 1, a });\n\t\t\tque.push_back({ MERGE, d + d + 1, a });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)swap(a, c);\n\t\t\tque.push_back({ CHANGE, b + b, a, c });\n\t\t}\n\t\txlist.push_back(a);\n\t\txlist.push_back(c);\n\t}\n\txlist.push_back(-INF);\n\txlist.push_back(0);\n\txlist.push_back(w);\n\tque.push_back({ SPLIT, -1, 0 });\n\tque.push_back({ SPLIT, -1, w });\n\tque.push_back({ MERGE, h + h + 1, 0 });\n\tque.push_back({ MERGE, h + h + 1, w });\n\tque.push_back({ CHANGE, 0,0,w });\n\tque.push_back({ CHANGE, h + h,0,w });\n\tsort(que.begin(), que.end(), [](const query& q1, const query& q2) {return q1.yval < q2.yval; });\n\tsort(xlist.begin(), xlist.end());\n\txlist.erase(unique(xlist.begin(), xlist.end()), xlist.end());\n\tset<pair<int, int>>bar;//first=left,second=index\n\tbar.insert({ -INF, 0 });\n\tint splitnum = 0;\n\tuf::init();\n\tsgt::init(xlist.size());\n\tbit::init(xlist.size());\n\tfor (auto& qq : que)\n\t{\n\t\tswitch (qq.type)\n\t\t{\n\t\tcase SPLIT:\n\t\t{\n\t\t\t//BIT???????????°????????????(???????????????1?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, 1);\n\t\t\t//?????????????????????????????????index?????\\???\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\t--itr;\n\t\t\tint index = itr->second;\n\t\t\t//??????????????´??°????¢???????\n\t\t\tint left = itr->first;\n\t\t\tint id = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(id))\n\t\t\t{\n\t\t\t\tindex = uf::addleaf();\n\t\t\t\tsgt::deflag(id);\n\t\t\t}\n\t\t\t//??????index??¨?????????????????????\n\t\t\tbar.insert({ qq.xval1, index });\n\t\t\t//???????¶????????????°??????????????¨??\\????????????\n\t\t\tbar.erase(pair<int, int>(itr->first, itr->second));\n\t\t\tbar.insert({ left, index });\n\t\t\tbreak;\n\t\t}\n\t\tcase MERGE:\n\t\t{\n\t\t\t//BIT???????????°????¶????(???????????????0?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, -1);\n\t\t\t//???????????¨????????????\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\tint rightindex = itr->second;\n\t\t\tint oldright = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint right = itr->first;\n\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), right) - xlist.begin();\n\t\t\tif (sgt::check(rid))\n\t\t\t{\n\t\t\t\trightindex = uf::addleaf();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t--itr;\n\t\t\tint leftindex = itr->second;\n\t\t\tint oldleft = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint left = itr->first;\n\t\t\tint lid = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(lid))\n\t\t\t{\n\t\t\t\tleftindex = uf::addleaf();\n\t\t\t\tsgt::deflag(lid);\n\t\t\t}\n\t\t\t//union find??¨??§??±?????????\n\t\t\tuf::unite(leftindex, rightindex);\n\t\t\t//??????????¶????????????°?????????????????\\??????\n\t\t\tbar.erase(pair<int, int>(right, oldright));\n\t\t\tbar.erase(pair<int, int>(left, oldleft));\n\t\t\tbar.insert({ left, leftindex });\n\t\t\tbreak;\n\t\t}\n\t\tcase CHANGE:\n\t\t{\n\t\t\t//????????£???????????????????¢????\n\t\t\tint lind = lower_bound(xlist.begin(), xlist.end(), qq.xval1) - xlist.begin();\n\t\t\tint rind = upper_bound(xlist.begin(), xlist.end(), qq.xval2) - xlist.begin();\n\t\t\t//????????????????????\\????????????\n\t\t\tsgt::change(lind, rind);\n\t\t\t//????????´??°\n\t\t\tsplitnum += max(0, bit::query(rind) - bit::query(lind) - 1);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tint answer = splitnum - (uf::vnum - uf::gnum);\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\n            //cout << \" \" << V.left << \" \"<< V.right << endl;\n\n\t\t    if (rr <= ll) continue;\n\n\t\t\tint count = seg.query(ll, rr+1);\n\n\t\t\t//cout << \" \" << ll << \" \"<< rr << \" \" << count << endl;\n\n\t\t\t//if(count < 2) continue;\n\t\t\tret += count - 1;\n\t\t\t//cout << V.left << \" \" << V.right << \" \" << *--S.upper_bound(V.right) << endl;\n\t\t\tseg.set_renew(ll, rr);\n\t\t\t//seg.set_renew(V.left, V.right-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Point;\nstruct Event {\n  int y, idx, type;\n  bool operator<(const Event& e) const {\n    if(y == e.y) return(type < e.type);\n    return(y < e.y);\n  }\n};\n \nstruct UnionFind {\n  vector< int > data;\n  int Inner;\n  UnionFind(): Inner(0) {};\n  int Make()\n  {\n    ++Inner;\n    data.push_back(-1);\n    return(data.size() - 1);\n  }\n  void Unite(int a, int b)\n  {\n    a = Find(a), b = Find(b);\n    if(a == b) return;\n    --Inner;\n    if(data[a] > data[b]) swap(a, b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n  int Find(int k)\n  {\n    if(data[k] < 0) return(k);\n    else return(data[k] = Find(data[k]));\n  }\n  int Size()\n  {\n    return(Inner);\n  }\n};\n \n \nint main()\n{\n  int W, H, N;\n  vector< Point > S, T;\n  vector< int > X, Y;\n \n  scanf(\"%d %d %d\", &W, &H, &N);\n  for(int i = 0; i < N; i++) {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n \n    X.push_back(A), X.push_back(C);\n    Y.push_back(B), Y.push_back(D);\n    S.push_back(Point(A, B));\n    T.push_back(Point(C, D));\n  }\n \n  S.push_back(Point(0, 0));\n  T.push_back(Point(W, 0));\n  S.push_back(Point(0, 0));\n  T.push_back(Point(0, H));\n  S.push_back(Point(W, 0));\n  T.push_back(Point(W, H));\n  S.push_back(Point(0, H));\n  T.push_back(Point(W, H));\n \n  N += 4;\n \n  X.push_back(0), X.push_back(W);\n  Y.push_back(0), Y.push_back(H);\n \n  sort(X.begin(), X.end());\n  sort(Y.begin(), Y.end());\n  X.erase(unique(X.begin(), X.end()), X.end());\n  Y.erase(unique(Y.begin(), Y.end()), Y.end());\n \n  for(int i = 0; i < N; i++) {\n    S[i].first  = lower_bound(X.begin(), X.end(), S[i].first ) - X.begin();\n    S[i].second = lower_bound(Y.begin(), Y.end(), S[i].second) - Y.begin();\n    T[i].first  = lower_bound(X.begin(), X.end(), T[i].first ) - X.begin();\n    T[i].second = lower_bound(Y.begin(), Y.end(), T[i].second) - Y.begin();\n  }\n \n \n  vector< Event > Events;\n  /*\n    type = 1: Y?????????????????????\n    type = 3: Y????????????????¶????\n    type = 2: X????????????\n  */\n  for(int i = 0; i < N; i++) {\n    if(S[i].first == T[i].first) {\n      Events.push_back((Event){S[i].second, i, 1});\n      Events.push_back((Event){T[i].second, i, 3});\n    } else {\n      Events.push_back((Event){S[i].second, i, 2});\n    }\n  }\n  sort(Events.begin(), Events.end());\n \n  UnionFind uf;\n  set< Point > Pool;\n  Pool.insert(Point(-1145141919, uf.Make()));\n \n  // ???????????§???????????????(??????\n \n  int sz = -1;\n  for(int i = 0; i < Events.size(); i++) {\n    const Event& e = Events[i];\n    const int& x = S[e.idx].first;\n \n    if(e.type == 1) {\n \n      set< Point >::iterator ptr = --Pool.lower_bound(Point(x, -1));\n      Pool.insert(Point(x, ptr -> second));\n    } else if(e.type == 3) {\n \n      set< Point >::iterator ptr = --Pool.lower_bound(Point(x, -1));\n \n      int u = ptr -> second;\n      ++ptr;\n      int v = ptr -> second;\n      uf.Unite(u, v);\n      Pool.erase(ptr);\n \n    } else {\n      const int& x2 = T[e.idx].first;\n \n      queue< Point > next;\n      set< Point >::iterator ptr = Pool.lower_bound(Point(x, -1));\n      set< Point >::iterator ptr2 = Pool.lower_bound(Point(x2, 11451419));\n      if(ptr == ptr2) continue;\n      --ptr2;\n      while(ptr != ptr2) { // ???????????°??¨???????????¨????????????????????????\n        next.push(Point(ptr -> first, uf.Make()));\n        ++ptr;\n      }\n \n      while(!next.empty()) {\n        Pool.erase(Pool.lower_bound(Point(next.front().first, -1)));\n        Pool.insert(next.front()); next.pop();\n      }\n    }\n  }\n \n  cout << uf.Size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define y1 y233\nusing ll = long long;\nusing pii = pair <int, int>;\n\nconst int N = 1e5L + 11;\nconst int M = N * 4 + 11;\nconst int inf = 2e9L;\n\nint x1[N], y1[N], x2[N], y2[N];\n\nint lowbit(int x) { return x & (-x); }\nstruct BIT {\n\tint b[M];\n\tvoid clear() { fill(b, b + M, 0); }\n\tvoid change(int p, int x) {\n\t\tfor(p += 5; p < M; p += lowbit(p))\n\t\t\tb[p] += x;\n\t}\n\tint query(int p) {\n\t\tint r = 0;\n\t\tfor(p += 5; p; p -= lowbit(p))\n\t\t\tr += b[p];\n\t\treturn r;\n\t}\n}bit;\n\nstruct event {\n\tint p, type, k1, k2, id;\n\tbool operator <(event e) const {\n\t\treturn tie(p, type, k1, k2, id) < tie(e.p, e.type, e.k1, e.k2, e.id);\n\t}\n};\n\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\t\n\t{\n\t\tmap <int, int> mp;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tmp[x1[i]] = 0; mp[y1[i]] = 0;\n\t\t\tmp[x2[i]] = 0; mp[y2[i]] = 0;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(auto &p : mp)\n\t\t\tp.second = ++ cnt;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\t//swap(x1[i], y1[i]); swap(x2[i], y2[i]);\n\t\t\tx1[i] = mp[x1[i]]; y1[i] = mp[y1[i]];\n\t\t\tx2[i] = mp[x2[i]]; y2[i] = mp[y2[i]];\n\t\t}\n\t}\n\t\n\tvector <event> eves; int cnt = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(x1[i] == x2[i]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\teves.pb({y1[i], 0, x1[i], 1, ++ cnt});\n\t\t\teves.pb({y2[i] + 1, 0, x1[i], -1, cnt});\n\t\t} else {\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\teves.pb({y1[i], 1, x1[i], x2[i], 0});\n\t\t}\n\tiota(p, p + cnt + 1, 0);\n\tsort(eves.begin(), eves.end());\n\n\tset <pii> sts, stp;\n\tfor(int i = 0; i < M; i ++)\n\t\tsts.insert({i, i});\n\tstp.insert({M, 0});\n\n\tll m = 0, sp = 0;\n\tbit.clear();\n\tfor(auto e : eves)\n\t\tif(e.type == 0) {\n\t\t\tbit.change(e.k1, e.k2);\n\n\t\t\tif(e.k2 == 1) {\n\t\t\t\tstp.insert({e.k1, e.id});\n\t\t\t\tpii p = *(-- sts.lower_bound({e.k1, inf})); sts.erase(p);\n\t\t\t\tif(p.fi != e.k1) sts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, e.k1});\n\t\t\t\tif(p.se != e.k1) sts.insert({e.k1 + 1, p.se});\n\t\t\t} else {\n\t\t\t\tstp.erase({e.k1, e.id});\n\t\t\t}\n\t\t} else {\n\t\t\tm += bit.query(e.k2);\n\t\t\tm -= bit.query(e.k1 - 1);\n\n\t\t\tauto it = stp.lower_bound({e.k1, 0});\n\t\t\tif(it -> first > e.k2) { sp ++; continue; }\n\t\t\tint x = it -> second;\n\n\t\t\tit = -- sts.lower_bound({e.k1, inf});\n\t\t\tint l = it -> first, r = it -> second;\n\t\t\twhile(1) {\n\t\t\t\tr = it -> second;\n\t\t\t\tauto is = stp.lower_bound({it -> first, 0});\n\t\t\t\tif(is -> first <= it -> second) {\n\t\t\t\t\tint y = is -> second;\n\t\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\t\tif(a != b) p[b] = a;\n\t\t\t\t}\n\n\t\t\t\tis = it ++;\n\t\t\t\tif(is -> second >= e.k2) { sts.erase(is); break; }\n\t\t\t\tsts.erase(is);\n\t\t\t}\n\t\t\tsts.insert({l, r});\n\t\t}\n\tint ans = m - n + sp;\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tif(find(i) == i) ans ++;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define y1 y233\nusing ll = long long;\nusing pii = pair <int, int>;\n\nconst int N = 1e5L + 11;\nconst int M = N * 4 + 11;\n\nint x1[N], y1[N], x2[N], y2[N];\n\nint lowbit(int x) { return x & (-x); }\nstruct BIT {\n\tint b[M];\n\tvoid clear() { fill(b, b + M, 0); }\n\tvoid change(int p, int x) {\n\t\tfor(p += 5; p < M; p += lowbit(p))\n\t\t\tb[p] += x;\n\t}\n\tint query(int p) {\n\t\tint r = 0;\n\t\tfor(p += 5; p; p -= lowbit(p))\n\t\t\tr += b[p];\n\t\treturn r;\n\t}\n}bit;\n\nstruct event {\n\tint p, type, k1, k2, id;\n\tbool operator <(event e) const {\n\t\treturn tie(p, type, k1, k2, id) < tie(e.p, e.type, e.k1, e.k2, e.id);\n\t}\n};\n\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\t{\n\t\tmap <int, int> mp;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tmp[x1[i]] = 0; mp[y1[i]] = 0;\n\t\t\tmp[x2[i]] = 0; mp[y2[i]] = 0;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(auto &p : mp)\n\t\t\tp.second = ++ cnt;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tx1[i] = mp[x1[i]]; y1[i] = mp[y1[i]];\n\t\t\tx2[i] = mp[x2[i]]; y2[i] = mp[y2[i]];\n\t\t}\n\t}\n\tvector <event> eves; int cnt = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(x1[i] == x2[i]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\teves.pb({y1[i], 0, x1[i], 1, ++ cnt});\n\t\t\teves.pb({y2[i] + 1, 0, x1[i], -1, cnt});\n\t\t} else {\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\teves.pb({y1[i], 1, x1[i], x2[i], 0});\n\t\t}\n\tiota(p, p + cnt + 1, 0);\n\tsort(eves.begin(), eves.end());\n\n\tset <pii> sts, stp;\n\tfor(int i = 0; i < M; i ++)\n\t\tsts.insert({i, i});\n\tstp.insert({M, 0});\n\n\tll m = 0;\n\tbit.clear();\n\tfor(auto e : eves)\n\t\tif(e.type == 0) {\n\t\t\tbit.change(e.k1, e.k2);\n\n\t\t\tif(e.k2 == 1) {\n\t\t\t\tstp.insert({e.k1, e.id});\n\t\t\t\tpii p = *sts.lower_bound({e.k1, 0}); sts.erase(p);\n\t\t\t\tif(p.fi != e.k1) sts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, e.k1});\n\t\t\t\tif(p.se != e.k1) sts.insert({e.k1 + 1, p.se});\n\t\t\t} else {\n\t\t\t\tstp.erase({e.k1, e.id});\n\t\t\t}\n\t\t} else {\n\t\t\tm += bit.query(e.k2);\n\t\t\tm -= bit.query(e.k1 - 1);\n\n\t\t\tauto it = stp.lower_bound({e.k1, 0});\n\t\t\tif(it -> first > e.k2) { m ++; continue; }\n\t\t\tint x = it -> second;\n\n\t\t\tit = sts.lower_bound({e.k1, 0});\n\t\t\tif(e.k1 != it -> fi) it --;\n\t\t\tint l = it -> first, r = it -> second;\n\t\t\twhile(1) {\n\t\t\t\tauto is = stp.lower_bound({it -> first, 0});\n\t\t\t\tif(is -> first <= it -> second) {\n\t\t\t\t\tint y = is -> second;\n\t\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\t\tif(a != b) p[b] = a;\n\t\t\t\t}\n\n\t\t\t\tis = it ++;\n\t\t\t\tr = it -> second;\n\t\t\t\tif(is -> second >= e.k2) { sts.erase(is); break; }\n\t\t\t\tsts.erase(is);\n\t\t\t}\n\t\t\tsts.insert({l, r});\n\t\t}\n\tint ans = m - n;\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tif(find(i) == i) ans ++;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1);\n\t\t\tS.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        x1 = LBD(xs, x1); x2 = LBD(xs, x2);\n        if(x1 == x2){\n            A.PB(Event(y1, 0, x1, x2));\n            A.PB(Event(y2, 2, x1, x2));\n        }else{\n            A.PB(Event(y1, 1, x1, x2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0));\n\tL.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H));\n\tL.PB(Line(0,H,W,H));\n\n\txs.PB(-1); REP(i, n) xs.PB(L[i].x1), xs.PB(L[i].x2); UNQ(xs);\n\tBIT::n = xs.size(); S.insert(0); DSU::P.resize(xs.size()+1, 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\nstruct Node {\n  int left, id;\n  Node(int x, int i = 2e9) : left(x), id(i) {}\n  bool operator<(const Node& n) const {return left != n.left ? left < n.left : id < n.id;}\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node* l_child;\n    Node* r_child;\n  };\n  inline void push(Node* n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node* n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node* n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node* root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  SegmentTree flag(W);\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(0, id);\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      auto right = (n == end(node)) ? W : n->left;\n      if(right == q.x1) continue;\n      --n;\n      auto f = flag.find(n->left);\n      flag.add(n->left, right - 1, -f);\n      id += 1 + f;\n      group.unite(n->id, id);\n      node.emplace(n->left, id);\n      group.unite(id, id + 1);\n      node.emplace(q.x1, ++id);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto right = (l == end(node)) ? W : l->left;\n      --l;\n      auto r = l--;\n      if(r->left != q.x1) continue;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, r->left - 1, -fl);\n      flag.add(r->left, right - 1, -fr);\n      group.unite(l->id, ++id);\n      group.unite(r->id, ++id);\n      auto il = fl ? id + fl : id - 1;\n      auto ir = fr ? id + fl + fr : id;\n      group.unite(il, ir);\n      node.emplace(l->left, id += fl + fr);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      auto right = (r == end(node)) ? W : r->left;\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(right != q.x2) right = r->left;\n      if(right <= l->left) continue;\n      flag.add(l->left, right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\t//if(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\n\tusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\npii Dir[] = {\n\t{ 0, 1 },{ -1 ,1 },{ -1, 0 },\n\t{ -1 ,-1 },{ 0,-1 },{ 1 ,-1 },\n\t{ 1,0 },{ 1 ,1 }\n};\n#define N (1<<17) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy = max(seg[2*k].lazy,seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2 * k + 1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum,seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl,vr);\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\nsigned main() {\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\n\tvector<pair<pair<ll, pll>, int>> ho;\n\tvector<pair<pll, int>> vs, ve;\n\tvector<ll> ax, ay;\n\tmap<ll, int> px, py;\n\n\tUnionFind uf(n + 1);\n\tint koutennsuu = 0;\n\tREP(i, n) {\n\t\tll sx, sy, ex, ey;\n\t\tscanf(\"%lld %lld %lld %lld\", &sx, &sy, &ex, &ey);\n\t\tif (sx == ex) {\n\t\t\tvs.push_back({ { sy, sx },i });\n\t\t\tve.push_back({ { ey, ex },i });\n\t\t}\n\t\telse {\n\t\t\tho.push_back({ { sy,{ sx,ex } },i });\n\t\t}\n\n\t\tif (!sx || !sy || !ex || !ey) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\t\tif (sx == w || ex == w || sy == h || ey == h) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\n\t\tax.push_back(sx);\n\t\tax.push_back(ex);\n\t\tay.push_back(sy);\n\t\tay.push_back(ey);\n\t}\n\tsort(ALL(ho));\n\tsort(ALL(vs));\n\tsort(ALL(ve));\n\tsort(ALL(ax));\n\tax.erase(unique(ALL(ax)),ax.end());\n\tsort(ALL(ay));\n\tay.erase(unique(ALL(ay)),ay.end());\n\tREP(i, ax.size()) {\n\t\tpx[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tpy[ay[i]] = i;\n\t}\n\n\tfenwick_tree<int> fw(ax.size());\n\tset < pii > ylist;\n\tint hoinp = 0, hooup = 0, vep = 0;\n\tREP(i, ay.size()) {\n\t\tfor (; hoinp < vs.size(); hoinp++) {\n\t\t\tif (vs[hoinp].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tfw.add(px[vs[hoinp].first.second], 1);\n\t\t\tylist.insert({ px[vs[hoinp].first.second], vs[hoinp].second });\n\t\t}\n\n\t\tfor (; vep < ho.size(); vep++) {\n\t\t\tif (ho[vep].first.first != ay[i])\n\t\t\t\tbreak;\n\n\t\t\tint a = px[ho[vep].first.second.first], b = px[ho[vep].first.second.second];\n\n\t\t\tkoutennsuu += fw.sum(a,b);\n\t\t\tint aln = get(a+1, b+1);\n\t\t\tint setn = ho[vep].second+ 1;\n\t\t\tif (aln) {\n\t\t\t\tuf.unionSet(aln-1, ho[vep].second);\n\t\t\t\tsetn = aln;\n\t\t\t}\n\t\t\tupdate(a+1,b+1,setn);\n\t\t}\n\n\t\tfor (; hooup < ve.size(); hooup++) {\n\t\t\tif (ve[hooup].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tint buf = px[vs[hooup].first.second];\n\t\t\tfw.add(px[vs[hooup].first.second], -1);\n\t\t\tylist.erase({ buf, vs[hooup].second });\n\t\t\tint nn = get(buf + 1, buf + 1);\n\t\t\tif (nn) {\n\t\t\t\tuf.unionSet(nn-1, ve[hooup].second);\n\t\t\t}\n\t\t\tupdate(buf+1,buf+1,0);\n\t\t}\n\t}\n\tint renketusuu = 0;\n\tREP(i, n+1) {\n\t\trenketusuu += uf.data[i] < 0;\n\t}\n\t//if (uf.data[n] < -1)\n\t\t//renketusuu++;\n\t//koutennsuu += 4;\n\t//n += 4;\n\tprintf(\"%d\\n\", koutennsuu - n + renketusuu+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\t//cout << V.left << \" \" << lf << endl;\n\t\t\t//cout << target[V.left] << \" \" << target[lf] << endl;\n\t\t\t//target[V.left] = target[lf];\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <map>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int,int> pi;\n\nstruct line{int s, e, x;};\nbool cmp(line a, line b){return a.x < b.x;}\n\nstruct event{int px, py, num;};\nbool cmp2(event a, event b){return a.px < b.px;}\n\nstruct disj{\n    int pa[100005];\n    void init(int n){\n        for(int i=0; i<=n; i++) pa[i] = i;\n    }\n    int find(int x){\n        return pa[x] = (pa[x] == x ? x : find(pa[x]));\n    }\n    void uni(int p, int q){\n        pa[find(p)] = find(q);\n    }\n}disj;\n\nstruct bit{\n    int tree[200050], lim;\n    void init(int n){\n        lim = n+2;\n        memset(tree,0,sizeof(tree));\n    }\n    void add(int x, int v){\n        x += 2;\n        while(x <= lim){\n            tree[x] += v;\n            x += x & -x;\n        }\n    }\n    int sum(int x){\n        x += 2;\n        int ret = 0;\n        while(x){\n            ret += tree[x];\n            x -= x & -x;\n        }\n        return ret;\n    }\n    int range_sum(int s, int e){\n        return sum(e) - sum(s-1);\n    }\n}bit;\n\nstruct seg{\n    int tree[270000], eraser[270000];\n    void add(int s, int e, int ps, int pe, int p, int v){\n        for (int i=s; i<=e; i++){\n            tree[i] = v;\n        }\n    }\n    void erase(int s, int e, int ps, int pe, int p){\n        for (int i=s; i<=e; i++){\n            tree[i] = -1;\n        }\n    }\n    void fill(int s, int e, int ps, int pe, int p, int v){\n        for(int i=s; i<=e; i++){\n            if(tree[i] != -1) disj.uni(tree[i],v);\n        }\n    }\n}seg;\n\nvector<line> linex, liney;\nvector<int> vx, vy;\nvector<pi> extreme;\n\nvector<pi> sweep_add, sweep_del;\n\nlint vertex(){\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s + 1,i.x));\n        sweep_del.push_back(pi(i.e,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    lint ret = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1);\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    sort(extreme.begin(),extreme.end());\n    extreme.resize(unique(extreme.begin(),extreme.end()) - extreme.begin());\n    ret += extreme.size();\n    //printf(\"vertex = %lld\\n\",ret);\n    return ret;\n}\n\nlint edge(){\n    lint ret = 0;\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    for (auto &i : linex){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vx.size());\n    p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vy.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < liney.size() && liney[p3].x == i) {\n            ret += bit.range_sum(liney[p3].s+1,liney[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n //   printf(\"edge = %lld\\n\",ret);\n    return ret;\n}\n\nmap<int,int> mp;\nvector<event> event_add, event_del;\n\nint component(){\n    int pt = 0;\n    for (auto &i : liney){\n        event_add.push_back({i.s,i.x,pt});\n        event_del.push_back({i.e+1,i.x,pt});\n        pt++;\n    }\n    sort(event_add.begin(),event_add.end(),cmp2);\n    sort(event_del.begin(),event_del.end(),cmp2);\n    int p1 = 0, p2 = 0, p3 = 0;\n    int ret = 1;\n    disj.init((int)liney.size());\n    seg.erase(0,(int)vy.size()-1,0,(int)vy.size()-1,1);\n    for (int i=0; i<=vx.size(); i++) {\n        while (p2 < event_del.size() && event_del[p2].px == i) {\n            int py = event_del[p2].py;\n            seg.erase(py,py,0,(int)vy.size()-1,1);\n            mp.erase(mp.find(py));\n            p2++;\n        }\n        while (p1 < event_add.size() && event_add[p1].px == i) {\n            int py = event_add[p1].py;\n            \n            seg.add(py,py,0,(int)vy.size()-1,1,event_add[p1].num);\n            \n            mp[py] = event_add[p1].num;\n            p1++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            auto t = mp.lower_bound(linex[p3].s);\n            if(t == mp.end() || t->first > linex[p3].e){\n                ret++;\n                p3++;\n                continue;\n            }\n            seg.fill(linex[p3].s,linex[p3].e,0,(int)vy.size()-1,1,t->second);\n            p3++;\n        }\n    }\n    for (int i=1; i<liney.size(); i++) {\n        if(disj.find(0) != disj.find(i)){\n            disj.uni(0,i);\n            ret++;\n        }\n    }\n  //  printf(\"component = %d\\n\",ret);\n    return ret;\n}\n\nint main(){\n    int w,h,n;\n    scanf(\"%d %d %d\",&w,&h,&n);\n    linex.push_back({0,h,0});\n    linex.push_back({0,h,w});\n    liney.push_back({0,w,0});\n    liney.push_back({0,w,h});\n    vx.push_back(0);\n    vy.push_back(0);\n    vx.push_back(w);\n    vy.push_back(h);\n    extreme.push_back(pi(0,0));\n    extreme.push_back(pi(0,h));\n    extreme.push_back(pi(w,0));\n    extreme.push_back(pi(w,h));\n    for (int i=0; i<n; i++) {\n        int a,b,c,d;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n        vx.push_back(a);\n        vx.push_back(c);\n        vy.push_back(b);\n        vy.push_back(d);\n        extreme.push_back(pi(a,b));\n        extreme.push_back(pi(a,d));\n        extreme.push_back(pi(c,b));\n        extreme.push_back(pi(c,d));\n        if(a == c){\n            linex.push_back({b,d,a});\n        }\n        else{\n            liney.push_back({a,c,b});\n        }\n    }\n    sort(vx.begin(),vx.end());\n    sort(vy.begin(),vy.end());\n    vx.resize(unique(vx.begin(),vx.end()) - vx.begin());\n    vy.resize(unique(vy.begin(),vy.end()) - vy.begin());\n    for (auto &i : linex){\n        i.s = (int)(lower_bound(vy.begin(),vy.end(),i.s) - vy.begin());\n        i.e = (int)(lower_bound(vy.begin(),vy.end(),i.e) - vy.begin());\n        i.x = (int)(lower_bound(vx.begin(),vx.end(),i.x) - vx.begin());\n    }\n    for (auto &i : liney){\n        i.s = (int)(lower_bound(vx.begin(),vx.end(),i.s) - vx.begin());\n        i.e = (int)(lower_bound(vx.begin(),vx.end(),i.e) - vx.begin());\n        i.x = (int)(lower_bound(vy.begin(),vy.end(),i.x) - vy.begin());\n    }\n    sort(linex.begin(),linex.end(),cmp);\n    sort(liney.begin(),liney.end(),cmp);\n    printf(\"%lld\\n\",edge() - vertex() + component());\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nconst int INF = 1004567890;\n\n//0-based index???????????????????????°??????????????????\nnamespace bit\n{\n\tint arr[234567];\n\tint siz;\n\tvoid init(int n)\n\t{\n\t\t++n;\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t}\n\tvoid add(int ind, int val)\n\t{\n\t\tind++;\n\t\twhile (ind <= siz)\n\t\t{\n\t\t\tarr[ind] += val;\n\t\t\tind += (ind & -ind);\n\t\t}\n\t}\n\tint query(int right)\n\t{\n\t\tint ret = 0;\n\t\twhile (right > 0)\n\t\t{\n\t\t\tret += arr[right];\n\t\t\tright -= (right & -right);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nnamespace uf\n{\n\tvector<int>par, rnk;\n\tint vnum, gnum;\n\tvoid init() { vnum = 1; gnum = 1; par.push_back(0); rnk.push_back(0); }\n\tint addleaf()\n\t{\n\t\tpar.push_back(vnum);\n\t\trnk.push_back(0);\n\t\t++vnum;\n\t\t++gnum;\n\t\treturn vnum - 1;\n\t}\n\tint getpar(int x)\n\t{\n\t\tif (x == par[x])return x;\n\t\treturn par[x] = getpar(par[x]);\n\t}\n\tbool issame(int a, int b)\n\t{\n\t\treturn getpar(a) == getpar(b);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b)return;\n\t\t--gnum;\n\t\tif (rnk[a] < rnk[b])\n\t\t{\n\t\t\tpar[a] = b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tif (rnk[a] == rnk[b])rnk[a]++;\n\t\t}\n\t}\n}\n\nnamespace sgt\n{\n\tbool buf[234567];\n\tint width;\n\tvoid init(int n)\n\t{\n\t\twidth = 1;\n\t\twhile (width < n)width <<= 1;\n\t}\n\tvoid change_raw(int a, int b, int k, int l, int r)\n\t{\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b)\n\t\t{\n\t\t\tbuf[k] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tchange_raw(a, b, k + k + 1, l, m);\n\t\t\tchange_raw(a, b, k + k + 2, m, r);\n\t\t}\n\t}\n\tvoid change(int a, int b)\n\t{\n\t\tchange_raw(a, b, 0, 0, width);\n\t}\n\tvoid deflag_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return;\n\t\tbuf[k] = false;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return;\n\t\tdeflag_raw(x, k + k + 1, l, m);\n\t\tdeflag_raw(x, k + k + 2, m, r);\n\t}\n\tvoid deflag(int x)\n\t{\n\t\tdeflag_raw(x, 0, 0, width);\n\t}\n\tbool check_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return false;\n\t\tif (buf[k])return true;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return false;\n\t\treturn check_raw(x, k + k + 1, l, m) || check_raw(x, k + k + 2, m, r);\n\t}\n\tbool check(int x)\n\t{\n\t\treturn check_raw(x, 0, 0, width);\n\t}\n}\n\nenum QueryType { SPLIT, MERGE, CHANGE };\nstruct query\n{\n\tQueryType type;\n\tint yval;\n\tint xval1, xval2;\n\tquery(QueryType t, int y, int x1, int x2 = 0)\n\t\t:type(t), yval(y), xval1(x1), xval2(x2)\n\t{}\n};\n\nint w, h, n;\nvector<int>xlist;\nvector<query>que;\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tque.reserve(n * 2);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tif (a == c)\n\t\t{\n\t\t\tif (b > d)swap(b, d);\n\t\t\tque.push_back({ SPLIT, b + b - 1, a });\n\t\t\tque.push_back({ MERGE, d + d + 1, a });\n\t\t\txlist.push_back(a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)swap(a, c);\n\t\t\tque.push_back({ CHANGE, b + b, a, c });\n\t\t}\n\t}\n\txlist.push_back(-INF);\n\txlist.push_back(0);\n\txlist.push_back(w);\n\tque.push_back({ SPLIT, -1, 0 });\n\tque.push_back({ SPLIT, -1, w });\n\tque.push_back({ MERGE, h + h + 1, 0 });\n\tque.push_back({ MERGE, h + h + 1, w });\n\tque.push_back({ CHANGE, 0,0,w });\n\tque.push_back({ CHANGE, h + h,0,w });\n\tsort(que.begin(), que.end(), [](const query& q1, const query& q2) {if (q1.yval == q2.yval)return q1.xval1 > q2.xval1;return q1.yval < q2.yval; });\n\tsort(xlist.begin(), xlist.end());\n\txlist.erase(unique(xlist.begin(), xlist.end()), xlist.end());\n\tset<pair<int, int>>bar;//first=left,second=index\n\tbar.insert({ -INF, 0 });\n\tint splitnum = 0;\n\tuf::init();\n\tsgt::init(xlist.size());\n\tbit::init(xlist.size());\n\tfor (auto& qq : que)\n\t{\n\t\tswitch (qq.type)\n\t\t{\n\t\tcase SPLIT:\n\t\t{\n\t\t\t//BIT???????????°????????????(???????????????1?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, 1);\n\t\t\t//?????????????????????????????????index?????\\???\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\t/*\n\t\t\tif (itr != bar.end())\n\t\t\t{\n\t\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), itr->first) - xlist.begin();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t//*/\n\t\t\t--itr;\n\t\t\tint index = itr->second;\n\t\t\t//??????????????´??°????¢???????\n\t\t\tint left = itr->first;\n\t\t\tint id = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(id))\n\t\t\t{\n\t\t\t\tindex = uf::addleaf();\n\t\t\t\tsgt::deflag(id);\n\t\t\t}\n\t\t\t//????????´??°????????¶????????????\n\t\t\t++itr;\n\t\t\tif (itr != bar.end())\n\t\t\t{\n\t\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), itr->first) - xlist.begin();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t--itr;\n\t\t\t//??????index??¨?????????????????????\n\t\t\tbar.insert({ qq.xval1, index });\n\t\t\t//???????¶????????????°??????????????¨??\\????????????\n\t\t\tbar.erase(pair<int, int>(itr->first, itr->second));\n\t\t\tbar.insert({ left, index });\n\t\t\tbreak;\n\t\t}\n\t\tcase MERGE:\n\t\t{\n\t\t\t//BIT???????????°????¶????(???????????????0?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, -1);\n\t\t\t//???????????¨????????????\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\tint rightindex = itr->second;\n\t\t\tint oldright = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint right = itr->first;\n\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), right) - xlist.begin();\n\t\t\tif (sgt::check(rid))\n\t\t\t{\n\t\t\t\trightindex = uf::addleaf();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t--itr;\n\t\t\tint leftindex = itr->second;\n\t\t\tint oldleft = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint left = itr->first;\n\t\t\tint lid = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(lid))\n\t\t\t{\n\t\t\t\tleftindex = uf::addleaf();\n\t\t\t\tsgt::deflag(lid);\n\t\t\t}\n\t\t\t//union find??¨??§??±?????????\n\t\t\tuf::unite(leftindex, rightindex);\n\t\t\t//??????????¶????????????°?????????????????\\??????\n\t\t\t\n\t\t\tbar.erase(pair<int, int>(right, oldright));\n\t\t\tbar.erase(pair<int, int>(left, oldleft));\n\t\t\tbar.insert({ left, leftindex });\n\t\t\tbreak;\n\t\t}\n\t\tcase CHANGE:\n\t\t{\n\t\t\t//????????£???????????????????¢????\n\t\t\tint ltex = bar.lower_bound({ qq.xval1,0 })->first;\n\t\t\tauto tmp = bar.upper_bound({ qq.xval2,INF+2 });\n\t\t\t--tmp;\n\t\t\tint rtex = (tmp)->first;\n\t\t\tint lind = lower_bound(xlist.begin(), xlist.end(), ltex) - xlist.begin();\n\t\t\tint rind = lower_bound(xlist.begin(), xlist.end(), rtex) - xlist.begin();\n\t\t\t//????????????????????\\????????????\n\t\t\tif(lind <= rind)sgt::change(lind, rind);\n\t\t\t//????????´??°\n\t\t\tsplitnum += max(0, bit::query(rind) - bit::query(lind));\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tint answer = splitnum - (uf::vnum - uf::gnum);\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (y == 32) cout << x << '\\n';\n    if (pos[x]) addEdge(pos[x], y);\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) {\n            add(it[1][i], id), pos[it[1][i]] = id;\n        }\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI Y; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 1, Y.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        y1 = LBD(Y, y1); y2 = LBD(Y, y2); if(y1 == y2){\n            A.PB(Event(x1, 0, y1, y2));\n            A.PB(Event(x2, 2, y1, y2));\n        }else{\n            A.PB(Event(x1, 1, y1, y2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0)); L.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H)); L.PB(Line(0,H,W,H));\n\n\tY.PB(-1); ECH(it, L) Y.PB(it->y1), Y.PB(it->y2); UNQ(Y);\n\tBIT::n = Y.size(); S.insert(0); DSU::P.resize(Y.size(), 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        //cout << x << endl;\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        //cout << x << \" \" << y << endl;\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.PB(-1); UNQ(xs);\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S; S.insert(0);\n\tDSU::P.resize(xs.size()+1, 0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tLL res = 0; for(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(V.left, lf);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tres += BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(DSU::Union(lf, V.left)) --res;\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) {\n            add(it[1][i], id), pos[it[1][i]] = id;\n        }\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n+1);\n\tvector<pair<int,pair<ll,pair<ll, ll>>>> y,t;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1,x2,y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tt.push_back({ i,{ x1,{y1,y2} } });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({i,{ y1,{x1,x2} } });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\tvector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tREP(i, y.size()) {\n\t\tint yy = lower_bound(ALL(ay), y[i].second.first) - ay.begin();\n\t\tint x1 = lower_bound(ALL(ax), y[i].second.second.first) - ax.begin();\n\t\tint x2 = lower_bound(ALL(ax), y[i].second.second.second) - ax.begin();\n\t\talx[x1][yy] = y[i].first+1;\n\t\talx[x2][yy] = -(y[i].first+1);\n\t}\n\tREP(i, t.size()) {\n\t\tint xx = lower_bound(ALL(ax), t[i].second.first) - ax.begin();\n\t\tint y1 = lower_bound(ALL(ay), t[i].second.second.first) - ay.begin();\n\t\tint y2 = lower_bound(ALL(ay), t[i].second.second.second) - ay.begin();\n\t\taly[xx][y1] = t[i].first+1;\n\t\taly[xx][y2] = -(t[i].first+1);\n\t}\n\tREP(i, ax.size()) {\n\t\tREP(j, ay.size()) {\n\t\t\tif (i < ax.size() - 1 && alx[i][j]>0 && !alx[i+1][j]) {\n\t\t\t\talx[i + 1][j] = alx[i][j];\n\t\t\t}\n\t\t\tif (j < ay.size() - 1 && aly[i][j]>0 && !aly[i][j+1]) {\n\t\t\t\taly[i][j + 1] = aly[i][j];\n\t\t\t}\n\n\t\t\tif(alx[i][j] && aly[i][j]){\n\t\t\t\tint a = abs(alx[i][j])-1, b = abs(aly[i][j])-1;\n\t\t\t\tif (uf.findSet(a,b)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(a,b);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI Y; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, Y.size()-1\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        ++x;\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        ++x;\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        y1 = LBD(Y, y1); y2 = LBD(Y, y2); if(y1 == y2){\n            A.PB(Event(x1, 0, y1, y2));\n            A.PB(Event(x2, 2, y1, y2));\n        }else{\n            A.PB(Event(x1, 1, y1, y2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0)); L.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H)); L.PB(Line(0,H,W,H));\n\n\tECH(it, L) Y.PB(it->y1), Y.PB(it->y2); UNQ(Y);\n\tBIT::n = Y.size(); S.insert(0); DSU::P.resize(Y.size(), 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef pair <ii, int> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nint w, h, n, x[2][N], y[2][N], a[N], pos[2][N], num, bit[N];\nint cnt, ver, root_ver[N], ans;\nbool check[N];\n\nstruct {\n    int pset[N], numdsu;\n\n    void init (int n){\n        for (int i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    int findset(int i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(int i, int j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    int val, left, right, cnt;\n} lv[20*N];\n\nvoid init(int l, int r){\n    int nod = cnt;\n    if (l != r){\n        int mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(int k, int l, int r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        int a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(int k, int l, int r, int pos, int val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    int mid = (l + r) / 2; int nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(int pos, int val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (int k, int l, int r, int L, int R, int val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(int u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; int v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(int i, int val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nint get(int l, int r){\n    int ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (int i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (int i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        int z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (int i = 0; i < mv.size(); i++){\n        int z = mv[i].second, val = mv[i].first.first;\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    for (int i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans << \"\\n\";\n}\n/*\n10 10 1\n2 3 2 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) {\n            add(it[1][i], id), pos[it[1][i]] = id;\n        }\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    pos[x] = y;\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t == 1) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) add(it[1][i], id);\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr == ll) continue;\n\n\t\t\tret += seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <map>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int,int> pi;\n\nstruct line{int s, e, x;};\nbool cmp(line a, line b){return a.x < b.x;}\n\nstruct event{int px, py, num;};\nbool cmp2(event a, event b){return a.px < b.px;}\n\nstruct disj{\n    int pa[100005];\n    void init(int n){\n        for(int i=0; i<=n; i++) pa[i] = i;\n    }\n    int find(int x){\n        return pa[x] = (pa[x] == x ? x : find(pa[x]));\n    }\n    void uni(int p, int q){\n        pa[find(p)] = find(q);\n    }\n}disj;\n\nstruct bit{\n    int tree[200050], lim;\n    void init(int n){\n        lim = n+2;\n        memset(tree,0,sizeof(tree));\n    }\n    void add(int x, int v){\n        x += 2;\n        while(x <= lim){\n            tree[x] += v;\n            x += x & -x;\n        }\n    }\n    int sum(int x){\n        x += 2;\n        int ret = 0;\n        while(x){\n            ret += tree[x];\n            x -= x & -x;\n        }\n        return ret;\n    }\n    int range_sum(int s, int e){\n        return sum(e) - sum(s-1);\n    }\n}bit;\n\nstruct seg{\n    int tree[270000], eraser[270000];\n    void add(int s, int e, int ps, int pe, int p, int v){\n        for (int i=s; i<=e; i++){\n            tree[i] = v;\n        }\n    }\n    void erase(int s, int e, int ps, int pe, int p){\n        for (int i=s; i<=e; i++){\n            tree[i] = -1;\n        }\n    }\n    void fill(int s, int e, int ps, int pe, int p, int v){\n        for(int i=s; i<=e; i++){\n            if(tree[i] != -1) disj.uni(tree[i],v);\n        }\n    }\n}seg;\n\nvector<line> linex, liney;\nvector<int> vx, vy;\nvector<pi> extreme;\n\nvector<pi> sweep_add, sweep_del;\n\nlint vertex(){\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s + 1,i.x));\n        sweep_del.push_back(pi(i.e,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    lint ret = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1);\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    sort(extreme.begin(),extreme.end());\n    extreme.resize(unique(extreme.begin(),extreme.end()) - extreme.begin());\n    ret += extreme.size();\n    //printf(\"vertex = %lld\\n\",ret);\n    return ret;\n}\n\nlint edge(){\n    lint ret = 0;\n    for (auto &i : liney){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vy.size());\n    int p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vx.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            ret += bit.range_sum(linex[p3].s+1,linex[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n    for (auto &i : linex){\n        sweep_add.push_back(pi(i.s,i.x));\n        sweep_del.push_back(pi(i.e + 1,i.x));\n    }\n    sort(sweep_add.begin(),sweep_add.end());\n    sort(sweep_del.begin(),sweep_del.end());\n    bit.init((int)vx.size());\n    p1 = 0, p2 = 0, p3 = 0;\n    for (int i=0; i<vy.size(); i++) {\n        while (p1 < sweep_add.size() && sweep_add[p1].first == i) {\n            bit.add(sweep_add[p1].second,1);\n            p1++;\n        }\n        while (p2 < sweep_del.size() && sweep_del[p2].first == i) {\n            bit.add(sweep_del[p2].second,-1);\n            p2++;\n        }\n        while (p3 < liney.size() && liney[p3].x == i) {\n            ret += bit.range_sum(liney[p3].s+1,liney[p3].e-1) + 1;\n            p3++;\n        }\n    }\n    sweep_add.clear();\n    sweep_del.clear();\n //   printf(\"edge = %lld\\n\",ret);\n    return ret;\n}\n\nmap<int,int> mp;\nvector<event> event_add, event_del;\n\nint component(){\n    int pt = 0;\n    for (auto &i : liney){\n        event_add.push_back({i.s,i.x,pt});\n        event_del.push_back({i.e+1,i.x,pt});\n        pt++;\n    }\n    sort(event_add.begin(),event_add.end(),cmp2);\n    sort(event_del.begin(),event_del.end(),cmp2);\n    int p1 = 0, p2 = 0, p3 = 0;\n    int ret = 1;\n    disj.init((int)liney.size());\n    seg.erase(0,(int)vy.size()-1,0,(int)vy.size()-1,1);\n    for (int i=0; i<=vx.size(); i++) {\n        while (p2 < event_del.size() && event_del[p2].px == i) {\n            int py = event_del[p2].py;\n            seg.erase(py,py,0,(int)vy.size()-1,1);\n            mp.erase(mp.find(py));\n            p2++;\n        }\n        while (p1 < event_add.size() && event_add[p1].px == i) {\n            int py = event_add[p1].py;\n            \n            seg.add(py,py,0,(int)vy.size()-1,1,event_add[p1].num);\n            \n            mp[py] = event_add[p1].num;\n            p1++;\n        }\n        while (p3 < linex.size() && linex[p3].x == i) {\n            auto t = mp.lower_bound(linex[p3].s);\n            if(t == mp.end() || t->first > linex[p3].e){\n                ret++;\n                p3++;\n                continue;\n            }\n            seg.fill(linex[p3].s,linex[p3].e,0,(int)vy.size()-1,1,t->second);\n            p3++;\n        }\n    }\n    for (int i=1; i<liney.size(); i++) {\n        if(disj.find(0) != disj.find(i)){\n            disj.uni(0,i);\n            ret++;\n        }\n    }\n  //  printf(\"component = %d\\n\",ret);\n    return ret;\n}\n\nint main(){\n    int w,h,n;\n    scanf(\"%d %d %d\",&w,&h,&n);\n    linex.push_back({0,h,0});\n    linex.push_back({0,h,w});\n    liney.push_back({0,w,0});\n    liney.push_back({0,w,h});\n    vx.push_back(0);\n    vy.push_back(0);\n    vx.push_back(w);\n    vy.push_back(h);\n    extreme.push_back(pi(0,0));\n    extreme.push_back(pi(0,h));\n    extreme.push_back(pi(w,0));\n    extreme.push_back(pi(w,h));\n    for (int i=0; i<n; i++) {\n        int a,b,c,d;\n        scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n        vx.push_back(a);\n        vx.push_back(c);\n        vy.push_back(b);\n        vy.push_back(d);\n        extreme.push_back(pi(a,b));\n        extreme.push_back(pi(a,d));\n        extreme.push_back(pi(c,b));\n        extreme.push_back(pi(c,d));\n        if(a == c){\n            linex.push_back({b,d,a});\n        }\n        else{\n            liney.push_back({a,c,b});\n        }\n    }\n    sort(vx.begin(),vx.end());\n    sort(vy.begin(),vy.end());\n    vx.resize(unique(vx.begin(),vx.end()) - vx.begin());\n    vy.resize(unique(vy.begin(),vy.end()) - vy.begin());\n    for (auto &i : linex){\n        i.s = (int)(lower_bound(vy.begin(),vy.end(),i.s) - vy.begin());\n        i.e = (int)(lower_bound(vy.begin(),vy.end(),i.e) - vy.begin());\n        i.x = (int)(lower_bound(vx.begin(),vx.end(),i.x) - vx.begin());\n    }\n    for (auto &i : liney){\n        i.s = (int)(lower_bound(vx.begin(),vx.end(),i.s) - vx.begin());\n        i.e = (int)(lower_bound(vx.begin(),vx.end(),i.e) - vx.begin());\n        i.x = (int)(lower_bound(vy.begin(),vy.end(),i.x) - vy.begin());\n    }\n    sort(linex.begin(),linex.end(),cmp);\n    sort(liney.begin(),liney.end(),cmp);\n    printf(\"%lld\",edge() - vertex() + component());\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1);\n\t\t\tS.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        x1 = LBD(xs, x1); x2 = LBD(xs, x2);\n        if(x1 == x2){\n            A.PB(Event(y1, 0, x1, x2));\n            A.PB(Event(y2, 2, x1, x2));\n        }else{\n            A.PB(Event(y1, 1, x1, x2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0));\n\tL.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H));\n\tL.PB(Line(0,H,W,H));\n\n\txs.PB(-1); REP(i, n) xs.PB(L[i].x1), xs.PB(L[i].x2); UNQ(xs);\n\tBIT::n = xs.size(); S.insert(0); DSU::P.resize(xs.size()+1, 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long N = 3e5 + 5;\nusing namespace std;\n\ntypedef pair <long long, long long> ii;\ntypedef pair <ii, long long> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nlong long w, h, n, x[2][N], y[2][N], a[N], pos[2][N], num, bit[N];\nlong long cnt, ver, root_ver[N], ans;\nbool check[N];\n\nstruct {\n    long long pset[N], numdsu;\n\n    void init (long long n){\n        for (long long i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    long long findset(long long i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(long long i, long long j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    long long val, left, right, cnt;\n} lv[30*N];\n\nvoid init(long long l, long long r){\n    long long nod = cnt;\n    if (l != r){\n        long long mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(long long k, long long l, long long r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        long long a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(long long k, long long l, long long r, long long pos, long long val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    long long mid = (l + r) / 2; long long nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(long long pos, long long val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (long long k, long long l, long long r, long long L, long long R, long long val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    long long mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(long long u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; long long v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(long long i, long long val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nlong long get(long long l, long long r){\n    long long ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (long long i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (long long i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (long long i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        long long z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (long long i = 0; i < mv.size(); i++){\n        long long z = mv[i].second, val = mv[i].first.first;\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    for (long long i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans << \"\\n\";\n}\n/*\n10 10 1\n2 3 2 4\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\n\n\n\n\n\n\n\nLL res;\n\nint W, H, N, x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nset<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n};\n\n\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tREP(i, N){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.PB(-1); UNQ(xs);\n\tBIT::n = xs.size();\n\n\tREP(i, N){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tS.insert(0); DSU::P.resize(xs.size()+1, 0);\n\n\tvector<Event> A; REP(i, N) if(x1[i] == x2[i]){\n        A.PB(Event(y1[i], 0, x1[i], x2[i]));\n        A.PB(Event(y2[i], 2, x1[i], x2[i]));\n    }else{\n        A.PB(Event(y1[i], 1, x1[i], x2[i]));\n    }\n\n\tSRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass unionfind {\npublic:\n\tclass node {\n\tpublic:\n\t\tint r, o, n;\n\t};\n\n\tnode* d;\n\n\tvoid init(int n) {\n\t\td = new node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i].o = i;\n\t\t\td[i].r = 0;\n\t\t\td[i].n = 1;\n\t\t}\n\t}\n\n\tint find(int a) {\n\t\tif (d[a].o == a) {\n\t\t\treturn a;\n\t\t}\n\t\treturn d[a].o = find(d[a].o);\n\t}\n\n\tvoid unit(int a, int b) {\n\t\tif (d[a].r > d[b].r) {\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse if (d[a].r == d[b].r) {\n\t\t\td[a].r++;\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse {\n\t\t\td[a].o = b;\n\t\t\td[a].n = 0;\n\t\t}\n\t}\n};\n\nclass bit {\npublic:\n\tint n;\n\tint* d;\n\t\n\tvoid init(int nw) {\n\t\tn = nw;\n\t\td = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = 0;\n\t\t}\n\t}\n\n\tvoid add(int b, int x) {\n\t\tfor (int i = b + 1; i <= n; i += (i & -i)) {\n\t\t\td[i - 1] += x;\n\t\t}\n\t}\n\n\tint sum(int b) {\n\t\tint all = 0;\n\t\tfor (int i = b + 1; i > 0; i -= (i & -i)) {\n\t\t\tall += d[i - 1];\n\t\t}\n\t\treturn all;\n\t}\n};\n\nint n1, n2;\n\nclass path {\npublic:\n\tint z, s, t;\n};\n\npath pl1[100100];\npath pl2[100100];\n\npath p1[100100];\npath p2[100100];\n\nint pp[100100];\nint pn;\n\nint bfind(int a) {\n\tint b = 0;\n\tint e = pn;\n\twhile (e - b > 1) {\n\t\tint m = (b + e) / 2;\n\t\tif (a < pp[m]) {\n\t\t\te = m;\n\t\t}\n\t\telse {\n\t\t\tb = m;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid zpress() {\n\tfor (int i = 0; i < n1; i++) {\n\t\tpp[i] = pl1[i].z;\n\t}\n\tsort(pp, pp + n1);\n\tpn = unique(pp, pp + n1) - pp;\n\tfor (int i = 0; i < n1; i++) {\n\t\tp1[i].z = bfind(pl1[i].z);\n\t\tp1[i].s = pl1[i].s;\n\t\tp1[i].t = pl1[i].t;\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\tp2[i].z = pl2[i].z;\n\t\tp2[i].s = bfind(pl2[i].s);\n\t\tif (pp[p2[i].s] < pl2[i].s) {\n\t\t\tp2[i].s++;\n\t\t}\n\t\tp2[i].t = bfind(pl2[i].t);\n\t}\n}\n\npair<int, pair<int, pair<int, int> > > tmp[1000000];\n\nint main() {\n\tint w, h, n;\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tn1 = 0;\n\tn2 = 0;\n\tpl1[n1].z = 0;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl1[n1].z = w;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl2[n2].z = 0;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tpl2[n2].z = h;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (a == c) {\n\t\t\tpl1[n1].z = a;\n\t\t\tpl1[n1].s = b;\n\t\t\tpl1[n1].t = d;\n\t\t\tn1++;\n\t\t}\n\t\telse {\n\t\t\tpl2[n2].z = b;\n\t\t\tpl2[n2].s = a;\n\t\t\tpl2[n2].t = c;\n\t\t\tn2++;\n\t\t}\n\t}\n\tzpress();\n\tint now = 0;\n\tfor (int i = 0; i < n1; i++) {\n\t\ttmp[now++] = make_pair(p1[i].s, make_pair(0, make_pair(p1[i].z, 0)));\n\t\ttmp[now++] = make_pair(p1[i].t, make_pair(2, make_pair(p1[i].z, 0)));\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\ttmp[now++] = make_pair(p2[i].z, make_pair(1, make_pair(p2[i].s, p2[i].t)));\n\t}\n\tsort(tmp, tmp + now);\n\tint ans = 0;\n\tunionfind uf;\n\tuf.init(n * 10);\n\tint unow = 0;\n\tmap<int, int> ss;\n\tmap<int, int> nj;\n\tnj[-1] = unow++;\n\tbit bb;\n\tbb.init(n + 100);\n\tfor (int i = 0; i < now; i++) {\n\t\t/*for (auto j : nj) {\n\t\t\tprintf(\"%d:%d \", j.first, j.second);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\tauto w = tmp[i];\n\t\tif (w.second.first == 0) {\n\t\t\tbb.add(w.second.second.first, 1);\n\t\t\tauto it = nj.lower_bound(w.second.second.first);\n\t\t\tit--;\n\t\t\tif (it != nj.end()) {\n\t\t\t\tint q = (*it).second;\n\t\t\t\tint nn;\n\t\t\t\tif (q < 0) {\n\t\t\t\t\tnn = unow++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn = (*it).second;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = nn;\n\t\t\t\tnj[w.second.second.first] = nn;\n\t\t\t\tss[(*it).first] = nn;\n\t\t\t\tss[w.second.second.first] = nn;\n\t\t\t}\n\t\t}\n\t\telse if (w.second.first == 1) {\n\t\t\tauto it = ss.lower_bound(w.second.second.first);\n\t\t\twhile (1) {\n\t\t\t\tauto itit = nj.find((*it).first);\n\t\t\t\titit++;\n\t\t\t\tif (itit == nj.end() || (*itit).first > w.second.second.second) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = -1;\n\t\t\t\tans--;\n\t\t\t\tauto itw = it;\n\t\t\t\tit++;\n\t\t\t\tss.erase(itw);\n\t\t\t}\n\t\t\tans += bb.sum(w.second.second.second) - bb.sum(w.second.second.first - 1) - 1;\n\t\t\t//printf(\"%d:%d,%d %d\\n\", w.first, w.second.second.first, w.second.second.second, ans);\n\t\t}\n\t\telse {\n\t\t\tbb.add(w.second.second.first, -1);\n\t\t\tauto it = nj.find(w.second.second.first);\n\t\t\tauto it2 = it;\n\t\t\tit2--;\n\t\t\tif ((*it).second >= 0) {\n\t\t\t\tif ((*it2).second < 0) {\n\t\t\t\t\tnj[(*it2).first] = (*it).second;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint aw = uf.find((*it).second);\n\t\t\t\t\tint bw = uf.find((*it2).second);\n\t\t\t\t\tif (aw != bw) {\n\t\t\t\t\t\tuf.unit(aw, bw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.erase((*it).first);\n\t\t\tnj.erase(it);\n\t\t}\n\t}\n\tfor (int i = 0; i < unow; i++) {\n\t\tans += uf.d[i].n;\n\t}\n\tans--;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr == ll) continue;\n\n\t\t\tret += seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef pair<ll,P> T;\ntypedef pair<int,ll> Pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nconst int SIZE = 1<<18;\n\nstruct BIT{\n\tint bit[SIZE+100];\n\tvoid add(int i,int x){\n\t\twhile(i<=SIZE){\n\t\t\tbit[i]+=x;\n\t\t\ti+=i&-i;\n\t\t}\n\t\treturn;\n\t}\n\tint sum(int i){\n\t\tint res=0;\n\t\twhile(i>0){\n\t\t\tres+=bit[i];\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn res;\n\t}\n\tint sum(int l,int r){\n\t\treturn sum(r)-sum(l-1);\n\t}\n}bit;\n\nstruct segtree{\n\tint seg[SIZE*2];\n\tvoid set(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l)return;\n\t\telse if(a<=l&&r<=b){\n\t\t\tseg[k]=1;\n\t\t\treturn;\n\t\t}else{\n\t\t\tif(k<SIZE-1){\n\t\t\t\tseg[k*2+1]|=seg[k];\n\t\t\t\tseg[k*2+2]|=seg[k];\n\t\t\t}\n\t\t\tseg[k]=0;\n\t\t\tset(a,b,k*2+1,l,(l+r)/2);\n\t\t\tset(a,b,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\tbool changed(int k){\n\t\tk += SIZE-1;\n\t\tif(seg[k]==1)return true;\n\t\twhile(k){\n\t\t\tk=(k-1)/2;\n\t\t\tif(seg[k]==1)return true;\n\t\t}\n\t\treturn false;\n\t}\n\tvoid unset(int a,int k,int l,int r){\n\t\tif(r<=a||a<l)return;\n\t\telse if(a<=l&&r<=a+1){\n\t\t\tseg[k]=0;\n\t\t\treturn;\n\t\t}else{\n\t\t\tif(k<SIZE-1){\n\t\t\t\tseg[k*2+1]|=seg[k];\n\t\t\t\tseg[k*2+2]|=seg[k];\n\t\t\t}\n\t\t\tseg[k]=0;\n\t\t\tunset(a,k*2+1,l,(l+r)/2);\n\t\t\tunset(a,k*2+2,(l+r)/2,r);\n\t\t}\n\t}\n\tvoid set(int a,int b){\n\t\tset(a,b,0,0,SIZE);\n\t}\n\tvoid unset(int a){\n\t\tunset(a,0,0,SIZE);\n\t}\n}seg;\n\nstruct event{\n\tint y,l,r,type;\n\tevent(int y,int l,int r,int type):y(y),l(l),r(r),type(type){}\n\tbool operator < (const event& a) const{\n\t\tif(y!=a.y)return y<a.y;\n\t\treturn type < a.type;\n\t}\n};\n\nint W,H,N;\nint A[100100],B[100100],C[100100],D[100100];\nvector<int> zip;\nll ans = 0ll;\nvector<event> ev;\nset<int> s;\n\nvector<int> uf,rank;\nint touf[200100];\nvoid fix(int k){\n\tif(seg.changed(k)){\n\t\ttouf[k]=sz(uf);\n\t\tuf.pb(touf[k]);\n\t\trank.pb(0);\n\t\tseg.unset(k);\n\t}\n}\nint find(int x){\n\tif(uf[x]==x)return x;\n\treturn uf[x]=find(uf[x]);\n}\nvoid unite(int a,int b){\n\ta = find(a);\n\tb = find(b);\n\tif(a==b)return;\n\t//printf(\"unite %d %d\\n\",a,b);\n\tans--;\n\tif(rank[a]<rank[b])uf[a]=b;\n\telse{\n\t\tuf[b]=a;\n\t\tif(rank[a]==rank[b])rank[a]++;\n\t}\n}\n\n/*void debug(event a){\n\tprintf(\"%d %d %d %d\\n\",a.y,a.l,a.r,a.type);\n}\nvoid ds(){\n\twhile(1){\n\t\tint t,a,b;\n\t\tcin >> t;\n\t\tif(t==0){\n\t\t\tcin >> a >> b;\n\t\t\tseg.set(a,b);\n\t\t}else if(t==1){\n\t\t\tcin >> a;\n\t\t\tseg.unset(a);\n\t\t}else{\n\t\t\tcin >> a;\n\t\t\tcout << seg.changed(a) << endl;\n\t\t}\t\n\t}\n}*/\n\nint main(){\n\tscanf(\"%d %d %d\",&W,&H,&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tif(B[i]>D[i])swap(B[i],D[i]);\n\t\tif(A[i]>C[i])swap(A[i],C[i]);\n\t}\n\tA[N]=0;B[N]=0;C[N]=W;D[N]=0;\n\tA[N+1]=0;B[N+1]=0;C[N+1]=0;D[N+1]=H;\n\tA[N+2]=W;B[N+2]=0;C[N+2]=W;D[N+2]=H;\n\tA[N+3]=0;B[N+3]=H;C[N+3]=W;D[N+3]=H;\n\tN+=4;\n\tfor(int i=0;i<N;i++){\n\t\tzip.pb(A[i]);zip.pb(C[i]);\n\t}\n\tzip.pb(-1); // for BIT\n\tsort(all(zip));\n\tzip.erase(unique(all(zip)),zip.end());\n\t/*for(int i=0;i<zip.size();i++){\n\t\tprintf(\"%d : %d\\n\",i,zip[i]);\n\t}*/\n\tfor(int i=0;i<N;i++){\n\t\tA[i]=lower_bound(all(zip),A[i])-zip.begin();\n\t\tC[i]=lower_bound(all(zip),C[i])-zip.begin();\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(A[i]==C[i]){\n\t\t\tev.pb(event(B[i],A[i],-1,0));\n\t\t\tev.pb(event(D[i],A[i],-1,2));\n\t\t}else{\n\t\t\tev.pb(event(B[i],A[i],C[i],1));\n\t\t}\n\t}\n\ts.insert(0);\n\tuf.pb(0);\n\ttouf[0]=0;\n\tsort(all(ev));\n\tfor(int i=0;i<ev.size();i++){\n\t\tevent e = ev[i];\n\t\t//debug(e);\n\t\tif(e.type==0){\n\t\t\tint p = *(--s.lower_bound(e.l));\n\t\t\t//printf(\"p %d\\n\",p);\n\t\t\tfix(p);fix(e.l);\n\t\t\ttouf[e.l]=touf[p];\n\t\t\ts.insert(e.l);\n\t\t\tbit.add(e.l,1);\n\t\t}else if(e.type==1){\n\t\t\tint num = bit.sum(e.l,e.r);\n\t\t\t//printf(\"num %d\\n\",num);\n\t\t\tif(num<=1)continue;\n\t\t\tans += num-1;\n\t\t\tint L = e.l;\n\t\t\tint R = *(--s.upper_bound(e.r));\n\t\t\tseg.set(L,R);\n\t\t}else{\n\t\t\tint p = *(--s.lower_bound(e.l));\n\t\t\tfix(p);fix(e.l);\n\t\t\tunite(touf[p],touf[e.l]);\n\t\t\ts.erase(e.l);\n\t\t\tbit.add(e.l,-1);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\tif (ST::Query(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\n public:\n  Compression(const std::vector<int>& list) : value_(list) {\n    std::sort(begin(value_), end(value_));\n    value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n    for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n  }\n  int size() const {return value_.size();}\n  int index(const int v) const {return index_.at(v);}\n  int operator[](const int i) const {return value_.at(i);}\n private:\n  std::unordered_map<int, int> index_;\n  std::vector<int> value_;\n};\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = make_unique<Node>();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    unique_ptr<Node> l_child, r_child;\n  };\n  inline void push(const unique_ptr<Node>& n) {\n    if(not n->l_child) n->l_child = make_unique<Node>();\n    if(not n->r_child) n->r_child = make_unique<Node>();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  unique_ptr<Node> root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n  vector<int> x = {0, W};\n  for(auto q: event) {x.emplace_back(q.x1); x.emplace_back(q.x2);}\n  Compression cx(x);\n  for(auto& q: event) {q.x1 = cx.index(q.x1); q.x2 = cx.index(q.x2);}\n\n  SegmentTree flag(W);\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, cx.index(W));\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n//       cout<<\"l: \"<<l->left<<\" to \"<<l->right;cout<<endl;\n//       cout<<\"r: \"<<r->left<<\" to \"<<r->right;cout<<endl;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define y1 y233\nusing ll = long long;\nusing pii = pair <int, int>;\n\nconst int N = 1e5L + 11;\nconst int M = N * 4 + 11;\nconst int inf = 2e9L;\n\nint x1[N], y1[N], x2[N], y2[N];\n\nint lowbit(int x) { return x & (-x); }\nstruct BIT {\n\tint b[M];\n\tvoid clear() { fill(b, b + M, 0); }\n\tvoid change(int p, int x) {\n\t\tfor(p += 5; p < M; p += lowbit(p))\n\t\t\tb[p] += x;\n\t}\n\tint query(int p) {\n\t\tint r = 0;\n\t\tfor(p += 5; p; p -= lowbit(p))\n\t\t\tr += b[p];\n\t\treturn r;\n\t}\n}bit;\n\nstruct event {\n\tint p, type, k1, k2, id;\n\tbool operator <(event e) const {\n\t\treturn tie(p, type, k1, k2, id) < tie(e.p, e.type, e.k1, e.k2, e.id);\n\t}\n};\n\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\t/*\n\t{\n\t\tmap <int, int> mp;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tmp[x1[i]] = 0; mp[y1[i]] = 0;\n\t\t\tmp[x2[i]] = 0; mp[y2[i]] = 0;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(auto &p : mp)\n\t\t\tp.second = ++ cnt;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tx1[i] = mp[x1[i]]; y1[i] = mp[y1[i]];\n\t\t\tx2[i] = mp[x2[i]]; y2[i] = mp[y2[i]];\n\t\t}\n\t}\n\t*/\n\tvector <event> eves; int cnt = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(x1[i] == x2[i]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\teves.pb({y1[i], 0, x1[i], 1, ++ cnt});\n\t\t\teves.pb({y2[i] + 1, 0, x1[i], -1, cnt});\n\t\t} else {\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\teves.pb({y1[i], 1, x1[i], x2[i], 0});\n\t\t}\n\tiota(p, p + cnt + 1, 0);\n\tsort(eves.begin(), eves.end());\n\n\tset <pii> sts, stp;\n\tfor(int i = 0; i < M; i ++)\n\t\tsts.insert({i, i});\n\tstp.insert({M, 0});\n\n\tll m = 0, sp = 0;\n\tbit.clear();\n\tfor(auto e : eves)\n\t\tif(e.type == 0) {\n\t\t\tbit.change(e.k1, e.k2);\n\n\t\t\tif(e.k2 == 1) {\n\t\t\t\tstp.insert({e.k1, e.id});\n\t\t\t\tpii p = *(-- sts.lower_bound({e.k1, inf})); sts.erase(p);\n\t\t\t\tif(p.fi != e.k1) sts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, e.k1});\n\t\t\t\tif(p.se != e.k1) sts.insert({e.k1 + 1, p.se});\n\t\t\t} else {\n\t\t\t\tstp.erase({e.k1, e.id});\n\t\t\t}\n\t\t} else {\n\t\t\tm += bit.query(e.k2);\n\t\t\tm -= bit.query(e.k1 - 1);\n\n\t\t\tauto it = stp.lower_bound({e.k1, 0});\n\t\t\tif(it -> first > e.k2) { sp ++; continue; }\n\t\t\tint x = it -> second;\n\n\t\t\tit = -- sts.lower_bound({e.k1, inf});\n\t\t\tint l = it -> first, r = it -> second;\n\t\t\twhile(1) {\n\t\t\t\tauto is = stp.lower_bound({it -> first, 0});\n\t\t\t\tif(is -> first <= it -> second) {\n\t\t\t\t\tint y = is -> second;\n\t\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\t\tif(a != b) p[b] = a;\n\t\t\t\t}\n\n\t\t\t\tis = it ++;\n\t\t\t\tr = it -> second;\n\t\t\t\tif(is -> second >= e.k2) { sts.erase(is); break; }\n\t\t\t\tsts.erase(is);\n\t\t\t}\n\t\t\tsts.insert({l, r});\n\t\t}\n\tint ans = m - n + sp;\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tif(find(i) == i) ans ++;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\n\nstruct seg{\n\tint s, e, x;\n\tbool operator<(const seg &s)const{\n\t\treturn x < s.x;\n\t}\n};\n\nstruct sweep{\n\tint idx, pos, val;\n\tbool operator<(const sweep &s)const{\n\t\treturn pi(idx, val) < pi(s.idx, s.val);\n\t}\n};\n\nstruct disj{\n\tint pa[100050];\n\tvoid init(int n){\n\t\tfor(int i=1; i<=n; i++) pa[i] = i;\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nint xsz, ysz;\nvector<seg> xs, ys; \n\nint ds[200050];\n\nconst int B = 400;\nint bkt[505][405];\nint rep[505];\n\nvoid bkt_push(int x){\n\tif(rep[x] == 0) return;\n\tfor(int i=0; i<B; i++){\n\t\tif(bkt[x][i]){\n\t\t\tbkt[x][i] = rep[x];\n\t\t}\n\t}\n\trep[x] = 0;\n}\n\nvoid bkt_insert(int p, int v){\n\tbkt_push(p / B);\n\tbkt[p / B][p % B] = v;\n}\n\nvoid bkt_merge(int s, int e, int x){\n\tif(s/B == e/B){\n\t\tbkt_push(s/B);\n\t\tfor(int i=s%B; i<=e%B; i++){\n\t\t\tif(bkt[s/B][i]){\n\t\t\t\tdisj.uni(bkt[s/B][i], x);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(s%B) bkt_push(s/B);\n\twhile(s % B){\n\t\tif(bkt[s/B][s%B]){\n\t\t\tdisj.uni(bkt[s/B][s%B], x);\n\t\t}\n\t\ts++;\n\t}\n\tif(e%B != B-1) bkt_push(e/B);\t\n\twhile(e%B != B-1){\n\t\tif(bkt[e/B][e%B]){\n\t\t\tdisj.uni(bkt[e/B][e%B], x);\n\t\t}\n\t\te--;\n\t}\n\tfor(int i=s/B; i<=e/B; i++){\n\t\tif(rep[i]){\n\t\t\tdisj.uni(rep[i], x);\n\t\t}\n\t\telse{\n\t\t\tint chk = 0;\n\t\t\tfor(int j=0; j<B; j++){\n\t\t\t\tif(bkt[i][j]){\n\t\t\t\t\tdisj.uni(bkt[i][j], x);\n\t\t\t\t\tchk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chk) rep[i] = x;\n\t\t}\n\t}\n}\n\nint get_component(){\n\tdisj.init(xs.size());\n\tvector<sweep> swp;\n\tset<int> s;\n\tfor(auto &i : xs){\n\t\tswp.push_back({i.s, i.x, 1});\n\t\tswp.push_back({i.e+1, i.x, -1});\n\t}\n\tsort(swp.begin(), swp.end());\n\tint p = 0, q = 0, r = 0;\n\tint cnt = 1;\n\tfor(int i=1; i<=ysz+1; i++){\n\t\twhile(p < swp.size() && swp[p].idx == i){\n\t\t\tif(swp[p].val == 1){\n\t\t\t\tds[swp[p].pos] = ++r;\n\t\t\t\tbkt_insert(swp[p].pos, r);\n\t\t\t\ts.insert(swp[p].pos);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbkt_insert(swp[p].pos, 0);\n\t\t\t\ts.erase(swp[p].pos);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\twhile(q < ys.size() && ys[q].x == i){\n\t\t\tauto t = s.lower_bound(ys[q].s);\n\t\t\tif(t == s.end() || *t > ys[q].e){\n\t\t\t\tcnt++;\n\t\t\t\tq++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbkt_merge(ys[q].s, ys[q].e, ds[*t]);\n\t\t\tq++;\n\t\t}\n\t}\n\tfor(int i=2; i<=xs.size(); i++){\n\t\tif(disj.uni(1, i)) cnt++;\n\t}\n\treturn cnt;\n}\n\nstruct bit{\n\tint tree[200050];\n\tvoid add(int x, int v){\n\t\twhile(x <= xsz){\n\t\t\ttree[x] += v;\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint query(int x){\n\t\tint ret = 0;\n\t\twhile(x){\n\t\t\tret += tree[x];\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}bit;\n\nlint get_intersection(){\n\tvector<sweep> swp;\n\tfor(auto &i : xs){\n\t\tswp.push_back({i.s, i.x, 1});\n\t\tswp.push_back({i.e+1, i.x, -1});\n\t}\n\tsort(swp.begin(), swp.end());\n\tlint ret = 0;\n\tint p = 0;\n\tfor(auto &j : ys){\n\t\twhile(p < swp.size() && swp[p].idx <= j.x){\n\t\t\tbit.add(swp[p].pos, swp[p].val);\n\t\t\tp++;\n\t\t}\n\t\tret += bit.query(j.e) - bit.query(j.s-1);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tvector<int> vx, vy;\n\tint w, h, n;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tvx.push_back(0);\n\tvx.push_back(w);\n\tvy.push_back(0);\n\tvy.push_back(h);\n\tfor(int i=0; i<n; i++){\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\tvx.push_back(x1);\n\t\tvx.push_back(x2);\n\t\tvy.push_back(y1);\n\t\tvy.push_back(y2);\n\t\tif(x1 < x2){\n\t\t\tys.push_back({x1, x2, y1});\n\t\t}\n\t\tif(y1 < y2){\n\t\t\txs.push_back({y1, y2, x1});\n\t\t}\n\t}\n\txs.push_back({0, h, 0});\n\txs.push_back({0, h, w});\n\tys.push_back({0, w, 0});\n\tys.push_back({0, w, h});\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\tsort(vx.begin(), vx.end());\n\tsort(vy.begin(), vy.end());\n\tvx.resize(unique(vx.begin(), vx.end()) - vx.begin());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tfor(auto &i : xs){\n\t\tint l = lower_bound(vy.begin(), vy.end(), i.s) - vy.begin();\n\t\tint r = upper_bound(vy.begin(), vy.end(), i.e) - vy.begin() - 1;\n\t\tint x = lower_bound(vx.begin(), vx.end(), i.x) - vx.begin();\n\t\ti = {l+1, r+1, x+1};\n\t}\n\tfor(auto &i : ys){\n\t\tint l = lower_bound(vx.begin(), vx.end(), i.s) - vx.begin();\n\t\tint r = upper_bound(vx.begin(), vx.end(), i.e) - vx.begin() - 1;\n\t\tint x = lower_bound(vy.begin(), vy.end(), i.x) - vy.begin();\n\t\ti = {l+1, r+1, x+1};\n\t}\n\txsz = vx.size();\n\tysz = vy.size();\n\tcout << get_intersection() + get_component() - (n+4) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass unionfind {\npublic:\n\tclass node {\n\tpublic:\n\t\tint r, o, n;\n\t};\n\n\tnode* d;\n\n\tvoid init(int n) {\n\t\td = new node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i].o = i;\n\t\t\td[i].r = 0;\n\t\t\td[i].n = 1;\n\t\t}\n\t}\n\n\tint find(int a) {\n\t\tif (d[a].o == a) {\n\t\t\treturn a;\n\t\t}\n\t\treturn d[a].o = find(d[a].o);\n\t}\n\n\tvoid unit(int a, int b) {\n\t\tif (d[a].r > d[b].r) {\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse if (d[a].r == d[b].r) {\n\t\t\td[a].r++;\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse {\n\t\t\td[a].o = b;\n\t\t\td[a].n = 0;\n\t\t}\n\t}\n};\n\nclass bit {\npublic:\n\tint n;\n\tint* d;\n\t\n\tvoid init(int nw) {\n\t\tn = nw;\n\t\td = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = 0;\n\t\t}\n\t}\n\n\tvoid add(int b, int x) {\n\t\tfor (int i = b + 1; i <= n; i += (i & -i)) {\n\t\t\td[i - 1] += x;\n\t\t}\n\t}\n\n\tint sum(int b) {\n\t\tint all = 0;\n\t\tfor (int i = b + 1; i > 0; i -= (i & -i)) {\n\t\t\tall += d[i - 1];\n\t\t}\n\t\treturn all;\n\t}\n};\n\nint n1, n2;\n\nclass path {\npublic:\n\tint z, s, t;\n};\n\npath pl1[100100];\npath pl2[100100];\n\npath p1[100100];\npath p2[100100];\n\nint pp[100100];\nint pn;\n\nint bfind(int a) {\n\tint b = 0;\n\tint e = pn;\n\twhile (e - b > 1) {\n\t\tint m = (b + e) / 2;\n\t\tif (a < pp[m]) {\n\t\t\te = m;\n\t\t}\n\t\telse {\n\t\t\tb = m;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid zpress() {\n\tfor (int i = 0; i < n1; i++) {\n\t\tpp[i] = pl1[i].z;\n\t}\n\tsort(pp, pp + n1);\n\tpn = unique(pp, pp + n1) - pp;\n\tfor (int i = 0; i < n1; i++) {\n\t\tp1[i].z = bfind(pl1[i].z);\n\t\tp1[i].s = pl1[i].s;\n\t\tp1[i].t = pl1[i].t;\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\tp2[i].z = pl2[i].z;\n\t\tp2[i].s = bfind(pl2[i].s);\n\t\tif (pp[p2[i].s] < pl2[i].s) {\n\t\t\tp2[i].s++;\n\t\t}\n\t\tp2[i].t = bfind(pl2[i].t);\n\t}\n}\n\npair<int, pair<int, pair<int, int> > > tmp[1000000];\n\nint main() {\n\tint w, h, n;\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tn1 = 0;\n\tn2 = 0;\n\tpl1[n1].z = 0;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl1[n1].z = w;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl2[n2].z = 0;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tpl2[n2].z = h;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (a == c) {\n\t\t\tpl1[n1].z = a;\n\t\t\tpl1[n1].s = b;\n\t\t\tpl1[n1].t = d;\n\t\t\tn1++;\n\t\t}\n\t\telse {\n\t\t\tpl2[n2].z = b;\n\t\t\tpl2[n2].s = a;\n\t\t\tpl2[n2].t = c;\n\t\t\tn2++;\n\t\t}\n\t}\n\tzpress();\n\tint now = 0;\n\tfor (int i = 0; i < n1; i++) {\n\t\ttmp[now++] = make_pair(p1[i].s, make_pair(0, make_pair(p1[i].z, 0)));\n\t\ttmp[now++] = make_pair(p1[i].t, make_pair(2, make_pair(p1[i].z, 0)));\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\ttmp[now++] = make_pair(p2[i].z, make_pair(1, make_pair(p2[i].s, p2[i].t)));\n\t}\n\tsort(tmp, tmp + now);\n\tint ans = 0;\n\tunionfind uf;\n\tuf.init(n * 10);\n\tint unow = 0;\n\tmap<int, int> ss;\n\tmap<int, int> nj;\n\tnj[-1] = unow++;\n\tbit bb;\n\tbb.init(n + 100);\n\tfor (int i = 0; i < now; i++) {\n\t\t/*for (auto j : nj) {\n\t\t\tprintf(\"%d:%d \", j.first, j.second);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\tauto w = tmp[i];\n\t\tif (w.second.first == 0) {\n\t\t\tbb.add(w.second.second.first, 1);\n\t\t\tauto it = nj.lower_bound(w.second.second.first);\n\t\t\tit--;\n\t\t\tif (it != nj.end()) {\n\t\t\t\tint q = (*it).second;\n\t\t\t\tint nn;\n\t\t\t\tif (q < 0) {\n\t\t\t\t\tnn = unow++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn = (*it).second;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = nn;\n\t\t\t\tnj[w.second.second.first] = nn;\n\t\t\t\tss[(*it).first] = nn;\n\t\t\t\tss[w.second.second.first] = nn;\n\t\t\t}\n\t\t}\n\t\telse if (w.second.first == 1) {\n\t\t\tauto it = ss.lower_bound(w.second.second.first);\n\t\t\twhile (1) {\n\t\t\t\tauto itit = nj.find((*it).first);\n\t\t\t\titit++;\n\t\t\t\tif (itit == nj.end() || (*itit).first > w.second.second.second) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = -1;\n\t\t\t\tans--;\n\t\t\t\tauto itw = it;\n\t\t\t\tit++;\n\t\t\t\tss.erase(itw);\n\t\t\t}\n\t\t\tans += bb.sum(w.second.second.second) - bb.sum(w.second.second.first - 1) - 1;\n\t\t\t//printf(\"%d:%d,%d %d\\n\", w.first, w.second.second.first, w.second.second.second, ans);\n\t\t}\n\t\telse {\n\t\t\tbb.add(w.second.second.first, -1);\n\t\t\tauto it = nj.find(w.second.second.first);\n\t\t\tauto it2 = it;\n\t\t\tit2--;\n\t\t\tif ((*it).second >= 0) {\n\t\t\t\tif ((*it2).second < 0) {\n\t\t\t\t\tnj[(*it2).first] = (*it).second;\n\t\t\t\t\tss[(*it2).first] = (*it).second;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint aw = uf.find((*it).second);\n\t\t\t\t\tint bw = uf.find((*it2).second);\n\t\t\t\t\tif (aw != bw) {\n\t\t\t\t\t\tuf.unit(aw, bw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.erase((*it).first);\n\t\t\tnj.erase(it);\n\t\t}\n\t}\n\tfor (int i = 0; i < unow; i++) {\n\t\tans += uf.d[i].n;\n\t}\n\tans--;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node *l_child, *r_child;\n  };\n  inline void push(Node *n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node *n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node *n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node *root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  SegmentTree flag(W);\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, W);\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\n\tusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\npii Dir[] = {\n\t{ 0, 1 },{ -1 ,1 },{ -1, 0 },\n\t{ -1 ,-1 },{ 0,-1 },{ 1 ,-1 },\n\t{ 1,0 },{ 1 ,1 }\n};\n#define N (1<<17) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy = max(seg[2*k].lazy,seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2 * k + 1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum,seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl,vr);\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\nsigned main() {\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\n\tvector<pair<pair<ll, pll>, int>> ho;\n\tvector<pair<pll, int>> vs, ve;\n\tvector<ll> ax, ay;\n\tmap<ll, int> px, py;\n\n\tUnionFind uf(n + 1);\n\tint koutennsuu = 0;\n\tREP(i, n) {\n\t\tll sx, sy, ex, ey;\n\t\tscanf(\"%lld %lld %lld %lld\", &sx, &sy, &ex, &ey);\n\t\tif (sx == ex) {\n\t\t\tvs.push_back({ { sy, sx },i });\n\t\t\tve.push_back({ { ey, ex },i });\n\t\t}\n\t\telse {\n\t\t\tho.push_back({ { sy,{ sx,ex } },i });\n\t\t}\n\n\t\tif (!sx || !sy || !ex || !ey) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\t\tif (sx == w || ex == w || sy == h || ey == h) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\n\t\tax.push_back(sx);\n\t\tax.push_back(ex);\n\t\tay.push_back(sy);\n\t\tay.push_back(ey);\n\t}\n\tsort(ALL(ho));\n\tsort(ALL(vs));\n\tsort(ALL(ve));\n\tsort(ALL(ax));\n\tax.erase(unique(ALL(ax)),ax.end());\n\tsort(ALL(ay));\n\tay.erase(unique(ALL(ay)),ay.end());\n\tREP(i, ax.size()) {\n\t\tpx[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tpy[ay[i]] = i;\n\t}\n\n\tfenwick_tree<int> fw(ax.size());\n\tset < pii > ylist;\n\tint hoinp = 0, hooup = 0, vep = 0;\n\tREP(i, ay.size()) {\n\t\tfor (; hoinp < vs.size(); hoinp++) {\n\t\t\tif (vs[hoinp].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tfw.add(px[vs[hoinp].first.second], 1);\n\t\t\tylist.insert({ px[vs[hoinp].first.second], vs[hoinp].second });\n\t\t}\n\n\t\tfor (; vep < ho.size(); vep++) {\n\t\t\tif (ho[vep].first.first != ay[i])\n\t\t\t\tbreak;\n\n\t\t\tint a = px[ho[vep].first.second.first], b = px[ho[vep].first.second.second];\n\n\t\t\tkoutennsuu += fw.sum(a,b);\n\t\t\tint aln = get(a+1, b+1);\n\t\t\tint setn = ho[vep].second+ 1;\n\t\t\tif (aln) {\n\t\t\t\tuf.unionSet(aln-1, ho[vep].second);\n\t\t\t\tsetn = aln;\n\t\t\t}\n\t\t\tupdate(a+1,b+1,setn);\n\t\t}\n\n\t\tfor (; hooup < ve.size(); hooup++) {\n\t\t\tif (ve[hooup].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tint buf = px[vs[hooup].first.second];\n\t\t\tfw.add(px[vs[hooup].first.second], -1);\n\t\t\tylist.erase({ buf, vs[hooup].second });\n\t\t\tint nn = get(buf + 1, buf + 1);\n\t\t\tif (nn) {\n\t\t\t\tuf.unionSet(nn-1, ve[hooup].second);\n\t\t\t}\n\t\t\tupdate(buf+1,buf+1,0);\n\t\t}\n\t}\n\tint renketusuu = 0;\n\tREP(i, n+1) {\n\t\trenketusuu += uf.data[i] < 0;\n\t}\n\t//if (uf.data[n] < -1)\n\t\t//renketusuu++;\n\t//koutennsuu += 4;u\n\t//n += 4;\n\tprintf(\"%d\\n\", koutennsuu - n + renketusuu);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long N = 2e5 + 5;\nusing namespace std;\n\ntypedef pair <long long, long long> ii;\ntypedef pair <ii, long long> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nlong long w, h, n, x[2][N], y[2][N], a[20*N], pos[2][N], num, bit[N];\nlong long cnt, ver, root_ver[N], ans;\nbool check[20*N];\n\nstruct {\n    long long pset[N], numdsu;\n\n    void init (long long n){\n        for (long long i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    long long findset(long long i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(long long i, long long j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    long long val, left, right, cnt;\n} lv[20*N];\n\nvoid init(long long l, long long r){\n    long long nod = cnt;\n    if (l != r){\n        long long mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(long long k, long long l, long long r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        long long a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(long long k, long long l, long long r, long long pos, long long val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    long long mid = (l + r) / 2; long long nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(long long pos, long long val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (long long k, long long l, long long r, long long L, long long R, long long val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    long long mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(long long u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; long long v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(long long i, long long val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nlong long get(long long l, long long r){\n    long long ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (long long i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (long long i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (long long i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        long long z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (long long i = 0; i < mv.size(); i++){\n        long long z = mv[i].second, val = mv[i].first.first;\n\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    for (long long i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n + 1);\n\tvector<pair<pair<ll, pair<ll, ll>>,int>> y;\n\tvector<pair<pair<ll, ll>,int>> ts, te;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1, x2, y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tts.push_back({ { y1, x1 },i });\n\t\t\tte.push_back({ { y2, x2 },i });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({ { y1,{ x1,x2 } },i });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tsort(ALL(ts));\n\tsort(ALL(te));\n\tsort(ALL(y));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\tmap<ll, int> zatux,zatuy;\n\tREP(i, ax.size()) {\n\t\tzatux[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tzatuy[ay[i]] = i;\n\t}\n\t//vector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tfenwick_tree<int> ft(ax.size());\n\tfenwick_tree<int> le(ax.size());\n\t//vector<int> rt(ax.size());\n\tint tsind = 0,tsend = 0;\n\n\tset<pii> ut;\n\tREP(i, ay.size()) {\n\t\tfor(; ts.size() > tsind; tsind++) {\n\t\t\tif (ts[tsind].first.first == ay[i]) {\n\t\t\t\tint ind = zatux[ts[tsind].first.second];\n\t\t\t\tft.add(ind, 1);\n\t\t\t\t//le.add(ind - ax.begin(), 1);\n\t\t\t\tut.insert(make_pair(ind, ts[tsind].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tauto itrs = lower_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>)make_pair(make_pair(ay[i], make_pair(0, 0)), 0)),\n\t\t\titre = upper_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>) make_pair(make_pair(ay[i], make_pair(LLONG_MAX, LLONG_MAX)), INT_MAX));\n\t\tfor (auto itr = itrs; itr != itre; itr++) {\n\t\t\tint s = zatux[itr->first.second.first],\n\t\t\t\te = zatux[itr->first.second.second];\n\t\t\tint tcou = ft.sum(s, e);\n\t\t\tauto sti = upper_bound(ALL(ut), make_pair(e, INT_MAX));\n\t\t\t//le.add(s, itr->second);\n\t\t\t//le.add(e, itr->second);\n\t\t\tREP(j, tcou) {\n\t\t\t\tsti--;\n\n\t\t\t\tif (uf.findSet(itr->second, sti->second)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(itr->second, sti->second);\n\t\t\t}\n\t\t}\n\n\n\t\tfor (; te.size() > tsend; tsend++) {\n\t\t\tif (te[tsend].first.first == ay[i]) {\n\n\t\t\t\tint ind = zatux[te[tsend].first.second];\n\t\t\t\tft.add(ind, -1);\n\n\t\t\t\t//le.add(ind - ax.begin(), -1);\n\t\t\t\tut.erase(make_pair(ind, te[tsend].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\n\tusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\npii Dir[] = {\n\t{ 0, 1 },{ -1 ,1 },{ -1, 0 },\n\t{ -1 ,-1 },{ 0,-1 },{ 1 ,-1 },\n\t{ 1,0 },{ 1 ,1 }\n};\n#define N (1<<17) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy = max(seg[2*k].lazy,seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2 * k + 1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum,seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl,vr);\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\nsigned main() {\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\n\tvector<pair<pair<ll, pll>, int>> ho;\n\tvector<pair<pll, int>> vs, ve;\n\tvector<ll> ax, ay;\n\tmap<ll, int> px, py;\n\n\tUnionFind uf(n + 1);\n\tint koutennsuu = 0;\n\tREP(i, n) {\n\t\tll sx, sy, ex, ey;\n\t\tscanf(\"%lld %lld %lld %lld\", &sx, &sy, &ex, &ey);\n\t\tif (sx == ex) {\n\t\t\tvs.push_back({ { sy, sx },i });\n\t\t\tve.push_back({ { ey, ex },i });\n\t\t}\n\t\telse {\n\t\t\tho.push_back({ { sy,{ sx,ex } },i });\n\t\t}\n\n\t\tif (!sx || !sy || !ex || !ey) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\t\tif (sx == w || ex == w || sy == h || ey == h) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\n\t\tax.push_back(sx);\n\t\tax.push_back(ex);\n\t\tay.push_back(sy);\n\t\tay.push_back(ey);\n\t}\n\tsort(ALL(ho));\n\tsort(ALL(vs));\n\tsort(ALL(ve));\n\tsort(ALL(ax));\n\tax.erase(unique(ALL(ax)),ax.end());\n\tsort(ALL(ay));\n\tay.erase(unique(ALL(ay)),ay.end());\n\tREP(i, ax.size()) {\n\t\tpx[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tpy[ay[i]] = i;\n\t}\n\n\tfenwick_tree<int> fw(ax.size());\n\tset < pii > ylist;\n\tint hoinp = 0, hooup = 0, vep = 0;\n\tREP(i, ay.size()) {\n\t\tfor (; hoinp < vs.size(); hoinp++) {\n\t\t\tif (vs[hoinp].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tfw.add(px[vs[hoinp].first.second], 1);\n\t\t\tylist.insert({ px[vs[hoinp].first.second], vs[hoinp].second });\n\t\t}\n\n\t\tfor (; vep < ho.size(); vep++) {\n\t\t\tif (ho[vep].first.first != ay[i])\n\t\t\t\tbreak;\n\n\t\t\tint a = px[ho[vep].first.second.first], b = px[ho[vep].first.second.second];\n\n\t\t\tkoutennsuu += fw.sum(a,b);\n\t\t\tint aln = get(a+1, b+1);\n\t\t\tint setn = ho[vep].second+ 1;\n\t\t\tif (aln) {\n\t\t\t\tuf.unionSet(aln-1, ho[vep].second);\n\t\t\t\tsetn = aln;\n\t\t\t}\n\t\t\tupdate(a+1,b+1,setn);\n\t\t}\n\n\t\tfor (; hooup < ve.size(); hooup++) {\n\t\t\tif (ve[hooup].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tint buf = px[vs[hooup].first.second];\n\t\t\tfw.add(px[vs[hooup].first.second], -1);\n\t\t\tylist.erase({ buf, vs[hooup].second });\n\t\t\tint nn = get(buf + 1, buf + 1);\n\t\t\tif (nn) {\n\t\t\t\tuf.unionSet(nn-1, ve[hooup].second);\n\t\t\t}\n\t\t\tupdate(buf+1,buf+1,0);\n\t\t}\n\t}\n\tint renketusuu = 0;\n\tREP(i, n) {\n\t\trenketusuu += uf.data[i] < 0;\n\t}\n\t//if (uf.data[n] < -1)\n\t\t//renketusuu++;\n\t//koutennsuu += 4;\n\t//n += 4;\n\tprintf(\"%d\\n\", koutennsuu - n + renketusuu+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t == 1) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) {\n            add(it[1][i], id), pos[it[1][i]] = id;\n        }\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nint target[MAXN*2];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\ttarget[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tDSU::P.PB(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(DSU::Union(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass unionfind {\npublic:\n\tclass node {\n\tpublic:\n\t\tint r, o, n;\n\t};\n\n\tnode* d;\n\n\tvoid init(int n) {\n\t\td = new node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i].o = i;\n\t\t\td[i].r = 0;\n\t\t\td[i].n = 1;\n\t\t}\n\t}\n\n\tint find(int a) {\n\t\tif (d[a].o == a) {\n\t\t\treturn a;\n\t\t}\n\t\treturn d[a].o = find(d[a].o);\n\t}\n\n\tvoid unit(int a, int b) {\n\t\tif (d[a].r > d[b].r) {\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse if (d[a].r == d[b].r) {\n\t\t\td[a].r++;\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse {\n\t\t\td[a].o = b;\n\t\t\td[a].n = 0;\n\t\t}\n\t}\n};\n\nclass bit {\npublic:\n\tint n;\n\tint* d;\n\t\n\tvoid init(int nw) {\n\t\tn = nw;\n\t\td = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = 0;\n\t\t}\n\t}\n\n\tvoid add(int b, int x) {\n\t\tfor (int i = b + 1; i <= n; i += (i & -i)) {\n\t\t\td[i - 1] += x;\n\t\t}\n\t}\n\n\tint sum(int b) {\n\t\tint all = 0;\n\t\tfor (int i = b + 1; i > 0; i -= (i & -i)) {\n\t\t\tall += d[i - 1];\n\t\t}\n\t\treturn all;\n\t}\n};\n\nint n1, n2;\n\nclass path {\npublic:\n\tint z, s, t;\n};\n\npath pl1[100000];\npath pl2[100000];\n\npath p1[100000];\npath p2[100000];\n\nint pp[10000];\nint pn;\n\nint bfind(int a) {\n\tint b = 0;\n\tint e = pn;\n\twhile (e - b > 1) {\n\t\tint m = (b + e) / 2;\n\t\tif (a < pp[m]) {\n\t\t\te = m;\n\t\t}\n\t\telse {\n\t\t\tb = m;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid zpress() {\n\tfor (int i = 0; i < n1; i++) {\n\t\tpp[i] = pl1[i].z;\n\t}\n\tsort(pp, pp + n1);\n\tpn = unique(pp, pp + n1) - pp;\n\tfor (int i = 0; i < n1; i++) {\n\t\tp1[i].z = bfind(pl1[i].z);\n\t\tp1[i].s = pl1[i].s;\n\t\tp1[i].t = pl1[i].t;\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\tp2[i].z = pl2[i].z;\n\t\tp2[i].s = bfind(pl2[i].s);\n\t\tif (pp[p2[i].s] < pl2[i].s) {\n\t\t\tp2[i].s++;\n\t\t}\n\t\tp2[i].t = bfind(pl2[i].t);\n\t}\n}\n\npair<int, pair<int, pair<int, int> > > tmp[1000000];\n\nint main() {\n\tint w, h, n;\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tn1 = 0;\n\tn2 = 0;\n\tpl1[n1].z = 0;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl1[n1].z = w;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl2[n2].z = 0;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tpl2[n2].z = h;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (a == c) {\n\t\t\tpl1[n1].z = a;\n\t\t\tpl1[n1].s = b;\n\t\t\tpl1[n1].t = d;\n\t\t\tn1++;\n\t\t}\n\t\telse {\n\t\t\tpl2[n2].z = b;\n\t\t\tpl2[n2].s = a;\n\t\t\tpl2[n2].t = c;\n\t\t\tn2++;\n\t\t}\n\t}\n\tzpress();\n\tint now = 0;\n\tfor (int i = 0; i < n1; i++) {\n\t\ttmp[now++] = make_pair(p1[i].s, make_pair(0, make_pair(p1[i].z, 0)));\n\t\ttmp[now++] = make_pair(p1[i].t, make_pair(2, make_pair(p1[i].z, 0)));\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\ttmp[now++] = make_pair(p2[i].z, make_pair(1, make_pair(p2[i].s, p2[i].t)));\n\t}\n\tsort(tmp, tmp + now);\n\tint ans = 0;\n\tunionfind uf;\n\tuf.init(n * 10);\n\tint unow = 0;\n\tmap<int, int> ss;\n\tmap<int, int> nj;\n\tnj[-1] = unow++;\n\tbit bb;\n\tbb.init(n + 100);\n\tfor (int i = 0; i < now; i++) {\n\t\tauto w = tmp[i];\n\t\tif (w.second.first == 0) {\n\t\t\tbb.add(w.second.second.first, 1);\n\t\t\tauto it = nj.lower_bound(w.second.second.first);\n\t\t\tit--;\n\t\t\tif (it != nj.end()) {\n\t\t\t\tint q = (*it).second;\n\t\t\t\tint nn;\n\t\t\t\tif (q < 0) {\n\t\t\t\t\tnn = unow++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn = (*it).second;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = nn;\n\t\t\t\tnj[w.second.second.first] = nn;\n\t\t\t\tss[(*it).first] = nn;\n\t\t\t\tss[w.second.second.first] = nn;\n\t\t\t}\n\t\t}\n\t\telse if (w.second.first == 1) {\n\t\t\tauto it = ss.lower_bound(w.second.second.first);\n\t\t\twhile (1) {\n\t\t\t\tauto itit = nj.find((*it).first);\n\t\t\t\titit++;\n\t\t\t\tif (itit == nj.end() || (*itit).first > w.second.second.second) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = -1;\n\t\t\t\tans--;\n\t\t\t\tauto itw = it;\n\t\t\t\tit++;\n\t\t\t\tss.erase(itw);\n\t\t\t}\n\t\t\tans += bb.sum(w.second.second.second) - bb.sum(w.second.second.first - 1) - 1;\n\t\t}\n\t\telse {\n\t\t\tbb.add(w.second.second.first, -1);\n\t\t\tauto it = nj.find(w.second.second.first);\n\t\t\tauto it2 = it;\n\t\t\tit2--;\n\t\t\tif ((*it).second >= 0) {\n\t\t\t\tif ((*it2).second < 0) {\n\t\t\t\t\tnj[(*it2).first] = (*it).first;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint aw = uf.find((*it).second);\n\t\t\t\t\tint bw = uf.find((*it2).second);\n\t\t\t\t\tif (aw != bw) {\n\t\t\t\t\t\tuf.unit(aw, bw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.erase((*it).first);\n\t\t\tnj.erase(it);\n\t\t}\n\t}\n\tfor (int i = 0; i < unow; i++) {\n\t\tans += uf.d[i].n;\n\t}\n\tans--;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\tif (ST::Query(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(-1); S.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *----S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr);\n\t\t\tST::Insert(ll, rr);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        //cout << \" Insert: \" << a << \" \" << b << \" \" << xs.size() << endl;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE; r += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE; r += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\t//if (ST::Query(p)){\n\tif (seg.is_renew(p)){\n\n        //cout << \"?!\" << endl;\n\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\t//cout << V.left << \" \" << lf << endl;\n\t\t\t//cout << target[V.left] << \" \" << target[lf] << endl;\n\t\t\t//target[V.left] = target[lf];\n\t\t\t//cout << \"Joint: \" <<  target[V.left] << \" \" << target[lf] << endl;\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n        //cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n\nusing namespace std;\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nconst int INF = 1004567890;\n\n//0-based index???????????????????????°??????????????????\nnamespace bit\n{\n\tint arr[234567];\n\tint siz;\n\tvoid init(int n)\n\t{\n\t\t++n;\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t}\n\tvoid add(int ind, int val)\n\t{\n\t\tind++;\n\t\twhile (ind <= siz)\n\t\t{\n\t\t\tarr[ind] += val;\n\t\t\tind += (ind & -ind);\n\t\t}\n\t}\n\tint query(int right)\n\t{\n\t\tint ret = 0;\n\t\twhile (right > 0)\n\t\t{\n\t\t\tret += arr[right];\n\t\t\tright -= (right & -right);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nnamespace uf\n{\n\tvector<int>par, rnk;\n\tint vnum, gnum;\n\tvoid init() { vnum = 1; gnum = 1; par.push_back(0); rnk.push_back(0); }\n\tint addleaf()\n\t{\n\t\tpar.push_back(vnum);\n\t\trnk.push_back(0);\n\t\t++vnum;\n\t\t++gnum;\n\t\treturn vnum - 1;\n\t}\n\tint getpar(int x)\n\t{\n\t\tif (x == par[x])return x;\n\t\treturn par[x] = getpar(par[x]);\n\t}\n\tbool issame(int a, int b)\n\t{\n\t\treturn getpar(a) == getpar(b);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b)return;\n\t\t--gnum;\n\t\tif (rnk[a] < rnk[b])\n\t\t{\n\t\t\tpar[a] = b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tif (rnk[a] == rnk[b])rnk[a]++;\n\t\t}\n\t}\n}\n\nnamespace sgt\n{\n\tbool buf[234567];\n\tint width;\n\tvoid init(int n)\n\t{\n\t\twidth = 1;\n\t\twhile (width < n)width <<= 1;\n\t}\n\tvoid change_raw(int a, int b, int k, int l, int r)\n\t{\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b)\n\t\t{\n\t\t\tbuf[k] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tchange_raw(a, b, k + k + 1, l, m);\n\t\t\tchange_raw(a, b, k + k + 2, m, r);\n\t\t}\n\t}\n\tvoid change(int a, int b)\n\t{\n\t\tchange_raw(a, b, 0, 0, width);\n\t}\n\tvoid deflag_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return;\n\t\tbuf[k] = false;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return;\n\t\tdeflag_raw(x, k + k + 1, l, m);\n\t\tdeflag_raw(x, k + k + 2, m, r);\n\t}\n\tvoid deflag(int x)\n\t{\n\t\tdeflag_raw(x, 0, 0, width);\n\t}\n\tbool check_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return false;\n\t\tif (buf[k])return true;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return false;\n\t\treturn check_raw(x, k + k + 1, l, m) || check_raw(x, k + k + 2, m, r);\n\t}\n\tbool check(int x)\n\t{\n\t\treturn check_raw(x, 0, 0, width);\n\t}\n}\n\nenum QueryType { SPLIT, MERGE, CHANGE };\nstruct query\n{\n\tQueryType type;\n\tint yval;\n\tint xval1, xval2;\n\tquery(QueryType t, int y, int x1, int x2 = 0)\n\t\t:type(t), yval(y), xval1(x1), xval2(x2)\n\t{}\n};\n\nint w, h, n;\nvector<int>xlist;\nvector<query>que;\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tque.reserve(n * 2);\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tif (a == c)\n\t\t{\n\t\t\tif (b > d)swap(b, d);\n\t\t\tque.push_back({ SPLIT, b + b - 1, a });\n\t\t\tque.push_back({ MERGE, d + d + 1, a });\n\t\t\txlist.push_back(a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)swap(a, c);\n\t\t\tque.push_back({ CHANGE, b + b, a, c });\n\t\t}\n\t}\n\txlist.push_back(-INF);\n\txlist.push_back(0);\n\txlist.push_back(w);\n\tque.push_back({ SPLIT, -1, 0 });\n\tque.push_back({ SPLIT, -1, w });\n\tque.push_back({ MERGE, h + h + 1, 0 });\n\tque.push_back({ MERGE, h + h + 1, w });\n\tque.push_back({ CHANGE, 0,0,w });\n\tque.push_back({ CHANGE, h + h,0,w });\n\tsort(que.begin(), que.end(), [](const query& q1, const query& q2) {if (q1.yval == q2.yval)return q1.xval1 > q2.xval1;return q1.yval < q2.yval; });\n\tsort(xlist.begin(), xlist.end());\n\txlist.erase(unique(xlist.begin(), xlist.end()), xlist.end());\n\tset<pair<int, int>>bar;//first=left,second=index\n\tbar.insert({ -INF, 0 });\n\tint splitnum = 0;\n\tuf::init();\n\tsgt::init(xlist.size());\n\tbit::init(xlist.size());\n\tfor (auto& qq : que)\n\t{\n\t\tswitch (qq.type)\n\t\t{\n\t\tcase SPLIT:\n\t\t{\n\t\t\t//BIT???????????°????????????(???????????????1?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, 1);\n\t\t\t//?????????????????????????????????index?????\\???\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\t/*\n\t\t\tif (itr != bar.end())\n\t\t\t{\n\t\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), itr->first) - xlist.begin();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t//*/\n\t\t\t--itr;\n\t\t\tint index = itr->second;\n\t\t\t//??????????????´??°????¢???????\n\t\t\tint left = itr->first;\n\t\t\tint id = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(id))\n\t\t\t{\n\t\t\t\tindex = uf::addleaf();\n\t\t\t\tsgt::deflag(id);\n\t\t\t}\n\t\t\t//??????index??¨?????????????????????\n\t\t\tbar.insert({ qq.xval1, index });\n\t\t\t//???????¶????????????°??????????????¨??\\????????????\n\t\t\tbar.erase(pair<int, int>(itr->first, itr->second));\n\t\t\tbar.insert({ left, index });\n\n\t\t\t//????????´??°????????¶????????????\n\t\t\titr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\tif (itr != bar.end())\n\t\t\t{\n\t\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), itr->first) - xlist.begin();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MERGE:\n\t\t{\n\t\t\t//BIT???????????°????¶????(???????????????0?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, -1);\n\t\t\t//???????????¨????????????\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\tint rightindex = itr->second;\n\t\t\tint oldright = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint right = itr->first;\n\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), right) - xlist.begin();\n\t\t\tif (sgt::check(rid))\n\t\t\t{\n\t\t\t\trightindex = uf::addleaf();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t--itr;\n\t\t\tint leftindex = itr->second;\n\t\t\tint oldleft = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint left = itr->first;\n\t\t\tint lid = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(lid))\n\t\t\t{\n\t\t\t\tleftindex = uf::addleaf();\n\t\t\t\tsgt::deflag(lid);\n\t\t\t}\n\t\t\t//union find??¨??§??±?????????\n\t\t\tuf::unite(leftindex, rightindex);\n\t\t\t//??????????¶????????????°?????????????????\\??????\n\t\t\t\n\t\t\tbar.erase(pair<int, int>(right, oldright));\n\t\t\tbar.erase(pair<int, int>(left, oldleft));\n\t\t\tbar.insert({ left, leftindex });\n\t\t\tbreak;\n\t\t}\n\t\tcase CHANGE:\n\t\t{\n\t\t\t//????????£???????????????????¢????\n\t\t\tint ltex = bar.lower_bound({ qq.xval1,0 })->first;\n\t\t\tauto tmp = bar.upper_bound({ qq.xval2,INF+2 });\n\t\t\t--tmp;\n\t\t\tint rtex = (tmp)->first;\n\t\t\tint lind = lower_bound(xlist.begin(), xlist.end(), ltex) - xlist.begin();\n\t\t\tint rind = lower_bound(xlist.begin(), xlist.end(), rtex) - xlist.begin();\n\t\t\t//????????????????????\\????????????\n\t\t\tif(lind <= rind)sgt::change(lind, rind);\n\t\t\t//????????´??°\n\t\t\tsplitnum += max(0, bit::query(rind) - bit::query(lind));\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tint answer = splitnum - (uf::vnum - uf::gnum);\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI Y; namespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 1, Y.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); adjust(y1); adjust(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        y1 = LBD(Y, y1); y2 = LBD(Y, y2); if(y1 == y2){\n            A.PB(Event(x1, 0, y1, y2));\n            A.PB(Event(x2, 2, y1, y2));\n        }else{\n            A.PB(Event(x1, 1, y1, y2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0)); L.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H)); L.PB(Line(0,H,W,H));\n\n\tY.PB(-1); ECH(it, L) Y.PB(it->y1), Y.PB(it->y2); UNQ(Y);\n\tBIT::n = Y.size(); S.insert(0); DSU::P.resize(Y.size(), 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI Y; template<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n} //using namespace BIT;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, Y.size()-1\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nnamespace DSU{ //Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y; return 1;\n    }\n    void fix(int p){\n        if (ST::Query(p)){\n            int n = P.size(); P.PB(n);\n            P[p] = n;\n        }\n}\n} //using namespace DSU;\n\nLL res; int W, H, n; set<int> S;\n\nstruct Event{\n    int x, t, y1, y2;\n\n    Event(int x, int t, int y1, int y2):x(x),t(t),y1(y1),y2(y2){\n    }\n    bool operator<(const Event& rhs)const{\n        return x < rhs.x || x == rhs.x && t < rhs.t;\n    }\n    void gao(){\n\t\tif(!t){\n\t\t\ty1 = *--S.lower_bound(y2); DSU::fix(y1); DSU::fix(y2); DSU::Union(y1, y2);\n\t\t\tBIT::Add(y2, 1); S.insert(y2);\n\t\t}else if(t == 1){\n\t\t    int ll = *S.lower_bound(y1), rr = *--S.upper_bound(y2); if (rr < ll) return;\n\t\t\tres += BIT::Sum(ll, rr-1); ST::Insert(ll, rr-1);\n\t\t}else if(t == 2){\n\t\t\ty1 = *--S.lower_bound(y2); DSU::fix(y1); DSU::fix(y2); if(DSU::Union(y1, y2)) --res;\n\t\t\tBIT::Add(y2, -1); S.erase(y2);\n\t\t}\n    }\n}; vector<Event> A;\n\nstruct Line{\n    int x1, y1, x2, y2;\n    Line(int x1=0, int y1=0, int x2=0, int y2=0):x1(x1),y1(y1),x2(x2),y2(y2){\n    }\n    void in(){\n        RD(x1, y1, x2, y2);\n        if (x1 > x2) swap(x1, x2);\n        if (y1 > y2) swap(y1, y2);\n    }\n    void gao(){\n        y1 = LBD(Y, y1); y2 = LBD(Y, y2); if(y1 == y2){\n            A.PB(Event(x1, 0, y1, y2));\n            A.PB(Event(x2, 2, y1, y2));\n        }else{\n            A.PB(Event(x1, 1, y1, y2));\n        }\n    }\n}; vector<Line> L;\n\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tRD(W, H, n); L.resize(n); REP(i, n) L[i].in();\n\n\tL.PB(Line(0,0,W,0)); L.PB(Line(0,0,0,H));\n\tL.PB(Line(W,0,W,H)); L.PB(Line(0,H,W,H));\n\n\tY.PB(-1); ECH(it, L) Y.PB(it->y1), Y.PB(it->y2); UNQ(Y);\n\tBIT::n = Y.size(); S.insert(0); DSU::P.resize(Y.size(), 0);\n\n\tECH(it, L) it->gao(); SRT(A); res = 0; ECH(it, A) it->gao();\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "bool debug=false;\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stdio.h>\nusing namespace std;\n#define F first\n#define S second\n#define PB push_back\nconst int N=1e5+10;\nstruct seg_tree{\n\tvector<int> v,p,cnt,have;\n\tvoid init(int n,int l,int r){\n\t\tif(v.size()<=n){\n\t\t\tv.resize(n+1);\n\t\t\tcnt.resize(n+1);\n\t\t}\n\t\tif(l<r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tinit(n*2+1,l,mid);\n\t\t\tinit(n*2+2,mid+1,r);\n\t\t}\n\t\treturn ;\n\t}\n\tvoid init(int n){\n\t\tp.resize(n);\n\t\tfor(int i=0;i<n;i++)p[i]=i;\n\t\thave.resize(n);\n\t\tinit(0,0,n-1);\n\t\treturn ;\n\t}\n\tint find(int n){return p[n]==n?n:p[n]=find(p[n]);}\n\tvoid push_up(int n){\n\t\tcnt[n]=cnt[n*2+1]+cnt[n*2+2];\n\t\tif(v[n*2+1]==-1||v[n*2+2]==-1)v[n]=-1;\n\t\telse if(find(v[n*2+1])==find(v[n*2+2]))v[n]=find(v[n*2+1]);\n\t\telse if(v[n*2+1]==0)v[n]=find(v[n*2+2]);\n\t\telse if(v[n*2+2]==0)v[n]=find(v[n*2+1]);\n\t\telse v[n]=-1;\n\t}\n\tvoid fix(int n,int l,int r,int pos,int x){\n\t\tif(l==r){\n\t\t\tif(x==-1){\n\t\t\t\thave[pos]--;\n\t\t\t\tif(have[pos]==0)cnt[n]=v[n]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(have[pos]==0)cnt[n]++;\n\t\t\t\tv[n]=x;\n\t\t\t\thave[pos]++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(pos>mid)fix(n*2+2,mid+1,r,pos,x);\n\t\t\telse fix(n*2+1,l,mid,pos,x);\n\t\t\tpush_up(n);\n\t\t}\n\t\treturn ;\n\t}\n\tvoid merge(int n){\n\t\t//if(debug)printf(\"merge(%d)\\n\",n);\n\t\tif(v[n*2+1]==-1)merge(n*2+1);\n\t\tif(v[n*2+2]==-1)merge(n*2+2);\n\t\tif(v[n*2+1]==0)v[n]=find(v[n*2+2]);\n\t\telse if(v[n*2+2]==0)v[n]=find(v[n*2+1]);\n\t\telse v[n]=p[find(v[n*2+1])]=find(v[n*2+2]);\n\t\treturn ;\n\t}\n\tpair<int,int> ask(int n,int l,int r,int L,int R){\n\t\t//if(debug)printf(\"ask(%d,%d,%d,%d,%d)\\n\",n,l,r,L,R);\n\t\tif(L<=l&&r<=R){\n\t\t\tif(v[n]==-1)merge(n);\n\t\t\treturn {cnt[n],v[n]};\n\t\t}\n\t\telse if(l>R||L>r)return {0,0};\n\t\telse{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tpair<int,int> left=ask(n*2+1,l,mid,L,R),right=ask(n*2+2,mid+1,r,L,R),ans;\n\t\t\tans.F=left.F+right.F;\n\t\t\tif(left.S==0)ans.S=right.S;\n\t\t\telse if(right.S==0)ans.S=left.S;\n\t\t\telse ans.S=p[find(left.S)]=find(right.S);\n\t\t\treturn ans;\n\t\t}\n\t}\n\tint ask(int L,int R){\n\t\treturn ask(0,0,(int)p.size()-1,L,R).F;\n\t}\n};\nbool cmp(pair<pair<int,int>,int> a,pair<pair<int,int>,int> b){\n\treturn a.S<b.S;\n}\nint main(){\n\tint temp,w,h,n,x1,now=1,x2,y1,y2;\n\tlong long int line=0,point=0,comp=0;\n\tvector<int> x,y;\n\tvector<pair<pair<int,int>,int>> hor,ver;\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> in,out;\n\tseg_tree seg;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tx.PB(x1);x.PB(x2);\n\t\ty.PB(y1);y.PB(y2);\n\t\tif(x1==x2)hor.PB({{y1,y2},x1});\n\t\telse ver.PB({{x1,x2},y1});\n\t}\n\thor.PB({{0,h},0});\n\thor.PB({{0,h},w});\n\tver.PB({{0,w},0});\n\tver.PB({{0,w},h});\n\tx.PB(0);\n\tx.PB(w);\n\ty.PB(0);\n\ty.PB(h);\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.resize(unique(x.begin(),x.end())-x.begin());\n\ty.resize(unique(y.begin(),y.end())-y.begin());\n\tfor(int i=0;i<hor.size();i++)hor[i]={{lower_bound(y.begin(),y.end(),hor[i].F.F)-y.begin(),lower_bound(y.begin(),y.end(),hor[i].F.S)-y.begin()},lower_bound(x.begin(),x.end(),hor[i].S)-x.begin()};\n\tfor(int i=0;i<ver.size();i++)ver[i]={{lower_bound(x.begin(),x.end(),ver[i].F.F)-x.begin(),lower_bound(x.begin(),x.end(),ver[i].F.S)-x.begin()},lower_bound(y.begin(),y.end(),ver[i].S)-y.begin()};\n\tfor(int i=0;i<hor.size();i++){\n\t\tin.push({hor[i].F.F,hor[i].S});\n\t\tout.push({hor[i].F.S,hor[i].S});\n\t\tpoint+=2;\n\t\tline++;\n\t}\n\tsort(ver.begin(),ver.end(),cmp);\n\tn+=10;\n\tn<<=1;\n\tseg.init(n);\n\tfor(int i=0;i<ver.size();i++){\n\t\tif(debug)printf(\"ver[%d]=(%d,%d,%d)\\n\",i,ver[i].F.F,ver[i].F.S,ver[i].S);\n\t\twhile(!in.empty()){\n\t\t\tif(in.top().F<=ver[i].S){\n\t\t\t\tseg.fix(0,0,n-1,in.top().S,now++);\n\t\t\t\tin.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\twhile(!out.empty()){\n\t\t\tif(out.top().F<ver[i].S){\n\t\t\t\tseg.fix(0,0,n-1,out.top().S,-1);\n\t\t\t\tout.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\ttemp=seg.ask(ver[i].F.F,ver[i].F.S);\n\t\tpoint+=temp+2;\n\t\tline+=(temp<<1)+1;\n\t\tif(temp==0)comp++;\n\t\tif(debug)printf(\"%d::temp=%d point=%d line=%d comp=%d\\n\",i,temp,point,line,comp);\n\t\tif(debug)printf(\"now=%d\\n\",now);\n\t\tif(0&&debug){\n\t\t\tprintf(\"p::\");\n\t\t\tfor(int i=1;i<now;i++)printf(\" %d\",seg.p[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\twhile(!in.empty()){\n\t\tin.pop();\n\t\tcomp++;\n\t}\n\tfor(int i=1;i<now;i++)if(seg.p[i]==i)comp++;\n\tprintf(\"%lld\\n\",line-point+comp);\n\tif(debug)printf(\"line=%d point=%d comp=%d\\n\",line,point,comp);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 2e5 + 50;\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef pair <ii, int> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nint w, h, n, x[2][N], y[2][N], a[N], pos[2][N], num, bit[N];\nint cnt, ver, root_ver[N], ans;\nbool check[N];\n\nstruct {\n    int pset[N], numdsu;\n\n    void init (int n){\n        for (int i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    int findset(int i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(int i, int j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    int val, left, right, cnt;\n} lv[30*N];\n\nvoid init(int l, int r){\n    int nod = cnt;\n    if (l != r){\n        int mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(int k, int l, int r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        int a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(int k, int l, int r, int pos, int val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    int mid = (l + r) / 2; int nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(int pos, int val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (int k, int l, int r, int L, int R, int val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(int u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; int v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(int i, int val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nint get(int l, int r){\n    int ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (int i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (int i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        int z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (int i = 0; i < mv.size(); i++){\n        int z = mv[i].second, val = mv[i].first.first;\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    for (int i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans << \"\\n\";\n}\n/*\n10 10 1\n2 3 2 4\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\tif (ST::Query(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1;\n\t\t\tST::Insert(ll, rr-1);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass unionfind {\npublic:\n\tclass node {\n\tpublic:\n\t\tint r, o, n;\n\t};\n\n\tnode* d;\n\n\tvoid init(int n) {\n\t\td = new node[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i].o = i;\n\t\t\td[i].r = 0;\n\t\t\td[i].n = 1;\n\t\t}\n\t}\n\n\tint find(int a) {\n\t\tif (d[a].o == a) {\n\t\t\treturn a;\n\t\t}\n\t\treturn d[a].o = find(d[a].o);\n\t}\n\n\tvoid unit(int a, int b) {\n\t\tif (d[a].r > d[b].r) {\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse if (d[a].r == d[b].r) {\n\t\t\td[a].r++;\n\t\t\td[b].o = a;\n\t\t\td[b].n = 0;\n\t\t}\n\t\telse {\n\t\t\td[a].o = b;\n\t\t\td[a].n = 0;\n\t\t}\n\t}\n};\n\nclass bit {\npublic:\n\tint n;\n\tint* d;\n\t\n\tvoid init(int nw) {\n\t\tn = nw;\n\t\td = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = 0;\n\t\t}\n\t}\n\n\tvoid add(int b, int x) {\n\t\tfor (int i = b + 1; i <= n; i += (i & -i)) {\n\t\t\td[i - 1] += x;\n\t\t}\n\t}\n\n\tint sum(int b) {\n\t\tint all = 0;\n\t\tfor (int i = b + 1; i > 0; i -= (i & -i)) {\n\t\t\tall += d[i - 1];\n\t\t}\n\t\treturn all;\n\t}\n};\n\nint n1, n2;\n\nclass path {\npublic:\n\tint z, s, t;\n};\n\npath pl1[100100];\npath pl2[100100];\n\npath p1[100100];\npath p2[100100];\n\nint pp[100100];\nint pn;\n\nint bfind(int a) {\n\tint b = 0;\n\tint e = pn;\n\twhile (e - b > 1) {\n\t\tint m = (b + e) / 2;\n\t\tif (a < pp[m]) {\n\t\t\te = m;\n\t\t}\n\t\telse {\n\t\t\tb = m;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid zpress() {\n\tfor (int i = 0; i < n1; i++) {\n\t\tpp[i] = pl1[i].z;\n\t}\n\tsort(pp, pp + n1);\n\tpn = unique(pp, pp + n1) - pp;\n\tfor (int i = 0; i < n1; i++) {\n\t\tp1[i].z = bfind(pl1[i].z);\n\t\tp1[i].s = pl1[i].s;\n\t\tp1[i].t = pl1[i].t;\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\tp2[i].z = pl2[i].z;\n\t\tp2[i].s = bfind(pl2[i].s);\n\t\tif (pp[p2[i].s] < pl2[i].s) {\n\t\t\tp2[i].s++;\n\t\t}\n\t\tp2[i].t = bfind(pl2[i].t);\n\t}\n}\n\npair<int, pair<int, pair<int, int> > > tmp[1000000];\n\nint main() {\n\tint w, h, n;\n\tscanf(\"%d%d%d\", &w, &h, &n);\n\tn1 = 0;\n\tn2 = 0;\n\tpl1[n1].z = 0;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl1[n1].z = w;\n\tpl1[n1].s = 0;\n\tpl1[n1].t = h;\n\tn1++;\n\tpl2[n2].z = 0;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tpl2[n2].z = h;\n\tpl2[n2].s = 0;\n\tpl2[n2].t = w;\n\tn2++;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tif (a == c) {\n\t\t\tpl1[n1].z = a;\n\t\t\tpl1[n1].s = b;\n\t\t\tpl1[n1].t = d;\n\t\t\tn1++;\n\t\t}\n\t\telse {\n\t\t\tpl2[n2].z = b;\n\t\t\tpl2[n2].s = a;\n\t\t\tpl2[n2].t = c;\n\t\t\tn2++;\n\t\t}\n\t}\n\tzpress();\n\tint now = 0;\n\tfor (int i = 0; i < n1; i++) {\n\t\ttmp[now++] = make_pair(p1[i].s, make_pair(0, make_pair(p1[i].z, 0)));\n\t\ttmp[now++] = make_pair(p1[i].t, make_pair(2, make_pair(p1[i].z, 0)));\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\ttmp[now++] = make_pair(p2[i].z, make_pair(1, make_pair(p2[i].s, p2[i].t)));\n\t}\n\tsort(tmp, tmp + now);\n\tint ans = 0;\n\tunionfind uf;\n\tuf.init((n + 10) * 10);\n\tint unow = 0;\n\tmap<int, int> ss;\n\tmap<int, int> nj;\n\tnj[-1] = unow++;\n\tbit bb;\n\tbb.init(n + 100);\n\tfor (int i = 0; i < now; i++) {\n\t\t/*for (auto j : nj) {\n\t\t\tprintf(\"%d:%d \", j.first, j.second);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\tauto w = tmp[i];\n\t\tif (w.second.first == 0) {\n\t\t\tbb.add(w.second.second.first, 1);\n\t\t\tauto it = nj.lower_bound(w.second.second.first);\n\t\t\tit--;\n\t\t\tif (it != nj.end()) {\n\t\t\t\tint nn;\n\t\t\t\tif ((*it).second < 0) {\n\t\t\t\t\tnn = unow++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn = (*it).second;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = nn;\n\t\t\t\tss[(*it).first] = nn;\n\t\t\t\tnj[w.second.second.first] = nn;\n\t\t\t\tss[w.second.second.first] = nn;\n\t\t\t}\n\t\t}\n\t\telse if (w.second.first == 1) {\n\t\t\tauto it = ss.lower_bound(w.second.second.first);\n\t\t\twhile (1) {\n\t\t\t\tauto itit = nj.find((*it).first);\n\t\t\t\titit++;\n\t\t\t\tif (itit == nj.end() || (*itit).first > w.second.second.second) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnj[(*it).first] = -1;\n\t\t\t\tans--;\n\t\t\t\tauto itw = it;\n\t\t\t\tit++;\n\t\t\t\tss.erase(itw);\n\t\t\t}\n\t\t\tans += max(0, bb.sum(w.second.second.second) - bb.sum(w.second.second.first - 1) - 1);\n\t\t\t//printf(\"%d:%d,%d %d\\n\", w.first, w.second.second.first, w.second.second.second, ans);\n\t\t}\n\t\telse {\n\t\t\tbb.add(w.second.second.first, -1);\n\t\t\tauto it = nj.find(w.second.second.first);\n\t\t\tauto it2 = it;\n\t\t\tit2--;\n\t\t\tif ((*it).second >= 0) {\n\t\t\t\tif ((*it2).second < 0) {\n\t\t\t\t\tnj[(*it2).first] = (*it).second;\n\t\t\t\t\tss[(*it2).first] = (*it).second;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint aw = uf.find((*it).second);\n\t\t\t\t\tint bw = uf.find((*it2).second);\n\t\t\t\t\tif (aw != bw) {\n\t\t\t\t\t\tuf.unit(aw, bw);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss.erase((*it).first);\n\t\t\tnj.erase(it);\n\t\t}\n\t}\n\tfor (int i = 0; i < unow; i++) {\n\t\tans += uf.d[i].n;\n\t}\n\tans--;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n\treturn (uf[p] < 0) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\n\tif(p==q) return false;\n\n\tif(uf[p] < uf[q]) swap(p, q);\n\tuf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n\t\tuf.push_back(-1);\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = uf.size() - 1;\n\t}\n\n}\n\nint main()\n{\n\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(-1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        //cout << x << endl;\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        //cout << x << \" \" << y << endl;\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\tDSU::P.PB(0);\n\n\t//ST::Insert(0, xs.size());\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\n\tREP(i, xs.size()){\n\t    DSU::P.PB(0);\n\t}\n\n\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(V.left, lf);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\tint rett = ret;\n\t\t\tif(DSU::Union(lf, V.left)) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Point;\nenum : int { CREATEY, APPEARX, DELETEY};\n  \nstruct Event {\n  int y, idx, type;\n  bool operator<(const Event& e) const {\n    if(y == e.y) return(type < e.type);\n    return(y < e.y);\n  }\n};\n  \nstruct BinaryIndexedTree\n{\n  vector< int > data;\n  BinaryIndexedTree(int sz)\n  {\n    data.assign(sz + 2, 0);\n  }\n  int query(int k)\n  {\n    int ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return(ret);\n  }\n  void update(int k, int x)\n  {\n    for(++k; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n \nstruct SegmentTree\n{\n  vector< int > isnew;\n  int sz;\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    isnew.assign(2 * sz - 1, false);\n  }\n  inline void AddF(const int a, const int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return;\n    } else if(a <= l && r <= b) {\n      isnew[k] = true;\n    } else {\n      AddF(a, b, 2 * k + 1, l, (l + r) >> 1);\n      AddF(a, b, 2 * k + 2, (l + r) >> 1, r);\n    }\n  }\n  inline void DelF(const int a, const int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return;\n    } else if(a <= l && r <= a + 1) {\n      isnew[k] = false;\n    } else {\n      if(isnew[k]) {\n        isnew[2 * k + 1] = true;\n        isnew[2 * k + 2] = true;\n        isnew[k] = false;\n      }\n      DelF(a, b, 2 * k + 1, l, (l + r) >> 1);\n      DelF(a, b, 2 * k + 2, (l + r) >> 1, r);\n    }\n  }\n  inline void AddF(int a, int b)\n  {\n    AddF(a, b, 0, 0, sz);\n  }\n  inline void DelF(const int x)\n  {\n    DelF(x, x + 1, 0, 0, sz);\n  }\n  inline bool CheckF(int k)\n  {\n    k += sz - 1;\n    if(isnew[k]) return(true);\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      if(isnew[k]) return(true); \n   } while(k > 0);\n    return(false);\n  }\n};\n  \nstruct UnionFind {\n  vector< int > data;\n  UnionFind(){};\n  inline int Make()\n  {\n    data.push_back(-1);\n    return(data.size() - 1);\n  }\n  inline bool Unite(int a, int b)\n  {\n    a = Find(a), b = Find(b);\n    if(a == b) return(false);\n    if(data[a] > data[b]) swap(a, b);\n    data[a] += data[b];\n    data[b] = a;\n    return(true);\n  }\n  inline int Find(int k)\n  {\n    if(data[k] < 0) return(k);\n    else return(data[k] = Find(data[k]));\n  }\n};\n  \nSegmentTree *tree;\nUnionFind *uf;\nBinaryIndexedTree *bit;\nint decode[200020];\n  \n  \nint Evaluate(int x)\n{\n  if(tree -> CheckF(x)) {\n    tree -> DelF(x);\n    return(uf -> Make());\n  } else {\n    return(decode[x]);\n  }\n}\n  \nint Press(int *A, int sz1, int *B, int sz2)\n{\n  vector< int > nums;\n  copy(A, A + sz1, back_inserter(nums));\n  copy(B, B + sz2, back_inserter(nums));\n  nums.push_back(-1);\n  sort(nums.begin(), nums.end());\n  nums.erase(unique(nums.begin(), nums.end()), nums.end());\n  transform(A, A + sz1, A, [&](int x) {\n      return(lower_bound(nums.begin(), nums.end(), x) - nums.begin());\n  });\n  transform(B, B + sz2, B, [&](int x) {\n      return(lower_bound(nums.begin(), nums.end(), x) - nums.begin());\n  });\n  return(nums.size());\n}\n  \nint main()\n{\n  int W, H, N;\n  int A[100004], B[100004], C[100004], D[100004];\n   \n  scanf(\"%d %d %d\", &W, &H, &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d %d %d\", &A[i], &B[i], &C[i], &D[i]);\n  }\n   \n  A[N] = 0; B[N] = 0; C[N] = W; D[N] = 0; ++N;\n  A[N] = 0; B[N] = 0; C[N] = 0; D[N] = H; ++N;\n  A[N] = W; B[N] = 0; C[N] = W; D[N] = H; ++N;\n  A[N] = 0; B[N] = H; C[N] = W; D[N] = H; ++N;\n  \n  W = Press(A, N, C, N);\n  \n  vector< Event > Events;\n  /*\n    type = CREATEY: Y?????????????????????\n    type = DELETEY: Y????????????????¶????\n    type = APPEARX: X????????????\n  */\n  for(int i = 0; i < N; i++) {\n    if(A[i] == C[i]) {\n      Events.push_back((Event){B[i], i, CREATEY});\n      Events.push_back((Event){D[i], i, DELETEY});\n    } else {\n      Events.push_back((Event){B[i], i, APPEARX});\n    }\n  }\n  sort(Events.begin(), Events.end());\n  \n  set< int > pool;\n  uf = new UnionFind();\n  tree = new SegmentTree(W);\n  bit = new BinaryIndexedTree(W);\n  pool.insert(0); decode[0] = uf -> Make();\n  long long int sz = 0;\n  \n  for(int i = 0; i < Events.size(); i++) {\n    const Event& e = Events[i];\n    const int&   x = A[e.idx]; \n    if(e.type == CREATEY) {\n      int L = *--pool.lower_bound(x);\n      decode[x] = Evaluate(x);\n      decode[L] = Evaluate(L);\n      decode[x] = decode[L];\n      pool.insert(x);\n      bit -> update(x, 1);\n    } else if(e.type == DELETEY) {\n      int L = *--pool.lower_bound(x);\n      decode[x] = Evaluate(x);\n      decode[L] = Evaluate(L);\n      if(uf -> Unite(decode[x], decode[L])) --sz;\n      pool.erase(x);\n      bit -> update(x, -1);\n    } else {\n      int x2 = C[e.idx];\n      int RSQ = bit -> query(x2) - bit -> query(x - 1) - 1;\n      if(RSQ > 0) {\n        sz += RSQ;\n        tree -> AddF(x, *--pool.upper_bound(x2));\n      }\n    }\n  }\n  printf(\"%lld\\n\", sz);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\t//seg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t\tseg.set_renew(V.left, V.right);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\n// -------------------------------------------------- ライブラリ 1（非自明なやつ） ---------------------------------------------------\nconst int MAX_N = (1 << 19);\n\nclass SuperSegmentTree {\npublic:\n\tint size_ = 1;\n\tint A[MAX_N];\n\tset<int> dat[MAX_N * 2], idx[MAX_N];\n\tvector<int> I;\n\n\tvoid init(int sz) {\n\t\twhile (size_ <= sz) size_ *= 2;\n\t\tfor (int i = 0; i <= sz; i++) A[i] = 0;\n\t}\n\tvoid dels(int pos, int x) {\n\t\tidx[x].erase(pos); pos += size_;\n\t\tdat[pos].erase(x);\n\t\twhile (pos >= 1) {\n\t\t\tauto itr1 = dat[pos * 2 + 0].lower_bound(x);\n\t\t\tauto itr2 = dat[pos * 2 + 1].lower_bound(x);\n\t\t\tint cntv = 0;\n\t\t\tif (itr1 == dat[pos * 2 + 0].end() || (*itr1) != x) cntv++;\n\t\t\tif (itr2 == dat[pos * 2 + 1].end() || (*itr2) != x) cntv++;\n\t\t\tif (cntv == 2) dat[pos].erase(x);\n\t\t\tpos >>= 1;\n\t\t}\n\t}\n\tvoid adds(int pos, int x) {\n\t\tidx[x].insert(pos); pos += size_;\n\t\twhile (pos >= 1) {\n\t\t\tdat[pos].insert(x);\n\t\t\tpos >>= 1;\n\t\t}\n\t}\n\tvoid update(int pos, int x) {\n\t\tif (A[pos] != 0) {\n\t\t\tdels(pos, A[pos]);\n\t\t\tA[pos] = 0;\n\t\t}\n\t\tif (x != 0) {\n\t\t\tA[pos] = x;\n\t\t\tadds(pos, A[pos]);\n\t\t}\n\t}\n\tbool check(int x) {\n\t\tif (idx[x].size() >= 1) return true;\n\t\treturn false;\n\t}\n\tint reads(int pos) {\n\t\treturn A[pos];\n\t}\n\tvoid query(int l, int r, int a, int b, int u) {\n\t\tif (l <= a && b <= r) {\n\t\t\tauto itr = dat[u].begin();\n\t\t\twhile (itr != dat[u].end()) { I.push_back(*itr); itr++; }\n\t\t\treturn;\n\t\t}\n\t\tif (r <= a || b <= l) return;\n\t\tquery(l, r, a, (a + b) >> 1, u * 2);\n\t\tquery(l, r, (a + b) >> 1, b, u * 2 + 1);\n\t}\n\tvoid conquer(int cl, int cr) {\n\t\tI.clear();\n\t\tquery(cl, cr, 0, size_, 1);\n\t\tsort(I.begin(), I.end());\n\t\tI.erase(unique(I.begin(), I.end()), I.end());\n\n\t\tvector<pair<int, int>> Z;\n\t\tfor (int i : I) Z.push_back(make_pair(idx[i].size(), i));\n\t\tsort(Z.begin(), Z.end());\n\n\t\tfor (int i = 0; i < (int)Z.size() - 1; i++) {\n\t\t\tint pos = Z[i].second; vector<int> vecs;\n\t\t\tauto itr = idx[pos].begin();\n\t\t\twhile (itr != idx[pos].end()) { vecs.push_back(*itr); itr++; }\n\t\t\tfor (int j : vecs) update(j, Z[Z.size() - 1].second);\n\t\t}\n\t\treturn;\n\t}\n};\n\n// --------------------------------------------------- ライブラリ 2（自明なやつ） ----------------------------------------------------\nclass BIT {\npublic:\n\tint size_ = 1;\n\tvector<int> bit;\n\n\tvoid init(int sz) {\n\t\tsize_ = sz + 2;\n\t\tbit.resize(size_ + 2, 0);\n\t}\n\tvoid add(int pos, int x) {\n\t\tpos++;\n\t\twhile (pos <= size_) {\n\t\t\tbit[pos] += x;\n\t\t\tpos += (pos & -pos);\n\t\t}\n\t}\n\tint sum(int pos) {\n\t\tpos++; int s = 0;\n\t\twhile (pos >= 1) {\n\t\t\ts += bit[pos];\n\t\t\tpos -= (pos & -pos);\n\t\t}\n\t\treturn s;\n\t}\n};\n\nstruct Point {\n\tint px, py;\n};\n\nbool operator<(const Point& a1, const Point& a2) {\n\tif (a1.px < a2.px) return true;\n\tif (a1.px > a2.px) return false;\n\tif (a1.py < a2.py) return true;\n\treturn false;\n}\n\nbool operator==(const Point& a1, const Point& a2) {\n\tif (a1.px == a2.px && a1.py == a2.py) return true;\n\treturn false;\n}\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\n// -------------------------------------------- 本質 -----------------------------------------------\nint H, W, N;\nPoint G1[1 << 17], G2[1 << 17];\nvector<int> V[1 << 18][3];\nset<int> Set;\nSuperSegmentTree S;\n\nint main() {\n\t// ステップ 1. 入力\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\tfor (int i = 1; i <= N; i++) scanf(\"%d%d%d%d\", &G1[i].px, &G1[i].py, &G2[i].px, &G2[i].py);\n\tG1[N + 1] = Point{ 0, 0 }; G2[N + 1] = Point{ W,0 };\n\tG1[N + 2] = Point{ 0, H }; G2[N + 2] = Point{ W,H };\n\tG1[N + 3] = Point{ 0, 0 }; G2[N + 3] = Point{ 0,H };\n\tG1[N + 4] = Point{ W, 0 }; G2[N + 4] = Point{ W,H };\n\tN += 4;\n\n\t// ステップ 2. 座標圧縮\n\tvector<int> LX, LY;\n\tfor (int i = 1; i <= N; i++) {\n\t\tLX.push_back(G1[i].px); LY.push_back(G1[i].py);\n\t\tLX.push_back(G2[i].px); LY.push_back(G2[i].py);\n\t}\n\tsort(LX.begin(), LX.end()); LX.erase(unique(LX.begin(), LX.end()), LX.end());\n\tsort(LY.begin(), LY.end()); LY.erase(unique(LY.begin(), LY.end()), LY.end());\n\tfor (int i = 1; i <= N; i++) {\n\t\tG1[i].px = lower_bound(LX.begin(), LX.end(), G1[i].px) - LX.begin();\n\t\tG1[i].py = lower_bound(LY.begin(), LY.end(), G1[i].py) - LY.begin();\n\t\tG2[i].px = lower_bound(LX.begin(), LX.end(), G2[i].px) - LX.begin();\n\t\tG2[i].py = lower_bound(LY.begin(), LY.end(), G2[i].py) - LY.begin();\n\t\tif (G1[i].px > G2[i].px) swap(G1[i].px, G2[i].px);\n\t\tif (G1[i].py > G2[i].py) swap(G1[i].py, G2[i].py);\n\t}\n\tW = LX.size() - 1;\n\tH = LY.size() - 1;\n\n\t// ステップ 3. 頂点個数の数え上げ（準備編）\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (G1[i].px == G2[i].px) {\n\t\t\tV[G1[i].px][1].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tV[G1[i].px][0].push_back(i);\n\t\t\tV[G2[i].px][2].push_back(i);\n\t\t}\n\t}\n\n\tlong long Vertex = 0;\n\tlong long Edges = N;\n\tlong long Connect = 0;\n\n\t// ステップ 4. 頂点個数の数え上げ（実践編）\n\tBIT Z; Z.init(H + 2);\n\tfor (int i = 0; i <= W; i++) {\n\t\tfor (int j : V[i][0]) Z.add(G1[j].py, 1);\n\t\tfor (int j : V[i][1]) {\n\t\t\tVertex += 1LL * (Z.sum(G2[j].py) - Z.sum(G1[j].py - 1));\n\t\t}\n\t\tfor (int j : V[i][2]) Z.add(G1[j].py, -1);\n\t}\n\n\t// ステップ 5. 連結成分数の数え上げ\n\tint cnts = 0; S.init(H + 2);\n\tfor (int i = 0; i <= W; i++) {\n\t\tfor (int j : V[i][0]) {\n\t\t\tcnts++;\n\t\t\tS.update(G1[j].py, cnts);\n\t\t\tSet.insert(G1[j].py);\n\t\t}\n\t\tfor (int j : V[i][1]) {\n\t\t\tauto itr = Set.lower_bound(G1[j].py);\n\t\t\tif (itr == Set.end() || (*itr) > G2[j].py) Connect++;\n\t\t\telse {\n\t\t\t\tS.conquer(G1[j].py, G2[j].py + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int j : V[i][2]) {\n\t\t\tint val = S.reads(G1[j].py);\n\t\t\tS.update(G1[j].py, 0);\n\t\t\tif (S.check(val) == false) Connect++;\n\t\t\tSet.erase(G1[j].py);\n\t\t}\n\t}\n\n\t// ステップ 6. 出力\n\tcout << Vertex - Edges + Connect << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = make_unique<Node>();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    unique_ptr<Node> l_child, r_child;\n  };\n  inline void push(const unique_ptr<Node>& n) {\n    if(not n->l_child) n->l_child = make_unique<Node>();\n    if(not n->r_child) n->r_child = make_unique<Node>();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  unique_ptr<Node> root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  SegmentTree flag(W);\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, W);\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n//       cout<<\"l: \"<<l->left<<\" to \"<<l->right;cout<<endl;\n//       cout<<\"r: \"<<r->left<<\" to \"<<r->right;cout<<endl;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        //cout << x << endl;\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        //cout << x << \" \" << y << endl;\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.PB(-1); UNQ(xs);\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\n\n\tST::Insert(0, xs.size()); DSU::P.resize(xs.size()+1);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\n\t/*REP(i, xs.size()){\n\t    DSU::P.PB(0);\n\t}*/\n\n\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(V.left, lf);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\tint rett = ret;\n\t\t\tif(DSU::Union(lf, V.left)) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\n\nconst int INF = 1004567890;\n\n//0-based index???????????????????????°??????????????????\nnamespace bit\n{\n\tint arr[234567];\n\tint siz;\n\tvoid init(int n)\n\t{\n\t\t++n;\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t}\n\tvoid add(int ind, int val)\n\t{\n\t\tind++;\n\t\twhile (ind <= siz)\n\t\t{\n\t\t\tarr[ind] += val;\n\t\t\tind += (ind & -ind);\n\t\t}\n\t}\n\tint query(int right)\n\t{\n\t\tint ret = 0;\n\t\twhile (right > 0)\n\t\t{\n\t\t\tret += arr[right];\n\t\t\tright -= (right & -right);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nnamespace uf\n{\n\tvector<int>par, rnk;\n\tint vnum, gnum;\n\tvoid init() { vnum = 1; gnum = 1; par.push_back(0); rnk.push_back(0); }\n\tint addleaf()\n\t{\n\t\tpar.push_back(vnum);\n\t\trnk.push_back(0);\n\t\t++vnum;\n\t\t++gnum;\n\t\treturn vnum - 1;\n\t}\n\tint getpar(int x)\n\t{\n\t\tif (x == par[x])return x;\n\t\treturn par[x] = getpar(par[x]);\n\t}\n\tbool issame(int a, int b)\n\t{\n\t\treturn getpar(a) == getpar(b);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b)return;\n\t\t--gnum;\n\t\tif (rnk[a] < rnk[b])\n\t\t{\n\t\t\tpar[a] = b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tif (rnk[a] == rnk[b])rnk[a]++;\n\t\t}\n\t}\n}\n\nnamespace sgt\n{\n\tbool buf[234567];\n\tint width;\n\tvoid init(int n)\n\t{\n\t\twidth = 1;\n\t\twhile (width < n)width <<= 1;\n\t}\n\tvoid change_raw(int a, int b, int k, int l, int r)\n\t{\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b)\n\t\t{\n\t\t\tbuf[k] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tchange_raw(a, b, k + k + 1, l, m);\n\t\t\tchange_raw(a, b, k + k + 2, m, r);\n\t\t}\n\t}\n\tvoid change(int a, int b)\n\t{\n\t\tchange_raw(a, b, 0, 0, width);\n\t}\n\tvoid deflag_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return;\n\t\tbuf[k] = false;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return;\n\t\tdeflag_raw(x, k + k + 1, l, m);\n\t\tdeflag_raw(x, k + k + 2, m, r);\n\t}\n\tvoid deflag(int x)\n\t{\n\t\tdeflag_raw(x, 0, 0, width);\n\t}\n\tbool check_raw(int x, int k, int l, int r)\n\t{\n\t\tif (x < l || r <= x)return false;\n\t\tif (buf[k])return true;\n\t\tint m = (l + r) / 2;\n\t\tif (k >= width + width)return false;\n\t\treturn check_raw(x, k + k + 1, l, m) || check_raw(x, k + k + 2, m, r);\n\t}\n\tbool check(int x)\n\t{\n\t\treturn check_raw(x, 0, 0, width);\n\t}\n}\n\nenum QueryType { SPLIT, MERGE, CHANGE };\nstruct query\n{\n\tQueryType type;\n\tint yval;\n\tint xval1, xval2;\n\tquery(QueryType t, int y, int x1, int x2 = 0)\n\t\t:type(t), yval(y), xval1(x1), xval2(x2)\n\t{}\n};\n\nint w, h, n;\nvector<int>xlist;\nvector<query>que;\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\tque.reserve(n * 2);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tif (a == c)\n\t\t{\n\t\t\tif (b > d)swap(b, d);\n\t\t\tque.push_back({ SPLIT, b + b - 1, a });\n\t\t\tque.push_back({ MERGE, d + d + 1, a });\n\t\t\txlist.push_back(a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)swap(a, c);\n\t\t\tque.push_back({ CHANGE, b + b, a, c });\n\t\t}\n\t}\n\txlist.push_back(-INF);\n\txlist.push_back(0);\n\txlist.push_back(w);\n\tque.push_back({ SPLIT, -1, 0 });\n\tque.push_back({ SPLIT, -1, w });\n\tque.push_back({ MERGE, h + h + 1, 0 });\n\tque.push_back({ MERGE, h + h + 1, w });\n\tque.push_back({ CHANGE, 0,0,w });\n\tque.push_back({ CHANGE, h + h,0,w });\n\tsort(que.begin(), que.end(), [](const query& q1, const query& q2) {return q1.yval < q2.yval; });\n\tsort(xlist.begin(), xlist.end());\n\txlist.erase(unique(xlist.begin(), xlist.end()), xlist.end());\n\tset<pair<int, int>>bar;//first=left,second=index\n\tbar.insert({ -INF, 0 });\n\tint splitnum = 0;\n\tuf::init();\n\tsgt::init(xlist.size());\n\tbit::init(xlist.size());\n\tfor (auto& qq : que)\n\t{\n\t\tswitch (qq.type)\n\t\t{\n\t\tcase SPLIT:\n\t\t{\n\t\t\t//BIT???????????°????????????(???????????????1?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, 1);\n\t\t\t//?????????????????????????????????index?????\\???\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\t/*\n\t\t\tif (itr != bar.end())\n\t\t\t{\n\t\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), itr->first) - xlist.begin();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t//*/\n\t\t\t--itr;\n\t\t\tint index = itr->second;\n\t\t\t//??????????????´??°????¢???????\n\t\t\tint left = itr->first;\n\t\t\tint id = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(id))\n\t\t\t{\n\t\t\t\tindex = uf::addleaf();\n\t\t\t\tsgt::deflag(id);\n\t\t\t}\n\t\t\t//??????index??¨?????????????????????\n\t\t\tbar.insert({ qq.xval1, index });\n\t\t\t//???????¶????????????°??????????????¨??\\????????????\n\t\t\tbar.erase(pair<int, int>(itr->first, itr->second));\n\t\t\tbar.insert({ left, index });\n\t\t\tbreak;\n\t\t}\n\t\tcase MERGE:\n\t\t{\n\t\t\t//BIT???????????°????¶????(???????????????0?????????)\n\t\t\tauto itritr = lower_bound(xlist.begin(), xlist.end(), qq.xval1);\n\t\t\tint bitrel = *itritr;\n\t\t\tint bitid = lower_bound(xlist.begin(), xlist.end(), bitrel) - xlist.begin();\n\t\t\tbit::add(bitid, -1);\n\t\t\t//???????????¨????????????\n\t\t\tauto itr = lower_bound(bar.begin(), bar.end(), make_pair(qq.xval1, 0));\n\t\t\tint rightindex = itr->second;\n\t\t\tint oldright = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint right = itr->first;\n\t\t\tint rid = lower_bound(xlist.begin(), xlist.end(), right) - xlist.begin();\n\t\t\tif (sgt::check(rid))\n\t\t\t{\n\t\t\t\trightindex = uf::addleaf();\n\t\t\t\tsgt::deflag(rid);\n\t\t\t}\n\t\t\t--itr;\n\t\t\tint leftindex = itr->second;\n\t\t\tint oldleft = itr->second;\n\t\t\t//??´??°????¢????\n\t\t\tint left = itr->first;\n\t\t\tint lid = lower_bound(xlist.begin(), xlist.end(), left) - xlist.begin();\n\t\t\tif (sgt::check(lid))\n\t\t\t{\n\t\t\t\tleftindex = uf::addleaf();\n\t\t\t\tsgt::deflag(lid);\n\t\t\t}\n\t\t\t//union find??¨??§??±?????????\n\t\t\tuf::unite(leftindex, rightindex);\n\t\t\t//??????????¶????????????°?????????????????\\??????\n\t\t\tbar.erase(pair<int, int>(right, oldright));\n\t\t\tbar.erase(pair<int, int>(left, oldleft));\n\t\t\tbar.insert({ left, leftindex });\n\t\t\tbreak;\n\t\t}\n\t\tcase CHANGE:\n\t\t{\n\t\t\t//????????£???????????????????¢????\n\t\t\tint lind = lower_bound(xlist.begin(), xlist.end(), qq.xval1) - xlist.begin();\n\t\t\tint rind = upper_bound(xlist.begin(), xlist.end(), qq.xval2) - xlist.begin();\n\t\t\t//????????????????????\\????????????\n\t\t\tif(lind <= rind - 1)sgt::change(lind, rind - 1);\n\t\t\t//????????´??°\n\t\t\tsplitnum += max(0, bit::query(rind) - bit::query(lind) - 1);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tint answer = splitnum - (uf::vnum - uf::gnum);\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q)\n{\n\n    //cout << \"!\" << p << \" \" << q << endl;\n\n\tp = root(p);\n\n\t//cout << \"!\" << p << \" \" << q << endl;\n\n\tq = root(q);\n\n\t//cout << \"!\" << p << \" \" << q << endl;\n\n\tif(p==q) return false;\n\n\t//if(uf[p] < uf[q]) swap(p, q);\n\t//uf[p] = uf[q];\n\tuf[q] = p;\n\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t\tint count = seg.query(V.left, V.right+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\n\t\t\tseg.set_renew(V.left, *--S.upper_bound(V.right));\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define y1 y233\nusing ll = long long;\nusing pii = pair <int, int>;\n\nconst int N = 1e5L + 11;\nconst int M = N * 4 + 11;\n\nint x1[N], y1[N], x2[N], y2[N];\n\nint lowbit(int x) { return x & (-x); }\nstruct BIT {\n\tint b[M];\n\tvoid clear() { fill(b, b + M, 0); }\n\tvoid change(int p, int x) {\n\t\tfor(p += 5; p < M; p += lowbit(p))\n\t\t\tb[p] += x;\n\t}\n\tint query(int p) {\n\t\tint r = 0;\n\t\tfor(p += 5; p; p -= lowbit(p))\n\t\t\tr += b[p];\n\t\treturn r;\n\t}\n}bit;\n\nstruct event {\n\tint p, type, k1, k2, id;\n\tbool operator <(event e) const {\n\t\treturn tie(p, type, k1, k2, id) < tie(e.p, e.type, e.k1, e.k2, e.id);\n\t}\n};\n\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\t{\n\t\tmap <int, int> mp;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tmp[x1[i]] = 0; mp[y1[i]] = 0;\n\t\t\tmp[x2[i]] = 0; mp[y2[i]] = 0;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(auto &p : mp)\n\t\t\tp.second = ++ cnt;\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\tx1[i] = mp[x1[i]]; y1[i] = mp[y1[i]];\n\t\t\tx2[i] = mp[x2[i]]; y2[i] = mp[y2[i]];\n\t\t}\n\t}\n\tvector <event> eves; int cnt = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(x1[i] == x2[i]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\teves.pb({y1[i], 0, x1[i], 1, ++ cnt});\n\t\t\teves.pb({y2[i] + 1, 0, x1[i], -1, cnt});\n\t\t} else {\n\t\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\t\teves.pb({y1[i], 1, x1[i], x2[i], 0});\n\t\t}\n\tiota(p, p + cnt + 1, 0);\n\tsort(eves.begin(), eves.end());\n\n\tset <pii> sts, stp;\n\tfor(int i = 0; i < M; i ++)\n\t\tsts.insert({i, i});\n\tstp.insert({M, 0});\n\n\tll m = 0;\n\tbit.clear();\n\tfor(auto e : eves)\n\t\tif(e.type == 0) {\n\t\t\tbit.change(e.k1, e.k2);\n\n\t\t\tif(e.k2 == 1) {\n\t\t\t\tstp.insert({e.k1, e.id});\n\t\t\t\tpii p = *sts.lower_bound({e.k1, 0}); sts.erase(p);\n\t\t\t\tif(p.fi != e.k1) sts.insert({p.fi, e.k1 - 1});\n\t\t\t\tsts.insert({e.k1, e.k1});\n\t\t\t\tif(p.se != e.k1) sts.insert({e.k1 + 1, p.se});\n\t\t\t} else {\n\t\t\t\tstp.erase({e.k1, e.id});\n\t\t\t}\n\t\t} else {\n\t\t\tm += bit.query(e.k2);\n\t\t\tm -= bit.query(e.k1 - 1);\n\n\t\t\tauto it = stp.lower_bound({e.k1, 0});\n\t\t\tif(it -> first > e.k2) continue;\n\t\t\tint x = it -> second;\n\n\t\t\tit = sts.lower_bound({e.k1, 0});\n\t\t\tif(e.k1 != it -> fi) it --;\n\t\t\tint l = it -> first, r = it -> second;\n\t\t\twhile(1) {\n\t\t\t\tauto is = stp.lower_bound({it -> first, 0});\n\t\t\t\tif(is -> first <= it -> second) {\n\t\t\t\t\tint y = is -> second;\n\t\t\t\t\tint a = find(x), b = find(y);\n\t\t\t\t\tif(a != b) p[b] = a;\n\t\t\t\t}\n\n\t\t\t\tis = it ++;\n\t\t\t\tr = it -> second;\n\t\t\t\tif(is -> second >= e.k2) { sts.erase(is); break; }\n\t\t\t\tsts.erase(is);\n\t\t\t}\n\t\t\tsts.insert({l, r});\n\t\t}\n\tint ans = m - n;\n\tfor(int i = 1; i <= cnt; i ++)\n\t\tif(find(i) == i) ans ++;\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n + 1);\n\tvector<pair<pair<ll, pair<ll, ll>>,int>> y;\n\tvector<pair<pair<ll, ll>,int>> ts, te;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1, x2, y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tts.push_back({ { y1, x1 },i });\n\t\t\tte.push_back({ { y2, x2 },i });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({ { y1,{ x1,x2 } },i });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tsort(ALL(ts));\n\tsort(ALL(te));\n\tsort(ALL(y));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\t//vector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tfenwick_tree<int> ft(ax.size());\n\tfenwick_tree<int> le(ax.size());\n\t//vector<int> rt(ax.size());\n\tint tsind = 0,tsend = 0;\n\n\tset<pii> ut;\n\tREP(i, ay.size()) {\n\t\tfor(; ts.size() > tsind; tsind++) {\n\t\t\tif (ts[tsind].first.first == ay[i]) {\n\t\t\t\tauto ind = lower_bound(ALL(ax), ts[tsind].first.second);\n\t\t\t\tft.add(ind-ax.begin(), 1);\n\t\t\t\t//le.add(ind - ax.begin(), 1);\n\t\t\t\tut.insert(make_pair(ind - ax.begin(), ts[tsind].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tauto itrs = lower_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>)make_pair(make_pair(ay[i], make_pair(0, 0)), 0)),\n\t\t\titre = upper_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>) make_pair(make_pair(ay[i], make_pair(LLONG_MAX, LLONG_MAX)), INT_MAX));\n\t\tfor (auto itr = itrs; itr != itre; itr++) {\n\t\t\tint s = lower_bound(ALL(ax), itr->first.second.first) - ax.begin(),\n\t\t\t\te = lower_bound(ALL(ax), itr->first.second.second) - ax.begin();\n\t\t\tint tcou = ft.sum(s, e);\n\t\t\tauto sti = upper_bound(ALL(ut), make_pair(e, INT_MAX));\n\t\t\t//le.add(s, itr->second);\n\t\t\t//le.add(e, itr->second);\n\t\t\tREP(j, tcou) {\n\t\t\t\tsti--;\n\n\t\t\t\tif (uf.findSet(itr->second, sti->second)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(itr->second, sti->second);\n\t\t\t}\n\t\t}\n\n\n\t\tfor (; te.size() > tsend; tsend++) {\n\t\t\tif (te[tsend].first.first == ay[i]) {\n\n\t\t\t\tauto ind = lower_bound(ALL(ax), te[tsend].first.second);\n\t\t\t\tft.add(ind - ax.begin(), -1);\n\n\t\t\t\t//le.add(ind - ax.begin(), -1);\n\t\t\t\tut.erase(make_pair(ind - ax.begin(), te[tsend].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100005;\n\nint w, h, n;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nint cnt, cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n    //cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t == 1) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) {\n            add(it[1][i], id), pos[it[1][i]] = id;\n        }\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n                //j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n            //j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define y1 y233\nconst int N = 1e5L + 11;\nint x1[N], y1[N], x2[N], y2[N];\nint p[N];\nint find(int x) {\n\tif(p[x] == x) return x;\n\treturn p[x] = find(p[x]);\n}\n\nint main() {\n\tint w, h, n; cin >> w >> h >> n;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = 0; y1[n] = 0; x2[n] = 0; y2[n] = h;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = w; y2[n] = 0;\n\tn ++; x1[n] = w; y1[n] = h; x2[n] = 0; y2[n] = h;\n\n\tint m = 0;\n\tiota(p, p + n + 1, 0);\n\tfor(int i = 1; i <= n; i ++) if(x1[i] == x2[i])\n\t\tfor(int j = 1; j <= n; j ++) if(y1[j] == y2[j]) {\n\t\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t\t\tif(x1[j] > x2[j]) swap(x1[j], x2[j]);\n\t\t\tif(y1[i] <= y1[j] && y1[j] <= y2[i] &&\n\t\t\t\tx1[j] <= x1[i] && x1[i] <= x2[j]) {\n\t\t\t\tm ++;\n\t\t\t\tint a = find(i), b = find(j);\n\t\t\t\tif(a != b) p[b] = a;\n\t\t\t}\n\t\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i ++) if(p[find(i)] == i) cnt ++;\n\tcout << m - n + cnt << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n    Line (int x1, int y1, int x2, int y2) :\n        x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nstruct Query {\n    int l, r, id;\n\n    Query (int l, int r, int id) :\n        l(l), r(r), id(id) {}\n\n    void dbg() {\n        cout << \"Query \" << l << ' ' << r << ' ' << id << '\\n';\n    }\n};\n\nstruct Update {\n    int p, t, id;\n\n    Update (int p, int t, int id) :\n        p(p), t(t), id(id) {}\n\n    void dbg() {\n        cout << \"Update \" << p << ' ' << t << ' ' << id << '\\n';\n    }\n};\n\nconst int N = 100010;\n\nint w, h, n, cnt;\nint it[2][8 * N];\nint go[2][40 * N];\nint pos[40 * N];\nbool visit[40 * N];\nlong long cntv, cnte, cntc;\nvector<Line> a;\nvector<int> vx, vy, G[N];\nvector<Update> update[N * 2];\nvector<Query> query[N * 2];\n\nvoid addEdge(int u, int v) {\n//    cout << u << ' ' << v << '\\n';\n    G[u].push_back(v), G[v].push_back(u);\n}\n\nvoid add(int x, int y) {\n    if (pos[x]) addEdge(pos[x], y);\n    pos[x] = y;\n    if (visit[x]) return; visit[x] = 1;\n    for (int i = 0; i < 2; ++i) {\n        if (!go[i][x]) continue;\n        add(go[i][x], y);\n    }\n}\n\nvoid upd(int i, int l, int r, int p, int t, int id) {\n    it[0][i] += t, it[1][i] = ++cnt;\n    if (!it[0][i]) it[1][i] = 0;\n    if (l == r) {\n        if (t == 1) pos[it[1][i]] = id; return;\n    }\n    int mid = (l + r) >> 1;\n    if (p <= mid) upd(i << 1, l, mid, p, t, id);\n    else upd(i << 1 | 1, mid + 1, r, p, t, id);\n    go[0][it[1][i]] = it[1][i << 1], go[1][it[1][i]] = it[1][i << 1 | 1];\n}\n\nint get(int i, int l, int r, int u, int v, int id) {\n    if (l > v || u > r) return 0;\n    if (u <= l && r <= v) {\n        if (it[1][i]) add(it[1][i], id);\n        return it[0][i];\n    }\n    int mid = (l + r) >> 1;\n    return get(i << 1, l, mid, u, v, id) + get(i << 1 | 1, mid + 1, r, u, v, id);\n}\n\nvoid dfs(int u) {\n    visit[u] = 1;\n    for (auto v : G[u]) {\n        if (!visit[v]) dfs(v);\n    }\n}\n\nvoid addLine(int x1, int y1, int x2, int y2) {\n    a.push_back(Line(x1, y1, x2, y2));\n    vx.push_back(x1), vx.push_back(x2);\n    vy.push_back(y1), vy.push_back(y2);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> w >> h >> n;\n\n    addLine(0, 0, 0, h);\n    addLine(0, h, w, h);\n    addLine(w, 0, w, h);\n    addLine(0, 0, w, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        addLine(x1, y1, x2, y2);\n    }\n\n    n += 4, cntv = n * 2, cnte = cnt = n;\n    sort(vx.begin(), vx.end()), sort(vy.begin(), vy.end());\n\n    for (int i = 0; i < n; ++i) {\n        a[i].x1 = lower_bound(vx.begin(), vx.end(), a[i].x1) - vx.begin();\n        a[i].y1 = lower_bound(vy.begin(), vy.end(), a[i].y1) - vy.begin();\n        a[i].x2 = lower_bound(vx.begin(), vx.end(), a[i].x2) - vx.begin();\n        a[i].y2 = lower_bound(vy.begin(), vy.end(), a[i].y2) - vy.begin();\n\n        if (a[i].y1 == a[i].y2) {\n            update[a[i].x1].push_back(Update(a[i].y1, 1, i + 1));\n            update[a[i].x2 + 1].push_back(Update(a[i].y2, -1, i + 1));\n        }\n        else {\n            query[a[i].x1].push_back(Query(a[i].y1, a[i].y2, i + 1));\n        }\n    }\n\n    for (int i = 0; i < n * 2; ++i) {\n        for (auto j : update[i]) {\n            if (j.t == -1) {\n//                j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : update[i]) {\n            if (j.t ==  1) {\n//                j.dbg();\n                upd(1, 0, n * 2, j.p, j.t, j.id);\n            }\n        }\n        for (auto j : query[i]) {\n//            j.dbg();\n            int tmp = get(1, 0, n * 2, j.l, j.r, j.id);\n            cntv += tmp, cnte += tmp * 2;\n        }\n    }\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= n; ++i) {\n        if (!visit[i]) dfs(i), cntc++;\n    }\n\n    //cout << \"End \" << cntc << ' ' << cntv << ' ' << cnte << '\\n';\n    cout << cntc - cntv + cnte << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong long H, W, N, a[100000], b[100000], c[100000], d[100000], x[4000][4000]; bool used[4000][4000];\nvector<long long>X, Y; queue<pair<long long, long long>>Q;\nint main() {\n\tcin >> H >> W >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i] >> d[i];\n\t\tX.push_back(a[i]); X.push_back(c[i]); Y.push_back(b[i]); Y.push_back(d[i]);\n\t}\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end()); unique(X.begin(), X.end()); unique(Y.begin(), Y.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tint pos1 = lower_bound(X.begin(), X.end(), a[i]) - X.begin(); a[i] = pos1 * 2;\n\t\tint pos2 = lower_bound(Y.begin(), Y.end(), b[i]) - Y.begin(); b[i] = pos1 * 2;\n\t\tint pos3 = lower_bound(X.begin(), X.end(), c[i]) - X.begin(); c[i] = pos1 * 2;\n\t\tint pos4 = lower_bound(Y.begin(), Y.end(), d[i]) - Y.begin(); d[i] = pos1 * 2;\n\t\tif (pos1 == pos3) { for (int j = pos2; j < pos4; j++)x[pos1][j] = 1; }\n\t\tif (pos2 == pos4) { for (int j = pos1; j < pos3; j++)x[j][pos2] = 1; }\n\t}\n\tH = (X.size() - 1) * 2, W = (Y.size() - 1) * 2; int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\tlong long cnt = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (used[i][j] == true)continue;\n\t\t\tQ.push(make_pair(i, j)); used[i][j] = true;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint cx = a1 + dx[k], cy = a2 + dy[k];\n\t\t\t\t\tif (used[cx][cy] == false) { Q.push(make_pair(cx, cy)); used[cx][cy] = true; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n public:\n  void unite(int a, int b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  int find(int x) {\n    if(!parent_[x]) parent_[x] = x;\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n  UnionFind(int n) : parent_(n), rank_(n) {}\n private:\n  vector<int> parent_;\n  vector<int> rank_;\n};\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = make_unique<Node>();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    unique_ptr<Node> l_child, r_child;\n  };\n  inline void push(const unique_ptr<Node>& n) {\n    if(not n->l_child) n->l_child = make_unique<Node>();\n    if(not n->r_child) n->r_child = make_unique<Node>();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, const unique_ptr<Node>& n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  unique_ptr<Node> root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  SegmentTree flag(W);\n  UnionFind group(1e7);\n  int id = 1;\n  set<Node> node;\n  node.emplace(id, 0, W);\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n//       cout<<\"l: \"<<l->left<<\" to \"<<l->right;cout<<endl;\n//       cout<<\"r: \"<<r->left<<\" to \"<<r->right;cout<<endl;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<int> res;\n  for(auto i = 1; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n public:\n  void unite(int a, int b) {p_[find(b)] = find(a);}\n  int find(int x) {return p_[x] == x ? x : p_[x] = find(p_[x]);}\n  int make() {p_.push_back(p_.size()); return p_.size() - 1;}\n private:\n  vector<int> p_;\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = make_unique<Node>();\n  }\n  void add(int a, int b, int v) {add(a, b+1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int v, lazy;\n    unique_ptr<Node> l, r;\n  };\n  void push(const auto& n) {\n    if(not n->l) n->l = make_unique<Node>();\n    if(not n->r) n->r = make_unique<Node>();\n    if(n->lazy) {\n      n->l->lazy += n->lazy;\n      n->r->lazy += n->lazy;\n      n->v += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, const auto& n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;}\n    add(a, b, v, n->l, l, (l+r)/2);\n    add(a, b, v, n->r, (l+r)/2, r);\n  }\n  int find(int x, const auto& n, int l, int r) {\n    push(n);\n    if(x==l && x+1==r) return n->v;\n    auto m = (l+r)/2;\n    if(x < m) find(x, n->l, l, m);\n    else      find(x, n->r, m, r);\n  }\n  int size_;\n  unique_ptr<Node> root_;\n};\n\nstruct Node {\n  int l, r, id;\n  Node(int x) : l(x), r(2e9), id(2e9) {}\n  Node(int l, int r, int id) : l(l), r(r), id(id) {}\n  bool operator<(auto n) const {return make_tuple(l, r, id) < make_tuple(n.l, n.r, n.id);}\n};\n\nenum {Y_IN, X, Y_OUT};\nstruct Event {\n  int y, type, l, r;\n  bool operator<(auto e) {return make_tuple(y, type, l, r) < make_tuple(e.y, e.type, e.l, e.r);}\n};\n\nint main() {\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  vector<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN, A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n  event.push_back({0, X, 0, W});\n  event.push_back({H, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  for(auto& i: event) {++i.l; ++i.r;}\n  sort(begin(event), end(event));\n\n  long long ans = 0;\n\n  SegmentTree flag(W+3);\n  UnionFind uf;\n  set<Node> dp;\n  dp.emplace(0, W+3, uf.make());\n  for(auto q: event) {\n    if(q.type == Y_IN) {\n      auto n = --dp.upper_bound(q.l);\n      auto f = flag.find(n->l);\n      auto i = f ? uf.make() : n->id;\n      auto j = uf.make();\n      flag.add(n->l, n->r-1, -f);\n      ans += f;\n      uf.unite(i, j);\n      dp.emplace(n->l, q.l, i);\n      dp.emplace(q.l, n->r, j);\n      dp.erase(n);\n    } else if(q.type == X) {\n      auto l = --dp.upper_bound(q.l);\n      auto r = --dp.upper_bound(q.r);\n      if(l->l != q.l) ++l;\n      if(r->r != q.r) --r;\n      flag.add(l->l, r->r-1, 1);\n    } else {\n      auto l = --dp.upper_bound(q.l);\n      auto r = l--;\n      auto fl = flag.find(l->l);\n      auto fr = flag.find(r->l);\n      auto i = fl ? uf.make() : l->id;\n      auto j = fr ? uf.make() : r->id;\n      flag.add(l->l, l->r-1, -fl);\n      flag.add(r->l, r->r-1, -fr);\n      ans += fl + fr - (uf.find(i)==uf.find(j) ? 0 : 1);\n      uf.unite(i, j);\n      dp.emplace(l->l, r->r, j);\n      dp.erase(l);\n      dp.erase(r);\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\nstruct Node {\n  int left;\n  long long id;\n  Node(int x, long long i = 1e18) : left(x), id(i) {}\n  bool operator<(const Node& n) const {return left != n.left ? left < n.left : id < n.id;}\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node* l_child;\n    Node* r_child;\n  };\n  inline void push(Node* n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node* n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node* n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node* root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  SegmentTree flag(W);\n  UnionFind<long long> group;\n  long long id = 0;\n  set<Node> node;\n  node.emplace(0, id);\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      auto right = (n == end(node)) ? W : n->left;\n      if(right == q.x1) continue;\n      --n;\n      auto f = flag.find(n->left);\n      flag.add(n->left, right - 1, -f);\n      id += 1 + f;\n      group.unite(n->id, id);\n      node.emplace(n->left, id);\n      group.unite(id, id + 1);\n      node.emplace(q.x1, ++id);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto right = (l == end(node)) ? W : l->left;\n      --l;\n      auto r = l--;\n      if(r->left != q.x1) continue;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, r->left - 1, -fl);\n      flag.add(r->left, right - 1, -fr);\n      group.unite(l->id, ++id);\n      group.unite(r->id, ++id);\n      auto il = fl ? id + fl : id - 1;\n      auto ir = fr ? id + fl + fr : id;\n      group.unite(il, ir);\n      node.emplace(l->left, id += fl + fr);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      auto right = (r == end(node)) ? W : r->left;\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(right != q.x2) right = r->left;\n      if(right <= l->left) continue;\n      flag.add(l->left, right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n\n  set<long long> res;\n  for(auto i = 0ll; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int SEG=1<<17;\nint cnt[SEG*2];\nbool put[SEG*2];\nint dat[SEG*2];\n\ninline void push(int k){\n    if(!put[k])return;\n    dat[k]=cnt[k];\n    if(k<SEG-1){\n        put[k*2+1]=put[k*2+2]=1;\n    }\n    put[k]=0;\n}\n\nvoid update(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        put[k]=1;\n        push(k);\n        return;\n    }\n    update(a,b,k*2+1,l,(l+r)/2);\n    update(a,b,k*2+2,(l+r)/2,r);\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n}\n\nvoid pushAll(int k){\n    if(k)pushAll((k-1)/2);\n    push(k);\n    if(k<SEG-1){\n        push(k*2+1);\n        push(k*2+2);\n    }\n}\n\nvoid addLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    cnt[kk]++;\n    while(kk){\n        kk=(kk-1)/2;\n        cnt[kk]++;\n    }\n}\n\nvoid remLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    cnt[kk]--;\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        cnt[kk]--;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nvoid toZero(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nint aggregate(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    return aggregate(a,b,k*2+1,l,(l+r)/2)+aggregate(a,b,k*2+2,(l+r)/2,r);\n}\n\nstruct UF{\n    vint par,cnt;\n    void init(int n){\n        par.resize(n);cnt.resize(n);\n        rep(i,n){\n            par[i]=i;\n            cnt[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        cnt[x]+=cnt[y];\n        par[y]=x;\n    }\n};\n\nint W,H,N;\n\nvint xs;\nset<tuple<int,int,int>>abn;\nset<int>ls;\nUF uf;\nint tail;\n\nset<tuple<int,int,int>>::iterator obtain(int l,int r){\n    if(r==-1){\n        auto it=abn.lower_bound(make_tuple(l,-1,-1));\n        if(it==abn.end()||get<0>(*it)!=l)return abn.end();\n        return it;\n    }\n    else{\n        auto it=abn.lower_bound(make_tuple(r,-1,-1));\n        if(it==abn.begin())return abn.end();\n        it--;\n        if(get<1>(*it)!=r)return abn.end();\n        return it;\n    }\n}\n\nvoid query1(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=ls.lower_bound(x);\n    int r=*it;\n    it--;\n    int l=*it;\n    auto it2=obtain(l,-1);\n    if(it2!=abn.end()){\n        int id;\n        tie(l,r,id)=*it2;\n        abn.erase(it2);\n        abn.insert(make_tuple(l,x,id));\n        abn.insert(make_tuple(x,r,id));\n        uf.cnt[uf.find(id)]++;\n    }\n    else{\n        toZero(l);\n        abn.insert(make_tuple(l,x,tail));\n        abn.insert(make_tuple(x,r,tail));\n        uf.cnt[tail]=2;\n        tail++;\n    }\n    ls.insert(x);\n    addLine(x);\n}\n\nvoid query2(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=obtain(-1,x);\n    auto it2=obtain(x,-1);\n\n    auto itit=ls.lower_bound(x);\n    itit++;int r=*itit;itit--;itit--;int l=*itit;\n\n    if(it!=abn.end()){\n        if(it2!=abn.end()){\n            int id=get<2>(*it),id2=get<2>(*it2);\n            uf.unite(id,id2);uf.cnt[uf.find(id)]--;\n            abn.erase(it);it2=obtain(x,-1);abn.erase(it2);\n            abn.insert(make_tuple(l,r,id));\n        }\n        else{\n            int id=get<2>(*it);\n            abn.erase(it);abn.insert(make_tuple(l,r,id));\n        }\n    }\n    else{\n        if(it2!=abn.end()){\n            int id=get<2>(*it2);\n            toZero(l);\n            abn.erase(it2);abn.insert(make_tuple(l,r,id));\n        }\n        else{\n\n        }\n    }\n    ls.erase(x);remLine(x);\n}\n\nint query3(int x,int xx){\n    //cout<<x<<\" \"<<xx<<\"------------\"<<endl;\n    //each(it,abn)cout<<get<0>(*it)<<\" \"<<get<1>(*it)<<\" \"<<get<2>(*it)<<endl;\n\n    x=lower_bound(all(xs),x)-xs.begin();\n    xx=upper_bound(all(xs),xx)-xs.begin()-1;\n    auto itit=ls.lower_bound(x);\n    if(itit==ls.end())return 0;\n    x=*itit;\n    itit=ls.upper_bound(xx);\n    if(itit==ls.begin())return 0;\n    itit--;\n    xx=*itit;\n    if(x>=xx)return 0;\n\n    int ret=aggregate(x,xx);\n\n    while(true){\n        auto it=abn.lower_bound(make_tuple(x,-1,-1));\n        if(it==abn.end()||get<0>(*it)>=xx)break;\n        int id=get<2>(*it);\n        if(--uf.cnt[uf.find(id)]==0)ret++;\n        abn.erase(it);\n    }\n    update(x,xx);\n    return ret;\n}\n\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&N);\n\n    xs.pb(0);xs.pb(W);\n    vector<tuple<int,int,int>>evs;\n    evs.pb(make_tuple(0*3+1,0,W));\n    evs.pb(make_tuple(H*3+1,0,W));\n\n    rep(i,N){\n        int a,b,c,d;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);\n        if(a==c){\n            evs.pb(make_tuple(b*3,a,114514));\n            evs.pb(make_tuple(d*3+2,a,1919810));\n            xs.pb(a);\n        }\n        else{\n            evs.pb(make_tuple(b*3+1,a,c));\n        }\n    }\n\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    sort(all(evs));\n\n    addLine(0);\n\n    ls.insert(0);ls.insert(xs.size()-1);\n    uf.init(N*3);\n\n    int ans=0;\n    bool flag=false;\n    for(auto &latte:evs){\n        int y,x,xx;\n        tie(y,x,xx)=latte;\n\n        if(y!=0&&!flag){\n            flag=true;\n            abn.clear();\n        }\n\n        if(xx==114514)query1(x);\n        else if(xx==1919810)query2(x);\n        else{\n            ans+=query3(x,xx);\n            //cout<<ans<<endl;\n        }\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100009;\n\nVI xs;\n\nnamespace ST{\n    const int NN = 4*2*MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n}\n\nstruct action{\n\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r){\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b){\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\n\nnamespace DSU{ // Disjoint Set Union\n    VI P;\n    inline int Find(int x){\n        //cout << x << endl;\n        return P[x] == x ? x : P[x] = Find(P[x]);\n    }\n    inline bool Union(int x, int y){\n        //cout << x << \" \" << y << endl;\n        x = Find(x), y = Find(y); if (x == y) return 0;\n        P[x] = y;\n        return 1;\n    }\n} //using namespace DSU;\n\n\nvoid adjust(int p){\n\tif (ST::Query(p)){\n        int n = DSU::P.size(); DSU::P.PB(n);\n\t\tDSU::P[p] = n;\n\t}\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\tDSU::P.PB(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tREP(i, xs.size()){\n\t    DSU::P.PB(0);\n\t}\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tDSU::Union(V.left, lf);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr-1);\n\t\t\tST::Insert(ll, rr-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\tint rett = ret;\n\t\t\tif(DSU::Union(lf, V.left)) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\ntypedef pair<pii, pii> Block;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\n\nsigned main() {\n\tll w, h;\n\tint n;\n\n\tscanf(\"%lld %lld %d\", &w, &h, &n);\n\tUnionFind uf(n + 1);\n\tvector<pair<pair<ll, pair<ll, ll>>,int>> y;\n\tvector<pair<pair<ll, ll>,int>> ts, te;\n\tvector<ll> ax, ay;\n\tint ans = 1;\n\tREP(i, n) {\n\t\tll x1, y1, x2, y2;\n\t\tscanf(\"%lld %lld %lld %lld\", &x1, &y1, &x2, &y2);\n\t\tax.push_back(x1);\n\t\tax.push_back(x2);\n\t\tay.push_back(y1);\n\t\tay.push_back(y2);\n\n\t\tif (x1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y1 == 0)\n\t\t\tuf.unionSet(i, n);\n\t\tif (x2 == w)\n\t\t\tuf.unionSet(i, n);\n\t\tif (y2 == h)\n\t\t\tuf.unionSet(i, n);\n\n\t\tif (x1 == 0 && x2 == w)\n\t\t\tans++;\n\n\t\tif (y1 == 0 && y2 == h)\n\t\t\tans++;\n\n\t\tif (x1 == x2) {\n\t\t\tts.push_back({ { y1, x1 },i });\n\t\t\tte.push_back({ { y2, x2 },i });\n\t\t}\n\t\telse {\n\t\t\ty.push_back({ { y1,{ x1,x2 } },i });\n\t\t}\n\t}\n\n\tsort(ALL(ax));\n\tsort(ALL(ay));\n\tsort(ALL(ts));\n\tsort(ALL(te));\n\tsort(ALL(y));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tay.erase(unique(ALL(ay)), ay.end());\n\n\tunordered_map<ll, int> zatux,zatuy;\n\tREP(i, ax.size()) {\n\t\tzatux[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tzatuy[ay[i]] = i;\n\t}\n\t//vector<vector<int>> alx(ax.size(), vector<int>(ay.size())), aly(ax.size(), vector<int>(ay.size()));\n\n\tfenwick_tree<int> ft(ax.size());\n\tfenwick_tree<int> le(ax.size());\n\t//vector<int> rt(ax.size());\n\tint tsind = 0,tsend = 0;\n\n\tset<pii> ut;\n\tREP(i, ay.size()) {\n\t\tfor(; ts.size() > tsind; tsind++) {\n\t\t\tif (ts[tsind].first.first == ay[i]) {\n\t\t\t\tint ind = zatux[ts[tsind].first.second];\n\t\t\t\tft.add(ind, 1);\n\t\t\t\t//le.add(ind - ax.begin(), 1);\n\t\t\t\tut.insert(make_pair(ind, ts[tsind].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tauto itrs = lower_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>)make_pair(make_pair(ay[i], make_pair(0, 0)), 0)),\n\t\t\titre = upper_bound(ALL(y), (pair<pair<ll, pair<ll, ll>>, int>) make_pair(make_pair(ay[i], make_pair(LLONG_MAX, LLONG_MAX)), INT_MAX));\n\t\tfor (auto itr = itrs; itr != itre; itr++) {\n\t\t\tint s = zatux[itr->first.second.first],\n\t\t\t\te = zatux[itr->first.second.second];\n\t\t\tint tcou = ft.sum(s, e);\n\t\t\tauto sti = upper_bound(ALL(ut), make_pair(e, INT_MAX));\n\t\t\t//le.add(s, itr->second);\n\t\t\t//le.add(e, itr->second);\n\t\t\tREP(j, tcou) {\n\t\t\t\tsti--;\n\n\t\t\t\tif (uf.findSet(itr->second, sti->second)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tuf.unionSet(itr->second, sti->second);\n\t\t\t}\n\t\t}\n\n\n\t\tfor (; te.size() > tsend; tsend++) {\n\t\t\tif (te[tsend].first.first == ay[i]) {\n\n\t\t\t\tint ind = zatux[te[tsend].first.second];\n\t\t\t\tft.add(ind, -1);\n\n\t\t\t\t//le.add(ind - ax.begin(), -1);\n\t\t\t\tut.erase(make_pair(ind, te[tsend].second));\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst long long N = 2e5 + 5;\nusing namespace std;\n\ntypedef pair <long long, long long> ii;\ntypedef pair <ii, long long> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nlong long w, h, n, x[2][N], y[2][N], a[20*N], pos[2][N], num, bit[N];\nlong long cnt, ver, root_ver[N], ans;\nbool check[20*N];\n\nstruct {\n    long long pset[N], numdsu;\n\n    void init (long long n){\n        for (long long i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    long long findset(long long i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(long long i, long long j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    long long val, left, right, cnt;\n} lv[20*N];\n\nvoid init(long long l, long long r){\n    long long nod = cnt;\n    if (l != r){\n        long long mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(long long k, long long l, long long r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        long long a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(long long k, long long l, long long r, long long pos, long long val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    long long mid = (l + r) / 2; long long nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(long long pos, long long val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (long long k, long long l, long long r, long long L, long long R, long long val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    long long mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(long long u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; long long v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(long long i, long long val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nlong long get(long long l, long long r){\n    long long ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (long long i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (long long i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (long long i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        long long z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (long long i = 0; i < mv.size(); i++){\n        long long z = mv[i].second, val = mv[i].first.first;\n\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    cout << cnt << endl;\n    for (long long i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 0, 1 },{ -1 ,1 },{ -1, 0 },\n\t{ -1 ,-1 },{ 0,-1 },{ 1 ,-1 },\n\t{ 1,0 },{ 1 ,1 }\n};\n#define N (1<<17) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum, seg[k].lazy);\n\tif (k < N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy = max(seg[2 * k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2 * k + 1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum, seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy, v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = N) {\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl, vr);\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\ntemplate <class T>\nstruct fenwick_tree {\n\tvector<T> x;\n\tfenwick_tree(int n) : x(n, 0) { }\n\tT sum(int i, int j) {\n\t\tif (i == 0) {\n\t\t\tT S = 0;\n\t\t\tfor (j; j >= 0; j = (j & (j + 1)) - 1) S += x[j];\n\t\t\treturn S;\n\t\t}\n\t\telse return sum(0, j) - sum(0, i - 1);\n\t}\n\tvoid add(int k, T a) {\n\t\tfor (; k < x.size(); k |= k + 1) x[k] += a;\n\t}\n};\nsigned main() {\n\tint w, h, n;\n\tscanf(\"%d %d %d\", &w, &h, &n);\n\n\tvector<pair<pair<ll, pll>, int>> ho;\n\tvector<pair<pll, int>> vs, ve;\n\tvector<ll> ax, ay;\n\tmap<ll, int> px, py;\n\n\tUnionFind uf(n + 1);\n\tint koutennsuu = 0;\n\tREP(i, n) {\n\t\tll sx, sy, ex, ey;\n\t\tscanf(\"%lld %lld %lld %lld\", &sx, &sy, &ex, &ey);\n\t\tif (sx == ex) {\n\t\t\tvs.push_back({ { sy, sx },i });\n\t\t\tve.push_back({ { ey, ex },i });\n\t\t}\n\t\telse {\n\t\t\tho.push_back({ { sy,{ sx,ex } },i });\n\t\t}\n\n\t\tif (!sx || !sy || !ex || !ey) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\t\tif (sx == w || ex == w || sy == h || ey == h) {\n\t\t\tuf.unionSet(n, i);\n\t\t\tkoutennsuu++;\n\t\t}\n\n\t\tax.push_back(sx);\n\t\tax.push_back(ex);\n\t\tay.push_back(sy);\n\t\tay.push_back(ey);\n\t}\n\tsort(ALL(ho));\n\tsort(ALL(vs));\n\tsort(ALL(ve));\n\tsort(ALL(ax));\n\tax.erase(unique(ALL(ax)), ax.end());\n\tsort(ALL(ay));\n\tay.erase(unique(ALL(ay)), ay.end());\n\tREP(i, ax.size()) {\n\t\tpx[ax[i]] = i;\n\t}\n\tREP(i, ay.size()) {\n\t\tpy[ay[i]] = i;\n\t}\n\n\tfenwick_tree<int> fw(ax.size());\n\tset < pii > ylist;\n\tint hoinp = 0, hooup = 0, vep = 0;\n\tREP(i, ay.size()) {\n\t\tfor (; hoinp < vs.size(); hoinp++) {\n\t\t\tif (vs[hoinp].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tfw.add(px[vs[hoinp].first.second], 1);\n\t\t\tylist.insert({ px[vs[hoinp].first.second], vs[hoinp].second });\n\t\t}\n\n\t\tfor (; vep < ho.size(); vep++) {\n\t\t\tif (ho[vep].first.first != ay[i])\n\t\t\t\tbreak;\n\n\t\t\tint a = px[ho[vep].first.second.first], b = px[ho[vep].first.second.second];\n\n\t\t\tkoutennsuu += fw.sum(a, b);\n\t\t\tint aln = get(a + 1, b + 1);\n\t\t\tint setn = ho[vep].second + 1;\n\t\t\tif (aln) {\n\t\t\t\tuf.unionSet(aln - 1, ho[vep].second);\n\t\t\t\tsetn = aln;\n\t\t\t}\n\t\t\tupdate(a + 1, b + 1, setn);\n\t\t}\n\n\t\tfor (; hooup < ve.size(); hooup++) {\n\t\t\tif (ve[hooup].first.first != ay[i])\n\t\t\t\tbreak;\n\t\t\tint buf = px[vs[hooup].first.second];\n\t\t\tfw.add(px[vs[hooup].first.second], -1);\n\t\t\tylist.erase({ buf, vs[hooup].second });\n\t\t\tint nn = get(buf + 1, buf + 1);\n\t\t\tif (nn) {\n\t\t\t\tuf.unionSet(nn - 1, ve[hooup].second);\n\t\t\t}\n\t\t\tupdate(buf + 1, buf + 1, 0);\n\t\t}\n\t}\n\tint renketusuu = 0;\n\tREP(i, n + 1) {\n\t\trenketusuu += uf.data[i] < 0;\n\t}\n\t//if (uf.data[n] < -1)\n\t//renketusuu++;\n\t//koutennsuu += 4;u\n\t//n += 4;\n\tprintf(\"%d\\n\", koutennsuu + renketusuu - n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int SEG=1<<17;\nset<int>st[SEG*2];\nbool put[SEG*2];\nint dat[SEG*2];\n\ninline void push(int k){\n    if(!put[k])return;\n    dat[k]=st[k].size();\n    if(k<SEG-1){\n        put[k*2+1]=put[k*2+2]=1;\n    }\n    put[k]=0;\n}\n\nvoid update(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        put[k]=1;\n        push(k);\n        return;\n    }\n    update(a,b,k*2+1,l,(l+r)/2);\n    update(a,b,k*2+2,(l+r)/2,r);\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n}\n\nvoid pushAll(int k){\n    if(k)pushAll((k-1)/2);\n    push(k);\n    if(k<SEG-1){\n        push(k*2+1);\n        push(k*2+2);\n    }\n}\n\nvoid addLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].insert(k);\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].insert(k);\n    }\n}\n\nvoid remLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].erase(k);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].erase(k);\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nvoid toZero(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nint aggregate(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    return aggregate(a,b,k*2+1,l,(l+r)/2)+aggregate(a,b,k*2+2,(l+r)/2,r);\n}\n\nstruct UF{\n    vint par,cnt;\n    void init(int n){\n        par.resize(n);cnt.resize(n);\n        rep(i,n){\n            par[i]=i;\n            cnt[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        cnt[x]+=cnt[y];\n        par[y]=x;\n    }\n};\n\nint W,H,N;\n\nvint xs;\nset<tuple<int,int,int>>abn;\nset<int>ls;\nUF uf;\nint tail;\n\nset<tuple<int,int,int>>::iterator obtain(int l,int r){\n    if(r==-1){\n        auto it=abn.lower_bound(make_tuple(l,-1,-1));\n        if(it==abn.end()||get<0>(*it)!=l)return abn.end();\n        return it;\n    }\n    else{\n        auto it=abn.lower_bound(make_tuple(r,-1,-1));\n        if(it==abn.begin())return abn.end();\n        it--;\n        if(get<1>(*it)!=r)return abn.end();\n        return it;\n    }\n}\n\nvoid query1(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=ls.lower_bound(x);\n    int r=*it;\n    it--;\n    int l=*it;\n    auto it2=obtain(l,-1);\n    if(it2!=abn.end()){\n        int id;\n        tie(l,r,id)=*it2;\n        abn.erase(it2);\n        abn.insert(make_tuple(l,x,id));\n        abn.insert(make_tuple(x,r,id));\n        uf.cnt[uf.find(id)]++;\n    }\n    else{\n        toZero(l);\n        abn.insert(make_tuple(l,x,tail));\n        abn.insert(make_tuple(x,r,tail));\n        uf.cnt[tail]=2;\n        tail++;\n    }\n    ls.insert(x);\n    addLine(x);\n}\n\nvoid query2(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=obtain(-1,x);\n    auto it2=obtain(x,-1);\n\n    auto itit=ls.lower_bound(x);\n    itit++;int r=*itit;itit--;itit--;int l=*itit;\n\n    if(it!=abn.end()){\n        if(it2!=abn.end()){\n            int id=get<2>(*it),id2=get<2>(*it2);\n            uf.unite(id,id2);uf.cnt[uf.find(id)]--;\n            abn.erase(it);it2=obtain(x,-1);abn.erase(it2);\n            abn.insert(make_tuple(l,r,id));\n        }\n        else{\n            int id=get<2>(*it);\n            abn.erase(it);abn.insert(make_tuple(l,r,id));\n        }\n    }\n    else{\n        if(it2!=abn.end()){\n            int id=get<2>(*it2);\n            toZero(l);\n            abn.erase(it2);abn.insert(make_tuple(l,r,id));\n        }\n        else{\n\n        }\n    }\n    ls.erase(x);remLine(x);\n}\n\nint query3(int x,int xx){\n    x=lower_bound(all(xs),x)-xs.begin();\n    xx=upper_bound(all(xs),xx)-xs.begin()-1;\n    if(x>=xx)return 0;\n\n    int ret=aggregate(x,xx);\n    while(true){\n        auto it=abn.lower_bound(make_tuple(x,-1,-1));\n        if(it==abn.end()||get<0>(*it)>=xx)break;\n        int id=get<2>(*it);\n        if(--uf.cnt[uf.find(id)]==0)ret++;\n        abn.erase(it);\n    }\n    update(x,xx);\n    return ret;\n}\n\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&N);\n\n    xs.pb(0);xs.pb(W);\n    vector<tuple<int,int,int>>evs;\n    evs.pb(make_tuple(H*3+1,0,W));\n\n    rep(i,N){\n        int a,b,c,d;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);\n        if(a==c){\n            evs.pb(make_tuple(b*3,a,114514));\n            evs.pb(make_tuple(d*3+2,a,1919810));\n            xs.pb(a);\n        }\n        else{\n            evs.pb(make_tuple(b*3+1,a,c));\n        }\n    }\n\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    sort(all(evs));\n\n    addLine(0);\n    update(0,xs.size()-1);\n\n    ls.insert(0);ls.insert(xs.size()-1);\n    uf.init(N*3);\n\n    int ans=0;\n    for(auto &latte:evs){\n        int y,x,xx;\n        tie(y,x,xx)=latte;\n        if(xx==114514)query1(x);\n        else if(xx==1919810)query2(x);\n        else ans+=query3(x,xx);\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\nint main(){\n\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\tseg.add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int up = *--S.upper_bound(V.right);\n\t\t\tint count = seg.query(V.left, up+1);\n\t\t\tif(count < 2) continue;\n\t\t\tret += count - 1;\n\t\t\t//cout << V.left << \" \" << V.right << \" \" << *--S.upper_bound(V.right) << endl;\n\t\t\tseg.set_renew(V.left, up);\n\t\t\t//seg.set_renew(V.left, V.right-1);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\tseg.add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef pair <ii, int> iii;\nvector <ii> vc;\nvector <iii> mv;\n\nint w, h, n, x[2][N], y[2][N], a[N], pos[2][N], num, bit[N];\nint cnt, ver, root_ver[N], ans;\nbool check[N];\n\nstruct {\n    int pset[N], numdsu;\n\n    void init (int n){\n        for (int i = 1; i <= n; i++) pset[i] = i;\n        numdsu = n;\n    }\n\n    int findset(int i) {\n        if (pset[i] != i) pset[i] = findset(pset[i]);\n        return pset[i];\n    }\n\n    void unionset(int i, int j){\n        if (findset(i) == findset(j)) return;\n        pset[findset(i)] = findset(j);\n        numdsu--;\n    }\n} dsu;\n\nstruct node {\n    int val, left, right, cnt;\n} lv[20*N];\n\nvoid init(int l, int r){\n    int nod = cnt;\n    if (l != r){\n        int mid = (l + r) / 2;\n        lv[nod].left  = ++cnt; init (l, mid);\n        lv[nod].right = ++cnt; init (mid+1, r);\n    }\n}\n\nvoid dolazy(int k, int l, int r){\n    if (lv[k].val == 0) return;\n    if (l != r) {\n        int a = lv[k].left, b = lv[k].right;\n        if (lv[a].val) {dsu.unionset(lv[a].val, lv[k].val);}\n        if (lv[b].val) {dsu.unionset(lv[b].val, lv[k].val);}\n        if (lv[a].cnt) lv[a].val = lv[k].val;\n        if (lv[b].cnt) lv[b].val = lv[k].val;\n        lv[k].val = 0;\n    }\n}\n\nvoid update(int k, int l, int r, int pos, int val){\n    dolazy(k, l, r);\n    if (l > pos || pos > r) return;\n    if (l == r){\n        lv[cnt].val = val;\n        lv[cnt].cnt = (val != 0);\n        return;\n    }\n    int mid = (l + r) / 2; int nod = cnt;\n    if (pos > mid){\n        lv[nod].left = lv[k].left;\n        lv[nod].right = ++cnt;\n        update(lv[k].right, mid+1, r, pos, val);\n    }\n    else{\n        lv[nod].left = ++cnt;\n        lv[nod].right = lv[k].right;\n        update(lv[k].left, l, mid, pos, val);\n    }\n    lv[nod].cnt = lv[lv[nod].left].cnt + lv[lv[nod].right].cnt;\n}\n\nvoid update(int pos, int val){\n    root_ver[++ver] = ++cnt;\n    update(root_ver[ver-1], 1, num, pos, val);\n}\n\nvoid update (int k, int l, int r, int L, int R, int val){\n    dolazy(k, l, r);\n    if (l > R || L > r) return;\n    if (L <= l && r <= R){\n        if (lv[k].val) dsu.unionset(lv[k].val, val);\n        if (lv[k].cnt) lv[k].val = val;\n        return;\n    }\n    int mid = (l + r) / 2;\n    update(lv[k].left, l, mid, L, R, val); update(lv[k].right, mid+1, r, L, R, val);\n}\n\nvoid dfs(int u){\n    if (check[u]) return;\n    check[u] = 1; a[u] = lv[u].val; int v;\n    v = lv[u].left;  dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n    v = lv[u].right; dfs(v);\n    if (a[u] && a[v]) {dsu.unionset(a[u], a[v]);}\n    else a[u] = max(a[u], a[v]);\n}\n\nvoid updatebit(int i, int val){\n    while (i <= num) bit[i]+=val, i += i&(-i);\n}\n\nint get(int l, int r){\n    int ans = 0; l--;\n    while (r > 0) ans += bit[r], r -= r&(-r);\n    while (l > 0) ans -= bit[l], l -= l&(-l);\n    return ans;\n}\n\nvoid init(){\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) cin >> x[0][i] >> y[0][i] >> x[1][i] >> y[1][i];\n    x[0][n+1] = 0; y[0][n+1] = 0; x[1][n+1] = w; y[1][n+1] = 0;\n    x[0][n+2] = 0; y[0][n+2] = h; x[1][n+2] = w; y[1][n+2] = h;\n    x[0][n+3] = 0; y[0][n+3] = 0; x[1][n+3] = 0; y[1][n+3] = h;\n    x[0][n+4] = w; y[0][n+4] = 0; x[1][n+4] = w; y[1][n+4] = h;\n    n += 4;\n    for (int i = 1; i <= n; i++){\n        if (x[0][i] > x[1][i] || y[0][i] > y[1][i]){\n            swap(x[0][i], x[1][i]);\n            swap(y[0][i], y[1][i]);\n        }\n        if (x[0][i] != x[1][i]) {\n            mv.push_back(iii(ii(x[0][i], -1), i));\n            mv.push_back(iii(ii(x[1][i],  1), i));\n            vc.push_back(ii(y[0][i], i));\n        }\n        else{\n            mv.push_back(iii(ii(x[0][i],  0), i));\n            vc.push_back(ii(y[0][i], i));\n            vc.push_back(ii(y[1][i], i));\n        }\n    }\n    sort (mv.begin(), mv.end());\n    sort (vc.begin(), vc.end());\n    dsu.init(n);\n    ans = -n;\n    for (int i = 0; i < vc.size(); i++){\n        if (i == 0 || (i > 0 && vc[i].first != vc[i-1].first)) num++;\n        int z = vc[i].second;\n        if (pos[0][z]) pos[1][z] = num;\n        else pos[0][z] = num;\n    }\n    root_ver[++ver] = ++cnt; init(1, num);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    init();\n    for (int i = 0; i < mv.size(); i++){\n        int z = mv[i].second, val = mv[i].first.first;\n        if (val == x[0][z] && val == x[1][z]) update(root_ver[ver], 1, num, pos[0][z], pos[1][z], z);\n        else if (val == x[0][z]) update(pos[0][z], z);\n        else update(pos[0][z], 0);\n        if (val == x[0][z] && val == x[1][z]) ans += get(pos[0][z], pos[1][z]);\n        else if (val == x[0][z]) updatebit(pos[0][z], 1);\n        else updatebit(pos[0][z], -1);\n    }\n    for (int i = 1; i <= cnt; i++) if (lv[i].val) dfs(i);\n    ans += dsu.numdsu;\n    cout << ans;\n}\n/*\n10 10 1\n2 3 2 4\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int SEG=1<<17;\nset<int>st[SEG*2];\nbool put[SEG*2];\nint dat[SEG*2];\n\ninline void push(int k){\n    if(!put[k])return;\n    dat[k]=st[k].size();\n    if(k<SEG-1){\n        put[k*2+1]=put[k*2+2]=1;\n    }\n    put[k]=0;\n}\n\nvoid update(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        put[k]=1;\n        push(k);\n        return;\n    }\n    update(a,b,k*2+1,l,(l+r)/2);\n    update(a,b,k*2+2,(l+r)/2,r);\n    dat[k]=dat[k*2+1]+dat[k*2+2];\n}\n\nvoid pushAll(int k){\n    if(k)pushAll((k-1)/2);\n    push(k);\n    if(k<SEG-1){\n        push(k*2+1);\n        push(k*2+2);\n    }\n}\n\nvoid addLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].insert(k);\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].insert(k);\n    }\n}\n\nvoid remLine(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    st[kk].erase(k);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        st[kk].erase(k);\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nvoid toZero(int k){\n    int kk=k+SEG-1;\n    pushAll(kk);\n    dat[kk]=0;\n    while(kk){\n        kk=(kk-1)/2;\n        dat[kk]=dat[kk*2+1]+dat[kk*2+2];\n    }\n}\n\nint aggregate(int a,int b,int k=0,int l=0,int r=SEG){\n    push(k);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    return aggregate(a,b,k*2+1,l,(l+r)/2)+aggregate(a,b,k*2+2,(l+r)/2,r);\n}\n\nstruct UF{\n    vint par,cnt;\n    void init(int n){\n        par.resize(n);cnt.resize(n);\n        rep(i,n){\n            par[i]=i;\n            cnt[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        cnt[x]+=cnt[y];\n        par[y]=x;\n    }\n};\n\nint W,H,N;\n\nvint xs;\nset<tuple<int,int,int>>abn;\nset<int>ls;\nUF uf;\nint tail;\n\nset<tuple<int,int,int>>::iterator obtain(int l,int r){\n    if(r==-1){\n        auto it=abn.lower_bound(make_tuple(l,-1,-1));\n        if(it==abn.end()||get<0>(*it)!=l)return abn.end();\n        return it;\n    }\n    else{\n        auto it=abn.lower_bound(make_tuple(r,-1,-1));\n        if(it==abn.begin())return abn.end();\n        it--;\n        if(get<1>(*it)!=r)return abn.end();\n        return it;\n    }\n}\n\nvoid query1(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=ls.lower_bound(x);\n    int r=*it;\n    it--;\n    int l=*it;\n    auto it2=obtain(l,-1);\n    if(it2!=abn.end()){\n        int id;\n        tie(l,r,id)=*it2;\n        abn.erase(it2);\n        abn.insert(make_tuple(l,x,id));\n        abn.insert(make_tuple(x,r,id));\n        uf.cnt[uf.find(id)]++;\n    }\n    else{\n        toZero(l);\n        abn.insert(make_tuple(l,x,tail));\n        abn.insert(make_tuple(x,r,tail));\n        uf.cnt[tail]=2;\n        tail++;\n    }\n    ls.insert(x);\n    addLine(x);\n}\n\nvoid query2(int x){\n    x=lower_bound(all(xs),x)-xs.begin();\n    auto it=obtain(-1,x);\n    auto it2=obtain(x,-1);\n\n    auto itit=ls.lower_bound(x);\n    itit++;int r=*itit;itit--;itit--;int l=*itit;\n\n    if(it!=abn.end()){\n        if(it2!=abn.end()){\n            int id=get<2>(*it),id2=get<2>(*it2);\n            uf.unite(id,id2);uf.cnt[uf.find(id)]--;\n            abn.erase(it);it2=obtain(x,-1);abn.erase(it2);\n            abn.insert(make_tuple(l,r,id));\n        }\n        else{\n            int id=get<2>(*it);\n            abn.erase(it);abn.insert(make_tuple(l,r,id));\n        }\n    }\n    else{\n        if(it2!=abn.end()){\n            int id=get<2>(*it2);\n            toZero(l);\n            abn.erase(it2);abn.insert(make_tuple(l,r,id));\n        }\n        else{\n\n        }\n    }\n    ls.erase(x);remLine(x);\n}\n\nint query3(int x,int xx){\n    //cout<<x<<\" \"<<xx<<\"------------\"<<endl;\n    //each(it,abn)cout<<get<0>(*it)<<\" \"<<get<1>(*it)<<\" \"<<get<2>(*it)<<endl;\n\n    x=lower_bound(all(xs),x)-xs.begin();\n    xx=upper_bound(all(xs),xx)-xs.begin()-1;\n    auto itit=ls.lower_bound(x);\n    if(itit==ls.end())return 0;\n    x=*itit;\n    itit=ls.upper_bound(xx);\n    if(itit==ls.begin())return 0;\n    itit--;\n    xx=*itit;\n    if(x>=xx)return 0;\n\n    int ret=aggregate(x,xx);\n\n    while(true){\n        auto it=abn.lower_bound(make_tuple(x,-1,-1));\n        if(it==abn.end()||get<0>(*it)>=xx)break;\n        int id=get<2>(*it);\n        if(--uf.cnt[uf.find(id)]==0)ret++;\n        abn.erase(it);\n    }\n    update(x,xx);\n    return ret;\n}\n\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&N);\n\n    xs.pb(0);xs.pb(W);\n    vector<tuple<int,int,int>>evs;\n    evs.pb(make_tuple(0*3+1,0,W));\n    evs.pb(make_tuple(H*3+1,0,W));\n\n    rep(i,N){\n        int a,b,c,d;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);\n        if(a==c){\n            evs.pb(make_tuple(b*3,a,114514));\n            evs.pb(make_tuple(d*3+2,a,1919810));\n            xs.pb(a);\n        }\n        else{\n            evs.pb(make_tuple(b*3+1,a,c));\n        }\n    }\n\n    sort(all(xs));xs.erase(unique(all(xs)),xs.end());\n    sort(all(evs));\n\n    addLine(0);\n\n    ls.insert(0);ls.insert(xs.size()-1);\n    uf.init(N*3);\n\n    int ans=0;\n    bool flag=false;\n    for(auto &latte:evs){\n        int y,x,xx;\n        tie(y,x,xx)=latte;\n\n        if(y!=0&&!flag){\n            flag=true;\n            abn.clear();\n        }\n\n        if(xx==114514)query1(x);\n        else if(xx==1919810)query2(x);\n        else{\n            ans+=query3(x,xx);\n            //cout<<ans<<endl;\n        }\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\nstruct seg_tree\n{\n\tstatic const int DEPTH = 19;\n\tstatic const int SIZE = 1<<DEPTH;\n\n\tint bit[1<<(DEPTH+1)];\n\tint renew[1<<(DEPTH+1)];\n\n\tseg_tree() { }\n\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<2*SIZE;i++) bit[i] = renew[i] = 0;\n\t}\n\n\tvoid add(int p, int v)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tbit[p] += v;\n\t\t\tp >>= 1;\n\t\t}\n\t}\n\n\tint query(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\t\tint ret = 0;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) ret += bit[l++];\n\t\t\tif(r&1) ret += bit[--r];\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tvoid set_renew(int l, int r)\n\t{\n\t\tl += SIZE;\n\t\tr += SIZE;\n\n\t\twhile(l < r){\n\t\t\tif(l&1) renew[l++] = 1;\n\t\t\tif(r&1) renew[--r] = 1;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\n\tbool is_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\twhile(p){\n\t\t\tif(renew[p]) return true;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid unset_renew(int p)\n\t{\n\t\tp += SIZE;\n\t\tfor(int i=DEPTH-1;i>0;i--){\n\t\t\tif(renew[p >> i]){\n\t\t\t\trenew[p >> i] = 0;\n\t\t\t\trenew[(p>>i)*2] = renew[(p>>i)*2+1] = 1;\n\t\t\t}\n\t\t}\n\n\t\trenew[p] = 0;\n\t}\n};\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nseg_tree seg;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\tif(seg.is_renew(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\t//cout <<  \" \" << uf[t] << \" \" << t << endl;\n\t\tseg.unset_renew(p);\n\t\ttarget[p] = t;\n\t}\n\n}\n\n\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\tfor(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tvector<int> xs;\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\ttarget[V.left] = target[lf];\n\n\t\t\tS.insert(V.left);\n\t\t\t//cout << \"+ \" << V.left << endl;\n\t\t\t//seg.add(V.left, 1);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *--S.upper_bound(V.right);\n\t\t    //cout << ll << \" \"<< rr << endl;\n\t\t    if (rr <= ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr) - 1; // seg.query(ll, rr+1) - 1;\n\t\t\tseg.set_renew(ll, rr);\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\t\t\t//cout << \" \" << target[lf] << \" \" << target[V.left] << endl;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\t\t\tS.erase(V.left);\n\t\t\t//cout << \"- \" << V.left << endl;\n\t\t\t//seg.add(V.left, -1);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\n\t\t//cout << V.act << \" \" << ret << endl;\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <windows.h>\nint WorkSize(void) {\n    typedef struct {\n        DWORD  cb;\n        DWORD  PageFaultCount;\n        SIZE_T PeakWorkingSetSize;\n        SIZE_T WorkingSetSize;\n        SIZE_T QuotaPeakPagedPoolUsage;\n        SIZE_T QuotaPagedPoolUsage;\n        SIZE_T QuotaPeakNonPagedPoolUsage;\n        SIZE_T QuotaNonPagedPoolUsage;\n        SIZE_T PagefileUsage;\n        SIZE_T PeakPagefileUsage;\n    } info_t;\n    typedef BOOL(WINAPI*func_t)(HANDLE,info_t*,DWORD);\n    static func_t func; static enum { FIRST,OK,ERR } flag;\n    static HANDLE proc; info_t info; HINSTANCE dll;\n    if (flag==FIRST) {\n        if ((dll=LoadLibraryA(\"psapi\"))==0) { flag=ERR; return 0; }\n        func=(func_t)GetProcAddress(dll,\"GetProcessMemoryInfo\");\n        if (func==0) { flag=ERR; return 0; }\n        proc=GetCurrentProcess(); flag=OK;\n    }\n    if (flag==ERR) return 0;\n    func(proc,&info,sizeof info); return(int)info.WorkingSetSize;\n}\n\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\n public:\n  Compression(const std::vector<int>& list) : value_(list) {\n    std::sort(begin(value_), end(value_));\n    value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n    for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n  }\n  int size() const {return value_.size();}\n  int index(const int v) const {return index_.at(v);}\n  int operator[](const int i) const {return value_.at(i);}\n private:\n  std::unordered_map<int, int> index_;\n  std::vector<int> value_;\n};\n\n#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    T x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  const T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// [left, right)\nstruct Node {\n  int id, left, right;\n  Node(int x) : id(2e9), left(x), right(2e9) {}\n  Node(int i, int l, int r) : id(i), left(l), right(r) {}\n  bool operator<(const Node& n) const {\n    if(left != n.left) return left < n.left;\n    if(right != n.right) return right < n.right;\n    return id < n.id;\n  }\n};\n\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    root_ = new Node();\n  }\n  void add(int a, int b, int v) {add(a, b + 1, v, root_, 0, size_);}\n  int find(int x) {return find(x, root_, 0, size_);}\n private:\n  struct Node {\n    int value;\n    int lazy;\n    Node *l_child, *r_child;\n  };\n  inline void push(Node *n) {\n    if(not n->l_child) n->l_child = new Node();\n    if(not n->r_child) n->r_child = new Node();\n    if(n->lazy) {\n      n->l_child->lazy += n->lazy;\n      n->r_child->lazy += n->lazy;\n      n->value += n->lazy;\n      n->lazy = 0;\n    }\n  }\n  void add(int a, int b, int v, Node *n, int l, int r) {\n    push(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {n->lazy = v; return;};\n    auto m = (l + r) / 2;\n    add(a, b, v, n->l_child, l, m);\n    add(a, b, v, n->r_child, m, r);\n  }\n  int find(int x, Node *n, int l, int r) {\n    push(n);\n    if(x == l && x == r - 1) return n->value;\n    auto m = (l + r) / 2;\n    if(x < m) return find(x, n->l_child, l, m);\n    else      return find(x, n->r_child, m, r);\n  }\n  Node *root_;\n  int size_;\n};\n\nint main() {\n  enum Type {Y_IN, X, Y_OUT};\n  struct Event {int y; Type type; int x1, x2;};\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  list<Event> event;\n  for(auto i = 0; i < N; ++i) {\n    int A, B, C, D;\n    cin >> A >> B >> C >> D;\n    if(B == D) event.push_back({B, X, A, C});\n    else {\n      event.push_back({B, Y_IN,  A, C});\n      event.push_back({D, Y_OUT, A, C});\n    }\n  }\n\n  event.push_back({0, X, 0, W});\n  event.push_back({0, Y_IN, 0, 0});\n  event.push_back({0, Y_IN, W, W});\n  event.push_back({H, Y_OUT, 0, 0});\n  event.push_back({H, Y_OUT, W, W});\n  event.push_back({H, X, 0, W});\n\n  event.sort([](auto l, auto r) {\n    if(l.y != r.y) return l.y < r.y;\n    if(l.type != r.type) return l.type < r.type;\n    if(l.x1 != r.x1) return l.x1 < r.x1;\n    return l.x2 < r.x2;\n  });\n\n  W += 3;\n  for(auto& q: event) {++q.x1; ++q.x2;}\n\n  vector<int> x = {W};\n  for(auto& q: event) {\n    x.emplace_back(q.x1);\n    x.emplace_back(q.x2);\n  }\n  Compression cx(x);\n  for(auto& q: event) {q.x1 = cx.index(q.x1); q.x2 = cx.index(q.x2);}\n\n  SegmentTree flag(cx.index(W));\n  UnionFind<int> group;\n  int id = 0;\n  set<Node> node;\n  node.emplace(id, 0, cx.index(W));\n\n  while(!event.empty()) {\n//     for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//     for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n    auto q = event.front();\n    event.pop_front();\n    if(q.type == Y_IN) {\n//       cout<<\"split: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto n = node.upper_bound(q.x1);\n      --n;\n      if(n->right == q.x1) continue;\n      auto f = flag.find(n->left);\n      flag.add(n->left, n->right - 1, -f);\n      auto i = f ? id + f : n->id;\n      id += f + 1;\n      group.unite(i, id);\n      node.emplace(i, n->left, q.x1);\n      node.emplace(id, q.x1, n->right);\n      node.erase(n);\n    } else if(q.type == Y_OUT) {\n//       cout<<\"merge: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      --l;\n      if(q.x1 != l->left) continue;\n      auto r = l--;\n      auto fl = flag.find(l->left);\n      auto fr = flag.find(r->left);\n      flag.add(l->left, l->right - 1, -fl);\n      flag.add(r->left, r->right - 1, -fr);\n      if(fl==0 && fr==0) group.unite(l->id, r->id);\n      else if(fl==0)     group.unite(l->id, id + fr);\n      else if(fr==0)     group.unite(id + fl, r->id);\n      else               group.unite(id + fl, id + fl + fr);\n      if(fl==0 && fr==0) node.emplace(l->id, l->left, r->right);\n      else               node.emplace(id += fl + fr, l->left, r->right);\n      node.erase(l);\n      node.erase(r);\n    } else {\n//       cout<<\"separate: \"<<q.y<<\" \"<<q.x1<<\" \"<<q.x2<<endl;\n      auto l = node.upper_bound(q.x1);\n      auto r = node.upper_bound(q.x2);\n      --l;\n      --r;\n      if(l->left != q.x1) ++l;\n      if(r->right != q.x2) --r;\n      if(l == end(node)) continue;\n      if(r->right <= l->left) continue;\n      flag.add(l->left, r->right - 1, 1);\n    }\n  }\n//   for(auto i:node)cout<<i.id<<\"(\"<<group.find(i.id)<<\")\"<<\": \"<<i.left<<\" to \"<<i.right<<endl;\n//   for(auto i=0;i<W;++i)cout<<\" \"<<flag.find(i);cout<<endl;cout<<endl;\n  set<int> res;\n  for(auto i = 0; i <= id; ++i) res.emplace(group.find(i));\n  cout << res.size() - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n//#include \"testlib.h\"\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<vector>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\n  REP(i, n){\t\t                            \\\n        REP(j, m-1) cout << A[i][j] << \" \";     \\\n        cout << A[i][m-1] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m-1) cout << A[i][j] << \" \";   \\\n        cout << A[i][m] << endl;\t\t        \\\n\t}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\n\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n        else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n        else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int MAXN = 100020;\n\n\tvector<int> xs;\n\nnamespace ST{\n    const int NN = 8 * MAXN;\n    bool T[NN]; int a, b;\n\n#define lx (x << 1)\n#define rx (lx | 1)\n#define ml (l + r >> 1)\n#define mr (ml + 1)\n#define lc lx, l, ml\n#define rc rx, mr, r\n#define rt 1, 0, xs.size()\n\n    void cov(int x){\n        T[x] = 1;\n    }\n\n    void rls(int x){\n        if (T[x]){\n            T[lx] = T[rx] = 1;\n            T[x] = 0;\n        }\n    }\n\n    bool Query(int x, int l, int r, int p){\n        if (l == r){\n            bool z = T[x]; T[x] = 0;\n            return z;\n        }\n        else{\n            rls(x);\n            return p < mr ? Query(lc, p) : Query(rc, p);\n        }\n    }\n    bool Query(int p){\n        return Query(rt, p);\n    }\n\n    void Insert(int x, int l, int r){\n        if (b < l || r < a) return;\n        if (a <= l && r <= b){\n            cov(x);\n        }\n        else{\n            rls(x);\n            Insert(lc); Insert(rc);\n        }\n    }\n    void Insert(int _a, int _b){\n        a = _a, b = _b;\n        Insert(rt);\n    }\n\n    void Clear(int x, int l, int r, int p){\n        if (l == r){\n            T[x] = 0;\n        }\n        else{\n            rls(x);\n            if (p < mr) Clear(lc, p);\n            else Clear(rc, p);\n        }\n    }\n}\n\nstruct action\n{\n\tint pos, act, left, right;\n\n\taction(int p, int a, int l, int r)\n\t{\n\t\tpos = p; act = a; left = l; right = r;\n\t}\n};\n\ninline bool operator<(const action& a, const action& b)\n{\n\treturn a.pos < b.pos || (a.pos == b.pos && a.act < b.act);\n}\n\nint W, H, N;\nint x1[MAXN], y1[MAXN], x2[MAXN], y2[MAXN];\nvector<int> uf;\nint target[MAXN*2];\n\nint root(int p)\n{\n    //cout << p << \" \" << uf[p] << endl;\n\treturn (uf[p] == p) ? p : (uf[p] = root(uf[p]));\n}\n\nbool join(int p, int q){\n\tp = root(p); q = root(q);\n\tif(p==q) return false;\n\tuf[q] = p;\n\treturn true;\n}\n\nvoid adjust(int p)\n{\n\t//if(seg.is_renew(p)){\n\n\t//cout << \" \" << p << endl;\n\n\t//cout << \"   \" << p << \" \"<< ST::Query(p) << \" \" << seg.is_renew(p) << endl;\n\n\tif (ST::Query(p)){\n        int t = uf.size();\n\t\tuf.push_back(t);\n\t\ttarget[p] = t;\n\t}\n\n}\n\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\n\nnamespace BIT{\n    const int N = MAXN * 2;\n    int C[N], n;\n    void Add(int x, int d){\n        for (;x<=n;x+=low_bit(x)) C[x] += d;\n    }\n    int Sum(int x){\n        int res = 0; for (;x;x^=low_bit(x)) res += C[x];\n        return res;\n    }\n    int Sum(int l, int r){\n        return Sum(r) - Sum(l-1);\n    }\n\n} //using namespace BIT;\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n\tscanf(\"%d%d%d\", &W, &H, &N);\n\t//N = 0;\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\", x1+i, y1+i, x2+i, y2+i);\n\t\tif(x1[i] > x2[i]) swap(x1[i], x2[i]);\n\t\tif(y1[i] > y2[i]) swap(y1[i], y2[i]);\n\t}\n\t//FLC(for(int i=0;i<2*N;i++) target[i] = -1;\n\n\tx1[N  ] = 0; y1[N  ] = 0; x2[N  ] = W; y2[N  ] = 0;\n\tx1[N+1] = 0; y1[N+1] = 0; x2[N+1] = 0; y2[N+1] = H;\n\tx1[N+2] = W; y1[N+2] = 0; x2[N+2] = W; y2[N+2] = H;\n\tx1[N+3] = 0; y1[N+3] = H; x2[N+3] = W; y2[N+3] = H;\n\tN += 4;\n\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(x1[i]);\n\t\txs.push_back(x2[i]);\n\t}\n\txs.push_back(-1);\n\tUNQ(xs);\n\n\tBIT::n = xs.size();\n\n\tfor(int i=0;i<N;i++){\n\t\tx1[i] = lower_bound(xs.begin(), xs.end(), x1[i]) - xs.begin();\n\t\tx2[i] = lower_bound(xs.begin(), xs.end(), x2[i]) - xs.begin();\n\t}\n\n\tset<int> S;\n\tS.insert(-1); S.insert(0);\n\ttarget[0] = 0;\n\tuf.push_back(0);\n\n\tvector<action> A;\n\n\tfor(int i=0;i<N;i++){\n\t\tif(x1[i] == x2[i]){\n\t\t\tA.push_back(action(y1[i], 0, x1[i], -1));\n\t\t\tA.push_back(action(y2[i], 2, x1[i], -1));\n\t\t}else{\n\t\t\tA.push_back(action(y1[i], 1, x1[i], x2[i]));\n\t\t}\n\t}\n\n\tsort(A.begin(), A.end());\n\n\tlong long ret = 0;\n\tfor(int i=0;i<A.size();i++){\n\t\taction V = A[i];\n\n\t\tif(V.act == 0){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\n\t\t\tadjust(lf); adjust(V.left);\n\t\t\tjoin(target[V.left], target[lf]);\n\n\t\t\tS.insert(V.left);\n\t\t\tBIT::Add(V.left, 1);\n\t\t}else if(V.act == 1){\n\t\t    int ll = *S.lower_bound(V.left);\n\t\t    int rr = *----S.upper_bound(V.right);\n\t\t    if (rr < ll) continue;\n\t\t\tret +=  BIT::Sum(ll, rr);\n\t\t\tST::Insert(ll, rr);\n\n\n\t\t}else if(V.act == 2){\n\t\t\tint lf = *--S.lower_bound(V.left);\n\t\t\tadjust(lf); adjust(V.left);\n\n\n\t\t\tint rett = ret;\n\t\t\tif(join(target[lf], target[V.left])) --ret;\n\n\n\t\t\tS.erase(V.left);\n\t\t\tBIT::Add(V.left, -1);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <chrono> //1e+9??§?????? auto end= chrono::system_clock::now()-st;  cout<<end.count()%1e+9<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef long double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\n\nll W,H,N;\nll A[100004],B[100004],C[100004],D[100004];\nvector<ll> xs,ys;\nvector<ll> uf;\nll ans=0;\nvector<ll> stev[200005];\nvector<P> xev[200005];\nvector<ll> enev[200005];\nset<ll> s;\nll bit[100005];\nconst ll SIZE=1<<18;\nll id[SIZE];\nbool flag[SIZE*2-1];\n\nvoid renew(ll a,ll b,ll k,ll l,ll r){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tflag[k]=1;\n\t\treturn;\n\t}\n\telse{\n\t\trenew(a,b,k*2+1,l,(l+r)/2);\n\t\trenew(a,b,k*2+2,(l+r)/2,r);\n\t\treturn;\n\t}\n}\n\nll query(ll a,ll k,ll l,ll r){\n\tif(SIZE-1<=k){\n\t\tif(flag[k]){\n\t\t\tflag[k]=0;\n\t\t\tid[a]=uf.size();\n\t\t\tuf.pb(uf.size());\n\t\t}\n\t\treturn id[a];\n\t}\n\tif(flag[k]){\n\t\tflag[k]=0;\n\t\tflag[k*2+1]=1;\n\t\tflag[k*2+2]=1;\n\t}\n\tif(a<(l+r)/2) return query(a,k*2+1,l,(l+r)/2);\n\telse return query(a,k*2+2,(l+r)/2,r);\n}\n\nvoid add(ll i,ll a){\n\ti++;\n\twhile(i<=100004){\n\t\tbit[i]+=a;\n\t\ti+=(i&-i);\n\t}\n}\n\nll sum(ll i){\n\tif(i==0) return 0;\n\tll r=0;\n\ti++;\n\twhile(i>0){\n\t\tr+=bit[i];\n\t\ti-=(i&-i);\n\t}\n\treturn r;\n}\n\nll find(ll x){\n\tif(uf[x]==x) return x;\n\treturn uf[x]=find(uf[x]);\n}\n\nvoid unite(ll x,ll y){\n\t//cout<<\" \"<<x<<\"and\"<<y<<endl;\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tans--;\n\t\t//cout<<\"m\"<<endl;\n\t}\n\tuf[x]=y;\n}\n\nint main()\n{\n\tcin>>W>>H>>N;\n\txs.pb(-1);\n\txs.pb(0);\n\txs.pb(W);\n\tys.pb(-1);\n\tys.pb(0);\n\tys.pb(H);\n\trep(i,N){\n\t\tcin>>A[i]>>B[i]>>C[i]>>D[i];\n\t\tif(A[i]>C[i]) swap(A[i],C[i]);\n\t\tif(B[i]>D[i]) swap(B[i],D[i]);\n\t\tif(A[i]==C[i]) xs.pb(A[i]);\n\t\tys.pb(B[i]);\n\t\tys.pb(D[i]);\n\t}\n\tA[N]=0; B[N]=0; C[N]=0; D[N]=H;\n\tA[N+1]=0; B[N+1]=0; C[N+1]=W; D[N+1]=0;\n\tA[N+2]=W; B[N+2]=0; C[N+2]=W; D[N+2]=H;\n\tA[N+3]=0; B[N+3]=H; C[N+3]=W; D[N+3]=H;\n\tN+=4;\n\tsort(xs.begin(),xs.end());\n\tsort(ys.begin(),ys.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tys.erase(unique(ys.begin(),ys.end()),ys.end());\n\tll ymax=0;\n\trep(i,N){\n\t\tif(A[i]==C[i]){\n\t\t\tA[i]=C[i]=lower_bound(xs.begin(),xs.end(),A[i])-xs.begin();\n\t\t\tB[i]=lower_bound(ys.begin(),ys.end(),B[i])-ys.begin();\n\t\t\tD[i]=lower_bound(ys.begin(),ys.end(),D[i])-ys.begin();\n\t\t\tstev[B[i]].pb(A[i]);\n\t\t\tenev[D[i]].pb(A[i]);\n\t\t\t//cout<<A[i]<<\" \"<<B[i]<<\" \"<<C[i]<<\" \"<<D[i]<<\"a\"<<endl;\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tA[i]=lower_bound(xs.begin(),xs.end(),A[i])-xs.begin();\n\t\t\tC[i]=upper_bound(xs.begin(),xs.end(),C[i])-xs.begin()-1;\n\t\t\tB[i]=D[i]=lower_bound(ys.begin(),ys.end(),B[i])-ys.begin();\n\t\t\txev[B[i]].pb(P(A[i],C[i]));\n\t\t\t//cout<<A[i]<<\" \"<<B[i]<<\" \"<<C[i]<<\" \"<<D[i]<<\"b\"<<endl;\n\t\t}\n\t\tymax=max(ymax,max(B[i],D[i]));\n\t}\n\tll l,r,bef;\n\ts.insert(0);\n\tuf.pb(0);\n\trep(Y,ymax+1){\n\t\trep(i,stev[Y].size()){\n\t\t\tbef=*--s.lower_bound(stev[Y][i]);\n\t\t\tquery(bef,0,0,SIZE);\n\t\t\tquery(stev[Y][i],0,0,SIZE);\n\t\t\tid[stev[Y][i]]=id[bef];\n\t\t\tadd(stev[Y][i],1);\n\t\t\ts.insert(stev[Y][i]);\n\t\t}\n\t\trep(i,xev[Y].size()){\n\t\t\tl=*s.lower_bound(xev[Y][i].fr); r=*--(s.upper_bound(xev[Y][i].sc));\n\t\t\tif(l<r){\n\t\t\t\tans+= sum(r-1)-sum(l-1);\n\t\t\t\t//cout<<Y<<endl;\n\t\t\t\t//cout<<sum(r-1)-sum(l-1)<<endl<<endl;\n\t\t\t\trenew(l,r,0,0,SIZE);\n\t\t\t}\n\t\t}\n\t\trep(i,enev[Y].size()){\n\t\t\t//cout<<Y;\n\t\t\tunite(query(*--( s.lower_bound(enev[Y][i]) ) ,0,0,SIZE) , query(  *(s.lower_bound(enev[Y][i])  ) ,0,0,SIZE ));\n\t\t\tadd(enev[Y][i],-1);\n\t\t\t//cout<<endl;\n\t\t\ts.erase(enev[Y][i]);\n\t\t}\n\t\t//rep(i,enev[Y].size()) \n\t\t//cout<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\t\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\t\tv.rank += 1\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tp x if v == nil\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, w)\nh_tree = IntervalTree.new(0, h)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {|hoge|\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\tuf.add(l)\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\t#a.each{|vl| uf.union(l, vl)}\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 100\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = v = nil\n\t\tif x.class == Node\n\t\t\tu = x\n\t\telse\n\t\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tend\n\n\t\tif y.class == Node\n\t\t\tv = y\n\t\telse\n\t\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\tend\n\n\t\treturn if u == v\n\t\t\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\t\tv.rank += 1\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nh_tree = IntervalTree.new(0, h)\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\n\nuf.union(l1, l2)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\n\nv_lines = []\n\ncount = 1\nn.times {|hoge|\n\t#p hoge\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_lines << l\n\tend\n\n\tif y1 == y2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\tuf.union(l, l1) if x1 == 0 || x2 == w \ncount += 1 if x1 == 0 && x2 == w\n\t\th_tree.add(x1, x2, y1)\n\tend\n}\n\nv_lines.each_with_index{|l, i|\n\t#p i\n\t#break\n\ta = h_tree.query(l.x1).map{|arr| h_line[arr]}\n\ta = a.select{|line| l.y1 <= line.y1 && line.y2 <= l.y2}\n\n\tgroup_count = Hash.new(-1)\n\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\tcount += group_count.values.inject(0, :+)\n\t#p a.size\n\t#a.each_cons(2){|foo, bar| uf.union(foo, bar)}\n\tgroup_count.keys.each_cons(2){|foo, bar| uf.union(foo, bar)}\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, w)\nh_tree = IntervalTree.new(0, h)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2\n\t\tif pred[c]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, 10**9)\nh_tree = IntervalTree.new(0, 10**9)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 100\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = v = nil\n\t\tif x.class == Node\n\t\t\tu = x.root\n\t\telse\n\t\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tend\n\n\t\tif y.class == Node\n\t\t\tv = y.root\n\t\telse\n\t\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\tend\n\n\t\treturn if u == v\n\t\t\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\t\tv.rank += 1\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nh_tree = IntervalTree.new(0, h)\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\n\nuf.union(l1, l2)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\n\nv_lines = []\n\ncount = 1\nn.times {|hoge|\n\t#p hoge\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_lines << l\n\tend\n\n\tif y1 == y2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\tuf.union(l, l1) if x1 == 0 || x2 == w \ncount += 1 if x1 == 0 && x2 == w\n\t\th_tree.add(x1, x2, y1)\n\tend\n}\n\nv_lines.each_with_index{|l, i|\n\t#p i\n\t#break\n\ta = h_tree.query(l.x1).map{|arr| h_line[arr]}\n\ta = a.select{|line| l.y1 <= line.y1 && line.y2 <= l.y2}\n\n\tgroup_count = Hash.new(-1)\n\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\tcount += group_count.values.inject(0, :+)\n\t#p a.size\n\t#a.each_cons(2){|foo, bar| uf.union(foo, bar)}\n\tgroup_count.keys.each_cons(2){|foo, bar| uf.union(foo, bar)}\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 100\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = v = nil\n\t\tif x.class == Node\n\t\t\tu = x\n\t\telse\n\t\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tend\n\n\t\tif y.class == Node\n\t\t\tv = y\n\t\telse\n\t\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\tend\n\n\t\treturn if u == v\n\t\t\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\t\tv.rank += 1\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nh_tree = IntervalTree.new(0, h)\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\n\nuf.union(l1, l2)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\n\nv_lines = []\n\ncount = 1\nn.times {|hoge|\n\t#p hoge\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_lines << l\n\tend\n\n\tif y1 == y2\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\tuf.union(l, l1) if x1 == 0 || x2 == w \n\t\th_tree.add(x1, x2, y1)\n\tend\n}\n\nv_lines.each_with_index{|l, i|\n\t#p i\n\t#break\n\ta = h_tree.query(l.x1).map{|arr| h_line[arr]}\n\ta = a.select{|line| l.y1 <= line.y1 && line.y2 <= l.y2}\n\n\tgroup_count = Hash.new(-1)\n\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\tcount += group_count.values.inject(0, :+)\n\t#p a.size\n\t#a.each_cons(2){|foo, bar| uf.union(foo, bar)}\n\tgroup_count.keys.each_cons(2){|foo, bar| uf.union(foo, bar)}\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, 10**9)\nh_tree = IntervalTree.new(0, 10**9)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, w)\nh_tree = IntervalTree.new(0, h)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\tuf.add(l)\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count.values\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2\n\t\tif pred[c]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, 10**9)\nh_tree = IntervalTree.new(0, 10**9)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\ta.each_cons(2){|l1, l2|\n\t\t\tif uf.same?(l1, l2)\n\t\t\t\tcount += 1\n\t\t#\t\tp \"gotcha\"\n\t\t\tend\n\t\t}\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\ta.each_cons(2){|l1, l2| \n\t\t\tif uf.same?(l1, l2)\n\t\t\t\tcount += 1\n\t\t#\t\tp \"gotcha\"\n\t\t\tend\n\t\t}\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n}\n\np count"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nclass Line\n\tdef initialize(*args)\n\t\t@x1, @y1, @x2, @y2 = args\n\tend\n\tattr_reader :x1, :y1, :x2, :y2\nend\n\nclass IntervalTree\n\tdef initialize(l, r)\n\t\t@l = l\n\t\t@r = r\n\t\t@c = (l + r) / 2\n\t\t@left_child = @right_child = nil\n\t\t@start_sorted = []\n\t\t@end_sorted = []\n\tend\n\n\tdef add(l, r, x)\n\t\tif r < @c\n\t\t\t@left_child ||= self.class.new(l, @c - 1)\n\t\t\t@left_child.add(l, r, x)\n\t\telsif @c < l\n\t\t\t@right_child ||= self.class.new(@c + 1, r)\n\t\t\t@right_child.add(l, r, x)\n\t\telse\n\t\t\ti = @start_sorted.bsearch{|p, q, _| p >= l} || @start_sorted.size\n\t\t\t@start_sorted.insert(i, [l, r, x])\n\t\t\ti = @end_sorted.bsearch{|p, q, _| q >= r} || @end_sorted.size\n\t\t\t@end_sorted.insert(i, [l, r, x])\n\t\tend\n\tend\n\n\tdef query(x)\n\t\tif x < @c\n\t\t\tans = @start_sorted.take_while{|l, r| l <= x} \n\t\t\tans += @left_child.query(x) if @left_child\n\t\t\tans\n\t\telsif x > @c\n\t\t\tans = []\n\t\t\tans += @right_child.query(x) if @right_child\n\t\t\ti = @end_sorted.bsearch{|l, r| x <= r}\n\t\t\tans += @end_sorted[i..-1] if i\n\t\t\tans\n\t\telse\n\t\t\t@start_sorted\n\t\tend\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\t\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\t\tv.rank += 1\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tv = @obj_to_node[x]\n\t\tp x if v == nil\n\t\tv ? v.root : nil\n\tend\nend\n\n\nuf = UnionFind.new\n\nw, h, n = gets.split.map(&:to_i)\nv_tree = IntervalTree.new(0, w)\nh_tree = IntervalTree.new(0, h)\nv_line = {}\nh_line = {}\n\nl1 = Line.new(0,0,w,0)\nl2 = Line.new(0,h,w,h)\nl3 = Line.new(0,0,0,h)\nl4 = Line.new(w,0,w,h)\n\nh_line[[0,w,0]] = l1\nh_line[[0,w,h]] = l2\nv_line[[0,h,0]] = l3\nv_line[[0,h,w]] = l4\n\nuf.union(l1, l2)\nuf.union(l1, l3)\nuf.union(l1, l4)\n\nh_tree.add(0, w, 0)\nh_tree.add(0, w, h)\nv_tree.add(0, h, 0)\nv_tree.add(0, h, w)\n\ncount = 1\nn.times {|hoge|\n\tx1, y1, x2, y2 = gets.split.map(&:to_i)\n\n\tif x1 == x2\n\t\t#puts \"added: v (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = h_tree.query(x1).map{|x| h_line[x]}\n\t\ta = a.select{|line| y1 <= line.y1 && line.y2 <= y2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|hl| group_count[uf.root_of(hl)] += 1}\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\tv_line[[y1, y2, x1]] = l\n\t\tuf.add(l)\n\t\ta.each{|hl| uf.union(l, hl)}\n\t\tv_tree.add(y1, y2, x1)\n\tend\n\n\tif y1 == y2\n\t\t#puts \"added: h (#{x1}, #{y1}, #{x2}, #{y2})\"\n\t\ta = v_tree.query(y1).map{|x| v_line[x]}\n\t\ta = a.select{|line| x1 <= line.x1 && line.x2 <= x2}\n\t\t#p a\n\n\t\tgroup_count = Hash.new(-1)\n\t\ta.each{|vl| group_count[uf.root_of(vl)] += 1}\n\t\t#p group_count\n\t\tcount += group_count.values.inject(0, :+)\n\n\t\tl = Line.new(x1, y1, x2, y2)\n\t\th_line[[x1, x2, y1]] = l\n\t\tuf.add(l)\n\t\t#a.each{|vl| uf.union(l, vl)}\n\t\ta.each{|vl| uf.union(l, vl)}\n\t\th_tree.add(x1, x2, y1)\n\tend\n\n\t#puts\n\tbreak if hoge > 1000\n}\n\np count"
  },
  {
    "language": "D",
    "code": "import std.container;\nimport std.algorithm;\nimport std.stdio;\nimport core.stdc.stdio;\nimport std.typecons;\n\nstruct BinaryIndexedTree{\n\tint s;\n\tint[] data;\n\tvoid Initialize(int size){\n\t\ts=size;\n\t\tdata = new int[size];\n\t}\n\tvoid Add(int idx,int val){\n\t\twhile(idx<s){\n\t\t\tdata[idx]+=val;\n\t\t\tidx+=(idx+1)&(-idx-1);\n\t\t}\n\t}\n\tint Get(int idx){\n\t\tint ret=0;\n\t\twhile(idx>=0){\n\t\t\tret += data[idx];\n\t\t\tidx -= (idx+1)&(-idx-1);\n\t\t}\n\t\treturn ret;\n\t}\n\tint Query(int b,int e){\n\t\tif(e<=b)\n\t\t\treturn 0;\n\t\treturn Get(e-1)-Get(b-1);\n\t}\n}\n\nstruct UnionFind{\n\talias Tuple!(int,\"rank\",int,\"parent\") rp;\n\trp[] data;\n\tvoid Initialize(int s){\n\t\tdata = new rp[s];\n\t\tfor(int i=0;i<s;i++)\n\t\t\tdata[i].parent=i;\n\t}\n\tint Find(int idx){\n\t\tif(data[idx].parent==idx)\n\t\t\treturn idx;\n\t\treturn data[idx].parent=Find(data[idx].parent);\n\t}\n\tint Unify(int a,int b){\n\t\ta = Find(a);\n\t\tb = Find(b);\n\t\tif(a!=b){\n\t\t\tif(data[a].rank<data[b].rank)\n\t\t\t\tdata[a].parent = b;\n\t\t\telse if(data[a].rank>data[b].rank)\n\t\t\t\tdata[b].parent = a;\n\t\t\telse{\n\t\t\t\tdata[a].parent = b;\n\t\t\t\tdata[b].rank++;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nint LowerBoundIdx(T)(T[] data,T t){\n\tint l=0;\n\tint r=cast(int)data.length+1;\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tif(data[m-1]<t)\n\t\t\tl=m;\n\t\telse\n\t\t\tr=m;\n\t}\n\treturn l;\n}\n\nvoid main(){\n\tint w,h,n;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tint[4][] lines = new int[4][n+4];\n\tint[] xs = new int[n+2];\n\tint vc=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&lines[i][0],&lines[i][1],&lines[i][2],&lines[i][3]);\n\t\tif(lines[i][0] == lines[i][2])\n\t\t\txs[vc++] = lines[i][0];\n\t}\n\tlines[n] = [0,0,w,0];\n\tlines[n+1] = [0,h,w,h];\n\tlines[n+2] = [0,0,0,h];\n\tlines[n+3] = [w,0,w,h];\n\tn+=4;\n\txs[vc++]=0;\n\txs[vc++]=w;\n\txs = xs[0..vc];\n\tsort(xs);\n\t\n\talias Tuple!(int,\"y\",int,\"type\",int,\"x\",int,\"v\") query;\n\tquery[] qs = new query[vc+n];\n\tint qc=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(lines[i][0] == lines[i][2]){\n\t\t\tint x = LowerBoundIdx(xs,lines[i][0]);\n\t\t\tqs[qc++] = query(lines[i][1],0,x,1);\n\t\t\tqs[qc++] = query(lines[i][3],2,x,-1);\n\t\t}else if(lines[i][1] == lines[i][3]){\n\t\t\tqs[qc++] = query(lines[i][1],1,LowerBoundIdx(xs,lines[i][0]),LowerBoundIdx(xs,lines[i][2]+1));\n\t\t}else\n\t\t\tassert(false);\n\t}\n\tsort(qs);\n\t\n\tint* numBuffer(int a){\n\t\tstatic int[] buffers = new int[1919810];\n\t\tstatic int nbc=0;\n\t\tbuffers[nbc]=a;\n\t\treturn &buffers[nbc++];\n\t}\n\talias Tuple!(int,\"x\",int,\"g\",int*,\"end\") group;\n\talias RedBlackTree!group gSet;\n\tgSet gs = new gSet;\n\t\n\talias RedBlackTree!int iSet;\n\tiSet vs = new iSet;\n\t\n\tBinaryIndexedTree bit;\n\tbit.Initialize(vc);\n\t\n\tUnionFind uf;\n\tuf.Initialize(vc);\n\tint uc=0;\n\t\n\tlong ans=0;\n\t\n\tfor(int i=0;i<qc;i++){\n\t\twith(qs[i]){\n\t\t\tif(type==0){\n\t\t\t\t//add Vertical line\n\t\t\t\tassert(v==1);\n\t\t\t\tbit.Add(x,1);\n\t\t\t\tauto lb = gs.lowerBound(group(x,-1,null));\n\t\t\t\tif(!lb.empty){\n\t\t\t\t\tgroup pre = lb.back;\n\t\t\t\t\tassert(*pre.end!=x);\n\t\t\t\t\tif(*pre.end>x){\n\t\t\t\t\t\tgroup d;\n\t\t\t\t\t\td.x = vs.upperBound(x).front;\n\t\t\t\t\t\td.g = pre.g;\n\t\t\t\t\t\td.end = numBuffer(*pre.end);\n\t\t\t\t\t\tgs.insert(d);\n\t\t\t\t\t\t*pre.end = vs.lowerBound(x).back;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgs.insert(group(x,uc++,numBuffer(x)));\n\t\t\t\tvs.insert(x);\n\t\t\t}else if(type==1){\n\t\t\t\t//add Horizonal line\n\t\t\t\tint kind=0;\n\t\t\t\tauto lb = gs.lowerBound(group(x,-1,null));\n\t\t\t\tgroup ml;\n\t\t\t\tint mr;\n\t\t\t\tif(!lb.empty){\n\t\t\t\t\tgroup pre = lb.back;\n\t\t\t\t\tif(x<=*pre.end){\n\t\t\t\t\t\tkind=1;\n\t\t\t\t\t\tml=pre;\n\t\t\t\t\t\tmr=*pre.end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto ub = gs.upperBound(group(x,-1,null));\n\t\t\t\twhile(!ub.empty){\n\t\t\t\t\tgroup nx = ub.front;\n\t\t\t\t\tub.popFront;\n\t\t\t\t\tif(nx.x<v){\n\t\t\t\t\t\tif(kind==0){\n\t\t\t\t\t\t\tkind=1;\n\t\t\t\t\t\t\tml=nx;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tkind += uf.Unify(ml.g,nx.g);\n\t\t\t\t\t\t\tgs.removeKey(nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmr = *nx.end;\n\t\t\t\t\t}else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//writeln(qs[i],\" \",kind);\n\t\t\t\tint bq = bit.Query(x,v);\n\t\t\t\tif(kind>0&&bq>0){\n\t\t\t\t\t*ml.end = mr;\n\t\t\t\t\tans += bq-kind;\n\t\t\t\t}\n\t\t\t}else if(type==2){\n\t\t\t\t//remove Vertical line\n\t\t\t\tassert(v==-1);\n\t\t\t\tbit.Add(x,-1);\n\t\t\t\tauto lb = gs.lowerBound(group(x,1919114514,null));\n\t\t\t\tassert(!lb.empty);\n\t\t\t\tgroup pre = lb.back;\n\t\t\t\tif(pre.x == x){\n\t\t\t\t\tgs.removeKey(pre);\n\t\t\t\t\tif(*pre.end>x){\n\t\t\t\t\t\tpre.x=vs.upperBound(x).front;\n\t\t\t\t\t\tgs.insert(pre);\n\t\t\t\t\t}\n\t\t\t\t}else if(*pre.end==x){\n\t\t\t\t\tif(pre.x<x)\n\t\t\t\t\t\t*pre.end = vs.lowerBound(x).back;\n\t\t\t\t\telse\n\t\t\t\t\t\tassert(false);\n\t\t\t\t}else if(pre.x<x&&x<*pre.end){\n\t\t\t\t\t//do nothing\n\t\t\t\t}else\n\t\t\t\t\tassert(false);\n\t\t\t\tvs.removeKey(x);\n\t\t\t}else\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import std.container;\nimport std.algorithm;\nimport std.stdio;\nimport core.stdc.stdio;\nimport std.typecons;\n\nstruct BinaryIndexedTree{\n\tint s;\n\tint[] data;\n\tvoid Initialize(int size){\n\t\ts=size;\n\t\tdata = new int[size];\n\t}\n\tvoid Add(int idx,int val){\n\t\twhile(idx<s){\n\t\t\tdata[idx]+=val;\n\t\t\tidx+=(idx+1)&(-idx-1);\n\t\t}\n\t}\n\tint Get(int idx){\n\t\tint ret=0;\n\t\twhile(idx>=0){\n\t\t\tret += data[idx];\n\t\t\tidx -= (idx+1)&(-idx-1);\n\t\t}\n\t\treturn ret;\n\t}\n\tint Query(int b,int e){\n\t\tif(e<=b)\n\t\t\treturn 0;\n\t\treturn Get(e-1)-Get(b-1);\n\t}\n}\n\nstruct UnionFind{\n\talias Tuple!(int,\"rank\",int,\"parent\") rp;\n\trp[] data;\n\tvoid Initialize(int s){\n\t\tdata = new rp[s];\n\t\tfor(int i=0;i<s;i++)\n\t\t\tdata[i].parent=i;\n\t}\n\tint Find(int idx){\n\t\tif(data[idx].parent==idx)\n\t\t\treturn idx;\n\t\treturn data[idx].parent=Find(data[idx].parent);\n\t}\n\tint Unify(int a,int b){\n\t\ta = Find(a);\n\t\tb = Find(b);\n\t\tif(a!=b){\n\t\t\tif(data[a].rank<data[b].rank)\n\t\t\t\tdata[a].parent = b;\n\t\t\telse if(data[a].rank>data[b].rank)\n\t\t\t\tdata[b].parent = a;\n\t\t\telse{\n\t\t\t\tdata[a].parent = b;\n\t\t\t\tdata[b].rank++;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nint LowerBoundIdx(T)(T[] data,T t){\n\tint l=0;\n\tint r=cast(int)data.length+1;\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tif(data[m-1]<t)\n\t\t\tl=m;\n\t\telse\n\t\t\tr=m;\n\t}\n\treturn l;\n}\n\nvoid main(){\n\tint w,h,n;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tint[4][] lines = new int[4][n+4];\n\tint[] xs = new int[n+2];\n\tint vc=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&lines[i][0],&lines[i][1],&lines[i][2],&lines[i][3]);\n\t\tif(lines[i][0] == lines[i][2])\n\t\t\txs[vc++] = lines[i][0];\n\t}\n\tlines[n] = [0,0,w,0];\n\tlines[n+1] = [0,h,w,h];\n\tlines[n+2] = [0,0,0,h];\n\tlines[n+3] = [w,0,w,h];\n\tn+=4;\n\txs[vc++]=0;\n\txs[vc++]=w;\n\txs = xs[0..vc];\n\tsort(xs);\n\t\n\talias Tuple!(int,\"y\",int,\"type\",int,\"x\",int,\"v\") query;\n\tquery[] qs = new query[vc+n];\n\tint qc=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(lines[i][0] == lines[i][2]){\n\t\t\tint x = LowerBoundIdx(xs,lines[i][0]);\n\t\t\tqs[qc++] = query(lines[i][1],0,x,1);\n\t\t\tqs[qc++] = query(lines[i][3],2,x,-1);\n\t\t}else if(lines[i][1] == lines[i][3]){\n\t\t\tqs[qc++] = query(lines[i][1],1,LowerBoundIdx(xs,lines[i][0]),LowerBoundIdx(xs,lines[i][2]+1));\n\t\t}else\n\t\t\tassert(false);\n\t}\n\tsort(qs);\n\t\n\tint* numBuffer(int a){\n\t\tstatic int[] buffers = new int[1919810];\n\t\tstatic int nbc=0;\n\t\tbuffers[nbc]=a;\n\t\treturn &buffers[nbc++];\n\t}\n\talias Tuple!(int,\"x\",int,\"g\",int*,\"end\") group;\n\talias RedBlackTree!group gSet;\n\tgSet gs = new gSet;\n\t\n\talias RedBlackTree!int iSet;\n\tiSet vs = new iSet;\n\t\n\tBinaryIndexedTree bit;\n\tbit.Initialize(vc);\n\t\n\tUnionFind uf;\n\tuf.Initialize(vc);\n\tint uc=0;\n\t\n\tlong ans=0;\n\t\n\tfor(int i=0;i<qc;i++){\n\t\twith(qs[i]){\n\t\t\tif(type==0){\n\t\t\t\t//add Vertical line\n\t\t\t\tassert(v==1);\n\t\t\t\tbit.Add(x,1);\n\t\t\t\tauto lb = gs.lowerBound(group(x,-1,null));\n\t\t\t\tif(!lb.empty){\n\t\t\t\t\tgroup pre = lb.back;\n\t\t\t\t\tassert(*pre.end!=x);\n\t\t\t\t\tif(*pre.end>x){\n\t\t\t\t\t\tgroup d;\n\t\t\t\t\t\td.x = vs.upperBound(x).front;\n\t\t\t\t\t\td.g = pre.g;\n\t\t\t\t\t\td.end = numBuffer(*pre.end);\n\t\t\t\t\t\tgs.insert(d);\n\t\t\t\t\t\t*pre.end = vs.lowerBound(x).back;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgs.insert(group(x,uc++,numBuffer(x)));\n\t\t\t\tvs.insert(x);\n\t\t\t}else if(type==1){\n\t\t\t\t//add Horizonal line\n\t\t\t\tint kind=0;\n\t\t\t\tauto lb = gs.lowerBound(group(x,-1,null));\n\t\t\t\tgroup ml;\n\t\t\t\tint mr;\n\t\t\t\tif(!lb.empty){\n\t\t\t\t\tgroup pre = lb.back;\n\t\t\t\t\tif(x<=*pre.end){\n\t\t\t\t\t\tkind=1;\n\t\t\t\t\t\tml=pre;\n\t\t\t\t\t\tmr=*pre.end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto ub = gs.upperBound(group(x,-1,null));\n\t\t\t\twhile(!ub.empty){\n\t\t\t\t\tgroup nx = ub.front;\n\t\t\t\t\tub.popFront;\n\t\t\t\t\tif(nx.x<v){\n\t\t\t\t\t\tif(kind==0){\n\t\t\t\t\t\t\tkind=1;\n\t\t\t\t\t\t\tml=nx;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tkind += uf.Unify(ml.g,nx.g);\n\t\t\t\t\t\t\tgs.removeKey(nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmr = *nx.end;\n\t\t\t\t\t}else\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(kind>0){\n\t\t\t\t\t*ml.end = mr;\n\t\t\t\t\tans += bit.Query(x,v)-kind;\n\t\t\t\t}\n\t\t\t}else if(type==2){\n\t\t\t\t//remove Vertical line\n\t\t\t\tassert(v==-1);\n\t\t\t\tbit.Add(x,-1);\n\t\t\t\tauto lb = gs.lowerBound(group(x,1919114514,null));\n\t\t\t\tassert(!lb.empty);\n\t\t\t\tgroup pre = lb.back;\n\t\t\t\tif(pre.x == x){\n\t\t\t\t\tgs.removeKey(pre);\n\t\t\t\t\tif(*pre.end>x){\n\t\t\t\t\t\tpre.x=vs.upperBound(x).front;\n\t\t\t\t\t\tgs.insert(pre);\n\t\t\t\t\t}\n\t\t\t\t}else if(*pre.end==x){\n\t\t\t\t\tif(pre.x<x)\n\t\t\t\t\t\t*pre.end = vs.lowerBound(x).back;\n\t\t\t\t\telse\n\t\t\t\t\t\tassert(false);\n\t\t\t\t}else if(pre.x<x&&x<*pre.end){\n\t\t\t\t\t//do nothing\n\t\t\t\t}else\n\t\t\t\t\tassert(false);\n\t\t\t\tvs.removeKey(x);\n\t\t\t}else\n\t\t\t\tassert(false);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "Python",
    "code": "import math\nclass seg_tree:\n    def __init__(self, n):\n        self.depth = math.ceil(math.log(n, 2))\n        self.size = 1 << self.depth\n        self.bit = [0] * 2 * self.size\n        self.renew = [0] * 2 * self.size\n\n    def add(self, p, v):\n        p += self.size;\n        while p:\n            self.bit[p] += v\n            p >>= 1\n\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        ret = 0\n\n        while l < r:\n            if l & 1:\n                ret += self.bit[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                ret += self.bit[r]\n            l >>= 1\n            r >>= 1\n        return ret\n\n    def set_renew(self, l, r):\n        l += self.size\n        r += self.size\n\n        while l < r:\n            if l & 1:\n                self.renew[l] = 1\n                l += 1\n            if r & 1:\n                r -= 1\n                self.renew[r] = 1\n            l >>= 1\n            r >>= 1\n\n    def is_renew(self, p):\n        p += self.size\n        while p:\n            if self.renew[p]:\n                return True\n            p >>= 1\n        return False\n\n    def unset_renew(self, p):\n        p += self.size\n        for i in range(self.depth - 1,0,-1):\n            if self.renew[p >> i]:\n                self.renew[p >> i] = 0\n                self.renew[(p>>i)*2] = self.renew[(p>>i)*2+1] = 1\n        self.renew[p] = 0\nfrom collections import UserList\nclass sorted_set(UserList):\n    def __init__(self):\n        UserList.__init__(self)\n    # 左隣の縦線の位置を取得\n    def get_lf(self, v):\n        return self.data[bisect(self.data, v) - 1]\n        \n    def insert(self, v):\n        i = bisect(self.data, v)\n        if len(self.data) <= i or self.data[i] != v:\n            self.data.insert(i, v)\n    def erase(self, v):\n        self.data.remove(v)\nclass union_find(UserList):\n    def __init__(self):\n        UserList.__init__(self)\n    def root(self, p):\n        if self.data[p] < 0:\n            return p\n        self.data[p] = self.root(self.data[p])\n        return self.data[p]\n    def join(self, p, q):\n        p, q = self.root(p), self.root(q)\n\n        if p == q:\n            return False\n        if self.data[p] < self.data[q]:\n            p, q = q, p\n        self.data[p], self.data[q] = self.data[q], p\n        return True\ndef bisect(a,v):\n    l, r = 0, len(a)\n    while l < r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\ndef adjust(seg, uf, target, p):\n    if seg.is_renew(p):\n        uf.append(-1)\n        seg.unset_renew(p)\n        target[p] = len(uf) - 1\nfrom operator import itemgetter\ndef main(f):    \n    w,h,n = map(int,f.readline().split())\n    abcd = [list(map(int,line.split())) for line in f]\n\n    abcd.extend([[0,0,w,0],\n                 [0,0,0,h],\n                 [w,0,w,h],\n                 [0,h,w,h]])\n\n    xs = sorted({abcdi[0] for abcdi in abcd} | {abcdi[2] for abcdi in abcd} | {-1})\n\n    for abcdi in abcd:\n        abcdi[0] = bisect(xs,abcdi[0])\n        abcdi[2] = bisect(xs,abcdi[2])\n\n    s = sorted_set()\n    s.insert(0)\n    target = [-1] * n * 2\n    target[0] = 0\n    uf = union_find()\n    uf.append(-1)\n    seg = seg_tree(len(xs))\n\n    a = []\n    for x1,y1,x2,y2 in abcd:\n        if x1 == x2:\n            a.append((y1, 0, x1, -1))\n            a.append((y2, 2, x1, -1))\n        else:\n            a.append((y1, 1, x1, x2))\n    a.sort(key=itemgetter(0,1))\n    ret = 0\n    for _, act, left, right in a:\n        if act == 0:\n            lf = s.get_lf(left)\n\n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            target[left] = target[lf]\n\n            s.insert(left)\n            seg.add(left, 1)\n        elif act == 1:\n            count = seg.query(left, right+1)\n            if count < 2:\n               continue\n            ret += count - 1;\n\n            seg.set_renew(left, s.get_lf(right + 1))\n        elif act == 2:\n            lf = s.get_lf(left)\n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            if uf.join(target[lf], target[left]):\n                ret -= 1\n            s.erase(left)\n            seg.add(left, -1)\n    print(ret)\nimport sys\nf = sys.stdin\nmain(f)"
  },
  {
    "language": "Python",
    "code": "import math\nclass segmentTree:\n    def __init__(self, n):\n        self.pad = 2 ** math.ceil(math.log(n, 2))\n        self.bit = [0] * self.pad * 2\n\n    def __add(self, i, v):\n        i += self.pad\n        while i:\n            self.bit[i] += v\n            i >>= 1        \n    def delete(self, i):\n        self.__add(i,-1)\n    def add(self, i):\n        self.__add(i, 1)\n\n    def crossing(self, l, r):\n        l += self.pad\n        r += self.pad\n        ret = 0\n        while l < r:\n            if r & 1:\n                r -= 1\n                ret += self.bit[r]\n            if l & 1:\n                ret += self.bit[l]\n                l += 1\n            l >>= 1\n            r >>= 1\n        return ret\n    # rの左直近で立つbitのindexを返す\n    def lower_bound(self, r):\n        l = self.pad\n        r += self.pad\n        while l < r:\n            if r & 1:\n                r -= 1\n                if self.bit[r]:\n                    while r < self.pad:\n                        r <<= 1\n                        if self.bit[r + 1]:\n                            r += 1\n                    return r - self.pad\n            if l & 1:\n                l += 1            \n            l >>= 1\n            r >>= 1\n        return -1\n    # iの右直近で立つbitのindexを返す\n    def upper_bound(self, l):\n        l += self.pad + 1\n        r = len(self.bit) - 1\n        while l <= r:\n            if r & 1:\n                r -= 1\n            if l & 1:\n                if self.bit[l]:\n                    while l < self.pad:\n                        l <<= 1\n                        if self.bit[l] == 0:\n                            l += 1\n                    return l - self.pad\n                l += 1            \n            l >>= 1\n            r >>= 1\n        return -1\n                \nclass delay_force_segment_no:\n    def __init__(self, n):\n        self.pad = 2 ** math.ceil(math.log(n, 2))\n        self.delay = [0] * self.pad * 2\n        self.dat = [0] * n\n        self.seg_no_max = 0\n    def mark_delay(self, l, r):\n        l += self.pad\n        r += self.pad\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.delay[r] = 1\n            if l & 1:\n                self.delay[l] = 1\n                l += 1\n            l >>= 1\n            r >>= 1\n    def update(self, i, v):\n        self.__force(i)\n        self.dat[i] = v\n    def get(self, i):\n        self.__force(i)\n        return self.dat[i]\n    def __is_marked(self, i):\n        i += self.pad\n        while i:\n            if self.delay[i]:\n                return True\n            i >>= 1\n        return False\n    def __force(self, i):\n        if not self.__is_marked(i):\n            return\n        self.seg_no_max += 1\n        self.dat[i] = self.seg_no_max\n        i += self.pad\n        for j in range(int(math.log(i, 2)), 0, -1):\n            if self.delay[i >> j]:\n                self.delay[i >> j] = 0\n                self.delay[(i >> j) * 2] = self.delay[(i >> j) * 2 + 1] = 1\n        self.delay[i] = 0\n\nimport sys\nf = sys.stdin\n\nw,h,n = map(int,f.readline().split())\n#abcd = [[0,0,0,h],[w,0,w,h],[0,0,w,0]] + [list(map(int,line.split())) for line in f] + [[0,h,w,h]]#a<=c and b<=d is True ※問の条件\nabcd = [[0,0,w,0],[0,h,w,h]] + [list(map(int,line.split())) for line in f] #a<=c and b<=d is True ※問の条件\n\n# X軸を圧縮\ndef bisect(a,v):\n    l,r = 0,len(a)-1    \n    while l != r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\nx_set = sorted({abcdi[0] for abcdi in abcd} | {abcdi[2] for abcdi in abcd})\naction = []\nVERTICAL_LINE_TOP,HORIZONTAL_LINE,VERTICAL_LINE_BOTTOM = 0,1,2\nfor a,b,c,d in abcd:\n    a = bisect(x_set,a) #X座標圧縮\n    c = bisect(x_set,c)\n    if a == c:\n        action.append((VERTICAL_LINE_TOP,a,b,-1))\n        action.append((VERTICAL_LINE_BOTTOM,a,d,-1))\n    else:\n        action.append((HORIZONTAL_LINE,a,b,c))\n    \n# 2:Y座標でソート,0:action_typeでソート\nfrom operator import itemgetter\naction.sort(key=itemgetter(2,0))\n\nret = 0\nvertical_line = segmentTree(len(x_set))\nvertical_line.add(0) #左の縦線\nvertical_line.add(len(x_set) - 1) # 右の縦線\nsegment_no = delay_force_segment_no(len(x_set))\nfor action_type,x1,y1,x2 in action:\n    if action_type == VERTICAL_LINE_TOP:\n        vertical_line.add(x1)\n        left_line = vertical_line.lower_bound(x1)\n        segment_no.update(x1, segment_no.get(left_line))\n    elif action_type == HORIZONTAL_LINE:\n        count = vertical_line.crossing(x1,x2 + 1)\n        if count < 2:\n            continue\n        ret += count - 1\n        segment_no.mark_delay(x1, x2)\n    else:\n        left_line = vertical_line.lower_bound(x1)\n        l_no = segment_no.get(left_line)\n        x_no = segment_no.get(x1)\n        if l_no != x_no:\n            ret -= 1\n            if l_no < x_no:\n                segment_no.update(x1, l_no)\n            else:\n                segment_no.update(left_line, x_no)\n        vertical_line.delete(x1)\nprint(ret - 1)"
  },
  {
    "language": "Python",
    "code": "import math\nclass segmentTree:\n    def __init__(self, n):\n        self.pad = 2 ** math.ceil(math.log(n, 2))\n        self.bit = [0] * self.pad * 2\n\n    def __add(self, i, v):\n        i += self.pad\n        while i:\n            self.bit[i] += v\n            i >>= 1        \n    def delete(self, i):\n        self.__add(i,-1)\n    def add(self, i):\n        self.__add(i, 1)\n\n    def crossing(self, l, r):\n        l += self.pad\n        r += self.pad\n        ret = 0\n        while l < r:\n            if r & 1:\n                r -= 1\n                ret += self.bit[r]\n            if l & 1:\n                ret += self.bit[l]\n                l += 1\n            l >>= 1\n            r >>= 1\n        return ret\n    # rの左直近で立つbitのindexを返す\n    def lower_bound(self, r):\n        l = self.pad\n        r += self.pad\n        while l < r:\n            if r & 1:\n                r -= 1\n                if self.bit[r]:\n                    while r < self.pad:\n                        r <<= 1\n                        if self.bit[r + 1]:\n                            r += 1\n                    return r - self.pad\n            if l & 1:\n                l += 1            \n            l >>= 1\n            r >>= 1\n        return 0\nclass delay_force_union_find:\n    def __init__(self, n):\n        self.pad = 2 ** math.ceil(math.log(n, 2))\n        self.delay = [0] * self.pad * 2\n        self.dat = [-1] * (n + 1)\n    def mark_delay(self, l, r):\n        l += self.pad\n        r += self.pad\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.delay[r] = 1\n            if l & 1:\n                self.delay[l] = 1\n                l += 1\n            l >>= 1\n            r >>= 1\n    def update(self, i, v):\n        self.__force(i)\n        self.dat[i] = v\n    def find(self, i):\n        self.__force(i)\n        while self.dat[i] >= 0:\n            i = self.dat[i]\n        return i\n    def union(self,a,b):\n        s1 = self.find(a)\n        s2 = self.find(b)\n        if s1 != s2:\n            if self.dat[s1] >= self.dat[s2]:\n                # 小さいほうが個数が多い\n                self.dat[s1] += self.dat[s2]\n                self.dat[s2] = s1\n            else:\n                self.dat[s2] += self.dat[s1]\n                self.dat[s1] = s2\n            return True\n        return False\n    \n    def __is_marked(self, i):\n        i += self.pad\n        while i:\n            if self.delay[i]:\n                return True\n            i >>= 1\n        return False\n    def __force(self, i):\n        if not self.__is_marked(i):\n            return\n        self.dat[i] = -1\n        i += self.pad\n        for j in range(int(math.log(i, 2)), 0, -1):\n            if self.delay[i >> j]:\n                self.delay[i >> j] = 0\n                self.delay[(i >> j) * 2] = self.delay[(i >> j) * 2 + 1] = 1\n        self.delay[i] = 0\n\nimport sys\nf = sys.stdin\nw,h,n = map(int,f.readline().split())\nabcd = [[0,0,0,h],[w,0,w,h],[0,0,w,0]] + [list(map(int,line.split())) for line in f] + [[0,h,w,h]]#a<=c and b<=d is True ※問の条件\n\n# X軸を圧縮\ndef bisect(a,v):\n    l,r = 0,len(a)-1    \n    while l != r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\nx_set = sorted({abcdi[0] for abcdi in abcd} | {abcdi[2] for abcdi in abcd})\naction = []\nVERTICAL_LINE_TOP,HORIZONTAL_LINE,VERTICAL_LINE_BOTTOM = 0,1,2\nfor a,b,c,d in abcd:\n    a = bisect(x_set,a) #X座標圧縮\n    c = bisect(x_set,c)\n    if a == c:\n        action.append((VERTICAL_LINE_TOP,a,b,-1))\n        action.append((VERTICAL_LINE_BOTTOM,a,d,-1))\n    else:\n        action.append((HORIZONTAL_LINE,a,b,c))\n    \n# 2:Y座標でソート,0:action_typeでソート\nfrom operator import itemgetter\naction.sort(key=itemgetter(2,0))\nret = 0\nvertical_line = segmentTree(len(x_set))\nsegment_no = delay_force_union_find(len(x_set))\nfor action_type,x1,y1,x2 in action:\n    if action_type == VERTICAL_LINE_TOP:\n        vertical_line.add(x1)\n        left_line = vertical_line.lower_bound(x1)\n        segment_no.union(left_line,x1)\n    elif action_type == HORIZONTAL_LINE:\n        count = vertical_line.crossing(x1,x2 + 1)\n        if count < 2:\n            continue\n        ret += count - 1\n        segment_no.mark_delay(x1, x2)\n    else:\n        left_line = vertical_line.lower_bound(x1)\n        if segment_no.union(left_line,x1):\n            ret -= 1\n        vertical_line.delete(x1)\nprint(ret - 1)"
  },
  {
    "language": "Python",
    "code": "import math\nclass seg_tree:\n    def __init__(self, n):\n        self.depth = math.ceil(math.log(n, 2))\n        self.size = 1 << self.depth\n        self.bit = [0] * 2 * self.size\n        self.renew = [0] * 2 * self.size\n \n    def add(self, p, v):\n        p += self.size;\n        while p:\n            self.bit[p] += v\n            p >>= 1\n \n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        ret = 0\n \n        while l < r:\n            if l & 1:\n                ret += self.bit[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                ret += self.bit[r]\n            l >>= 1\n            r >>= 1\n        return ret\n \n    def set_renew(self, l, r):\n        l += self.size\n        r += self.size\n \n        while l < r:\n            if l & 1:\n                self.renew[l] = 1\n                l += 1\n            if r & 1:\n                r -= 1\n                self.renew[r] = 1\n            l >>= 1\n            r >>= 1\n \n    def is_renew(self, p):\n        p += self.size\n        while p:\n            if self.renew[p]:\n                return True\n            p >>= 1\n        return False\n \n    def unset_renew(self, p):\n        p += self.size\n        for i in range(self.depth - 1,0,-1):\n            if self.renew[p >> i]:\n                self.renew[p >> i] = 0\n                self.renew[(p>>i)*2] = self.renew[(p>>i)*2+1] = 1\n        self.renew[p] = 0\n    def get_lf(self, r):\n        l = self.size\n        r += self.size\n        while l < r:\n            if r & 1:\n                r -= 1\n                if self.bit[r]:\n                    while r < self.size:\n                        r <<= 1\n                        if self.bit[r + 1]:\n                            r += 1\n                    return r - self.size\n            if l & 1:\n                l += 1            \n            l >>= 1\n            r >>= 1\n        return -1\nfrom collections import UserList\nclass union_find(UserList):\n    def __init__(self):\n        UserList.__init__(self)\n    def root(self, p):\n        if self.data[p] < 0:\n            return p\n        self.data[p] = self.root(self.data[p])\n        return self.data[p]\n    def join(self, p, q):\n        p, q = self.root(p), self.root(q)\n \n        if p == q:\n            return False\n        if self.data[p] < self.data[q]:\n            p, q = q, p\n        self.data[p], self.data[q] = self.data[q], p\n        return True\ndef bisect(a,v):\n    l, r = 0, len(a)\n    while l < r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\ndef adjust(seg, uf, target, p):\n    if seg.is_renew(p):\n        uf.append(-1)\n        seg.unset_renew(p)\n        target[p] = len(uf) - 1\nfrom operator import itemgetter\n@profile\ndef main(f):    \n    w,h,n = map(int,f.readline().split())\n    abcd = [list(map(int,line.split())) for line in f]\n \n    abcd.extend([[0,0,w,0],\n                 [0,0,0,h],\n                 [w,0,w,h],\n                 [0,h,w,h]])\n \n    xs = {x:i for i, x in enumerate(sorted(set([abcdi[0] for abcdi in abcd] +[abcdi[2] for abcdi in abcd] + [-1])))}\n    abcd =[(xs[a],b,xs[c],d) for a,b,c,d in abcd]\n \n    target = [-1] * n * 2\n    target[0] = 0\n    uf = union_find()\n    uf.append(-1)\n    seg = seg_tree(len(xs))\n    seg.add(0, 1) #\n \n    a = []\n    for x1,y1,x2,y2 in abcd:\n        if x1 == x2:\n            a.append((y1, 0, x1, -1))\n            a.append((y2, 2, x1, -1))\n        else:\n            a.append((y1, 1, x1, x2))\n    a.sort(key=itemgetter(0,1))\n    ret = 0\n    for _, act, left, right in a:\n        if act == 0:\n            lf = seg.get_lf(left)\n \n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            target[left] = target[lf]\n \n            seg.add(left, 1)\n        elif act == 1:\n            count = seg.query(left, right+1)\n            if count < 2:\n               continue\n            ret += count - 1;\n \n            seg.set_renew(left, seg.get_lf(right + 1))\n        elif act == 2:\n            lf = seg.get_lf(left)\n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            if uf.join(target[lf], target[left]):\n                ret -= 1\n            seg.add(left, -1)\n    print(ret)\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "import math\nclass seg_tree:\n    def __init__(self, n):\n        self.depth = math.ceil(math.log(n, 2))\n        self.size = 1 << self.depth\n        self.bit = [0] * 2 * self.size\n        self.renew = [0] * 2 * self.size\n \n    def add(self, p, v):\n        p += self.size;\n        while p:\n            self.bit[p] += v\n            p >>= 1\n \n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        ret = 0\n \n        while l < r:\n            if l & 1:\n                ret += self.bit[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                ret += self.bit[r]\n            l >>= 1\n            r >>= 1\n        return ret\n \n    def set_renew(self, l, r):\n        l += self.size\n        r += self.size\n \n        while l < r:\n            if l & 1:\n                self.renew[l] = 1\n                l += 1\n            if r & 1:\n                r -= 1\n                self.renew[r] = 1\n            l >>= 1\n            r >>= 1\n \n    def is_renew(self, p):\n        p += self.size\n        while p:\n            if self.renew[p]:\n                return True\n            p >>= 1\n        return False\n \n    def unset_renew(self, p):\n        p += self.size\n        for i in range(self.depth - 1,0,-1):\n            if self.renew[p >> i]:\n                self.renew[p >> i] = 0\n                self.renew[(p>>i)*2] = self.renew[(p>>i)*2+1] = 1\n        self.renew[p] = 0\n    def get_lf(self, r):\n        l = self.size\n        r += self.size\n        while l < r:\n            if r & 1:\n                r -= 1\n                if self.bit[r]:\n                    while r < self.size:\n                        r <<= 1\n                        if self.bit[r + 1]:\n                            r += 1\n                    return r - self.size\n            if l & 1:\n                l += 1            \n            l >>= 1\n            r >>= 1\n        return -1\nfrom collections import UserList\nclass union_find(UserList):\n    def __init__(self):\n        UserList.__init__(self)\n    def root(self, p):\n        if self.data[p] < 0:\n            return p\n        self.data[p] = self.root(self.data[p])\n        return self.data[p]\n    def join(self, p, q):\n        p, q = self.root(p), self.root(q)\n \n        if p == q:\n            return False\n        if self.data[p] < self.data[q]:\n            p, q = q, p\n        self.data[p], self.data[q] = self.data[q], p\n        return True\ndef bisect(a,v):\n    l, r = 0, len(a)\n    while l < r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\ndef adjust(seg, uf, target, p):\n    if seg.is_renew(p):\n        uf.append(-1)\n        seg.unset_renew(p)\n        target[p] = len(uf) - 1\nfrom operator import itemgetter\n#@profile\ndef main(f):    \n    w,h,n = map(int,f.readline().split())\n    abcd = [list(map(int,line.split())) for line in f]\n \n    abcd.extend([[0,0,w,0],\n                 [0,0,0,h],\n                 [w,0,w,h],\n                 [0,h,w,h]])\n \n    xs = {x:i for i, x in enumerate(sorted(set([abcdi[0] for abcdi in abcd] +[abcdi[2] for abcdi in abcd] + [-1])))}\n    abcd =[(xs[a],b,xs[c],d) for a,b,c,d in abcd]\n \n    target = [-1] * n * 2\n    target[0] = 0\n    uf = union_find()\n    uf.append(-1)\n    seg = seg_tree(len(xs))\n    seg.add(0, 1) #\n \n    a = []\n    for x1,y1,x2,y2 in abcd:\n        if x1 == x2:\n            a.append((y1, 0, x1, -1))\n            a.append((y2, 2, x1, -1))\n        else:\n            a.append((y1, 1, x1, x2))\n    a.sort(key=itemgetter(0,1))\n    ret = 0\n    for _, act, left, right in a:\n        if act == 0:\n            lf = seg.get_lf(left)\n \n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            target[left] = target[lf]\n \n            seg.add(left, 1)\n        elif act == 1:\n            count = seg.query(left, right+1)\n            if count < 2:\n               continue\n            ret += count - 1;\n \n            seg.set_renew(left, seg.get_lf(right + 1))\n        elif act == 2:\n            lf = seg.get_lf(left)\n            adjust(seg, uf, target, lf)\n            adjust(seg, uf, target, left)\n            if uf.join(target[lf], target[left]):\n                ret -= 1\n            seg.add(left, -1)\n    print(ret)\nimport sys\nf = sys.stdin\n\nmain(f)"
  }
]