[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\n\n#define MAX_PLAYERS 100\n#define MAX_FRAMES 10000\n\ntypedef struct {\n    int frame;\n    int jersey;\n    char team;\n    double x;\n    double y;\n} PlayerData;\n\ndouble euclidean_distance(double x1, double y1, double x2, double y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    PlayerData data[MAX_FRAMES];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c %lf %lf\", &data[i].frame, &data[i].jersey, &data[i].team, &data[i].x, &data[i].y);\n    }\n\n    double max_passes[2] = {-1, -1};\n    int min_times[2] = {INT_MAX, INT_MAX};\n\n    for (int team_idx = 0; team_idx < 2; team_idx++) {\n        char current_team = (team_idx == 0) ? 'A' : 'B';\n\n        for (int i = 0; i < N; i++) {\n            if (data[i].team != current_team) continue;\n\n            for (int j = i + 1; j < N; j++) {\n                if (data[j].team != current_team) continue;\n\n                double pass_distance = euclidean_distance(data[i].x, data[i].y, data[j].x, data[j].y);\n                int pass_time = abs(data[j].frame - data[i].frame);\n\n                if (pass_distance > max_passes[team_idx] || \n                    (pass_distance == max_passes[team_idx] && pass_time < min_times[team_idx])) {\n                    max_passes[team_idx] = pass_distance;\n                    min_times[team_idx] = pass_time;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < 2; i++) {\n        if (max_passes[i] == -1) {\n            printf(\"-1 -1\\n\");\n        } else {\n            printf(\"%.2lf %d\\n\", max_passes[i], min_times[i]);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int frame;\n    int jersey;\n    char team;\n    int x;\n    int y;\n} Record;\n\ndouble calculateDistance(int x1, int y1, int x2, int y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Record records[N];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c %d %d\", &records[i].frame, &records[i].jersey, &records[i].team, &records[i].x, &records[i].y);\n    }\n\n    double maxA_dist = -1;\n    int maxA_time = -1;\n\n    double maxB_dist = -1;\n    int maxB_time = -1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (records[i].team == records[j].team && records[i].jersey != records[j].jersey) {\n                double dist = calculateDistance(records[i].x, records[i].y, records[j].x, records[j].y);\n                int time = records[j].frame - records[i].frame;\n\n                if (records[i].team == 'A') {\n                    if (dist > maxA_dist || (dist == maxA_dist && time < maxA_time)) {\n                        maxA_dist = dist;\n                        maxA_time = time;\n                    }\n                } else if (records[i].team == 'B') {\n                    if (dist > maxB_dist || (dist == maxB_dist && time < maxB_time)) {\n                        maxB_dist = dist;\n                        maxB_time = time;\n                    }\n                }\n            }\n        }\n    }\n\n    if (maxA_dist == -1) {\n        printf(\"-1 -1\\n\");\n    } else {\n        printf(\"%.2f %d\\n\", maxA_dist, maxA_time);\n    }\n\n    if (maxB_dist == -1) {\n        printf(\"-1 -1\\n\");\n    } else {\n        printf(\"%.2f %d\\n\", maxB_dist, maxB_time);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Record {\n    int frame;\n    int jersey;\n    char team;\n    int x, y;\n};\n\ndouble calculateDistance(int x1, int y1, int x2, int y2) {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n}\n\nvoid solve() {\n    int N;\n    cin >> N;\n    vector<Record> records(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> records[i].frame >> records[i].jersey >> records[i].team >> records[i].x >> records[i].y;\n    }\n\n    map<char, vector<pair<double, int>>> teamPasses;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (records[i].team == records[j].team && records[i].jersey != records[j].jersey) {\n                bool isPass = true;\n                for (int k = i + 1; k < j; ++k) {\n                    if (records[k].team != records[i].team) {\n                        isPass = false;\n                        break;\n                    }\n                }\n                if (isPass) {\n                    double dist = calculateDistance(records[i].x, records[i].y, records[j].x, records[j].y);\n                    int time = records[j].frame - records[i].frame;\n                    teamPasses[records[i].team].emplace_back(dist, time);\n                }\n            }\n        }\n    }\n\n    for (char team : {'A', 'B'}) {\n        if (teamPasses.find(team) == teamPasses.end()) {\n            cout << -1 << \" \" << -1 << endl;\n            continue;\n        }\n        auto& passes = teamPasses[team];\n        double maxDist = 0;\n        int minTime = INT_MAX;\n        for (auto& pass : passes) {\n            if (pass.first > maxDist) {\n                maxDist = pass.first;\n                minTime = pass.second;\n            } else if (pass.first == maxDist && pass.second < minTime) {\n                minTime = pass.second;\n            }\n        }\n        cout << maxDist << \" \" << minTime << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SoccerPassAnalyzer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<Record> records = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            int frame = scanner.nextInt();\n            int jersey = scanner.nextInt();\n            String team = scanner.next();\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            records.add(new Record(frame, jersey, team, x, y));\n        }\n        \n        Map<String, List<Pass>> teamPasses = new HashMap<>();\n        teamPasses.put(\"A\", new ArrayList<>());\n        teamPasses.put(\"B\", new ArrayList<>());\n        \n        for (int i = 1; i < records.size(); i++) {\n            Record prev = records.get(i - 1);\n            Record curr = records.get(i);\n            if (prev.team.equals(curr.team) && prev.jersey != curr.jersey) {\n                double distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));\n                int time = curr.frame - prev.frame;\n                teamPasses.get(prev.team).add(new Pass(distance, time));\n            }\n        }\n        \n        processTeam(teamPasses.get(\"A\"));\n        processTeam(teamPasses.get(\"B\"));\n    }\n    \n    private static void processTeam(List<Pass> passes) {\n        if (passes.isEmpty()) {\n            System.out.println(\"-1 -1\");\n            return;\n        }\n        \n        double maxDistance = -1;\n        int minTime = Integer.MAX_VALUE;\n        \n        for (Pass pass : passes) {\n            if (pass.distance > maxDistance) {\n                maxDistance = pass.distance;\n                minTime = pass.time;\n            } else if (pass.distance == maxDistance && pass.time < minTime) {\n                minTime = pass.time;\n            }\n        }\n        \n        System.out.printf(\"%.6f %d\\n\", maxDistance, minTime);\n    }\n    \n    static class Record {\n        int frame;\n        int jersey;\n        String team;\n        double x;\n        double y;\n        \n        Record(int frame, int jersey, String team, double x, double y) {\n            this.frame = frame;\n            this.jersey = jersey;\n            this.team = team;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Pass {\n        double distance;\n        int time;\n        \n        Pass(double distance, int time) {\n            this.distance = distance;\n            this.time = time;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:53:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SoccerPassAnalysis {\n    static class Player {\n        int frame;\n        int jersey;\n        String team;\n        int x, y;\n\n        Player(int frame, int jersey, String team, int x, int y) {\n            this.frame = frame;\n            this.jersey = jersey;\n            this.team = team;\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static int[] findLongestPass(List<Player> players) {\n        Map<String, List<Player>> teamPlayers = new HashMap<>();\n        \n        for (Player p : players) {\n            teamPlayers.putIfAbsent(p.team, new ArrayList<>());\n            teamPlayers.get(p.team).add(p);\n        }\n\n        int[] result = {-1, -1};\n        double maxDistance = 0;\n\n        for (String team : teamPlayers.keySet()) {\n            List<Player> teamPlayerList = teamPlayers.get(team);\n            teamPlayerList.sort(Comparator.comparingInt(p -> p.frame));\n\n            for (int i = 0; i < teamPlayerList.size(); i++) {\n                for (int j = i + 1; j < teamPlayerList.size(); j++) {\n                    Player p1 = teamPlayerList.get(i);\n                    Player p2 = teamPlayerList.get(j);\n\n                    if (p1.jersey != p2.jersey) {\n                        double distance = Math.sqrt(\n                            Math.pow(p1.x - p2.x, 2) + \n                            Math.pow(p1.y - p2.y, 2)\n                        );\n\n                        int timeDiff = p2.frame - p1.frame;\n\n                        if (distance > maxDistance || \n                            (distance == maxDistance && timeDiff < result[1])) {\n                            maxDistance = distance;\n                            result[0] = (int) Math.round(distance);\n                            result[1] = timeDiff;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        \n        List<Player> players = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            int frame = scanner.nextInt();\n            int jersey = scanner.nextInt();\n            String team = scanner.next();\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            \n            players.add(new Player(frame, jersey, team, x, y));\n        }\n\n        int[] result = findLongestPass(players);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 21:53:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct PlayerData {\n    int frame;\n    int jerseyNumber;\n    char team;\n    int x, y;\n};\n\ndouble calculateDistance(int x1, int y1, int x2, int y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\n\npair<double, int> findLongestPass(const vector<PlayerData>& data, char teamToCheck) {\n    unordered_map<int, vector<PlayerData>> teamFrames;\n    for (const auto& entry : data) {\n        if (entry.team == teamToCheck) {\n            teamFrames[entry.jerseyNumber].push_back(entry);\n        }\n    }\n\n    double maxDistance = -1;\n    int minTimeDiff = INT_MAX;\n\n    for (const auto& playerA : teamFrames) {\n        for (const auto& playerB : teamFrames) {\n            if (playerA.first == playerB.first) continue;\n\n            for (size_t i = 0; i < playerA.second.size(); ++i) {\n                for (size_t j = 0; j < playerB.second.size(); ++j) {\n                    double distance = calculateDistance(\n                        playerA.second[i].x, playerA.second[i].y,\n                        playerB.second[j].x, playerB.second[j].y\n                    );\n                    int timeDiff = abs(playerA.second[i].frame - playerB.second[j].frame);\n\n                    if (distance > maxDistance || \n                        (distance == maxDistance && timeDiff < minTimeDiff)) {\n                        maxDistance = distance;\n                        minTimeDiff = timeDiff;\n                    }\n                }\n            }\n        }\n    }\n\n    return maxDistance == -1 ? make_pair(-1.0, -1) : make_pair(maxDistance, minTimeDiff);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<PlayerData> data(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> data[i].frame >> data[i].jerseyNumber >> data[i].team >> data[i].x >> data[i].y;\n    }\n\n    auto teamAPass = findLongestPass(data, 'A');\n    auto teamBPass = findLongestPass(data, 'B');\n\n    cout << teamAPass.first << \" \" << teamAPass.second << endl;\n    cout << teamBPass.first << \" \" << teamBPass.second << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef longest_pass(n, activities):\n    def calculate_distance(x1, y1, x2, y2):\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    teams = defaultdict(list)\n    \n    for entry in activities:\n        frame, player, team, x, y = entry\n        teams[team].append((frame, player, x, y))\n    \n    results = {}\n    \n    for team, actions in teams.items():\n        longest_dist = -1\n        shortest_time = sys.maxsize\n        action_len = len(actions)\n\n        for i in range(action_len):\n            for j in range(i + 1, action_len):\n                frame1, player1, x1, y1 = actions[i]\n                frame2, player2, x2, y2 = actions[j]\n                \n                if player1 != player2:\n                    curr_distance = calculate_distance(x1, y1, x2, y2)\n                    time_taken = frame2 - frame1\n                    \n                    if curr_distance > longest_dist or (curr_distance == longest_dist and time_taken < shortest_time):\n                        longest_dist = curr_distance\n                        shortest_time = time_taken\n        \n        if longest_dist != -1:\n            results[team] = (longest_dist, shortest_time)\n        else:\n            results[team] = (-1, -1)\n    \n    return results\n\n# Example input list\nn = 5\nactivities = [\n    (1, 10, 'A', 0, 0),\n    (2, 11, 'A', 1, 1),\n    (3, 10, 'A', 4, 5),\n    (4, 20, 'B', 2, 1),\n    (5, 20, 'B', 3, 3),\n]\n\nresult = longest_pass(n, activities)\nfor team in result:\n    print(f\"Team {team}: {result[team]}\")",
    "timestamp": "2025-08-13 07:54:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SoccerMatchAnalysis {\n\n    static class Frame {\n        int frameNumber;\n        int jerseyNumber;\n        String team;\n        double x, y;\n\n        Frame(int frameNumber, int jerseyNumber, String team, double x, double y) {\n            this.frameNumber = frameNumber;\n            this.jerseyNumber = jerseyNumber;\n            this.team = team;\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frame> frames = Arrays.asList(\n            // Add frames data here\n        );\n\n        Map<String, List<Frame>> teamFrames = new HashMap<>();\n        for (Frame frame : frames) {\n            teamFrames.computeIfAbsent(frame.team, k -> new ArrayList<>()).add(frame);\n        }\n\n        for (Map.Entry<String, List<Frame>> entry : teamFrames.entrySet()) {\n            String team = entry.getKey();\n            List<Frame> teamFrameList = entry.getValue();\n            double maxDistance = 0;\n            int shortestTime = Integer.MAX_VALUE;\n            for (int i = 0; i < teamFrameList.size() - 1; i++) {\n                Frame first = teamFrameList.get(i);\n                Frame second = teamFrameList.get(i + 1);\n                if (first.jerseyNumber != second.jerseyNumber) {\n                    double distance = Math.sqrt(Math.pow(second.x - first.x, 2) + Math.pow(second.y - first.y, 2));\n                    int time = second.frameNumber - first.frameNumber;\n                    if (distance > maxDistance || (distance == maxDistance && time < shortestTime)) {\n                        maxDistance = distance;\n                        shortestTime = time;\n                    }\n                }\n            }\n            if (maxDistance == 0) {\n                System.out.println(team + \": -1 -1\");\n            } else {\n                System.out.printf(\"%s: %.2f %d%n\", team, maxDistance, shortestTime);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 07:54:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    int frame;\n    int jersey;\n    char team;\n    double x, y;\n} Record;\n\ndouble euclidean_distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Record records[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d %c %lf %lf\", &records[i].frame, &records[i].jersey, &records[i].team, &records[i].x, &records[i].y);\n    }\n\n    double longestDistanceA = -1, longestDistanceB = -1;\n    int shortestTimeA = -1, shortestTimeB = -1;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (records[i].team == records[j].team && records[i].jersey == records[j].jersey) {\n                double distance = euclidean_distance(records[i].x, records[i].y, records[j].x, records[j].y);\n                int time = records[j].frame - records[i].frame;\n                \n                if (records[i].team == 'A') {\n                    if (distance > longestDistanceA || (distance == longestDistanceA && time < shortestTimeA)) {\n                        longestDistanceA = distance;\n                        shortestTimeA = time;\n                    }\n                } else if (records[i].team == 'B') {\n                    if (distance > longestDistanceB || (distance == longestDistanceB && time < shortestTimeB)) {\n                        longestDistanceB = distance;\n                        shortestTimeB = time;\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%lf %d\\n\", longestDistanceA, longestDistanceA != -1 ? shortestTimeA : -1);\n    printf(\"%lf %d\\n\", longestDistanceB, longestDistanceB != -1 ? shortestTimeB : -1);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:54:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef find_longest_pass(N, frames):\n    def euclidean_distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n    team_passes = {'A': [], 'B': []}\n\n    for team in ['A', 'B']:\n        player_positions = {}\n        last_possessor = None\n        pass_start = None\n\n        for frame, jersey, curr_team, x, y in sorted(frames, key=lambda f: f[0]):\n            if curr_team != team:\n                continue\n\n            if last_possessor is not None and last_possessor != jersey:\n                old_pos = player_positions[last_possessor]\n                curr_pos = (x, y)\n                dist = euclidean_distance(old_pos[0], old_pos[1], curr_pos[0], curr_pos[1])\n                time = frame - pass_start\n                team_passes[team].append((dist, time))\n\n            player_positions[jersey] = (x, y)\n            last_possessor = jersey\n            pass_start = frame\n\n    for team in ['A', 'B']:\n        if not team_passes[team]:\n            team_passes[team] = [(-1, -1)]\n\n    result = {}\n    for team in ['A', 'B']:\n        longest_pass = max(team_passes[team], key=lambda p: (p[0], -p[1]))\n        result[team] = longest_pass\n\n    return result\n\ndef main():\n    N = int(input())\n    frames = []\n    for _ in range(N):\n        frame, jersey, team, x, y = map(str.split)\n        frames.append((int(frame), int(jersey), team, float(x), float(y)))\n\n    result = find_longest_pass(N, frames)\n    for team in ['A', 'B']:\n        print(f\"{team}: {result[team][0]} {result[team][1]}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:54:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    \n    team_a_passes = []\n    team_b_passes = []\n    \n    # Store last known positions for each player\n    last_pos = {}\n    \n    for _ in range(N):\n        frame = int(input[ptr])\n        jersey = int(input[ptr+1])\n        team = input[ptr+2]\n        x = float(input[ptr+3])\n        y = float(input[ptr+4])\n        ptr +=5\n        \n        key = (team, jersey)\n        if key in last_pos:\n            last_frame, last_x, last_y = last_pos[key]\n            if last_frame != frame:\n                # Check if the ball was passed to another player\n                # Need to find if another player has this frame as their first appearance\n                pass_found = False\n                for other_key in last_pos:\n                    if other_key[0] == team and other_key != key:\n                        other_frame, other_x, other_y = last_pos[other_key]\n                        if other_frame == frame:\n                            # Pass detected\n                            distance = calculate_distance(last_x, last_y, other_x, other_y)\n                            time = frame - last_frame\n                            if team == 'A':\n                                team_a_passes.append((distance, time))\n                            else:\n                                team_b_passes.append((distance, time))\n                            pass_found = True\n                            break\n                if not pass_found:\n                    # Update current player's position\n                    last_pos[key] = (frame, x, y)\n            else:\n                # Same frame, update position\n                last_pos[key] = (frame, x, y)\n        else:\n            # First time seeing this player\n            last_pos[key] = (frame, x, y)\n    \n    def process_passes(passes):\n        if not passes:\n            return (-1, -1)\n        max_distance = -1\n        min_time = float('inf')\n        for distance, time in passes:\n            if distance > max_distance:\n                max_distance = distance\n                min_time = time\n            elif distance == max_distance:\n                if time < min_time:\n                    min_time = time\n        return (max_distance, min_time)\n    \n    a_dist, a_time = process_passes(team_a_passes)\n    b_dist, b_time = process_passes(team_b_passes)\n    \n    print(f\"{a_dist:.8f} {a_time}\" if a_dist != -1 else \"-1 -1\")\n    print(f\"{b_dist:.8f} {b_time}\" if b_dist != -1 else \"-1 -1\")\n\nsolve()",
    "timestamp": "2025-08-13 07:55:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n#include <iomanip>\n\nstruct Frame {\n    int frameNumber;\n    int jerseyNumber;\n    char team;\n    double x, y;\n};\n\ndouble calculateDistance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nstd::pair<double, int> findLongestPass(const std::vector<Frame>& frames, char team) {\n    std::unordered_map<int, std::pair<int, std::pair<double, double>>> positions; // jerseyNumber -> {frameNumber, {x, y}}\n    double maxDistance = -1.0;\n    int minTime = -1;\n\n    for (const auto& frame : frames) {\n        if (frame.team != team) continue;\n\n        if (positions.find(frame.jerseyNumber) != positions.end()) {\n            int prevFrame = positions[frame.jerseyNumber].first;\n            double prevX = positions[frame.jerseyNumber].second.first;\n            double prevY = positions[frame.jerseyNumber].second.second;\n            \n            double distance = calculateDistance(prevX, prevY, frame.x, frame.y);\n            int time = frame.frameNumber - prevFrame;\n            \n            if (distance > maxDistance || (distance == maxDistance && time < minTime)) {\n                maxDistance = distance;\n                minTime = time;\n            }\n        }\n\n        positions[frame.jerseyNumber] = {frame.frameNumber, {frame.x, frame.y}};\n    }\n\n    return {maxDistance, minTime};\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<Frame> frames(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> frames[i].frameNumber >> frames[i].jerseyNumber >> frames[i].team >> frames[i].x >> frames[i].y;\n    }\n\n    auto resultA = findLongestPass(frames, 'A');\n    auto resultB = findLongestPass(frames, 'B');\n\n    if (resultA.first == -1.0)\n        std::cout << \"-1 -1\\n\";\n    else\n        std::cout << std::fixed << std::setprecision(6) << resultA.first << \" \" << resultA.second << \"\\n\";\n\n    if (resultB.first == -1.0)\n        std::cout << \"-1 -1\\n\";\n    else\n        std::cout << std::fixed << std::setprecision(6) << resultB.first << \" \" << resultB.second << \"\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:41:36"
  }
]