[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n\nusing namespace std;\n\nint r[1001], w[1001];\nbool dp[1001] = { 0 };\n\nint w_book(int wait, int n, int r_max) {\n\tsort(r, r + n);\n\tsort(w, w + n);\n\tint i_max = 0;\n\tdp[0] = 1;\n\tint cnt = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = wait; j >= w[i]; j--) {\n\t\t\tdp[j] = dp[j - w[i]];\n\t\t\tif (dp[j]) {\n\t\t\t\tif (i_max < j) i_max = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn i_max;\n}\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\tint n;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tr[i] = 0;\n\t\t\tw[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\n\t\tint time = 0;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t}\n\t\tint r_max = 0;\n\t\tint r_total = 0, w_total = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (r_max < r[i]) r_max = r[i];\n\t\t\tr_total += r[i];\n\t\t\tw_total += w[i];\n\t\t}\n\t\tif (r_max <= r_total - r_max) time = r_total + w_total;\n\t\telse time = 2 * r_max + w_total - w_book(r_max - (r_total - r_max), n, r_max);\n\n\t\tcout << time << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N=1010;\n\nint N;\nint r[MAX_N],w[MAX_N];\n\nvoid solve(){\n    int maxr=0,sumr=0,sumw=0;\n    for (int i=0;i<N;++i){\n        maxr=max(maxr,r[i]);\n        sumr+=r[i]; sumw+=w[i];\n    }\n    if (maxr*2>sumr){\n        int rest=maxr*2-sumr;\n        vector<bool> dp(rest+1,false);\n        dp[0]=true;\n        for (int i=0;i<N;++i){\n            if (r[i]==maxr) continue;\n            for (int j=rest;j>=w[i];--j){\n                if (dp[j-w[i]]) dp[j]=true;\n            }\n        }\n        int maxw=0;\n        for (int j=0;j<=rest;++j) if (dp[j]) maxw=j;\n        cout << maxr*2+sumw-maxw << '\\n';\n    } else cout << sumr+sumw << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N,N){\n        for (int i=0;i<N;++i) cin >> r[i] >> w[i];\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n\tint r[1000],w[1000];\n\tint sum_r=0,sum_w=0,idx=0;\n    while(scanf(\"%d\",&n),n){\n \t\t\n\t\tsum_r=sum_w=idx=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&r[i],&w[i]);\n\t\t\tsum_r+=r[i];\n\t\t\tsum_w+=w[i];\n\t\t\tif(r[idx]<r[i]) idx=i;\n\t\t}\n \n\t\tint r0=r[idx],r=sum_r-r0;\n\t\tw[idx]=0;\n\n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*r0;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<=1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n \n            int opt=r0-r;\n\t\t\twhile(!dp[n][opt]) opt--;\n \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N;\nVI R, W;\n\nint solve() {\n    // ?????§r???idx\n    int max_r_i;\n    {\n        auto it = max_element(ALL(R));\n        max_r_i = it - R.begin();\n    }\n\n    // ?????§r????????????sum\n    int other_sum = accumulate(ALL(R), 0) - R[max_r_i];\n\n    // calc time\n    int r_time;\n    int w_time;\n    if (other_sum >= R[max_r_i]) {\n        r_time = other_sum + R[max_r_i];\n        w_time = accumulate(ALL(W), 0);\n    } else {\n        r_time = R[max_r_i] * 2;\n\n        int T = R[max_r_i] - other_sum;\n        VI dp(N + 1);\n        for (int i = 0; i < N; i++) {\n            if (i == max_r_i) {\n                dp[i + 1] = dp[i];\n            } else {\n                int t = dp[i] + W[i];\n                if (t <= T) {\n                    dp[i + 1] = max(dp[i + 1], t);\n                }\n            }\n        }\n\n        int t = *max_element(ALL(dp));\n\n        w_time = accumulate(ALL(W), 0) - t;\n    }\n\n    return r_time + w_time;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        R = VI(N);\n        W = VI(N);\n\n        rep(i, N) {\n            cin >> R[i] >> W[i];\n        }\n\n        cout << solve() << endl;\n    }\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N;\nint R[1010],W[1010];\nbool dp[1010][1010];\nint main(){\n    while(true){\n        cin >> N;\n        if(N==0) break;\n        int sumr = 0,sumw = 0,ma = 0,id = -1;\n        for(int i=1;i<=N;i++){\n            cin >> R[i] >> W[i];\n            sumr += R[i];\n            sumw += W[i];\n            if(ma<R[i]){\n                ma = R[i];\n                id = i;\n            }\n        }\n        if(2*ma<=sumr){\n            cout << sumr+sumw << endl;\n            continue;\n        }\n        for(int i=1;i<=N;i++) for(int j=0;j<=1000;j++) dp[i][j] = false;\n        dp[0][0] = true;\n        for(int i=1;i<=N;i++){\n            for(int j=0;j<=1000;j++){\n                dp[i][j] = (dp[i][j] | dp[i-1][j]);\n                if(i!=id) dp[i][min(j+W[i],1000)] = (dp[i][min(j+W[i],1000)] | dp[i-1][j]);\n            }\n        }\n        int ok_max = 0;\n        for(int j=0;j<=2*ma-sumr;j++) if(dp[N][j]) ok_max = j;\n        cout << max(sumr+sumw,2*ma+sumw-ok_max) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n;\nint r[1111],w[1111];\nint dp[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    int rs=0,ws=0;\n    rep(i,n){\n      cin>>r[i]>>w[i];\n      rs+=r[i]; ws+=w[i];\n    }\n    int midx=max_element(r,r+n)-r;\n    int mr=*max_element(r,r+n);\n    if(mr<=rs/2){\n      cout<<rs+ws<<endl;\n    }else{\n      int rest=mr*2-rs;\n      memset(dp,0,sizeof(dp));\n      dp[0]=1;\n      rep(i,n)for(int j=1000;j>=0;j--){\n        if(i==midx)continue;\n        if(dp[j]&&w[i]+j<=1000)dp[w[i]+j]=1;\n      }\n      int used=0;\n      rep(j,rest+1)if(dp[j])maxch(used,j);\n      cout<<mr*2+(ws-used)<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint n;\npair<int, int> data[N];\n\nint calc(int emp){\n  bool dp[N][N+1];\n  for(int i=0;i<=emp;i++) dp[0][i] = false;\n  dp[0][0] = true;\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=emp;j++){\n      dp[i+1][j] |= dp[i][j];\n      if(j+data[i].second <= emp) dp[i+1][j+data[i].second] |= dp[i][j];\n    }\n  }\n  int tmp = 0;\n  for(int i=0;i<=emp;i++) if(dp[n-1][i]) tmp = i;\n  int res = data[n-1].first * 2;\n  for(int i=0;i<n;i++) res += data[i].second;\n  return res - tmp;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      data[i] = make_pair(a, b);\n    }\n    sort(data, data+n);\n    int sum = 0;\n    for(int i=0;i<n-1;i++) sum += data[i].first;\n    int ans = 0;\n    if(sum >= data[n-1].first){\n      for(int i=0;i<n;i++) ans += data[i].first + data[i].second;\n    }else ans = calc(data[n-1].first - sum);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define all(a) (a).begin(),(a).end()\n\nint calcDP(const vector<int>& w, int width) {\n    int N = w.size();\n    vector<vector<bool>> dp(N + 1, vector<bool>(width + 1));\n    dp[0][0] = true;\n    int ma = 0;\n    rep(i, N) {\n        rep(j, width + 1) {\n            if (!dp[i][j]) continue;\n            dp[i + 1][j] = true;\n            if (j + w[i] <= width) {\n                dp[i + 1][j + w[i]] = true;\n            }\n        }\n    }\n    rep(j, width + 1) {\n        if (dp[N][j]) ma = max(ma, j);\n    }\n    return ma;\n}\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<int> r(N), w(N);\n        rep(i, N) cin >> r[i] >> w[i];\n        sort(all(r));\n        reverse(all(r));\n        sort(all(w));\n        reverse(all(w));\n\n        int sm_r = accumulate(all(r), 0);\n        int sm_w = accumulate(all(w), 0);\n        int Tr = max(sm_r, 2 * r[0]);\n        int Tw = sm_w;\n\n        if (2 * r[0] > sm_r) {\n            int width = 2 * r[0] - sm_r;\n            int ma_1 = calcDP(w, width);\n            w.erase(w.begin());\n            int ma_2 = calcDP(w, width);\n            Tw -= min(ma_1, ma_2);\n        }\n\n        cout << Tr + Tw << endl;\n\n        // int sm = 0;\n        // int j = 0;\n        // if (2 * r[0] > sm_r) {\n        //     int width = 2 * r[0] - sm_r;\n        //     cout << \"width = \" << width << endl;\n        //     while (sm < width && j < N) {\n        //         sm += w[j];\n        //         j++;\n        //     }\n        // }\n        //\n        // int Tw = max(sm_w - sm, 2 * w[j]);\n        //\n        // cout << Tr << \" \" << Tw << \" \" << j << \" \" << sm << endl;\n        //\n        // cout << Tr + Tw << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n#include<fstream>\n\n#define N 100//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[1000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif (dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\tif (!fin)cout << \"file read error!\" << endl;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tfin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfin >> rTime[i] >> wTime[i];\n//\t\t\tcout << rTime[i] << wTime[i] << endl;\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n//#include<fstream>\n\n#define N 1001//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ){\n\tbool dp[1000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\n\tfor (int i = 0; i <= n - 2; i++){//各wTimeごとに\n\t\tfor (int j = differ; j >= wTime[i]; j--){//wTime[i] < j < differ\n\t\t\tif (dp[j - wTime[i]]){\n\t\t\t\tdp[j] = true;//DP的な。\n\t\t\t\tif (time < j)time = j;//大きい方を選択\n\t\t\t}\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n/*\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\tif (!fin)cout << \"file read error!\" << endl;\n*/\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> rTime[i] >> wTime[i];\n//\t\t\tcout << rTime[i] << wTime[i] << endl;\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp[2] = { rTime[j], wTime[j] };\n\t\t\t\t\t\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\twTime[j] = wTime[j + 1];\n\n\t\t\t\t\trTime[j + 1] = tmp[0];\n\t\t\t\t\twTime[j + 1] = tmp[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n \n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n \n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n \n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n \n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n \n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n \n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n \n//alias\ntypedef long long LL;\ntypedef std::vector<bool> VB;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n \ntypedef std::vector< VB > VB2;\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n \ntypedef std::pair<int,int> PII;\n \nint N;\nstd::vector< PII > d(1000);\nVI2 dp(1003, VI(1003));\n \nint main() {\n    while(std::cin >> N, N != 0) {\n        REP(i, N) {\n            std::cin >> d[i].fst >> d[i].snd;\n        }\n        std::sort(d.begin(), d.begin() + N);\n \n        int sum = 0;\n        REP(i, N-1) {\n            //1~N-1までの和\n            sum += d[i].fst;\n        }\n        if(sum >= d[N-1].fst) {\n            int ans = 0;\n            REP(i, N) {\n                ans += (d[i].fst + d[i].snd);\n            }\n            std::cout  << ans << std::endl;\n        } else {\n            dp.assign(1003, VI(1003, 0));\n            dp[0][0] = 1;\n \n            int rem = d[N-1].fst - sum;\n            REP(i, N-1) {\n                REP(j, rem + 1) {\n                    dp[i+1][j] |= dp[i][j];\n                    dp[i+1][j + d[i].snd] |= dp[i][j];\n                }\n            }\n \n            int maxi = 0;\n            REP(i, rem + 1) {\n                if(dp[N-1][i]) {\n                    maxi = std::max(maxi, (int)i);\n                }\n            }\n \n            int t = rem - maxi;\n            REP(i, N) {\n                t += d[i].snd;\n            }\n            std::cout << d[N-1].fst + sum + t << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint r[1010], w[1010];\nint dp[1000010];\n\nint main(){\n    while(cin >> n && n){\n        int sum_r = 0, sum_w = 0, max_r = 0;\n        for(int i = 0; i < n; ++i){\n            cin >> r[i] >> w[i];\n            if(r[max_r] < r[i]){\n                max_r = i;\n            }\n            sum_r += r[i];\n            sum_w += w[i];\n        }\n\n        if(r[max_r] * 2 <= sum_r){\n            cout << sum_r + sum_w << endl;\n        } else {\n            swap(r[n-1], r[max_r]);\n            swap(w[n-1], w[max_r]);\n            int rem = r[n-1]*2 - sum_r;\n            for(int i = 0; i <= rem; ++i) dp[i] = false;\n            dp[0] = true;\n            for(int i = 0; i < n-1; ++i){\n                for(int j = rem; j >= w[i]; --j){\n                    dp[j] |= dp[j-w[i]];\n                }\n            }\n            int dead = -1;\n            for(int i = rem; i >= 0; --i){\n                if(dp[i]){\n                    dead = rem - i;\n                    break;\n                }\n            }\n            cout << sum_r + sum_w + dead << endl; \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\ntypedef long long LL;\nusing namespace std;\nconst int SIZE=1001;\nint r[2*SIZE],w[2*SIZE];\nbool DP[2*SIZE][2*SIZE];\nint N;\nint leastSpace(int n,int maximN){\n\tDP[0][0]=true;\n\tif(maximN) DP[0][w[0]]=true;\n\tint maxim=0;\n\tFOR(i,1,N){\n\t\tFOR(j,0,n+1){\n\t\t\tif(maximN!=i && j>=w[i])\n\t\t\t\tDP[i][j]=DP[i-1][j]|DP[i-1][j-w[i]];\n\t\t\telse DP[i][j]=DP[i-1][j];\n\t\t\tif(DP[i][j]) maxim=max(maxim,j);\n\t\t}\n\t}\n\treturn n-maxim;\n}\nint main() {\n\t\n\t\n\twhile(cin >> N && N){\n\t\tint sum=0,maxim=0,sumW=0,maximN=0;\n\t\tREP(i,N){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum+=r[i];\n\t\t\tmaxim=max(maxim,r[i]);\n\t\t\tif(r[i]==maxim) maximN=i;\n\t\t\tsumW+=w[i];\n\t\t}\n\t\tif(maxim*2<=sum){\n\t\t\tcout << sum+sumW << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint space=maxim*2-sum;\n\t\tcout << sum+sumW+leastSpace(space,maximN) << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint N;\n\nstruct Book {\n    int r,w;\n    Book() {}\n    Book(int r,int w) : r(r),w(w) {}\n    bool operator<(const Book& b) const {\n        return this->r < b.r;\n    }\n\n};\nint dp[1003][1003];\n\nvoid solve() {\n    rep(i,1003) rep(j,1003) dp[i][j] = 0;\n    vector<Book> book;\n    book.resize(N);\n\n    rep(i,N) {\n        int a,b;\n        cin>>a>>b;\n        book[i] = Book(a,b);\n    }\n    sort(book.begin(), book.end());\n    int sum = 0;\n    rep(i,N) if(i!=N-1) sum += book[i].r;\n    if(sum >= book[N-1].r) {\n        sum += book[N-1].r;\n        rep(i,N) sum += book[i].w;\n        cout<<sum<<endl;\n        return;\n    }\n    \n    // i番目までで,時間jにできるか\n    dp[0][0] = 1;\n    rep(i,N-1) {\n        rep(j,book[N-1].r-sum+1) {\n            //cout<<i+1<<\",\"<<j+book[i].w<<endl;\n            dp[i+1][j] |= dp[i][j];\n            dp[i+1][j+book[i].w] |= dp[i][j];\n        }\n    }\n    int maxi = 0;\n    rep(i,book[N-1].r-sum+1) {\n        if(dp[N-1][i]) maxi = max(maxi,i);\n    }\n    \n    int t = book[N-1].r - sum;\n    t -= maxi;\n    rep(i,N) t+=book[i].w;\n    cout<<book[N-1].r+sum+t<<endl;\n\n    \n\n}\n\nint main() {\n    while(cin>>N) {\n        if(N==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint r[1010], w[1010];\n\nint dp[1000010];\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    while(cin >> n && n){\n        int sum_r = 0, sum_w = 0, max_r = 0;\n        for(int i = 0; i < n; ++i){\n            cin >> r[i] >> w[i];\n            if(r[max_r] < r[i]){\n                max_r = i;\n            }\n            sum_r += r[i];\n            sum_w += w[i];\n        }\n        if(r[max_r] * 2 <= sum_r){\n            cout << sum_r + sum_w << endl;\n        } else {\n            swap(r[n-1], r[max_r]);\n            swap(w[n-1], w[max_r]);\n            int rem = r[n-1]*2 - sum_r;\n            fill(dp, dp+rem, false);\n            dp[0] = true; // mudanazikannni tsumekomi\n            for(int i = 0; i < n-1; ++i){\n                for(int j = rem; j >= w[i]; --j){\n                    dp[j] |= dp[j-w[i]];\n                }\n            }\n            int dead = -1;\n            for(int i = rem; i >= 0; --i){\n                if(dp[i]){\n                    dead = rem - i;\n                    break;\n                }\n            }\n            cout << sum_r + sum_w + dead << endl; \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<pair<int, int> > rw(n);\n\t\tint rsum=0, wsum=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint r,w;\n\t\t\tcin >> r >> w;\n\t\t\trsum += r;\n\t\t\twsum += w;\n\t\t\trw[i] = make_pair(r, w);\n\t\t}\n\t\tsort(rw.begin(), rw.end());\n\t\tif(2*rw[n-1].first > rsum){\n\t\t\tint t = 2*rw[n-1].first -rsum;\n\t\t\tvector<bool> dp(t+1, false);\n\t\t\tdp[0] = true;\n\t\t\tfor(int i=0; i<n-1; i++){\n\t\t\t\tfor(int j=t-1; j>=0; j--){\n\t\t\t\t\tif(dp[j] && j+rw[i].second <= t){\n\t\t\t\t\t\tdp[j+rw[i].second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint fill=0;\n\t\t\tfor(int i=0; i<=t; i++){\n\t\t\t\tif(dp[i]) fill=i;\n\t\t\t}\n\t\t\tcout << rsum + t + wsum -fill << endl;\n\t\t}else{\n\t\t\tcout << rsum +wsum << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint n;\nP book[1001];\n\nint solve(){\n  int sumf=0,sums=0;\n  for(int i=0;i<n;i++)sumf+=book[i].f,sums+=book[i].s;\n\n  int d=max(0,2*book[0].f-sumf),dp[3000]={1};\n  for(int i=1;i<n;i++)\n    for(int j=d-book[i].s;j>=0;j--) dp[j+book[i].s]|=dp[j];\n\n  int cnt=0;\n  while(!dp[d--])cnt++;\n  return sumf+sums+cnt;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>book[i].f>>book[i].s;\n    sort(book,book+n,greater<P>());\n    cout <<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\ntypedef pair<int, int> PII;\nint main(){\n  int N;\n  while(true){\n    cin >> N;\n    if(N == 0){\n      break;\n    }\n    vector<PII> rw(N);\n    for(int i = 0; i < N; ++i){\n      cin >> rw[i].first >> rw[i].second;\n    }\n    sort(rw.begin(), rw.end(), greater<PII>());\n    int p_s = 0;\n    for(int i = 1; i < N; ++i){\n      p_s += rw[i].first;\n    }\n    int r_time = 0, w_time = 0;\n    if(p_s > rw[0].first){      \n      r_time = rw[0].first + p_s;\n      for(int i = 0; i < N; ++i){\n\tw_time += rw[i].second;\n      }\n    }\n    else{\n      r_time = rw[0].first * 2;\n      int rem = rw[0].first - p_s;\n      bool table[rem+1];\n      fill_n(table, rem+1, false);\n      table[0] = true;\n      int max_w = 0;\n      for(int i = 1; i < N; ++i){\n\t  int w = rw[i].second;\n\t  for(int j = rem; j >= w; --j){\n\t    if(table[j-w]){\n\t      table[j] = true;\t    \n\t      max_w = max(max_w, j);\n\t  }\n\t}\n      }\n      w_time = 0;\n      for(int i = 0; i < N; ++i){\n\tw_time += rw[i].second;\n      }\n      w_time -= max_w;\n    }    \n    cout << r_time + w_time << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[3][1000];\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[1][0],false);\n            dp[0][0]=true;\n\t\t\tint cur=0,next=1;\n            for(int i=0;i<n;i++){\n\t\t\t\tfill(&dp[next][0],&dp[next+1][0],false);\n                for(int j=0;j<1000;j++){\n                    if(dp[cur][j]){\n                        dp[next][j]=true; \n                        if(j+w[i]<1000)\n                            dp[next][j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!dp[cur][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\ntypedef long long LL;\nusing namespace std;\nconst int SIZE=1001;\nint r[2*SIZE],w[2*SIZE];\nbool DP[2*SIZE][2*SIZE];\nint N;\nint leastSpace(int n,int maximN){\n\tDP[0][0]=true;\n\tif(maximN) DP[0][w[0]]=true;\n\tint maxim=0;\n\tFOR(i,1,N){\n\t\tFOR(j,0,n+1){\n\t\t\tif(maximN!=i && j>=w[i])\n\t\t\t\tDP[i][j]=DP[i-1][j]|DP[i-1][j-w[i]];\n\t\t\telse DP[i][j]=DP[i-1][j];\n\t\t\tif(DP[i][j]) maxim=max(maxim,j);\n\t\t}\n\t}\n\treturn n-maxim;\n}\nint main() {\n\t\n\t\n\twhile(cin >> N && N){\n\t\tREP(i,SIZE*2){\n\t\t\tr[i]=w[i]=0;\n\t\t}\n\t\tREP(i,SIZE)\n\t\t\tREP(j,SIZE)\n\t\t\t\tDP[i][j]=0;\n\t\tint sum=0,maxim=0,sumW=0,maximN=0;\n\t\tREP(i,N){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum+=r[i];\n\t\t\tmaxim=max(maxim,r[i]);\n\t\t\tif(r[i]==maxim) maximN=i;\n\t\t\tsumW+=w[i];\n\t\t}\n\t\tif(maxim*2<=sum){\n\t\t\tcout << sum+sumW << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint space=maxim*2-sum;\n\t\tcout << sum+sumW+leastSpace(space,maximN) << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N)\n    {\n        vector<P> p(N + 1);\n        vector<int> rsum(N + 1, 0), wsum(N + 1, 0);\n        for (int i = 1; i <= N; i++)\n        {\n            int r, w;\n            cin >> r >> w;\n            p[i] = P(r, w);\n        }\n        sort(p.begin(), p.end());\n        for (int i = 1; i <= N; i++)\n        {\n            rsum[i] = rsum[i - 1] + p[i].first;\n            wsum[i] = wsum[i - 1] + p[i].second;\n        }\n        if (2 * p[N].first > rsum[N])\n        {\n            // dp[i][j] := i 冊目まででwrite に T 使えるか\n            int wmax = p[N].first;\n            vector<vector<bool>> dp(N + 1, vector<bool>(wmax + 1, false));\n            dp[0][0] = true;\n            for (int i = 1; i < N; i++)\n            {\n                int w = p[i].second;\n                for (int j = 0; j <= wmax; j++)\n                {\n                    dp[i][j] = dp[i - 1][j];\n                    if (j >= w)\n                    {\n                        dp[i][j] = dp[i][j] | dp[i - 1][j - w];\n                    }\n                }\n            }\n            int ma = -1;\n            for (int j = 0; j <= wmax - rsum[N - 1]; j++)\n            {\n                if (dp[N - 1][j])\n                    ma = max(ma, j);\n            }\n            cout << 2 * wmax + (wsum[N] - ma) << endl;\n        }\n        else\n        {\n            cout << rsum[N] + wsum[N] << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n\n#define N 1001//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ){\n\tbool dp[1001] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\n\tfor (int i = 0; i <= n - 2; i++){//各wTimeごとに\n\t\tfor (int j = differ; j >= wTime[i]; j--){//wTime[i] < j < differ\n\t\t\tif (dp[j - wTime[i]]){\n\t\t\t\tdp[j] = true;//DP的な。\n\t\t\t\tif (time < j)time = j;//大きい方を選択\n\t\t\t}\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> rTime[i] >> wTime[i];\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp[2] = { rTime[j], wTime[j] };\n\t\t\t\t\t\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\twTime[j] = wTime[j + 1];\n\n\t\t\t\t\trTime[j + 1] = tmp[0];\n\t\t\t\t\twTime[j + 1] = tmp[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint sum=0, mi=0, ans=0, r[1005], w[1005];\n\n\t\trep(i,N){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tif( r[i] > r[mi] ) mi = i;\n\t\t\tsum += r[i];\n\t\t\tans += r[i] + w[i];\n\t\t}\n\n\t\tint dp[2005]={};\n\t\tdp[0] = true;\n\t\trep(i,N) if(i!=mi) for(int j=1000; j>=0; j--) dp[ j+w[i] ] |= dp[j];\n\n\t\tint tmp = max(0, 2*r[mi] - sum);\n\t\tfor(int i=0; !dp[tmp-i]; i++) ans++;\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tint sumr=0,sumw=0;\n\t\tvector<pair<int,int> >a;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;cin>>x>>y;\n\t\t\ta.push_back(make_pair(x,y));\n\t\t\tsumr+=x,sumw+=y;\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tif(sumr>=a[n-1].first*2)cout<<sumr+sumw<<endl;\n\t\telse\n\t\t{\n\t\t\tbool dp[1001]={};\n\t\t\tdp[0]=1;\n\t\t\tint ret=0;\n\t\t\tfor(int i=0;i<n-1;i++)\n\t\t\t{\n\t\t\t\tfor(int j=a[n-1].first*2-sumr;j>=a[i].second;j--)\n\t\t\t\t{\n\t\t\t\t\tdp[j]|=dp[j-a[i].second];\n\t\t\t\t\tif(dp[j])ret=max(ret,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<sumr+sumw+a[n-1].first*2-sumr-ret<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <cstring>\n#include <vector>\n\nint N;\n\nint R[1010], W[1010];\n\nint dp[2020];\nint main() {\n    for(;;) {\n        std::cin >> N;\n\n        if(N == 0) {\n            return 0;\n        }\n\n        int sum = 0;\n        for(int i = 0; i < N; ++i) {\n            std::cin >> R[i] >> W[i];\n\n            sum += R[i];\n        }\n\n        int overHalf = -1;\n        for(int i = 0; i < N; ++i) {\n            if(R[i] * 2 > sum) {\n                overHalf = i;\n                break;\n            }\n        }\n\n        if(overHalf == -1) {\n            for(int i = 0; i < N; ++i) {\n                sum += W[i];\n            }\n\n            std::cout << sum << std::endl;\n\n            continue;\n        }\n\n        int reading = R[overHalf] * 2;\n\n        memset(dp, 0, sizeof(dp));\n        dp[0] = 1;\n        for(int i = 0; i < N; ++i) {\n            if(i == overHalf)\n                continue;\n            for(int j = 2000; j >= 0; --j) {\n                if(W[i] + j <= 1500)\n                    dp[j + W[i]] = dp[j + W[i]] || dp[j];\n            }\n        }\n\n        int cut;\n        for(int i = R[overHalf] - (sum - R[overHalf]); i >= 0; --i) {\n            if(dp[i]) {\n                cut = i;\n                break;\n            }\n        }\n\n        int writing = 0;\n        for(int i = 0; i < N; ++i) {\n            writing += W[i];\n        }\n\n        std::cout << reading + (writing - cut) << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( sizeof(bool)*(r0-r+2) );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( sizeof(bool)*(r0-r+2) );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint n,mi;\nint r,w[1001];\nint dp[1001][1001];\n\nint rec(int i, int j){\n\tif(dp[i][j] >= 0) return dp[i][j];\n\tint res;\n\tif(i==n) res = 0;\n\telse if(j < w[i] || i==mi) res = rec(i+1, j);\n\telse res = max(rec(i+1, j), rec(i+1, j-w[i]) + w[i]);\n\treturn dp[i][j] = res;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> n, n){\n\t\tint sr=0,sw=0,mr=0;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> r >> w[i];\n\t\t\tsr += r;sw += w[i];\n\t\t\tif(mr<r){\n\t\t\t\tmr = max(mr, r);\n\t\t\t\tmi = i;\n\t\t\t}\n\t\t}\n\t\tif(sr-mr < mr){\n\t\t\tint blank = mr - (sr-mr);\n\t\t\tcout << mr*2 + sw - rec(0, blank) << endl;\n\t\t}else cout << sr + sw << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int> r(N);\n\t\tvector<int> w(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t}\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\tint mx = -1;\n\t\tint mxi = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsum += r[i];\n\t\t\tsum2 += w[i];\n\t\t\tif (mx < r[i]) {\n\t\t\t\tmx = r[i];\n\t\t\t\tmxi = i;\n\t\t\t}\n\t\t}\n\t\t//cerr << sum << \" \" << mxi << endl;\n\t\tif (mx * 2 > sum) {\n\t\t\tint t = mx - (sum - mx);\n\t\t\t//cerr << t << endl;\n\t\t\tint res;\n\t\t\tvector<int> X(t + 1, 0);\n\t\t\tX[0] = 1;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (mxi != i) {\n\t\t\t\t\tfor (int j = t - w[i]; j >= 0; j--) {\n\t\t\t\t\t\tif (X[j] == 1) {\n\t\t\t\t\t\t\tX[j + w[i]] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = t; i >= 0; i--) {\n\t\t\t\tif (X[i] == 1) {\n\t\t\t\t\t//cerr << i << endl;\n\t\t\t\t\tres = 2 * mx + sum2 - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << sum + sum2 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n\n\n#define N 1001//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[1000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif (dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> rTime[i] >> wTime[i];\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint r[1010], w[1010];\n\nint dp[1000010];\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    while(cin >> n && n){\n        int sum_r = 0, sum_w = 0, max_r = 0;\n        for(int i = 0; i < n; ++i){\n            cin >> r[i] >> w[i];\n            if(r[max_r] < r[i]){\n                max_r = i;\n            }\n            sum_r += r[i];\n            sum_w += w[i];\n        }\n        if(r[max_r] * 2 <= sum_r){\n            cout << sum_r + sum_w << endl;\n        } else {\n            swap(r[n-1], r[max_r]);\n            swap(w[n-1], w[max_r]);\n            int rem = r[n-1]*2 - sum_r;\n            fill(dp, dp+rem+10, 0);\n            dp[0] = true; // mudanazikannni tsumekomi\n            for(int i = 0; i < n-1; ++i){\n                for(int j = rem; j >= w[i]; --j){\n                    dp[j] |= dp[j-w[i]];\n                }\n            }\n            int dead = -1;\n            for(int i = rem; i >= 0; --i){\n                if(dp[i]){\n                    dead = rem - i;\n                    break;\n                }\n            }\n            cout << sum_r + sum_w + dead << endl; \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N;\nint r[1010],w[1010];\nint dp[1010][1010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>N && N){\n\t\trep(i,N)cin>>r[i]>>w[i];\n\t\tint sumr=accumulate(r,r+N,0);\n\t\tint sumw=accumulate(w,w+N,0);\n\t\tint maxr=*max_element(r,r+N);\n\t\tif(maxr <= sumr-maxr){\n\t\t\tcout<<sumr+sumw<<endl;\n\t\t}else{\n\t\t\tint gap=maxr-(sumr-maxr);\n\t\t\tint ng;\n\t\t\trep(i,N)if(r[i]==maxr)ng=i;\n\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\tdp[0][0]=1;\n\t\t\trep(i,N){\n\t\t\t\trep(j,gap+1)if(dp[i][j]){\n\t\t\t\t\tdp[i+1][j]=1;\n\t\t\t\t\tif(i!=ng && j+w[i]<=gap)dp[i+1][j+w[i]]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=gap;i>=0;i--)if(dp[N][i]){\n\t\t\t\tcout<<2*maxr+sumw-i<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = min(maxsum, N-as[i]);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nP v[1000];\n\nvoid solve(){\n  int sum = 0, ans;\n  int dp[1000][1000];\n  fill(dp[0],dp[1000],0);\n  sort(v,v+n);\n  for(int i=0;i<n-1;i++) sum += v[i].first;\n  ans = sum + v[n-1].first;\n  for(int i=0;i<n;i++) ans += v[i].second;\n\n  if(sum < v[n-1].first){\n    int sum2 = 0;\n    for(int i=0;i<n-1;i++){\n      sum2 += v[i].second;\n      for(int j=v[i].second; j<=v[n-1].first-sum; j++){\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j-v[i].second] + v[i].second);\n      }\n    }\n    ans += v[n-1].first - dp[n-1][v[n-1].first-sum] - sum;\n    //cout << v[n-1].first << ' ' << dp[n-1][v[n-1].first-sum] << endl;\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> v[i].first >> v[i].second;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( r0-r+2 );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( r0-r+2 );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  while(1){\n    int N, i, j;\n    scanf(\"%d\", &N);\n    if(N == 0){\n      return 0;\n    }\n    vector<pair<int, int>> rw(N);\n    int rsum = 0, wsum = 0;\n    for(i = 0; i < N; i++){\n      scanf(\"%d %d\", &rw[i].first, &rw[i].second);\n      rsum += rw[i].first;\n      wsum += rw[i].second;\n    }\n    sort(rw.begin(), rw.end());\n    if(rsum >= 2 * rw[N - 1].first){\n      printf(\"%d\\n\", rsum + wsum);\n      continue;\n    }\n    int d = rw[N - 1].first - (rsum - rw[N - 1].first);\n    vector<int> dp(d + 1, 0);\n    dp[0] = 1;\n    for(i = 0; i < N - 1; i++){\n      int w = rw[i].second;\n      for(j = d; j >= w; j--){\n        dp[j] |= dp[j - w];\n      }\n    }\n    int m = 0;\n    for(i = 0; i <= d; i++){\n      if(dp[i] == 1){\n        m = max(m, i);\n      }\n    }\n//    printf(\"(rsum, wsum) = (%d, %d)\\n\", rsum, wsum);\n//    printf(\"d = %d\\n\", d);\n//    printf(\"m = %d\\n\", m);\n    printf(\"%d\\n\", rsum + wsum + (d - m));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[2][1000]={};\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[2][0],false);\n            dp[0][0]=true;\n\t\t\tbool cur=0;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[cur][j]){\n                        dp[!cur][j]=true; \n                        if(j+w[i]<1000)\n                            dp[!cur][j+w[i]]=true; \n                    }\n                }\n\t\t\t\tcur=!cur;\n            }\n  \n            int opt=r0-r;\n            while(!dp[cur][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nclass Task{\n\tpublic:\n\tll r,w;\n\tTask(ll r,ll w):r(r),w(w){}\n\t bool operator < (Task const &_r ) const{\n\t \treturn  r<_r.r;\n\t }\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;cin >>N;\n\t\t\tif(N==0)return;\n\t\t\tvector<Task> ts;\n\t\t\tREP(i,N){\n\t\t\t\tll r,w;cin >> r >> w;\n\t\t\t\tts.push_back(Task(r,w));\n\t\t\t} \n\t\t\tsort(ALL(ts));\n\t\t\tll MR=0;REP(i,N)MR=max(MR,ts[i].r);\n\t\t\tll sum=0;REP(i,N)sum+=ts[i].r;\n\t\t\t\n\t\t\tll res;\n\t\t\tif(sum>=2*MR){\n\t\t\t\tres=sum;\n\t\t\t}else{\n\t\t\t\tres=2*MR;\n\t\t\t\tll space=2*MR-sum;\n\t\t\t\tvector<bool> dp(space+1);\n\t\t\t\tdp[0]=true;\n\t\t\t\tfor(int i=0;i<N-1;i++){\n\t\t\t\t\tfor(int d=space;d>=0;d--){\n\t\t\t\t\t\tif(dp[d] && ts[i].w+d<=space)dp[ts[i].w+d]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tll useM=0;for(int d=0;d<=space;d++)if(dp[d])useM=d;\n\t\t\t\tres-=useM;\n\t\t\t}\n\t\t\tREP(i,N) res+=ts[i].w;\n\n\t\t\tcout << res<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(3);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 1111;\n\n\nint n;\nvector<int> r;\nvector<int> w;\n\nint nupsuck(int t, vector<int>& w){\n\n\tint dp[N][N]={0};\n\n\tint ret = 0;\n\trep(i,w.size()){\n\t\trep(j,t){\n\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n\t\t\tdp[i+1][j+w[i]] = max(dp[i+1][j+w[i]], dp[i][j]+w[i]);\n\t\t}\n\t}\t\n\trep(i,w.size()+1){\n\t\trep(j,t+1)ret = max(ret, dp[i][j]);\n\t}\n\n\trep(i,w.size()+1){\n\t\trep(j,t+1){}\n\t}\n\n\treturn ret;\n}\n\n\nbool input(){\n\tcin>>n;\n\tif(n==0)return false;\n\n\tr.clear();w.clear();\n\n\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tr.push_back(a);\n\t\tw.push_back(b);\n\t}\n\n\treturn true;\n}\n\n\nint solve(){\n\tint wsum = 0, rsum =0;\n\tint len = 0;\n\tint lenx = 0;\n\trep(i,n){\n\t\twsum += w[i];\n\t\trsum += r[i];\n\t\tlen = max(len, r[i]);\n\t\tif(len==r[i])lenx = i;\n\t}\n\n\n\tif(len*2 > rsum){\n\t\tvector<int> w2 = w;\n\t\tw2.erase(w2.begin() + lenx);\n\t\tint np = nupsuck(len-(rsum-len), w2);\n\t\t//cout<<len<<\" \"<<wsum<<\" \"<<rsum<<\" \"<<np<<endl;\n\t\treturn 2*len + wsum - np;\n\t}\n\treturn rsum+wsum;\n}\n\n\nint main(){\n\n\twhile(input()){\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = min(maxsum, N-as[i]);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      //assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    //assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = min(maxsum, N-as[i]);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nbool dp[1001][1001];\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n;\n  while(cin>>n,n){\n    vector<pair<int,int> > v;\n    int sum=0,maxe=0;\n    int sumw=0;\n    int maxw=0;\n    vector<int> vv;\n    for(int i=0;i<n;i++){\n      int a,b;cin>>a>>b;\n      v.push_back({a,b});\n      vv.push_back(b);\n      sum+=a;\n      if(maxe<a){\n        maxe=a;\n        maxw=i;\n      }\n      sumw+=b;\n    }\n    if(maxe<=sum-maxe){\n      cout<<sum+sumw<<endl;\n    }else{\n      int ans=maxe*2+v[maxw].se;\n      int nokori=maxe-(sum-maxe);\n      vv.erase(vv.begin()+maxw);\n      sort(vv.begin(),vv.end());\n      int vvsum=0;\n      for(int i=0;i<(int)vv.size();i++)vvsum+=vv[i];\n      for(int i=0;i<=(int)vv.size();i++)for(int j=0;j<=nokori;j++)dp[i][j]=0;\n      dp[0][0]=1;\n      for(int i=0;i<(int)vv.size();i++){\n        for(int j=0;j<=nokori;j++){\n          if(dp[i][j]==0)continue;\n          if(j+vv[i]<=nokori){\n            dp[i+1][j+vv[i]]=1;\n          }\n          dp[i+1][j]=1;\n        }\n      }\n      for(int i=nokori;i>=0;i--){\n        if(dp[vv.size()][i]){\n          cout<<ans+vvsum-i<<endl;\n          break;\n        }\n      }\n    }\n  }  \n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \n\n \nint main(){\n \n\tint n; \n\twhile(scanf(\"%d\",&n),n){\n\n\t\tvector<pair<int,int> > rw(n);\n\t\tint sum_r=0,sum_w=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>rw[i].first>>rw[i].second;\n\t\t\tsum_r+=rw[i].first;\n\t\t\tsum_w+=rw[i].second;\n\t\t}\n\t\tsort(rw.begin(),rw.end(),greater< pair<int,int> >());\n\n\t\tint r0=rw[0].first;\n\t\tint r=sum_r-r0;\n\n\t\tif(r0 <= r){\n\t\t\tcout<<sum_r+sum_w<<endl;\n\t\t}else{\n\n\t\t\tint res=2*rw[0].first;\n\t\t\tvector<vector<bool> > dp(1001,vector<bool>(10000,false));\n\n\t\t\t//r0-r???w?????°??????\n\t\t\t//dp[pos][sum]\n\n\t\t\tdp[1][0]=true;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\tdp[i+1][j]=true; //??°?????????\n\t\t\t\t\t\tif(j+rw[i].second<=10000)\n\t\t\t\t\t\t\tdp[i+1][j+rw[i].second]=true; //??°??????\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint opt=0;\n\t\t\tfor(int i=1;i<=r0-r;i++){\n\t\t\t\tif(dp[n][i]) opt=i;\n\t\t\t}\n\n\t\t\tres+=sum_w-opt;\n\t\t\tcout<<res<<endl;\n\n\n\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\nint n;\nint dp[1001];\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<int> r(n),w(n);\n\t\tvector<pair<int,pair<int,int> > > p;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tp.push_back(make_pair(r[i],make_pair(w[i],i)));\n\t\t}\n\t\tsort(p.begin(),p.end());\n\t\tint sum=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tsum+=p[i].first;\n\t\t}\n\t\tif(sum>=p[n-1].first){\n\t\t\tsum+=p[n-1].first;\n\t\t\tint sumw=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsumw+=p[i].second.first;\n\t\t\t}\n\t\t\tcout << sum+ sumw << endl;\n\t\t}\n\t\telse{\n\t\t\tint dif=p[n-1].first-sum;\n\t\t\tfor(int i=0;i<1001;i++){\n\t\t\t\tdp[i]=0;\n\t\t\t}\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tint q=p[i].second.first;\n\t\t\t\tfor(int j=1000-q;j>=0;j--){\n\t\t\t\t\tif(dp[j]){\n\t\t\t\t\t\tdp[j+q]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint copy=-1;\n\t\t\tfor(int i=dif;i>=0;i--){\n\t\t\t\tif(dp[i]){\n\t\t\t\t\tcopy=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wait=dif-copy;\n\t\t\tsum+=p[n-1].first;\n\t\t\tint sumw=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsumw+=p[i].second.first;\n\t\t\t}\n\t\t\tcout << sumw+sum+wait << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<int> a,b;\n    a.resize(n);\n    b.resize(n);\n    REP(i,n) cin >> a[i] >> b[i];\n    int asum=0,amax=0,bsum=0;\n    REP(i,n){\n      asum+=a[i];\n      amax=max(amax,a[i]);\n      bsum+=b[i];\n    }\n    int dp[4096];\n    REP(i,2048) dp[i]=0;\n    dp[0]=1;\n    REP(i,n) for(int j=1000;j>=0;--j){\n      if(a[i]==amax) continue;\n      if(dp[j]){\n\tdp[j+a[i]]+=dp[j];\n\tdp[j+a[i]+b[i]]+=dp[j];\n      }\n    }\n    int answer=asum+bsum;\n    if(asum<amax*2){\n      for(int i=amax;dp[i]==0;--i) answer++;\n    }\n    cout << answer << endl;\n    \n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector <int> r, w;\n\t\tr = w = vector <int> (n);\n\t\tint sumR = 0, sumW = 0;\n\t\trep (i, n) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsumR += r[i];\n\t\t\tsumW += w[i];\n\t\t}\n\n\t\tvector <int> copyR = r;\n\t\tsort(r.begin(), r.end());\n\n\t\tif (sumR >= 2*r.back()) {\n\t\t\tcout << sumR + sumW << endl;\n\t\t} else {\n\t\t\tint gap = r.back() - (sumR - r.back());\n\t\t\tvector <vector <int>> dp(n, vector <int> (gap + 1, 0));\n\t\t\tdp[0][0] = true;\n\t\t\tw.erase(w.begin() + (find(copyR.begin(), copyR.end(), r.back())-copyR.begin()));\n\t\t\trange (i, 1, n) {\n\t\t\t\trep (j, gap + 1) {\n\t\t\t\t\tif (j - w[i - 1] < 0) continue;\n\t\t\t\t\tdp[i][j] |= dp[i - 1][j];\n\t\t\t\t\tdp[i][j] |= dp[i - 1][j - w[i-1]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint maxJ = 0;\n\t\t\trep (i, n) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n\t\t\tcout << 2*r.back() + sumW - maxJ << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n        dp[0][0] = true;\n        range (i, 1, n + 1) {\n            if (r.back() == copyR[i - 1]) {\n                dp[i]=dp[i-1];\n                continue;\n            }\n            for(int j=gap;j>=0;j--){\n                if (j - w[i - 1] < 0) continue;\n                dp[i][j] |= dp[i - 1][j - w[i - 1]];\n            }\n        }\n        int maxJ = 0;\n        rep (i, n + 1) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void){\n\tint n, r[1000], w[1000], maxel, sr, sw, i, j, dp[2500], max;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&r[i],&w[i]);\n\t\tif(!n) break;\n\t\tsr = 0;\n\t\tsw = 0;\n\t\tfor(i = 0,maxel = 0;i < n;i++){\n\t\t\tif(r[i] > r[maxel]) maxel = i;\n\t\t\tsr += r[i];\n\t\t\tsw += w[i];\n\t\t}\n\t\tif(2 * r[maxel] >= sr){\n\t\t\tif(r[maxel] <= (sr - r[maxel]) + (sw - w[maxel])){\n\t\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\t\tif(i != maxel){\n\t\t\t\t\t\tfor(j = 2 * r[maxel] - sr;j >= 0;j--){\n\t\t\t\t\t\t\tif(dp[j] && j + w[i] <= 2 * r[maxel] - sr){\n\t\t\t\t\t\t\t\tdp[j + w[i]] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(j = 2 * r[maxel] - sr;j >= 0;j--){\n\t\t\t\t\tif(dp[j]){\n\t\t\t\t\t\tmax = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",sr + sw + (2 * r[maxel] - sr - max));\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"%d\\n\",2 * r[maxel] + w[maxel]);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%d\\n\",sr + sw);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<bool> VB;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VB > VB2;\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\nint N;\nstd::vector< PII > d(1000);\nVI2 dp(1003, VI(1003));\n\nint main() {\n    while(std::cin >> N, N != 0) {\n        REP(i, N) {\n            std::cin >> d[i].fst >> d[i].snd;\n        }\n        std::sort(d.begin(), d.begin() + N);\n\n        int sum = 0;\n        REP(i, N-1) {\n            //1~N-1までの和\n            sum += d[i].fst;\n        }\n        if(sum >= d[N-1].fst) {\n            int ans = 0;\n            REP(i, N) {\n                ans += (d[i].fst + d[i].snd);\n            }\n            std::cout  << ans << std::endl;\n        } else {\n            REP(i, 1003) { \n                REP(j, 1003) { \n                    dp[i][j] = 0;\n                }\n            }\n            dp[0][0] = 1;\n\n            REP(i, N-1) {\n                REP(j, d[N-1].fst - sum + 1) {\n                    dp[i+1][j] |= dp[i][j];\n                    dp[i+1][j + d[i].snd] |= dp[i][j];\n                }\n            }\n\n            int maxi = 0;\n            REP(i, d[N-1].fst - sum + 1) {\n                if(dp[N-1][i]) {\n                    maxi = std::max(maxi, (int)i);\n                }\n            }\n\n            int t = d[N-1].fst - sum;\n            t -= maxi;\n\n            REP(i, N) {\n                t += d[i].snd;\n            }\n            std::cout << d[N-1].fst + sum + t << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nvector<bool> napsac(vector<pii> x, int m){\n\tvector<bool> ret(m+1,false);\n\tint sz = x.size();\n\t// cout<<\"====\"<<endl;\n\t// rep(i,sz) cout<<i<<\" \"<<x[i].se<<endl;\n\t// cout<<\"====\"<<endl;\n\tret[0] = true;\n\trep(i,sz){\n\t\tfor(int j=m;j>=0;j--){\n\t\t\tint w = j-x[i].se;\n\t\t\tif(0<=w && w<=m){\n\t\t\t\tif(ret[w]){\n\t\t\t\t\tret[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool comp(pii a,pii b){\n\tif(a.se > b.se){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tvector<pii> b(2100,mp(0,0));\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> b[i].fi >> b[i].se;\n\t\t}\n\t\tsort(rall(b));\n\n\t\tvector<pii> x;\n\t\tint xs=0;\n\t\tint kxs = 0;\n\n\t\tvector<pii> y;\n\t\tint ys=0;\n\t\tint kys = 0;\n\t\trep(i,n){\n\t\t\tif(xs > ys){\n\t\t\t\ty.pb(b[i]);\n\t\t\t\tys += b[i].fi;\n\t\t\t\tkys += b[i].se;\n\t\t\t}else{\n\t\t\t\tx.pb(b[i]);\n\t\t\t\txs += b[i].fi;\n\t\t\t\tkxs += b[i].se;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << \"@ : \" <<xs << \" \" << ys << endl;\n\t\t//rep(i,y.size()) cout<<i<<\" \"<<y[i].fi<<\" \"<<y[i].se<<endl;\n\t\t//msort(all(x),comp);\n\t\t//rep(i,x.size()) cout<<i<<\" \"<<x[i].fi<<\" \"<<x[i].se<<endl;\n\t\t//msort(all(y),comp);\n\n\t\trep(i,x.size()){\n\t\t\trep(j,x.size()){\n\t\t\t\tif(x[j].se > x[j+1].se) swap(x[j],x[j+1]);\n\t\t\t}\n\t\t}\n\t\trep(i,y.size()){\n\t\t\trep(j,y.size()-1){ \n\t\t\t\tif(y[j].se > y[j+1].se) swap(y[j],y[j+1]);\n\t\t\t}\n\t\t}\n\t\t \n\t\t//cout<<\"# \"<<kxs<<\" \"<<kys<<endl;\n\t\t\n\t\tint res;\n\t\tvector<bool> nap;\n\t\tint ans;\n\t\tint aida;\n\t\tif(xs > ys){\n\t\t\taida = xs-ys;\n\t\t\tnap = napsac(y,aida);\n\t\t\t//cout<<\"# xs : \"<<xs<<\" \"<<kys<<endl;\n\t\t}else{\n\t\t\taida = ys-xs;\n\t\t\tnap = napsac(x,aida);\n\t\t\t//ans = ys + kxs;\n\t\t}\n\n\t\t// cout<<\"-----\"<<endl;\n\t\t// rep(i,aida+1){\n\t\t// \tcout<<i<<\" \"<<nap[i]<<endl;\n\t\t// }\n\t\t// cout<<\"-----\"<<endl;\n\t\tint tar;\n\t\tfor(int i=aida;i>=0;i--){\n\t\t\tif(nap[i]) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = xs + ys + kxs + kys - tar + aida;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvi rs(n),ws(n);\n\t\trep(i,n) cin>>rs[i]>>ws[i];\n\t\t\n\t\trep(i,n) per(j,i) if(rs[j]<rs[j+1]){\n\t\t\tswap(rs[j],rs[j+1]);\n\t\t\tswap(ws[j],ws[j+1]);\n\t\t}\n\t\t\n\t\tint rsum=accumulate(all(rs),0),wsum=accumulate(all(ws),0);\n\t\tif(2*rs[0]<=rsum){\n\t\t\tcout<<rsum+wsum<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint gap=2*rs[0]-rsum;\n\t\tvi dp(gap+1); dp[0]=1;\n\t\trepi(i,1,n) peri(j,ws[i],gap+1)\n\t\t\tdp[j]|=dp[j-ws[i]];\n\t\tint overlap=-1;\n\t\trep(i,gap+1) if(dp[i]) overlap=i;\n\t\t\n\t\tcout<<rsum+wsum+gap-overlap<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\n// dp[i][t] := i?????????????????§?????????????????????????¨?t???????????¨????????????????????????????¨?\nint dp[2][1010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<PII> xs(N);\n\tREP(i,N) cin >> xs[i].FF >> xs[i].SS;\n\tSORT(xs);\n\n\tint mx = xs.back().FF;\n\tint sum = accumulate(ALL(xs), 0,\n\t\t\t\t\t\t [](int s, PII x){ return s+x.FF;}) - mx;\n\tif(sum >= mx){\n\t  cout << accumulate(ALL(xs), sum+mx,\n\t\t\t\t\t\t [](int s, PII x){ return s+x.SS;}) << endl;\n\t}\n\telse{\n\t  int crt = 0, nxt = 1;\n\t  dp[crt][0] = 0;\n\t  REP(i,N-1){\n\t\tfill(dp[nxt], dp[nxt]+1010, -INF);\n\t\tREP(t,mx+1){\n\t\t  int nxt_t = t + xs[i].FF;\n\t\t  if(nxt_t <= mx){\n\t\t\tdp[nxt][nxt_t] = max(dp[nxt][nxt_t], dp[crt][t]);\n\t\t\tnxt_t += xs[i].SS;\n\t\t\tif(nxt_t <= mx)\n\t\t\t  dp[nxt][nxt_t] = max(dp[nxt][nxt_t], dp[crt][t] + xs[i].SS);\n\t\t  }\n\t\t}\n\t\tswap(crt, nxt);\n\t  }\n\t  int tmp = 0;\n\t  REP(t,mx+1) tmp = max(tmp, dp[crt][t]);\n\t  int ans = accumulate(ALL(xs), -tmp, [](int s, PII x){return s+x.SS;});\n\t  cout << ans + 2*mx << endl;\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n        dp[0][0] = true;\n        range (i, 1, n + 1) {\n            dp[i]=dp[i-1];\n            if (r.back() == copyR[i - 1]) {\n                continue;\n            }\n            rep (j, gap + 1) {\n                if (j - w[i - 1] < 0) continue;\n                dp[i][j] |= dp[i - 1][j - w[i - 1]];\n            }\n        }\n//      cout << endl;\n        int maxJ = 0;\n        rep (i, n + 1) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[2][1000]={};\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[2][0],false);\n            dp[0][0]=true;\n\t\t\tbool cur=0;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[cur][j]){\n                        dp[!cur][j]=true; \n                        if(j+w[i]<1000)\n                            dp[!cur][j+w[i]]=true; \n                    }\n                }\n\t\t\t\tcur=!cur;\n            }\n  \n            int opt=r0-r;\n            while(!dp[cur][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n) break;\n    vector<pair<int,int>> b;\n    REP(i,n) {\n      int r,w;\n      cin>>r>>w;\n      b.emplace_back(r,w);\n    }\n    sort(b.rbegin(),b.rend());\n    int sum = 0;\n    REP(i,n) sum += b[i].first;\n    int sumw = 0;\n    REP(i,n) sumw += b[i].second;\n    int b0r = b[0].first;\n    if (b0r*2 > sum) {\n      int rem = b0r*2 - sum;\n      vector<vector<bool>> dp(n,vector<bool>(rem+1101,false));\n      dp[0][0] = true;\n      REP(i,n-1)\n        REP(j,rem+1) {\n          dp[i+1][j] = dp[i+1][j] || dp[i][j];\n          dp[i+1][j+b[i+1].second] = dp[i+1][j+b[i+1].second] || dp[i][j];\n        }\n      int mxb = 0;\n      REP(i,rem+1)\n        if (dp[n-1][i])\n          mxb = i;\n      //int rbmt = max(2 * b0r, b0r + mxb);\n      cout << b0r*2 + (sumw - mxb) << endl;\n    } else {\n      cout << (sum + sumw) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool dp[1001][1000]={};\n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n  \n            int opt=r0-r;\n            while(!dp[n][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvp a;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\ta=vp(n);\n\t\tint sum=0,M=0,wsum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint r,w;\n\t\t\tcin>>r>>w;\n\t\t\tsum+=r;\n\t\t\twsum+=w;\n\t\t\tM=max(M,r);\n\t\t\ta[i]={r,w};\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tif(sum<2*M){\n\t\t\tint S=2*M-sum;\n\t\t\tvi dp(S+1);\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=S;j>=a[i].second;j--){\n\t\t\t\tdp[j]|=dp[j-a[i].second];\n\t\t\t}\n\t\t\tfor(int i=S;i>=0;i--) if(dp[i]){\n\t\t\t\tcout<<2*M+wsum-i<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse cout<<sum+wsum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include <functional>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef pair<int, int> p;\nconst int INF = 1e9;\n\nint dp[1001][1001];\n\nint main() {\n\tint n;\n\twhile (cin >> n && n) {\n\n\t\tvector<p> a(n);\n\t\trep(i, n) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tsort(all(a));\n\t\treverse(all(a));\n\n\t\tint sum = 0;\n\t\tfor (int i = 1; i < a.size(); i++) {\n\t\t\tsum += a[i].first;\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\tans += a[i].first + a[i].second;\n\t\t}\n\t\tif (sum >= a[0].first) {\n\t\t\tcout << ans << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, 1001)rep(j, 1001) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\n\t\tint l = a[0].first - sum;\n\t\tfunction<int(int, int)> solve = [&](int m, int re) {\n\t\t\tif (re < 0)return INF;\n\t\t\tif (dp[m][re] != -1)return dp[m][re];\n\t\t\tif (m == a.size()) {\n\t\t\t\treturn re;\n\t\t\t}\n\t\t\treturn dp[m][re] = min(solve(m + 1, re - a[m].second), solve(m + 1, re));\n\t\t};\n\t\tcout << ans + solve(1, l) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\ntypedef long long LL;\nusing namespace std;\nconst int SIZE=1001;\nint r[SIZE],w[SIZE];\nbool DP[2*SIZE][2*SIZE];\nint N;\nint leastSpace(int n,int maximN){\n\tDP[0][0]=true;\n\tif(maximN) DP[0][w[0]]=true;\n\tint maxim=0;\n\tFOR(i,1,N){\n\t\tFOR(j,w[i],n+1){\n\t\t\tif(maximN!=i)\n\t\t\t\tDP[i][j]=DP[i-1][j]|DP[i-1][j-w[i]];\n\t\t\tif(DP[i][j]) maxim=max(maxim,j);\n\t\t}\n\t}\n\treturn n-maxim;\n}\nint main() {\n\t\n\t\n\twhile(cin >> N && N){\n\t\tint sum=0,maxim=0,sumW=0,maximN=0;\n\t\tREP(i,N){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum+=r[i];\n\t\t\tmaxim=max(maxim,r[i]);\n\t\t\tif(r[i]==maxim) maximN=i;\n\t\t\tsumW+=w[i];\n\t\t}\n\t\tif(maxim*2<=sum){\n\t\t\tcout << sum+sumW << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint space=maxim*2-sum;\n\t\tcout << sum+sumW+leastSpace(space,maximN) << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[2][1000];\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[2][0],false);\n            dp[0][0]=true;\n\t\t\tint cur=0,next=1;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[cur][j]){\n                        dp[next][j]=true; \n                        if(j+w[i]<1000)\n                            dp[next][j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!dp[cur][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tvector<P> v;\n\t\tint ans=0, sum=0, mx=0;\n\t\tbool dp[1005][1005] = {0};\n\t\tdp[0][0] = true;\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tmx = max(mx, r);\n\t\t\tans += r + w;\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\t\tv.pop_back();\n\t\tif( 2*mx > sum ){\n\t\t\trep(t, v.size()) rep(k,2){\n\t\t\t\tint w = v[t].first + ( k ? 0 : v[t].second );\n\t\t\t\tfor(int j=1000; j>=0; j--){\n\t\t\t\t\tif( dp[t][j] && j+w <= 1000 ){\n\t\t\t\t\t\tdp[t+1][j+w] = true;\n\t\t\t\t\t}\n\t\t\t\t\tdp[t+1][j] |= dp[t][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//rep(i,10){\n\t\t\t//\tcout << i << \" \" << dp[v.size()][i] << endl;\n\t\t\t//}\n\t\t\t//int df = 2*mx - sum;\n\t\t\tint df = mx;\n\t\t\t//cout << \"hit\" << df << endl;\n\t\t\trep(i,df+1){\n\t\t\t\t//cout << df-i << endl;\n\t\t\t\tif( dp[ v.size() ][ df-i ] ){\n\t\t\t\t\tans += i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[2][1000];\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[1][0],false);\n            dp[0][0]=true;\n\t\t\tint cur=0,next=1;\n            for(int i=0;i<n;i++){\n\t\t\t\tfill(&dp[next][0],&dp[next+1][0],false);\n                for(int j=0;j<1000;j++){\n                    if(dp[cur][j]){\n                        dp[next][j]=true; \n                        if(j+w[i]<1000)\n                            dp[next][j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!dp[cur][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<string>\n\n#define reps(i,f,n) for(int i = f; i <= n; i++)\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\n\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    int r[1024];\n    int w[1024];\n    int dp[1024];\n    const int INF = -100000000;\n    int rsum = 0;\n    int wsum = 0;\n    int mx = -10000000;\n    int ind = -1;\n\n    rep(i,n){\n      cin >> r[i] >> w[i];\n      rsum += r[i];\n      wsum += w[i];\n      if( r[i] > mx){\n        ind = i;\n        mx = r[i];\n      }\n    }\n\n    rsum -= mx;\n\n    if(mx > rsum){\n      //length = mx*2\n      // pad = mx - rsum;\n      int pad = mx -rsum;\n      int dp[1024];\n      rep(i,1024) dp[i] = -INF;\n      dp[0] = 0;\n\n      rep(i,n){\n        if(ind != i){\n          for(int j = 1024; j >= 0; j--){\n            if(dp[j] != -INF && j + w[i] < 1024){\n              dp[j+w[i]] = 1;\n            }\n          }\n        }\n      }\n\n      for(int i = pad;i > 0; --i){\n        if(dp[i] != -INF){\n          wsum -= i;\n          break;\n        }\n      }\n      cout << 2 * mx + wsum << endl;\n    }else{\n      cout << rsum + wsum + mx << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n;\n  while(1){\n    cin>>n;\n    if(n==0) return 0;\n    int r[1001], w[1001];\n    int s=0, sw=0;\n    for(int i=0; i<n; i++){\n      cin>>r[i]>>w[i];\n      s+=r[i];\n      sw+=w[i];\n    }\n    if(n==1){\n      cout<<2*r[0]+w[0]<<endl;\n      continue;\n    }\n    int i0=max_element(r, r+n)-r;\n    if(2*r[i0]<=s){\n      cout<<s+sw<<endl;\n      continue;\n    }\n    bool dp[1010]={};\n    dp[0]=1;\n    for(int i=0; i<n; i++){\n      if(i==i0) continue;\n      for(int j=2*r[i0]-s; j>=w[i]; j--){\n        if(dp[j-w[i]]) dp[j]=1;\n      }\n    }\n    int d=0;\n    for(int j=2*r[i0]-s; j>=0; j--){\n      if(dp[j]){\n        d=j;\n        break;\n      }\n    }\n    cout<<2*r[i0]+sw-d<<endl;\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[1005][1005];\n\nint main(){\n    int n;\n    while(cin >> n, n != 0){\n        int sum = 0, maxi = 0, rsum = 0, wsum = 0;\n        vector<pair<int, int>> v;\n        for(int i=0;i<n;++i){\n            int r, w;\n            cin >> r >> w;\n            v.emplace_back(r, w);\n            sum += r;\n            rsum += r;\n            wsum += w;\n            maxi = max(maxi, r);\n        }\n        sum -= maxi;\n        if(sum >= maxi){\n            cout << rsum + wsum << endl;\n        }else{\n            for(int i=0;i<=1000;++i){\n                for(int j=0;j<=1000;++j){\n                    dp[i][j] = false;\n                }\n            }\n            dp[0][0] = true;\n\n            int diff = maxi - sum;\n            for(int i=1;i<=n;++i){\n                for(int j=0;j<=diff;++j){\n                    dp[i][j] |= dp[i-1][j];\n                    if(v[i-1].first == maxi || v[i-1].second > j)continue;\n                    dp[i][j] |= dp[i-1][j-v[i-1].second];\n                }\n            }\n\n            int t = 0;\n            for(int i=diff;i>=0;--i){\n                if(dp[n][i])break;\n                t++;\n            }\n\n            cout << rsum + wsum + t << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    //vector<int> r(n),w(n);\n    vector<pii> ps(n);\n    int sumr=0,sumw=0;\n    rep(i,0,n){\n        cin >> ps[i].first >> ps[i].second;\n        sumr+=ps[i].first;\n        sumw+=ps[i].second;\n    }\n\n    sort(ps.rbegin(),ps.rend());\n    if(ps[0].first<=sumr-ps[0].first){\n        cout << sumr+sumw << endl;\n        return;\n    }\n\n    const int t=ps[0].first*2-sumr;\n    vector<vector<bool>> dp(n+1,vector<bool>(t+1));\n    dp[1][0]=true;\n    if(ps[1].second<=t) dp[1][ps[1].second]=true;\n    rep(i,2,n){\n        rep(j,0,t+1){\n            if(dp[i-1][j]){\n                dp[i][j]=true;\n                continue;\n            }\n            if(j-ps[i].second<0) continue;\n            if(!dp[i-1][j-ps[i].second]) continue;\n            dp[i][j]=true;\n        }\n    }\n    int maxi=0;\n    rep(i,0,t+1) if(dp[n-1][i]) maxi=max(maxi,i);\n    cout << sumr+sumw+(t-maxi) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int N;\n  while(cin>>N,N) {\n    vector<int> r(N),w(N);\n    int maxi=0,rsum=0,wsum=0;\n    for(int i=0; i<N; i++) {\n      cin >> r[i] >> w[i];\n      maxi = ((r[i]>r[0])?i:0);\n      rsum += r[i];\n      wsum += w[i];\n    }\n    swap(r[0],r[maxi]);\n    swap(w[0],w[maxi]);\n    if(r[0]*2<=rsum){\n      cout << rsum+wsum << endl;\n    }else{\n      int ds = r[0]*2-rsum;\n      vector<vector<int> > dp(N, vector<int>(ds+1));\n      for(int s=0; s<=ds; s++)\n\tdp[0][s] = 0;\n      for(int n=0; n<N; n++)\n\tdp[n][0] = 0;\n      for(int n=1; n<N; n++)\n\tfor(int s=1; s<=ds; s++)\n\t  if (s<w[n]) {\n\t    dp[n][s] = dp[n-1][s];\n\t  } else {\n\t    dp[n][s] = max(dp[n-1][s],dp[n-1][s-w[n]]+w[n]);\n\t  }\n      cout << r[0]*2+wsum-dp[N-1][ds] << endl;;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( r0-r+2 );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( r0-r+2 );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint dp[1001][5001];\n\nint main(){\n\tint n,r,w[1000],maxr,sum,sumr,p;\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)break;\n\t\tsum = sumr = maxr = p = 0;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",&r,w+i);\n\t\t\tsum += r+w[i];\n\t\t\tsumr += r;\n\t\t\tif(maxr < r){\n\t\t\t\tp = i;\n\t\t\t\tmaxr = r;\n\t\t\t}\n\t\t}\n\t\tsumr -= maxr;\n\t\tif(maxr <= sumr){\n\t\t\tprintf(\"%d\\n\",sum);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n        sumr = maxr - sumr;\n\t\trep(i,n){\n\t\t\trep(j,sumr+1){\n\t\t\t\tif(j >= w[i] && i!=p)\n\t\t\t\t    dp[i+1][j] = max(dp[i][j],dp[i][j - w[i]]+w[i]);\n\t\t\t\telse dp[i+1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n(\"%d %d %d %d\\n\",sum, maxr, sumr);\n\t\tprintf(\"%d\\n\",sum + sumr - dp[n][sumr]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n#define endl '\\n'\n#define ALL(V) V.begin(),V.end()\n#define ALLR(V) V.rbegin(),V.rend()\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing PLL = pair<ll, ll>;\n\nbool solve() {\n    ll N;\n    cin >> N;\n    if(!N) return false;\n\n    V<PLL> books;\n    ll rsum = 0;\n    ll wsum = 0;\n    for(ll i = 0; i < N; i++) {\n        ll r, w;\n        cin >> r >> w;\n        rsum += r;\n        wsum += w;\n        books.emplace_back(r, w);\n    }\n\n    sort(ALLR(books));\n    ll max_r = books[0].first;\n\n    if(rsum - max_r >= max_r) {\n        cout << rsum + wsum << endl;\n        return true;\n    }\n\n    ll ans = rsum + wsum;\n    ll rest = max_r - (rsum - max_r);\n\n    const ll dp_size = 1001;\n    bool dp[dp_size][dp_size];\n    for(ll i = 0; i <= N; i++) for(ll j = 0; j <= rest; j++) dp[i][j] = false;\n    dp[0][0] = true;\n\n    for(ll i = 1; i < N; i++) {\n        for(ll j = 0; j <= rest; j++) {\n            if(!dp[i - 1][j]) continue;\n            dp[i][j] = true;\n            ll nxtj = j + books[i].second;\n            if(nxtj <= rest) dp[i][nxtj] = true;\n        }\n    }\n\n    ll maxv = 0;\n    for(ll i = rest; i >= 0; i--) if(dp[N - 1][i]) {\n        maxv = i;\n        break;\n    }\n\n    ans = max(ans, max_r + max_r + (wsum - maxv));\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    int r[1000], w[1000];\n    REP(i, N) cin >> r[i] >> w[i];\n    REP(i, N) FOR(j, i + 1, N) if(r[i] > r[j]) {\n      swap(r[i], r[j]);\n      swap(w[i], w[j]);\n    }\n    int sum = 0;\n    REP(i, N - 1) sum += r[i];\n    if(sum >= r[N - 1]){\n      REP(i, N) sum += w[i];\n      cout << sum + w[N - 1] << endl;\n    }else{\n      int rest = r[N - 1] - sum;\n      assert(rest > 0);\n      assert(rest <= 1000);\n      bool dp[1010] = {};\n      dp[0] = true;\n      for(int i = 0; i < N - 1; i++){\n        for(int j = rest; j - w[i] >= 0; j--){\n          dp[j] |= dp[j - w[i]];\n        }\n      }\n      int ans = 2 * r[N - 1];\n      int sum_w = 0;\n      REP(i, N) sum_w += w[i];\n      for(int i = rest; i >= 0; i--){\n        if(dp[i]){\n          ans += sum_w - i;\n          break;\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Book\n{\n  int read,write;\n  Book(int read=inf,int write=inf):read(read),write(write){}\n  bool operator < (const Book& a)const\n  {\n    if(read != a.read)return read < a.read;\n    return write < a.write;\n  }\n};\n\nint main()\n{\n  int N;\n  while(scanf(\"%d\",&N),N)\n    {\n      Book array[N];\n      int sum_r = 0;\n      int sum_w = 0;\n      rep(i,N)\n\t{\n\t  scanf(\"%d %d\",&array[i].read,&array[i].write);\n\t  sum_r += array[i].read;\n\t  sum_w += array[i].write;\n\t}\n\n      sort(array,array+N);\n\n      if(sum_r-array[N-1].read < array[N-1].read)\n\t{\n\t  int limit = array[N-1].read - (sum_r-array[N-1].read);\n\t  bool dp[limit+1];\n\t  rep(i,limit+1)dp[i] = false;\n\t  dp[0] = true;\n\t  int mex = 0;\n\t  rep(i,N-1)for(int j=limit;j>=0;j--)\n\t    {\n\t      if(!dp[j] || j+array[i].write > limit)continue;\n\t      dp[j+array[i].write] = true;\n\t      mex = max(mex,j+array[i].write);\n\t    }\n\t  printf(\"%d\\n\",sum_r+sum_w+(limit-mex));\n\t}\n      else\n\t{\n\t  printf(\"%d\\n\",sum_r+sum_w);\n\t}\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n;\nint r[1010];\nint w[1010];\n\nbool dp[1010][1010];\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,1010)rep(j,1010) dp[i][j]=false;\n\t\trep(i,n) cin >> r[i] >> w[i];\n\t\tint rmax=0,rother=0,rindex=-1;\n\t\trep(i,n){\n\t\t\tif(r[i] > rmax){\n\t\t\t\trmax=r[i];\n\t\t\t\trindex=i;\n\t\t\t}\n\t\t\trother+=r[i];\n\t\t}\n\t\trother-=rmax;\n\t\tint ans=0;\n\t\tif(rother>=rmax){\n\t\t\trep(i,n) ans+=r[i]+w[i];\n\t\t}else{\n\t\t\tint rem=rmax-rother;\n\t\t\tdp[0][0]=true;;\n\t\t\trep(i,n)rep(j,rem+1){\n\t\t\t\tif(dp[i][j]==false) \n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i+1][j]=true;\n\t\t\t\tif(i!=rindex&&j+w[i]<=rem)\n\t\t\t\t\tdp[i+1][j+w[i]]=true;\n\t\t\t}\n\t\t\tint wsum=0;\n\t\t\trep(i,n) wsum+=w[i];\n\n\t\t\tint res=0;\n\t\t\trep(i,rem+1){\n\t\t\t\tif(dp[n][i]) res=i;\n\t\t\t}\n\t\t\tans=2*rmax+(wsum-res);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N;\npii p[1010];\n\nint calc(vector<int> v, int w) {\n  vector<vector<int>> dp(1010,vector<int>(1010,0));\n  dp[0][0] = 1;\n  REP(i,v.size()) REP(j,1010) if (dp[i][j]) {\n    dp[i+1][j] |= dp[i][j];\n    if (j+v[i] <= w) dp[i+1][j+v[i]] |= dp[i][j];\n  }\n  int ans = 0;\n  REP(i,1010) if (dp[v.size()][i]) ans = i;\n  return ans;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N, N) {\n    REP(i,N) cin >> p[i].first >> p[i].second;\n    sort(p,p+N);\n    int sum = 0;\n    REP(i,N-1) sum += p[i].first;\n    int sumw = 0;\n    REP(i,N) sumw += p[i].second;\n    if (sum >= p[N-1].first) {\n      cout << sum + p[N-1].first + sumw << endl;\n    } else {\n      vector<int> v;\n      REP(i,N-1) v.push_back(p[i].second);\n      cout << max(2*p[N-1].first+sumw-calc(v,p[N-1].first-sum),p[N-1].first+sum+sumw) << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  long long r, w;\n  bool operator<(const data &p) { return r > p.r; }\n};\n\nlong long n;\nvector<data> v;\nvector<vector<bool>> dp;\n\nlong long solve();\n\nint main() {\n  while(cin >> n, n) {\n    v.resize(n);\n    for(int i = 0; i < n; ++i) cin >> v[i].r >> v[i].w;\n    sort(v.begin(), v.end());\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long rsum = 0, wsum = 0, now = 0;\n  for(int i = 0; i < n; ++i) {\n    rsum += v[i].r;\n    wsum += v[i].w;\n  }\n  now = max(0LL, 2 * v[0].r - rsum);\n  dp.assign(n + 1, vector<bool>(now + 1, 0));\n  dp[1][0] = 1;\n  for(int i = 1; i < n; ++i)\n    for(int j = 0; j <= now; ++j) {\n      dp[i + 1][j] = dp[i][j];\n      if(j >= v[i].w && dp[i][j - v[i].w]) dp[i + 1][j] = 1;\n    }\n  for(int i = now; i >= 0; --i)\n    if(dp[n][i]) {\n      now -= i;\n      break;\n    }\n  return max(rsum + wsum, rsum + wsum + now);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define ROF(i,b,a) for(int i=(b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n#define SUPbl 1002\n#define SUPrt 1002\n#define SUPut 1002\n\n\nint bl;\nbool dp[SUPrt];\t//dp[t] = rs no bubun syuugou no wa de t ga tukureru ka\nint rs[SUPbl];\nint us[SUPbl];\nint sumr, sumu;\nint maxr, maxu;\nint T;\n\nint solve(){\n\tsumr=0; sumu=0; maxr=0; maxu=0;\n\tREP(bi,bl){ sumr+=rs[bi]; sumu+=us[bi]; maxr=max(maxr,rs[bi]); maxu=max(maxu,us[bi]);}\n\tT=maxr*2-sumr;\n\tif(T<=0){\n\t\treturn sumr+sumu;\n\t}else{\n\t\tFOR(t,0,T+1) dp[t]=false;\n\t\tdp[0]=true;\n\t\tFOR(bi,0,bl){\n\t\t\tif(rs[bi]==maxr) continue;\n\t\t\tROF(t,T+1,0){\n\t\t\t\tif(t>=us[bi]) dp[t] = dp[t] || dp[t-us[bi]];\n\t\t\t}\n\t\t}\n\t\tint t=T;\n\t\tfor(;t>=0;--t){\n\t\t\tif(dp[t]) break;\n\t\t}\n\t\treturn sumr+sumu+(T-t);\n\t}\n\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> bl;\t\t\tif(!bl) return 0;\n\t\tREP(bi,bl) cin>>rs[bi]>>us[bi];\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool cur[1000]={};\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool next[1001]={};\n                for(int j=0;j<1000;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<1000)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n#define whole(xs) xs.begin(), xs.end()\n\nint N;\nvector<int> r, w;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    r.resize(N); w.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> r[i] >> w[i];\n    }\n    return true;\n}\n\nint sum(const vector<int>& v) {\n    int ret = 0;\n    for (int i = 0; i < v.size(); i++) ret += v[i];\n    return ret;\n}\n\nint dfs(int y, int p) {\n    bool dp[y + 1]; memset(dp, 0, sizeof(dp));\n    dp[0] = true;\n    for (int i = 0; i <= y; i++) {\n        if (!dp[i]) continue;\n        for (int j = 0; j < w.size(); j++) {\n            if (j == p) continue;\n            if (i + w[j] > y) continue;\n            dp[i + w[j]] = true;\n        }\n    }\n    int ret = 0;\n    for (int i = 1; i <= y; i++) {\n        if (dp[i]) ret = max(ret, i);\n    }\n    return ret;\n}\n\nint main() {\n    while (input()) {\n        int mr = *max_element(whole(r));\n        int index = max_element(whole(r)) - r.begin();\n        int x = sum(r) - mr;\n        if (mr >= x) {\n            int y = mr - x;\n            cout << sum(r) + sum(w) + (y - dfs(y, index)) << endl;\n        } else {\n            cout << sum(r) + sum(w) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,length,maximum;\nbool check[1100];\n\nvoid func(){\n\n\tint read[N],write[N],read_sum = 0,write_sum = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&read[i],&write[i]);\n\t\tread_sum += read[i];\n\t\twrite_sum += write[i];\n\t}\n\n\tsort(read,read+N,greater<int>());\n\tsort(write,write+N,greater<int>());\n\n\tif(N > 1 && read[0] >= read_sum-read[0]){\n\n\t\tlength = read[0]-(read_sum-read[0]);\n\n\t\tif(write[N-1] <= length){\n\n\t\t\tcheck[0] = true;\n\t\t\tfor(int i = 1; i <= length; i++)check[i] = false;\n\t\t\tcheck[write[N-1]] = true;\n\t\t\tmaximum = write[N-1];\n\n\t\t\tfor(int i = N-2; i >= 1; i--){\n\t\t\t\tif(write[i] > length)break;\n\n\t\t\t\tfor(int k = length; k-write[i] >= 0; k--){\n\t\t\t\t\tif(check[k-write[i]] == true)check[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k = maximum + 1; k <= length; k++){\n\t\t\t\tif(check[k]){\n\t\t\t\t\tmaximum = k;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\t\t\tmaximum = 0;\n\t\t}\n\n\t\tprintf(\"%d\\n\",max(read_sum+write_sum,2*read[0]+write_sum-maximum));\n\n\t}else{\n\t\tif(N == 1){\n\t\t\tprintf(\"%d\\n\",2*read[0]+write[0]);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",read_sum+write_sum);\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( sizeof(bool)*(r0-r+2) );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( sizeof(bool)*(r0-r+2) );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\n\nstruct Book {\n\tint read, write;\n};\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<Book> books(n);\n\t\tfor (auto& book : books) std::cin >> book.read >> book.write;\n\t\tif (n == 1) {\n\t\t\tstd::cout << books.front().read * 2 + books.front().write << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tconst auto sum_length = std::accumulate(books.begin(), books.end(), 0, [](int acc, const Book& b) {return acc + b.read; });\n\t\tstd::sort(books.begin(), books.end(), [](const Book& a, const Book& b) {return a.read > b.read; });\n\t\tconst auto longest = books.front().read;\n\t\tif (sum_length >= longest * 2) {\n\t\t\tstd::cout << sum_length + std::accumulate(books.begin(), books.end(), 0, [](int acc, const Book& b) {return acc + b.write; }) << '\\n';\n\t\t}\n\t\telse {\n\t\t\tstd::sort(std::next(books.begin()), books.end(), [](const Book& a, const Book& b) {return a.write < b.write; });\n\t\t\tconst auto rest_time = longest * 2 - sum_length;\n\t\t\tauto write_time = std::accumulate(books.begin(), books.end(), 0, [](int acc, const Book& b) {return acc + b.write; });\n\t\t\tstd::vector<bool> can_make(rest_time + 1, false); can_make[0] = true;\n\t\t\tfor (auto i = 1; i < n; ++i) {\n\t\t\t\tfor (int j = rest_time; j >= books[i].write; --j) {\n\t\t\t\t\tcan_make[j] = can_make[j] || can_make[j - books[i].write];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto i = rest_time; i > 0; --i) {\n\t\t\t\tif (can_make[i]) {\n\t\t\t\t\twrite_time -= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::cout << longest * 2 + write_time << '\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define READ first\n#define WRITE second\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<pair<int, int> > book(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> book[i].READ >> book[i].WRITE;\n\n\t\tsort(book.begin(), book.end());\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n - 1; ++i)\n\t\t\tsum += book[i].READ;\n\n\t\tint ans = sum + book[n - 1].READ;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tans += book[i].WRITE;\n\n\t\tif(sum < book[n - 1].READ) {\n\t\t\tint rest = book[n - 1].READ - sum;\n\t\t\tvector<bool> dp(rest + 1, false);\n\t\t\tdp[rest] = true;\n\n\t\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\t\tfor(int j = book[i].WRITE; j <= rest; ++j) {\n\t\t\t\t\tif(dp[j])\n\t\t\t\t\t\tdp[j - book[i].WRITE] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i <= rest; ++i)\n\t\t\t\tif(dp[i]) {\n\t\t\t\t\tans += i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst int64_t LINF=8931145141919364364,LMOD=998244353;\n// const int dy[]={0,-1,0,1,1,-1,-1,1};\n// const int dx[]={1,0,-1,0,1,1,-1,-1};\n\nint main() {\n\tint n;\n\twhile(cin >> n and n > 0) {\n\t\tpair<int, int> book[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint r, w; cin >> r >> w;\n\t\t\tbook[i] = {r, w};\n\t\t}\n\t\tsort(book, book + n);\n\t\treverse(book, book + n);\n\t\tint readSum = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\treadSum += book[i].first;\n\t\t}\n\t\tif(book[0].first <= readSum - book[0].first) {\n\t\t\tint writeSum = 0;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\twriteSum += book[i].second;\n\t\t\t}\n\t\t\tcout << readSum + writeSum << endl;\n\t\t} else {\n\t\t\tint rest = book[0].first - (readSum - book[0].first);\n\t\t\t// iまでで時間jが可能か\n\t\t\tbool dp[n][rest + 1] = {};\n\t\t\tdp[0][0] = true;\n\t\t\tfor(int i = 1; i < n; ++i) {\n\t\t\t\tfor(int j = 0; j <= rest; ++j) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t\tif(j - book[i].second >= 0) dp[i][j] |= dp[i - 1][j - book[i].second];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint writeSum = 0;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\twriteSum += book[i].second;\n\t\t\t}\n\t\t\tfor(int j = rest; j >= 0; --j) {\n\t\t\t\tif(dp[n - 1][j]) {\n\t\t\t\t\twriteSum -= j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << book[0].first * 2 + writeSum << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp in(n);\n\t\trep(i,n)cin>>in[i].first>>in[i].second;\n\t\tsort(all(in));\n\t\tint sum1=0,sum2=0;\n\t\trep(i,n)sum1+=in[i].first,sum2+=in[i].second;\n\t\tif(sum1>=2*in[n-1].first)cout<<sum1+sum2<<endl;\n\t\telse{\n\t\t\tint m=2*in[n-1].first-sum1;\n\t\t\tvi dp(m+1);\n\t\t\tdp[0]=true;\n\t\t\trep(i,n-1)for(int j=m-in[i].second;j>=0;j--)if(dp[j])dp[j+in[i].second]=true;\n\t\t\tint ma=0;\n\t\t\trep(i,m+1)if(dp[i])ma=i;\n\t\t\tcout<<in[n-1].first*2+sum2-ma<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <complex>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <climits>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint sr = 0, sw = 0;\n\t\tvector<pii> v(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d\", &v[i].first, &v[i].second);\n\t\t\tsr += v[i].first;\n\t\t\tsw += v[i].second;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\t\n\t\tint ans = 0;\n\t\tint sl = v.back().first;\n\t\tint st = sr - sl;\n\n\t\tif(st >= sl){\n\t\t\tans = sr + sw;\n\t\t}\n\t\telse{\n\t\t\tint t = sl - st;\n\t\t\tvector<char> dp(t + 1);\n\t\t\tdp[0] = 1;\n\t\t\tfor(int i = 0; i < n - 1; ++i){\n\t\t\t\tfor(int j = t; j >= v[i].second; --j){\n\t\t\t\t\tdp[j] |= dp[j - v[i].second];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint u;\n\t\t\tfor(u = t; !dp[u]; --u);\n\t\t\tans = 2 * sl + sw - u;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\npair<int, int>x[1000]; int n, a, b, s1, s2, dp[1100000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; s1 = 0; s2 = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> a >> b; x[i] = make_pair(a, b); s1 += a; s2 += b; }\n\t\tsort(x, x + n);\n\t\tif (x[n - 1].first * 2 <= s1) { cout << s1 + s2 << endl; }\n\t\telse {\n\t\t\tfor (int i = 0; i <= s2; i++)dp[i] = 0; dp[0] = 1; queue<int>Q; Q.push(0);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvector<int>f;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\t\t\tif (dp[a1 + x[i].second] == 0) { f.push_back(a1 + x[i].second); dp[a1 + x[i].second] = 1; }\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < f.size(); i++)Q.push(f[i]);\n\t\t\t}\n\t\t\tint g = 0; for (int i = x[n - 1].first - (s1 - x[n - 1].first); i >= 0; i--) { if (dp[i] == 1) { g = i; break; } }\n\t\t\tcout << (x[n - 1].first - (s1 - x[n - 1].first) - g) + s1 + s2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n\tint r[1000],w[1000];\n\tint sum_r=0,sum_w=0,idx=0;\n    while(scanf(\"%d\",&n),n){\n \t\t\n\t\tsum_r=sum_w=idx=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&r[i],&w[i]);\n\t\t\tsum_r+=r[i];\n\t\t\tsum_w+=w[i];\n\t\t\tif(r[idx]<r[i]) idx=i;\n\t\t}\n \n\t\tint r0=r[idx],r=sum_r-r0;\n\t\tw[idx]=0;\n\n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*r0;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<=1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n \n            int opt=r0-r;\n\t\t\twhile(!dp[n][opt]) opt--;\n \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    vector<pair<int, int>> book(N);\n    int rsum = 0, wsum = 0;\n    for (auto& b : book) {\n        cin >> b.first >> b.second;\n        rsum += b.first;\n        wsum += b.second;\n    }\n    sort(book.rbegin(), book.rend());\n\n    int read = max(rsum, book[0].first * 2);\n    int rem = read - rsum;\n    if (rem > 0) {\n        bitset<2000> dp(1);\n        for (int i = 1; i < N; ++i) {\n            dp |= (dp << book[i].second);\n        }\n\n        for (int r = rem; r > 0; --r) {\n            if (dp[r]) {\n                wsum -= r;\n                break;\n            }\n        }\n    }\n\n    cout << read + wsum << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair< int, int > P;\ntypedef pair< int, P > PP;\n\nstruct edge {\n\tint from, to, cost;\n};\n\nint main() {\n\n\tint n, m;\n\n\twhile(true) {\n\n\t\tcin >> n >> m;\n\n\t\tif( !n && !m ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< vector< edge > > G(n + 1);\n\t\tvector< vector< int > > d(28, vector< int >(n, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint f, t, c;\n\t\t\tedge m;\n\t\t\tcin >> f >> t >> c;\n\n\t\t\tm.from = f;\n\t\t\tm.to = t;\n\t\t\tm.cost = c;\n\n\t\t\tG[f].push_back(m);\n\n\t\t\tm.from = t;\n\t\t\tm.to = f;\n\t\t\tm.cost = c;\n\n\t\t\tG[t].push_back(m);\n\t\t}\n\n\t\tpriority_queue<PP, vector< PP >, greater< PP > > que;\n\t\td[0][0] = 0;\n\t\tque.push(PP(0, P(0, 0)));\n\n\t\twhile( !que.empty() ) {\n\t\t\tPP p = que.top(); que.pop();\n\t\t\tint v = p.second.second;\n\t\t\tint a = p.second.first;\n\n\t\t\tif(d[a][v] < p.first) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(v == n - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\t\tedge e = G[v][i];\n\n\t\t\t\tif(d[(d[a][v] + e.cost) % 28][e.to] > d[a][v] + e.cost) {\n\t\t\t\t\td[(d[a][v] + e.cost) % 28][e.to] = d[a][v] + e.cost;\n\t\t\t\t\tque.push(PP(d[(d[a][v] + e.cost) % 28][e.to], P((d[a][v] + e.cost) % 28, e.to)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for(int i = 0; i < 28; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcout << d[i][j] << \"   \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\n\t\tint ans = INT_MAX - 1;\n\t\tfor(int i = 0; i < 28; i++) {\n\t\t\tif(i % 4 == 0 || i % 7 == 0) {\n\t\t\t\tans = min(ans, d[i][n - 1]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n//#include<fstream>\n\n#define N 1001//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ){\n\tbool dp[1000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\n\tfor (int i = 0; i < n - 2; i++){//各wTimeごとに\n\t\tfor (int j = differ; j >= wTime[i]; j--){//wTime[i] < j < differ\n\t\t\tif (dp[j - wTime[i]]){\n\t\t\t\tdp[j] = true;//DP的な。\n\t\t\t\tif (time < j)time = j;//大きい方を選択\n\t\t\t}\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n/*\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\tif (!fin)cout << \"file read error!\" << endl;\n*/\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> rTime[i] >> wTime[i];\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  map<pair<int, int>, int> mp;\n  vector<pair<int, ll>> vs;\n  rep(i, N) {\n    int x, y, w; cin >> x >> y >> w;\n    vs.emplace_back(x, y);\n    mp[{x, y}] += w;\n  }\n\n  ll ans = 0;\n\n  rep(i, vs.size()) {\n    int x = vs[i].first, y = vs[i].second;\n    maximize(ans, (ll)mp[{x, y}] + mp[{x + 1, y}] + mp[{x, y + 1}] + mp[{x + 1, y + 1}]);\n  }\n\n  cout << ans << \" / 1\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntemplate<typename T>\nusing vec = vector<T>;\n\nint N;\n\nvoid solve() {\n    vec<P> p(N);\n    for (auto &i : p) cin >> i.first >> i.second;\n    sort(p.begin(), p.end());\n    int sum = 0;\n    for (int i = 0; i < N - 1; i++) sum += p[i].first;\n    int sub = 0;\n    if (sum < p[N-1].first) sub = p[N-1].first - sum;\n\n    vector<map<int,bool> > dp(N);\n    dp[0][0] = true;\n    int m = 0;\n    for (int i = 0; i < N - 1; i++) {\n        for (auto x : dp[i]) {\n            if (x.first > sub) break;\n            m = max(x.first, m);\n            dp[i+1][x.first] = true;\n            if (x.first + p[i].second <= sub) dp[i+1][x.first + p[i].second] = true;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; i++) ans += p[i].first + p[i].second;\n\n    cout << ans + sub - m << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[1001][1000]={};\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[1001][0],false);\n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n  \n            int opt=r0-r;\n            while(!dp[n][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<pii> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tv.emplace_back(a, b);\n\t\t}\n\t\tsort(ALL(v));\n\t\tint sum = 0;\n\t\tREP(i, n - 1) sum += v[i].first;\n\t\tif (sum >= v.back().first)\n\t\t{\n\t\t\tsum += v.back().first;\n\t\t\tREP(i, n) sum += v[i].second;\n\t\t\tcout << sum << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint w = v.back().first - sum;\n\t\t\tvi t;\n\t\t\tREP(i, n - 1) t.push_back(v[i].second);\n\t\t\tvector<bool> dp(w + 1, false);\n\t\t\tdp[0] = true;\n\t\t\tint mx = -1;\n\t\t\tREP(i, n - 1)for (int j = w; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (dp[j] && j + t[i] <= w)\n\t\t\t\t{\n\t\t\t\t\tdp[j + t[i]] = true;\n\t\t\t\t\tchmax(mx, j + t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = v.back().first * 2;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tans += v[i].second;\n\t\t\t}\n\t\t\tans -= mx;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\n#define whole(x) begin(x), end(x)\nusing namespace std;\n\nint main() {\n    while (true) {\n        // input\n        int n; scanf(\"%d\", &n);\n        if (n == 0) break;\n        vector<pair<int, int> > books(n);\n        repeat (i, n) {\n            int r, w; scanf(\"%d%d\", &r, &w);\n            books[i] = { r, w };\n        }\n        // solve\n        sort(whole(books));\n        int max_r = books[n - 1].first;\n        int sum_r = 0, sum_w = 0;\n        for (auto book : books) {\n            sum_r += book.first;\n            sum_w += book.second;\n        }\n        int result;\n        if (2 * max_r > sum_r) {\n            int capacity = max_r - (sum_r - max_r);\n            vector<char> dp(capacity + 1);\n            dp[0] = true;\n            repeat (i, n - 1) {\n                int w = books[i].second;\n                repeat_reverse (j, capacity + 1 - w) if (dp[j]) {\n                    dp[j + w] = true;\n                }\n            }\n            int knapsack = 0;\n            repeat (j, capacity + 1) if (dp[j]) {\n                knapsack = j;\n            }\n            result = 2 * max_r + sum_w - knapsack;\n        } else {\n            result = sum_r + sum_w;\n        }\n        // output\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nint n;\nvector<int> r, w;\nint dp[1010][1010];\nint res_sum, full_time;\n\nint solve(int idx, int time) {\n  if (dp[idx][time] >=0) return dp[idx][time];\n\n  if (idx == 0) {\n    if (time >= w[idx]) {\n      return dp[idx][time] = w[idx];\n    } else {\n      return dp[idx][time] = 0;\n    }\n  }\n\n  if (time < w[idx]) {\n    return solve(idx-1, time);\n  }\n\n  return dp[idx][time] = max(\n      solve(idx-1, time),\n      solve(idx-1, time-w[idx]) + w[idx]\n      );\n}\n\nint main(){\n  while(1) {\n    cin >> n;\n    if (n==0) break;\n\n    r = vector<int>();\n    w = vector<int>();\n    REP(i, n) {\n      REP(j, 1001) {\n        dp[i][j] = -1;\n      }\n    }\n\n\n    REP(i, n) {\n      int ri, wi;\n      cin >> ri >> wi;\n      r.push_back(ri);\n      w.push_back(wi);\n    }\n\n    sort(r.begin(), r.end());\n    sort(w.begin(), w.end());\n\n    if (n==1) {\n      cout << r[0] * 2 + w[0] << endl;\n      continue;\n    }\n    \n    res_sum = 0;\n    REP(i, n-1) {\n      res_sum += r[i];\n    }\n\n    full_time = 0;\n    REP(i, n) {\n      full_time += r[i] + w[i];\n    }\n\n    if (res_sum >= r[n-1]) {\n      cout << full_time << endl;\n    } else {\n      int fill_gap = solve(n-2, r[n-1] - res_sum);\n#ifdef DEBUG\n      cout << r[n-1]-res_sum << \" \" << fill_gap << endl;\n#endif\n      cout << full_time + (r[n-1] - res_sum - fill_gap) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\tbool dp[1001][1000]={};\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tfill(&dp[0][0],&dp[1001][0],false);\n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n  \n            int opt=r0-r;\n            while(!dp[n][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nint main()\n{\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> r(n), w(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> r[i] >> w[i];\n        }\n\n        int rsum = accumulate(r.begin(), r.end(), 0);\n        int rmax = *max_element(r.begin(), r.end());\n        int wsum = accumulate(w.begin(), w.end(), 0);\n\n        if (rmax * 2 <= rsum) {\n            cout << rsum + wsum << endl;\n            continue;\n        }\n\n        int d = 2 * rmax - rsum;\n        vector<int> dp(d+1,0);\n        dp[0] = 1;\n        for (int i = 0; i < n; ++i) {\n            if (r[i] == rmax) continue;\n            for (int k = d-w[i]; k >= 0; --k) {\n                dp[k+w[i]] |= dp[k];\n            }\n        }\n\n        int dmax;\n        for (int k = d; k >= 0; --k) {\n            if (dp[k]) {\n                dmax = k;\n                break;\n            }\n        }\n\n        cout << 2 * rmax + wsum - dmax << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tpair<int,int> a[1000];\n\t\trep(i,n) scanf(\"%d%d\",&a[i].first,&a[i].second);\n\t\tsort(a,a+n,greater< pair<int,int> >());\n\n\t\tint r[1000],w[1000];\n\t\trep(i,n) r[i]=a[i].first, w[i]=a[i].second;\n\n\t\t// easy case\n\t\tif(r[0]<=accumulate(r+1,r+n,0)){\n\t\t\tprintf(\"%d\\n\",accumulate(r,r+n,0)+accumulate(w,w+n,0));\n\t\t}\n\t\t// hard case\n\t\telse{\n\t\t\tint d=r[0]-accumulate(r+1,r+n,0);\n\t\t\tbool dp[1001]={};\n\t\t\tdp[0]=true;\n\t\t\tfor(int i=1;i<n;i++) for(int j=d;j>=w[i];j--) dp[j]|=dp[j-w[i]];\n\t\t\tint j0;\n\t\t\tfor(j0=d;!dp[j0];j0--);\n\t\t\tprintf(\"%d\\n\",2*r[0]+accumulate(w,w+n,0)-j0);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( sizeof(bool)*(1000+2) );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( sizeof(bool)*(1000+2) );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n\n//alias\ntypedef std::vector<int>  VI;\ntypedef std::vector< VI > VI2;\ntypedef std::pair<int,int> PII;\n\nint N;\nstd::vector< PII > d(1000);\nVI2 dp(1003, VI(1003));\n\nint main() {\n    while(std::cin >> N, N != 0) {\n        REP(i, N) {\n            std::cin >> d[i].fst >> d[i].snd;\n        }\n        std::sort(d.begin(), d.begin() + N);\n\n        int sum = 0;\n        REP(i, N-1) {\n            sum += d[i].fst;\n        }\n        if(sum >= d[N-1].fst) {\n            int ans = 0;\n            REP(i, N) {\n                ans += (d[i].fst + d[i].snd);\n            }\n            std::cout  << ans << std::endl;\n        } else {\n            dp.assign(1003, VI(1003, 0));\n            dp[0][0] = 1;\n\n\n            int rem = d[N-1].fst - sum;\n            REP(i, N-1) {\n                REP(j, rem + 1) {\n                    dp[i+1][j] |= dp[i][j];\n                    dp[i+1][j + d[i].snd] |= dp[i][j];\n                }\n            }\n\n            int maxi = 0;\n            REP(i, rem + 1) {\n                if(dp[N-1][i]) {\n                    maxi = std::max(maxi, (int)i);\n                }\n            }\n\n            int t = rem - maxi;\n            REP(i, N) {\n                t += d[i].snd;\n            }\n            std::cout << rem + t << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = max(min(maxsum, N-as[i]), 1000);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N;\nll r[1000], w[1000];\nll rsum = 0;\nll wsum;\n\nbool dp[1005];\n\nvoid solve() {\n    //cout.precision(10);\n    rsum = 0;\n    wsum = 0;\n    for(int i = 0; i < N; i++) {\n        cin >> r[i] >> w[i];\n        rsum += r[i];\n        wsum += w[i];\n    }\n    for(int i = 1; i < N; i++) {\n        if(r[i] > r[0]) {\n            swap(r[i], r[0]);\n            swap(w[i], w[0]);\n        }\n    }\n    if(r[0] * 2 <= rsum) {\n        cout << rsum + wsum << endl;\n        return;\n    }\n    ll W = r[0] - (rsum - r[0]);\n    for(int i = 0; i <= W; i++) dp[i] = false;\n    dp[0] = true;\n    for(int i = 1; i < N; i++) {\n        for(int j = W; j >= 0; j--) {\n            if(j + w[i] <= W) {\n                dp[j+w[i]] |= dp[j];\n            }\n        }\n    }\n    ll maxi = 0;\n    for(int i = 0; i <= W; i++) {\n        if(dp[i]) maxi = i;\n    }\n    cout << 2 * r[0] + wsum - maxi << endl;\n    return;\n}\n\nint main() {\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int n;\n    cin >> n;\n    if(!n)\n        return false;\n    vector<pair<int,int>> v;\n    for(int i = 0; i < n; ++i){\n        int r, w;\n        cin >> r >> w;\n        v.emplace_back(r, w);\n    }\n    sort(v.begin(), v.end());\n    vector<int> a(n), b(n);\n    for(int i = 0; i < n; ++i){\n        a[i] = v[i].first;\n        b[i] = v[i].second;\n    }\n    if(2 * a.back() > accumulate(a.begin(), a.end(), 0LL)){\n        int w = 2 * a.back() - accumulate(a.begin(), a.end(), 0LL);\n        bitset<2007> dp;\n        dp.set(0);\n        for(int i = 0; i < n - 1; ++i)\n            dp |= (dp << b[i]);\n        int val = 0;\n        for(int i = 0; i <= w; ++i)\n            if(dp[i])\n                val = i;\n        int ans = 2 * a.back() - val + accumulate(b.begin(), b.end(), 0LL);\n        cout << ans << endl;\n    }\n    else{\n        cout << accumulate(a.begin(), a.end(), 0LL) + accumulate(b.begin(), b.end(), 0LL) << endl;\n    }\n\n\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint dp[1001][1001];\n\nint main(){\n\tint n,r[1000],w[1000],maxr,sum,sumr,p;\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)break;\n\t\tsum = sumr = maxr = p = 0;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",r+i,w+i);\n\t\t\tsum += r[i]+w[i];\n\t\t\tsumr += r[i];\n\t\t\tif(maxr < r[i]){\n\t\t\t\tp = i;\n\t\t\t\tmaxr = r[i];\n\t\t\t}\n\t\t}\n\t\tsumr -= maxr;\n\t\tif(maxr <= sumr){\n\t\t\tprintf(\"%d\\n\",sum);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n        sumr = maxr - sumr;\n\t\trep(i,n){\n\t\t\trep(j,sum+1){\n\t\t\t\tif(j >= w[i] && i!=p)dp[i+1][j] = max(dp[i][j],dp[i][j - w[i]]+w[i]);\n\t\t\t\telse dp[i+1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum + sumr - dp[n][sumr]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\npair<int, int>x[1000]; int n, a, b, s1, s2, dp[1100000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; s1 = 0; s2 = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> a >> b; x[i] = make_pair(a, b); s1 += a; s2 += b; }\n\t\tsort(x, x + n);\n\t\tif (x[n - 1].first * 2 <= s1) { cout << s1 + s2 << endl; }\n\t\telse {\n\t\t\tfor (int i = 0; i < 1100000; i++)dp[i] = 0; dp[0] = 1;\n\t\t\tint nokori = x[n - 1].first - (s1 - x[n - 1].first);\n\t\t\tvector<int>f; f.push_back(0);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvector<int>g;\n\t\t\t\tfor (int a1 : f) {\n\t\t\t\t\tif (dp[a1 + x[i].second] == 0) { g.push_back(a1 + x[i].second); dp[a1 + x[i].second] = 1; }\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < g.size(); i++)f.push_back(g[i]);\n\t\t\t}\n\t\t\tint g = 0; for (int i = nokori; i >= 0; i--) { if (dp[i] == 1) { g = i; break; } }\n\t\t\tcout << (nokori - g) + s1 + s2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n        dp[0][0] = true;\n        range (i, 1, n + 1) {\n            dp[i]=dp[i-1];\n            if (r.back() == copyR[i - 1]) {\n                continue;\n            }\n            for(int j=gap;j>=0;j--){\n                if (j - w[i - 1] < 0) continue;\n                dp[i][j] |= dp[i - 1][j - w[i - 1]];\n            }\n        }\n        int maxJ = 0;\n        rep (j, gap + 1) if (dp[n][j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair< int, int > P;\ntypedef pair< int, P > PP;\n\nstruct edge {\n\tint from, to, cost;\n};\n\nint main() {\n\n\tint n, m;\n\n\tcin >> n >> m;\n\n\tvector< vector< edge > > G(n + 1);\n\tvector< vector< int > > d(28, vector< int >(n, INT_MAX / 4));\n\n\tfor(int i = 0; i < m; i++) {\n\t\tint f, t, c;\n\t\tedge m;\n\t\tcin >> f >> t >> c;\n\n\t\tm.from = f;\n\t\tm.to = t;\n\t\tm.cost = c;\n\n\t\tG[f].push_back(m);\n\n\t\tm.from = t;\n\t\tm.to = f;\n\t\tm.cost = c;\n\n\t\tG[t].push_back(m);\n\t}\n\n\tpriority_queue<PP, vector< PP >, greater< PP > > que;\n\td[0][0] = 0;\n\tque.push(PP(0, P(0, 0)));\n\n\twhile( !que.empty() ) {\n\t\tPP p = que.top(); que.pop();\n\t\tint v = p.second.second;\n\t\tint a = p.second.first;\n\n\t\tif(d[a][v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(v == n - 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\n\t\t\tif(d[(d[a][v] + e.cost) % 28][e.to] > d[a][v] + e.cost) {\n\t\t\t\td[(d[a][v] + e.cost) % 28][e.to] = d[a][v] + e.cost;\n\t\t\t\tque.push(PP(d[(d[a][v] + e.cost) % 28][e.to], P((d[a][v] + e.cost) % 28, e.to)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*for(int i = 0; i < 28; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << d[i][j] << \"   \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\n\tint ans = INT_MAX - 1;\n\tfor(int i = 0; i < 28; i++) {\n\t\tif(i % 4 == 0 || i % 7 == 0) {\n\t\t\tans = min(ans, d[i][n - 1]);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Book\n{\n  int read,write;\n  Book(int read=inf,int write=inf):read(read),write(write){}\n  bool operator < (const Book& a)const\n  {\n    if(read != a.read)return read < a.read;\n    return write < a.write;\n  }\n};\n\nint main()\n{\n  int N;\n  while(scanf(\"%d\",&N),N)\n    {\n      Book array[N];\n      int sum_r = 0;\n      int sum_w = 0;\n      rep(i,N)\n\t{\n\t  scanf(\"%d %d\",&array[i].read,&array[i].write);\n\t  sum_r += array[i].read;\n\t  sum_w += array[i].write;\n\t}\n\n      sort(array,array+N);\n\n      if(sum_r-array[N-1].read < array[N-1].read)\n\t{\n\t  int limit = array[N-1].read - (sum_r-array[N-1].read);\n\t  bool dp[limit+1];\n\t  rep(i,limit+1)dp[i] = false;\n\t  dp[0] = true;\n\t  int mex = 0;\n\t  rep(i,N-1)for(int j=limit;j>=0;j--)\n\t    {\n\t      if(!dp[j] || j+array[i].write > limit)continue;\n\t      dp[j+array[i].write] = true;\n\t      mex = max(mex,j+array[i].write);\n\t    }\n\t  printf(\"%d\\n\",sum_r+sum_w+(limit-mex));\n\t}\n      else\n\t{\n\t  printf(\"%d\\n\",sum_r+sum_w);\n\t}\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool cur[1000]={};\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool next[1000]={};\n                for(int j=0;j<1000;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<1000)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector <int> r, w;\n\t\tr = w = vector <int> (n);\n\t\tint sumR = 0, sumW = 0;\n\t\trep (i, n) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsumR += r[i];\n\t\t\tsumW += w[i];\n\t\t}\n\n\t\tvector <int> copyR = r;\n\t\tsort(r.begin(), r.end());\n\n\t\tif (sumR >= 2*r.back()) {\n\t\t\tcout << sumR + sumW << endl;\n\t\t} else {\n\t\t\tint gap = r.back() - (sumR - r.back());\n\t\t\tvector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n\t\t\tdp[0][0] = true;\n\t\t\tw.erase(w.begin() + (copyR.begin() - find(copyR.begin(), copyR.end(), r.back())));\n\t\t\trange (i, 1, n) {\n\t\t\t\trep (j, gap + 1) {\n\t\t\t\t\tif (j - w[i - 1] < 0) continue;\n\t\t\t\t\tdp[i][j] |= dp[i - 1][j - w[i-1]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint maxJ = 0;\n\t\t\trep (i, n + 1) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n\t\t\tcout << 2*r.back() + sumW - maxJ << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\npii A[1000];\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> A[i].fi >> A[i].se;\n    sort(A, A + N);\n\n    int s1 = 0, s2 = 0;\n    REP(i, 0, N - 1) s1 += A[i].fi;\n    REP(i, 0, N) s2 += A[i].se;\n\n    if(s1 >= A[N - 1].fi) {\n      cout << A[N - 1].fi + s1 + s2 << endl;\n    } else {\n      int d = A[N - 1].fi - s1;\n      bool dp[N][d + 1];\n      REP(i, 0, N) REP(j, 0, d + 1) dp[i][j] = false;\n      dp[0][0] = true;\n      int m = 0;\n      REP(i, 0, N - 1) REP(j, 0, d + 1) if(dp[i][j]) {\n        if(j + A[i].se <= d) {\n          dp[i + 1][j + A[i].se] = true;\n          m = max(m, j + A[i].se);\n        }\n      }\n      cout << A[N - 1].fi * 2 + (s2 - m) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair< int, int > P;\n\nint main() {\n\tint n;\n\n\twhile( true ) {\n\t\tcin >> n;\n\t\tif( !n ) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< P > book(n);\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> book[i].first >> book[i].second;\n\t\t}\n\n\t\tsort(book.begin(), book.end(), greater< P >());\n\n\t\tint ans = 0;\n\t\tif(book.size() == 1) {\n\t\t\tans = book[0].first * 2 + book[0].second;\n\t\t} else {\n\t\t\tint total = 0;\n\t\t\tfor(int i = 1; i < book.size(); i++) {\n\t\t\t\ttotal += book[i].first;\n\t\t\t}\n\n\t\t\tif(book[0].first > total) {\n\t\t\t\tint a = book[0].first - total;\n\n\t\t\t\tvector< int > b(a + 1, 0);\n\t\t\t\tvector< int > write(n - 1);\n\t\t\t\tb[0] = 1;\n\n\t\t\t\tfor(int i = 1; i < book.size(); i++) {\n\t\t\t\t\twrite[i - 1] = book[i].second;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < write.size(); i++){\n\t\t\t\t\tfor(int j = b.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tif(b[j]) {\n\t\t\t\t\t\t\tif(j + write[i] < b.size()) {\n\t\t\t\t\t\t\t\tb[j + write[i]] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint s = a;\n\n\n\t\t\t\tfor(int i = b.size() - 1; i >= 0; i--) {\n\t\t\t\t\tif(b[i]) {\n\t\t\t\t\t\ts -= i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < book.size(); i++) {\n\t\t\t\t\tans += book[i].first + book[i].second;\n\t\t\t\t}\n\t\t\t\tans += s;\n\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < book.size(); i++) {\n\t\t\t\t\tans += book[i].first + book[i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dp[1010][3010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    VI r(n), w(n);\n    int sumr = 0, sumw = 0;\n    int ma=0, idx=-1;\n    REP(i, n) {\n      cin >> r[i] >> w[i];\n      if(ma < r[i]) {\n        ma = r[i];\n        idx = i;\n      }\n      sumr += r[i];\n      sumw += w[i];\n    }\n\n    if(ma <= sumr - ma) {\n      cout << sumr + sumw << endl;\n    } else {\n      // r.back() - (sumr - r.back()) = 2*r.back() - sumr にできるだけ近づける\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1;\n      REP(i, n) REP(j, 2*ma-sumr+1) {\n        dp[i+1][j] |= dp[i][j];\n        if(j+w[i] <= 2*ma-sumr && i != idx) dp[i+1][j+w[i]] |= dp[i][j];\n      }\n\n      int tmp = -1;\n      REP(i, 2*ma-sumr+1) if(dp[n][i]==1) chmax(tmp, i);\n\n      cout << ma*2 + sumw - tmp << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int,int> book[1<<11];\nint n;\n\nvoid solve() {\n    int ans=0;\n    int rest=0;\n    for(int i=1; i<n; ++i) {\n        rest+=book[i].first;\n    }\n    if(rest>=book[0].first) {\n        ans=rest+book[0].first;\n        for(int i=0; i<n; ++i) {\n            ans+=book[i].second;\n        }\n    } else {\n        ans=book[0].first*2;\n        rest=book[0].first-rest;\n        bitset<1010> bs;\n        bs[0]=1;\n        int mx=0;\n        int tmp=0;\n        for(int i=0; i<n; ++i) tmp+=book[i].second;\n        for(int i=1; i<n; ++i) {\n            bs|=bs<<book[i].second;\n        }\n        for(int i=0; i<=rest; ++i) {\n            if(bs[i]) mx=i;\n        }\n        tmp-=mx;\n        ans+=tmp;\n    }\n    cout<<ans<<endl;\n}\n\nint main() {\n    while(cin>>n,n) {\n        for(int i=0; i<n; ++i) cin>>book[i].first>>book[i].second;\n        sort(book,book+n,greater<pair<int,int>>());\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<pii> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tv.emplace_back(a, b);\n\t\t}\n\t\tsort(ALL(v));\n\t\tint sum = 0;\n\t\tREP(i, n - 1) sum += v[i].first;\n\t\tif (sum >= v.back().first)\n\t\t{\n\t\t\tsum += v.back().first;\n\t\t\tREP(i, n) sum += v[i].second;\n\t\t\tcout << sum << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint w = v.back().first - sum;\n\t\t\tvi t;\n\t\t\tREP(i, n - 1) t.push_back(v[i].second);\n\t\t\tvector<bool> dp(w + 1, false);\n\t\t\tdp[0] = true;\n\t\t\tint mx = 0;\n\t\t\tREP(i, n - 1)for (int j = w; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (dp[j] && j + t[i] <= w)\n\t\t\t\t{\n\t\t\t\t\tdp[j + t[i]] = true;\n\t\t\t\t\tchmax(mx, j + t[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = v.back().first * 2;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tans += v[i].second;\n\t\t\t}\n\t\t\tans -= mx;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n#define whole(xs) xs.begin(), xs.end()\n\nint N;\nvector<int> r, w;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    r.resize(N); w.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> r[i] >> w[i];\n    }\n    return true;\n}\n\nint sum(const vector<int>& v) {\n    int ret = 0;\n    for (int i = 0; i < v.size(); i++) ret += v[i];\n    return ret;\n}\n\nint dfs(int y) {\n    int dp[y + 1]; memset(dp, -1, sizeof(dp));\n    sort(whole(w));\n    dp[0] = 0;\n    for (int i = 0; i <= y; i++) {\n        if (dp[i] == -1) continue;\n        for (int j = dp[i]; j < w.size(); j++) {\n            if (i + w[j] > y) continue;\n            dp[i + w[j]] = j + 1;\n        }\n    }\n    int ret = 0;\n    for (int i = 1; i <= y; i++) {\n        if (dp[i] >= 0) ret = max(ret, i);\n    }\n    return ret;\n}\n\nint main() {\n    while (input()) {\n        int mr = *max_element(whole(r));\n        int sr = sum(r);\n        int sw = sum(w);\n        int x = sr - mr;\n        if (mr >= x) {\n            int index = max_element(whole(r)) - r.begin();\n            w.erase(w.begin() + index);\n            int y = mr - x;\n            cout << sr + sw + (y - dfs(y)) << endl;\n        } else {\n            cout << sr + sw << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nvector<bool> napsac(vector<pii> x, int m){\n\tvector<bool> ret(m+1,false);\n\tint sz = x.size();\n\t// cout<<\"====\"<<endl;\n\t// rep(i,sz) cout<<i<<\" \"<<x[i].se<<endl;\n\t// cout<<\"====\"<<endl;\n\tret[0] = true;\n\trep(i,sz){\n\t\tfor(int j=m;j>=0;j--){\n\t\t\tint w = j-x[i].se;\n\t\t\tif(0<=w && w<=m){\n\t\t\t\tif(ret[w]){\n\t\t\t\t\tret[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool comp(pii a,pii b){\n\tif(a.se > b.se){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tvector<pii> b(1100,mp(0,0));\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin >> b[i].fi >> b[i].se;\n\t\t}\n\t\tsort(rall(b));\n\n\t\tvector<pii> x;\n\t\tint xs=0;\n\t\tint kxs = 0;\n\n\t\tvector<pii> y;\n\t\tint ys=0;\n\t\tint kys = 0;\n\t\trep(i,n){\n\t\t\tif(xs > ys){\n\t\t\t\ty.pb(b[i]);\n\t\t\t\tys += b[i].fi;\n\t\t\t\tkys += b[i].se;\n\t\t\t}else{\n\t\t\t\tx.pb(b[i]);\n\t\t\t\txs += b[i].fi;\n\t\t\t\tkxs += b[i].se;\n\t\t\t}\n\t\t}\n\t\t// cout << \"debug : \" <<ys << \" \" << xs << endl;\n\t\tsort(all(x),comp);\n\t\tsort(all(y),comp);\n\t\tint res;\n\t\tvector<bool> nap;\n\t\tint ans;\n\t\tint aida;\n\t\tif(xs > ys){\n\t\t\taida = xs-ys;\n\t\t\tnap = napsac(y,aida);\n\t\t\t//cout<<\"# xs : \"<<xs<<\" \"<<kys<<endl;\n\t\t}else{\n\t\t\taida = ys-xs;\n\t\t\tnap = napsac(x,aida);\n\t\t\t//ans = ys + kxs;\n\t\t}\n\n\t\t// cout<<\"-----\"<<endl;\n\t\t// rep(i,aida+1){\n\t\t// \tcout<<i<<\" \"<<nap[i]<<endl;\n\t\t// }\n\t\tint tar;\n\t\tfor(int i=aida;i>=0;i--){\n\t\t\tif(nap[i]) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = xs + ys + kxs + kys - tar + aida;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nint dp[1001];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint r, w;\n\t\tvector<P> book;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> r >> w;\n\t\t\tbook.emplace_back(r, w);\n\t\t}\n\t\tsort(book.begin(), book.end());\n\t\tint r_sum = 0, w_sum = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tr_sum += book[i].first;\n\t\t\tw_sum += book[i].second;\n\t\t}\n\t\tif (r_sum >= 2 * book[N - 1].first) {\n\t\t\tcout << r_sum + w_sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tfor (int j = 1000; j >= 0; j--) {\n\t\t\t\tif (j >= book[i].second) {\n\t\t\t\t\tdp[j] = max(dp[j], dp[j - book[i].second] + book[i].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint t = book[N - 1].first - (r_sum - book[N - 1].first);\n\t\tcout << r_sum + w_sum + (t - dp[t]) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, r[1000];\nlong long w[1000];\nbool dp[2][1001];\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> n,n){\n    int sumr = 0, sumw = 0, id = 0;\n    for(int i=0;i<n;i++){\n      cin >> r[i] >> w[i];\n      sumr += r[i]; sumw += w[i];\n      if(r[id] < r[i])id = i;\n    }\n\n    int lim = 2*r[id]-sumr;\n    if(lim<=0){\n      cout << sumr + sumw << endl;\n      continue;\n    }\n\n    for(int j=0;j<=lim;j++)dp[0][j] = false;\n    dp[0][0] = true;\n    \n    for(int i=0;i<n;i++){\n      int now = i&1, nxt = 1-now;\n      for(int j=0;j<=lim;j++)dp[nxt][j] = false;\n      for(int j=0;j<=lim;j++){\n\tif(dp[now][j]){\n\t  dp[nxt][j] = true;\n\t  if(i!=id && j+w[i]<=lim)dp[nxt][j+w[i]] = true;\n\t}\n      }\n    }\n    \n    int tmp = 0;\n    for(int i=0;i<=lim;i++){\n      if(dp[n&1][i])tmp = i;\n    }\n    cout << sumr + sumw + lim - tmp << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n    while(scanf(\"%d\",&n),n){\n \n        vector<pair<int,int> > rw(n);\n        int r_max=-1,sum_r=0,sum_w=0;\n        for(int i=0;i<n;i++){\n            cin>>rw[i].first>>rw[i].second;\n            sum_r+=rw[i].first;\n            sum_w+=rw[i].second;\n\t\t\tr_max=max(r_max,rw[i].first);\n        }\n        sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n \n        int r0=rw[0].first;\n\t\tr0=r_max;\n        int r=sum_r-r0;\n \n\n\n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*r0;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[1][0]=true;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+rw[i].second<=1000)\n                            dp[i+1][j+rw[i].second]=true; \n                    }\n                }\n            }\n \n            int opt=0;\n            for(int i=1;i<=r0-r;i++){\n                if(dp[n][i]) opt=i;\n            }\n \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vint;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<pii> v(n);\n\t\trep(i,n) cin>>v[i].F>>v[i].S;\n\t\tsort(ALL(v));\n\t\tint sum = 0;\n\t\trep(i,n) sum+=v[i].F;\n\t\tif(sum>=2*v.back().F){\n\t\t\trep(i,n) sum+=v[i].S;\n\t\t\tcout<<sum<<endl;\n\t\t}\n\t\telse{\n\t\t\tint t = v.back().F-(sum-v.back().F);\n\t\t\tassert(t<1010);\n\t\t\tvint dp(1010,0);\n\t\t\tdp[0]=1;\n\t\t\trep(i,n-1){\n\t\t\t\tfor(int j=1010-1;j>=0;j--){\n\t\t\t\t\tif(j-v[i].S<0) break;\n\t\t\t\t\tif(dp[j-v[i].S]) dp[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n) sum+=v[i].S;\n\t\t\tsum+=t;\n\t\t\twhile(1){\n\t\t\t\tif(dp[t]){\n\t\t\t\t\tcout<<sum-t<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool cur[1001]={};\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool next[1001]={};\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \n\n \nint main(){\n \n\tint n; \n\twhile(scanf(\"%d\",&n),n){\n\n\t\tvector<pair<int,int> > rw(n);\n\t\tint r0=-1,sum_r=0,sum_w=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>rw[i].first>>rw[i].second;\n\t\t\tsum_r+=rw[i].first;\n\t\t\tsum_w+=rw[i].second;\n\t\t\tr0=max(r0,rw[i].first);\n\t\t}\n\t\t//sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n\n\t\tint r=sum_r-r0;\n\n\t\tif(r0 <= r){\n\t\t\tcout<<sum_r+sum_w<<endl;\n\t\t}else{\n\n\t\t\tint res=2*rw[0].first;\n\t\t\tvector<vector<bool> > dp(1001,vector<bool>(10000,false));\n\n\t\t\t//r0-r???w?????°??????\n\t\t\t//dp[pos][sum]\n\n\t\t\tdp[1][0]=true;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\tdp[i+1][j]=true; //??°?????????\n\t\t\t\t\t\tif(j+rw[i].second<=10000)\n\t\t\t\t\t\t\tdp[i+1][j+rw[i].second]=true; //??°??????\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint opt=0;\n\t\t\tfor(int i=1;i<=r0-r;i++){\n\t\t\t\tif(dp[n][i]) opt=i;\n\t\t\t}\n\n\t\t\tres+=sum_w-opt;\n\t\t\tcout<<res<<endl;\n\n\n\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nbool dp[1001][2001];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        vi r(n),w(n);\n        rep(i,n){\n            cin >> r[i] >> w[i];\n        }\n        int sm = accumulate(all(r),0);\n        int mx = *max_element(all(r));\n        sort(all(w));\n        if(sm >= 2*mx){\n            cout << sm + accumulate(all(w),0) << \"\\n\";\n        }else{\n            dp[0][0] = true;\n            rep(i,n-1){\n                rrep(j,2*mx-sm+1){\n                    if(dp[i][j]){\n                        dp[i+1][j] = true;\n                    }\n                    if(j >= w[i] && dp[i][j-w[i]]){\n                        dp[i+1][j] = true;\n                    }\n                }\n            }\n            int num = 0;\n            rep(i,2*mx-sm+1){\n                if(dp[n-1][i]){\n                    num = i;\n                }\n            }\n            cout << 2*mx + accumulate(all(w),0) - num << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    using P = pair<int, int>;\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        vector<P> book(N);\n        int read_sum = 0;\n        int write_sum = 0;\n        for (int i = 0; i < N; i++) {\n            int r, w;\n            cin >> r >> w;\n            book[i] = make_pair(r, w);\n            read_sum += r;\n            write_sum += w;\n        }\n        sort(book.begin(), book.end());\n        const int total = max(2 * book[N - 1].first, read_sum);\n        const int mergin = total - read_sum;\n        vector<vector<bool>> dp(N, vector<bool>(mergin + 1, false));\n        dp[0][0] = true;\n        for (int i = 0; i < N - 1; i++) {\n            for (int w = 0; w <= mergin; w++) {\n                dp[i + 1][w] = dp[i + 1][w] or dp[i][w];\n                if (w + book[i].second <= mergin) {\n                    dp[i + 1][w + book[i].second] = dp[i + 1][w + book[i].second] or dp[i][w];\n                }\n            }\n        }\n\n        int w = mergin;\n        for (w = mergin; w >= 0; w--) {\n            if (dp[N - 1][w]) {\n                break;\n            }\n        }\n        cout << write_sum + total - w << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<pii> v(N);\n        int sum = 0;\n        int kansou_sum = 0;\n        for(int i=0; i<N; ++i) {\n            cin >> v[i].first >> v[i].second;\n            sum += v[i].first;\n            kansou_sum += v[i].second;\n        }\n        sort(v.begin(), v.end());\n        sum -= v.back().first;\n        if(v.back().first > sum) {\n            int t = 2 * v.back().first;\n            vector<int> dp(v.back().first - sum + 1);\n            dp[0] = 1;\n            for(int i=0; i<N-1; ++i) {\n                for(int j=dp.size()-1-v[i].second; j>=0; --j) {\n                    dp[j+v[i].second] |= dp[j];\n                }\n            }\n            int ma = 0;\n            for(int j=dp.size()-1; j>=0; --j) {\n                if(dp[j]) {\n                    ma = j;\n                    break;\n                }\n            }\n            t += kansou_sum - ma;\n            cout << t << endl;\n        } else {\n            int t = sum + v.back().first + kansou_sum;\n            cout << t << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "template<bool r>\nclass Range{\n    struct It{\n        int it;\n        explicit constexpr It(int it_):it(it_){}\n        int operator*(){return it;}\n        bool operator!=(It& a){return it!=a.it;}\n        void operator++(){ r ? --it : ++it;}\n    };\n    const It i,n;\n  public:\n    explicit constexpr Range(int i,int n):i(i),n(n){}\n    Range<true> rev(){return Range<true>(n.it - 1, i.it - 1);};\n    const It& begin(){return i;}\n    const It& end(){return n;}\n};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nint main() {\n    int n;\n    while (cin >> n && n) {\n        vector<pair<int, int>> books(n);\n        for (auto& p: books) cin >> p.first >> p.second;\n        sort(books.rbegin(), books.rend());\n        int rs = 0, ws = 0;\n        for (auto& p: books) rs += p.first, ws += p.second;\n        int longest = books.front().first;\n        if (longest * 2 <= rs) {\n            cout << rs + ws << endl;\n            continue;\n        }\n        int rest = longest * 2 - rs;\n        vector<bool> dp(rest + 1, false);\n        dp[0] = true;\n        for (int i : in(1, n)) {\n            int val = books[i].second;\n            for (int j : in(val, rest + 1).rev()) {\n                dp[j] = dp[j] | dp[j - val];\n            }\n        }\n        for (int i : in(rest + 1).rev()) {\n            if (dp[i]) {\n                cout << rest + rs + ws - i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nP B[1111];\nint dp[1111][1111];\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> B[i].first >> B[i].second;\n    }\n    sort(B,B+N);\n\n    int sum = 0;\n    for(int i=0;i<N-1;i++){\n      sum += B[i].first;\n    }\n    int ktime = B[N-1].first - sum;\n    if( ktime > 0 ) {\n      memset(dp,0,sizeof(dp));\n      dp[0][0] = 1;\n      int rt = 0;\n      for(int i=0;i<N;i++){\n\tfor(int w=0;w<=ktime;w++){\n\t  if( dp[i][w] == 0 ) continue;\n\t  rt = max(rt,w);\n\t  dp[i+1][w+B[i].second] = 1;\n\t  dp[i+1][w] = 1;\n\t}\n      }\n      int res = sum + B[N-1].first;\n      for(int i=0;i<N;i++) res += B[i].second;\n      cout << res + ktime-rt << endl;\n    } else {\n      int res = sum + B[N-1].first;\n      for(int i=0;i<N;i++) res += B[i].second;\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\n\nint solve(vector<pii> v){\n\t\n\tsort(v.begin(), v.end());\n\t\n\tint rl, rs = 0, ws = 0;\n\tbool dp[1010] = {0};\n\t\n\trl = v[N-1].first;\n\t\n\tfor(int i=0; i<N; ++i){\n\t\trs += v[i].first;\n\t\tws += v[i].second;\n\t}\n\t\n\trs -= rl;\n\t\n\tif(rs >= rl){\n\t\treturn rs + rl + ws;\n\t}\n\t\n\tdp[0] = true;\n\t\n\tfor(int i = 0; i < N-1; ++i){\n\t\tfor(int j=rl-rs; j >=0; --j){\n\t\t\t\n\t\t\tif( dp[j] && j + v[i].second <= rl - rs )\n\t\t\t\tdp[j + v[i].second] = true;\n\t\t\t\t\n\t\t}\n\t}\n\t\n\tint maxwrite = 0;\n\t\n\tfor(int i = rl - rs; i >= 0; --i){\n\t\n\t\tif(dp[i])\n\t\t\treturn 2*rl + ws - i;\n\t}\n}\n\nint main(){\n\t\n\twhile(cin>>N, N){\n\t\t\n\t\tvector<pii> v;\n\t\tint r, w;\n\t\t\n\t\tfor(int i=0; i<N; ++i){\n\t\t\t\n\t\t\tcin >> r >> w;\n\t\t\tv.push_back(make_pair(r, w));\n\t\t}\n\t\t\n\t\tcout << solve(v) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<Int> rs(n),ws(n);\n    for(Int i=0;i<n;i++) cin>>rs[i]>>ws[i];\n    Int sum=0;\n    for(Int r:rs) sum+=r;\n    Int k=max_element(rs.begin(),rs.end())-rs.begin();\n    if(rs[k]*2<=sum){\n      for(Int w:ws) sum+=w;\n      cout<<sum<<endl;\n      continue;\n    }\n\n    using BS = bitset<1010>;\n    BS dp(1);\n\n    for(Int i=0;i<n;i++)\n      if(i!=k) dp|=dp<<ws[i];\n\n    Int dif=rs[k]*2-sum;\n    for(Int i=dif;i>=0;i--){\n      if(dp[i]){\n        sum+=dif-i;\n        break;\n      }\n    }\n    for(Int w:ws) sum+=w;\n    cout<<sum<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <cassert>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >> n && n){\n\tvector<pair<int,int> > book(n);\n\tfor(int i = 0;i < n;i++){\n\t  cin >> book[i].first >> book[i].second;\n\t}\n\tsort(book.begin(),book.end());\n\tint sum = 0;\n\tif(n == 1 ){\n\t  cout << book[0].first*2+book[0].second << endl;\n\t  continue;\n\t}\n\tfor(int i = n-2;i >= 0;i--){\n\t  sum+=book[i].first;\n\t}\n\n\tif(sum >= book[n-1].first){\n\t  sum = 0;\n\t  for(int i = 0;i < n;i++){\n\t\tsum+=book[i].first + book[i].second;\n\t  }\n\t  cout << sum << endl;\n\n\t}else{\n\t  int amari = book[n-1].first - sum;\n\n\t  vector<int> dp(amari+1,-1);\n\t  dp[0] = 1;\n\t  for(int i = 0;i < n-1;i++){\n\t\tfor(int j = amari;0 <= j;j--){\n\t\t  if(dp[j] == 1 && book[i].second+j <= amari){\n\t\t\tdp[j+book[i].second] = 1;\n\t\t  }\n\t\t}\n\t  }\n\t  int amari_max = 0;\n\t  for(int i = 0;i <= amari;i++){\n\t\tif(dp[i] == 1)amari_max = max(amari_max,i);\n\t  }\n\t  sum = 0;\n\t  for(int i = 0;i < n;i++){\n\t\tsum+= book[i].first + book[i].second;\n\t  }\n\t  assert(amari-amari_max >= 0);\n\t  cout << sum + amari - amari_max << endl;\n\t  \n\t  \n\t}\n\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint N;\nint a[1200];\nint b[1200];\nint wa1,wa2,amax;\nint nokoa;\nint c[1200];\nint jjjj;\n\nint main(){\n\twhile(1){\n\t\tcin >> N;\n\t\tif (N==0) return 0;\n\t\twa1 = 0;\t\n\t\twa2 = 0;\n\t\tamax = 0;\n\t\tnokoa = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\twa1 += a[i];\n\t\t\twa2 += b[i];\n\t\t\tamax = max(amax,a[i]);\n\t\t}\n\t\tif(amax*2 <= wa1){\n\t\t\tcout << wa1+wa2 << endl;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<1100;i++){\n\t\t\t\tc[i]=0;\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(a[i]==amax) jjjj = i;\n\t\t\t}\n\t\t\tnokoa = amax - (wa1-amax);\n\t\t\tc[0] = 1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif (j==jjjj) continue;\n\t\t\t\tfor(int k=nokoa;k>=0;k--){\n\t\t\t\t\tif(k-b[j]>=0 && c[k-b[j]]==1){\n\t\t\t\t\t\tc[k]=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint kk = nokoa;\n\t\t\twhile(c[kk] == 0)kk--;\n\t\t\tcout << wa1+wa2+(nokoa-kk) << endl;\n\t\t}\n\t}\n}\n\t\t\t\t\n\t\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( sizeof(bool)*(r0-r+1) );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( sizeof(bool)*(r0-r+1) );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n    \n   \n    \nint main(){\n    \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n     \n    while(scanf(\"%d\",&n),n){\n          \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n   \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n  \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n   \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n   \n//          bool cur[1001]={};\n            bool *cur = (bool*)malloc( r0-r+2 );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n                bool *next = (bool*)malloc( r0-r+2 );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n                swap(cur,next);\n            }\n   \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n   \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n   \n   \n   \n        }\n           \n           \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i,k,n) for(int i = k; i < n; i++)\n#define mmax(start, end) *max_element(start, end)\n#define mmin(start, end) *min_element(start, end)\n#define argmax max_element\n#define argmin min_element\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef pair<int, int> prii;\n\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint dx8[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy8[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\ntemplate<class T = ll> T in() {\n    T _in;\n    cin >> _in;\n    return _in;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(N==0) {\n            break;\n        }\n\n        pair<int, int> rw[1000];\n        rep(i, N) {\n            int r, w;\n            cin >> r >> w;\n            rw[i] = make_pair(r, w);\n        }\n\n        sort(rw, rw+N, greater< pair<int, int> >());\n        int others = 0;\n        REP(i, 1, N) {\n            others += rw[i].first;\n        }\n\n        // cout << others << endl;\n        // cout << rw[0].first << endl;\n        int ans = 0;\n        rep(i, N) {\n            ans += rw[i].first;\n            ans += rw[i].second;\n        }\n        if(rw[0].first <= others) {\n            cout << ans << endl;\n        } else {\n            // DP\n            int w_lim = rw[0].first - others;\n            int dp[1000][1001] = {0};\n            REP(w, 1, w_lim+1) {\n              REP(b, 2, N+1) {\n                dp[w][b] = dp[w][b-1];\n                if (w >= rw[b-1].second) {\n                  dp[w][b] = max(dp[w][b-1],\n                    dp[w - rw[b-1].second][b-1] + rw[b-1].second);\n                }\n              }\n            }\n            // rep(i, w_lim+1) {\n            //   rep(j, N+1) {\n            //     cout << dp[i][j] << \" \";\n            //   }\n            //   cout << endl;\n            // }\n            cout << ans + w_lim - dp[w_lim][N] << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n    while(scanf(\"%d\",&n),n){\n \n        vector<pair<int,int> > rw(n);\n        int r_max=-1,sum_r=0,sum_w=0;\n        for(int i=0;i<n;i++){\n            cin>>rw[i].first>>rw[i].second;\n            sum_r+=rw[i].first;\n            sum_w+=rw[i].second;\n\t\t\tr_max=max(r_max,rw[i].first);\n        }\n        //sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n \n        int r0=rw[0].first;\n\t\tr0=r_max;\n        int r=sum_r-r0;\n \n\n\n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*r0;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[1][0]=true;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+rw[i].second<=1000)\n                            dp[i+1][j+rw[i].second]=true; \n                    }\n                }\n            }\n \n            int opt=0;\n            for(int i=1;i<=r0-r;i++){\n                if(dp[n][i]) opt=i;\n            }\n \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\n\nint main() {\n\t\n\twhile (1) {\n\t\tvector<int>reads;\n\t\tvector<int>writes;\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\treads.push_back(a);\n\t\t\twrites.push_back(b);\n\t\t}\n\t\tint ans;\n\t\tconst int readsum = accumulate(reads.begin(), reads.end(), 0);\n\t\tint readtime;\n\t\tconst auto maxid = (max_element(reads.begin(), reads.end()))-reads.begin();\n\t\tif (reads[maxid] * 2 > readsum) {\n\t\t\treadtime = reads[maxid] * 2;\n\t\t\tconst int resttime = readtime - readsum;//余った時間で感想文書く//maxの以外\n\n\t\t\tbool dp[1001];\n\t\t\tmemset(dp, false, sizeof(dp));\n\t\t\tdp[0] = true;\n\t\t\tfor (int i = 0; i < resttime; ++i) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = N-1; j >=0; --j) {\n\n\t\t\t\t\t\tif (j != maxid) {\n\t\t\t\t\t\t\tif (i + writes[j] <= resttime) {\n\t\t\t\t\t\t\t\tdp[i + writes[j]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxtime;\n\t\t\tfor (int i = resttime; i >= 0; --i) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tmaxtime = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0) - maxtime;\n\n\t\t}\n\t\telse {\n\t\t\treadtime = readsum;\n\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0);\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> r(n), w(n);\n\t\trep(i,n){\n\t\t\tcin >> r[i] >> w[i];\n\t\t}\n\t\tauto it = max_element(all(r));\n\t\tint maxi = distance(r.begin(), it);\n\n\t\tint sum = accumulate(all(r),0);\n\t\tint cnt = 0;\n\n\t\tif(sum - *it < *it){\n\t\t\tint s = *it * 2 - sum;\n\t\t\tvector<bool> dp(s + 1,0);\n\t\t\tdp[0] = 1;\n\t\t\trep(i,n){\n\t\t\t\tif(maxi == i) continue;\n\t\t\t\tfor(int j = s; j >= w[i]; j--){\n\t\t\t\t\tif(dp[j - w[i]]) dp[j] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = s; i >= 0; i--) {\n\t\t\t\tif(dp[i]) {\n\t\t\t\t\tcnt = s - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//rep(i,it->first + 1){ cout << dp[i] << ' '; } cout << endl;\n\t\t}\n\t\tcout << accumulate(all(r),0) + accumulate(all(w),0) + cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \n\n \nint main(){\n \n\tint n; \n\twhile(scanf(\"%d\",&n),n){\n\n\t\tvector<pair<int,int> > rw(n);\n\t\tint r0=-1,sum_r=0,sum_w=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>rw[i].first>>rw[i].second;\n\t\t\tsum_r+=rw[i].first;\n\t\t\tsum_w+=rw[i].second;\n\t\t\tr0=max(r0,rw[i].first);\n\t\t}\n\t\t//sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n\n\t\tint r=sum_r-r0;\n\n\t\tif(r0 <= r){\n\t\t\tcout<<sum_r+sum_w<<endl;\n\t\t}else{\n\n\t\t\tint res=2*r0;\n\t\t\tvector<vector<bool> > dp(1001,vector<bool>(10000,false));\n\n\t\t\t//r0-r???w?????°??????\n\t\t\t//dp[pos][sum]\n\n\t\t\tdp[1][0]=true;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<=10000;j++){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\tdp[i+1][j]=true; //??°?????????\n\t\t\t\t\t\tif(j+rw[i].second<=10000)\n\t\t\t\t\t\t\tdp[i+1][j+rw[i].second]=true; //??°??????\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint opt=0;\n\t\t\tfor(int i=1;i<=r0-r;i++){\n\t\t\t\tif(dp[n][i]) opt=i;\n\t\t\t}\n\n\t\t\tres+=sum_w-opt;\n\t\t\tcout<<res<<endl;\n\n\n\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\nvoid chmax(int &a, int b) { a = max(a, b); }\n\nint n;\nint r[1000], w[1000];\nbool dp[1001][1001];\n\nvoid toSort() {\n\ttypedef pair<int, int> P;\n\tvector<P> vec;\n\tfor (int i = 0; i < n; i++) vec.push_back(P(r[i], w[i]));\n\tsort(vec.begin(), vec.end(), greater<P>());\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i] = vec[i].first;\n\t\tw[i] = vec[i].second;\n\t}\n}\n\nint main() {\n\tint i, j;\n\t\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\trep(i, n) cin >> r[i] >> w[i]; toSort();\n\t\t\n\t\tint sum_r = 0;\n\t\trep(i, n) sum_r += r[i];\n\t\tint blank = max(0, 2 * r[0] - sum_r);\n\t\t\n\t\trep(i, n+1) rep(j, blank+1) dp[i][j] = false;\n\t\tdp[0][0] = true;\n\t\trep(i, n) {\n\t\t\trep(j, blank + 1) {\n\t\t\t\tdp[i + 1][j] |= dp[i][j];\n\t\t\t\tif (i > 0 && j + w[i] <= blank) dp[i + 1][j + w[i]] |= dp[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max_wb = 0;\n\t\trep(j, blank + 1) {\n\t\t\tif (dp[n][j]) chmax(max_wb, j);\n\t\t}\n\t\t\n\t\tint gokei = 0;\n\t\trep(i, n) gokei += r[i] + w[i];\n\t\t\n\t\tcout << gokei + blank - max_wb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#include <map>\n#include <algorithm>\n#include <math.h>\n#include <stdio.h>\n#include <queue>\n#include <utility>\n#define llint long long\n#define inf 1e9\n#define eps 1e-8\n\nusing namespace std;\n\nint n;\nllint r[1005], w[1005];\nbool dp[1005][1005];\n\nint main(void)\n{\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i = 1; i <= n; i++){\n      cin >> r[i] >> w[i];\n    }\n    llint rsum = 0, wsum = 0;\n    for(int i = 1; i <= n; i++) rsum += r[i], wsum += w[i];;\n\n    bool flag = false;\n    for(int i = 1; i <= n; i++){\n      if(r[i] * 2 > rsum) flag = true;\n    }\n    if(!flag){\n      cout << rsum + wsum << endl;\n      continue;\n    }\n\n    llint mx = 0, mx_i, delay;\n    for(int i = 1; i <= n; i++){\n      if(mx < r[i]){\n        mx = r[i];\n        mx_i = i;\n      }\n    }\n    delay = mx - (rsum-mx);\n\n    for(int i = 0; i <= n; i++){\n      for(int j = 0; j <= delay; j++){\n        dp[i][j] = false;\n      }\n    }\n    dp[0][0] = true;\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j <= delay; j++){\n        if(!dp[i][j]) continue;\n        dp[i+1][j] = true;\n        if(i+1 != mx_i) dp[i+1][j+w[i+1]] = true;\n      }\n    }\n\n    llint ans = 0;\n    for(llint i = 0; i <= delay; i++){\n      if(dp[n][i]) ans = max(ans, i);\n    }\n    cout << rsum + wsum + (delay-ans) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 1024;\npii P[MAXN];\nbool dp[2][MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while (cin >> N) {\n        if (N==0) break;\n        for (int i = 0; i < N; i++) cin >> P[i].first >> P[i].second;\n        sort(P, P+N);\n        int sum = 0;\n        for (int i = 0; i < N-1; i++) sum += P[i].first;\n        if (sum >= P[N-1].first) {\n            int ans = 0;\n            for (int i = 0; i < N; i++) ans += P[i].first+P[i].second;\n            cout << ans << endl;\n        } else {\n            int diff = P[N-1].first - sum;\n            memset(dp, false, sizeof(dp));\n            dp[0][0] = true;\n            for (int i = 0; i < N-1; i++) {\n                int cur = i%2, tar = cur^1;\n                for (int j = 0; j <= diff; j++) {\n                    if (!dp[cur][j]) continue;\n                    dp[tar][j] |= true;\n                    int t = j+P[i].second;\n                    if (t <= diff) dp[tar][t] |= true;\n                }\n            }\n            int wsum = 0;\n            for (int i = 0; i < N; i++) wsum += P[i].second;\n            int t = diff;\n            for (; t > 0; t--) if (dp[(N-1)%2][t]) break;\n            cout << 2*P[N-1].first + (wsum-t) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<pair<int,int>> rw(n);\n        for(int i=0;i<n;i++) cin>>rw[i].first>>rw[i].second;\n        if(n==1){\n            cout<<2*rw[0].first+rw[0].second<<endl;\n            continue;\n        }\n        sort(rw.begin(),rw.end(),greater<pair<int,int>>());\n        int rsum=accumulate(rw.begin(),rw.end(),0,[](int x,pair<int,int> y){return x+y.first;});\n        int wsum=accumulate(rw.begin(),rw.end(),0,[](int x,pair<int,int> y){return x+y.second;});\n        if(rsum<2*rw[0].first){\n            int span=rw[0].first-(rsum-rw[0].first);\n            vector<vector<int>> dp(n,vector<int>(span+1,0));\n            dp[0][0]=true;\n            for(int i=0;i<n-1;i++){\n                for(int j=0;j<=span;j++){\n                    dp[i+1][j]|=dp[i][j];\n                    if(j-rw[i+1].second>=0) dp[i+1][j]|=dp[i][j-rw[i+1].second];\n                }\n            }\n            int re=0;\n            for(int i=0;i<=span;i++){\n                if(dp[n-1][i]) re=i;\n            }\n            cout<<rw[0].first*2+wsum-re<<endl;\n        }\n        else{\n            cout<<rsum+wsum<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<P> book(n);\n    rep(i, n) cin >> book[i].f >> book[i].s;\n    \n    sort(book.rbegin(), book.rend());\n    \n    int sum_w = 0;\n    rep(i, n) sum_w += book[i].s;\n    \n    int Maxr = book[0].f;\n    int Relse = 0;\n    for(int i = 1 ; i < n ; i++) Relse += book[i].f;\n    \n    if(Maxr > Relse){\n      bool dp[1010][1010];\n      memset(dp, false, sizeof(dp));\n      dp[0][0] = true;\n      book[0].s = 0;\n      for(int i = 0 ; i < n ; i++){\n\tfor(int j = 0 ; j + book[i].s <= Maxr-Relse ; j++){\n\t  if(!dp[i][j]) continue;\n\t  dp[i+1][j] = dp[i+1][j+book[i].s] = true;\n\t}\n      }\n      int maxWrite = 0;\n      for(int i = 0 ; i <= Maxr-Relse ; i++){\n\tif(dp[n][i]) maxWrite = i;\n      }\n      int ans = 2* Maxr + sum_w - maxWrite;\n      cout << ans << endl;\n    }\n    \n    else{\n      int ans = Maxr + Relse + sum_w;\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\npii A[1000];\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> A[i].fi >> A[i].se;\n    sort(A, A + N);\n\n    int s1 = 0, s2 = 0;\n    REP(i, 0, N - 1) s1 += A[i].fi;\n    REP(i, 0, N) s2 += A[i].se;\n\n    if(s1 >= A[N - 1].fi) {\n      cout << A[N - 1].fi + s1 + s2 << endl;\n    } else {\n      int d = A[N - 1].fi - s1;\n      bool dp[N][d + 1];\n      REP(i, 0, N) REP(j, 0, d + 1) dp[i][j] = false;\n      dp[0][0] = true;\n      int m = 0;\n      REP(i, 0, N - 1) REP(j, 0, d + 1) if(dp[i][j]) {\n        dp[i + 1][j] = true;\n        if(j + A[i].se <= d) {\n          dp[i + 1][j + A[i].se] = true;\n          m = max(m, j + A[i].se);\n        }\n      }\n      cout << A[N - 1].fi * 2 + (s2 - m) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        vector<pair<int,int>> v(n);\n        for(int i = 0; i < n; i++)  cin >> v[i].first >> v[i].second;\n        sort(v.begin(), v.end());\n        int sum = 0;\n        for(int i = 0; i < n-1; i++)    sum += v[i].first;\n        int ans = sum + v[n-1].first;\n        for(int i = 0; i < n; i++)  ans += v[i].second;\n        if(sum < v[n-1].first){\n            int res = v[n-1].first - sum;\n            bool dp[1001] = {};\n            dp[0] = true;\n            for(int i = 0; i < n-1; i++){\n                for(int j = res; j >= v[i].second; j--){\n                    dp[j] |= dp[j-v[i].second];\n                }\n            }\n            int ma;\n            for(ma = res; ma >= 0; ma--){\n                if(dp[ma])  break;\n            }\n            cout << ans + res-ma << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n#include<fstream>\n\n#define N 1000//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[10000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif (dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> rTime[i] >> wTime[i];\n//\t\t\tcout << rTime[i] << wTime[i] << endl;\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 本を読む時間も最短でないといけない\n// 1) aの最大値mxがaの総和sの半分以上である場合は余ったところ(2mx-s)に感想文を入れられる\n// 2) そうじゃない場合は普通にaの総和とbの総和の和が答え\n\nint n;\npii a[1010];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tint sa = 0, sb = 0;\n\t\trep(i,n) {\n\t\t\tcin >> a[i].fi >> a[i].se;\n\t\t\tsa += a[i].fi, sb += a[i].se;\n\t\t}\n\t\tsort(a,a+n);\n\t\tint m = a[n-1].fi;\n\t\tif (m<sa-m) {\n\t\t\tcout << sa+sb << ln;\n\t\t\tcontinue;\n\t\t}\n\t\tint res = m*2 + sb, p = m*2 - sa;\n\t\tbitset<1010> b = 1;\n\t\trep(i,n-1) b |= (b<<a[i].se);\n\t\trepr(i,p) if (b[i]) {\n\t\t\tres -= i;\n\t\t\tbreak;\n\t\t}\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = min(maxsum, N-as[i]);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint n;\npair<int, int> data[N];\n\nint calc(int emp){\n  bool dp[N][N+1];\n  fill(dp[0], dp[1], false);\n  dp[0][0] = true;\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=emp;j++){\n      if(!dp[i][j]) continue;\n      dp[i+1][j] = true;\n      if(j+data[i].second <= emp) dp[i+1][j+data[i].second] = true;\n    }\n  }\n  int tmp = 0;\n  for(int i=0;i<=emp;i++) if(dp[n-1][i]) tmp = i;\n  int res = data[n-1].first * 2;\n  for(int i=0;i<n;i++) res += data[i].second;\n  return res - tmp;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      data[i] = make_pair(a, b);\n    }\n    sort(data, data+n);\n    int sum = 0;\n    for(int i=0;i<n-1;i++) sum += data[i].first;\n    int ans = 0;\n    if(sum >= data[n-1].first) for(int i=0;i<n;i++) ans += data[i].first + data[i].second;\n    else ans = calc(data[n-1].first - sum);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\n//const long long int MOD = 1000003;\n//const int MOD = 998244353;\nconst long long int MOD = 998244353;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N, N) {\n\t\tvector<pair<int, int>>v(N);\n\t\tint fsum = 0, ssum = 0;\n\t\tfor (auto &i : v) {\n\t\t\tcin >> i.first >> i.second;\n\t\t\tfsum += i.first;\n\t\t\tssum += i.second;\n\t\t}\n\t//\tcout << fsum << \" \" << ssum << endl;\n\t\tsort(v.begin(), v.end());\n\t\tif (v.back().first * 2 > fsum) {\n\t\t\tint box = v.back().first * 2 - fsum;\n\t\t\tvector<int>dp(box + 1);\n\t\t\tdp[0] = 1;\n\t\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\t\tfor (int j = box; j >= v[i].second; j--) {\n\t\t\t\t\tdp[j] |= dp[j - v[i].second];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = box; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t//\tcout << i << endl;\n\t\t\t\t\tcout << fsum + ssum + box - i << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << fsum + ssum << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\n// dp[i][t] := i?????????????????§?????????????????????????¨?t???????????¨????????????????????????????¨?\nint dp[2][1010];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<PII> xs(N);\n\tREP(i,N) cin >> xs[i].FF >> xs[i].SS;\n\tSORT(xs);\n\n\tint mx = xs.back().FF;\n\tint sum = accumulate(ALL(xs), 0,\n\t\t\t\t\t\t [](int s, PII x){ return s+x.FF;}) - mx;\n\tif(sum >= mx){\n\t  cout << accumulate(ALL(xs), sum+mx,\n\t\t\t\t\t\t [](int s, PII x){ return s+x.SS;}) << endl;\n\t}\n\telse{\n\t  int crt = 0, nxt = 1;\n\t  fill(dp[crt], dp[crt]+1010, -INF);\n\t  dp[crt][0] = 0;\n\t  REP(i,N-1){\n\t\tfill(dp[nxt], dp[nxt]+1010, -INF);\n\t\tREP(t,mx+1){\n\t\t  int nxt_t = t + xs[i].FF;\n\t\t  if(nxt_t <= mx){\n\t\t\tdp[nxt][nxt_t] = max(dp[nxt][nxt_t], dp[crt][t]);\n\t\t\tnxt_t += xs[i].SS;\n\t\t\tif(nxt_t <= mx)\n\t\t\t  dp[nxt][nxt_t] = max(dp[nxt][nxt_t], dp[crt][t] + xs[i].SS);\n\t\t  }\n\t\t}\n\t\tswap(crt, nxt);\n\t  }\n\t  int tmp = 0;\n\t  REP(t,mx+1) tmp = max(tmp, dp[crt][t]);\n\t  int ans = accumulate(ALL(xs), -tmp, [](int s, PII x){return s+x.SS;});\n\t  cout << ans + 2*mx << endl;\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define ll long long\n#define fi first\n#define fs first\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint n;\nvec dp;\n\nvoid solve() {\n\tvector<P> a(n);\n\tint sum1 = 0, sum2 = 0;\n\tREP(i, n) cin >> a[i].fs >> a[i].sc, sum1 += a[i].fs, sum2 += a[i].sc;\n\n\tsort(a.begin(), a.end());\n\n\tif (sum1 >= a.back().fs * 2) {\n\t\tcout << sum1 + sum2 << endl;\n\t\treturn;\n\t}\n\n\tint k = a.back().fs * 2 - sum1;\n\tvec dp(k + 1, 0);\n\tdp[0] = 1;\n\n\tREP(i, n - 1) {\n\t\tRREP(j, k) {\n\t\t\tif (j + a[i].sc <= k) dp[j + a[i].sc] |= dp[j];\n\t\t}\n\t}\n\n\tint mx = 0;\n\tREP(i, k + 1) if (dp[i]) mx = i;\n\n\tcout << a.back().fs * 2 + sum2 - mx << endl;\n}\n\nint main() {\n\twhile (cin >> n, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\nint N;\nstruct Book{\n\tint page;\n\tint write;\n};\nBook book[1000];\nint dp[1000 * 1000*3];\nint sum = 0;\nint deal = 0;\nint solve(){\n\tmemset(dp, 0, sizeof(dp));\n\tint s = book[N - 1].page*2-sum;\n\t//cout << endl<<s << endl<<endl;\n\tdp[0] = -1;\n\trep(i, 0, N - 1){\n\t\trep(j, 1, s + 1){\n\t\t\tif (j - book[i].write >= 0 && dp[j - book[i].write] != 0 && dp[j - book[i].write] <= i&&dp[j]==0)dp[j] = i + 1;\n\t\t\t//cout << dp[j] << \"/\";\n\t\t}\n\t//\tcout << endl << endl;\n\t}\n\tfor (int i = s; i >= 0; i--)\n\t\tif (dp[i] != 0){\n\t\treturn(s - i);\n\t}\n\n\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tint max_n=0,max_i=0;\n\t\tsum = 0;\n\t\tdeal = 0;\n\t\trep(i, 0, N){\n\t\t\tcin >> book[i].page >> book[i].write;\n\t\t\tsum += book[i].page;\n\t\t\tdeal += book[i].write;\n\t\t\tif (book[i].page > max_n)max_n = book[i].page, max_i = i;\n\t\t}\n\t\tif (sum >= max_n * 2)cout << sum + deal << endl;\n\t\telse{\n\t\t\tBook tmp = book[max_i];\n\t\t\tbook[max_i] = book[N - 1];\n\t\t\tbook[N - 1] = tmp;\n\t\t\tcout << sum+deal+solve() << endl;\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct dat{\n  int r, w;\n  bool operator<(const dat &R)const{\n    if(r!=R.r) return r>R.r;\n    return w<R.w;\n  }\n};\n\nint n, dp[1005];\ndat rw[1005];\n\nint main(){\n  \n  while(cin>>n, n){\n\n    int sum=0, sum2=0;\n      \n    for(int i=0;i<n;i++){\n      cin>>rw[i].r>>rw[i].w;\n      sum+=rw[i].r;\n      sum2+=rw[i].w;\n    }\n    \n    sort(rw,rw+n);\n\n    if(rw[0].r*2<=sum){\n      cout<<sum+sum2<<endl;\n      continue;\n    }\n    \n    int space=rw[0].r*2-sum;\n    \n    int ans=sum2;\n    \n    memset(dp,0,sizeof(dp));\n    \n    dp[0]=1;\n      \n    for(int i=1;i<n;i++){\n      \n      for(int j=space;j>=0;j--){\n\tif(!dp[j]) continue;\n\tif(j+rw[i].w<=space) dp[j+rw[i].w]=1;\n      }\n    }\n    \n    int maxs=0;\n    \n    for(int i=0;i<=space;i++)\n      if(dp[i]) maxs=max(maxs,i);\n\n    cout<<rw[0].r*2+(ans-maxs)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[1100];\nint c[1100];\nint dp[1100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d\",b+i,c+i);\n\t\tint t=0;\n\t\tfor(int i=0;i<a;i++)t+=b[i];\n\t\tint m=0;\n\t\tfor(int i=0;i<a;i++)m=max(m,b[i]);\n\t\tif(m+m<=t){\n\t\t\tint ret=0;for(int i=0;i<a;i++)ret+=c[i];\n\t\t\tprintf(\"%d\\n\",t+ret);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<1100;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(m==b[i])continue;\n\t\t\tfor(int j=m-(t-m)-c[i];j>=0;j--){\n\t\t\t\tif(dp[j])dp[j+c[i]]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=0;for(int i=0;i<a;i++)ret+=c[i];\n\t\tint v=0;for(int i=0;i<=m-(t-m);i++)if(dp[i])v=i;\n\t\tprintf(\"%d\\n\",max(t+ret,m*2+ret-v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> R, W;\n\nint solve(){\n    vector<pair<int, int>> Rp(N);\n    for(int i=0; i<N; i++)\n        Rp.push_back({R[i], i});\n    \n    sort(Rp.rbegin(), Rp.rend());\n    int Rs = 0;\n    for(int i=1; i<N; i++)\n        Rs += Rp[i].first;\n    \n    int Ws = 0;\n    for(int i=0; i<N; i++)\n        Ws += W[i];\n    \n    if(Rs >= Rp[0].first){\n        return  Rs + Rp[0].first + Ws;\n    }\n    \n    int rem = Rp[0].first - Rs;\n    vector<bool> dp(rem + 1, false);\n    dp[0] = true;\n    \n    for(int i=0; i<N; i++) if(i != Rp[0].second){\n        int w = W[i];\n        for(int j=rem; j>=0; j--){\n            if(j - w < 0) break;\n            dp[j] = dp[j] || dp[j-w];\n        }\n    }\n    \n    int add = -1;\n    for(int i=rem; i>=0; i--) if(dp[i]){\n        add = rem - i;\n        break;\n    }\n    return Rs + Rp[0].first + Ws + add;\n}\n\nint main(){\n    while(cin >> N, N){\n        R.resize(N);\n        W.resize(N);\n        for(int i=0; i<N; i++)\n            cin >> R[i] >> W[i];\n        \n        cout << solve() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n\nint solve(){\n  int n, sum_r = 0, max_r = 0, sum_w = 0;\n  int r[SIZE], w[SIZE];\n\n  pair<int,int> book[SIZE];\n\n  scanf(\"%d\" , &n);\n  if(n == 0) return 0;\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\", r+i, w+i);\n    sum_r += r[i];\n    sum_w += w[i];\n    max_r = max(max_r, r[i]);\n  }\n  \n  if(max_r*2 > sum_r){\n    bool dp[1001] = {};\n\n    dp[0] = true;\n    bool f = false;\n    for(int i=0;i<n;i++){\n      if(r[i]==max_r && !f){f=true; continue;}\n      for(int j=max_r-w[i];j>=0;j--){\n        dp[j+w[i]] |= dp[j];\n      }\n    }\n\n    for(int i=max_r-(sum_r-max_r);i>=0;i--){\n      if(dp[i]){\n        printf(\"%d\\n\", max_r * 2 + sum_w-i);\n        break;\n      }\n    }\n    \n  }else{\n    printf(\"%d\\n\",sum_r + sum_w);\n  }\n  \n\n  return 1;\n}\n\nint main(){\n  while(solve());\n  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\t\n\twhile (scanf(\"%d\", &N) && N){\n\t\tpair<int, int> a[1024];\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &a[i].first, &a[i].second);\n\t\t}\n\t\t\n\t\tsort(a, a + N);\n\t\t\n\t\tint sum = 0, ans = 0;\n\t\tfor (int i = 0; i < N - 1; i++) sum += a[i].first;\n\t\tfor (int i = 0; i < N; i++) ans += a[i].first + a[i].second;\n\t\t\n\t\tif (sum >= a[N - 1].first){\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t\telse {\n\t\t\tbool dp[1001] = {false};\n\t\t\tdp[0] = true;\n\t\t\tint spend = 0;\n\t\t\tfor (int i = 0; i < N - 1; i++){\n\t\t\t\tfor (int j = a[N - 1].first - sum; j >= a[i].second; j--){\n\t\t\t\t\tdp[j] |= dp[j - a[i].second];\n\t\t\t\t\tif (dp[j]) spend = max(spend, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans + a[N - 1].first - sum - spend);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\ntypedef long long LL;\nusing namespace std;\nconst int SIZE=1001;\nint r[2*SIZE],w[2*SIZE];\nbool DP[2*SIZE][2*SIZE];\nint N;\nint leastSpace(int n,int maximN){\n\tDP[0][0]=true;\n\tif(maximN) DP[0][w[0]]=true;\n\tint maxim=0;\n\tFOR(i,1,N){\n\t\tFOR(j,w[i],n+1){\n\t\t\tif(maximN!=i)\n\t\t\t\tDP[i][j]=DP[i-1][j]|DP[i-1][j-w[i]];\n\t\t\tif(DP[i][j]) maxim=max(maxim,j);\n\t\t}\n\t}\n\treturn n-maxim;\n}\nint main() {\n\t\n\t\n\twhile(cin >> N && N){\n\t\tint sum=0,maxim=0,sumW=0,maximN=0;\n\t\tREP(i,N){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum+=r[i];\n\t\t\tmaxim=max(maxim,r[i]);\n\t\t\tif(r[i]==maxim) maximN=i;\n\t\t\tsumW+=w[i];\n\t\t}\n\t\tif(maxim*2<=sum){\n\t\t\tcout << sum+sumW << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint space=maxim*2-sum;\n\t\tcout << sum+sumW+leastSpace(space,maximN) << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int N, r[1000], w[1000];\n  bool dp[1000];\n  \n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d %d\", r + i, w + i);\n    }\n    int sum = accumulate(r, r + N, 0);\n    int* big = max_element(r, r + N);\n    int add = 0;\n  \n    if(*big * 2 > sum) {\n      int space = *big * 2 - sum;\n      swap(w[big - r], w[N - 1]);\n      memset(dp, false, sizeof(bool) * (space + 1));\n      dp[0] = true;\n      for(int i = 0; i < N - 1; i++) {\n        for(int j = space; j >= w[i]; j--) {\n          dp[j] |= dp[j - w[i]];\n        }\n      }\n      for(int i = space; i >= 0; i--) {\n        if(dp[i]) {\n          add = space - i;\n          break;\n        }\n      }\n    }\n    printf(\"%d\\n\", sum + accumulate(w, w + N, 0) + add);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vector<pii> rw(n);\n        rep(i, n) cin >> rw[i].F >> rw[i].S;\n\n        sort(all(rw));\n\n        int sum_r = 0, sum_rw = 0; //sum_r??????1??????-1\n        rep(i, n - 1) sum_r += rw[i].F;\n        rep(i, n) sum_rw += rw[i].F + rw[i].S;\n\n        int res;\n        if(sum_r >= rw[n - 1].F){\n            res = sum_rw;\n        }\n        else{\n            int rest = rw[n - 1].F - sum_r;\n\n            vi dp(rest + 1);\n            dp[0] = true;\n\n            int time_w = 0;\n            rep(i, n - 1){\n                for(int j = rest; j >= rw[i].S; j--){\n                    if(dp[j - rw[i].S]){\n                        dp[j] = true;\n                        time_w = max(time_w, j);\n                    }\n                }\n            }\n\n            res = sum_rw + rw[n - 1].F - sum_r - time_w;\n        }\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( 1002 );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( 1002 );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tint ma = 0, sum = 0, dsum = 0;\n\t\tvector<int> r(N), w(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum += r[i];\n\t\t\tma = max(ma, r[i]);\n\t\t\tdsum += r[i] + w[i];\n\t\t}\n\t\tif (ma * 2 <= sum) {\n\t\t\tcout << dsum << endl;\n\t\t}\n\t\telse {\n\t\t\tint W = ma * 2 - sum;\n\t\t\tvector<vector<int>> dp(N + 1, vector<int>(W + 1));\n\t\t\tdp[0][0] = 1;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j <= W; j++) {\n\t\t\t\t\tif (r[i] != ma && j - w[i] >= 0 && dp[i][j - w[i]]) {\n\t\t\t\t\t\tdp[i + 1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j]) {\n\t\t\t\t\t\tdp[i + 1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wma = 0;\n\t\t\tfor (int i = 0; i <= W; i++) {\n\t\t\t\tif (dp[N][i]) {\n\t\t\t\t\twma = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << dsum + W - wma << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint n;\n\nvoid solve() {\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(),v.end());\n\tint sum = 0;\n\trep(i, n - 1) {\n\t\tsum += v[i].first;\n\t}\n\tint dif = max(0, v[n - 1].first-sum);\n\tif (dif == 0) {\n\t\tint ans = sum + v[n - 1].first;\n\t\trep(i, n) {\n\t\t\tans += v[i].second;\n\t\t}\n\t\tcout << ans << endl; return;\n\t}\n\tbitset<1001> b; b[0] = 1;\n\trep(i, n) {\n\t\tif (i == n - 1)continue;\n\t\tint z = v[i].second;\n\t\tb |= (b << z);\n\t}\n\tint ans = 2 * v[n - 1].first;\n\trep(i, n) {\n\t\tans += v[i].second;\n\t}\n\tint dec = 0;\n\trep(i, dif + 1)if (b[i])dec = i;\n\t//cout << \"hello \" << dec << endl;\n\tcout << ans - dec << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >>n,n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n#include<fstream>\n\n#define N 100//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[10000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif (dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\tif (!fin)cout << \"file read error!\" << endl;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tfin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfin >> rTime[i] >> wTime[i];\n//\t\t\tcout << rTime[i] << wTime[i] << endl;\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N;\nVI R, W;\n\nint solve() {\n    // ?????§r???idx\n    int max_r_i;\n    {\n        auto it = max_element(ALL(R));\n        max_r_i = it - R.begin();\n    }\n\n    // ?????§r????????????sum\n    int other_sum = accumulate(ALL(R), 0) - R[max_r_i];\n\n    // calc time\n    int r_time;\n    int w_time;\n    if (other_sum >= R[max_r_i]) {\n        r_time = other_sum + R[max_r_i];\n        w_time = accumulate(ALL(W), 0);\n    } else {\n        r_time = R[max_r_i] * 2;\n\n        int T = R[max_r_i] - other_sum;\n        VI dp(N + 1);\n        for (int i = 0; i < N; i++) {\n            if (i == max_r_i) {\n                dp[i + 1] = dp[i];\n            } else {\n                int t = dp[i] + W[i];\n                if (t <= T) {\n                    dp[i + 1] = max({dp[i + 1], t, dp[i]});\n                }\n            }\n        }\n\n        int t = *max_element(ALL(dp));\n\n        w_time = accumulate(ALL(W), 0) - t;\n    }\n\n    return r_time + w_time;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        R = VI(N);\n        W = VI(N);\n\n        rep(i, N) {\n            cin >> R[i] >> W[i];\n        }\n\n        cout << solve() << endl;\n    }\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\nusing namespace std;\n\nint main(void){\n\tint N;\n\tint read[1000];\n\tint write[1000];\n\tbool dp[1001];\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)\n\t\t\treturn(0);\n\n\t\trep(i, 0, N)\n\t\t\tcin >> read[i] >> write[i];\n\n\t\tint read_sum = 0;\n\t\tint read_max = 0;\n\t\tint max_index = 0;\n\t\trep(i, 0, N){\n\t\t\tif (read[i] > read_max)\n\t\t\t\tread_sum += read_max,\n\t\t\t\tread_max = read[max_index = i];\n\t\t\telse\n\t\t\t\tread_sum += read[i];\n\t\t}\n\n\n\t\tint write_sum = 0;\n\t\trep(i, 0, N)\n\t\t\twrite_sum += write[i];\n\n\t\tint all_sum = read_max + read_sum + write_sum;\n\t\tint wait_space = read_max - read_sum;\n\t\tif (wait_space <= 0)\n\t\t\tcout << all_sum << endl;\n\t\telse{\n\t\t\trep(i, 0, wait_space + 1)\n\t\t\t\tdp[i] = false;\n\t\t\tdp[0] = true;\n\t\t\trep(i, 0, N)\n\t\t\tif (i!=max_index)\n\t\t\t\trev(j, write[i], wait_space + 1)\n\t\t\tif (dp[j - write[i]])\n\t\t\t\tdp[j] = true;\n\n\t\t\trev(i, 0, wait_space + 1)\n\t\t\tif (dp[i]){\n\t\t\t\tcout << ((wait_space)-i) + all_sum<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\nvector<pa> ve;\nint dp[1050][1050]={0};\n\nsigned main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tve.clear();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint rr,rrr;\n\t\t\tcin>>rr>>rrr;\n\t\t\tve.pb(mp(rr,rrr));\n\t\t}\n\t\tsort(ve.begin(),ve.end());\n\t\t\n\t\tint e1=ve[n-1].first,eall=0;\n\t\tfor(int i=0;i<n;i++)eall += ve[i].first;\n\t\tint wall=0;\n\t\tfor(int i=0;i<n;i++)wall += ve[i].second;\n\t\tif(e1*2<=eall){\n\t\t\tcout<<eall+wall<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint w=e1-(eall-e1);\n\t//\tcout<<\"w=\"<<w<<endl;\n\t\tfor(int i=0;i<1050;i++)for(int j=0;j<1050;j++) dp[i][j]=0;\n\t\tdp[0][0]=1;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint qw=ve[i].second;\n\t\t//\tcout<<\"qw= \"<<qw<<endl;\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tif(dp[i][j]==0) continue;\n\t\t\t\tdp[i+1][j]=1;\n\t\t\t\tif(j+qw<=w)dp[i+1][j+qw]=1;\n\t\t\t}\n\t\t}\n\t\tint s=0;\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tif(dp[n-1][j]==1) s=j;\n\t\t}\n\t\t//cout<<\"s= \"<<s<<endl;\n\t\t//cout<<\"wall \"<<wall<<endl;\n\t\tcout<<2*e1+wall-s<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstruct data{\n\tint r,w;\n\tdata(){}\n\tdata(int rr,int ww){\n\t\tr=rr;\n\t\tw=ww;\n\t}\n\tbool operator<(const data d1)const{\n\t\treturn r>d1.r;\n\t}\n};\nint n;\ndata dat[1005];\nbool dp[1005][2001];\n\nint main(void){\n\t\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint allr=0,allw=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d\",&dat[i].r,&dat[i].w);\n\t\t\tallr+=dat[i].r;\n\t\t\tallw+=dat[i].w;\n\t\t}\n\t\tsort(dat,dat+n);\n\t\tif(dat[0].r<=allr-dat[0].r){\n\t\t\tprintf(\"%d\\n\",allr+allw);\n\t\t}else{\n\t\t\tint wait=dat[0].r-(allr-dat[0].r);\n\t\t\tmemset(dp,false,sizeof(dp));\n\t\t\tdp[1][0]=true;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<=wait;j++){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\tdp[i+1][j]=true;\n\t\t\t\t\t\tdp[i+1][j+dat[i].w]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint val=0;\n\t\t\tfor(int i=0;i<=wait;i++){\n\t\t\t\tif(dp[n][i])val=i;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",dat[0].r*2+allw-val);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\npair<int, int>x[1000]; int n, a, b, s1, s2, dp[1100000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; s1 = 0; s2 = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> a >> b; x[i] = make_pair(a, b); s1 += a; s2 += b; }\n\t\tsort(x, x + n);\n\t\tif (x[n - 1].first * 2 <= s1) { cout << s1 + s2 << endl; }\n\t\telse {\n\t\t\tfor (int i = 0; i <= s2; i++)dp[i] = 0; dp[0] = 1;\n\t\t\tint nokori = x[n - 1].first - (s1 - x[n - 1].first);\n\t\t\tvector<int>f; f.push_back(0);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvector<int>g;\n\t\t\t\tfor (int a1 : f) {\n\t\t\t\t\tif (dp[a1 + x[i].second] == 0) { g.push_back(a1 + x[i].second); dp[a1 + x[i].second] = 1; }\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < g.size(); i++)f.push_back(g[i]);\n\t\t\t}\n\t\t\tint g = 0; for (int i = nokori; i >= 0; i--) { if (dp[i] == 1) { g = i; break; } }\n\t\t\tcout << (nokori - g) + s1 + s2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n#define whole(xs) xs.begin(), xs.end()\n\nint N;\nvector<int> r, w;\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    r.resize(N); w.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> r[i] >> w[i];\n    }\n    return true;\n}\n\nint sum(const vector<int>& v) {\n    int ret = 0;\n    for (int i = 0; i < v.size(); i++) ret += v[i];\n    return ret;\n}\n\nint dfs(int y) {\n    int INF = 1<<28;\n    int dp[y + 1]; \n    for (int i = 0; i <= y; i++) dp[i] = INF;\n    dp[0] = 0;\n    for (int i = 0; i <= y; i++) {\n        if (dp[i] == INF) continue;\n        for (int j = dp[i]; j < w.size(); j++) {\n            if (i + w[j] > y) continue;\n            dp[i + w[j]] = min(dp[i + w[j]], j + 1);\n        }\n    }\n    int ret = 0;\n    for (int i = 1; i <= y; i++) {\n        if (dp[i] < INF) ret = max(ret, i);\n    }\n    return ret;\n}\n\nint main() {\n    while (input()) {\n        int mr = *max_element(whole(r));\n        int sr = sum(r);\n        int sw = sum(w);\n        int x = sr - mr;\n        if (mr >= x) {\n            int index = max_element(whole(r)) - r.begin();\n            w.erase(w.begin() + index);\n            int y = mr - x;\n            cout << sr + sw + (y - dfs(y)) << endl;\n        } else {\n            cout << sr + sw << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\nint n,mi;\nint r,w[1001];\nint dp[1001][1001];\n\nint rec(int i, int j){\n\tif(dp[i][j] >= 0) return dp[i][j];\n\tint res;\n\tif(i==n) res = 0;\n\telse if(j < w[i] || i==mi) res = rec(i+1, j);\n\telse res = max(rec(i+1, j), rec(i+1, j-w[i]) + w[i]);\n\treturn dp[i][j] = res;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> n, n){\n\t\tint sr=0,sw=0,mr=0;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> r >> w[i];\n\t\t\tsr += r;sw += w[i];\n\t\t\tif(mr<r){\n\t\t\t\tmr = max(mr, r);\n\t\t\t\tmi = i;\n\t\t\t}\n\t\t}\n\t\tif(sr-mr < mr){\n\t\t\tint blank = mr - (sr-mr);\n\t\t\tcout << mr*2 + sw - rec(0, blank) << endl;\n\t\t}else cout << sr + sw << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n//\t\t\tbool cur[1001]={};\n\t\t\tbool *cur = (bool*)malloc( sizeof(bool)*(r0-r) );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool *next = (bool*)malloc( sizeof(bool)*(r0-r) );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> vp(n);\n    for(int i=0;i<n;i++) cin>>vp[i].first>>vp[i].second;\n    sort(vp.rbegin(),vp.rend());\n    int sum=0,res=0;\n    for(int i=0;i<n;i++) sum+=vp[i].first;\n    for(int i=0;i<n;i++) res+=vp[i].second;\n    if(sum<vp[0].first*2){\n      bool dp[1111];\n      memset(dp,0,sizeof(dp));\n      dp[0]=1;\n      for(int i=1;i<n;i++){\n\tfor(int j=1111;j>=vp[i].second;j--){\n\t  if(dp[j-vp[i].second]) dp[j]=1;\n\t}\n      }\n      int ans=0;\n      for(int i=0;i<=vp[0].first*2-sum;i++)\n\tif(dp[i]) ans=i;\n      cout<<vp[0].first*2+res-ans<<endl;\n    }else{\n      cout<<sum+res<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n;\n    while(cin >> n, n) {\n        vector<P> rw(n);\n        int allRead = 0, allWrite = 0;\n        rep(i, n) {\n            cin >> rw[i].fi >> rw[i].se;\n            allRead += rw[i].fi;\n            allWrite += rw[i].se;\n        }\n\n        sort(all(rw), greater<P>());\n        if (allRead >= 2 * rw[0].fi) {\n            cout << allRead + allWrite << endl;\n        } else {\n            int rest = 2 * rw[0].fi - allRead + 1;\n            bool dp[rest] = {true};\n            int maxi = 0;\n            repl(i, 1, rest) dp[i] = false;\n            repl(i, 1, n) {\n                repr(j, rest) {\n                    if (dp[j] && j + rw[i].se < rest) {\n                        dp[j + rw[i].se] = true;\n                        maxch(maxi, j + rw[i].se);\n                    }\n                }\n            }\n            cout << 2 * rw[0].fi + allWrite - maxi << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string.h>\n\nusing namespace std;\n\nint w[1100];\nint r[1100];\nbool dp[1100][1100];\nint used[1100];\n\n\n\nint main(void)\n{\n\tint n;\n\tint max;\n\tint maxr;\n\tint sumr,sumw;\n\tint dis;\n\n\tint i1,i2;\n\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\n\t\tmax=0;\n\t\tsumr=0;\n\t\tsumw=0;\n\t\tmaxr=-1;\n\n\t\tmemset(w,0,sizeof(w));\n\t\tmemset(r,0,sizeof(r));\n\n\t\tfor(i1=0;i1<n;i1++){\n\t\t\tcin>>r[i1]>>w[i1];\n\n\t\t\tif(max<r[i1]){\n\t\t\t\tsumr+=max;\n\t\t\t\tmax=r[i1];\n\t\t\t\tmaxr=i1;\n\t\t\t}\n\t\t\telse sumr+=r[i1];\n\n\t\t\tsumw+=w[i1];\n\t\t}\n\n\t\t//cout<<max<<\" \"<<sumr<<endl;\n\n\t\tif(sumr>=max) {\n\t\t\tsumr+=max;\n\t\t\tcout<<sumr+sumw<<endl;\n\t\t}\n\t\telse{\n\t\t\tdis=max-sumr;\n\n\t\t\tfor(i1=0;i1<1100;i1++){\n\t\t\t\tfor(i2=0;i2<1100;i2++){\n\t\t\t\t\tdp[i1][i2]=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(w[0]<=dis && 0!=maxr) dp[0][w[0]]=true;\n\n\t\t\tfor(i1=1;i1<n;i1++){\n\t\t\t\tfor(i2=0;i2<=dis;i2++){\n\t\t\t\t\tif(dp[i1-1][i2]==true){\n\t\t\t\t\t\tdp[i1][i2]=true;\n\t\t\t\t\t\tif((i2+w[i1])<=dis && i1!=maxr) dp[i1][i2+w[i1]]=true;\t\n\t \t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(w[i1]<=dis && i1!=maxr) dp[i1][w[i1]]=true;\n\t\t\t}\n\n\t\t\tfor(i1=dis;i1>0;i1--){\n\t\t\t\tif(dp[n-1][i1]==true) break;\n\t\t\t}\n\t\t\t//cout<<dis<<\" \"<<i1<<\" \"<<sumr+sumw+max<<endl;\n\t\t\tdis-=i1;\n\n\t\t\tcout<<sumr+sumw+dis+max<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[1005],b[1005],S,ret;\nvoid honshitsu(){\n\tbool dp[1005]={}; dp[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i] == *max_element(a+1,a+n+1)) continue;\n\t\tfor(int j=1000;j>=0;j--){\n\t\t\tif(j >= a[i] && dp[j-a[i]]){\n\t\t\t\tdp[j] = 1;\n\t\t\t}\n\t\t\tif(j >= a[i]+b[i] && dp[j-a[i]-b[i]]){\n\t\t\t\tdp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint j = 0;\n\tfor(int i=*max_element(a+1,a+n+1);i>=0;i--){\n\t\tif(!dp[i]){\n\t\t\tj++; continue;\n\t\t}\n\t\tcout << ret+j << endl;\n\t\treturn;\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcin >> n; if(!n) return 0;\n\t\tS = 0,ret = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tS += a[i]; ret += a[i]+b[i];\n\t\t}\n\t\tbool x = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(a[i] * 2 > S){\n\t\t\t\thonshitsu(); x = 1; break;\n\t\t\t}\n\t\t}\n\t\tif(!x) cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <int> dp(gap + 1, 0);\n        dp[0] = true;\n        range (i, 1, n + 1) {\n            if (r.back() == copyR[i - 1]) {\n                continue;\n            }\n            for(int j=gap;j>=0;j--){\n                if (j - w[i - 1] < 0) continue;\n                dp[j] |= dp[j - w[i - 1]];\n            }\n        }\n        int maxJ = 0;\n        rep (j, gap + 1) if (dp[j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nvector<pair<int,int> >vec;\nbool com(pair<int,int>p1, pair<int,int>p2){\n    return p1.first>p2.first;\n}\nint main()\n{\n    int N;\n    while(cin>>N,N){\n        vec.clear();\n        for(int i=0;i<N;i++){\n            int r,w;\n            cin>>r>>w;\n            vec.push_back(make_pair(r,w));\n        }\n        sort(vec.begin(),vec.end(),com);\n        int tot=0;\n        for(int i=1;i<vec.size();i++)\n            tot+=vec[i].first;\n        int ans=0;\n        for(int i=0;i<vec.size();i++){\n            ans+=vec[i].first;\n            ans+=vec[i].second;\n        }\n        if(vec[0].first>tot){\n            int left=vec[0].first-tot;\n            int dp[1001];\n            memset(dp,0,sizeof(dp));\n            dp[0]=1;\n            int m=10000;\n            for(int i=1;i<N;i++){\n                for(int j=left;j>=vec[i].second;j--){\n                    dp[j]|=dp[j-vec[i].second];\n                    if(dp[j])\n                        m=min(m,left-j);\n                }\n            }\n            ans+=m;\n        }\n        else{\n            \n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<int,int> P;\nbool dp[1001][1001];\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tvector<P> vc;\n\t\trep(i,N){\n\t\t\tint r,w;\n\t\t\tcin>>r>>w;\n\t\t\tvc.pb(P(r,w));\n\t\t}\n\t\tsort(all(vc));\n\t\tint elsum=0,mx=vc[N-1].fs;\n\t\trep(i,N-1) elsum+=vc[i].fs;\n\t\tif(elsum>=mx){\n\t\t\tint ans=0;\n\t\t\trep(i,N) ans+=vc[i].fs+vc[i].sc;\n\t\t\tcout<<ans<<endl;\n\t\t}else{\n\t\t\tint ans=mx*2;\n\t\t\tint left=mx-elsum;\n\t\t\trep(i,N) rep(j,left+1) dp[i][j]=0;\n\t\t\tdp[0][0]=true;\n\t\t\trep(i,N-1){\n\t\t\t\trep(j,left+1){\n\t\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\t\tdp[i+1][j]=1;\n\t\t\t\t\tif(j+vc[i].sc<=left) dp[i+1][j+vc[i].sc]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint can=0;\n\t\t\trep(i,left+1) if(dp[N-1][i]) can=i;\n\t\t\tint wsum=0;\n\t\t\trep(i,N) wsum+=vc[i].sc;\n\t\t\tcout<<ans+wsum-can<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int r, w;\n    bool operator<(const Data& d) const{\n        return r < d.r;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Data> d(n);\n        int rSum = 0;\n        int wSum = 0;\n        for(int i=0; i<n; ++i){\n            cin >> d[i].r >> d[i].w;\n            rSum += d[i].r;\n            wSum += d[i].w;\n        }\n        sort(d.rbegin(), d.rend());\n\n        if(2 * d[0].r <= rSum){\n            cout << (rSum + wSum) << endl;\n            continue;\n        }\n\n        int t = 2 * d[0].r - rSum;\n        vector<bool> dp(t+1, false);\n        dp[0] = true;\n        for(int i=1; i<n; ++i){\n            for(int j=t; j>=d[i].w; --j){\n                if(dp[j-d[i].w])\n                    dp[j] = true;\n            }\n        }\n\n        while(!dp[t])\n            -- t;\n\n        int ret = d[0].r * 2 + (wSum - t);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\ntypedef long long ll;\nint dp[1000][1000] = {0};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tint r[1000];\n\t\tint w[1000];\n\t\tint rsum = 0, rmax = 0, wsum = 0, rmaxid;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tif (rmax < r[i])\n\t\t\t{\n\t\t\t\trmax = r[i];\n\t\t\t\trmaxid = i;\n\t\t\t}\n\t\t\trsum += r[i];\n\t\t\twsum += w[i];\n\t\t}\n\t\tif (rmax * 2 <= rsum)\n\t\t{\n\t\t\tcout << rsum + wsum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint m = rmax * 2 - rsum;\n\t\tif (m >= wsum - w[rmaxid])\n\t\t{\n\t\t\tcout << rmax * 2 + w[rmaxid] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rmaxid)\n\t\t\tfor (int i = w[0]; i <= m; i++)\n\t\t\t\tdp[0][i] = w[0];\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (rmaxid == i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= m; ++j)\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j <= m; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], (j >= w[i]) ? dp[i - 1][j - w[i]] + w[i] : 0);\n\t\t\t}\n\t\t\tif (dp[i][m] == m)\n\t\t\t{\n\t\t\t\tdp[n - 1][m] = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << rmax * 2 + wsum - dp[n - 1][m] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n\nusing namespace std;\n\nint r[1001], w[1001];\nbool dp[1001];\n\nint w_book(int wait, int n) {\n\t\n\tint j_max = 0;\n\tdp[0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = wait; j >= w[i]; j--) {\n\t\t\tif (dp[j - w[i]]) {\n\t\t\t\tdp[j] = 1;\n\t\t\t\tif (j > j_max) j_max = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn j_max;\n}\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\tint n;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tr[i] = 0;\n\t\t\tw[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\n\t\tint time = 0;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t}\n\t\tsort(r + 1, r + n + 1);\n\t\tsort(w + 1, w + n + 1);\n\t\tint r_total = 0, w_total = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr_total += r[i];\n\t\t\tw_total += w[i];\n\t\t}\n\t\tif (r[n] <= r_total - r[n]) time = r_total + w_total;\n\t\telse time = 2 * r[n] + w_total - w_book(r[n] - (r_total - r[n]), n);\n\n\t\tcout << time << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<pair<int, int> > rw(n);\n\t\tint rsum=0, wsum=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint r,w;\n\t\t\tcin >> r >> w;\n\t\t\trsum += r;\n\t\t\twsum += w;\n\t\t\trw[i] = make_pair(r, w);\n\t\t}\n\t\tsort(rw.begin(), rw.end());\n\t\tif(2*rw[n-1].first > rsum){\n\t\t\tint t = 2*rw[n-1].first -rsum;\n\t\t\tvector<bool> dp(t+1, false);\n\t\t\tdp[0] = true;\n\t\t\tfor(int i=0; i<n-1; i++){\n\t\t\t\tfor(int j=t-1; j>=0; j--){\n\t\t\t\t\tif(dp[j] && j+rw[i].second <= t){\n\t\t\t\t\t\tdp[j+rw[i].second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mintime=0;\n\t\t\tfor(int i=0; i<t; i++){\n\t\t\t\tif(dp[i]) mintime=i;\n\t\t\t}\n\t\t\tcout << rsum + t + wsum -mintime << endl;\n\t\t}else{\n\t\t\tcout << rsum +wsum << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint dp[1010][3010] = {};\n\nsigned main(void) {\n    int n;\n    while(cin >> n,n){\n        vp v(n);\n        rep(i,n)cin >> v[i].first >> v[i].second;\n        sort(all(v));\n        int sumr = 0, sumw = 0;\n        rep(i,n){\n            sumr += v[i].first;\n            sumw += v[i].second;\n        }\n        int ma = v.back().first;\n        if(ma <= sumr - ma){\n            cout << sumr + sumw << endl;\n        }else{\n            rep(i,1010)rep(j,3010)dp[i][j] = 0;\n            dp[0][0] = 1;\n            int MAX = 2*ma-sumr+1;\n            rep(i,n)rep(j,MAX){\n                dp[i+1][j] += dp[i][j];\n                if(j+v[i].second < MAX && i < n-1){\n                    dp[i+1][j+v[i].second] += dp[i][j];\n                }\n            }\n            int tmp = -1;\n            rep(i,MAX)if(dp[n][i])tmp = max(tmp, i);\n            cout << ma*2 + sumw - tmp << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint n;\nP book[1001];\n\nint solve(){\n  int sumf=0,sums=0;\n  for(int i=0;i<n;i++)sumf+=book[i].f,sums+=book[i].s;\n  if(2*book[0].f<=sumf)return sumf+sums;\n  int d=2*book[0].f-sumf,dp[3000]={1},D=d;\n  for(int i=1;i<n;i++)\n    for(int j=d-book[i].s;j>=0;j--) dp[j+book[i].s]|=dp[j];\n  while(!dp[D])D--;\n  return sumf+sums+(d-D);\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>book[i].f>>book[i].s;\n    sort(book,book+n,greater<P>());\n    cout <<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint N;\npii rw[1001];\nbool dp[1001];\nint r[1001], w[1001];\n\nint main() {\n    while(cin>>N, N) {\n        for (int i=0; i<N; ++i) {\n            int a,b; cin>>a>>b;\n            rw[i] = make_pair(a,b);\n        }\n        sort(rw, rw+N, greater<pii>());\n        for (int i=0; i<N; ++i) r[i] = rw[i].first, w[i] = rw[i].second;\n\n        int sum = 0;\n        for (int i=1; i<N; ++i) sum += r[i];\n        if (sum >= r[0]) {\n            sum += r[0];\n            for (int i=0; i<N; ++i) sum += w[i];\n            cout<<sum<<endl;\n            continue;\n        }\n\n        int rem = r[0] - sum;\n        memset(dp, false, sizeof(dp));\n        dp[0] = true;\n        for (int i=1; i<N; ++i) {\n            for (int p=rem; p>=0; --p)\n                if (dp[p] && p + w[i] <= rem) dp[p+w[i]] = true;\n        }\n\n        int mx = -1;\n        for (int p=rem; p>=0; --p)\n            if (dp[p]) { mx = p; break; }\n\n        int ans = r[0] * 2;\n        for (int i=0; i<N; ++i) ans += w[i];\n        ans -= mx;\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<pii> v;\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> v[i].fi >> v[i].se;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint sum = 0;\n\t\tint res = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tsum += v[i].fi;\n\t\t\tres += v[i].fi + v[i].se;\n\t\t}\n\t\t//cout << sum << \" \" << v.back().fi << endl;\n\t\tif(v.back().fi*2 > sum) {\n\t\t\tint dp[1100] = {};\n\t\t\tint tmp = 0;\n\t\t\tdp[0] = 1;\n\t\t\tfor(int i = 0; i < v.size()-1; i++) {\n\t\t\t\tfor(int j = 1099; j >= 0; j--) {\n\t\t\t\t\tif(j + v[i].se < 1100 && dp[j]) {\n\t\t\t\t\t\tdp[j+v[i].se] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += v[i].fi;\n\t\t\t}\n\t\t\tfor(int i = v.back().fi - tmp; i >= 0; i--) {\n\t\t\t\tif(dp[i]) {\n\t\t\t\t\tres += (v.back().fi-tmp) - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) c.begin(),c.end()\n\n\nint N,M;\nint r[1010],w[1010];\nbool dp[2][1010*1010];\nint sum;\n\nbool check(){\n\tsum=0;\n\tfor(int i=0;i<N;i++){\n\t\tsum+=r[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(sum<r[i]*2) return false;\n\t}\n\treturn true;\n}\n\nint ub;\n\nint solve2(){\n\tfor(int i=0;i<2;i++) for(int j=0;j<1010*1010;j++){\n\t\tdp[i][j]=false;\n\t}\n\tint t=0;\n\tdp[0][0]=true;\n\tub=-1;\n\tfor(int i=0;i<N;i++){\n\t\tif(sum<r[i]*2){\n\t\t\tub=r[i]*2-sum;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<1010*1010;j++){\n\t\t\tif(dp[t][j]==false) continue;\n\t\t\tint nj=j+w[i];\n\t\t\tif(nj>=1010*1010) continue;\n\t\t\tdp[1^t][nj]=true;\n\t\t\tdp[1^t][j]=true;\n\t\t}\n\t\tt^=1;\n\t}\n\tfor(int i=ub;i>=0;i--){\n\t\tif(dp[t][i]) return ub-i;\n\t}\n\treturn -1;\n}\n\nint solve(){\n\tbool flg=check();\n\tif(flg){\n\t\tint res=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tres+=w[i];\n\t\t\tres+=r[i];\n\t\t}\n\t\treturn res;\n\t}\n\tint tmp=solve2();\n\tint res=0;\n\tfor(int i=0;i<N;i++){\n\t\tres+=w[i];\n\t\tres+=r[i];\n\t}\n\tres+=tmp;\n\treturn res;\n}\n\nvoid input(){\n\tscanf(\"%d\",&N);\n\tif(N==0) exit(0);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d\",r+i,w+i);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tinput();\n\t\tint ans=solve();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e14+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nbool solve(void){\n\tint n,i,rwa=0,wwa=0;cin>>n;\n\tif(n==0){return false;}\n\tvector<pair<int,int>>hon(n);\n\tfor(i=0;i<n;i++){cin>>hon[i].fir>>hon[i].sec;rwa+=hon[i].fir;wwa+=hon[i].sec;}\n\tSO(hon);REV(hon);\n\tif(hon[0].fir*2<=rwa){cout<<rwa+wwa<<endl;return true;}\n\t//ロスタイム計測\n\tint w=hon[0].fir*2-rwa;//これだけの空き時間\n\tbitset<1001>dp=0;\n\tdp[0]=1;\n\tfor(i=1;i<n;i++){dp|=(dp<<hon[i].sec);}\n\tint ros=0;\n\tfor(i=w;i>=0;i--){if(dp[i]){ros=w-i;break;}}\n\tcout<<rwa+wwa+ros<<endl;\n\t\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\tcin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint dp[1000];\n\nint main()\n{\n    int n;\n    while(scanf(\" %d\", &n),n)\n    {\n        vector<pi> p(n);\n        rep(i,n) scanf(\" %d %d\", &p[i].fi, &p[i].se);\n        sort(all(p));\n\n        if(n==1)\n        {\n            printf(\"%d\\n\", p[0].fi*2+p[0].se);\n            continue;\n        }\n\n        int sum_r=0;\n        rep(i,n) sum_r+=p[i].fi;\n\n        if(sum_r - p[n-1].fi >= p[n-1].fi)\n        {\n            // 2?????¨???sum_r??§???????????????\n            int ans=sum_r;\n            rep(i,n) ans+=p[i].se;\n            printf(\"%d\\n\", ans);\n        }\n        else\n        {\n            // 2*p[n-1].fi???????????????\n            memset(dp,0,sizeof(dp));\n\n            // 0~n-2?????????????????¨??????????????????????????????\n            int rem = p[n-1].fi - (sum_r-p[n-1].fi);\n\n            // n-1?????????????????????????????????????????¢???\n            dp[0]=1;\n            rep(i,n-1)\n            {\n                for(int j=rem; j>=0; --j)if(dp[j]) dp[j+p[i].se]=1;\n            }\n\n            int ok=0;\n            rep(i,rem+1)if(dp[i]) ok=i;\n\n            int sum_w=0;\n            rep(i,n) sum_w+=p[i].se;\n\n            printf(\"%d\\n\", 2*p[n-1].fi+sum_w-ok);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int, int>P;\n\nint main(){\n\n    for(int n;cin>>n,n;){\n        vector<P>books(n);\n        int rSum = 0, wSum = 0;\n        for(int i=0;i<n;i++){\n            cin >> books[i].first;\n            cin >> books[i].second;\n            rSum += books[i].first;\n            wSum += books[i].second;\n        }\n        sort(books.begin(), books.end(), greater<P>());\n        if(books[0].first >= (rSum - books[0].first)){\n            int w = books[0].first - (rSum - books[0].first);\n            vector<int>dp(w+1, 0);\n            dp[0]=1;\n            int mx = 0;\n            for(int i=1;i<n;i++){\n                int v = books[i].second;\n                for(int j=w;j>=0;j--){\n                    if(dp[j]==0)continue;\n                    if(v+j>w)continue;\n                    dp[v+j]=1;\n                    mx = max(mx, v+j);\n                }\n            }\n            cout<<books[0].first*2+wSum-mx<<endl;\n        }\n        else{\n            cout<<rSum+wSum<<endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510&lang=jp\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N;\n\twhile (cin >> N, N) {\n\t\tvector<pll> rw(N);\n\t\tfor (int i = 0; i < N;i++)cin >> rw[i].first >> rw[i].second;\n\t\tsort(rw.begin(), rw.end());\n\t\tll sum = 0;\n\t\tfor (int i = 0; i < N - 1;i++)sum += rw[i].first;\n\t\tif (rw[N - 1].first <= sum) {\n\t\t\tll ans = 0; ans = sum + rw[N - 1].first;\n\t\t\tfor (int i = 0;i < N;i++) ans += rw[i].second;\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tvector<vector<ll>> dp(N, vector<ll>(rw[N - 1].first - sum + 1, 0));\n\t\t\tdp[0][0] = 1;\n\t\t\tll max_impress = 0;\n\t\t\tfor (int i = 0; i < N-1;i++) {\n\t\t\t\tfor (int t = 0; t <= rw[N - 1].first - sum;t++) {\n\t\t\t\t\tif (dp[i][t] != 1) continue;\n\t\t\t\t\tdp[i + 1][t] = dp[i][t];\n\t\t\t\t\tif (t + rw[i].second <= rw[N - 1].first - sum) {\n\t\t\t\t\t\tdp[i + 1][t + rw[i].second] = 1;\n\t\t\t\t\t\tmax_impress = max(max_impress, t + rw[i].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll ans = 0; ans = sum + rw[N - 1].first;\n\t\t\tfor (int i = 0;i < N;i++) ans += rw[i].second;\n\t\t\tans += (rw[N - 1].first - sum - max_impress);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define ll long long\n#define fi first\n#define fs first\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n \nint n;\nvec dp;\n \nvoid solve() {\n    vector<P> a(n);\n    int sum1 = 0, sum2 = 0;\n    REP(i, n) cin >> a[i].fs >> a[i].sc, sum1 += a[i].fs, sum2 += a[i].sc;\n \n    sort(a.begin(), a.end());\n \n    if (sum1 >= a.back().fs * 2) {\n        cout << sum1 + sum2 << endl;\n        return;\n    }\n \n    int k = a.back().fs * 2 - sum1;\n    vec dp(k + 1, 0);\n    dp[0] = 1;\n \n    REP(i, n - 1) {\n        RREP(j, k) {\n            if (j + a[i].sc <= k) dp[j + a[i].sc] |= dp[j];\n        }\n    }\n \n    int mx = 0;\n    REP(i, k + 1) if (dp[i]) mx = i;\n \n    cout << a.back().fs * 2 + sum2 - mx << endl;\n}\n \nint main() {\n    while (cin >> n, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint r[1001], w[1001];\nint time;\nbool dp[1001] = { 0 };\n\nint w_book(int wait, int n, int r_max) {\n\tint i_max = 0;\n\tdp[0] = 1;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != r_max || cnt > 0) {\n\t\t\tfor (int j = wait; j >= w[i]; j--) {\n\t\t\t\tdp[j] = dp[j - w[i]];\n\t\t\t\tif (dp[j]) {\n\t\t\t\t\tif (i_max < j) i_max = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse cnt++;\n\t}\n\treturn i_max;\n}\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < 1001; i++) {\n\t\tcin >> r[i] >> w[i];\n\t}\n\tint r_max = 0;\n\tint r_total = 0, w_total = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (r_max < r[i]) r_max = r[i];\n\t\tr_total += r[i];\n\t\tw_total += w[i];\n\t}\n\tif (r_max <= r_total - r_max) time = r_total + w_total;\n\telse time = 2 * r_max + w_total - w_book(r_max - (r_total - r_max), n, r_max);\n\n\tcout << time << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = max(min(maxsum, N-as[i]), 0);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nP t[1000];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    int sum=0,sum2=0;\n    for(int i=0;i<n;i++){\n      cin>>t[i].first>>t[i].second;\n      sum+=t[i].first;\n      sum2+=t[i].second;\n    }\n    sort(t,t+n);\n    int X=sum-t[n-1].first;\n    if(t[n-1].first<=X){\n      cout<<sum+sum2<<endl;\n      continue; \n    }\n    int Y=t[n-1].first-X;\n    int dp[1002]={};\n    for(int i=0;i<n-1;i++){\n      int se=t[i].second;\n      for(int j=Y;j>=se;j--)\n        dp[j]=max(dp[j],dp[j-se]+se);\n    }\n    cout<<t[n-1].first*2+sum2-dp[Y]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct edge{\n  int to;\n  int cost;\n  edge(){}\n  edge(int t,int c){\n    to=t;\n    cost=c;\n  }\n};\n\nint N,M;\npii hs[201];\nvector<edge> G[201];\nbool noNode[201];\n\nint makeMST(int st){\n  int sumCost=0;\n  priority_queue<pii,vector<pii>,greater<pii> > pq;\n  bool used[201]={};\n  pq.push(pii(0,st));\n  while(pq.size()){\n    pii p=pq.top();pq.pop();\n    if(used[p.second])continue;\n    used[p.second]=true;\n    sumCost+=p.first;\n    for(int i=0;i<(int)G[p.second].size();i++){\n      edge &e=G[p.second][i];\n      if(used[e.to])continue;\n      pq.push(pii(e.cost,e.to));\n    }\n  }\n  for(int i=0;i<N;i++)\n    if(!used[i])return -1;\n  return sumCost;\n}\n\nint main(){\n\n  while(cin>>N>>M&&(N|M)){\n    map<int,vector<int> > m;\n    for(int i=0;i<N;i++){\n      G[i].clear();\n      cin>>hs[i].first;\n      hs[i].second=i;\n      m[hs[i].first].push_back(i);\n    }\n    //sort(hs,hs+N);\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      G[a].push_back(edge(b,c));\n      G[b].push_back(edge(a,c));\n    }\n    memset(noNode,0,sizeof(noNode));\n    int idx=-1;\n    // どのノードまで使えるか\n    for(int i=0;i<=N;i++){\n      //makeMST(hs[i].second);\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n\t\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool cur[1001]={};\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n\t\t\t\tbool next[1001]={};\n                for(int j=0;j<1000;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<1000)\n                            next[j+w[i]]=true; \n                    }\n                }\n\t\t\t\tswap(cur,next);\n            }\n  \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nint N;\nvector<int> R;\nvector<int> W;\nint memo[1010][1010];\n\nint rec(int pos, int rest){\n  if (pos == N){\n    return rest;\n  }\n\n  if (memo[pos][rest] != -1){\n    return memo[pos][rest];\n  }\n\n  int &res = memo[pos][rest] = rest;\n\n  if (rest - R[pos] >= 0){\n    res = min(res, rec(pos + 1, rest - R[pos]));\n  }\n\n  if (rest - R[pos] - W[pos] >= 0){\n    res = min(res, rec(pos + 1, rest - R[pos] - W[pos]));\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  while (cin >> N && N){\n    R = vector<int>(N);\n    W = vector<int>(N);\n    REP(i, N){\n      cin >> R[i] >> W[i];\n    }\n\n    REP(i, N) REP(j, N - 1){\n      if (R[j] < R[j + 1]){\n        swap(R[j], R[j + 1]);\n        swap(W[j], W[j + 1]);\n      }\n    }\n\n    if (R[0] * 2 <= accumulate(ALL(R), 0)){\n      cout << accumulate(ALL(R), 0) + accumulate(ALL(W), 0) << endl;\n    } else {\n      memset(memo, -1, sizeof(memo));\n      cout << accumulate(ALL(R), 0) + accumulate(ALL(W), 0) + rec(1, R[0]) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint sum = 0, mx=0, ans=0;\n\t\tvector<pair<int,int> > v;\n\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tans += r + w;\n\t\t}\n\n\t\tsort( v.begin(), v.end() );\n\t\tmx = v.back().first;\n\t\tv.pop_back();\n\n\t\tint dp[1005]={};\n\t\tdp[0] = true;\n\t\tfor(auto t: v){\n\t\t\tfor(int j=1000; j>=0; j--){\n\t\t\t\tif( j+t.second >= 0 ){\n\t\t\t\t\tdp[j+t.second] |= dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tmp = max(0, 2*mx - sum);\n\t\trep(i,1000){\n\t\t\tif( dp[tmp-i] ){\n\t\t\t\tans += i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint main(){\n\t\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint r[1100], w[1100], r_sum = 0, w_sum = 0;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tr_sum += r[i];\n\t\t\tw_sum += w[i];\n\t\t}\n\t\t\n\t\tbool flag = true;\n\t\tint pos, rem;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(r[i] * 2 > r_sum){\n\t\t\t\tpos = i;\n\t\t\t\trem = 2 * r[i] - r_sum;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag){\n\t\t\tcout << r_sum + w_sum << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tbool DP[1100] = {};\n\t\tDP[0] = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == pos){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = rem; j >= w[i]; j--){\n\t\t\t\tDP[j] |= DP[j - w[i]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j = rem; j >= 0; j--){\n\t\t\tif(DP[j]){\n\t\t\t\tcout << r_sum + w_sum + rem - j << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nsigned main(){\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> r(n);\n        vector<int> w(n);\n        vector<pair<int, int>> vec(n);\n        for(int i = 0; i < n; i++){\n            cin >> r[i] >> w[i];\n            vec[i] = pair<int, int>(r[i], w[i]);\n        }\n\n        sort(vec.begin(), vec.end());\n    \n        int longest = vec[n - 1].first;\n        int sumOfOthers = 0;\n        for(int i = 0; i < n - 1; i++) sumOfOthers += vec[i].first;\n\n        int ans = 0;\n        for(int i = 0; i < n; i++) ans += vec[i].first + vec[i].second;\n        \n        if(longest <= sumOfOthers){\n            // みっちりやる\n        }else{\n            int rest = longest - sumOfOthers;\n            vector<int> v(n - 1);\n            for(int i = 0; i < n - 1; i++) v[i] = vec[i].second;\n\n            ans += rest;\n\n            vector<vector<bool>> dp(n, vector<bool> (rest + 1, false));\n            dp[0][0] = true;\n            for(int i = 0; i < n - 1; i++){\n                for(int j = 0; j <= rest; j++){\n                    if(!dp[i][j]) continue;\n                    int nj = j + v[i];\n                    dp[i + 1][j] = true;\n                    if(nj <= rest) dp[i + 1][nj] = true;\n                }\n            }\n\n            int val = 0;\n            for(int j = 0; j <= rest; j++) if(dp[n - 1][j]) val = j;\n            ans -= val;\n        }\n        cout << ans << endl;\n        \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i = (bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\nstruct cww {\n\tcww() {\n\t\tios::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t}\n}star;\ntemplate<typename T>\nistream & operator>> (istream &is, vector<T>&v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int, int> P;\nconst int INF = 1e7;\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<P> rw(n);\n\t\tREP(i, n)cin >> rw[i].fi >> rw[i].se;\n\t\tsort(ALL(rw));\n\t\treverse(ALL(rw));\n\t\tint rsum = 0;\n\t\tint wsum = 0;\n\t\tREP(i, n) {\n\t\t\trsum += rw[i].fi;\n\t\t\twsum += rw[i].se;\n\t\t}\n\t\tif (rw.front().first * 2 <= rsum) {\n\t\t\tcout << rsum + wsum << endl;\n\t\t}\n\t\telse {\n\t\t\tint rest = rw.front().first * 2 - rsum;\n\t\t\tvector<int> dp(rest + 1, 0);\n\t\t\tdp[0] = 1;\n\t\t\tFOR(i, 1, n) {\n\t\t\t\tfor (int j = rest; j >= rw[i].se; j--) {\n\t\t\t\t\tdp[j] |= dp[j - rw[i].se];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tREP(i, rest + 1)if (dp[i])ans = i;\n\t\t\tcout << rest - ans + rsum + wsum << endl;\n\t\t}\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, r[1009], w[1009]; bool dp[1009];\nint main() {\n\twhile (cin >> n, n) {\n\t\tint sumr = 0, sumw = 0, maxr = 0, maxptr = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsumr += r[i];\n\t\t\tsumw += w[i];\n\t\t\tif (r[i] >= r[maxptr]) {\n\t\t\t\tmaxptr = i;\n\t\t\t\tmaxr = r[i];\n\t\t\t}\n\t\t}\n\t\tif (maxr * 2 <= sumr) {\n\t\t\tcout << sumr + sumw << endl;\n\t\t}\n\t\telse {\n\t\t\tfill(dp, dp + maxr * 2 - sumr + 1, false); dp[0] = true;\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxptr) continue;\n\t\t\t\tfor (int j = maxr * 2 - sumr; j >= w[i]; j--) {\n\t\t\t\t\tif (dp[j - w[i]]) {\n\t\t\t\t\t\tdp[j] = true;\n\t\t\t\t\t\tres = max(res, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << max(maxr * 2 + sumw - res, maxr * 2) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\n\nint solve(vector<pii> v){\n\t\n\tsort(v.begin(), v.end());\n\t\n\tint rl, rs = 0, ws = 0;\n\tbool dp[1010] = {0};\n\t\n\trl = v[N-1].first;\n\t\n\tfor(int i=0; i<N; ++i){\n\t\trs += v[i].first;\n\t\tws += v[i].second;\n\t}\n\t\n\trs -= rl;\n\t\n\tif(rs >= rl){\n\t\treturn rs + rl + ws;\n\t}\n\t\n\tdp[0] = true;\n\t\n\tfor(int i = 0; i < N-1; ++i){\n\t\tfor(int j=rl-rs; j >=0; --j){\n\t\t\t\n\t\t\tif( dp[j] && j + v[i].second <= rl - rs )\n\t\t\t\tdp[j + v[i].second] = true;\n\t\t\t\t\n\t\t}\n\t}\n\t\n\tfor(int i = rl - rs; i >= 0; --i){\n\t\n\t\tif(dp[i])\n\t\t\treturn 2*rl + ws - i;\n\t}\n}\n\nint main(){\n\t\n\twhile(cin>>N, N){\n\t\t\n\t\tvector<pii> v;\n\t\tint r, w;\n\t\t\n\t\tfor(int i=0; i<N; ++i){\n\t\t\t\n\t\t\tcin >> r >> w;\n\t\t\tv.push_back(make_pair(r, w));\n\t\t}\n\t\t\n\t\tcout << solve(v) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector <int> r, w;\n\t\tr = w = vector <int> (n);\n\t\tint sumR = 0, sumW = 0;\n\t\trep (i, n) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsumR += r[i];\n\t\t\tsumW += w[i];\n\t\t}\n\n\t\tvector <int> copyR = r;\n\t\tsort(r.begin(), r.end());\n\n\t\tif (sumR >= 2*r.back()) {\n\t\t\tcout << sumR + sumW << endl;\n\t\t} else {\n\t\t\tint gap = r.back() - (sumR - r.back());\n\t\t\tvector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n\t\t\tdp[0][0] = true;\n\t\t\tw.erase(w.begin() + (copyR.begin() - find(copyR.begin(), copyR.end(), r.back())));\n\t\t\trange (i, 1, n) {\n\t\t\t\trep (j, gap + 1) {\n\t\t\t\t\tif (j - w[i - 1] < 0) continue;\n\t\t\t\t\tdp[i][j] |= dp[i - 1][j - w[i-1]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint maxJ = 0;\n\t\t\trep (i, n + 1) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n\t\t\tcout << 2*r.back() + sumW - maxJ << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<pair<ll, ll>> rw(n);\n\t\tREP(i, n) cin >> rw[i].first >> rw[i].second;\n\t\tsort(ALL(rw)); reverse(ALL(rw));\n\t\tll sum = 0; FOR(i, 1, n) sum += rw[i].first;\n\t\tif (rw[0].first <= sum) {\n\t\t\tll sum2 = 0; REP(i, n) sum2 += rw[i].second;\n\t\t\tcout << sum + rw[0].first + sum2 << endl;\n\t\t} else {\n\t\t\tll rest = rw[0].first - sum;\n\n\t\t\tvvb dp(n+1, vb(rest + 1, false)); dp[0][0] = true;\n\t\t\tFOR(i, 1, n) REP(j, rest + 1) {\n\t\t\t\tif (j + rw[i].second < rest + 1) {\n\t\t\t\t\tdp[i][j + rw[i].second] = dp[i][j + rw[i].second] | dp[i - 1][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j] = dp[i][j] | dp[i - 1][j];\n\t\t\t}\n\t\t\tfor (ll i = rest; i >= 0; --i) if (dp[n-1][i]) {\n\t\t\t\tll sum2 = 0; REP(i, n) sum2 += rw[i].second;\n\t\t\t\tcout << sum + rw[0].first + sum2 + (rest - i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Book {\n    int r, w;\n};\n\nint main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<Book> book(N);\n\n        int max_idx = 0, max_r = -1, sum_r = 0, sum_w = 0;\n        for (int i = 0; i < N; ++i) {\n            cin >> book[i].r >> book[i].w;\n\n            if (book[i].r > max_r) {\n                max_idx = i;\n                max_r = book[i].r;\n            }\n            sum_r += book[i].r;\n            sum_w += book[i].w;\n        }\n\n        sum_r -= max_r;\n\n        if (sum_r >= max_r) {\n            cout << sum_r + max_r + sum_w << '\\n';\n        }\n        else {\n            int wait_time = max_r - sum_r;\n            vector<vector<bool>> dp(N + 1, vector<bool>(wait_time + 1, false));\n\n            dp[0][0] = true;\n\n            if (max_idx != N - 1)\n                swap(book[max_idx], book[N - 1]);\n            --N;\n\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j <= wait_time; ++j) {\n                    if (!dp[i][j])\n                        continue;\n                    dp[i + 1][j] = true;\n                    if (j + book[i].w <= wait_time)\n                        dp[i + 1][j + book[i].w] = true;\n                }\n            }\n\n            int max_write = 0;\n            for (int i = 0; i <= wait_time; ++i)\n                if (dp[N][i])\n                    max_write = i;\n\n            cout << 2 * max_r + (sum_w - max_write) << '\\n';\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int> r(N);\n\t\tvector<int> w(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t}\n\t\tint sum = 0;\n\t\tint sum2 = 0;\n\t\tint mx = -1;\n\t\tint mxi = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tsum += r[i];\n\t\t\tsum2 += w[i];\n\t\t\tif (mx < r[i]) {\n\t\t\t\tmx = r[i];\n\t\t\t\tmxi = i;\n\t\t\t}\n\t\t}\n\t\t//cerr << sum << \" \" << mxi << endl;\n\t\tif (mx * 2 > sum) {\n\t\t\tint t = mx - (sum - mx);\n\t\t\t//cerr << t << endl;\n\t\t\tint res;\n\t\t\tif (t >= w[mxi]) {\n\t\t\t\tvector<int> X(t + 1, 0);\n\t\t\t\tX[0] = 1;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (mxi != i) {\n\t\t\t\t\t\tfor (int j = t - w[i]; j >= 0; j--) {\n\t\t\t\t\t\t\tif (X[j] == 1) {\n\t\t\t\t\t\t\t\tX[j + w[i]] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = t; i >= 0; i--) {\n\t\t\t\t\tif (X[i] == 1) {\n\t\t\t\t\t\t//cerr << i << endl;\n\t\t\t\t\t\tres = 2 * mx + sum2 - i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << res << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 * mx + sum2 << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << sum + sum2 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector <int> r, w;\n\t\tr = w = vector <int> (n);\n\t\tint sumR = 0, sumW = 0;\n\t\trep (i, n) {\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsumR += r[i];\n\t\t\tsumW += w[i];\n\t\t}\n\n\t\tvector <int> copyR = r;\n\t\tsort(r.begin(), r.end());\n\n\t\tif (sumR >= 2*r.back()) {\n\t\t\tcout << sumR + sumW << endl;\n\t\t} else {\n\t\t\tint gap = r.back() - (sumR - r.back());\n\t\t\tvector <vector <int>> dp(n, vector <int> (gap + 1, 0));\n\t\t\tdp[0][0] = true;\n\t\t\tw.erase(w.begin() + (find(copyR.begin(), copyR.end(), r.back())-copyR.begin()));\n\t\t\trange (i, 1, n) {\n\t\t\t\trep (j, gap + 1) {\n\t\t\t\t\tif (j - w[i - 1] < 0) continue;\n\t\t\t\t\tdp[i][j] |= dp[i - 1][j - w[i-1]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint maxJ = 0;\n\t\t\trep (i, n) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n\t\t\tcout << 2*r.back() + sumW - maxJ << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\ntypedef pair<int,int> pii;//Add other types in the same way.\n\nvoid solve(int n){\n\tint r[1000],w[1000],m=0,rs=0,ws=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>r[i]>>w[i];\n\t\tif(r[m]<r[i]){\n\t\t\tm=i;\n\t\t}\n\t\trs+=r[i];\n\t\tws+=w[i];\n\t}\n\tif(2*r[m]<=rs){\n\t\tcout<<ws+rs<<endl;\n\t}else{\n\t\tbool f[1000];\n\t\tint k=2*r[m]-rs;\n\t\tfill(f,f+k,false);\n\t\tf[0]=true;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(i==m){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=k;j>0;--j){\n\t\t\t\tif(j>=w[i]&&f[j-w[i]]){\n\t\t\t\t\tf[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f[k]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=k;++j){\n\t\t\tif(f[k-j]){\n\t\t\t\tcout<<ws+rs+j<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\t\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\nint n;\nint dp[1001];\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tvector<int> r(n),w(n);\n\t\tvector<pair<int,pair<int,int> > > p;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tp.push_back(make_pair(r[i],make_pair(w[i],i)));\n\t\t}\n\t\tsort(p.begin(),p.end());\n\t\tint sum=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tsum+=p[i].first;\n\t\t}\n\t\tif(sum>=p[n-1].first){\n\t\t\tsum+=p[n-1].first;\n\t\t\tint sumw=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsumw+=p[i].second.first;\n\t\t\t}\n\t\t\tcout << sum+ sumw << endl;\n\t\t}\n\t\telse{\n\t\t\tint dif=p[n-1].first-sum;\n\t\t\tfor(int i=0;i<1001;i++){\n\t\t\t\tdp[i]=0;\n\t\t\t}\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tint q=p[i].second.first;\n\t\t\t\tfor(int j=1000-q;j>=0;j--){\n\t\t\t\t\tif(dp[j]){\n\t\t\t\t\t\tdp[j+q]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint copy=-1;\n\t\t\tfor(int i=dif;i>=0;i--){\n\t\t\t\tif(dp[i]){\n\t\t\t\t\tcopy=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wait=dif-copy;\n\t\t\tsum+=p[n-1].first;\n\t\t\tint sumw=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsumw+=p[i].second.first;\n\t\t\t}\n\t\t\tcout << sumw+sum+wait << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nP v[1000];\n\nvoid solve(){\n  int sum = 0, ans;\n  int dp[1000][1000];\n  fill(dp[0],dp[1000],0);\n  sort(v,v+n);\n  for(int i=0;i<n-1;i++) sum += v[i].first;\n  ans = sum + v[n-1].first;\n  for(int i=0;i<n;i++) ans += v[i].second;\n\n  if(sum < v[n-1].first){\n    int sum2 = 0;\n    for(int i=0;i<n-1;i++){\n      sum2 += v[i].second;\n      for(int j=0; j<=v[n-1].first-sum; j++){\n        if(j >= v[i].second) dp[i+1][j] = max(dp[i+1][j], dp[i][j-v[i].second] + v[i].second);\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n      }\n    }\n    ans += v[n-1].first - dp[n-1][v[n-1].first-sum] - sum;\n    //cout << sum << ' ' << dp[n-1][v[n-1].first-sum] << endl;\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++) cin >> v[i].first >> v[i].second;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\ntypedef long long Int;\nstring str;\nint dp[1080], n;\n\nint main(){\n\tint r[1080], w[1080];\n\twhile(cin >> n, n){\n\t\tint m = 0, sr = 0, sw = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tm = max(m, r[i]);\n\t\t\tsr += r[i];\n\t\t\tsw += w[i];\n\t\t}\n\t\tif(m * 2 <= sr){\n\t\t\tcout << sr + sw << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfill(dp, dp + 1080, 0);\n\t\tdp[0] = 1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(r[i] == m)continue;\n\t\t\tfor(int j = 1079;j - w[i] >= 0;j--){\n\t\t\t\tdp[j] |= dp[j - w[i]];\n\t\t\t}\n\t\t}\n\t\tint ok = m * 2 - sr;\n\t\twhile(dp[ok] == 0)ok--;\n\t\tcout << m + m + sw - ok << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\twhile(cin>>n,n){\n\t\tvl r(n),w(n);\n\t\trep(i,n)cin>>r[i]>>w[i];\n\t\tll rs=sum(r),ws=sum(w);\n\t\tll rmax=max(r);\n\t\tif(rs>=rmax*2){//セーフ\n\t\t\tputa(rs+ws);\n\t\t}else{\n\t\t\tll diff=rmax*2-rs;\n\t\t\tll mv=0;\n\t\t\tvb dp(diff+1,false);\n\t\t\tdp[0]=true;\n\t\t\trep(i,n)if(r[i]!=rmax){\n\t\t\t\tvb ndp=dp;\n\t\t\t\trep(j,diff)if(dp[j]){\n\t\t\t\t\tif(j+w[i]<=diff){\n\t\t\t\t\t\tndp[j+w[i]]=true;\n\t\t\t\t\t\tchmax(mv,j+w[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp=ndp;\n\t\t\t}\n\t\t\tputa(rs+diff+ws-mv);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair <int,int> P;\nint n;\nP book[1001];\n\nint solve(){\n  int sumf=0,sums=0;\n  for(int i=0;i<n;i++)sumf+=book[i].f,sums+=book[i].s;\n\n  int d=max(0,2*book[0].f-sumf),dp[3000]={1};\n  for(int i=1;i<n;i++)\n    for(int j=d-book[i].s;j>=0;j--) dp[j+book[i].s]|=dp[j];\n\n  int cnt=0;\n  while(!dp[d--])cnt++;\n  return sumf+sums+cnt;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>book[i].f>>book[i].s;\n    sort(book,book+n,greater<P>());\n    cout <<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\t\n\twhile (scanf(\"%d\", &N) && N){\n\t\tpair<int, int> a[1024];\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d\", &a[i].first, &a[i].second);\n\t\t}\n\t\t\n\t\tsort(a, a + N);\n\t\t\n\t\tint sum = 0, ans = 0;\n\t\tfor (int i = 0; i < N - 1; i++) sum += a[i].first;\n\t\tfor (int i = 0; i < N; i++) ans += a[i].first + a[i].second;\n\t\t\n\t\tif (sum >= a[N - 1].first){\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t\telse {\n\t\t\tbool dp[1001] = {false};\n\t\t\tdp[0] = true;\n\t\t\tint spend = 0;\n\t\t\tfor (int i = 0; i < N - 1; i++){\n\t\t\t\tfor (int j = a[N - 1].first - sum; j >= a[i].second; j--){\n\t\t\t\t\tdp[j] |= dp[j - a[i].second];\n\t\t\t\t\tif (dp[j]) spend = max(spend, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans + a[N - 1].first - sum - spend);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000003\n#define HOGE 100000\n#define HUGA 100000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nint n;\nint x[HOGE], y[HOGE];\nbool dp[HUGA];\n\nvoid solve(){\n    memset(dp,0,sizeof(dp));\n    rep(i,n) cin >> x[i] >> y[i];\n    int ma = 0;\n    int ig = 0;\n    rep(i,n){\n        if(ma < x[i]){\n            ma = x[i];\n            ig = i;\n        }\n    }\n    sort(x,x+n,greater<int>());\n    ll sum = 0;\n    ll sumy = 0;\n    rep(i,n) sumy += y[i];\n    for(int i = 1; i < n; i++) sum += x[i];\n    if(x[0] <= sum){\n        cout << x[0]+sum+sumy << endl;\n    } else{\n        ll p = x[0]-sum;\n        dp[0] = true;\n        rep(i,n){\n            if(i == ig){\n                ig = -1;\n                continue;\n            }\n            for(int j = p; j >= y[i]; j--){\n                if(dp[j-y[i]]) dp[j] = true;\n            }\n        }\n        ll b = 0;\n        for(int i = p; i >= 0; i--){\n            if(dp[i]){\n                b = i;\n                break;\n            }\n        }\n        cout << x[0]+sum+sumy+p-b << endl;\n    }\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntemplate<typename T>\nusing vec = vector<T>;\n\nint N;\n\nvoid solve() {\n    vec<P> p(N);\n    for (auto &i : p) cin >> i.first >> i.second;\n    sort(p.begin(), p.end());\n    int sum = 0;\n    for (int i = 0; i < N - 1; i++) sum += p[i].first;\n    int sub = 0;\n    if (sum < p[N-1].first) sub = p[N-1].first - sum;\n\n    vector<map<int,bool> > dp(N);\n    dp[0][0] = true;\n    int m = 0;\n    for (int i = 0; i < N; i++) {\n        for (auto x : dp[i]) {\n            if (x.first > sub) break;\n            m = max(x.first, m);\n            if (i == N - 1) continue;\n            dp[i+1][x.first] = true;\n            if (x.first + p[i].second <= sub) dp[i+1][x.first + p[i].second] = true;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; i++) ans += p[i].first + p[i].second;\n\n    cout << ans + sub - m << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n\nint main() {\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<pii> v;\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> v[i].fi >> v[i].se;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint sum = 0;\n\t\tint res = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tsum += v[i].fi;\n\t\t\tres += v[i].fi + v[i].se;\n\t\t}\n\t\t//cout << sum << \" \" << v.back().fi << endl;\n\t\tif(v.back().fi*2 > sum) {\n\t\t\tint dp[1100] = {};\n\t\t\tint tmp = 0;\n\t\t\tdp[0] = 1;\n\t\t\tfor(int i = 0; i < v.size()-1; i++) {\n\t\t\t\tfor(int j = 1099; j >= 0; j--) {\n\t\t\t\t\tif(j + v[i].se < 1100 && dp[j]) {\n\t\t\t\t\t\tdp[j+v[i].se] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += v[i].fi;\n\t\t\t}\n\t\t\tfor(int i = v.back().fi - tmp; i >= 0; i--) {\n\t\t\t\tif(dp[i]) {\n\t\t\t\t\tres += (v.back().fi-tmp) - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tvector<P> v;\n\t\tint ans=0, sum=0, mx=0;\n\t\tbool dp[1005][1005] = {0};\n\t\tdp[0][0] = true;\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tmx = max(mx, r);\n\t\t\tans += r + w;\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\t\tv.pop_back();\n\t\tif( 2*mx > sum ){\n\t\t\trep(t, v.size()) rep(k,2){\n\t\t\t\tint w = v[t].first + ( k ? 0 : v[t].second );\n\t\t\t\tfor(int j=1000; j>=0; j--){\n\t\t\t\t\tif( j+w <= 1000 ){\n\t\t\t\t\t\tdp[t+1][j+w] |= dp[t][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[t+1][j] |= dp[t][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, mx+1){\n\t\t\t\tif( dp[ v.size() ][ mx-i ] ){\n\t\t\t\t\tans += i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint sum = 0, mx=0, ans=0;\n\t\tvector<pair<int,int> > v;\n\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tans += r + w;\n\t\t}\n\n\t\tsort( v.begin(), v.end() );\n\t\tmx = v.back().first;\n\t\tv.pop_back();\n\n\t\tint dp[2005]={};\n\t\tdp[0] = true;\n\t\tfor(auto t: v) for(int j=1000; j>=0; j--) dp[j+t.second] |= dp[j];\n\n\t\tint tmp = max(0, 2*mx - sum);\n\t\tfor(int i=0; !dp[tmp-i]; i++) ans++;\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\ntypedef pair<int,int> pii;//Add other types in the same way.\n\nvoid solve(int n){\n\tint r[1000],w[1000],m=0,rs=0,ws=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>r[i]>>w[i];\n\t\tif(r[m]<r[i]){\n\t\t\tm=i;\n\t\t}\n\t\trs+=r[i];\n\t\tws+=w[i];\n\t}\n\tif(2*r[m]<=rs){\n\t\tcout<<ws+rs<<endl;\n\t}else{\n\t\tbool f[1001];\n\t\tint k=2*r[m]-rs;\n\t\tfill(f,f+k+1,false);\n\t\tf[0]=true;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(i==m){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=k;j>0;--j){\n\t\t\t\tif(j>=w[i]&&f[j-w[i]]){\n\t\t\t\t\tf[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f[k]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=k;++j){\n\t\t\tif(f[k-j]){\n\t\t\t\tcout<<ws+rs+j<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\t\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tsolve(n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nint main() {\n  int n;\n  while(cin>>n&&n) {\n    P a[n];\n    for(int i=0;i<n;i++)cin>>a[i].F>>a[i].S;\n    sort(a,a+n,greater<P>());\n    int x=-a[0].F,y=a[0].F;\n    for(int i=0;i<n;i++)x+=a[i].F,y+=a[i].S;\n    int m=max(0,a[0].F-x);\n    int dp[m+1];\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    for(int i=1;i<n;i++)for(int j=m-a[i].S;j>=0;j--)dp[j+a[i].S]|=dp[j];\n    for(int i=m;!dp[i];i--)x++;\n    cout<<x+y<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n    while(scanf(\"%d\",&n),n){\n \n        vector<pair<int,int> > rw(n);\n        int sum_r=0,sum_w=0;\n        for(int i=0;i<n;i++){\n            cin>>rw[i].first>>rw[i].second;\n            sum_r+=rw[i].first;\n            sum_w+=rw[i].second;\n        }\n        sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n \n        int r0=rw[0].first;\n        int r=sum_r-r0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*r0;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[1][0]=true;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+rw[i].second<=1000)\n                            dp[i+1][j+rw[i].second]=true; \n                    }\n                }\n            }\n \n            int opt=0;\n            for(int i=1;i<=r0-r;i++){\n                if(dp[n][i]) opt=i;\n            }\n \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\npair<int, int>x[1000]; int n, a, b, s1, s2, dp[1100000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; s1 = 0; s2 = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> a >> b; x[i] = make_pair(a, b); s1 += a; s2 += b; }\n\t\tsort(x, x + n);\n\t\tif (x[n - 1].first * 2 <= s1) { cout << s1 + s2 << endl; }\n\t\telse {\n\t\t\tfor (int i = 0; i <= s2; i++)dp[i] = 0; dp[0] = 1; queue<int>Q; Q.push(0);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvector<int>f;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\t\t\tif (dp[a1 + x[i].second] == 0) { f.push_back(a1 + x[i].second); dp[a1 + x[i].second] = 1; }\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < f.size(); i++)Q.push(f[i]);\n\t\t\t}\n\t\t\tint g = 0; for (int i = x[n - 1].first - (s1 - x[n - 1].first); i >= 0; i--) { if (dp[i] == 1) { g = i; break; } }\n\t\t\tcout << (x[n - 1].first - (s1 - x[n - 1].first) - g) + s1 + s2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, r[1010], w[1010];\nbool dp[1010][1010];\n\nsigned main() {\n    while(cin >> N, N) {\n        rep(i,0,N) cin >> r[i] >> w[i];\n        int readmax = *max_element(r, r+N);\n        int idx = max_element(r, r+N) - r;\n        int sum = accumulate(r, r+N, 0LL) - readmax;\n        int wsum = accumulate(w, w+N, 0LL);\n\n        if(readmax <= sum) {\n            cout << readmax + sum + wsum << endl;\n        }\n        else {\n            int ans = 2 * readmax;\n            memset(dp, false, sizeof(dp));\n            dp[0][0] = true;\n\n            int rest = readmax - sum;\n            rep(i,0,N) repq(j,0,rest) {\n                dp[i+1][j] |= dp[i][j];\n                if(i == idx) continue;\n                if(j-w[i] < 0) continue;\n                dp[i+1][j] |= dp[i][j-w[i]];\n            }\n\n            int ma = -1;\n            repq(i,0,rest) if(dp[N][i]) ma = i;\n            ans += wsum - ma;\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n\nusing namespace std;\n\nint r[1001], w[1001];\nint time;\nbool dp[1001] = { 0 };\n\nint w_book(int wait, int n, int r_max) {\n\tsort(r, r + n);\n\tsort(w, w + n);\n\tint i_max = 0;\n\tdp[0] = 1;\n\tint cnt = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = wait; j >= w[i]; j--) {\n\t\t\tdp[j] = dp[j - w[i]];\n\t\t\tif (dp[j]) {\n\t\t\t\tif (i_max < j) i_max = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn i_max;\n}\n\nint main() {\n\t//ifstream fin(\"input.txt\");\n\t//ofstream fout(\"output.txt\");\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < 1001; i++) {\n\t\tcin >> r[i] >> w[i];\n\t}\n\tint r_max = 0;\n\tint r_total = 0, w_total = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (r_max < r[i]) r_max = r[i];\n\t\tr_total += r[i];\n\t\tw_total += w[i];\n\t}\n\tif (r_max <= r_total - r_max) time = r_total + w_total;\n\telse time = 2 * r_max + w_total - w_book(r_max - (r_total - r_max), n, r_max);\n\n\tcout << time << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    //vector<int> r(n),w(n);\n    vector<pii> ps(n);\n    int sumr=0,sumw=0;\n    rep(i,0,n){\n        cin >> ps[i].first >> ps[i].second;\n        sumr+=ps[i].first;\n        sumw+=ps[i].second;\n    }\n\n    sort(ps.rbegin(),ps.rend());\n    if(ps[0].first<=sumr-ps[0].first){\n        cout << sumr+sumw << endl;\n        return;\n    }\n\n    const int t=ps[0].first*2-sumr;\n    int maxi=0;\n    vector<vector<bool>> dp(n+1,vector<bool>(t+1));\n    dp[1][0]=true;\n    if(ps[1].second<=t){\n        dp[1][ps[1].second]=true;\n        maxi=ps[1].second;\n    }\n    rep(i,2,n){\n        rep(j,0,t+1){\n            if(dp[i-1][j]){\n                dp[i][j]=true;\n                continue;\n            }\n            if(j-ps[i].second<0) continue;\n            if(!dp[i-1][j-ps[i].second]) continue;\n            dp[i][j]=true;\n            maxi=max(maxi,j);\n        }\n    }\n    cout << sumr+sumw+(t-maxi) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x33433433\n\nint n;\nint rmin;\nint rmax;\nint rsum;\nint wsum;\nint r[114514];\nint w[114514];\nbool G[114514];\n\nvoid SubsetSum(int N, int *as, int n) {\n  int maxsum = 1000;\n  int sum = 0;\n\n  fill(G, G+N+1, false);\n  G[0] = true;\n  for (int i=1; i<=n; i++) {\n    int lim = min(maxsum, N-as[i]);\n    for (int j=lim; j>=lim-1000; j--) {\n      G[j+as[i]] |= G[j];\n    }\n    sum += as[i];\n    maxsum = max(maxsum, sum);\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rsum = 0;\n    wsum = 0;\n    rmax = -1;\n    rmin = INF;\n    for (int i=1; i<=n; i++) {\n      scanf(\"%d%d\", &r[i], &w[i]);\n      rsum += r[i];\n      wsum += w[i];\n      rmax = max(rmax, r[i]);\n      rmin = min(rmin, r[i]);\n    }\n\n    /*if (n > 3) {\n      printf(\"%d\\n\", rsum+wsum);\n      continue;\n    }*/\n\n    int leftover;\n    if (rmax >= rsum/2 + rsum%2) {\n      leftover = rmax*2-rsum;\n    } else {\n      if (rmin < rsum/3 + (rsum%3 != 0)) {\n        printf(\"%d\\n\", rsum+wsum);\n        continue;\n      }\n\n      assert(rsum%3 == 0); // r = 0 mod 3 if the program reaches here\n      leftover = rsum/3;\n    }\n\n    bool should_move = false; // remove w[i] from w if r[i] == rmax\n    for (int i=1; i<=n; i++) {\n      if (r[i] == rmax) should_move = true;\n      if (should_move) {\n        r[i] = r[i+1];\n        w[i] = w[i+1];\n      }\n    }\n\n    //printf(\"wsum: %d\\n\", wsum);\n    //printf(\"rsum: %d\\n\", rsum);\n    //printf(\"rmax: %d\\n\", rmax);\n    //printf(\"leftover: %d\\n\", leftover);\n    SubsetSum(leftover, w, n-1); // put wi as many as possible\n    int ans = -1;\n    for (int i=leftover; i>=0; i--) {\n      if (G[i]) {\n        //printf(\"i: %d\\n\", i);\n        ans = rsum+wsum+leftover-i;\n        break;\n      }\n    }\n    assert (ans != -1);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tint t[1000], r[1000];\n\tint dp[2][1000];\n\twhile(cin >> N && N){\n\t\tint sumT = 0, sumR = 0, maxIdx = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> t[i] >> r[i];\n\t\t\tsumT += t[i];\n\t\t\tsumR += r[i];\n\t\t\tif(t[maxIdx] < t[i]) maxIdx = i;\n\t\t}\n\t\tint waitTime = max(0, 2*t[maxIdx] - sumT);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(i == maxIdx) continue;\n\t\t\tmemcpy(dp[next], dp[cur], sizeof(dp[next]));\n\t\t\tfor(int j=0;j+r[i]<=waitTime;j++){\n\t\t\t\tif(dp[cur][j]==0) continue;\n\t\t\t\tdp[next][j+r[i]] = 1;\n\t\t\t}\n\t\t\tint maxIdx = 0;\n\t\t\tfor(int j=0;j<1000;j++) if(dp[next][j]) maxIdx = j;\n\t\t\tswap(cur, next);\n\t\t}\n\t\tfor(int i=waitTime;i>=0;i--){\n\t\t\tif(!dp[cur][i]) continue;\n\t\t\tcout << sumT + sumR + waitTime - i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \n\n \nint main(){\n \n\tint n; \n\twhile(scanf(\"%d\",&n),n){\n\n\t\tvector<pair<int,int> > rw(n);\n\t\tint sum_r=0,sum_w=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>rw[i].first>>rw[i].second;\n\t\t\tsum_r+=rw[i].first;\n\t\t\tsum_w+=rw[i].second;\n\t\t}\n\t\tsort(rw.begin(),rw.end(),greater< pair<int,int> >());\n\n\t\tint r0=rw[0].first;\n\t\tint r=sum_r-r0;\n\n\t\tif(r0 <= r){\n\t\t\tcout<<sum_r+sum_w<<endl;\n\t\t}else{\n\n\t\t\tint res=2*rw[0].first;\n\t\t\tvector<vector<bool> > dp(1001,vector<bool>(1000,false));\n\n\t\t\t//r0-r???w?????°??????\n\t\t\t//dp[pos][sum]\n\n\t\t\tdp[1][0]=true;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<=1000;j++){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\tdp[i+1][j]=true; //??°?????????\n\t\t\t\t\t\tif(j+rw[i].second<=10000)\n\t\t\t\t\t\t\tdp[i+1][j+rw[i].second]=true; //??°??????\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint opt=0;\n\t\t\tfor(int i=1;i<=r0-r;i++){\n\t\t\t\tif(dp[n][i]) opt=i;\n\t\t\t}\n\n\t\t\tres+=sum_w-opt;\n\t\t\tcout<<res<<endl;\n\n\n\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 1000000007;\n\nint xcomp(pii& a, pii& b) {\n\treturn a.first < b.first;\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(true){\n  LL N;\n  cin >> N;\n  if(N==0){\n    break;\n  }\n  vector<pair<LL, LL>> rw;\n  LL r_sum = 0;\n  LL w_sum = 0;\n  REP(i, N)\n  {\n    LL r,w;\n    cin >> r >> w;\n    rw.push_back({r, w});\n    r_sum += r;\n    w_sum += w;\n  }\n  XSORT(rw);\n  if(r_sum-rw[rw.size()-1].first<rw[rw.size()-1].first){\n    LL r_space = rw[rw.size() - 1].first - (r_sum - rw[rw.size() - 1].first);\n    auto rw_rmax = rw[rw.size() - 1];\n    rw.pop_back();\n\n    vector<bool> hoge(2001, false);\n    hoge[0] = true;\n    REP(i, rw.size())\n    {\n      for (int j = 1000; j >= 0;--j){\n        hoge[j + rw[i].second]= hoge[j + rw[i].second] || hoge[j];\n      }\n    }\n\n    LL max = 0;\n    \n    REP(i,r_space+1){\n      if(hoge[i]){\n        max = i;\n      }\n    }\n\n    cout << rw_rmax.first * 2 + w_sum - max << endl;\n  }\n  else\n  {\n    cout << r_sum + w_sum << endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int N;\n  while(cin>>N,N) {\n    vector<int> r(N),w(N);\n    int maxi=0,rsum=0,wsum=0;\n    for(int i=0; i<N; i++) {\n      cin >> r[i] >> w[i];\n      maxi = ((r[i]>r[0])?i:0);\n      rsum += r[i];\n      wsum += w[i];\n    }\n    swap(r[0],r[maxi]);\n    swap(w[0],w[maxi]);\n    if(r[0]*2<=rsum){\n      cout << rsum+wsum << endl;\n    }else{\n      int ds = r[0]*2-rsum;\n      vector<vector<int> > dp(N, vector<int>(ds+1,0));\n      for(int n=1; n<N; n++)\n\tfor(int s=1; s<=ds; s++)\n\t  dp[n][s] = max(dp[n-1][s],(s<w[n]?0:dp[n-1][s-w[n]]+w[n]));\n      cout << r[0]*2+wsum-dp[N-1][ds] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef vector<Def> vi;\ntypedef pair<Def,Def> pii;\ntypedef vector<pii> vp;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp in(n);\n\t\trep(i,n)cin>>in[i].first>>in[i].second;\n\t\tsort(all(in));\n\t\tint sum=0;\n\t\trep(i,n-1)sum+=in[i].first;\n\t\tif(sum<in[n-1].first){\n\t\t\tint t=in[n-1].first-sum;\n\t\t\tint s=0;\n\t\t\trep(i,n)s+=in[i].second;\n\t\t\tbitset<1000010>bs;\n\t\t\tbs[0]=1;\n\t\t\trep(i,n-1)bs=bs|bs<<in[i].second;\n\t\t\tint ma=0;\n\t\t\trep(i,t+1)if(bs[i])ma=i;\n\t\t\tcout<<2*in[n-1].first+s-ma<<endl;\n\t\t}else{\n\t\t\tint s=0;\n\t\t\trep(i,n)s+=in[i].first+in[i].second;\n\t\t\tcout<<s<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    int r[1000], w[1000];\n    REP(i, N) cin >> r[i] >> w[i];\n    REP(i, N) FOR(j, i + 1, N) if(r[i] > r[j]) {\n      swap(r[i], r[j]);\n      swap(w[i], w[j]);\n    }\n    int sum = 0;\n    REP(i, N - 1) sum += r[i];\n    if(sum >= r[N - 1]){\n      REP(i, N) sum += w[i];\n      cout << sum + r[N - 1] << endl;\n    }else{\n      int rest = r[N - 1] - sum;\n      assert(rest > 0);\n      assert(rest <= 1000);\n      bool dp[1010] = {};\n      dp[0] = true;\n      for(int i = 0; i < N - 1; i++){\n        for(int j = rest; j - w[i] >= 0; j--){\n          dp[j] |= dp[j - w[i]];\n        }\n      }\n      int ans = 2 * r[N - 1];\n      int sum_w = 0;\n      REP(i, N) sum_w += w[i];\n      for(int i = rest; i >= 0; i--){\n        if(dp[i]){\n          ans += sum_w - i;\n          break;\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\n\nint solve(vector<pii> v){\n\t\n\tsort(v.begin(), v.end());\n\t\n\tint rl, rs = 0, ws = 0;\n\tbool dp[1010][1010] = {0};\n\t\n\trl = v[N-1].first;\n\t\n\tfor(int i=0; i<N; ++i){\n\t\trs += v[i].first;\n\t\tws += v[i].second;\n\t}\n\t\n\trs -= rl;\n\t\n\tif(rs >= rl){\n\t\treturn rs + rl + ws;\n\t}\n\t\n\t\n\tdp[0][0] = true;\n\t\n\tfor(int i = 0; i < N; ++i){\n\t\tfor(int j = 0; j <= rl - rs; ++j){\n\t\t\t\n\t\t\tif(dp[i][j]){\n\t\t\t\n\t\t\t\tif( j + v[i].second <= rl - rs )\n\t\t\t\t\tdp[i+1][j + v[i].second] = dp[i+1][j] =true;\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j] = true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tint maxwrite = 0;\n\t\n\tfor(int i = 0; i <= rl - rs; ++i){\n\t\n\t\tif(dp[N-1][i])\n\t\t\tmaxwrite = i;\n\t}\n\t\n\treturn 2*rl + ws - maxwrite;\n}\n\nint main(){\n\t\n\twhile(cin>>N, N){\n\t\t\n\t\tvector<pii> v;\n\t\tint r, w;\n\t\t\n\t\tfor(int i=0; i<N; ++i){\n\t\t\t\n\t\t\tcin >> r >> w;\n\t\t\tv.push_back(make_pair(r, w));\n\t\t}\n\t\t\n\t\tcout << solve(v) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nbool dp[1001][2001];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        vi r(n),w(n);\n        rep(i,n){\n            cin >> r[i] >> w[i];\n        }\n        int sm = accumulate(all(r),0);\n        int mx = *max_element(all(r));\n        sort(all(w));\n        if(sm >= 2*mx){\n            cout << sm + accumulate(all(w),0) << \"\\n\";\n        }else{\n            rep(i,n){\n                rep(j,2*mx-sm+1){\n                    dp[i][j] = false;\n                }\n            }\n            dp[0][0] = true;\n            rep(i,n-1){\n                rrep(j,2*mx-sm+1){\n                    if(dp[i][j]){\n                        dp[i+1][j] = true;\n                    }\n                    if(j >= w[i] && dp[i][j-w[i]]){\n                        dp[i+1][j] = true;\n                    }\n                }\n            }\n            int num = 0;\n            rep(i,2*mx-sm+1){\n                if(dp[n-1][i]){\n                    num = i;\n                }\n            }\n            cout << 2*mx + accumulate(all(w),0) - num << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int>r(N), w(N); rep(i, 0, N) { cin >> r[i] >> w[i]; }\n\t\tint sumr = accumulate(all(r), 0);\n\t\tint sumw = accumulate(all(w), 0);\n\t\tint ma = max_element(all(r)) - r.begin();\n\t\tint rmax = r[ma];\n\n\t\tif (rmax <= sumr - rmax) {\n\t\t\tcout << sumr + sumw << endl;\n\t\t}\n\t\telse {\n\t\t\tdump(sumr, sumw, ma, rmax);\n\t\t\tint d = rmax - (sumr - rmax);\n\t\t\tvector<int>dp(d + 1, 0);\n\t\t\tdp[0] = 1;\n\t\t\trep(i, 0, N) {\n\t\t\t\tif (i == ma)continue;\n\t\t\t\trrep(j, w[i], dp.size()) {\n\t\t\t\t\tchmax(dp[j], dp[j - w[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = 0;\n\t\t\trep(i, 0, dp.size()) {\n\t\t\t\tif (dp[i])x = i;\n\t\t\t}\n\t\t\tdump(d,x);\n\t\t\tcout << sumr + sumw + (d - x) << endl;\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) break;\n\n\t\tvector<P> rw(n);\n\t\trep(i, n){\n\t\t\tcin >> rw[i].first >> rw[i].second;\n\t\t}\n\t\tsort(all(rw));\n\n\t\tint rsum = 0;\n\t\tint wsum = 0;\n\t\trep(i, n){\n\t\t\trsum += rw[i].first;\n\t\t\twsum += rw[i].second;\n\t\t}\n\t\tif(rsum <= 2*rw[n-1].first){\n\t\t\t// 1〜n-1のwで作れる「rsum - 2*rw[n-1].first」以下の最大の整数\n\t\t\tint diff = 2*rw[n-1].first - rsum;\n\t\t\tbool dp[1001] = {};\n\t\t\tdp[0] = true;\n\t\t\trep(j, n-1){\n\t\t\t\tfor(int i = 1000; i >= 0; i--){\n\t\t\t\t\tif(!dp[i]) continue;\n\t\t\t\t\tif(i+rw[j].second > diff) continue;\n\t\t\t\t\tdp[i+rw[j].second] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ssum = 0;\n\t\t\trep(i, 1001){\n\t\t\t\tif(dp[i]) ssum = i;\n\t\t\t}\n\t\t\tcout << 2*rw[n-1].first + wsum - ssum << endl;\n\n\t\t}else{\n\t\t\tcout << rsum + wsum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp1[1010];\nint dp2[1010];\n\nint main(){\n\tint N;\n\twhile( cin >> N && N ){\n\t\tvector< pair<int,int> > b(N);\n\t\tint rsum = 0, wsum = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tint r,w;\n\t\t\tcin >> r >> w;\n\t\t\trsum += r;\n\t\t\twsum += w;\n\t\t\tb[i] = make_pair(r,w);\n\t\t}\n\t\tsort(b.begin(),b.end());\n\t\tint maxRVal = b.back().first;\n\t\tint margin = max(0,2*maxRVal-rsum);\n\t\tint required = rsum + margin;\n\t\t\n\t\tvector<int> normal,special;\n\t\tint specialWSum = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tif( b[i].first < maxRVal ){\n\t\t\t\tnormal.push_back(b[i].second);\n\t\t\t}else{\n\t\t\t\tspecial.push_back(b[i].second);\n\t\t\t\tspecialWSum += b[i].second;\n\t\t\t}\n\t\t}\n\t\tsort(normal.begin(),normal.end());\n\t\tsort(special.begin(),special.end());\n\t\tfor(int i = 0 ; i < 1010 ; i++)\n\t\t\tdp1[i] = dp2[i] = 0;\n\t\tdp1[0] = dp2[0] = 1;\n\t\tfor(int i = 0 ; i < normal.size() ; i++)\n\t\t\tfor(int j = 1000 ; j >= normal[i] ; j--)\n\t\t\t\tdp1[j] |= dp1[j-normal[i]];\n\t\tfor(int i = 0 ; i < special.size() ; i++)\n\t\t\tfor(int j = 1000 ; j >= special[i] ; j--)\n\t\t\t\tdp2[j] |= dp2[j-special[i]];\n\t\tfor(int i = 0 ; i <= 1000 ; i++){\n\t\t\tif( dp1[i] > 0 ) dp1[i] = i;\n\t\t\tif( dp2[i] > 0 ) dp2[i] = i;\n\t\t}\n\t\tfor(int i = 1 ; i <= 1000 ; i++){\n\t\t\tdp1[i] = max(dp1[i-1],dp1[i]);\n\t\t\tdp2[i] = max(dp2[i-1],dp2[i]);\n\t\t}\n\t\t\n\t\tint answer = 0;\n\t\tfor(int i = 0 ; i <= margin ; i++){\n\t\t\tint x = dp1[i];\n\t\t\tint y = dp2[margin-i];\n\t\t\tif( y == specialWSum ){\n\t\t\t\ty -= special[0];\n\t\t\t}\n\t\t\tanswer = max(answer,x+y);\n\t\t}\n\t\t\n\t\tcout << required + wsum - answer << endl; // \n\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dp[1001][1001];\nint main(){\n\n  int N;\n  pii ps[1001];\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++)cin>>ps[i].first>>ps[i].second;\n    sort(ps,ps+N,greater<pii>());\n    int rsum=0;\n    int wsum=0;\n    int res=0;\n    for(int i=0;i<N;i++){\n      rsum+=ps[i].first;\n      wsum+=ps[i].second;\n    }\n    if(rsum-ps[0].first>=ps[0].first)res=rsum+wsum;\n    else{\n      const int leftTime=ps[0].first*2-rsum;\n      // leftTimeを最大いくつ埋められるか?\n      for(int i=N;i>=1;i--){\n        for(int j=0;j<=leftTime;j++){\n          int tmp=0;\n          if(i==N)tmp=(leftTime-j);\n          else{\n            if(j-ps[i].second>=0)\n              tmp=max(tmp,dp[i+1][j-ps[i].second]);\n            tmp=max(tmp,dp[i+1][j]);\n          }\n          dp[i][j]=tmp;\n        }\n      }\n      int add=leftTime-dp[1][leftTime];\n      //cout<<leftTime<<\" \"<<add<<endl;\n      res=add+rsum+wsum;\n    }\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int> pii;\nint dp[1001][1001];\nmain(){\n\tint N,r,w,rL,mw,i,j;\n\tfor(;~scanf(\"%d\",&N),N;){\n\t\tvector<pii>v;\n\t\tfor(i=0;i<N;i++)scanf(\"%d%d\",&r,&w),v.push_back(make_pair(r,w));\n\t\tsort(v.begin(),v.end());\n\t\tpii m=v[v.size()-1];\n\t\trL=m.first;\n\t\tfor(r=w=i=0;i<N-1;i++)r+=v[i].first,w+=v[i].second;\n\t\tif(r>=rL){\n\t\t\tprintf(\"%d\\n\",r+w+rL+m.second);\n\t\t}else{\n\t\t\tmemset(dp,0,sizeof(dp));\n\t\t\t// http://acm-icpc.aitea.net/index.php?2013%2FPractice%2F%CC%CF%B5%BC%B9%F1%C6%E2%CD%BD%C1%AA%2F%B9%D6%C9%BE\n\t\t\tdp[0][0] = 1;\n\t\t\tfor(i=0;i<N-1;i++){\n\t\t\t\t// rL-rが本Lを読むまでに生じる待ち時間\n\t\t\t\tfor(j=0;j<=rL-r;j++)if(dp[i][j]){\n\t\t\t\t\tdp[i+1][j] = 1;\n\t\t\t\t\tif(j+v[i].second<=rL-r)dp[i+1][j+v[i].second]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(mw=i=0;i<=rL-r;i++)if(dp[N-1][i])mw=i; // 待ち時間に書ける感想文の最大量\n\t\t\tprintf(\"%d\\n\",2*rL+w+m.second-mw);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n        dp[0][0] = true;\n        range (i, 1, n + 1) {\n            if (r.back() == copyR[i - 1]) {\n                dp[i]=dp[i-1];\n                continue;\n            }\n            rep (j, gap + 1) {\n                if (j - w[i - 1] < 0) continue;\n                dp[i][j] |= dp[i - 1][j - w[i - 1]];\n            }\n        }\n        int maxJ = 0;\n        rep (i, n + 1) rep (j, gap + 1) if (dp[i][j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\nint N;\nstruct Book{\n\tint page;\n\tint write;\n};\nBook book[1000];\nint dp[1000 * 1000*30];\nint sum = 0;\nint deal = 0;\nint solve(){\n\tmemset(dp, 0, sizeof(dp));\n\tint s = book[N - 1].page*2-sum;\n\t//cout << endl<<s << endl<<endl;\n\tdp[0] = -1;\n\trep(i, 0, N - 1){\n\t\trep(j, 1, s + 1){\n\t\t\tif (j - book[i].write >= 0 && dp[j - book[i].write] != 0 && dp[j - book[i].write] <= i&&dp[j]==0)dp[j] = i + 1;\n\t\t\t//cout << dp[j] << \"/\";\n\t\t}\n\t//\tcout << endl << endl;\n\t}\n\tfor (int i = s; i >= 0; i--)\n\t\tif (dp[i] != 0){\n\t\treturn(s - i);\n\t}\n\n\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tint max_n=0,max_i=0;\n\t\tsum = 0;\n\t\tdeal = 0;\n\t\trep(i, 0, N){\n\t\t\tcin >> book[i].page >> book[i].write;\n\t\t\tsum += book[i].page;\n\t\t\tdeal += book[i].write;\n\t\t\tif (book[i].page > max_n)max_n = book[i].page, max_i = i;\n\t\t}\n\t\tif (sum >= max_n * 2)cout << sum + deal << endl;\n\t\telse{\n\t\t\tBook tmp = book[max_i];\n\t\t\tbook[max_i] = book[N - 1];\n\t\t\tbook[N - 1] = tmp;\n\t\t\tcout << sum+deal+solve() << endl;\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n \nusing namespace std;\n \n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n \nconst int N = 1111;\n \n \nint n;\nvector<int> r;\nvector<int> w;\n \nint nupsuck(int t, vector<int>& w){\n \n    int dp[N][N]={0};\n \n    int ret = 0;\n    rep(i,w.size()){\n        rep(j,t){\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n            dp[i+1][j+w[i]] = max(dp[i+1][j+w[i]], dp[i][j]+w[i]);\n        }\n    }   \n    rep(i,w.size()+1){\n        rep(j,t+1)ret = max(ret, dp[i][j]);\n    }\n \n    rep(i,w.size()+1){\n        rep(j,t+1){}\n    }\n \n    return ret;\n}\n \n \nbool input(){\n    cin>>n;\n    if(n==0)return false;\n \n    r.clear();w.clear();\n \n \n    rep(i,n){\n        int a,b;\n        cin>>a>>b;\n        r.push_back(a);\n        w.push_back(b);\n    }\n \n    return true;\n}\n \n \nint solve(){\n    int wsum = 0, rsum =0;\n    int len = 0;\n    int lenx = 0;\n    rep(i,n){\n        wsum += w[i];\n        rsum += r[i];\n        len = max(len, r[i]);\n        if(len==r[i])lenx = i;\n    }\n \n \n    if(len*2 > rsum){\n        vector<int> w2 = w;\n        w2.erase(w2.begin() + lenx);\n        int np = nupsuck(len-(rsum-len), w2);\n        //cout<<len<<\" \"<<wsum<<\" \"<<rsum<<\" \"<<np<<endl;\n        return 2*len + wsum - np;\n    }\n    return rsum+wsum;\n}\n \n \nint main(){\n \n    while(input()){\n        cout<<solve()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\n\nP book[1000];\nbool dp[1000][1001]; //時間jをちょうど使ってi冊目までを適切に選んで感想を書けるか\nint solve(int n)\n{\n\tint ret=0;\n\tsort(book,book+n);\n\tint sum=0;\n\tfor(int i=0;i<n-1;i++)\n\t\tsum+=book[i].first;\n\tif(sum<book[n-1].first)\n\t{\n\t\tret=book[n-1].first*2;\n\t\t//1冊がとても重い場合スキマ時間になるべく感想を詰め込む\n\t\tint suki=book[n-1].first-sum; //スキマ時間の量\n\t\tfill(dp[0],dp[1000],false);\n\t\tdp[0][0]=true;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<1001;j++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=true;\n\t\t\t\t\tif(j+book[i-1].second<=suki)\n\t\t\t\t\t\tdp[i][j+book[i-1].second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint del=0;\n\t\tfor(int i=0;i<=suki;i++)\n\t\t{\n\t\t\tif(dp[n-1][i])\n\t\t\t\tdel=i;\n\t\t}\n\t\tsum=0;\n\t\t//感想の総時間を求める\n\t\tfor(int i=0;i<n;i++)\n\t\t\tsum+=book[i].second;\n\t\tret+=(sum-del);\n\t}else{\n\t\t//同時にすべての本が読み終わる場合感想は同時に書ける\n\t\tret=sum+book[n-1].first;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tret+=book[i].second;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint r,w;\n\t\t\tcin>>r>>w;\n\t\t\tbook[i]=P(r,w);\n\t\t}\n\t\tcout<<solve(n)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int N;cin>>N,N;){\n    int r[1000],w[1000];\n    int rsum=0,wsum=0;\n    for(int i=0;i<N;i++){\n      cin>>r[i]>>w[i];\n      rsum+=r[i];\n      wsum+=w[i];\n    }\n    auto it=max_element(begin(r),begin(r)+N);\n    if(*it*2<=rsum){\n      cout<<rsum+wsum<<endl;\n    }else{\n      bool dp[1001]={true};\n      for(int i=0;i<N;i++){\n\tif(*it==r[i])continue;\n\tfor(int j=1000;j-w[i]>=0;j--){\n\t  dp[j]|=dp[j-w[i]];\n\t}\n      }\n      int x=*it*2-rsum;\n      while(!dp[x]){\n\tx--;\n      }\n      cout<<*it*2+wsum-x<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Book{\npublic:\n  int read;\n  int write;\n  Book(int _r,int _w) : read(_r), write(_w) {}\n  bool operator <(const Book& b) const {\n    return (read != b.read ? (read < b.read) : (write < b.write));\n  }\n  bool operator >(const Book& b) const {\n    return (read != b.read ? (read > b.read) : (write > b.write));\n  }\n};\n\nbool dp[1000010];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n\n    vector<Book> books;\n\n    int total_reading = 0;\n    int total_writing = 0;\n    for(int book_idx = 0; book_idx < N; book_idx++){\n      int read,write;\n      scanf(\"%d %d\",&read,&write);\n      books.push_back(Book(read,write));\n      total_reading += read;\n      total_writing += write;\n    }\n\n    sort(books.begin(),books.end());\n    int longest_reading = (books.end()-1)->read;\n    int remaining = total_reading - longest_reading;\n\n    if(remaining < longest_reading){\n      int fill_space = longest_reading - remaining;\n      memset(dp,false,sizeof(dp));\n      dp[0] = true;\n      int max_fill = 0;\n      for(int i=0; i < N - 1; i++){\n        for(int j=fill_space; j>=0; j--){\n          if(j + books[i].write > fill_space) continue;\n\n          dp[j + books[i].write] = dp[j];\n          if(dp[j + books[i].write]){\n            max_fill = max(max_fill,j+books[i].write);\n          }\n        }\n      }\n\n      printf(\"%d\\n\",total_reading + total_writing + (fill_space - max_fill));\n    }\n    else{\n      printf(\"%d\\n\",total_reading + total_writing);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N;\n  while(cin >> N, N) {\n    pair<int,int> x[1001];\n    int rsum = 0, wsum = 0;\n    rep(i, N) {\n      cin >> x[i].first >> x[i].second;\n      rsum += x[i].first;\n      wsum += x[i].second;\n    }\n    sort(x, x+N);\n    int rx = x[N-1].first;\n    if(rsum-rx >= rx) {\n      cout << rsum+wsum << endl;\n      continue;\n    }\n    bool dp[1001] = {};\n    dp[0] = true;\n    rep(i, N-1) {\n      for(int j = rx-(rsum-rx); j >= x[i].second; j--) {\n\tif(dp[j-x[i].second]) dp[j] = true;\n      }\n    }\n    int ans = 0;\n    rep(i, rx-(rsum-rx) + 1) {\n      if(dp[i]) ans = i;\n    }\n    cout << rx+rx+wsum-ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dp[55][50010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    VI r(n), w(n);\n    int sumr = 0, sumw = 0;\n    int ma=0, idx=-1;\n    REP(i, n) {\n      cin >> r[i] >> w[i];\n      if(ma < r[i]) {\n        ma = r[i];\n        idx = i;\n      }\n      sumr += r[i];\n      sumw += w[i];\n    }\n\n    if(ma <= sumr - ma) {\n      cout << sumr + sumw << endl;\n    } else {\n      // r.back() - (sumr - r.back()) = 2*r.back() - sumr にできるだけ近づける\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1;\n      REP(i, n) REP(j, 2*ma-sumr+1) {\n        dp[i+1][j] |= dp[i][j];\n        if(j+w[i] <= 50000 && i != idx) dp[i+1][j+w[i]] |= dp[i][j];\n      }\n\n      int tmp = -1;\n      REP(i, 2*ma-sumr+1) if(dp[n][i]==1) chmax(tmp, i);\n      \n      cout << ma*2 + sumw - tmp << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\n\nint main() {\n\t\n\twhile (1) {\n\t\tvector<int>reads;\n\t\tvector<int>writes;\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\treads.push_back(a);\n\t\t\twrites.push_back(b);\n\t\t}\n\t\tint ans;\n\t\tconst int readsum = accumulate(reads.begin(), reads.end(), 0);\n\t\tint readtime;\n\t\tconst auto maxid = (max_element(reads.begin(), reads.end()))-reads.begin();\n\t\tif (reads[maxid] * 2 > readsum) {\n\t\t\treadtime = reads[maxid] * 2;\n\t\t\tconst int resttime = readtime - readsum;//余った時間で感想文書く//maxの以外\n\n\t\t\tbool dp[1001];\n\t\t\tmemset(dp, false, sizeof(dp));\n\t\t\tdp[0] = true;\n\t\t\tfor (int j = N - 1; j >= 0; --j) {\n\t\t\tfor (int i = 0; i < resttime; ++i) {\n\t\t\t\tif (dp[i]) {\n\n\t\t\t\t\t\tif (j != maxid) {\n\t\t\t\t\t\t\tif (i + writes[j] <= resttime) {\n\t\t\t\t\t\t\t\tdp[i + writes[j]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxtime;\n\t\t\tfor (int i = resttime; i >= 0; --i) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tmaxtime = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0) - maxtime;\n\n\t\t}\n\t\telse {\n\t\t\treadtime = readsum;\n\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0);\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main() {\n\tvector<int>a;\n\tbool b[1001];\n\tint n, k;\n\tint x, y;\n\tint m, s;\n\twhile (true) {\n\t\tm = 0;\n\t\ts = 0;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\ta.clear();\n\t\tf(i, n) {\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tm = max(m, x);\n\t\t\tif (m == x)k = i;\n\t\t\ts += x;\n\t\t\ta.push_back(y);\n\t\t}\n\t\tif (2 * m <= s) {\n\t\t\tf(i, n)s += a[i];\n\t\t\tprintf(\"%d\\n\", s);\n}\n\t\telse {\n\t\t\ts = (2 * m) - s;\n\t\t\tf(i, 1001)b[i] = false;\n\t\t\tb[0] = true;\n\t\t\tf(i, n) {\n\t\t\t\tif (i != k) {\n\t\t\t\t\tfor (int j = s - a[i]; j >= 0; j--) {\n\t\t\t\t\t\tif (b[j])b[j + a[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = s; j >= 0; j--) {\n\t\t\t\tif (b[j]) {\n\t\t\t\t\ts = 2 * m;\n\t\t\t\t\tf(i, n)s += a[i];\n\t\t\t\t\ts -= j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", s);\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nvector<pair<int,int> >vec;\nbool com(pair<int,int>p1, pair<int,int>p2){\n    return p1.first>p2.first;\n}\nint main()\n{\n    int N;\n    while(cin>>N,N){\n        vec.clear();\n        for(int i=0;i<N;i++){\n            int r,w;\n            cin>>r>>w;\n            vec.push_back(make_pair(r,w));\n        }\n        sort(vec.begin(),vec.end(),com);\n        int tot=0;\n        for(int i=1;i<vec.size();i++)\n            tot+=vec[i].first;\n        int ans=0;\n        for(int i=0;i<vec.size();i++){\n            ans+=vec[i].first;\n            ans+=vec[i].second;\n        }\n        if(vec[0].first>tot){\n            int left=vec[0].first-tot;\n            bool dp[1001]={false};\n            dp[0]=true;\n            int m=left;\n            for(int i=1;i<N;i++){\n                for(int j=left;j>=vec[i].second;j--){\n                    dp[j]|=dp[j-vec[i].second];\n                    if(dp[j])\n                        m=min(m,left-j);\n                }\n            }\n            ans+=m;\n        }\n        else{\n            \n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\npii p[1000];\n\nint main() {\n  int n;\n  while(cin>>n, n) {\n    int all = 0;\n    REP(i,n) {\n      cin >> p[i].first >> p[i].second;\n      all += p[i].first + p[i].second;\n    }\n    sort(p,p+n);\n    int sum1 = 0;\n    int sum2 = 0;\n    for (int i=0; i<n-1; ++i) {\n      sum1 += p[i].first;\n      sum2 += p[i].second;\n    }\n    pii q = p[n-1];\n    if (sum1 >= q.first) {\n      cout << all << endl;\n      continue;\n    }\n    int W = q.first - sum1;\n    bool dp[W+1+2000];\n    REP(i,W+1) dp[i] = 0;\n    dp[0] = 1;\n    REP(i, n-1) {\n      for (int j=W; j>=0; --j) {\n        dp[j+p[i].second] |= dp[j];\n      }\n    }\n    int ans = INF;\n    for (int i=0; i<=W; ++i) {\n      if (dp[i]) {\n        chmin(ans, q.first * 2 + q.second + sum2-i);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n   \n  \n   \nint main(){\n   \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n    while(scanf(\"%d\",&n),n){\n         \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n  \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n  \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n  \n\t\t\tbool dp[1001][1000]={};\n            dp[0][0]=true;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+w[i]<1000)\n                            dp[i+1][j+w[i]]=true; \n                    }\n                }\n            }\n  \n            int opt=r0-r;\n            while(!dp[n][opt]) opt--;\n  \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n  \n  \n  \n        }\n          \n          \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, r[1000], w[1000];\nbool dp[2][1001];\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> n,n){\n    int sumr = 0, sumw = 0, id = 0;\n    for(int i=0;i<n;i++){\n      cin >> r[i] >> w[i];\n      sumr += r[i]; sumw += w[i];\n      if(r[id] < r[i])id = i;\n    }\n\n    int lim = 2*r[id]-sumr;\n    if(lim<=0){\n      cout << sumr + sumw << endl;\n      continue;\n    }\n\n    for(int j=0;j<=lim;j++)dp[0][j] = false;\n    dp[0][0] = true;\n    \n    for(int i=0;i<n;i++){\n      int now = i&1, nxt = 1-now;\n      for(int j=0;j<=lim;j++)dp[nxt][j] = false;\n      for(int j=0;j<=lim;j++){\n\tif(dp[now][j]){\n\t  dp[nxt][j] = true;\n\t  if(i!=id && j+w[i]<=lim)dp[nxt][j+w[i]] = true;\n\t}\n      }\n    }\n    \n    int tmp = 0;\n    for(int i=0;i<=lim;i++){\n      if(dp[n&1][i])tmp = i;\n    }\n    cout << sumr + sumw + lim - tmp << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector <int> r, w;\n        r = w = vector <int> (n);\n        int sumR = 0, sumW = 0;\n        rep (i, n) {\n            cin >> r[i] >> w[i];\n            sumR += r[i];\n            sumW += w[i];\n        }\n        vector <int> copyR = r;\n        sort(r.begin(), r.end());\n        if (sumR >= 2*r.back()) {\n            cout << sumR + sumW << endl;\n            continue;\n        }\n        int gap = 2*r.back()-sumR;\n        vector <vector <int>> dp(n + 1, vector <int> (gap + 1, 0));\n        dp[0][0] = true;\n        range (i, 1, n + 1) {\n            if (r.back() == copyR[i - 1]) {\n                dp[i]=dp[i-1];\n                continue;\n            }\n            for(int j=gap;j>=0;j--){\n                if (j - w[i - 1] < 0) continue;\n                dp[i][j] |= dp[i - 1][j - w[i - 1]];\n            }\n        }\n        int maxJ = 0;\n        rep (j, gap + 1) if (dp[n][j]) maxJ = max(maxJ, j);\n        cout << sumR + sumW + (gap - maxJ) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nbool dp[1010][1010];\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n\n    int read_sum = 0, write_sum = 0;\n    vector< pair<int, int> > books(N);\n    for(int i=0; i<N; i++) {\n        int r, w;\n        scanf(\"%d%d\", &r, &w);\n        books[i] = make_pair(r, w);\n        read_sum += r;\n        write_sum += w;\n    }\n\n    sort(books.rbegin(), books.rend());\n    if(read_sum - books[0].first >= books[0].first) {\n        printf(\"%d\\n\", read_sum + write_sum);\n    }\n    else {\n        int r0, w0; tie(r0, w0) = books[0];\n        books.erase(books.begin()); N--;\n        fill(dp[0], dp[N+1], false);\n        dp[0][0] = true;\n\n        for(int i=0; i<N; i++) {\n            int r, w; tie(r, w) = books[i];\n            for(int j=0; j<=1000; j++) {\n                if(!dp[i][j]) continue;\n                dp[i+1][j] |= dp[i][j];\n                if(j + r <= 1000) dp[i+1][j+r] |= dp[i][j];\n                if(j + r + w <= 1000) dp[i+1][j+r+w] |= dp[i][j];\n            }\n        }\n\n        int ans = 1 << 29, s = read_sum - r0 + write_sum;\n        for(int i=0; i<=r0; i++) {\n            if(!dp[N][i]) continue;\n            ans = min(ans, 2*r0 + s - i);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tint t[1000], r[1000];\n\tint dp[2][1000];\n\twhile(cin >> N && N){\n\t\tint sumT = 0, sumR = 0, maxIdx = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> t[i] >> r[i];\n\t\t\tsumT += t[i];\n\t\t\tsumR += r[i];\n\t\t\tif(t[maxIdx] < t[i]) maxIdx = i;\n\t\t}\n\t\tint waitTime = max(0, 2*t[maxIdx] - sumT);\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1;\n\t\tint cur = 0, next = 1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tmemcpy(dp[next], dp[cur], sizeof(dp[next]));\n\t\t\tfor(int j=0;j+r[i]<=waitTime;j++){\n\t\t\t\tif(dp[cur][j]==0) continue;\n\t\t\t\tdp[next][j+r[i]] = 1;\n\t\t\t}\n\t\t\tint maxIdx = 0;\n\t\t\tfor(int j=0;j<1000;j++) if(dp[next][j]) maxIdx = j;\n\t\t\tswap(cur, next);\n\t\t}\n\t\tfor(int i=waitTime;i>=0;i--){\n\t\t\tif(!dp[cur][i]) continue;\n\t\t\tcout << sumT + sumR + waitTime - i << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int N;\n  while(cin >> N, N){\n    int r[N], w[N], s_r = 0, M = 0, s = 0, id;\n    for(int i = 0; i < N; ++i){\n      cin >> r[i] >> w[i];\n      //M = max(max(M,r[i]),w[i]);\n      if(r[i] > M){\n\tM = r[i];\n\tid = i;\n      }\n      s_r += r[i];\n      s += r[i] + w[i];\n    }\n    if(M*2 > s_r){\n      int t = 2*M - s_r;\n      //cout << \"t = \" << t << endl;\n      bool k[t+1];\n      fill(k,k+t+1,false);\n      k[0] = true;\n      for(int i = 0; i < N; ++i){\n\tif(i == id) continue;\n\tfor(int j = t; j >= 0; --j){\n\t  if(!k[j] && j >= w[i] && k[j-w[i]]) k[j] = true;\n\t}\n\tif(k[t]) break;\n      }\n      /*\n      for(int i = 0; i <= t; ++i){\n\tcout << k[i] << \" \";\n      }cout << endl;\n      */\n      int a;\n      for(int i = t; i >= 0; --i){\n\tif(k[i]){\n\t  a = i;\n\t  break;\n\t}\n      }\n      cout << s + t - a << endl;\n    }else{\n      cout << s << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n//#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n;\nmp dat[1005];\nint dp[1005];\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint s=0,w=0;\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tdat[i]=mp(a,b);\n\t\t\ts+=a; w+=b;\n\t\t}\n\t\tsort(dat,dat+n,greater<mp>());\n\t\tint x=dat[0].fir*2-s;\n\t\tif(x<=0){\n\t\t\tprintf(\"%d\\n\",s+w); \n\t\t\tcontinue;\n\t\t}\n\t\t//printf(\"%d %d %d %d\\n\",s,w,x,dat[0].fir);\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0]=1;\n\t\treg(i,1,n-1){\n\t\t\tireg(j,dat[i].sec,x){\n\t\t\t\tif(dp[j-dat[i].sec]==0)continue;\n\t\t\t\tdp[j]=1;\n\t\t\t}\n\t\t}\n\t\tireg(i,0,x){\n\t\t\tif(dp[i]==1){\n\t\t\t\tprintf(\"%d\\n\",s+w+x-i); \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n;\n    while(cin >> n&&n!=0){\n        vector<int>a(n),b(n);\n        rep(i,n){\n            cin >> a[i] >> b[i];\n        }\n        int sa=0,sb=0;\n        int mx = 0;\n        int bb = 0;\n        rep(i,n){\n            sa += a[i];\n            sb += b[i];\n            mx = max(mx,a[i]);\n        }\n        if(sa-mx>=mx){\n            cout << sa+sb << endl;\n        }else{\n            bool dp[1001][2000]={};\n            dp[0][0] = 1;\n            for(int i=0;i<n;i++){\n                if(mx==a[i]){\n                    for(int j=0;j<=1000;j++){\n                        dp[i+1][j] = dp[i][j];\n                    }\n                }else{\n                    for(int j=0;j<=1000;j++){\n                        if(dp[i][j]){\n                            dp[i+1][j] = 1;\n                            dp[i+1][j+a[i]] = 1;\n                            dp[i+1][j+a[i]+b[i]]=1;\n                        }\n                    }\n                }\n            }\n            int zz=0;\n            for(int i=0;i<=mx;i++){\n                if(dp[n][i]){\n                    zz = i;\n                }\n            }\n            cout << sa+sb+mx-zz << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll n,m;\nll x[1200],y[1200];\nll dp[3000];\nll i,j;\nll sumx,sumy;\nll ans = 0;\n\nbool solve(){\n\tcin >> n;\n\tif(n == 0){\n\t\treturn false;\n\t}\n\tsumx = 0;\n\tsumy = 0;\n\tll v = -1;\n\tll sumv = -1;\n\tfor(i=0;i<n;i++){\n\n\t\tcin >> x[i] >> y[i];\n\t\tif(x[i] > sumv){\n\t\t\tsumv = x[i];\n\t\t\tv = i;\n\t\t}\n\t\tsumx += x[i];\n\t\tsumy += y[i];\n\t}\n\tsort(x,x+n);\n\treverse(x,x+n);\n\tif(x[0] * 2 > sumx){\n\t\t//cout << \"!\" << endl;\n\t\tll w = x[0] - (sumx - x[0]);\n\t\tdp[0] = 1;\n\t\tfor(i=1;i<=w;i++)dp[i] = 0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i == v)continue;\n\t\t\tfor(j=w;j>=1;j--){\n\t\t\t\tif(j - y[i] >= 0){\n\t\t\t\t\tdp[j] |= dp[j - y[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ma = 0;\n\t\tfor(i=1;i<=w;i++){\n\t\t\t//cout << dp[i] << \" \";\n\t\t\tif(dp[i])ma = i;\n\t\t}\n\t\t//cout << endl;\n\t\tll ans1,ans2;\n\t\tans1 = sumx + sumy + w - ma;\n\t\tans2 = 0;\n\t\t//cout << \"ma = \" << ma << endl;\n\t\tcout << max(ans1,ans2) << endl;\n\t}else{\n\t\tcout << sumx + sumy << endl;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(solve()){}\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                 //    #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint n;\nvector<pa> ve;\nint dp[1050][1050]={0};\n\nsigned main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) return 0;\n\t\tve.clear();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint rr,rrr;\n\t\t\tcin>>rr>>rrr;\n\t\t\tve.pb(mp(rr,rrr));\n\t\t}\n\t\tsort(ve.begin(),ve.end());\n\t\t\n\t\tint e1=ve[n-1].first,eall=0;\n\t\tfor(int i=0;i<n;i++)eall += ve[i].first;\n\t\tint wall=0;\n\t\tfor(int i=0;i<n;i++)wall += ve[i].second;\n\t\tif(e1*2<=eall){\n\t\t\tcout<<eall+wall<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint w=e1-(eall-e1);\n\t//\tcout<<\"w=\"<<w<<endl;\n\t\tdp[0][0]=1;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint qw=ve[i].second;\n\t\t//\tcout<<\"qw= \"<<qw<<endl;\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tif(dp[i][j]==0) continue;\n\t\t\t\tdp[i+1][j]=1;\n\t\t\t\tif(j+qw<=w)dp[i+1][j+qw]=1;\n\t\t\t}\n\t\t}\n\t\tint s=0;\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tif(dp[n-1][j]==1) s=j;\n\t\t}\n\t\t//cout<<\"s= \"<<s<<endl;\n\t\t//cout<<\"wall \"<<wall<<endl;\n\t\tcout<<2*e1+wall-s<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e15;\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<pair<int,int>> rw(n);\n    rep(i,n)cin>>rw[i].first>>rw[i].second;\n    sort(all(rw));\n    int readsum=0,writesum=0;\n    rep(i,n){\n      if(i<n-1)readsum+=rw[i].first;\n      writesum+=rw[i].second;\n    }\n    if(readsum>=rw[n-1].first){\n      cout<<readsum+rw[n-1].first+writesum<<endl;\n    }else{\n      int dp[1003][1003]={};\n      dp[0][0]=1;\n      int uplim=rw[n-1].first-readsum;\n      int mw=0;\n      rep(i,n){\n        for(int j=0;j<=uplim;j++){\n          if(dp[i][j]==1){\n            dp[i+1][j]=1;\n            if(j+rw[i].second<=uplim)dp[i+1][j+rw[i].second]=1;\n          }\n        }\n      }\n      rep(i,uplim+1){\n        if(dp[n-1][i])mw=i;\n      }\n      //cout<<\"uplim=\"<<uplim<<' '<<\"mw=\"<<mw<<endl;\n      cout<<2*rw[n-1].first+writesum-mw<<endl;\n    }\n\n\n  }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint dp[1001][1001];\n\nint main(){\n\tint n,r[1000],w[1000],maxr,sum,sumr,p;\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)break;\n\t\tsum = sumr = maxr = p = 0;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d\",r+i,w+i);\n\t\t\tsum += r[i]+w[i];\n\t\t\tsumr += r[i];\n\t\t\tif(maxr < r[i]){\n\t\t\t\tp = i;\n\t\t\t\tmaxr = r[i];\n\t\t\t}\n\t\t}\n\t\tsumr -= maxr;\n\t\tif(maxr <= sumr){\n\t\t\tprintf(\"%d\\n\",sum);\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\t\n\t\trep(i,n){\n\t\t\trep(j,w[p]+1){\n\t\t\t\tif(j >= w[i] && i!=p)dp[i+1][j] = max(dp[i][j],dp[i][j - w[i]]+w[i]);\n\t\t\t\telse dp[i+1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum + w[p] - dp[n][w[p]]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        int r[1111], w[1111];\n        rep(i, n)\n            cin >> r[i] >> w[i];\n        int sum_r = accumulate(r, r + n, 0);\n        int sum_w = accumulate(w, w + n, 0);\n\n        vector<pint> b;\n        rep(i, n)\n            b.pb(pint(r[i], w[i]));\n        sort(all(b));\n\n        int rem = b.back().first - (sum_r - b.back().first);\n        if (rem <= 0)\n            cout << sum_r + sum_w << endl;\n        else\n        {\n            bool dp[2111];\n            CL(dp, 0);\n            dp[0] = true;\n            rep(i, b.size() - 1) revrep(j, rem)\n                dp[j + b[i].second] |= dp[j];\n            int written = 0;\n            erep(j, rem)\n                if (dp[j])\n                    written = j;\n\n            int ami = sum_r + sum_w;\n            int mami = (2 * b.back().first) + (sum_w - written);\n            cout << max(ami, mami) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n    \n   \n    \nint main(){\n    \n    int n; \n    int r[1000],w[1000];\n    int sum_r=0,sum_w=0,idx=0;\n     \n    while(scanf(\"%d\",&n),n){\n          \n        sum_r=sum_w=idx=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d\",&r[i],&w[i]);\n            sum_r+=r[i];\n            sum_w+=w[i];\n            if(r[idx]<r[i]) idx=i;\n        }\n   \n        int r0=r[idx],r=sum_r-r0;\n        w[idx]=0;\n  \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n   \n            int res=2*r0;\n            //vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n   \n//          bool cur[1001]={};\n            bool *cur = (bool*)malloc( r0-r+2 );\n            cur[0]=true;\n            for(int i=0;i<n;i++){\n                bool *next = (bool*)malloc( r0-r+2 );\n                for(int j=0;j<=r0-r;j++){\n                    if(cur[j]){\n                        next[j]=true; \n                        if(j+w[i]<=r0-r)\n                            next[j+w[i]]=true; \n                    }\n                }\n                swap(cur,next);\n            }\n   \n            int opt=r0-r;\n            while(!cur[opt]) opt--;\n   \n            res+=sum_w-opt;\n            printf(\"%d\\n\",res);\n   \n   \n   \n        }\n           \n           \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nvoid solve(int n) {\n  vector<P> v(n);\n  int su = 0;\n  for(int i=0;i<n;++i) {\n    cin >> v[i].first >> v[i].second;\n    su += v[i].first + v[i].second;\n  }\n  sort(v.rbegin(), v.rend());\n  int subook = 0;\n  for(int i=1;i<n;++i) {\n    subook += v[i].first;\n  }\n  if(v[0].first <= subook) {\n    cout << su << endl;\n    return;\n  }\n  vector<vector<bool>> dp(n, vector<bool>(v[0].first - subook + 1, false));\n  dp[0][0] = true;\n  for(int i=1;i<n;++i) {\n    for(int j=0;j<v[0].first - subook + 1;++j) {\n      if(!dp[i-1][j] || j + v[i].second > v[0].first - subook) continue;\n      dp[i][j+v[i].second] = true;\n      dp[i][j] = true;\n    }\n  }\n  int ma = 0;\n  for(int i=0;i<v[0].first - subook + 1;++i) {\n    if(dp[n-1][i]) ma = max(ma, i);\n  }\n  cout << su + (v[0].first - subook - ma) << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<int, int> P;\n\nint dp[1010][1010];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<P> book;\n\t\tint rsum = 0, wsum = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tbook.push_back({ r, w });\n\t\t\trsum += r;\n\t\t\twsum += w;\n\t\t}\n\n\t\tsort(book.begin(), book.end());\n\t\tP B = book.back();\n\t\tbook.pop_back();\n\t\trsum -= B.first, wsum -= B.second;\n\n\t\tif(B.first <= rsum) {\n\t\t\tcout << rsum + B.first + wsum + B.second << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tdp[0][0] = 1;\n\t\tN--;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 1000; j++) {\n\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\tdp[i + 1][j] = 1;\n\t\t\t\tif(j + book[i].second < 1000) {\n\t\t\t\t\tdp[i + 1][j + book[i].second] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rem = B.first - rsum;\n\t\tint t = 0;\n\t\tfor(int j = 0; j <= rem; j++) {\n\t\t\tif(dp[N][j]) t = j;\n\t\t}\n\n\t\tcout << 2 * B.first + B.second + wsum - t << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint n;\npair<int, int> data[N];\n\nint calc(int emp){\n  bool dp[N][N+1];\n  fill(dp[0], dp[N], false);\n  dp[0][0] = true;\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=emp;j++){\n      if(!dp[i][j]) continue;\n      dp[i+1][j] = true;\n      if(j+data[i].second <= emp) dp[i+1][j+data[i].second] = true;\n    }\n  }\n  int tmp = 0;\n  for(int i=0;i<=emp;i++) if(dp[n-1][i]) tmp = i;\n  int res = data[n-1].first * 2;\n  for(int i=0;i<n;i++) res += data[i].second;\n  return res - tmp;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      data[i] = make_pair(a, b);\n    }\n    sort(data, data+n);\n    int sum = 0;\n    for(int i=0;i<n-1;i++) sum += data[i].first;\n    int ans = 0;\n    if(sum >= data[n-1].first) for(int i=0;i<n;i++) ans += data[i].first + data[i].second;\n    else ans = calc(data[n-1].first - sum);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int N, r[1000], w[1000];\n  bool dp[1000];\n  \n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) {\n      cin >> r[i] >> w[i];\n    }\n    int sum = accumulate(r, r + N, 0);\n    int* big = max_element(r, r + N);\n    int add = 0;\n  \n    if(*big * 2 > sum) {\n      int space = *big * 2 - sum;\n      swap(w[big - r], w[N - 1]);\n      memset(dp, false, sizeof(bool) * (space + 1));\n      dp[0] = true;\n      for(int i = 0; i < N - 1; i++) {\n        for(int j = space; j >= w[i]; j--) {\n          dp[j] |= dp[j - w[i]];\n        }\n      }\n      for(int i = space; i >= 0; i--) {\n        if(dp[i]) {\n          add = space - i;\n          break;\n        }\n      }\n    }\n    cout << sum + accumulate(w, w + N, 0) + add << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define REP(i,k,n) for(int i = k; i < (int)(n); i++)\nusing namespace std;\nint main(){\n        int N;\n        while(true) {\n                cin >> N;\n                if(N==0) break;\n                vector<pair<int,int> > rw(N);\n                rep(i,N) cin >> rw[i].first >> rw[i].second;\n                sort(rw.begin(),rw.end(),greater<pair<int,int> >());\n                int sum = 0;\n                rep(i,N-1) sum +=rw[i+1].first;\n\n                int ans = 0;\n                rep(i,N) ans +=rw[i].first + rw[i].second;\n\n\n                if(rw[0].first > sum) {\n                        int W = rw[0].first - sum;\n                        int d[1010][1010]={};\n                        REP(i,1,N){\n                                rep(j,W+1){\n                                        if(j < rw[i].second) d[i][j] = d[i-1][j];\n                                        else{\n                                                d[i][j] = max(d[i-1][j], (rw[i].second + d[i-1][j-(rw[i].second)]));\n                                        }\n                                }\n                        }\n                        int space = W - d[N-1][W];\n                        ans += space;\n                }\n                cout << ans << endl;\n        }\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nclass Book{\npublic:\n  int read;\n  int write;\n  Book(int _r,int _w) : read(_r), write(_w) {}\n  bool operator <(const Book& b) const {\n    return (read != b.read ? (read < b.read) : (write < b.write));\n  }\n  bool operator >(const Book& b) const {\n    return (read != b.read ? (read > b.read) : (write > b.write));\n  }\n};\n\nbool dp[1000010];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n\n    vector<Book> books;\n\n    int total_reading = 0;\n    int total_writing = 0;\n    for(int book_idx = 0; book_idx < N; book_idx++){\n      int read,write;\n      scanf(\"%d %d\",&read,&write);\n      books.push_back(Book(read,write));\n      total_reading += read;\n      total_writing += write;\n    }\n\n    sort(books.begin(),books.end());\n    int longest_reading = (books.end()-1)->read;\n    \n    int fill_space = total_reading - longest_reading;\n    if(fill_space < longest_reading){\n      memset(dp,false,sizeof(dp));\n      dp[0] = true;\n      int max_fill = 0;\n      for(int i=N-2;i >= 0; i--){\n        for(int j=fill_space; j>=0; j--){\n          dp[j + books[i].write] = dp[j];\n          if(dp[j + books[i].write]){\n            max_fill = max(max_fill,j+books[i].write);\n          }\n        }\n      }\n\n      printf(\"%d\\n\",total_reading + total_writing + (fill_space - max_fill));\n    }\n    else{\n      printf(\"%d\\n\",total_reading + total_writing);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAX_BOOK = 1000;\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n){\n\t\tvector<pii> items;\n\t\tint readsum = 0, writesum = 0, readmax = 0;\n\t\tREP(i, n){\n\t\t\tint read, write;\n\t\t\tcin >> read >> write;\n\t\t\treadsum += read;\n\t\t\twritesum += write;\n\t\t\treadmax = max(readmax, read);\n\n\t\t\titems.push_back({read, write});\n\t\t}\n\n\t\tif(readsum > readmax * 2){\n\t\t\tcout << writesum + readsum << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tSORT(items);\n\n\t\tint dpmax = 2 * readmax - readsum + 1;\n\t\tvi dp(dpmax, 0);\n\t\tdp[0] = 1;\n\t\tint X = 0;\n\t\tREP(i, n - 1){\n\t\t\tvi dp_stk(dpmax, 0);\n\t\t\tREP(j, dpmax){\n\t\t\t\tif(dp[j]){\n\t\t\t\t\tdp_stk[j] = 1;\n\t\t\t\t\tint idx = j + items[i].second;\n\t\t\t\t\tif(idx < dpmax){\n\t\t\t\t\t\tdp_stk[idx] = 1;\n\t\t\t\t\t\tX = max(X, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = dp_stk;\n\t\t}\n\n\t\tint mods = writesum - X;\n\t\tcout << readmax * 2 + mods << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tint sum = 0, mx=0, ans=0;\n\t\tvector<pair<int,int> > v;\n\n\t\trep(i,N){\n\t\t\tint r, w;\n\t\t\tcin >> r >> w;\n\t\t\tv.emplace_back(r, w);\n\t\t\tsum += r;\n\t\t\tans += r + w;\n\t\t}\n\n\t\tsort( v.begin(), v.end() );\n\t\tmx = v.back().first;\n\t\tv.pop_back();\n\n\t\tint dp[1005]={};\n\t\tdp[0] = true;\n\t\trep(i,v.size()){\n\t\t\tint w = v[i].second;\n\t\t\tfor(int j=1000; j>=0; j--){\n\t\t\t\tif( j+w <= 1000 ){\n\t\t\t\t\tdp[j+w] |= dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tmp = max(0, 2*mx - sum);\n\t\trep(i,1000){\n\t\t\tif( dp[tmp-i] ){\n\t\t\t\tans += i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) begin(x), end(x)\n#define RALL(x) rbegin(x), rend(x)\nusing pii = pair<int, int>;\n\nsigned main() {\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    \n    int rsum = 0, wsum = 0;\n    vector<pii> rw(n);\n    REP(i, n) {\n      int r, w;\n      cin >> r >> w;\n      rw[i] = {r, w};\n      rsum += r;\n      wsum += w;\n    }\n    sort(RALL(rw));\n    \n    int rmax = rw.front().first;\n    if (rmax <= rsum - rmax) {\n      int ans = rsum;\n      REP(i, n) {\n        ans += rw[i].second;\n      }\n      cout << ans << endl;\n    } else {\n      int W = rmax - (rsum - rmax);\n      vector<vector<bool>> dp(n + 1, vector<bool>(W + 1));\n      dp[0][0] = true;\n      REP(i, n) {\n        REP(j, W + 1) {\n          if (dp[i][j]) {\n            int nj = j + rw[i].second;\n            if (i != 0 && nj <= W) dp[i + 1][nj] = true;\n            dp[i + 1][j] = true;\n          }\n        }\n      }\n      int tmp = 0;\n      for (int i = W; i >= 0; i--) {\n        if (dp[n][i]) {\n          tmp = i;\n          break;\n        }\n      }\n      int add = wsum - tmp;\n      cout << rmax * 2 + add << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid solve(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0)return;\n        vector<pair<int, int>> inputs;\n        int hoge = 0;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            inputs.push_back(mp(a, b));\n            hoge += a;\n        }\n        sort(ALL(inputs));\n        if (hoge >= 2 * inputs.back().first) {\n            int sum = 0;\n            REP(i, inputs.size()) sum += inputs[i].first + inputs[i].second;\n            cout << sum << endl;\n            continue;\n        }\n        int dp[2024] = {};\n        dp[0] = 0;\n        for (int i = 0; i < (int)inputs.size() - 1; ++i) {\n            for (int q = 1000; q >= 0;--q) {\n                int hoge = q + inputs[i].second;\n                if (hoge <= 2000) {\n                    dp[hoge] = max(dp[hoge], dp[q] + inputs[i].second);\n                }\n            }\n        }\n        int sum = 0;\n        REP(i, inputs.size()) sum += inputs[i].second;\n        sum -= dp[2 * inputs.back().first - hoge];\n        sum += inputs.back().first * 2;\n        cout << sum << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\nbool isso(long long int a) {\n\tif (a == 1||a==0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\n\nint main() {\n\t\n\twhile (1) {\n\t\tvector<int>reads;\n\t\tvector<int>writes;\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\treads.push_back(a);\n\t\t\twrites.push_back(b);\n\t\t}\n\t\tint ans;\n\t\tconst int readsum = accumulate(reads.begin(), reads.end(), 0);\n\t\tint readtime;\n\t\tconst auto maxid = (max_element(reads.begin(), reads.end()))-reads.begin();\n\t\tif (reads[maxid] * 2 > readsum) {\n\t\t\treadtime = reads[maxid] * 2;\n\t\t\tconst int resttime = readtime - readsum;//余った時間で感想文書く//maxの以外\n\n\t\t\tbool dp[1001];\n\t\t\tmemset(dp, false, sizeof(dp));\n\t\t\tdp[0] = true;\n\t\t\tfor (int j = N - 1; j >= 0; --j) {\n\t\t\tfor (int i = resttime-1; i >=0; --i) {\n\t\t\t\tif (dp[i]) {\n\n\t\t\t\t\t\tif (j != maxid) {\n\t\t\t\t\t\t\tif (i + writes[j] <= resttime) {\n\t\t\t\t\t\t\t\tdp[i + writes[j]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxtime;\n\t\t\tfor (int i = resttime; i >= 0; --i) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tmaxtime = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0) - maxtime;\n\n\t\t}\n\t\telse {\n\t\t\treadtime = readsum;\n\n\t\t\tans = readtime + accumulate(writes.begin(), writes.end(), 0);\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nbool dp[1001][1001] = {0};\nint main() {\n\tint N;\n\twhile ( cin >> N, N ) {\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint r, w; cin >> r >> w;\n\t\t\tv.push_back( P(r, w) );\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tif (N == 1) {\n\t\t\tcout << v[0].first + v[0].first + v[0].second << endl;\n\t\t}\n\t\telse {\n\t\t\tint S = 0;\n\t\t\tfor (int i = 0; i < N-1; ++i) {\n\t\t\t\tS += v[i].first;\n\t\t\t}\n\t\t\tif (S >= v[N-1].first) {\n\t\t\t\tint ans = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tans += v[i].first + v[i].second;\n\t\t\t\t}\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint W = v[N-1].first-S;\n\t\t\t\tfill(dp[0], dp[1001], false);\n\t\t\t\tdp[0][0] = true;\n\t\t\t\tfor (int i = 0; i < N-1; ++i) {\n\t\t\t\t\tfor (int j = 0; j <= W; ++j) {\n\t\t\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\t\t\tdp[i+1][j] = true;\n\t\t\t\t\t\t\tint nj = j + v[i].second;\n\t\t\t\t\t\t\tif (nj <= W) {\n\t\t\t\t\t\t\t\tdp[i+1][nj] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ans = 0;\n\t\t\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\t\t\tif (dp[N-1][i]) {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint SW = 0;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tSW += v[i].second;\n\t\t\t\t}\n\t\t\t\tans = v[N-1].first + v[N-1].first + SW - ans;\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n#include<fstream>\n\n#define N 1000//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[10000000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif (dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\tif (!fin)cout << \"file read error!\" << endl;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\n\t\tfin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfin >> rTime[i] >> wTime[i];\n//\t\t\tcout << rTime[i] << wTime[i] << endl;\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(int (i)=(b)-1;(i)>=(a);(i)--)\nusing namespace std;\n\nint main(void){\n\tint N;\n\tint read[1000];\n\tint write[1000];\n\tbool dp[1001];\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)\n\t\t\treturn(0);\n\n\t\trep(i, 0, N)\n\t\t\tcin >> read[i] >> write[i];\n\n\t\tint read_sum = 0;\n\t\tint read_max = 0;\n\t\tint max_index = 0;\n\t\trep(i, 0, N){\n\t\t\tif (read[i] > read_max)\n\t\t\t\tread_max = read[max_index = i];\n\t\t\tread_sum += read[i];\n\t\t}\n\t\tread_sum -= read_max;\n\n\t\tint write_sum = 0;\n\t\trep(i, 0, N)\n\t\t\twrite_sum += write[i];\n\n\t\tint all_sum = read_max + read_sum + write_sum;\n\t\tint wait_space = read_max - read_sum;\n\t\tif (wait_space <= 0)\n\t\t\tcout << all_sum << endl;\n\t\telse{\n\t\t\trep(i, 0, wait_space + 1)\n\t\t\t\tdp[i] = false;\n\t\t\tdp[0] = true;\n\t\t\trep(i, 0, N)\n\t\t\tif (i!=max_index)\n\t\t\t\trev(j, write[i], wait_space + 1)\n\t\t\tif (dp[j - write[i]])\n\t\t\t\tdp[j] = true;\n\n\t\t\trev(i, 0, wait_space + 1)\n\t\t\tif (dp[i]){\n\t\t\t\tcout << ((wait_space)-i) + all_sum<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\n\nvoid solve(){\n\tint r[1010],w[1010],sumr = 0,sumw = 0;\n\tvector<P> vec;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> r[i] >> w[i];\n\t\tvec.emplace_back(r[i],w[i]);\n\t\tsumr += r[i];\n\t\tsumw += w[i];\n\t}\n\tsort(all(vec));\n\tfor(int i = 0;i < n;i++){\n\t\tr[i] = vec[i].first;\n\t\tw[i] = vec[i].second;\n\t}\n\tif(sumr >= r[n - 1] * 2){\n\t\tcout << sumr + sumw << endl;\n\t\treturn;\n\t}\n\tbool dp[1010][1010] = {};\n\tdp[0][0] = true;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tfor(int j = 0;j <= 1000;j++){\n\t\t\tdp[i + 1][j] = dp[i][j] | ((j >= w[i]) ? dp[i][j - w[i]] : false);\n\t\t}\n\t}\n\tint ma = 0;\n\tfor(int i = 0;i <= 2 * r[n - 1] - sumr;i++){\n\t\tif(dp[n - 1][i]) chmax(ma,i);\n\t}\n\tcout << 2 * r[n - 1] + sumw - ma << endl;\n}\n\nsigned main(){\n\twhile(cin >> n,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, r[1000],w[1000];\nbool dp[1001][1001];\n\nint main(){\n  while(cin >> n,n){\n    int sumr = 0, sumw = 0, id = 0;\n    for(int i=0;i<n;i++){\n      cin >> r[i] >> w[i];\n      sumr += r[i]; sumw += w[i];\n      if(r[id] < r[i])id = i;\n    }\n\n    if(sumr-r[id] >= r[id]){\n      cout << sumr + sumw << endl;\n      continue;\n    }\n\n    int lim = 2*r[id]-sumr;\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<=lim;j++)dp[i][j] = false;\n    }\n    dp[0][0] = true;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<=lim;j++){\n\tif(dp[i][j]){\n\t  dp[i+1][j] = true;\n\t  if(i!=id && j+w[i]<=lim)dp[i+1][j+w[i]] = true;\n\t}\n      }\n    }\n    \n    int tmp = 0;\n    for(int i=0;i<=lim;i++){\n      if(dp[n][i])tmp = i;\n    }\n    cout << sumr + sumw + lim - tmp << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<cmath>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define min_(a,b) ((a)<(b)?(a):(b))\nusing namespace std;\n\nint N;\nstruct Book{\n\tint page;\n\tint write;\n};\nBook book[1000];\nint dp[1000 * 1000];\nint sum = 0;\nint deal = 0;\nint solve(){\n\tmemset(dp, 0, sizeof(dp));\n\tint s = book[N - 1].page*2-sum;\n\tdp[0] = -1;\n\trep(i, 0, N - 1){\n\t\trep(j, 1, s+1)\n\t\tif (j - book[i].write >=0 && dp[j - book[i].write] != 0 && dp[j - book[i].write] <= i)dp[j] = i+1;\n\t}\n\tfor (int i = s; i >= 0; i--)if (dp[i] != 0){\n\t\treturn(s - i);\n\t}\n\n\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)return(0);\n\t\tint max_n=0,max_i=0;\n\t\tsum = 0;\n\t\tdeal = 0;\n\t\trep(i, 0, N){\n\t\t\tcin >> book[i].page >> book[i].write;\n\t\t\tsum += book[i].page;\n\t\t\tdeal += book[i].write;\n\t\t\tif (book[i].page > max_n)max_n = book[i].page, max_i = i;\n\t\t}\n\t\tif (sum >= max_n * 2)cout << sum + deal << endl;\n\t\telse{\n\t\t\tBook tmp = book[max_i];\n\t\t\tbook[max_i] = book[N - 1];\n\t\t\tbook[N - 1] = tmp;\n\t\t\tcout << sum+deal+solve() << endl;\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n  \n \n  \nint main(){\n  \n    int n; \n    while(scanf(\"%d\",&n),n){\n \n        vector<pair<int,int> > rw(n);\n        int sum_r=0,sum_w=0;\n        for(int i=0;i<n;i++){\n            cin>>rw[i].first>>rw[i].second;\n            sum_r+=rw[i].first;\n            sum_w+=rw[i].second;\n        }\n        sort(rw.begin(),rw.end(),greater< pair<int,int> >());\n \n        int r0=rw[0].first;\n        int r=sum_r-r0;\n \n        if(r0 <= r){\n            cout<<sum_r+sum_w<<endl;\n        }else{\n \n            int res=2*rw[0].first;\n            vector<vector<bool> > dp(1001,vector<bool>(1000,false));\n \n            dp[1][0]=true;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<=1000;j++){\n                    if(dp[i][j]){\n                        dp[i+1][j]=true; \n                        if(j+rw[i].second<=1000)\n                            dp[i+1][j+rw[i].second]=true; \n                    }\n                }\n            }\n \n            int opt=0;\n            for(int i=1;i<=r0-r;i++){\n                if(dp[n][i]) opt=i;\n            }\n \n            res+=sum_w-opt;\n            cout<<res<<endl;\n \n \n \n        }\n         \n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\n\nint dp[1111];\nint a,b,n,sum,sum2;\nvector<P>v;\n\nsigned main(){\n  while(cin>>n,n){\n    sum=sum2=0;\n    v.clear();\n    r(i,n){\n      cin>>a>>b;\n      v.push_back(P(a,b));\n    }\n    sort(v.begin(),v.end());\n    r(i,n-1)sum+=v[i].F;\n    r(i,n)sum2+=v[i].S;\n    if(sum>=v[n-1].F){\n      cout<<sum+sum2+v[n-1].F<<endl;\n      continue;\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0]=1;\n    for(int i=0;i<n-1;i++){\n      for(int j=1100;j>=0;j--)if(dp[j]){\n        if(j+v[i].F<1001)dp[j+v[i].F]=1;\n        if(j+v[i].F+v[i].S<1001)dp[j+v[i].F+v[i].S]=1;\n      }\n    }\n    for(int i=v[n-1].F;i>=0;i--){\n      if(!dp[i])continue;\n      cout<<v[n-1].F-i+v[n-1].F+sum+sum2<<endl;\n      break;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\nvoid maxUpdate(int& a, int b) { a = max(a, b); }\n\nint N, r[1010], w[1010];\nbool dp[1010][2];\n\nvoid solve() {\t\n\tint max_r = *max_element(r, r+N);\n\tint sum_other = accumulate(r, r+N, int()) - max_r;\n\tint sum_w = accumulate(w, w+N, int());\n\t\n\tif (sum_other >= max_r) {\n\t\tcout << max_r + sum_other + sum_w << endl;\n\t} else {\n\t\tint rem_time = max_r - sum_other;\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1;\n\t\tfor_(i,0,N) for_(t,0,rem_time+1) for_(f,0,2) {\n\t\t\tif (f && r[i] == max_r) continue;\n\t\t\tif (dp[t][f] && t+w[i] <= rem_time) dp[t+w[i]][f | (r[i] == max_r)] = 1;\n\t\t}\n\t\t\n\t\tint max_cnt = 0;\n\t\tfor_(i,0,N) max_cnt += (r[i] == max_r);\n\t\t\n\t\tfor_rev(t,rem_time,0) for_(f,0,2) {\n\t\t\tif (max_cnt == 1 && f) continue;\n\t\t\tif (dp[t][f]) {\n\t\t\t\tcout << max_r * 2 + sum_w - t << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor_(i,0,N) cin >> r[i] >> w[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        int r[1111], w[1111];\n        rep(i, n)\n            cin >> r[i] >> w[i];\n        int sum_r = accumulate(r, r + n, 0);\n        int sum_w = accumulate(w, w + n, 0);\n\n        vector<pint> b;\n        rep(i, n)\n            b.pb(pint(r[i], w[i]));\n        sort(all(b));\n\n        int rem = b.back().first - (sum_r - b.back().first);\n        if (rem <= 0)\n            cout << sum_r + sum_w << endl;\n        else\n        {\n            bool dp[2111];\n            CL(dp, 0);\n            dp[0] = true;\n            rep(i, b.size() - 1) revrep(j, rem)\n                dp[j + b[i].second] |= dp[j];\n            int written = 0;\n            erep(j, rem)\n                if (dp[j])\n                    written = j;\n\n            int mami = (2 * b.back().first) + (sum_w - written);\n            cout << mami << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\n#define FORR(i,a,b) for(int i=(b)-1; i>=(a); i--)\n\n#define ALL(v) (v).begin(), (v).end()\n#define CHMAX(a,b) a=max(a,b)\n#define CHMIN(a,b) a=min(a,b)\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n\nint n;\nint r[1252], w[1252];\nbool ok[2521];\n\nint main(){\n    while(true){\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        REP(i,n)scanf(\"%d%d\",r+i,w+i);\n        int rsum = accumulate(r,r+n,0);\n        int mx = *max_element(r,r+n);\n        if(2*mx <= rsum){\n            int ans = rsum + accumulate(w,w+n,0);\n            printf(\"%d\\n\",ans);\n        }else{\n            int wsum = accumulate(w,w+n,0);\n            int mxid = max_element(r,r+n)-r;\n            int rest = 2*mx - rsum;\n            fill(ok,ok+1252,false);\n            ok[0] = true;\n            REP(i,n)if(i != mxid){\n                FORR(j,w[i],rest+1)ok[j] = ok[j] || ok[j-w[i]];\n            }\n            int go = 0;\n            REP(i,rest+1)if(ok[i])go=i;\n            int ans = 2*mx + (wsum-go);\n            printf(\"%d\\n\",ans);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\npair<int, int>x[1000]; int n, a, b, s1, s2, dp[1100000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; s1 = 0; s2 = 0; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { cin >> a >> b; x[i] = make_pair(a, b); s1 += a; s2 += b; }\n\t\tsort(x, x + n);\n\t\tif (x[n - 1].first * 2 <= s1) { cout << s1 + s2 << endl; }\n\t\telse {\n\t\t\tfor (int i = 0; i <= s2; i++)dp[i] = 0; dp[0] = 1;\n\t\t\tint nokori = x[n - 1].first - (s1 - x[n - 1].first);\n\t\t\tvector<int>f; f.push_back(0);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tvector<int>g;\n\t\t\t\tfor (int a1 : f) {\n\t\t\t\t\tif (dp[a1 + x[i].second] == 0) { g.push_back(a1 + x[i].second); dp[a1 + x[i].second] = 1; }\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < g.size(); i++)f.push_back(g[i]);\n\t\t\t}\n\t\t\tint g = 0; for (int i = nokori; i >= 0; i--) { if (dp[i] == 1) { g = i; break; } }\n\t\t\tcout << (nokori - g) + s1 + s2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nint N;\nVI R, W;\n\nint solve() {\n    // ?????§r???idx\n    int max_r_i;\n    {\n        auto it = max_element(ALL(R));\n        max_r_i = it - R.begin();\n    }\n\n    // ?????§r????????????sum\n    int other_sum = accumulate(ALL(R), 0) - R[max_r_i];\n\n    // calc time\n    int r_time;\n    int w_time;\n    if (other_sum >= R[max_r_i]) {\n        r_time = other_sum + R[max_r_i];\n        w_time = accumulate(ALL(W), 0);\n    } else {\n        r_time = R[max_r_i] * 2;\n\n        int T = R[max_r_i] - other_sum;\n\n        VB dp(T + 1);\n        dp[0] = true;\n\n        rep(i, N) {\n            if (i == max_r_i) continue;\n            for (int j = T; j >= 0; --j) {\n                if (dp[j]) {\n                    int t = j + W[i];\n                    if (t <= T) {\n                        dp[t] = true;\n                    }\n                }\n            }\n        }\n\n        int t = 0;\n        rep(i, T + 1) {\n            if (dp[i]) {\n                t = i;\n            }\n        }\n\n        w_time = accumulate(ALL(W), 0) - t;\n    }\n\n    return r_time + w_time;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        R = VI(N);\n        W = VI(N);\n\n        rep(i, N) {\n            cin >> R[i] >> W[i];\n        }\n\n        cout << solve() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int N = 1000;\n\nint n;\npair<int, int> data[N];\n\nint calc(int emp){\n  bool dp[N][N+1];\n  fill(dp[0], dp[N], false);\n  dp[0][0] = true;\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=emp;j++){\n      dp[i+1][j] |= dp[i][j];\n      if(j+data[i].second <= emp) dp[i+1][j+data[i].second] |= dp[i][j];\n    }\n  }\n  int tmp = 0;\n  for(int i=0;i<=emp;i++) if(dp[n-1][i]) tmp = i;\n  int res = data[n-1].first * 2;\n  for(int i=0;i<n;i++) res += data[i].second;\n  return res - tmp;\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      data[i] = make_pair(a, b);\n    }\n    sort(data, data+n);\n    int sum = 0;\n    for(int i=0;i<n-1;i++) sum += data[i].first;\n    int ans = 0;\n    if(sum >= data[n-1].first){\n      for(int i=0;i<n;i++) ans += data[i].first + data[i].second;\n    }else ans = calc(data[n-1].first - sum);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// dp[k][sum] := w[k] まで使ったときに合計が sum になるかどうか\nbool dp[1001][1001];\n\nint main(){\n\tint N, r[1001], w[1001];\n\twhile( cin >> N , N ){\n\t\tfor(int i = 0 ; i < 1001 ; i++ ) fill(dp[i], dp[i] + 1001, false);\n\t\n\t\tint sum_r = 0, sum_w = 0, max_r = 0, k;\n\t\tfor(int i = 0 ; i < N ; i++ ){\n\t\t\tcin >> r[i] >> w[i];\n\t\t\tsum_r += r[i];\n\t\t\tsum_w += w[i];\n\t\t\tif( max_r < r[i] ){\n\t\t\t\tk = i;\n\t\t\t}\n\t\t\tmax_r = max(max_r, r[i]);\n\t\t}\n\n\t\tif( max_r <= sum_r - max_r ){\n\t\t\tcout << sum_r + sum_w << endl;\n\t\t}else{\n\t\t\t// wt := 待ち時間\n\t\t\tint wt = 2 * max_r - sum_r, res = 0;\n\t\t\t\n\t\t\t// w[0..N-1] の部分和で wt 以下の最大値を DP で求める\n\t\t\t// r[k] の本はまだ読んでいないので感想は書けない\n\t\t\tw[k] = 0;\n\t\t\tdp[0][0] = true;\n\t\t\tfor(int i = 0 ; i < N ; i++ ){\n\t\t\t\tfor(int j = 0 ; j <= wt ; j++ ){\n\t\t\t\t\tif( dp[i][j] ){\n\t\t\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\t\t\tif( j + w[i] <= wt ){\n\t\t\t\t\t\t\tdp[i + 1][j + w[i]] = dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0 ; j <= wt ; j++ ){\n\t\t\t\tif( dp[N][j] ) res = j;\n\t\t\t}\n\t\t\tint ans = 2 * max_r + sum_w - res;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N;\n\nint solve(vector<pii> v){\n\t\n\tsort(v.begin(), v.end());\n\t\n\tint rl, rs = 0, ws = 0;\n\tbool dp[1010] = {0};\n\t\n\trl = v[N-1].first;\n\t\n\tfor(int i=0; i<N; ++i){\n\t\trs += v[i].first;\n\t\tws += v[i].second;\n\t}\n\t\n\trs -= rl;\n\t\n\tif(rs >= rl){\n\t\treturn rs + rl + ws;\n\t}\n\t\n\tdp[0] = true;\n\t\n\tfor(int i = 0; i < N-1; ++i){\n\t\tfor(int j=rl-rs; j >=0; --j){\n\t\t\t\n\t\t\tif( dp[j] && j + v[i].second <= rl - rs ){\n\t\t\t\tdp[j + v[i].second] = true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tint maxwrite = 0;\n\t\n\tfor(int i = rl - rs; i >= 0; ++i){\n\t\n\t\tif(dp[i])\n\t\t\treturn 2*rl + ws - i;\n\t}\n}\n\nint main(){\n\t\n\twhile(cin>>N, N){\n\t\t\n\t\tvector<pii> v;\n\t\tint r, w;\n\t\t\n\t\tfor(int i=0; i<N; ++i){\n\t\t\t\n\t\t\tcin >> r >> w;\n\t\t\tv.push_back(make_pair(r, w));\n\t\t}\n\t\t\n\t\tcout << solve(v) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\nusing namespace std;\n\nint main(void){\n\tint N;\n\tint read[1000];\n\tint write[1000];\n\tbool dp[1001];\n\twhile (true){\n\t\tcin >> N;\n\t\tif (N == 0)\n\t\t\treturn(0);\n\n\t\trep(i, 0, N)\n\t\t\tcin >> read[i] >> write[i];\n\n\t\tint read_sum = 0;\n\t\tint read_max = 0;\n\t\tint max_index = 0;\n\t\trep(i, 0, N){\n\t\t\tif (read[i] > read_max)\n\t\t\t\tread_max = read[max_index = i];\n\t\t\tread_sum += read[i];\n\t\t}\n\t\tread_sum -= read_max;\n\n\t\tint write_sum = 0;\n\t\trep(i, 0, N)\n\t\t\twrite_sum += write[i];\n\n\t\tint all_sum = read_max + read_sum + write_sum;\n\t\tint wait_space = read_max - read_sum;\n\t\tif (wait_space <= 0)\n\t\t\tcout << all_sum << endl;\n\t\telse{\n\t\t\trep(i, 0, wait_space + 1)\n\t\t\t\tdp[i] = false;\n\t\t\tdp[0] = true;\n\t\t\trep(i, 0, N)\n\t\t\tif (i!=max_index)\n\t\t\t\trev(j, write[i], wait_space + 1)\n\t\t\tif (dp[j - write[i]])\n\t\t\t\tdp[j] = true;\n\n\t\t\trev(i, 0, wait_space + 1)\n\t\t\tif (dp[i]){\n\t\t\t\tcout << ((wait_space)-i) + all_sum<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2510: Twin book report\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint r[1003], w[1003];\nint dp[1000003];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint i, j, k, sr, sw, max;\n\tint t;\n\n\twhile (n = in()) {\n\t\tsr = sw = 0, max = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint _r, _w;\n\t\t\tr[i] = _r = in(), w[i] = _w = in();\n\t\t\tif (r[max] < _r) max = i;\n\t\t\tsr += _r, sw += _w;\n\t\t}\n\n\t\tif ((r[max] << 1) <= sr) { printf(\"%d\\n\", sr + sw); continue; }\n\n\t\tt = r[n-1], r[n-1] = r[max], r[max] = t;\n\t\tt = w[n-1], w[n-1] = w[max], w[max] = t;\n\t\tk = (r[n-1] << 1) - sr;\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0] = 1;\n\t\tfor (i = 0; i < n-1; i++) for (j = k; j >= w[i]; j--) dp[j] |= dp[j-w[i]];\n\t\tt = -1; for (i = k; i >= 0; i--) if (dp[i]) { t = k - i; break; }\n\t\tprintf(\"%d\\n\", sr + sw + t); \n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2510\nTitle Twin book report\n*/\n#include <stdio.h>\n\nint N;\nint r[1000],w[1000];\n\nint max_read;         //max read time\nint maxbookno;        //max read time book no\nint sum_except_max;   //all read time except max\nint sum_write;        //all write time\nint gap;              //difference between max_read and sum_excep max\nint max_write_while_read; //longest write time while gap\n//\nint get_all_sum()\n{\n        int i,sum;\n        sum=0;\n        for(i=0;i<N;i++)\n                sum+=(r[i]+w[i]);\n        return(sum);\n}\nint get_max_read(int * pos)\n{\n        int i,ret;\n        ret=0;\n        for(i=0;i<N;i++)\n        {\n                if(ret<r[i])\n                {\n                        ret=r[i];\n                        *pos=i;\n                }\n        }\n        return(ret);\n}\nint get_sum_except_max()\n{\n        int i,ret;\n        ret=0;\n        for(i=0;i<N;i++)\n                ret+=r[i];\n        ret -= max_read;\n        return(ret);\n}\nint while_read(int ceil_,int start,int sum)\n{\n        int c,ret,ret1,ret2;\n#ifdef DEBUG\n        printf(\"WR %d %d %d\\n\",ceil_,start,sum);\n\n#endif\n        if(start>N-1)\n                return(sum);\n        c=start;\n        while(w[c]>ceil_)\n                c++;\n        if(c>N-1)\n                return(sum);\n        ret1=while_read(ceil_,start+1,sum);\n\n        ret2=while_read(ceil_-w[c],start+1,sum+w[c]);\n\n        if(ret1>ret2)\n                ret=ret1;\n        else\n                ret=ret2;\n        return(ret);\n}\nint get_max_write_while_read()\n{\n        return(while_read(gap,0,0));\n}\nint get_sum_write()\n{\n        int i,ret;\n        ret=0;\n        for(i=0;i<N;i++)\n                ret+=w[i];\n        return(ret);\n}\nint compare_int(const void *a, const void *b)\n{\n    return *(int*)b - *(int*)a;\n}\n\n\nmain()\n{\n        int i,ret;\n\n        while(EOF!=scanf(\"%d\",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                        scanf(\"%d %d\",&r[i],&w[i]);\n                if(N==1)\n                {\n                        ret = 2*r[0]+w[0];\n                        goto PRINT;\n                }\n                max_read=get_max_read(&maxbookno);\n                sum_except_max=get_sum_except_max();\n                gap=max_read-sum_except_max;\n#ifdef DEBUG\n                printf(\"Mr:SexcM:G:MBk=%d:%d:%d:%d\\n\",max_read,\n                       sum_except_max,gap,maxbookno);\n#endif\n                if(gap<=0)\n                        ret=get_all_sum();\n                else\n                {\n                        sum_write=get_sum_write();\n                        if(sum_write - w[maxbookno]<gap)\n                        {\n                                ret=2*max_read+w[maxbookno];\n                        }\n                        w[maxbookno]=0;\n                        qsort(w,N,sizeof(int),compare_int);\n                        max_write_while_read=get_max_write_while_read();\n#ifdef DEBUG\n                        printf(\"W:%d %d %d SW:%d MWWR %d\\n\"\n                               ,w[0],w[1],w[2],sum_write\n                               ,max_write_while_read);\n#endif\n                        ret=2*max_read+sum_write-max_write_while_read;\n\n                }\n        PRINT:\n                printf(\"%d\\n\",ret);\n       }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint comp(const void *b,const void * a){\n  return *(int*)a - *(int*)b;\n}\nvoid cal(int sub,int data[1000],int count,int i,int sum,int rest,int* halt,int* max){//sum(i of data 1 or 0)\n  //want to look at data[i]\n  //if halt == 1 >>> return;\n  //if sum == sub  >>>  halt=1; max; return;\n  //if i == count  >>> return sum\n  //\n  //printf(\"calculating sub %d,i %d,sum %d,rest %d,max %d\\n\",sub,i,sum,rest,*max);\n  if(*halt==1){//halt\n    return;\n  }\n  if(sum==sub){//to halt\n    *halt=1;\n    *max=sub;\n    return;\n  }\n  if(rest+sum < *max){\n    return;\n  }\n  if(rest+sum < sub && rest + sum > *max){//or new max\n    *max=rest+sum;\n    if(*max==sub){\n      *halt=1;\n    }\n    return;\n  }\n  if(*max<sum){//new max\n    *max=sum;\n  }\n  if(i<count){\n    if(data[i]+sum <= sub){\n      cal(sub,data,count,i+1,sum+data[i],rest-data[i],halt,max);\n    }\n    if(*halt){\n      return;\n    }\n    cal(sub,data,count,i+1,sum,rest-data[i],halt,max);\n    if(*halt){\n      return;\n    }\n\n  }\n  \n  return;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi,int rest){\n  \n  int i,j;\n  int data2[1000];\n  for(i=0;i<count;i++){\n    data2[i]=data[i][1];\n  }\n  data2[maxi]=0;\n  qsort(data2,count,sizeof(int),comp);\n  int halt=0,max=0;\n  \n  FILE *fp;\n  fp = fopen(\"log\",\"w\");\n  fprintf(fp,\"count:%d\\nsub:%d\\nrest:%d\\n\",count,sub,rest);\n  for(i=0;i<count;i++){\n    fprintf(fp,\"%d\\n\",data2[i]);\n  }\n  \n  cal(sub,data2,count,0,0,rest,&halt,&max);\n  return sub-max;\n  \n}\n\n\nint main(void){\n  FILE *fp;\n  //fp = fopen(\"003\",\"r\");\n  //fp = fopen(\"2510-in1.txt\",\"r\");\n  fp = stdin;\n  /*if(fp==NULL){\n    printf(\"error opening file\\n\");\n    return 1;\n    }*/\n  \n  int count;\n  int i,j;\n  int data[1000][2];\n  int max,maxi,rsum,wsum;\n  int sub;\n  int rest;\n  int res;\n  while(1){\n    fscanf(fp,\"%d\",&count);\n    if(count==0){\n      return 0;\n    }\n    max=0;rsum=0;wsum=0;\n    for(i=0;i<count;i++){\n      fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n      if(data[i][0]>max){\n\tmax=data[i][0];\n\tmaxi=i;\n      }\n      rsum+=data[i][0];\n      wsum+=data[i][1];\n    }\n    \n    if(2*max<=rsum){\n      res=rsum+wsum;\n    }else{\n      rest=wsum-data[maxi][1];\n      sub = 2 * max - rsum;\n      if(rest<=sub){\n\tres=rsum+wsum+sub-rest;\n      }else{\n\t//printf(\"sub%d rest%d rsum-max%d wsum%d rsum+wsum%d\\n\",sub,rest,rsum-max,wsum,rsum+wsum);\n\tsub = calsub(sub,data,count,maxi,rest);\n\tres = rsum+wsum+sub;\n      }\n    }\n\n    printf(\"%d\\n\",res);\n    \n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "char W[9],V[9];Z[8],S,N,T,P,M;main(i,j,k,l,r,d){for(;scanf(\"%d%d%d%s%s%d%d\",&S,&N,&T,W,V,&P,&M),S;printf(\"%.10f\\n\",1-pow(1-1.0/P,N*r))){\n\tmemset(Z,0,sizeof(Z));\n\tl=*W=='A'?2:1;\n\td=24*60*(*W=='A'?1:7);\n\tif(*V=='A')for(i=0;i<l;i++)Z[i*4]=Z[i*4+1]=Z[i*4+2]=Z[i*4+3]=1;\n\tif(*V=='D')for(i=0;i<l;i++)Z[i*4+1]=Z[i*4+2]=1;\n\tif(*V=='N')for(i=0;i<l;i++)Z[i*4]=Z[i*4+3]=1;\n\tfor(r=j=0;j<24*60;r=r>l?r:l,j++)for(k=j,l=i=0;i<M;k=(k+T)%d,i++)if(k<24*60)l+=Z[(k+S)%(48*60)/360]&Z[k/360];\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint comp(const void *a,const void * b){\n  return *(int*)a - *(int*)b;\n}\nint cal(int sub,int data[1000],int count,int i,int sum,int rest,int* halt){//sum(i of data 1 or 0)\n  //want to look at data[i]\n  //if halt == 1 >>> return sub;\n  //if sum == sub  >>>  halt=1; return sub;\n  //if i == count  >>> return sum\n  //\n  //printf(\"calculating sub %d,i %d,sum %d,rest %d\\n\",sub,i,sum,rest);\n  if(*halt==1){\n    return sub;\n  }\n  if(sum==sub){\n    *halt=1;\n    return sub;\n  }\n  if(rest+sum<sub){\n    return sum+rest;\n  }\n  \n  int a,b;\n  if(i<count){\n    a=(data[i]+sum > sub) ? 0 : cal(sub,data,count,i+1,sum+data[i],rest-data[i],halt);\n    if(a==sub){\n      *halt=1;\n    }\n    if(*halt){\n      return sub;\n    }\n    b=cal(sub,data,count,i+1,sum,rest-data[i],halt);\n    if(*halt){\n      return sub;\n    }\n    return (a>b)?a:b;\n  }\n  \n  return sum;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi,int rest){\n  \n  int i,j;\n  int data2[1000];\n  for(i=0;i<count;i++){\n    data2[i]=data[i][1];\n  }\n  data2[maxi]=0;\n  qsort(data2,count,sizeof(int),comp);\n  int halt=0;\n  int sum = cal(sub,data2,count,0,0,rest,&halt);\n  return sub-sum;\n  \n}\n\n\n\nint main(void){\n  FILE *fp;\n  //fp = fopen(\"2510-in1.txt\",\"r\");\n  fp = stdin;\n  /*if(fp==NULL){\n    printf(\"error opening file\\n\");\n    return 1;\n    }*/\n  \n  int count;\n  int i,j;\n  int data[1000][2];\n  int max,maxi,rsum,wsum;\n  int sub;\n  int rest;\n  int res;\n  while(1){\n    fscanf(fp,\"%d\",&count);\n    if(count==0){\n      return 0;\n    }\n    max=0;rsum=0;wsum=0;\n    for(i=0;i<count;i++){\n      fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n      if(data[i][0]>max){\n\tmax=data[i][0];\n\tmaxi=i;\n      }\n      rsum+=data[i][0];\n      wsum+=data[i][1];\n    }\n    \n    if(2*max<=rsum){\n      res=rsum+wsum;\n    }else{\n      rest=wsum-data[maxi][1];\n      sub = 2 * max - rsum;\n      if(rest<=sub){\n\tres=rsum+wsum+sub-rest;\n      }else{\n\tsub = calsub(sub,data,count,maxi,rest);\n\tres = rsum+wsum+sub;\n      }\n    }\n\n    printf(\"%d\\n\",res);\n    \n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint comp(const void *b,const void * a){\n  return *(int*)a - *(int*)b;\n}\nvoid cal(int sub,int data[1000],int count,int i,int sum,int rest,int* halt,int* max){//sum(i of data 1 or 0)\n  //want to look at data[i]\n  //if halt == 1 >>> return;\n  //if sum == sub  >>>  halt=1; max; return;\n  //if i == count  >>> return sum\n  //\n  //printf(\"calculating sub %d,i %d,sum %d,rest %d,max %d\\n\",sub,i,sum,rest,*max);\n  if(*halt==1){//halt\n    return;\n  }\n  if(sum==sub){//to halt\n    *halt=1;\n    *max=sub;\n    return;\n  }\n  if(rest+sum < *max){\n    return;\n  }\n  if(rest+sum < sub && rest + sum > *max){//or new max\n    *max=rest+sum;\n    if(*max=sub){\n      *halt=1;\n    }\n    return;\n  }\n  if(*max<sum){//new max\n    *max=sum;\n  }\n  if(i<count){\n    if(data[i]+sum <= sub){\n      cal(sub,data,count,i+1,sum+data[i],rest-data[i],halt,max);\n    }\n    if(*halt){\n      return;\n    }\n    cal(sub,data,count,i+1,sum,rest-data[i],halt,max);\n    if(*halt){\n      return;\n    }\n\n  }\n  \n  return;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi,int rest){\n  \n  int i,j;\n  int data2[1000];\n  for(i=0;i<count;i++){\n    data2[i]=data[i][1];\n  }\n  data2[maxi]=0;\n  qsort(data2,count,sizeof(int),comp);\n  int halt=0,max=0;\n  \n  FILE *fp;\n  fp = fopen(\"log\",\"w\");\n  fprintf(fp,\"count:%d\\nsub:%d\\nrest:\\n\",count,sub,rest);\n  for(i=0;i<count;i++){\n    fprintf(fp,\"%d\\n\",data2[i]);\n  }\n\n  cal(sub,data2,count,0,0,rest,&halt,&max);\n  return sub-max;\n  \n}\n\n\nint main(void){\n  FILE *fp;\n  //fp = fopen(\"037\",\"r\");\n  fp = fopen(\"2510-in2.txt\",\"r\");\n  //fp = stdin;\n  /*if(fp==NULL){\n    printf(\"error opening file\\n\");\n    return 1;\n    }*/\n  \n  int count;\n  int i,j;\n  int data[1000][2];\n  int max,maxi,rsum,wsum;\n  int sub;\n  int rest;\n  int res;\n  while(1){\n    fscanf(fp,\"%d\",&count);\n    if(count==0){\n      return 0;\n    }\n    max=0;rsum=0;wsum=0;\n    for(i=0;i<count;i++){\n      fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n      if(data[i][0]>max){\n\tmax=data[i][0];\n\tmaxi=i;\n      }\n      rsum+=data[i][0];\n      wsum+=data[i][1];\n    }\n    \n    if(2*max<=rsum){\n      res=rsum+wsum;\n    }else{\n      rest=wsum-data[maxi][1];\n      sub = 2 * max - rsum;\n      if(rest<=sub){\n\tres=rsum+wsum+sub-rest;\n      }else{\n\t//printf(\"sub%d rest%d rsum-max%d wsum%d\\n\",sub,rest,rsum-max,wsum);\n\tsub = calsub(sub,data,count,maxi,rest);\n\tres = rsum+wsum+sub;\n      }\n    }\n\n    printf(\"%d\\n\",res);\n    \n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint comp(const void *b,const void * a){\n  return *(int*)a - *(int*)b;\n}\nvoid cal(int sub,int data[1000],int count,int i,int sum,int rest,int* halt,int* max){//sum(i of data 1 or 0)\n  //want to look at data[i]\n  //if halt == 1 >>> return;\n  //if sum == sub  >>>  halt=1; max; return;\n  //if i == count  >>> return sum\n  //\n  //printf(\"calculating sub %d,i %d,sum %d,rest %d,max %d\\n\",sub,i,sum,rest,*max);\n  if(*halt==1){//halt\n    return;\n  }\n  if(sum==sub){//to halt\n    *halt=1;\n    *max=sub;\n    return;\n  }\n  if(rest+sum < *max){\n    return;\n  }\n  if(rest+sum < sub && rest + sum > *max){//or new max\n    *max=rest+sum;\n    if(*max=sub){\n      *halt=1;\n    }\n    return;\n  }\n  if(*max<sum){//new max\n    *max=sum;\n  }\n  if(i<count){\n    if(data[i]+sum <= sub){\n      cal(sub,data,count,i+1,sum+data[i],rest-data[i],halt,max);\n    }\n    if(*halt){\n      return;\n    }\n    cal(sub,data,count,i+1,sum,rest-data[i],halt,max);\n    if(*halt){\n      return;\n    }\n\n  }\n  \n  return;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi,int rest){\n  \n  int i,j;\n  int data2[1000];\n  for(i=0;i<count;i++){\n    data2[i]=data[i][1];\n  }\n  data2[maxi]=0;\n  qsort(data2,count,sizeof(int),comp);\n  int halt=0,max=0;\n  \n  FILE *fp;\n  fp = fopen(\"log\",\"w\");\n  fprintf(fp,\"count:%d\\nsub:%d\\nrest:\\n\",count,sub,rest);\n  for(i=0;i<count;i++){\n    fprintf(fp,\"%d\\n\",data2[i]);\n  }\n\n  cal(sub,data2,count,0,0,rest,&halt,&max);\n  return sub-max;\n  \n}\n\n\nint main(void){\n  FILE *fp;\n  //fp = fopen(\"037\",\"r\");\n  //fp = fopen(\"2510-in2.txt\",\"r\");\n  fp = stdin;\n  /*if(fp==NULL){\n    printf(\"error opening file\\n\");\n    return 1;\n    }*/\n  \n  int count;\n  int i,j;\n  int data[1000][2];\n  int max,maxi,rsum,wsum;\n  int sub;\n  int rest;\n  int res;\n  while(1){\n    fscanf(fp,\"%d\",&count);\n    if(count==0){\n      return 0;\n    }\n    max=0;rsum=0;wsum=0;\n    for(i=0;i<count;i++){\n      fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n      if(data[i][0]>max){\n\tmax=data[i][0];\n\tmaxi=i;\n      }\n      rsum+=data[i][0];\n      wsum+=data[i][1];\n    }\n    \n    if(2*max<=rsum){\n      res=rsum+wsum;\n    }else{\n      rest=wsum-data[maxi][1];\n      sub = 2 * max - rsum;\n      if(rest<=sub){\n\tres=rsum+wsum+sub-rest;\n      }else{\n\t//printf(\"sub%d rest%d rsum-max%d wsum%d\\n\",sub,rest,rsum-max,wsum);\n\tsub = calsub(sub,data,count,maxi,rest);\n\tres = rsum+wsum+sub;\n      }\n    }\n\n    printf(\"%d\\n\",res);\n    \n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        int r[1000],w[1000];\n        int rL=0,r_sum=0,w_sum=0;\n        int idx;\n        for(int i=0;i<n;i++){\n            scanf(\"%d%d\",&r[i],&w[i]);\n            r_sum+=r[i]; w_sum+=w[i];\n            if(rL<r[i]){\n                rL=r[i];\n                idx=i;\n            }\n        }\n        if(r_sum>=2*rL){\n            printf(\"%d\\n\",r_sum+w_sum);\n        }\n        else{\n            int sa=2*rL-r_sum;\n            int dp[1001][1001]={0};\n            int j=0;\n            for(int i=0;i<n;i++){\n                if(i==idx) continue;\n                else w[j++]=w[i];\n            }\n            for(int i=0;i<n-1;i++){\n                for(int j=0;j<=sa;j++){\n                    if(w[i]<=j && dp[i][j]<dp[i][j-w[i]]+w[i]){\n                        dp[i+1][j]=dp[i][j-w[i]]+w[i];\n                    }else{\n                        dp[i+1][j]=dp[i][j];\n                    }\n                }\n            }\n            int max=dp[n-1][sa];\n            /*for(int j=0;j<=sa;j++)\n                if(max<dp[n-1][j]) max=dp[n-1][j];*/\n            printf(\"%d\\n\",2*rL+w_sum-max);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n    FILE *fp;\n    fp = stdin;\n    if(fp==NULL){\n        printf(\"error opening file\\n\");\n        return 1;\n    }\n    int count;\n    int i,j;\n    int data[1000][2];\n    int max,maxi,rsum,wsum;\n    int sub;\n    while(1){\n        fscanf(fp,\"%d\",&count);\n        if(count==0){\n            return 0;\n        }\n        max=0;rsum=0;wsum=0;\n        for(i=0;i<count;i++){\n            fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n            if(data[i][0]>max){\n                max=data[i][0];\n                maxi=i;\n            }\n            rsum+=data[i][0];\n            wsum+=data[i][1];\n        }\n        \n        if(2*max<=rsum){\n            printf(\"%d\\n\",rsum+wsum);\n        }else{\n            sub = 2 * max - rsum;\n            sub = calsub(sub,data,count,maxi);\n            printf(\"%d\\n\",rsum+wsum+sub);\n        }\n        \n        \n    }\n    \n}\nint comp(int a,int b){\n    return a - b;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi){\n\n    int i,j;\n    int data2[1000];\n    for(i=0;i<count;i++){\n        data2[i]=data[i][1];\n    }\n    data2[maxi]=0;\n    qsort(data2,count,sizeof(int),comp);\n    int halt=0;\n    //printf(\"sub=%d\\n\",sub);\n    int sum = cal(sub,data2,count,0,0,&halt);\n    //printf(\"sum=%d\\n\",sum);\n    return sub-sum;\n    \n}\n\n\nint cal(int sub,int data[1000],int count,int i,int sum,int* halt){//sum(i of data 1 or 0)\n    //printf(\"calculating sub %d,i %d,sum %d\\n\",sub,i,sum);\n    if (data[i]+sum > sub){\n        return sum;\n    }\n    int a,b;\n    if(i+1<count){\n        a=cal(sub,data,count,i+1,sum+data[i],halt);\n\n        b=cal(sub,data,count,i+1,sum,halt);\n\n        return (a>b)?a:b;\n    }\n    //*halt=1;\n    \n    return sum;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint comp(const void *b,const void * a){\n  return *(int*)a - *(int*)b;\n}\nvoid cal(int sub,int data[1000],int count,int i,int sum,int rest,int* halt,int* max){//sum(i of data 1 or 0)\n  //want to look at data[i]\n  //if halt == 1 >>> return;\n  //if sum == sub  >>>  halt=1; max; return;\n  //if i == count  >>> return sum\n  //\n  //printf(\"calculating sub %d,i %d,sum %d,rest %d,max %d\\n\",sub,i,sum,rest,*max);\n  if(*halt==1){//halt\n    return;\n  }\n  if(sum==sub){//to halt\n    *halt=1;\n    *max=sub;\n    return;\n  }\n  if(rest+sum < *max){\n    return;\n  }\n  if(rest+sum < sub && rest + sum > *max){//or new max\n    *max=rest+sum;\n    if(*max=sub){\n      *halt=1;\n    }\n    return;\n  }\n  if(*max<sum){//new max\n    *max=sum;\n  }\n  if(i<count){\n    if(data[i]+sum <= sub){\n      cal(sub,data,count,i+1,sum+data[i],rest-data[i],halt,max);\n    }\n    if(*halt){\n      return;\n    }\n    cal(sub,data,count,i+1,sum,rest-data[i],halt,max);\n    if(*halt){\n      return;\n    }\n\n  }\n  \n  return;\n}\nint calsub(int sub,int data[1000][2],int count,int maxi,int rest){\n  \n  int i,j;\n  int data2[1000];\n  for(i=0;i<count;i++){\n    data2[i]=data[i][1];\n  }\n  data2[maxi]=0;\n  qsort(data2,count,sizeof(int),comp);\n  int halt=0,max=0;\n  \n  FILE *fp;\n  fp = fopen(\"log\",\"w\");\n  fprintf(fp,\"count:%d\\nsub:%d\\nrest:\\n\",count,sub,rest);\n  for(i=0;i<count;i++){\n    fprintf(fp,\"%d\\n\",data2[i]);\n  }\n\n  cal(sub,data2,count,0,0,rest,&halt,&max);\n  return sub-max;\n  \n}\n\n\nint main(void){\n  FILE *fp;\n  //fp = fopen(\"037\",\"r\");\n  fp = fopen(\"2510-in2.txt\",\"r\");\n  //fp = stdin;\n  /*if(fp==NULL){\n    printf(\"error opening file\\n\");\n    return 1;\n    }*/\n  \n  int count;\n  int i,j;\n  int data[1000][2];\n  int max,maxi,rsum,wsum;\n  int sub;\n  int rest;\n  int res;\n  while(1){\n    fscanf(fp,\"%d\",&count);\n    if(count==0){\n      return 0;\n    }\n    max=0;rsum=0;wsum=0;\n    for(i=0;i<count;i++){\n      fscanf(fp,\"%d %d\",&data[i][0],&data[i][1]);\n      if(data[i][0]>max){\n\tmax=data[i][0];\n\tmaxi=i;\n      }\n      rsum+=data[i][0];\n      wsum+=data[i][1];\n    }\n    \n    if(2*max<=rsum){\n      res=rsum+wsum;\n    }else{\n      rest=wsum-data[maxi][1];\n      sub = 2 * max - rsum;\n      if(rest<=sub){\n\tres=rsum+wsum+sub-rest;\n      }else{\n\t//printf(\"sub%d rest%d rsum-max%d wsum%d\\n\",sub,rest,rsum-max,wsum);\n\tsub = calsub(sub,data,count,maxi,rest);\n\tres = rsum+wsum+sub;\n      }\n    }\n\n    printf(\"%d\\n\",res);\n    \n  }\n  \n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2510\n  Titl:ewin Book Report\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint N,w[1000];\nchar s[1000000];\n\nint undermax(int a[],int n,int aim)\n{\n  int i,j;\n\n  memset(s,0,sizeof(s));\n  s[0]=1;\n  for(i=0;i<n;i++)\n    for(j=aim-a[i];j>=0;j--)\n      if(s[j])\n\t{\n\t  s[j+a[i]]=1;\n\t}\n  for(i=aim;i>=0;i--)\n    if(s[i])\n      return(i);\n}\n\nmain()\n{ int i,ret,r1,w1,rmax,rsum,wsum,gap,over,lb;\n  \n  while(scanf(\"%d\",&N) && N)\n    {\n      rmax=rsum=wsum=0;\n      memset(w,0,sizeof(w));\n      for(i=0;i<N;i++)\n\t{\n\t  scanf(\"%d %d\",&r1,&w1);\n\t  if(rmax<r1)\n\t    {\n\t      lb=i;        //longest read time book\n\t      rmax=r1;\n\t    }\n\t  rsum+=r1;\n\t  wsum+=w1;\n\t  w[i]=w1;\n\t}\n      if(rsum > 2*rmax)\n\tret=rsum+wsum;\n      else\n\t{\n\t  gap=rmax-(rsum-rmax);\n\t  w[lb]=0;         //exclude lonest read time book\n\t  over=undermax(w,N,gap);\n\t  ret=2*rmax+wsum-over;\n\t}\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tint[] r = new int[n], w = new int[n];\n\t\t\tint max = 0, p=0, sumr = 0, sumw = 0;\n\t\t\tfor(int i=0;i<n;i++){ \n\t\t\t\tr[i] = sc.nextInt(); \n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tif( r[i] > max ) {\n\t\t\t\t\tmax = r[i]; p = i;\n\t\t\t\t}\n\t\t\t\tsumr += r[i];\n\t\t\t\tsumw += w[i];\n\t\t\t}\n\t\t\t\n\t\t\tif( sumr - max >= max ) {\n\t\t\t\tSystem.out.println((sumr + sumw));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean[] dp = new boolean[2 * max - sumr + 1];\n\t\t\t\tdp[0] = true;\n\t\t\t\tfor(int i=0;i<n;i++) if(i != p) \n\t\t\t\t\tfor(int j = 2 * max - sumr;j>=w[i];j--)\tdp[j] |= dp[j-w[i]];\n\t\t\t\tfor(p = 2 * max - sumr;!dp[p];p--);\n\t\t\t\tSystem.out.println((2 * max + sumw - p));\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tBook[] books = new Book[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tbooks[i] = new Book(r, w);\n\t\t\t}\n\t\t\tArrays.sort(books);\n\t\t\tint sumR = 0;\n\t\t\tint sumW = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsumR += books[i].r;\n\t\t\t\tsumW += books[i].w;\n\t\t\t}\n\t\t\tint maxR = books[N - 1].r;\n\t\t\tif (sumR - maxR < maxR) {\n\t\t\t\tint early = early(books, maxR - (sumR - maxR));\n\t\t\t\tSystem.out.println(Math.max(sumR + sumW, maxR * 2 + sumW - early));\n\t\t\t} else {\n\t\t\t\tSystem.out.println(sumR + sumW);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int early(Book[] books, int time) {\n\t\tboolean[] ok = new boolean[time + 1];\n\t\tok[0] = true;\n\t\tfor (int i = 0; i < books.length - 1; ++i) {\n\t\t\tint w = books[i].w;\n\t\t\tfor (int j = time; j - w >= 0; --j) {\n\t\t\t\tif (ok[j - w]) ok[j] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = time; i >= 0; --i) {\n\t\t\tif (ok[i]) return i;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic class Book implements Comparable<Book> {\n\t\tint r, w;\n\n\t\tpublic Book(int r, int w) {\n\t\t\tthis.r = r;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(Book o) {\n\t\t\treturn Integer.compare(this.r, o.r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  int solve2(int n, int[] r, int[] w, int target) {\n    int remain = target * 2 - IntStream.of(r).sum();\n    int[][] dp = new int[target + 1][remain + 1];\n    for (int[] a : dp) Arrays.fill(a, INF);\n    dp[0][0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = target; 0 <= j; --j) {\n        for (int k = remain; 0 <= k; --k) {\n          if (dp[j][k] == INF) {\n            continue;\n          }\n          // skip\n          if (k + w[i] <= remain)\n            dp[j][k + w[i]] = Math.min(dp[j][k + w[i]], n + i);\n          // skip2\n          if (k + r[i] <= remain && j + r[i] <= target)\n            dp[j + r[i]][k + r[i]] = Math.min(dp[j + r[i]][k + r[i]], n * 2 + i);\n          // use\n          if (j + r[i] <= target)\n            dp[j + r[i]][k] = Math.min(dp[j + r[i]][k], i);\n        }\n      }\n    }\n    for (int i = remain; 0 <= i; --i) {\n      if (dp[target][i] == INF) {\n        continue;\n      }\n      int sum = IntStream.of(w).sum();\n      int s = target;\n      int t = i;\n      while (dp[s][t] != -1) {\n        if (dp[s][t] >= n * 2) {\n          int j = dp[s][t] % n;\n          sum -= r[j];\n          t -= r[j];\n          s -= r[j];\n        } else if (dp[s][t] >= n) {\n          int j = dp[s][t] % n;\n          sum -= w[j];\n          t -= w[j];\n        } else {\n          int j = dp[s][t];\n          s -= r[j];\n        }\n      }\n      return target * 2 + sum;\n    }\n    return -1;\n  }\n\n  int solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      return solve2(n, r, w, i);\n    }\n    return -1;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> -a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      int ans = solve(n, r, w);\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int solve2(int n, int[] r, int[] w, int target) {\n    int remain = target * 2 - IntStream.of(r).sum();\n    int[][] dp = new int[target + 1][remain + 1];\n    int[] dp2 = new int[target + 1];\n    Arrays.fill(dp2, -1);\n    dp2[0] = 0;\n    for (int[] a : dp) Arrays.fill(a, INF);\n    dp[0][0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = target; 0 <= j; --j) {\n        if (dp2[j] != -1) {\n          // use\n          if (j + r[i] <= target) {\n            dp2[j + r[i]] = Math.max(dp2[j + r[i]], dp2[j]);\n          }\n          // skip\n          if (dp2[j] + w[i] <= remain)\n            dp2[j] = Math.max(dp2[j], dp2[j] + w[i]);\n          // skip2\n          if (j + r[i] <= target && dp2[j] + r[i] <= remain)\n            dp2[j + r[i]] = Math.max(dp2[j + r[i]], dp2[j] + r[i]);\n        }\n      }\n    }\n    int sum = IntStream.of(w).sum();\n    return target * 2 + sum - dp2[target];\n  }\n\n  int solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      return solve2(n, r, w, i);\n    }\n    return -1;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> -a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      int ans = solve(n, r, w);\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic int N;\n\tstatic int[] R, W;\n\t\n\t// list内の要素を何個か足して、max以下の最大数を返す\n\tstatic private int calc(int[] list, int max)\n\t{\n\t\tArrays.sort(list);\n\t\t\n\t\tint[][] dp = new int[1001][1001];\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 1;\n\t\t\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\tdp[i+1][j] = 1;\n\t\t\t\tif(j + list[i] <= max) dp[i+1][j+list[i]] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = max; i >= 0; i--) {\n\t\t\tif(dp[list.length][i] == 1) return i;\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tstatic private void solve()\n\t{\n\t\tif(N == 1)\n\t\t{\n\t\t\tSystem.out.println(R[0]*2 + W[0]);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint maxread = 0;\n\t\tint maxindex = 0;\n\t\tint sumread = 0;\n\t\tint sumwrite = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif(maxread < R[i])\n\t\t\t{\n\t\t\t\tmaxread = R[i];\n\t\t\t\tmaxindex = i;\n\t\t\t}\n\t\t\tsumread += R[i];\n\t\t\tsumwrite += W[i];\n\t\t}\n\t\t\n\t\tif((sumread - maxread) >= maxread)\n\t\t{\n\t\t\tSystem.out.println(sumread + sumwrite);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint free = maxread - (sumread - maxread);\n\t\t\n\t\tint[] list = new int[N-1];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif(i == maxindex) continue;\n\t\t\t\n\t\t\tif(i < maxindex)\n\t\t\t\tlist[i] = W[i];\n\t\t\telse {\n\t\t\t\tlist[i-1] = W[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint totalwrite = calc(list, free);\n\t\t\n\t\tSystem.out.println(maxread*2+sumwrite-totalwrite);\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\t\n\t\t\tN = sca.nextInt();\n\t\t\tif(N == 0) break;\n\t\t\t\n\t\t\tR = new int[N];\n\t\t\tW = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tR[i] = sca.nextInt();\n\t\t\t\tW[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint r[]=new int[n];\n\t\t\tint w[]=new int[n];\n\t\t\tint sumr=0,sumw=0,rmax=0,maxindex=-1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tr[i]=sc.nextInt();\n\t\t\t\tw[i]=sc.nextInt();\n\t\t\t\tsumr+=r[i];\n\t\t\t\tsumw+=w[i];\n\t\t\t\tif(rmax<r[i]){\n\t\t\t\t\trmax=r[i];\n\t\t\t\t\tmaxindex=i;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tArrays.sort(r);\n//\t\t\tSystem.out.println(\"読むのが長い奴=\"+rmax+\" sumr=\"+sumr+\" 待ち時間!\"+(rmax-(sumr-rmax)));\n//\t\t\tSystem.out.println(\"sumw=\"+sumw);\n\t\t\tif(rmax <= (sumr-rmax)){\n\t\t\t\tSystem.out.println(sumr+sumw);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean dp[][]=new boolean[n+1][sumw+1];//dp[i][j]は1-iから本を選んで感想文の合計をjにできる \n\t\t\t\tfor(int i=0; i<n+1; i++){\n\t\t\t\t\tArrays.fill(dp[i],false);\n\t\t\t\t}\n\t\t\t\tdp[0][0]=true;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<=sumw; j++){\n\t\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\t\tdp[i+1][j]=true;\n\t\t\t\t\t\t\tif(i!=maxindex)dp[i+1][j+w[i]]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n//\t\t\t\tfor(int i=0; i<n-1; i++){\n//\t\t\t\t\tfor(int j=0; j<sumw; j++){\n//\t\t\t\t\t\tSystem.out.print(\" \"+dp[i][j]);\n//\t\t\t\t\t} \n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\tint max=0;\n\t\t\t\tint wait=rmax-(sumr-rmax);\n\t\t\t\tfor(int i=0; i<=n; i++){\n\t\t\t\t\tfor(int j=0; j<=sumw; j++){\n\t\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\t\tif(j <= wait && max < j){\n\t\t\t\t\t\t\t\tmax=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n//\t\t\t\tSystem.out.println(max);\n\t\t\t\tSystem.out.println(2*rmax+(sumw-max));\n\t\t\t}\n\t\t}//while\n\t}//run\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n\n    @Override\n    public int compareTo(Node node) {\n      if (min != node.min) {\n        return Integer.compare(min, node.min);\n      }\n      return -Integer.compare(remain, node.remain);\n    }\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    TreeSet<Integer> set = new TreeSet<>();\n    dp[0] = -1;\n    set.add(0);\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        j = set.lower(j + 1);\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n        set.add(j + r[i]);\n      }\n    }\n    for (int i = sum; 0 <= i; --i) {\n      i = set.lower(i + 1);\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      if (me < vs) {\n        continue;\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      node = Util.min(node, next);\n    }\n    return node;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      int left = r[n - 1];\n      int right = IntStream.of(r).sum() - left;\n      if (right >= left) {\n        System.out.println(left + right + IntStream.of(w).sum());\n      } else {\n        int remain = left - right;\n        boolean[][] dp = new boolean[n + 1][remain + 1];\n        dp[0][0] = true;\n        for (int i = 0; i < n; ++i) {\n          for (int j = remain; 0 <= j; --j) {\n            dp[i + 1][j] |= dp[i][j];\n            if (j + w[i] <= remain && i != n - 1)\n              dp[i + 1][j + w[i]] |= dp[i][j];\n          }\n        }\n        int max = 0;\n        for (int i = remain; 0 <= i; --i) {\n          if (dp[n][i]) {\n            max = i;\n            break;\n          }\n        }\n        System.out.println(left * 2 + IntStream.of(w).sum() - max);\n      }\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n\n    @Override\n    public int compareTo(Node node) {\n      if (min != node.min) {\n        return Integer.compare(min, node.min);\n      }\n      return -Integer.compare(remain, node.remain);\n    }\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = sum; 0 <= i; --i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      if (me < vs) {\n        continue;\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      node = Util.min(node, next);\n    }\n    return node;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      return next;\n    }\n    return null;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tint suma = 0;\n\t\t\tint sumb = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tsuma += a[i];\n\t\t\t\tsumb += b[i];\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tArrays.sort(b);\n\t\t\t\n\t\t\tint W = 0;\n\t\t\tif(suma-a[n-1]<a[n-1]) W = a[n-1] - (suma-a[n-1]);\n\t\t\t\n\t\t\tif(W==0){\n\t\t\t\tSystem.out.println(suma+sumb);\n\t\t\t}else{\t\t\t\n\t\t\t\tint[][] dp = new int[n][W+1];\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\t\tfor(int j=0;j<=W;j++){\n\t\t\t\t\t\tif(j<b[i]) dp[i+1][j] = dp[i][j];\n\t\t\t\t\t\telse dp[i+1][j] = Math.max(dp[i][j], dp[i][j-b[i]]+b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(2*a[n-1] + (sumb-dp[n-1][W]));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  Node solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        if (dp[j + r[i]] == INF) {\n          dp[j + r[i]] = i;\n          continue;\n        }\n        int me = j + r[i];\n        int vs = sum - me;\n        if (me < vs) {\n          continue;\n        }\n        int next = j + r[i];\n        int s = w[dp[next]];\n        int t = w[i];\n        if (Math.abs(me - (vs + s)) < Math.abs(me - (vs + t))) {\n          dp[j + r[i]] = i;\n        }\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      return next;\n    }\n    return null;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[0] * 1000 + a[1]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r, w);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\t\n\tstatic final double INF = 1e9;\n\tint n;\n\tboolean solve(){\n\t\tn = in.nextInt();\n\t\tif(n == 0) return false;\n\t\tint[] r = new int[n];\n\t\tint[] w = new int[n];\n\t\tBook[] b = new Book[n];\n\t\tint all = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tr[i] = in.nextInt();\n\t\t\tw[i] = in.nextInt();\n\t\t\tall += r[i]+w[i];\n\t\t\tb[i] = new Book(r[i], w[i]);\n\t\t}\n\t\tArrays.sort(b);\n\t\tint wsum = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\twsum += b[i].r;\n\t\t}\n\t\tint sp = b[0].r - wsum;\n\t\tif(sp <= 0){\n\t\t\tSystem.out.println(all);\n\t\t\treturn true;\n\t\t}\n\t\tint[] nw = new int[n-1];\n\t\twsum = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tnw[i-1] = b[i].w;\n\t\t\twsum += b[i].w;\n\t\t}\n\t\tif(wsum <= sp){\n\t\t\tSystem.out.println(all+(sp-wsum));\n\t\t\treturn true;\n\t\t}\n\t\tArrays.sort(nw);\n\t\tn--;\n\t\tres = 0;\n\t\tint[] ww = new int[n];\n\t\tfor(int i=0; i<n; i++) ww[i] = nw[n-1-i];\n\t\tdfs(0, 0, sp, ww, new BitSet(n));\n\t\tSystem.out.println(all+(sp-res));\n\t\treturn true;\n\t}\n\t\n\tint res = 0;\n\tboolean dfs(int sum, int st, int sp, int[] w, BitSet used){\n\t\tif(sum == sp){\n\t\t\tres = sum;\n\t\t\treturn true;\n\t\t}\n\t\tif(sum > sp) return false;\n\t\tif(sum > res) res = sum;\n\t\tfor(int i=used.nextClearBit(st); i<n && sum+w[i]*(n-i)>res; i=used.nextClearBit(i+1)){\n\t\t\tused.set(i);\n\t\t\tif(dfs(sum+w[i], i+1, sp, w, used)) return true;\n\t\t\tused.clear(i);\n\t\t}\n\t\treturn false;\n\t}\n\t\n}\n\nclass Book implements Comparable<Book>{\n\tint r, w;\n\tBook(int r, int w){\n\t\tthis.r = r;\n\t\tthis.w = w;\n\t}\n\t@Override\n\tpublic int compareTo(Book o) {\n\t\treturn o.r-r;\n\t}\n}\n\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint r[]=new int[n];\n\t\t\tint w[]=new int[n];\n\t\t\tint sumr=0,sumw=0,rmax=0,maxindex=-1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tr[i]=sc.nextInt();\n\t\t\t\tw[i]=sc.nextInt();\n\t\t\t\tsumr+=r[i];\n\t\t\t\tsumw+=w[i];\n\t\t\t\tif(rmax<r[i]){\n\t\t\t\t\trmax=r[i];\n\t\t\t\t\tmaxindex=i;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tArrays.sort(r);\n//\t\t\tSystem.out.println(\"読むのが長い奴=\"+rmax+\" sumr=\"+sumr+\" 待ち時間!\"+(rmax-(sumr-rmax)));\n//\t\t\tSystem.out.println(\"sumw=\"+sumw);\n\t\t\tif(rmax <= (sumr-rmax)){\n\t\t\t\tSystem.out.println(sumr+sumw);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean dp[][]=new boolean[n+1][sumw+1];//dp[i][j]は1-iから本を選んで感想文の合計をjにできる \n\t\t\t\tfor(int i=0; i<n+1; i++){\n\t\t\t\t\tArrays.fill(dp[i],false);\n\t\t\t\t}\n\t\t\t\tdp[0][0]=true;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<=sumw; j++){\n\t\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\t\tdp[i+1][j]=true;\n\t\t\t\t\t\t\tif(i!=maxindex)dp[i+1][j+w[i]]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n//\t\t\t\tfor(int i=0; i<n-1; i++){\n//\t\t\t\t\tfor(int j=0; j<sumw; j++){\n//\t\t\t\t\t\tSystem.out.print(\" \"+dp[i][j]);\n//\t\t\t\t\t} \n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\tint max=0;\n\t\t\t\tint wait=rmax-(sumr-rmax);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=0; j<=sumw; j++){\n\t\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\t\tif(j <= wait && max < j){\n\t\t\t\t\t\t\t\tmax=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t}\n//\t\t\t\tSystem.out.println(max);\n\t\t\t\tSystem.out.println(2*rmax+(sumw-max));\n\t\t\t}\n\t\t}//while\n\t}//run\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic int N;\n\tstatic int[] R, W;\n\t\n\t// list内の要素を何個か足して、max以下の最大数を返す\n\tstatic private int calc(int[] list, int max)\n\t{\n\t\tArrays.sort(list);\n\t\t\n\t\tint[][] dp = new int[1001][1001];\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif(j == 0)\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < list.length; i++) {\n\t\t\tfor (int j = 0; j < 1001-list[i]; j++) {\n\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\tdp[i+1][j+list[i]] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = max; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < list.length; j++) {\n\t\t\t\tif(dp[j][i] == 1) return i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tstatic private void solve()\n\t{\n\t\tif(N == 1)\n\t\t{\n\t\t\tSystem.out.println(R[0]*2 + W[0]);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint maxread = 0;\n\t\tint maxindex = 0;\n\t\tint sumread = 0;\n\t\tint sumwrite = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif(maxread < R[i])\n\t\t\t{\n\t\t\t\tmaxread = R[i];\n\t\t\t\tmaxindex = i;\n\t\t\t}\n\t\t\tsumread += R[i];\n\t\t\tsumwrite += W[i];\n\t\t}\n\t\t\n\t\tif((sumread - maxread) >= maxread)\n\t\t{\n\t\t\tSystem.out.println(sumread + sumwrite);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint free = maxread - (sumread - maxread);\n\t\t\n\t\tint[] list = new int[N-1];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif(i == maxindex) continue;\n\t\t\t\n\t\t\tif(i < maxindex)\n\t\t\t\tlist[i] = W[i];\n\t\t\telse {\n\t\t\t\tlist[i-1] = W[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint totalwrite = calc(list, free);\n\t\t\n\t\tSystem.out.println(maxread*2+sumwrite-totalwrite);\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\t\n\t\t\tN = sca.nextInt();\n\t\t\tif(N == 0) break;\n\t\t\t\n\t\t\tR = new int[N];\n\t\t\tW = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tR[i] = sca.nextInt();\n\t\t\t\tW[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\tpublic static boolean solve() {\n\t\tint n = io.nextInt();\n\t\tif (n == 0) return false;\n\t\tint[] r = new int[n];\n\t\tint[] w = new int[n];\n\t\tio.nextIntArrays(r,w);\n\t\tint sumR = 0;\n\t\tint maxR = 0;\n\t\tint argmaxR = 0;\n\t\tint sumW = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsumR += r[i];\n\t\t\tsumW += w[i];\n\t\t\tif (maxR < r[i]) {\n\t\t\t\tmaxR = r[i];\n\t\t\t\targmaxR = i;\n\t\t\t}\n\t\t}\n\t\tif (maxR * 2 <= sumR) {\n\t\t\tio.println(sumR + sumW);\n\t\t}else{\n\t\t\tw[argmaxR] = 0;\n\t\t\tio.println(maxR * 2 + sumW - partialSum(n,w,maxR*2-sumR));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static int partialSum(int n, int[] w, int x) {\n\t\tboolean[] dp = new boolean[x+1];\n\t\tdp[0] = true;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=x;j>=w[i];j--) {\n\t\t\t\tdp[j] |= dp[j-w[i]];\n\t\t\t}\n\t\t}\n\t\tfor(int i=x;i>=0;i--) {\n\t\t\tif (dp[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  int solve2(int n, int[] r, int[] w, int target) {\n    int remain = target * 2 - IntStream.of(r).sum();\n    int[][] dp = new int[target + 1][remain + 1];\n    for (int[] a : dp) Arrays.fill(a, INF);\n    dp[0][0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = target; 0 <= j; --j) {\n        for (int k = remain; 0 <= k; --k) {\n          if (dp[j][k] == INF) {\n            continue;\n          }\n          // skip\n          if (k + w[i] <= remain)\n            dp[j][k + w[i]] = Math.min(dp[j][k + w[i]], n + i);\n          // skip2\n          if (k + r[i] <= remain && j + r[i] <= target)\n            dp[j + r[i]][k + r[i]] = Math.min(dp[j + r[i]][k + r[i]], i);\n          // use\n          if (j + r[i] <= target)\n            dp[j + r[i]][k] = Math.min(dp[j + r[i]][k], n * 2 + i);\n        }\n      }\n    }\n    for (int i = remain; 0 <= i; --i) {\n      if (dp[target][i] == INF) {\n        continue;\n      }\n      int sum = IntStream.of(w).sum();\n      int s = target;\n      int t = i;\n      while (dp[s][t] != -1) {\n        if (dp[s][t] >= n * 2) {\n          int j = dp[s][t] % n;\n          s -= r[j];\n        } else if (dp[s][t] >= n) {\n          int j = dp[s][t] % n;\n          sum -= w[j];\n          t -= w[j];\n        } else {\n          int j = dp[s][t];\n          sum -= r[j];\n          s -= r[j];\n          t -= r[j];\n        }\n      }\n      return target * 2 + sum;\n    }\n    return -1;\n  }\n\n  int solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      return solve2(n, r, w, i);\n    }\n    return -1;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> -a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      int ans = solve(n, r, w);\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n\n    @Override\n    public int compareTo(Node node) {\n      if (min != node.min) {\n        return Integer.compare(min, node.min);\n      }\n      return -Integer.compare(remain, node.remain);\n    }\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = sum; 0 <= i; --i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      if (me < vs) {\n        continue;\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      node = Util.min(node, next);\n    }\n    return node;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tvoid swap(int[] array, int i, int j) {\n\t\tint temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\t\n\t}\n\n\tvoid sortByAsc(int[] array, int[] array2) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = i+1; j < array.length; j++) {\n\t\t\t\tif (array[i] > array[j]) {\n\t\t\t\t\tswap(array, i, j);\n\t\t\t\t\tswap(array2, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint calc(int[] write, int t) {\n\t\tboolean[] dp = new boolean[t+1];\n\t\t\n\t\tdp[0] = true;\n\t\tfor (int i = 0; i < write.length - 1; i++) {\n\t\t\tfor (int j = t; j - write[i] >= 0; j--) {\n\t\t\t\tif (dp[j-write[i]]) {\n\t\t\t\t\tdp[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = t; i >= 0; i--) {\n\t\t\tif (dp[i]) return i;\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint[] readTime = new int[n], writeTime = new int[n];\n\t\t\tfor (int i = 0; i < writeTime.length; i++) {\n\t\t\t\treadTime[i] = in.nextInt();\n\t\t\t\twriteTime[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsortByAsc(readTime, writeTime);\n\t\t\t\n\t\t\tint sumR = 0, sumW = 0;\n\t\t\tfor (int i = 0; i < writeTime.length; i++) {\n\t\t\t\tsumR += readTime[i];\n\t\t\t\tsumW += writeTime[i];\n\t\t\t}\n\t\t\t\n\t\t\tint maxR = readTime[n-1];\n\t\t\t\n\t\t\tif (2 * maxR > sumR) {\n\t\t\t\tint preWrite = calc(writeTime, 2 * maxR - sumR);\n\t\t\t\tSystem.out.println(Math.max(sumR + sumW, maxR * 2 + sumW - preWrite));\n\t\t\t} else {\n\t\t\t\tSystem.out.println((sumR + sumW));\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tBook[] books = new Book[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tbooks[i] = new Book(r, w);\n\t\t\t}\n\t\t\tArrays.sort(books);\n\t\t\tint sumR = 0;\n\t\t\tint sumW = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsumR += books[i].r;\n\t\t\t\tsumW += books[i].w;\n\t\t\t}\n\t\t\tint maxR = books[N - 1].r;\n\t\t\tif (sumR - maxR < maxR) {\n\t\t\t\tint early = early(books, maxR - (sumR - maxR));\n\t\t\t\tSystem.out.println(Math.max(sumR + sumW, maxR * 2 + sumW - early));\n\t\t\t} else {\n\t\t\t\tSystem.out.println(sumR + sumW);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int early(Book[] books, int time) {\n\t\tboolean[] ok = new boolean[time + 1];\n\t\tok[0] = true;\n\t\tfor (int i = 0; i < books.length - 1; ++i) {\n\t\t\tint w = books[i].w;\n\t\t\tfor (int j = time; j - w >= 0; --j) {\n\t\t\t\tif (ok[j - w]) ok[j] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = time; i >= 0; --i) {\n\t\t\tif (ok[i]) return i;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic class Book implements Comparable<Book> {\n\t\tint r, w;\n\n\t\tpublic Book(int r, int w) {\n\t\t\tthis.r = r;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tpublic int compareTo(Book o) {\n\t\t\treturn this.r - o.r;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  int solve2(int n, int[] r, int[] w, int target) {\n    int sum = IntStream.of(r).sum();\n    int remain = target * 2 - sum;\n    int[][] dp = new int[target + 1][remain + 1];\n    for (int[] a : dp) Arrays.fill(a, INF);\n    dp[0][0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = target; 0 <= j; --j) {\n        for (int k = remain; 0 <= k; --k) {\n          if (dp[j][k] == INF) {\n            continue;\n          }\n          // skip\n          if (k + w[i] <= remain)\n            dp[j][k + w[i]] = n + i;\n          // use\n          if (j + r[i] <= target)\n            dp[j + r[i]][k] = i;\n        }\n      }\n    }\n    for (int i = remain; 0 <= i; --i) {\n      if (dp[target][i] == INF) {\n        continue;\n      }\n      int tum = IntStream.of(w).sum();\n      int s = target;\n      int t = i;\n      while (dp[s][t] != -1) {\n        if (dp[s][t] >= n) {\n          int j = dp[s][t] % n;\n          tum -= w[j];\n          t -= w[j];\n        } else {\n          int j = dp[s][t];\n          s -= r[j];\n        }\n      }\n      return target * 2 + tum;\n    }\n    return -1;\n  }\n\n  int solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      return solve2(n, r, w, i);\n    }\n    return -1;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> -a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      int ans = solve(n, r, w);\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n\n    @Override\n    public int compareTo(Node node) {\n      if (min != node.min) {\n        return Integer.compare(min, node.min);\n      }\n      return -Integer.compare(remain, node.remain);\n    }\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    TreeSet<Integer> set = new TreeSet<>();\n    dp[0] = -1;\n    set.add(0);\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        j = set.lower(j + 1);\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n        set.add(j + r[i]);\n      }\n    }\n    for (int i = sum; 0 <= i; --i) {\n      i = set.lower(i + 1);\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      if (me < vs) {\n        continue;\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      node = Util.min(node, next);\n    }\n    return node;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      TreeSet<Integer> set = new TreeSet<>();\n      set.add(0);\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          j = set.lower(j + 1);\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n          set.add(j + w[i]);\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\t\n\tstatic final double INF = 1e9;\n\tint n;\n\tboolean solve(){\n\t\tn = in.nextInt();\n\t\tif(n == 0) return false;\n\t\tint[] r = new int[n];\n\t\tint[] w = new int[n];\n\t\tBook[] b = new Book[n];\n\t\tint all = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tr[i] = in.nextInt();\n\t\t\tw[i] = in.nextInt();\n\t\t\tall += r[i]+w[i];\n\t\t\tb[i] = new Book(r[i], w[i]);\n\t\t}\n\t\tArrays.sort(b);\n\t\tint wsum = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\twsum += b[i].r;\n\t\t}\n\t\tint sp = b[0].r - wsum;\n\t\tif(sp <= 0){\n\t\t\tSystem.out.println(all);\n\t\t\treturn true;\n\t\t}\n\t\tint[] nw = new int[n-1];\n\t\tfor(int i=1; i<n; i++){\n\t\t\tnw[i-1] = b[i].w;\n\t\t}\n\t\tArrays.sort(nw);\n\t\tn--;\n\t\tres = 0;\n\t\tint[] ww = new int[n];\n\t\tfor(int i=0; i<n; i++) ww[i] = nw[n-1-i];\n\t\tdfs(0, 0, sp, ww, new BitSet(n));\n\t\tSystem.out.println(all+(sp-res));\n\t\treturn true;\n\t}\n\t\n\tint res = 0;\n\tboolean dfs(int sum, int st, int sp, int[] w, BitSet used){\n\t\tif(sum == sp){\n\t\t\tres = sum;\n\t\t\treturn true;\n\t\t}\n\t\tif(sum > sp) return false;\n\t\tif(sum > res) res = sum;\n\t\tfor(int i=used.nextClearBit(st); i<n && sum+w[i]*(n-i)>res; i=used.nextClearBit(i+1)){\n\t\t\tused.set(i);\n\t\t\tif(dfs(sum+w[i], i+1, sp, w, used)) return true;\n\t\t\tused.clear(i);\n\t\t}\n\t\treturn false;\n\t}\n\t\n}\n\nclass Book implements Comparable<Book>{\n\tint r, w;\n\tBook(int r, int w){\n\t\tthis.r = r;\n\t\tthis.w = w;\n\t}\n\t@Override\n\tpublic int compareTo(Book o) {\n\t\treturn o.r-r;\n\t}\n}\n\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n  }\n\n  Node solve(int n, int[] r, int[] w) {\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    dp[0] = -1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        if (dp[j + r[i]] == INF) {\n          dp[j + r[i]] = i;\n          continue;\n        }\n      }\n    }\n    for (int i = (sum + 1) / 2; i <= sum; ++i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      return next;\n    }\n    return null;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> -a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r, w);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tint INF = 1 << 29;\n\t\n\tclass C implements Comparable<C>{\n\t\tint read, write;\n\n\t\tpublic C(int read, int write) {\n\t\t\tthis.read = read;\n\t\t\tthis.write = write;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(C arg0) {\n\t\t\treturn arg0.read - this.read;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [read=\" + read + \", write=\" + write + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tC [] data = new C[n];\n\t\t\tint sumRead = 0, sumWrite = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint read = sc.nextInt();\n\t\t\t\tint write = sc.nextInt();\n\t\t\t\tdata[i] = new C(read, write);\n\t\t\t\tsumRead += read;\n\t\t\t\tsumWrite += write;\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tif(data[0].read > sumRead - data[0].read){\n\t\t\t\tint restTime = data[0].read - (sumRead - data[0].read);\n\t\t\t\tboolean [] dp = new boolean[restTime + 1];\n\t\t\t\tdp[0] = true;\n\t\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\t\tfor(int j = restTime; j >= 0 ; j--){\n\t\t\t\t\t\tif(! dp[j]) continue;\n\t\t\t\t\t\tint next = j + data[i].write;\n\t\t\t\t\t\tif(next > restTime) continue;\n\t\t\t\t\t\tdp[next] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint ind = -1;\n\t\t\t\tfor(int i = 0; i <= restTime; i++){\n\t\t\t\t\tif(dp[i]){\n\t\t\t\t\t\tind = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sumRead + sumWrite + (restTime - ind));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(sumRead + sumWrite);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Comparator;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CTwinBookReport solver = new CTwinBookReport();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwinBookReport {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            while (n != 0) {\n                CTwinBookReport.Book[] books = new CTwinBookReport.Book[n];\n                int totalRead = 0, totalWrite = 0;\n                for (int i = 0; i < n; i++) {\n                    books[i] = new CTwinBookReport.Book(in.nextInt(), in.nextInt());\n                    totalRead += books[i].r;\n                    totalWrite += books[i].w;\n                }\n                Arrays.sort(books, Comparator.comparing(book -> -book.r));\n\n                int voidTime = Math.max(0, books[0].r - (totalRead - books[0].r));\n                //System.out.println(\"(READ, WRITE) = (\" + totalRead + \", \" + totalWrite + \")\");\n                //System.out.println(\"VOID TIME IS \" + voidTime);\n                int finishTime = totalRead + voidTime; // 読み終わり\n\n                boolean[][] dp = new boolean[n][];\n                dp[0] = new boolean[voidTime + 1];\n                dp[0][0] = true;\n                for (int i = 1; i < n; i++) {\n                    dp[i] = dp[i - 1].clone();\n                    //System.out.print(books[i].w + \" \");\n                    for (int j = 0; j <= voidTime - books[i].w; j++) {\n                        dp[i][j + books[i].w] |= dp[i - 1][j];\n                    }\n                }\n                //System.out.println(Arrays.toString(dp));\n                for (int i = voidTime; ; i--) {\n                    if (dp[n - 1][i]) {\n                        //System.out.println(\"REDUCED TIME IS \"+ i);\n                        out.println(finishTime + totalWrite - i);\n                        break;\n                    }\n                }\n\n                n = in.nextInt();\n            }\n        }\n\n        private static class Book {\n            int r;\n            int w;\n\n            Book(int r, int w) {\n                this.r = r;\n                this.w = w;\n            }\n\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int min = INF;\n    int remain = 0;\n    boolean[] done;\n\n    @Override\n    public int compareTo(Node node) {\n      if (min != node.min) {\n        return Integer.compare(min, node.min);\n      }\n      return -Integer.compare(remain, node.remain);\n    }\n  }\n\n  Node solve(int n, int[] r) {\n    Node node = new Node();\n    int sum = IntStream.of(r).sum();\n    int[] dp = new int[sum + 1];\n    Arrays.fill(dp, INF);\n    TreeSet<Integer> set = new TreeSet<>();\n    dp[0] = -1;\n    set.add(0);\n    for (int i = 0; i < n; ++i) {\n      for (int j = sum; 0 <= j; --j) {\n        j = set.lower(j + 1);\n        if (j + r[i] > sum) {\n          continue;\n        }\n        if (dp[j] == INF) {\n          continue;\n        }\n        dp[j + r[i]] = i;\n        set.add(j + r[i]);\n      }\n    }\n    for (int i = sum; 0 <= i; --i) {\n      if (dp[i] == INF) {\n        continue;\n      }\n      int me = 0;\n      int vs = sum;\n      int ok = i;\n      boolean[] done = new boolean[n];\n      while (dp[ok] != -1) {\n        me += r[dp[ok]];\n        vs -= r[dp[ok]];\n        done[dp[ok]] = true;\n        ok = ok - r[dp[ok]];\n      }\n      if (me < vs) {\n        continue;\n      }\n      Node next = new Node();\n      next.min = me;\n      next.remain = me - vs;\n      next.done = done;\n      node = Util.min(node, next);\n    }\n    return node;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] r = new int[n];\n      int[] w = new int[n];\n      int[][] t = new int[n][2];\n      for (int i = 0; i < n; ++i) {\n        r[i] = ni();\n        w[i] = ni();\n        t[i][0] = r[i];\n        t[i][1] = w[i];\n      }\n      Arrays.sort(t, Comparator.comparingInt(a -> a[1] * 1000 + a[0]));\n      for (int i = 0; i < n; ++i) {\n        r[i] = t[i][0];\n        w[i] = t[i][1];\n      }\n      Node node = solve(n, r);\n      int sum = IntStream.of(w).sum();\n      int[] dp = new int[node.remain + 1];\n      Arrays.fill(dp, INF);\n      dp[0] = -1;\n      for (int i = 0; i < n; ++i) {\n        if (node.done[i]) {\n          continue;\n        }\n        for (int j = node.remain; 0 <= j; --j) {\n          if (j + w[i] > node.remain) {\n            continue;\n          }\n          if (dp[j] == INF) {\n            continue;\n          }\n          dp[j + w[i]] = i;\n        }\n      }\n      for (int i = node.remain; 0 <= i; --i) {\n        if (dp[i] != INF) {\n          sum -= i;\n          break;\n        }\n      }\n      System.out.println(node.min * 2 + sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            for (; ; )\n            {\n                var n = ri; if (n == 0) break;\n                var a = Enumerate(n, x => new int[] { ri, ri });\n                var sum = a.Sum(x => x[0]);\n                var max = a.Max(x => x[0]);\n                if (sum >= 2 * max)\n                {\n                    Console.WriteLine(a.Sum(x => x[0] + x[1]));\n                    continue;\n                }\n                var dp = new bool[1050];\n                dp[0] = true;\n                foreach (var x in a.Where(x => x[0] != max).Select(x => x[1]))\n                    for (int i = 1000 - x; i >= 0; i--)\n                        if (dp[i]) dp[i + x] = true;\n                for (int i = 2 * max - sum; i >= 0; i--)\n                    if (dp[i])\n                    {\n                        Console.WriteLine(a.Sum(x => x[0] + x[1]) + 2 * max - sum - i);\n                        break;\n                    }\n\n            }\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "def knapsack(items, budget)\n    table = (0..1).map{ Array.new(budget+1, 0) }\n    for i in 0..items.size-1\n        c, v = items[i]\n        for j in 0..budget\n            x = table[0][j]\n            y = (j >= c ? table[0][j-c] + v : 0)\n            table[1][j] = x > y ? x : y \n        end\n        table << table.shift\n    end \n    table[0][budget]\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    read_time, write_time = (1..n).map{gets.split.map(&:to_i)}.sort.transpose\n    if n == 1\n        p read_time[0] * 2 + write_time[0]\n    elsif read_time[-1] * 2 > read_time.inject(:+)  \n        t1 = read_time.pop\n        t2 = read_time.inject(:+)\n        space = t1 - t2\n        t3 = knapsack(write_time[0..-2].map{|x| [x, x]}, space)\n        p 2 * t1 + write_time.inject(:+) - t3\n    else\n        p read_time.inject(:+) + write_time.inject(:+)\n    end \nend"
  },
  {
    "language": "Python",
    "code": "import operator\nimport sys\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    N = int(readline())\n    if N == 0:\n        return False\n    P = [list(map(int, readline().split())) for i in range(N)]\n    P.sort(key = operator.itemgetter(0))\n    RS = sum(r for r, w in P)\n    WS = sum(w for r, w in P)\n    if all(2*r <= RS for r, w in P):\n        write(\"%d\\n\" % (RS + WS))\n        return True\n    rl, sl = P[-1]\n\n    W = 2*rl - RS\n    dp = [0]*(W+1)\n    dp[0] = 1\n    for r, w in P[:-1]:\n        for j in range(W, w-1, -1):\n            dp[j] |= dp[j-w]\n    ma = max(j for j in range(W+1) if dp[j])\n    write(\"%d\\n\" % (RS + WS + (W - ma)))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=int(input())\n    if n==0:\n        break\n    books=[]\n    read_t=0\n    write_t=0\n    for i in range(n):\n        r,w=map(int,input().split())\n        read_t+=r\n        write_t+=w\n        books.append((r,w))\n    books=sorted(books)\n    if books[-1][0]<=read_t//2:\n        print(read_t+write_t)\n        continue\n    sukima=books[-1][0]-(read_t-books[-1][0])\n    dp=[[0 for i in range(sukima+1)] for i in range(n)]\n    for i in range(1,n):\n        for j in range(1,sukima+1):\n            dp[i][j]=max(dp[i-1][j],\n            dp[i-1][j-books[i-1][1]]\n            +books[i-1][1] if j-books[i-1][1]>=0 else 0)\n\n    print(read_t+write_t+sukima-dp[-1][-1])\n\n    \n"
  },
  {
    "language": "Python",
    "code": "while True:\n    N = input()\n    if N == 0:\n        break\n    data = [map(int,raw_input().split()) for _ in xrange(N)]\n    data.sort(key = lambda x:-x[0])\n    R,W = zip(*data)\n    empty = max(0,R[0]-sum(R[1:]))\n    #print \"empty\",empty\n    dp = [False]*(empty+1)\n    dp[0] = True\n    ma = 0\n    for w in W[-1:0:-1]:\n        if empty < w:\n            break\n        for i in xrange(empty,-1,-1):\n            if dp[i] and i+w <= empty:\n                ma = max(ma, i+w)\n                dp[i+w] = True\n    #print filter(lambda x: dp[x], xrange(empty+1))\n    print sum(R)+sum(W)+(empty-ma)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\ninput=lambda : sys.stdin.readline().rstrip()\n\nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    books=[]\n    read_t=0\n    write_t=0\n    for i in range(n):\n        r,w=map(int,input().split())\n        read_t+=r\n        write_t+=w\n        books.append((r,w))\n    books=sorted(books)\n    if books[-1][0]<=read_t//2:\n        print(read_t+write_t)\n        continue\n    sukima=books[-1][0]-(read_t-books[-1][0])\n    dp=[[0 for i in range(sukima+1)] for i in range(n)]\n    for i in range(1,n):\n        for j in range(1,sukima+1):\n            dp[i][j]=max(dp[i-1][j],\n            dp[i-1][j-books[i-1][1]]\n            +books[i-1][1] if j-books[i-1][1]>=0 else 0)\n\n    print(read_t+write_t+sukima-dp[-1][-1])\n\n    \n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\nfrom __future__ import division,print_function\ntry:\n    input = raw_input\nexcept NameError:\n    pass\n\nfrom datetime import datetime\nimport math\n\nMAXW = 1001\n\ndef solve(n, read, write):\n    sumR = sum(read)\n    sumW = sum(write)\n\n    next = []\n    base = -1\n    for i in range(n):\n        if read[i] < sumR // 2:\n            next.append((read[i], write[i]))\n        else:\n            base = read[i]\n    if (len(next) == n):\n        print(sumR + sumW)\n        return\n\n    dp = [False] * MAXW\n    dp[0] = True\n    for i in range(n - 1):\n        tmp = dp[:]\n        for j in range(base + 1):\n            if dp[j]:\n                na = j + next[i][0]\n                nb = j + next[i][0] + next[i][1]\n                if na <= base:\n                    tmp[na] = True\n                if nb <= base:\n                    tmp[nb] = True\n        dp = tmp\n    res = 0\n    for i in range(base + 1):\n        if dp[i]:\n            res = base - i\n    print(sumR + sumW + res)\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0: return\n        read = []\n        write = []\n        for i in range(n):\n            r, w = map(int, input().split())\n            read.append(r)\n            write.append(w)\n        solve(n, read, write)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        t = max(map(lambda x: x[0]*2+x[1], a))\n        u = sum(map(sum,a))\n        mx = max(map(lambda x: [x[0],-x[1]], a))\n        mxi = a.index([mx[0], -mx[1]])\n        k = sum(map(lambda x: x[0], a)) - mx[0]\n        if k < mx[0]:\n            mx0 = mx[0]\n            dp = [0] * (mx0+1)\n            dp[k] = 1\n            for ai in range(n):\n                if ai == mxi:\n                    continue\n                c = a[ai][1]\n                for i in range(mx0-c,-1,-1):\n                    dp[i+c] |= dp[i]\n            mt = 0\n            for i in range(mx0,-1,-1):\n                if dp[i]:\n                    mt = i\n                    break\n            u += (mx0 - mt)\n        return max(t,u)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]