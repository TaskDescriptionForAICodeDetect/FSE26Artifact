[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 2) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfl2 = fl;\n\t\n\tfl = true;\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(i >= j) continue;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u) + 1);\n    //cout << u << \": \";\n    //for(int k : vals) cout << k << \" \";\n    //cout << endl;\n    if(vals.size() == 0) return 0;\n    if(vals.size()%2 == 0) {\n        if( u == 0 ){\n            sort(vals.begin(), vals.end());\n            for(int i = 0, j = vals.size()-1; i < j; i++, j--) if(vals[i] + vals[j] > B) return B+1;\n            return 0;\n        }\n        vals.pb(0);\n    }\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size();\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    if(rb == vals.size()) return B+1;\n    //cout << \"leastUp \" << u << \": \" << vals[rb] << endl;\n    return vals[rb];\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    //cout << \"l = \" << l << \" B = \" << B << endl;\n    return l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint K;\nbool dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    multiset<int> st;\n    st.insert(0);\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        const bool f = dp_dfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        st.insert(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = st.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        st.insert(0);\n    }\n    auto st_copy = st;\n    int mini = 10000;\n    bool ok = true;\n    while (not st.empty()) {\n        auto it = st.end();\n        it--;\n        const int v = *it;\n        st.erase(it);\n        auto upp = st.upper_bound(K - v - 1);\n        if (upp == st.begin()) {\n            ok = false;\n            break;\n        }\n        upp--;\n        if (*upp == 0 or v == 0) {\n            mini = min(mini, *upp + v + 1);\n        }\n        st.erase(upp);\n    }\n    if (not ok) {\n        if (size % 2 == 1) {\n            return false;\n        } else {\n            st = st_copy;\n            auto it = st.end();\n            it--;\n            if (*it + 1 > K) {\n                return false;\n            }\n            st.erase(it);\n            st.insert(0);\n            while (not st.empty()) {\n                auto it = st.end();\n                it--;\n                const int v = *it;\n                st.erase(it);\n                auto upp = st.upper_bound(K - v - 1);\n                if (upp == st.begin()) {\n                    return false;\n                }\n                upp--;\n                if (*upp == 0 or v == 0) {\n                    mini = min(mini, *upp + v + 1);\n                }\n                st.erase(upp);\n            }\n        }\n    }\n    dp[s] = {sum, mini};\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    int inf = 0;\n    int sup = N + 1;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        if (dp_dfs(g, 0, dp)) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    dp_dfs(g, 0, dp);\n    cout << dp[0].first + (g.edge[0].size() % 2 == 0 ? 0 : 1) << \" \" << sup - 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n\nusing namespace std;\n\n\nGraph<> tree;\nint A, B;\n\n// Aを求める\nvoid dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n}\n\n// パスの最大長がB以下になるようにしたとき、\n// 親に送られるパスの最小値(無理ならINF)を返す\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    // ダミーを仕込んで奇数の場合に帰着させる\n    if (ch.size() % 2 == 0) ch.push_back(0);\n\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree[u].emplace_back(u, v);\n        tree[v].emplace_back(v, u);\n    }\n\n    int r;\n    for (r = 0; tree[r].size() > 1; ++r) {}\n\n    A = 0;\n    dfs1(r, -1);\n    ++A;  // 根から出てくるパスを受け取る\n\n    // Bを二分探索\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(r, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001],d[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tif (x==1) return INF;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t\td[u]++;\n\t\td[v]++;\n\t}\n\tint ans=dfs(1,-1);\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*بِسْمِ اللَّهِ الرَّحْمَنِ الرَّحِيم*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mx=1e5+5;\nvector <int> edges[mx];\nint DP[mx];\nbool vis[mx];\n\nbool check (vector <int>& val,int b,int mid)\n{\n    int i,j;\n    bool ret=true;\n    i=0;\n    j=val.size()-1;\n    while (i<j) {\n        if (i==mid) i++;\n        if (j==mid) j--;\n        if (val[i]+val[j]>b) {\n            ret=false;\n            break;\n        }\n        else i++,j--;\n    }\n    return ret;\n}\n\nbool DFS (int u,int b)\n{\n    vis[u]=true;\n    bool ret=true;\n    vector <int> val;\n\n    for (auto v : edges[u]) {\n        if (!vis[v]) {\n            ret=(ret & DFS(v,b));\n            val.push_back(DP[v]);\n        }\n    }\n    if (!ret) return ret;\n    if (val.empty()) {\n        DP[u]=1;\n        return true;\n    }\n    int m=val.size();\n    if (m%2==0) {\n        val.push_back(0);\n        m++;\n    }\n    sort(val.begin(),val.end());\n\n    int hi,lo,mid,ans=-1;\n    lo=0,hi=m-1;\n    while (lo<=hi) {\n        mid=(lo+hi)/2;\n        if (val[mid]<=b && check(val,b,mid)) {\n            ans=mid;\n            hi=mid-1;\n        }\n        else lo=mid+1;\n    }\n    if (ans==-1) return false;\n    else {\n        DP[u]=1+val[ans];\n        return true;\n    }\n}\n\nint main ()\n{\n    int i,n;\n\n    scanf (\"%d\",&n);\n    for (i=1;i<n;i++) {\n        int u,v;\n        scanf (\"%d %d\",&u,&v);\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    int u,hi,lo,mid,ans,cnt=0;\n    for (i=1;i<=n;i++) {\n        cnt+=edges[i].size()%2;\n        if (edges[i].size()==1) u=i;\n    }\n\n    lo=1,hi=n-1;\n    while (lo<=hi) {//cout<<lo<<endl;\n        mid=(lo+hi)/2;\n        memset(vis,0,sizeof(vis));\n        if (DFS(u,mid)) {\n            ans=mid;\n            hi=mid-1;\n        }\n        else lo=mid+1;\n    }\n    printf (\"%d %d\\n\",cnt/2,ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN],pre[MN],lst[MN];\nstruct edge{int to,next;}g[MN<<1];\nmultiset<int>::iterator it,it2;\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,lef=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)if(!dp(g[i].to,u,mid))return false;\n\tmultiset<int>S;S.clear();\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)S.insert(f[g[i].to]),tt++;\n\tif(!tt){f[u]=0;return true;}\n\twhile(S.begin()!=S.end()){\n\t\tit=S.end();--it;int tmp=(*it);S.erase(it);\n\t\tit2=S.upper_bound(mid-tmp-2);\n\t\tif(it2!=S.begin()){--it2;S.erase(it2);}\n\t\telse {lst[++lef]=tmp;}\n\t}\n\tif(u==1){\n\t\tif(lef==1)return lst[1]+1<=mid;\n\t\telse return lef==0;\n\t}else {\n\t\tif(tt&1){\n\t\t\tif(lef==1){f[u]=lst[lef]+1;return lst[1]+1<=mid;}\n\t\t\telse {f[u]=0;return lef==0;}\n\t\t}else {\n\t\t\tif(lef==2){f[u]=lst[2]+1;return f[u]<=mid&&lst[1]+1<=mid;}\n\t\t\telse {f[u]=0;return lef==0;}\n\t\t}\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nmultiset<int>G[N];\nmultiset<int>::iterator gt,gtt;\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tson++;\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=(son+(u==1))/2;\n}\ninline void dfs_ans(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs_ans(v,u);\n\t\tG[u].insert(dis[v]+1);\n\t\tif(dis[v]+1>len)flag=0;\n\t\tson++;\n\t}\n\tint res=u==1?son&1:son&1?1:2;\n\t//printf(\"%d %d\\n\",u,res);\n\twhile(!G[u].empty())\n\t{\n\t\tgt=G[u].end();--gt;\n\t\tgtt=G[u].upper_bound(len-*gt);\n\t\tif(gtt==G[u].begin()||SZ(G[u])==1)\n\t\t{\n\t\t\tif(!res)flag=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdis[u]=*gt;\n\t\t\t\tres--;\n\t\t\t\tG[u].erase(gt);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t--gtt;\n\t\tif(gt==gtt)gtt--;\n\t\tG[u].erase(gtt);\n\t\tgt=G[u].end();--gt;\n\t\tG[u].erase(gt);\n\t}\n\t//printf(\"%d %d\\n\",u,dis[u]);\n}\ninline bool check(int x)\n{\n\t//printf(\"%d:\\n\",x);\n\tFor(i,1,n)\n\t{\n\t\tG[i].clear();\n\t\tdis[i]=0;\n\t}\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\treturn dis[1]<=len&&flag;\n}\nint main()\n{\n\tint x,y;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int ok = N, ng = 0;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> vec[N];\nint head[N],deg[N];\nint n,x,y,tot,flag,A;\nstruct edge{int to,next;}e[N*2];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint check(vector<int> vec,int ban,int lim,int sz){\n\tif (ban!=-1)\n\t\tif (vec[ban]>lim) return 0;\n\tint L=0,R=sz-1;\n\tif (L==ban) L++;\n\tif (R==ban) R--;\n\twhile (L<=R){\n\t\tif (L==R){\n\t\t\tif (vec[L]>lim) return 0;\n\t\t}\n\t\telse\n\t\t\tif (vec[L]+vec[R]>lim) return 0;\n\t\tL++; R--;\n\t\tif (L==ban) L++;\n\t\tif (R==ban) R--;\n\t}\n\treturn 1;\n}\nint dfs(int x,int fa,int lim){\n\tif (!flag) return 0;\n\tvec[x].resize(0);\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa)\n\t\t\tvec[x].push_back(dfs(e[i].to,x,lim)+1);\n\tsort(vec[x].begin(),vec[x].end());\n\tint sz=vec[x].size();\n\tif (sz%2==0&&check(vec[x],-1,lim,sz))\n\t\treturn 0;\n\tif (x==1&&sz%2==0)\n\t\treturn flag=0,233;\n\tint l=0,r=sz-1,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(vec[x],mid,lim,sz))\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif (ans==-1)\n\t\tflag=0;\n\telse return vec[x][ans];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t\tdeg[x]++; deg[y]++;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tA+=(deg[i]-1)/2;\n\tint l=1,r=n,ans=0;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tflag=1;\n\t\tdfs(1,1,mid);\n\t\tif (flag)\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",A+1,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nvector<int>G[N];\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=G[u].size()/2;\n}\ninline void dfs_ans(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs_ans(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t}\n\tsort(G[u].begin(),G[u].end());\n\t/*\n\tprintf(\"%d: \",u);\n\tFor(i,0,G[u].size()-1)printf(\"%d \",G[u][i]);\n\tputs(\"\");\n\t*/\n\tif(G[u].size()&1)\n\t{\n\t\tdis[u]=G[u].back();\n\t\tint last=G[u].size()-2;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<=i)break;\n\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t{\n\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\tflag=0;\n\t\t\t}\n\t\t\tlast--;\n\t\t}\n\t}\n\telse\n\t{\n\t\tdis[u]=0;\n\t\tint last=G[u].size()-1,ret=0;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<=i)break;\n\t\t\tchkmax(ret,G[u][i]+G[u][last]);\n\t\t\tlast--;\n\t\t}\n\t\tif(ret>len&&u==1)flag=0;\n\t\tif(ret>len)\n\t\t{\n\t\t\tif(G[u].back()>len)flag=0;\n\t\t\tdis[u]=G[u][G[u].size()-2];\n\t\t\tlast=G[u].size()-3;\n\t\t\tFor(i,0,G[u].size()-1)\n\t\t\t{\n\t\t\t\tif(last<=i)break;\n\t\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t\tlast--;\n\t\t\t}\n\t\t}\n\t}\n}\ninline bool check(int x)\n{\n\tFor(i,1,n)\n\t{\n\t\tG[i].clear();\n\t\tdis[i]=0;\n\t}\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\tif((G[1].size()&1)&&G[1].back()>len)flag=0;\n\t//printf(\"%d %d\\n\",len,flag);\n\treturn flag;\n}\nint main()\n{\n\tint x,y;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(G[1].size()&1)dp[1]++;\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n\telse{\n\t\tif (x==1){\n\t\t\tf[x]=0;\n\t\t\tFOR(i,1,top/2)\n\t\t\t\tif (stk[i]+stk[top-i+1]>O) f[x]=-1;\n\t\t\treturn;\n\t\t}\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=1,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (f[1]>O+1 || f[1]==-1) ok=0;\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 5) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\tfl2 = fl;\n\tfl = true;\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nint dfs(Graph<int> &g, int v, int p, const int &mid) {\n  multiset<int, greater<int>> s;\n\n  for (int &nv : g[v]) {\n    if (nv != p) {\n      int val = dfs(g, nv, v, mid);\n\n      if (val == -1 || val == mid) return -1;\n\n      s.insert(val + 1);\n    }\n  }\n\n  bool odd = g[v].size() & 1;\n  int ret = 0;\n\n  while (s.size() > 1) {\n    int w = *begin(s); s.erase(s.begin());\n    auto itr = s.lower_bound(mid - w);\n\n    if (itr == s.end()) {\n      if (!odd) {\n        if (ret != 0) return -1;\n        ret = w;\n      }\n      else odd = false;\n      continue;\n    }\n\n    s.erase(itr);\n  }\n\n  if (s.empty()) return ret;\n\n  return *begin(s);\n}\n\nvoid solve() {\n  int n; cin >> n;\n  Graph<int> g(n);\n  rep1(i,n) {\n    int a, b; cin >> a >> b; --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  int odd = 1;\n  rep(i,n) {\n    if (g[i].size() & 1) ++odd;\n  }\n\n  const int cnt = odd / 2;\n\n  int l = 0, r = n;\n\n  while (r - l > 1) {\n    int mid = (l + r) / 2;\n    if (dfs(g, 0, -1, mid) == -1) l = mid;\n    else r = mid;\n  }\n\n  cout << pii(cnt, r) << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool check(int l) {\n\tfl = true;\n\n\tif (l == 5) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\n\treturn fl;\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nint32_t F(std::vector<int32_t>& a, int32_t K)\n{\n\tstd::sort(a.begin(),a.end());\n\tint lb = -1, ub = a.size();\n\twhile (ub - lb>1) {\n\t\tint mid = (ub + lb) / 2;\n\n\t\tbool f = true;\n\t\tint l = 0, r = a.size() - 1;\n\t\tfor (int i = 0; i < a.size() / 2;++i) {\n\t\t\tif (l == mid)l++;\n\t\t\tif (r == mid)r--;\n\t\t\tif (a[l] + a[r]>K)f = false;\n\t\t\tl++; r--;\n\t\t}\n\t\tif (f)ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tint32_t zero =1;\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0); ++zero;\n\t}\n\tL.insert(0);\n\n\tif (0)\n\t{\n\t\tstd::vector<int32_t> T;\n\t\tfor (auto& i : L) { T.push_back(i); }\n\t\tauto R = F(T, len_max);\n\t\tif (R == T.size()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn T[R];\n\t\t}\n\t}\n\tint32_t res;\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tif (*iter1 == 0) { --zero; if (zero == 0) { res = *iter2; } }\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn res;\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\tif(1){\n\n\t\tlen_max = 3;\n\t\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\t\tL.insert(2);\n\t\tL.insert(1);\n\t\tL.insert(1);\n\n\t\tif (L.size() % 2 == 0) {\n\t\t\tL.insert(0);\n\t\t}\n\n\t\twhile (L.size() >= 2) {\n\t\t\tauto iter2 = L.begin();\n\t\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\t\tif (iter1 == L.end()) {\n\t\t\t\tfunc_ok = false;\n\t\t\t\t//return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (iter1 == iter2) {\n\t\t\t\t++iter1;\n\t\t\t}\n\t\t\tL.erase(iter1);\n\t\t\tL.erase(iter2);\n\t\t}\n\t}\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrt(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-15;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint n;\nvint edge[100010];\n\nint solve(int cur, int parent, int m) {\n\tvint v;\n\trep(i, edge[cur].size()) {\n\t\tif (edge[cur][i] == parent)\tcontinue;\n\t\tint ret = solve(edge[cur][i], cur, m);\n\t\tif (ret == -1)\treturn -1;\n\t\tv.push_back(ret);\n\t}\n\t// add self=0(上にも辺があり、そのため次数が奇数）\n\tif (edge[cur].size() & 1)\tv.push_back(0);\n\tsort(all(v));\n\tif (parent == -1) {\n\t\tfor (int i = 0; i < v.size() - i - 1; i++) {\n\t\t\tif (v[i] + v[v.size() - i - 1] > m)\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\t// 一番大きなv[v.size()-1]を除いてダメならダメ\n\t\tfor (int i = 0; i < (v.size() - 1) >> 1; i++) {\n\t\t\tif (v[i] + v[v.size() - i - 2] > m)\treturn -1;\n\t\t}\n\t\t// 後ろから見て駄目な箇所を探す。それを除くと以降の整合性は取れる。\n\t\tfor (int i = v.size() - 1; i > v.size() - 1 - i; i--) {\n\t\t\tif (v[i] + v[v.size() - 1 - i] > m)\treturn v[i] + 1;\n\t\t}\n\t\tfor (int i = (v.size() - 1) >> 1; i > 0; i--) {\n\t\t\tif (v[i] + v[v.size() - i] > m)\treturn v[i] + 1;\n\t\t}\n\t\treturn v[0] + 1;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint a, b;\tcin >> a >> b;\ta--;\tb--;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tint A = 0;\n\trep(i, n)\tA += (edge[i].size() & 1);\n\tA >>= 1;\n\tint left = 0, right = n;\n\trep(i, 100) {\n\t\tint mid = (left + right) >> 1;\n\t\tif (solve(0, -1, mid) == -1)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\tcout << A << \" \" << right << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\n#define pb push_back\n#define sz(a) int(a.size())\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,A,lim,f[N];\nvector<int> E[N];\nbool fl;\n\nbool check2(vector<int> &v,int mid) {\n\tint l=0,r=sz(v)-1;\n\twhile(l<r) {\n\t\tif(l==mid) { ++l;continue; }\n\t\tif(r==mid) { --r;continue; }\n\t\tif(v[l]+v[r]>lim) return 0;\n\t\t++l,--r;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int u,int fa) {\n\tif(E[u].empty()) { f[u]=1;return; }\n\tvector<int> vec;\n\tfor(auto v:E[u]) if(v^fa) dfs(v,u),vec.pb(f[v]);\n\tif(sz(vec)&1^1) vec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=sz(vec);\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check2(vec,mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tif(l==sz(vec)) { fl=0;return; }\n\tf[u]=vec[l]+1;\n}\n\nbool check(int mid) {\n\tlim=mid;fl=1;dfs(1,0);\n\treturn fl&&f[1]<=lim+1;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tfor(int i=1;i<=n;i++)\n\t\tif(sz(E[i])&1) ++A;\n\tint l=0,r=n;\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<A/2<<' '<<l;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1) return -1;\n\t\t\telse if(res == B) ++tot, res = 0;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2 + 1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) \n\t\t\t{\n\t\t\t\ttot += a.size() / 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta.pop_back();\n\t\t\t++tot;\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];                                                                                                  \n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\ttot += a.size() / 2;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\ttot += a.size() / 2;\n\t\treturn ret;\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn tot <= A;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i,a,b) for (int i = a; i <= b; i++)\n#define rep1(i, a, b) for(int i =a; i >=b; i--)\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define f first\n#define ss second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\n\nint n,dp[101010],a,b,vis[101010],leaf,deg[101010];\nvi adj[101010];\nbool flag;\n\nvoid init(){\n       for(int i=1;i<=n;i++){\n              dp[i]=0;\n              vis[i]=0;\n       }\n       flag = true;\n}\n/*bool can2(int pos, int b){\n       if(pos<0)return true;\n       int k = v.size();\n       int itr = k/2,mx=0;\n       for(int i=0;i<k;i++){\n              if(i!=pos)q.pb(v[i]);\n       }\n       int i=0;\n       sort(all(q));\n       while(itr--){\n              int cur = q[i++]+q.back();\n              mx = max(cur,mx);\n              q.pop_back();\n       }\n       q.clear();\n       return mx<=b;\n}*/\nint dfs(int s, int p){\n       vi v;\n       for(auto t:adj[s]){\n              if(t!=p){\n                    int m = dfs(t,s);\n                    if(m!=inf)v.pb(m);\n                    else return inf;\n                     //v.pb(dp[t]);\n              }\n       }\n       if(p==-1)return 0;\n       if(v.size()==0)return 1;\n       sort(all(v));\n       int k = (int)v.size();\n       flag = true;\n       if(k%2==0){\n              for(int i=0;i<k/2;i++){\n                     if(v[i]+v[k-i-1]>b)flag = false;\n              }\n              if(flag)return 1;\n              v.pop_back();\n       }\n       //if(!can2(k-1,b))flag=false;\n       k = v.size();\n       int l=-1,r=k;\n       while(r-l>1){\n              int mid = (l+r)/2;\n              int ll=0,rr=k-1;\n              flag = true;\n\n              for(int i=0;i<k/2;i++){\n                     if(ll==mid)ll++;\n                     if(rr==mid)rr--;\n                     if(v[ll]+v[rr]>b)flag = false;\n                     ll++;rr--;\n              }\n              if(flag)r=mid;\n              else l=mid;\n       }\n       if(r==k)return inf;\n       if(v[r]+1>b)return inf;\n       return v[r]+1;\n}\nbool can(int x){\n       init();\n       b = x;\n       return dfs(leaf,-1)!=inf;\n}\n\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\nfor(int i=1;i<n;i++){\n       int x,y;\n       cin >> x >> y;\n       adj[x].pb(y);\n       adj[y].pb(x);\n       deg[x]++;\n       deg[y]++;\n}\nfor(int i=1;i<=n;i++){\n       if(deg[i]%2)a++;\n       if(deg[i]==1)leaf=i;\n}\nint l=0,r=n,ans;\nwhile(r-l>1){\n       int mid = (l+r)/2;\n       if(can(mid)){\n              r=mid;\n       }\n       else {\n              l=mid;\n       }\n}\n\ncout << a/2 << \" \" << r << endl;\n\n\n\n\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(vec[l]==son) ++l;\n\t\tif(vec[r]==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tret&=treeDP(v,u);\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(!ret) return false;\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nint N;\nvint G[111111];\n\nint K;\n\nint dfs(int v,int p){\n    vint a;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        int tmp=dfs(u,v);\n        if(tmp==INF)return INF;\n        a.pb(tmp);\n    }\n\n    sort(all(a));\n    if(p==-1)return 0;\n    if(a.size()==0)return 1;\n\n    if(a.size()%2==0){\n        bool f=true;\n        rep(i,a.size()/2)if(a[i]+a[a.size()-i-1]>K)f=false;\n        if(f)return 1;\n        a.pop_back();\n    }\n\n    int lb=-1,ub=a.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n\n        bool f=true;\n        int l=0,r=a.size()-1;\n        rep(i,a.size()/2){\n            if(l==mid)l++;\n            if(r==mid)r--;\n            if(a[l]+a[r]>K)f=false;\n            l++;r--;\n        }\n        if(f)ub=mid;\n        else lb=mid;\n    }\n    if(ub==a.size())return INF;\n    if(a[ub]+1>K)return INF;\n    return a[ub]+1;\n}\n\nbool C(int x){\n    K=x;\n    rep(i,N)if(G[i].size()==1)return dfs(i,-1)!=INF;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    int cnt=0;\n    rep(i,N)if(G[i].size()%2)cnt++;\n\n    int A=cnt/2;\n\n    int lb=0,ub=N;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(C(mid))ub=mid;\n        else lb=mid;\n    }\n\n    cout<<A<<\" \"<<ub<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(l==son) ++l;\n\t\tif(r==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tif(!treeDP(v,u)) return false;\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(n+1,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tdeg[n+1]=1,addE(n+1,1);\n\tcal_A();\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n       \n        }\n            \n    dp[n]=X[ind].first+1;\n    if(dp[n]>mid){\n        \n        dp[n]=1000000000;\n    }\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n   \n   \n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n   \n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]!=1000000000){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]!=1000000000){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<bool, Int> P;\n\n\nvector<int> edge[110000];\nint n, u, v;\n\nP check(vector<int> &tmp, int b){\n    int k = tmp.size();\n    if(k == 1)return P(true, tmp[0]);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-2-i] > b)return P(false, 0);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-1-i] > b)return P(true, tmp[k-1-i]);\n    for(int i = k/2;i > 0;i--)\n        if(tmp[i] + tmp[k-i] > b)return P(true, tmp[i]);\n    return P(true, tmp[0]);\n}\n\nP dfs(int x, int b, int last = -1){\n    vector<int> tmp;\n    for(auto to: edge[x]){\n        if(to == last)continue;\n        auto p = dfs(to, b, x);\n        if(!p.first)return P(false, 0);\n        if(p.second == b)return P(false, 0);\n        tmp.push_back(p.second + 1);\n    }\n    sort(tmp.begin(), tmp.end());\n    int k = tmp.size();\n    if(tmp.size() % 2 == 0){\n        bool ok = true;\n        for(int i = 0;i < k/2;i++)\n            if(tmp[i] + tmp[k-1-i] > b)ok = false;\n        if(ok)return P(true, 0);\n        tmp.pop_back();\n    }\n    return check(tmp, b);\n}\n\nint main(){\n    cin >> n;\n    int a = 0;\n    for(int i = 0;i < n-1;i++){\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    for(int i = 1;i <= n;i++)if(edge[i].size() % 2)a++;\n    a/=2;\n\n    int bottom  = 0, top = n;\n    while(top - bottom > 1){\n        int mid = (top + bottom) / 2;\n        if(dfs(1, mid).first)top = mid;\n        else bottom = mid;\n    }\n    cout << a << \" \" << top << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool check(int l) {\n\tfl = true;\n\n\tif (l == 5) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\n\treturn fl;\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tif(t.back()>h)return inf;\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(t.size()%2==0){\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=-1,r=t.size()-1;\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tif(f(t,r))cmin(out,t[r]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n-1;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e5 + 5;\n\nvector < int > V[N];\nint T[N],t,ok,K;\n\nint f(int x, int p){\n    if(ok == 0) return 0;\n    vector < int > v;\n    if(V[x].size() % 2 == 1) v.pb(0);\n    for(int y, i=0; i<V[x].size(); i++)\n        if((y = V[x][i]) != p){\n            v.pb( f(y,x)+1 );\n            if(ok == 0) return 0;\n        }\n    sort(v.begin() , v.end());\n    if(x == 1){\n        t = v.size();\n        for(int i=0; i<t; i++)\n            if(v[i] + v[t-i-1] > K) return ok=0;\n        return 0;\n    }\n    int i,l,m,r;\n    l = 0;\n    r = v.size();\n    for(;l < r;){\n        m = l+r >> 1;\n        t = 0;\n        for(i=0;i<v.size();i++)\n            if(i != m)\n                T[++t] = v[i];\n        \n        for(i=1;i<=t/2;i++)\n            if(T[i] + T[t-i+1] > K)\n                break;\n        if(i <= t/2) l = m+1;\n        else r = m;\n    }\n    if(l == v.size()) return ok=0;\n    return v[l];\n}\n\nint n,i,x,y,a,l,m,r;\nint main(){\n    cin >> n;\n    for(i=1;i<n;i++){\n        scanf(\"%d%d\",&x,&y);\n        V[x].pb(y); V[y].pb(x);\n    }\n    \n    a = 1;\n    for(i=1;i<=n;i++)\n        a += (int)V[i].size()-1 >> 1;\n        \n    l = n/a-1;\n    r = n;\n    for(; l<r ;){\n        m = l+r >> 1;\n        ok = 1;\n        K = m;\n        f(1,-1);\n        if(ok) r = m;\n        else l = m+1;\n    }\n    \n    cout << a << \" \" << l << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tint p1 = 0, p2 = son.size()-1;\n\twhile (p1 < p2)\n\t{\n\t\tif (p1 == r) p1++;\n\t\tif (p2 == r) p2--;\n\t\tif (p1 >= p2) break;\n\t\tif (son[p1] + son[p2] > B) return false;\n\t\tp1++; p2--;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x, bool deg) {\n        if (deg) assert(tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x, false)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x, false)) {\n                                        res = false;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x, true)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x, true)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x, false)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 2) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfl2 = fl;\n\t/*\n\tfl = true;\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}*/\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5;\nvector<int> g[N];\nvector<int> path[N];\n\nvoid dfs(int u, int p, int x) {\n  for (int v : g[u]) if (v != p) {\n    dfs(v, u, x);\n    path[u].push_back(path[v].back() + 1);\n  }\n\n  if (path[u].size() % 2 == 0) {\n    path[u].push_back(0);\n  }\n\n  sort(path[u].begin(), path[u].end());\n\n  int ok = path[u].size();\n  int ng = -1;\n\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n\n    int mx = 0;\n    auto tmp = path[u];\n    tmp.erase(tmp.begin() + mid);\n\n    for (int i = 0; i * 2 + 1 < tmp.size(); i++) {\n      mx = max(mx, tmp[i] + tmp[tmp.size() - 1 - i]);\n    }\n\n    if (mx <= x) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n \n  if (ok == path[u].size()) throw -1;\n  swap(path[u][ok], path[u].back());\n  \n  if (p == -1) {\n    if (path[u].back() > x) throw -1;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<int> deg(n);\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    deg[u]++;\n    deg[v]++;\n  }\n  int A = 1;\n  for (int i = 0; i < n; i++) {\n    A += (deg[i] - 1) / 2;\n  }\n\n  int ok = n - 1;\n  int ng = -1;\n  while (ok - ng > 1) {\n    for (int i = 0; i < n; i++) {\n      path[i].clear();\n    }\n    int mid = (ok + ng) / 2;\n    try {\n      dfs(0, -1, mid);\n      ok = mid;\n    } catch (...) {\n      ng = mid;\n    }\n  }\n\n  cout << A << ' ' << ok << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nvoid dfs2(int u, int p, int cri, int& sm)\n{\n    multiset<int> ng;\n    for(int v : G[u]){\n        if(v != p){\n            dfs2(v, u, cri, sm);\n            ng.insert(dp[v]);\n        }\n    }\n    while(!ng.empty()){\n        if(len(ng) == 1){\n            int val = *ng.begin();\n            if(cri >= val+1){\n                dp[u] = val + 1;\n                return;\n            }else{\n                dp[u] = 1;\n                sm++;\n                return;\n            }\n        }else{\n            int val = *(--ng.end());\n            ng.erase(--ng.end());\n            if(val == cri){\n                sm++;\n                ng.insert(0);\n            }else{\n                auto it = ng.upper_bound(cri-val-2);\n                if(it == ng.begin()){\n                    sm++;\n                }else{\n                    --it;\n                    ng.erase(it);\n                    sm++;\n                }\n            }\n        }\n    }\n    dp[u] = 0;\n}\n\nbool possible(int cri, int a)\n{\n    int sm = 0;\n    dfs2(0, -1, cri, sm);\n    if(dp[0]) sm++;\n    return (sm == a);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    assert(possible(n, a));\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)if(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\tif(u==1&&(tt&1)){\n\t\tif(now[tt]+1>mid)return false;tt--;\n\t\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);pre=i-1,suf=i;\n\t\twhile(1){\n\t\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\t\telse if(pre>0)tt--,pre--;\n\t\t\telse if(tt-suf==1){\n\t\t\t\tif(u==1)return false;\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else return false;\n\t\t}\n\t}else {\n\t\twhile(1){\n\t\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\t\telse if(pre>0)tt--,pre--;\n\t\t\telse if(tt-suf==1){\n\t\t\t\tif(u==1)return false;\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else return false;\n\t\t}\n\t}\n\t\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;//printf(\"%d\\n\",dp(1,1,3));\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define si scanf\n#define so printf\n#define N 200100\n#define M \n#define INF  \n#define nxt t[j]\ntemplate<typename TP>inline bool rd(TP& r)\n{\n\tr=0;\n\tchar tmp=getchar();\n\twhile(tmp<'0'||tmp>'9')\n\t{\n\t\tif(tmp==EOF)\n\t\t\treturn 0;\n\t\ttmp=getchar();\n\t}\n\twhile('0'<=tmp&&tmp<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+tmp-'0';\n\t\ttmp=getchar();\n\t}\n\treturn 1;\n\t\n} \nint n; \nint h[N],x[N*2],t[N*2],tot=1;\nint du[N],A;\nvoid add(int u,int v)\n{\n\t++tot;\n\tx[tot]=h[u];\n\th[u]=tot;\n\tt[tot]=v;\n\t++du[u];\n}\nint ln[N],l2[N];\nint f[N];\nbool ok(int mid,int u)\n{\n\tfor(int i=1;i<=ln[0];++i)\n\t\tif(i==mid)\n\t\t\tl2[i]=n+100;\n\t\telse\n\t\t\tl2[i]=ln[i];\n\tsort(l2+1,l2+ln[0]+1);\n\tfor(int i=1;i<ln[0];++i)\n\t\tif(l2[i]+l2[ln[0]-i]+1>u)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dp(int u)\n{\n\tsort(ln+1,ln+ln[0]+1);\n\tfor(int i=1;i<=ln[0]-1;++i)\n\t\tif(ln[i]+ln[ln[0]-i]+1>u)//无法配对 \n\t\t\treturn n*12;\n\tln[ln[0]+1]=n*12;\n\tint l=1,r=ln[0]+1,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(ok(mid,u))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tif(l>ln[0])\n\t\treturn n*12;\n\treturn ln[l]+1;\n}\nbool dfs(int now,int u,int fa)\n{\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tif(dfs(nxt,u,now)==0)\n\t\t\t\treturn 0;\n\tln[0]=0;\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tln[++ln[0]]=f[nxt];\n\tif(du[now]&1)\n\t\tln[++ln[0]]=0;\n\tf[now]=dp(u);\n\tif(f[now]>u)\n\t\treturn 0; \n\treturn 1;\n}\nint main()\n{\n\trd(n);\n\tint u,v;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\trd(u),rd(v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(du[i]&1)\n\t\t\t++A;\n\tint rt=0;\n\tfor(int i=1;i<=n&&!rt;++i)\n\t\tif(du[i]==1)\n\t\t\trt=i;\n\tA>>=1;\n\tint l=1,r=n*10,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\t//memset(f,0x3f,sizeof(f));\n\t\tif(dfs(rt,mid,0))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tso(\"%d %d\\n\",A,l-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    assert(V[1].size()%2!=0);\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        assert((int) tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        //bool res = true;\n        //function<void (int, int)> dfs = [&](int u, int prev) {\n        function<bool (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        //dfs(v, u);\n                        if (!dfs(v, u)) return false;\n                        //if (dp[v] + 1 > x) res = false;\n                        if (dp[v] + 1 > x) return false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        //return;\n                        return true;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                //res = false;\n                                return false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        //res = false;\n                                        return false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        //res = false;\n                                        return false;\n                                }\n                        }\n                        //return;\n                        return true;\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                //res = false;\n                                return false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                //res = false;\n                                return false;\n                        }\n                }\n                return true;\n        };\n        bool res = dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+50;\nint n;\nvector<int> g[N], h[N];\n\nint dfs(int x, int f, int d) {\n\tfor (int y:g[x]) if (y!=f) h[x].pb(dfs(y,x,d));\t\n\tif (h[x].empty()) return 1;\n\tif (h[x].size()%2==0) h[x].pb(0);\n\tsort(h[x].begin(),h[x].end());\n\tint sz=h[x].size(),l=0,r=sz-1,ans=-1;\n\twhile (l<=r) {\n\t\tint ql=0,qr=sz-1,ok=1;\n\t\twhile (1) {\n\t\t\tif (ql==mid) ++ql;\n\t\t\tif (qr==mid) --qr;\n\t\t\tif (ql>qr) break;\n\t\t\tif (h[x][ql]+h[x][qr]>d) ok=0;\n\t\t\t++ql,--qr;\n\t\t}\n\t\tif (ok) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans<0?INF:h[x][ans]+1; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,2,n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tint cnt = 0;\n\tREP(i,1,n) cnt += g[i].size()&1;\n\tcnt /= 2;\n\tint l = 0, r = n-1, ans;\n\twhile (l<=r) {\n\t\tif (dfs(1,0,mid)<=mid+1) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\", cnt, ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 1];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, length[MAX_N];\nint que[MAX_N], top, ans2, mid, ok, ans1;\n\nbool check(int pos) {\n  for (int i = 1, j = top; i < j; ++i, --j) {\n    if (i == pos) i++;\n    if (j == pos) j--;\n    if (i < j && que[i] + que[j] > mid) return false;\n  }\n  return true;\n}\n\nvoid dfs(int u, int v) {\n  if (!ok) return;\n  \n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v)\n      dfs(e[i].to, u);\n  if (!ok) return;\n  \n  top = 0;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v)\n      que[++top] = length[e[i].to];\n  sort(que + 1, que + top + 1);\n  \n  if (top % 2 == 0) {\n    bool flag = 1;\n    for (int i = 1; i <= top / 2; ++i)\n      if (que[i] + que[top - i + 1] > mid) {\n\tflag = 0;\n\tbreak;\n      }\n    if (flag) {\n      length[u] = 1, ans1 += top / 2;\n      return;\n    }\n    if (v == 0) {\n      ok = 0;\n      return;\n    }\n    top--, ans1++;\n  }\n  que[top + 1] = 0;\n  if (top & 1) {\n    int l = 1, r = top, res = -1;\n    while (l <= r) {\n      int tmid = (l + r) >> 1;\n      if (check(tmid)) res = tmid, r = tmid - 1;\n      else l = tmid + 1;\n    }\n    if (res == -1) ok = 0;\n    if (que[res] == mid && v != 0) ok = 0;\n    length[u] = que[res] + 1, ans1 += top / 2;\n    if (v == 0) ans1++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, u, v; i < N; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v);\n  }\n  int l = 1, r = N, ans2 = N;\n  while (l <= r) {\n    ans1 = 0;\n    mid = (l + r) >> 1;\n    ok = 1, dfs(1, 0);\n    if (ok) ans2 = mid, r = mid - 1;\n    else l = mid + 1;\n  }\n  \n  ans1 = 0, ok = 1, mid = ans2;\n  dfs(1, 0);\n  printf(\"%d %d\\n\", ans1, ans2);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(vec[l]==son) ++l;\n\t\tif(vec[r]==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tret&=treeDP(v,u);\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(!ret) return false;\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tif(a + table.front() > length){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\t//if(de < 0){\n\t\t//\tdame = true;\n\t\t//\treturn INF;\n\t\t//}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\tassert(node == num);\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 1;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring> \n#include<cstdio>\n#include<set>\n#define MN 100000\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nmultiset<int>s[MN+5];\nmultiset<int>::iterator it;\nint n,f[MN+5],head[MN+5],cnt,ans,flag,mid,rt,d[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t){\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;++d[f];\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;++d[t];\n}\nvoid dfs(int x,int fa){\n\ts[x].clear();f[x]=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)dfs(e[i].to,x),s[x].insert(f[e[i].to]+1);\n\tint has=0,has2=0,size=s[x].size();\n\tif(!size)ans++;ans-=(size-1)/2;\n\tif(s[x].size()&&(*(--(it=s[x].end())))>mid) return(void)(flag=0);\n\twhile(!s[x].empty()){\n\t\tit=s[x].end();--it;\n\t\tint v=*it;s[x].erase(it);\n\t\tit=s[x].upper_bound(mid-v);\n\t\tif(it==s[x].begin())\n\t\t\tif(!has) has=v,f[x]=has;\n\t\t\telse if(~size&1)\n\t\t\t\tif(!has2)has2=v,f[x]=has2;\n\t\t\t\telse return(void)(flag=0);\n\t\t\telse return (void)(flag=0);\n\t\telse s[x].erase(--it);\n\t}\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<n;i++)ins(read(),read());\n\tint l=1,r=n,res,Ans;\n\tfor(rt=1;~d[rt]&1;rt++);\n\twhile(l<=r){\n\t\tmid=l+r>>1;ans=0;flag=1;\n\t\tdfs(rt,0);\n\t\tif(flag)res=mid,r=mid-1,Ans=ans;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",Ans,res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nint N;\nvint G[111111];\n\nint K;\n\nint dfs(int v,int p){\n    vint a;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        int tmp=dfs(u,v);\n        if(tmp==INF)return INF;\n        a.pb(tmp);\n    }\n\n    sort(all(a));\n    if(p==-1)return 0;\n    if(a.size()==0)return 1;\n\n    if(a.size()%2==0)a.pop_back();\n\n    int lb=-1,ub=a.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n\n        bool f=true;\n        int l=0,r=a.size()-1;\n        rep(i,a.size()/2){\n            if(l==mid)l++;\n            if(r==mid)r--;\n            if(a[l]+a[r]>K)f=false;\n            l++;r--;\n        }\n        if(f)ub=mid;\n        else lb=mid;\n    }\n    if(ub==a.size())return INF;\n    if(a[ub]+1>K)return INF;\n    return a[ub]+1;\n}\n\nbool C(int x){\n    K=x;\n    rep(i,N)if(G[i].size()==1)return dfs(i,-1)!=INF;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    int cnt=0;\n    rep(i,N)if(G[i].size()%2)cnt++;\n\n    int A=cnt/2;\n\n    int lb=0,ub=N;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(C(mid))ub=mid;\n        else lb=mid;\n    }\n\n    cout<<A<<\" \"<<ub<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\tif (len[j]<=mid)\n\t\t\t{\n\t\t\t\ts.erase(j);\n\t\t\t\tt--;\n\t\t\t}\n\t\t\tj--;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1) dis[x]=len[*s.begin()];\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\twhile (nt && extra.size()) {\n\t\textra.pop_back();\n\t\tnt--;\n\t}\n\tif(nt)ans = 1e9;\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\tif(all != ans1)return false;\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tmd = 1e9;\n\tdfs(1,-1);\n\tans1 = all;\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tvector<int> vec;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvec.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vec.size()==0)return P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\n#ifdef ONLINE_JUDGE\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n#define fu(a,b,c) for(int a=b;a<=(int)c;++a)\n#define fd(a,b,c) for(int a=b;a>=(int)c;--a)\n#define cu(a,b,c) for(int a=b;a<(int)c;++a)\n#define cd(a,b,c) for(int a=(b)-1;a>=(int)c;--a)\n#define gcd(a,b) __gcd(a,b) \n#define pii pair<int,int>\n#define pll pair<long long,long long>\n#define all(a) a.begin(),a.end()\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define uint unsigned int\n#define MOD 100000007\n#define MAXN 200005\n#define MAXH 4\n#define MAXM 100\n#define INF 1LL << 61\n#define ll long long\n#define ull unsigned long long\n#define RNG rng mt19937(time(NULL))\n#define udist(a,b) uniform_int_distribution<uint32_t> distribution(a,b)\n#define max3(a,b,c) max(a, max(b, c))\n#define min3(a,b,c) min(a, min(b, c))\n#define gmax(a,b) a = max(a, b)\n#define gmin(a,b) a = min(a, b)\n#define whatis(x) cerr << #x << \" is \" << x << endl;\n#define mat vector<vector<T>>\n#define T long long\n#define fast_io() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define cld complex<long double>\nusing namespace std;\nconst int N = 100005;\nint n;\nvector<int> t[N];\nint dp[N];\n\nbool check(int c, int p, int b){\n\tvector<int> children;\n\tbool val = true;\n\tfor(int a: t[c]){\n\t\tif(a != p){\n\t\t\tval &= check(a, c, b);\n\t\t\tchildren.pb(dp[a]);\n\t\t}\n\t}\n\tif(!val)return false;\n\tif(children.size() % 2 == 0)children.pb(0);\n\n\tsort(all(children));\n\tint l=0, r=children.size() - 1, m;\n\tint best = -1;\n\tint mx = 0;\n\twhile(l <= r){\n\t\tm = l + (r-l)/2;\t\n\t\tint left = 0, right = children.size() - 1;\n\t\twhile(left < right){\n\t\t\tif(left == m){++left;continue;}\n\t\t\tif(right == m){--right;continue;}\n\t\t\tgmax(mx, children[left] + children[right]);\n\t\t\t++left;\n\t\t\t--right;\n\t\t}\n\t\tif(mx <= b){\n\t\t\tbest = m;\n\t\t\tr = m - 1;\n\t\t}\n\t\telse{\n\t\t\tl = m + 1;\n\t\t}\n\t}\n\tif(best == -1)return false;\n\tdp[c] = children[best] + 1;\n\tif(c == 1){\n\t\treturn dp[c] <= b + 1;\n\t}\n\treturn true;\n}\n\nint main(){\n\tfast_io();\n\tcin >> n;\n\tint x,y;\n\tcu(i,0,n-1){\n\t\tcin >> x >> y;\t\n\t\tt[x].pb(y);\n\t\tt[y].pb(x);\n\t}\n\tint A = 0;\n\tfu(i,1,n)A+=(t[i].size()&1);\n\tA/=2;\n\tt[1].pb(0); // for correct dp\n\tt[0].pb(1); // for correct dp\n\tint B = n;\n\tint l = 1, r = n, m;\n\twhile(l <= r){\n\t\tm = l + (r-l)/2;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tif(check(1, 0, m)){\n\t\t\tB = m;\n\t\t\tr = m - 1;\n\t\t}\n\t\telse{\n\t\t\tl = m + 1;\n\t\t}\n\t}\n\tcout << A << ' ' << B << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans_a, ans_b;\n\t\n\tvoid write () {\n\t\tcout << ans_a << ' ' << ans_b << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint root;\n\t\tint mxl;\n\t\t\n\t\tint rec (int v, int pr) {\n\t\t\tvi q;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint val = rec(to, v);\n\t\t\t\tif (val == -1 || val + 1 > mxl) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tq.pb(val + 1);\n\t\t\t}\n\t\t\tsort(all(q), greater<int>());\n\t\t\t\n\t\t\tif (!sz(q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint val0 = q[0];\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tq[0] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (j < sz(q) && (j <= i || q[j] == -1 || q[i] + q[j] > mxl)) {\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tif (j < sz(q)) {\n\t\t\t\t\tq[i] = q[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvi qq;\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tqq.pb(val0);\n\t\t\t}\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] != -1) {\n\t\t\t\t\tqq.pb(q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sz(qq) == 2 && qq[0] + qq[1] <= mxl) {\n\t\t\t\tqq.clear();\n\t\t\t}\n\t\t\t\n\t\t\tif (sz(qq) == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (sz(qq) == 1) {\n\t\t\t\treturn qq[0];\n\t\t\t} else if (sz(qq) == 2) {\n\t\t\t\treturn qq[1];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\n\t\tbool check (int val) {\n\t\t\tmxl = val;\n\t\t\treturn rec(root, -1) != -1;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\troot = 0;\n\t\t\twhile (sz(e[root]) > 1) {\n\t\t\t\troot++;\n\t\t\t}\n\t\t\t\n\t\t\tans_a = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tif (sz(e[i]) & 1) {\n\t\t\t\t\tans_a++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_a /= 2;\n\t\t\t\n\t\t\tint lb = 0, rb = n - 1;\n\t\t\twhile (lb < rb) {\n\t\t\t\tint md = (lb + rb) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\trb = md;\n\t\t\t\t} else {\n\t\t\t\t\tlb = md + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_b = lb;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <algorithm>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nconst int ms = 100100;\n\nstd::vector<int> edges[ms];\nstd::vector<std::pair<int, int>> dp[ms];\n\nvoid pre(int on, int par) {\n\tfor(int i = 0; i < (int) edges[on].size(); i++) {\n\t\tif(edges[on][i] == par) {\n\t\t\tstd::swap(edges[on][i], edges[on].back());\n\t\t\tedges[on].pop_back();\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tpre(edges[on][i], on);\n\t}\n\tdp[on].resize(edges[on].size());\n}\n\nint L;\nint solve(const std::vector<std::pair<int, int>> &a, int skip) {\n\tint ans = 0;\n\tfor(int l = 0, r = (int) a.size() - 1; l < r; l++) {\n\t\tif(l == skip) continue;\n\t\tif(r == skip) {\n\t\t\tr--;l--;\n\t\t\tcontinue;\n\t\t}\n\t\tint s1 = L - a[l].first;\n\t\tint s2 = L - a[r].first;\n\t\tif(s1 + s2 <= L) {\n\t\t\tr--;\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nstd::pair<int, int> dfs(int on) {\n\t// returns (number of paths, rest of path going up)\n\tint sum = 0;\n\tfor(int i = 0; i < (int) edges[on].size(); i++) {\n\t\tdp[on][i] = dfs(edges[on][i]);\n\t\tif(dp[on][i].second == 0) {\n\t\t\tdp[on][i].first++;\n\t\t\tdp[on][i].second = L - 1;\n\t\t} else {\n\t\t\tdp[on][i].second--;\n\t\t}\n\t\tsum += dp[on][i].first;\n\t}\n\t// always when possible, pair shit up\n\tfor(auto &p : dp[on]) std::swap(p.first, p.second);\n\tstd::sort(dp[on].begin(), dp[on].end());\n\tint can = solve(dp[on], 1298739);\n\tif(2 * can == (int) dp[on].size()) {\n\t\treturn std::pair<int, int>(sum - can, 0);\n\t}\n\tint l = 0, r = (int) dp[on].size() - 1;\n\twhile(l != r) {\n\t\tint mid = (l + r + 1) / 2;\n\t\tif(solve(dp[on], mid) == can) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\tassert(solve(dp[on], l) == can);\n\treturn std::pair<int, int>(sum - can, dp[on][l].first);\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint n;\n\tstd::cin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tstd::cin >> u >> v;\n\t\tu--;v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpre(0, 0);\n\tint l = 1, r = n;\n\tL = n;\n\tint best = dfs(0).first;\n\twhile(l != r) {\n\t\tL = (l + r) / 2;\n\t\tif(dfs(0).first == best) {\n\t\t\tr = L;\n\t\t} else {\n\t\t\tl = L + 1;\n\t\t}\n\t}\n\tstd::cout << best << ' ' << l << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\n\nint n, lim, ans, dt[N];\n\nvector<int> adj[N], arr;\n\nbool can (int C, int P) {\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(!can(T, C)) return false;\n\t}\n\tarr.clear();\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(dt[T]+1 > lim) return false;\n\t\tarr.push_back(dt[T]+1);\n\t}\n\tsort(arr.begin(), arr.end());\n\tint N = arr.size();\n\tif(N % 2 == 0) {\n\t\tbool F = false;\n\t\tfor(int i=0;i<N/2;i++) {\n\t\t\tif(arr[i] + arr[N-1-i] > lim) F = true;\n\t\t}\n\t\tif(!F) {dt[C] = 0; return true;}\n\t\tarr.pop_back(); N--;\n\t}\n\tint S = 0, E = N;\n\twhile(S<E) {\n\t\tint M = (S+E)/2, L = 0, R = N-1;\n\t\tbool F = false;\n\t\twhile(1) {\n\t\t\tif(L == M) L++;\n\t\t\tif(R == M) R--;\n\t\t\tif(L >= R) break;\n\t\t\tif(arr[L] + arr[R] > lim) {F = true; break;}\n\t\t\tL++; R--;\n\t\t}\n\t\tF ? S = M+1 : E = M;\n\t}\n\tif(S == N) return false;\n\tdt[C] = arr[S];\n\treturn true;\n}\n\nbool can () {\n\tif(!can(1, 0)) return false;\n\treturn (adj[1].size() % 2 || dt[1] == 0);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tans = n-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tans -= (int)adj[i].size() / 2;\n\t}\n\tprintf(\"%d \",ans);\n\tint S = 0, E = n;\n\twhile(S<E) {\n\t\tlim = (S+E)/2;\n\t\tcan() ? E = lim : S = lim+1;\n\t}\n\tprintf(\"%d\\n\",S);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  rep(i,0,n){\n    if(g[i].size()&1)res++;\n  }\n  ll ok=n,ng=0;\n  while(ok-ng>=2){\n    ll mid=(ok+ng)/2;\n    bool sw=true;\n    auto dfs=[&](auto &&f,ll k,ll par)->ll{\n      vector<ll>v;\n      if(g[k].size()&1)v.PB(0);\n      for(auto to:g[k]){\n        if(to==par)continue;\n        ll p=f(f,to,k);\n        if(p!=-1)v.PB(p);\n      }\n      sort(ALL(v));\n      ll sz=v.size();\n      rep(i,0,sz/2){\n        if(v[i]+v[sz-i-1]>mid)sw=false;\n      }\n      if(sz%2==0){\n        return -1;\n      }\n      else{\n        ll ok=sz-1,ng=-1;\n        while(ok-ng>=2){\n          ll mid=(ok+ng)/2;\n          vector<ll>tmp;\n          rep(i,0,sz)if(i!=mid)tmp.PB(v[i]);\n          bool sw2=true;\n          rep(i,0,sz/2){\n            if(v[i]+v[sz-i-2])sw2=false;\n          }\n          if(sw)ok=mid;\n          else ng=mid;\n        }\n        return v[ok]+1;\n      }\n    };\n    dfs(dfs,0,-1);\n    if(sw)ok=mid;\n    else ng=mid;\n  }\n  cout<<res/2 spa ok<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nvector<int> g[100010];\nbool visited[100010];\n\npair<int,bool> dfs1(int v) {\n  visited[v] = true;\n  int res = 0;\n  int d = 0;\n  for (int i: g[v]) {\n    if (visited[i]) continue;\n    ++d;\n    res += dfs1(i).first;\n  }\n  res += d / 2;\n  return make_pair(res, d % 2 == 1);\n}\n\npair<int,int> dfs2(int v, int limit) {\n  visited[v] = true;\n  int sum = 0;\n  multiset<int> s;\n  for (int i: g[v]) {\n    if (visited[i]) continue;\n    auto r = dfs2(i, limit);\n    sum += r.first;\n    s.insert(r.second + 1);\n  }\n  multiset<int> rest;\n  while (!s.empty()) {\n    auto it = prev(end(s));\n    int a = *it;\n    s.erase(it);\n    if (a > limit) { s.insert(a - limit); ++sum; continue; }\n    if (s.empty()) { rest.insert(a); break; }\n    it = s.upper_bound(limit - a);\n    if (it == begin(s)) { rest.insert(a); continue; }\n    sum++;\n    s.erase(prev(it));\n  }\n  if (!rest.empty()) sum += int(rest.size()) - 1;\n  int len = rest.empty() ? 0 : *begin(rest);\n  // cout << v << \" \" << limit << \" \" << sum << \" \" << len << endl;\n  return make_pair(sum, len);\n}\n\nvoid solve(ll N, vector<ll> a, vector<ll> b) {\n  REP(i,N-1) {\n    int s = a[i] - 1, t = b[i] - 1;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  memset(visited, 0, sizeof(visited));\n  auto r = dfs1(0);\n  int res = r.first + r.second;\n  int lb = 0, ub = 1e6;\n  // memset(visited, 0, sizeof(visited));\n  // auto rr = dfs2(0, 2);\n  // cout << rr.first << \" \" << rr.second << endl;\n  // return;\n  while (ub - lb > 1) {\n    int mid = (lb + ub) / 2;\n    memset(visited, 0, sizeof(visited));\n    auto r = dfs2(0, mid);\n    int c = r.first + (r.second > 0);\n    if (c > res) lb = mid; else ub = mid;\n  }\n  cout << res << \" \" << ub << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> b((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor (int i = 0 ; i <= (N-1)-1 ; i++) {\n\t  scanf(\"%lld\", &a[i]);\n\t  scanf(\"%lld\", &b[i]);\n\t}\n\tsolve(N, a, b);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge && ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\telse if(n==1) return false;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 0,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    if(len(vec) % 2){\n        sort(all(vec));\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri) return false;\n        }\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nvector<int> V[MC];\nvector<int> S[MC];\nint r;\n\nbool dfs(int p , int q , int z){\n\tS[q].clear();\n\tfor(auto u : V[q]){\n\t\tif(u==p) continue;\n\t\tif(!dfs(q,u,z)) return 0;\n\t}\n\tif(S[q].size()%2==0) S[q].PB(0);\n\tsort(S[q].begin(),S[q].end());\n\tint f = 0 , g = -1;\n\tdeque<int> Q;\n\trepm(i,S[q].size()-1,-1){\n\t\twhile(f<i && S[q][f]+S[q][i]<=z){\n\t\t\tQ.push_back(S[q][f]);\n\t\t\t++f;\n\t\t}\n\t\tif(f == i){\n\t\t\tQ.push_back(S[q][f]);\n\t\t\tbreak;\n\t\t}\n\t\tif(Q.empty()){\n\t\t\tif(~g) return 0;\n\t\t\tg = S[q][i];\n\t\t} else {\n\t\t\tQ.pop_back();\n\t\t}\n\t}\n\tint w = max(Q.empty()?0:Q.front(),g);\n\tif(p>0) S[p].PB(w+1);\n\telse if(w>z) return 0;\n\treturn 1;\n}\n\nint BS(int x , int y){\n\tif(x-y<2) return x;\n\tint z = (x+y) / 2;\n\treturn dfs(-1,r,z) ? BS(z,y) : BS(x,z);\n}\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tint A = 1;\n\trepp(i,1,N+1){\n\t\tA += (V[i].size()-1)/2;\n\t\tif(V[i].size()==1) r = i;\n\t}\n\tcout << A << ' ' << (A==1?N-1:BS(N-1,0)) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n//#ifdef LOCAL\n//#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n//#else\n//#define NDEBUG\n//#define eprintf(...) do {} while (0)\n//#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t, st;\n\nbool ok(int mid) {\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    if (dp[*e]+1 > mid) return false;\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (v == 0) {\n\t    int m = t.size()/2;\n\t    sort(t.begin(), t.end());\n\t    REP (j, m) if (t[j] + t[m*2-1-j] > mid) return false;\n\t    return true;\n\t} else {\n\t    if (t.size() % 2 == 0) t.push_back(0);\n\t    sort(t.begin(), t.end());\n\t    st.clear();\n\t    int pos = 0;\n\t    dp[v] = -1;\n\t    for (int j=t.size()-1; j>=0; j--) {\n\t\tint c = t[j];\n\t\tif (c == -1) break;\n\t\twhile (pos < j && t[pos] + c <= mid) {\n\t\t    st.push_back(t[pos]);\n\t\t    t[pos] = -1;\n\t\t    pos++;\n\t\t}\n\t\tif (st.empty()) {\n\t\t    if (dp[v] == -1) dp[v] = c;\n\t\t    else return false;\n\t\t} else {\n\t\t    st.pop_back();\n\t\t}\n\t    }\n\n\t    if (dp[v] == -1) {\n\t\tdp[v] = st[0];\n\t    }\n\t}\n    }\n\n    assert(false);\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += ((int)G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstatic_assert(sizeof(long) >= 8, \"long too short\");\n\nvector<int> adj[100000];\nvector<int> data1[100000];\n\nint solvea(int n) {\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n        ans += adj[i].size() % 2;\n    return ans / 2;\n}\n\nint dfs(int u, int p, int b) {\n    auto &v = data1[u];\n    v.clear();\n    v.reserve(adj[u].size() + 1);\n\n    for (int c : adj[u]) {\n        if (c != p) {\n            v.push_back(dfs(c, u, b));\n        }\n    }\n    if (adj[u].size() % 2 == 1)\n        v.push_back(1);\n    sort(v.begin(), v.end());\n\n    if (p < 0) {\n        int ans = 0;\n        for (int i = 0, j = v.size() - 1; i < j; i++, j--)\n            ans = max(ans, v[i] + v[j] - 1);\n        return ans;\n    } else {\n        int l = 0, r = v.size();\n        while (l < r) {\n            int k = (l + r) / 2;\n            bool ok = true;\n            for (int i = 0, j = v.size() - 1; i < j;\n                    i++, j--, i == k && i++, j == k && j--)\n                if (v[i] + v[j] - 1 > b) {\n                    ok = false;\n                    break;\n                }\n            if (ok)\n                r = k;\n            else\n                l = k + 1;\n        }\n        if (r < (int) v.size())\n            return v[r] + 1;\n        return b + 1;\n    }\n}\n\nbool checkb(int b) {\n    return dfs(0, -1, b) <= b;\n}\n\nint solveb(int n) {\n    int l = 2, r = n;\n    while (l < r) {\n        int m = (l + r) / 2;\n        if (checkb(m))\n            r = m;\n        else\n            l = m + 1;\n    }\n    return r - 1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--, b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int a = solvea(n);\n    int b = solveb(n);\n    printf(\"%d %d\\n\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\tbool flag = false;\n\tc = -1;\n\tif(table.size() % 2 == 0)flag = true;\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0 && !flag){\n\t\t\tflag = true;\n\t\t\tc = a;\n\t\t}else if(de < 0){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}else{\n\t\t\ttable.erase(table.begin() + de);\n\t\t}\n\t}\n\tif(c != -1){\n\t\ttable.pb(c);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn -100;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = -1;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame || ans != -100){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MN 100005\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct st{\n\tint to,nxt;\n}e[MN<<1];\nint head[MN],a[MN],st[MN],f[MN],ind[MN],fa[MN];\nint cnt=0,num=0,top,n,x,y,rt,ans;\nbool mk;\ninline void ins(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;\n}\ninline bool chk(int u,int x,int tp){\n\tint hd=1,tl=tp;\n\tif (u==hd) ++hd;if (u==tl) --tl;\n\twhile (hd<tl){\n\t\tif (st[hd]+st[tl]>x) return 0;++hd;--tl;\n\t\tif (u==hd) ++hd;if (u==tl) --tl;\n\t}return 1;\n}\ninline void dfs(int u,int x){\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v!=fa[u]) fa[v]=u,dfs(v,x);\n\t}top=0;\n\tfor (int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v!=fa[u]) st[++top]=f[v];\n\t}if (!top) {f[u]=1;return;}\n\tif (!(top&1)) st[++top]=0;\n\tsort(st+1,st+top+1);int l=1,r=top,res=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (chk(mid,x,top)) res=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}if (res==-1&&!chk(r,x,top)) mk=0;f[u]=st[res]+1;\t\n}\ninline bool check(int x){\n\tmk=1;fa[rt]=0;dfs(rt,x);\n\treturn (mk&&(f[rt]<=x+1));\t\n}\nint main()\n{\n\tn=in();\n\tfor (int i=1;i<n;++i){\n\t\tx=in();y=in();ins(x,y);ins(y,x);\n\t\t++ind[x];++ind[y];\n\t}\n\tfor (int i=1;i<=n;++i) if (ind[i]&1) rt=i,++num;\n\tprintf(\"%d \",num>>1);\n\tint l=1,r=n;while (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid)) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}printf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=100005;\nvi v[N];\nint root=-1,dp[N],n;\nvoid dfs(int u,int val,int par=-1)\n{\n  dp[u]=0;\n  vi tmp;\n  for(int v1:v[u])\n    {\n      if(v1==par) continue;\n      dfs(v1,val,u);\n      tmp.pb(v1);\n    }\n  if(sz(tmp)%2==0) tmp.pb(0);\n  sort(all(tmp),[](int i,int j){return dp[i]<dp[j];});\n  int low=0,high=sz(tmp)-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      int i=0,j=sz(tmp)-1;\n      bool ok=true;\n      while(i<j)\n\t{\n\t  if(i==mid) i++;\n\t  else if(j==mid) j--;\n\t  else if(dp[tmp[i]]+dp[tmp[j]]>val) { ok=false; break; }\n\t  else i++,j--;\n\t}\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  int i=0,j=sz(tmp)-1;\n  bool ok=true;\n  while(i<j)\n    {\n      if(i==low) i++;\n      else if(j==low) j--;\n      else if(dp[tmp[i]]+dp[tmp[j]]>val) { ok=false; break; }\n      else i++,j--;\n    }\n  if(!ok) dp[u]=val+100;\n  dp[u]=dp[tmp[low]]+1;\n}\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  int x,y;\n  cin>>n;\n  rep(i,1,n) cin>>x>>y,v[x].pb(y),v[y].pb(x);\n  rep(i,1,n+1) if(sz(v[i])==1) root=i;\n  assert(root!=-1);\n  root=1;\n  int cnt=0;\n  rep(i,1,n+1) cnt+=(sz(v[i])&1);\n  int low=0,high=n-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      dfs(root,mid);\n      bool ok=true;\n      rep(i,1,n+1) ok&=(dp[i]<=mid+1);\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  cout<<cnt/2<<\" \"<<low<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=1e5,INF=1e8;\nbool ans;\nint B,dp[MAX_N],N;\nvector<int> G[MAX_N];\nvoid dfs(int v,int p){\n\tvector<int> vec;\n\tint n=0;\n\tfor(auto e:G[v]){\n\t\tif (e!=p){\n\t\t\tdfs(e,v);\n\t\t\tvec.push_back(dp[e]);\n\t\t\tn++;\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tdp[v]=INF;\n\tif (n%2==0){\n\t\tbool f=true;\n\t\tREP(i,n/2){\n\t\t\tif (vec[i]+vec[n-i-1]+2>B){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif (f){\n\t\t\tdp[v]=0;\n\t\t}\n\t\tif (n==0){\n\t\t\treturn ;\n\t\t}\n\t}\n\tif (p!=-1 || n%2){\n\t\tif (n%2==0){\n\t\t\tif (vec[n-1]+1>B){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t\tif (vec[n-1]+1>B){\n\t\t\treturn;\n\t\t}\n\t\tint lb=-1,ub=n;\n\t\twhile(ub-lb>1){\n\t\t\tint mid=(lb+ub)/2;\n\t\t\tint le=0,ri=n-1;\n\t\t\tbool f=true;\n\t\t\tREP(i,n/2){\n\t\t\t\tif (le==mid){\n\t\t\t\t\tle++;\n\t\t\t\t}\n\t\t\t\tif (ri==mid){\n\t\t\t\t\tri--;\n\t\t\t\t}\n\t\t\t\tif (vec[le]+vec[ri]+2>B){\n\t\t\t\t\tf=false;\n\t\t\t\t}\n\t\t\t\tle++;\n\t\t\t\tri--;\n\t\t\t}\n\t\t\tif (f){\n\t\t\t\tub=mid;\n\t\t\t}else{\n\t\t\t\tlb=mid;\n\t\t\t}\n\t\t}\n\t\tif (ub!=n){\n\t\t\tdp[v]=min(dp[v],vec[ub]+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>N;\n\tREP(i,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint A=0;\n\tREP(i,N){\n\t\tif (G[i].size()%2){\n\t\t\tA++;\n\t\t}\n\t}\n\tA/=2;\n\tint lb=0,ub=N-1;\n\twhile(ub-lb>1){\n\t\tint mid=(lb+ub)/2;\n\t\tB=mid;\n\t\tans=true;\n\t\tdfs(0,-1);\n\t\tREP(i,N){\n\t\t\tif (dp[i]==INF){\n\t\t\t\tans=false;\n\t\t\t}\n\t\t}\n\t\tif (ans){\n\t\t\tub=mid;\n\t\t}else{\n\t\t\tlb=mid;\n\t\t}\n\t}\n\tcout<<A<<\" \"<<ub<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi g;\nvi dp;\n\nbool ff(vi& a,int I,int L){\n\tint N=a.size();\n\tbool B=1;\n\tfor(int i=0;i<N/2;i++) if(a[(i<I?i:i+1)]+a[(N-i-1>I?N-i-1:N-i-2)]>L) B=0;\n\treturn B;\n}\n\nbool f(int v,int p,int L){\n\tbool B=1;\n\tvi a;\n\tfor(auto u:g[v]) if(u!=p){\n\t\tB&=f(u,v,L)&&dp[u]!=L;\n\t\ta.push_back(dp[u]+1);\n\t}\n\tif(!B) return 0;\n\tsort(a.begin(),a.end());\n\tint N=a.size();\n\tif(N%2==0){\n\t\tfor(int i=0;i<N/2;i++) if(dp[i]+dp[N-i-1]>L) return 0;\n\t}\n\telse{\n\t\tint l=-1,r=N;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(ff(a,m,L)) r=m;\n\t\t\telse l=m;\n\t\t}\n\t\tif(r==N) return 0;\n\t\tdp[v]=a[r];\n\t}\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint A=0,v,l=0,r=n-1;\n\tfor(int i=0;i<n;i++){\n\t\tint S=g[i].size();\n\t\tA+=S%2;\n\t\tif(S==1) v=i;\n\t}\n\tA/=2;\n\twhile(r-l>1){\n\t\tdp=vi(n);\n\t\tint m=(l+r)/2;\n\t\tif(f(v,-1,m)) r=m;\n\t\telse l=m;\n\t}\n\tdp=vi(n); \n\tcout<<A<<' '<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <climits>\n#include <bitset>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0;\n    char ch = Advance();\n    while (!isdigit(ch))\n        ch = Advance();\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer;\n}\n\nconst int MAXN = 100000;\n\nvector<int> g[1 + MAXN];\nint limit, splits[1 + MAXN];\n\nint DFS(int node, int father) {\n    multiset<int> sons;\n    for (auto &son : g[node])\n        if (son != father) {\n            sons.insert(DFS(son, node));\n            if (sons.find(-1) != sons.end())\n                return -1;\n        }\n    if (sons.empty())\n        return 1;\n    if (sons.size() == 1)\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    int n = sons.size();\n    if (sons.size() % 2) {\n        for (int i = 1; 2 * i <= n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n    else {\n        for (int i = 1; 2 * i < n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() + *sons.rbegin() + 1 <= limit)\n            return 1;\n        if (node == 1)\n            return -1;\n        if (*sons.begin() < limit && *sons.rbegin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n}\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int first = 1, left = 2, right = n, second = n;\n    for (int i = 3; i <= n; i++)\n        splits[i] = splits[i / 2] + splits[i - i / 2] + 1;\n    for (int i = 1; i <= n; i++)\n        first += splits[g[i].size()];\n    while (left <= right) {\n        limit = (left + right) / 2;\n        if (DFS(1, 0) != -1) {\n            second = limit;\n            right = limit - 1;\n        }\n        else\n            left = limit + 1;\n    }\n    second--;\n    printf(\"%d %d\\n\", first, second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint n; \nconst int INF = int(1e9);\nconst int N = 123456;\nii dp[N];\nvi adj[N];\n\nint threshold;\n\nvoid dfs(int u, int p=-1)\n{\n\tint sum = 0;\n\tdeque<int> V;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\tsum+=dp[v].fi;\n\t\tV.pb(dp[v].se);\n\t}\n\tsort(V.begin(),V.end());\n\twhile(!V.empty()&&V.back()>=INF)\n\t{\n\t\tV.pop_back(); V.push_front(0); sum++;\n\t}\n\tint mnup=INF;\n\twhile(!V.empty())\n\t{\n\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t{\n\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t}\n\t\tif(V.back()+1<=threshold)\n\t\t{\n\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t}\n\t\tmnup=min(mnup,1); \n\t\tif(V.back()!=0) sum++;\n\t\tV.pop_back();\n\t}\n\tdp[u] = mp(sum,mnup);\n\t//cerr<<threshold<<\" | \"<<u<<' '<<sum<<' '<<mnup<<'\\n';\n}\n\nint calc(int C)\n{\n\tthreshold=C;\n\tdfs(0,-1); \n\treturn dp[0].fi;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tint bestres = calc(n+1);\n\tint lo=1; int hi=n;\n\tint ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint v=calc(mid);\n\t\tif(v<=bestres)\n\t\t{\n\t\t\tans=mid; hi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tcout<<bestres<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\n\ninline bool cmp(int a,int b){return F[a]<F[b];}\n\ninline bool dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tif(!dfs(vs[i].v,rt,x)) return false;\n\t\tv.push_back(vs[i].v);\n\t}\n\tif(v.size()==0){\n\t\tF[rt]=1;\n\t\treturn true;\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end(),cmp);\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tint tmp1=F[v[i]],tmp2=F[v[j]];\n\t\t\tfg&=(tmp1+tmp2)<=x;\n\t\t}\n\t\tif(fg) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l==v.size()) return false;\n\tF[rt]=F[l]+1;\n\treturn F[rt]<=x+1;\n}\ninline bool check(int x)\n{\n\treturn dfs(Rt,0,x);\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin>>n;\n  vvi G(n);\n  FOR(i,n-1) {\n    int a,b; cin>>a>>b;\n    --a; --b;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  { int a = 0;\n    FOR(i,n) if(G[i].size()&1) a += 1;\n    cout << a/2 << ' ';\n  }\n\n  auto ok = [&](int b) -> bool {\n    function<int(int, int)> dfs = [&](int i, int p) -> int {\n      deque<int> rs;\n      for(int j : G[i]) if(j != p) {\n          int r = dfs(j,i);\n          if(r>b) throw 0;\n          rs.pb(r);\n      }\n      sort(all(rs));\n      if(p == -1) {\n        if(rs.size()&1) {\n          rs.pop_back();\n        }\n        FOR(i,rs.size()) if(rs[i]+rs[rs.size()-1-i] > b) throw 0;\n        return 0;\n      }else{\n        if((rs.size()&1) == 0) rs.pb(0);\n        int r0 = rs.front(); rs.pop_front();\n        while(!rs.empty()) {\n          if(rs.front()+rs.back() > b) {\n            if(r0+rs.back() > b) throw 0;\n            r0 = rs.front(); rs.pop_front(); rs.pop_back();\n          }else{\n            rs.pop_front();\n            rs.pop_back();\n          }\n        }\n        return r0+1;\n      }\n    };\n    try {\n      int i=0;\n      while((G[i].size()&1) == 0) i++;\n      dfs(i,-1);\n      return 1;\n    } catch(int){\n      return 0;\n    }\n  };\n\n  int lo = 1, hi = n;\n  while(lo != hi) {\n    int mi = (lo+hi)/2;\n    if(ok(mi)) { hi = mi; }\n    else { lo = mi+1; }\n  }\n  cout << lo << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\nint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\treturn F?n:-n;\n\t}\nlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\nint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n#include<cassert>\n#include<set>\nstruct kk\n{\n\tint v;\n}\n;\nbool operator <(const kk &x,const kk &y)\n{\nreturn x.v>y.v;\n}\nbool cmp(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nstd::multiset<kk> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int mid)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,mid)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\nstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>mid)return 0;\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\ts.clear();\n\t\tif(deg[o]&1)++cnt,s.insert((kk){0});\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)++cnt,s.insert((kk){f[e[p].to]+1});\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tkk val=*s.begin();\n\t\t\ts.erase(s.find(val));\n\t\t\tif(s.rbegin()->v+val.v>mid)return 0;\n\t\t\tkk tmp=(kk){mid-val.v};\n\t\t\tstd::multiset<kk>::iterator pl=s.lower_bound(tmp);\n\t\t\ts.erase(pl);\n\t\t\tcnt-=2;\n\t\t}\n\t\tassert(s.size()==1);\n\t\tf[o]=s.begin()->v;\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,1,mid);\n}\nint main()\n{int n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(3);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O+1)?stk[r]+1:(-1);\n\t}\n\telse{\n\t\tif (x==1){\n\t\t\tf[x]=0;\n\t\t\tFOR(i,1,top/2)\n\t\t\t\tif (stk[i]+stk[top-i+1]>O) f[x]=-1;\n\t\t\treturn;\n\t\t}\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O+1)?stk[r]+1:(-1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=1,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (f[1]>O+1 || f[1]==-1) ok=0;\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\n// (個数, 最大値, 伸びてるやつ)\ntri dp[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    vp hoge;\n    each(v, G[u]){\n        if(v != p){\n            dfs(v, u);\n            hoge.pb(P(dp[v].th, v));\n        }\n    }\n    sort(all(hoge));\n    int cnt = len(hoge), mx = 0, res = 0;\n    if(cnt == 1){\n        dp[u] = dp[hoge[0].se];\n        dp[u].th++;\n    }else if(cnt >= 2){\n        if(cnt % 2){\n            // 上げる\n            rep(i,cnt/2){\n                res += dp[hoge[i].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n            }\n            res += dp[hoge[cnt/2].se].fi;\n            cmx(mx, dp[hoge[cnt/2].se].se);\n            dp[u] = (tri){res, mx, hoge[cnt/2].fi+1};\n        }else{\n            srep(i,1,cnt/2){\n                res += dp[hoge[i].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n            }\n            // 最初\n            res += dp[hoge[0].se].fi;\n            cmx(mx, dp[hoge[0].se].se);\n            // 最後\n            res += dp[hoge[cnt-1].se].fi+1;\n            cmx(mx, max(dp[hoge[cnt-1].se].se, dp[hoge[cnt-1].se].th+1));\n            dp[u] = (tri){res, mx, hoge[0].fi+1};\n        }\n    }\n    // ashow(u, dp[u]);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        --a, --b;\n        G[a].pb(b), G[b].pb(a);\n    }\n    dfs(0, -1);\n    cout << dp[0].fi+1 << \" \" << max(dp[0].se, dp[0].th) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[100000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\tif (edge[v].size() == 1) {\n\t\treturn 0;\n\t}\n\tif (edge[v].size() == 2) {\n\t\tfor (auto& e : edge[v]) {\n\t\t\tif (e != parent) { return 1 + func(e, v); }\n\t\t}\n\t}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (*L.begin() > len_max) {\n\t\tfunc_ok = false;\n\t\treturn 0;\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\treturn *L.rbegin();\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nvector<int> graph[N];\nint root;\nint A, t;\nint beginning;\n\nint find_value(vector<int> &dp, int M)\n{\n    int L = -1, R = dp.size();\n    while (L + 1 < R)\n    {\n        int mid = (L + R) / 2;\n        int j = dp.size() - 1;\n        int t = 1;\n        for (int i = 0; i < j; )\n        {\n            if (i == mid) i++;\n            if (j == mid) j--;\n            if (dp[i] + dp[j] > M) t = 0;\n            i++, j--;\n        }\n        if (t) R = mid;\n        else L = mid;\n    }\n    return dp[R];\n}\n\nint dfs(int v, int p, int M)\n{\n    vector<int> dp;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dp.push_back(dfs(u, v, M));\n    }\n    if (dp.size() % 2 == 0) dp.push_back(0), beginning++;\n    sort(all(dp));\n    int x = find_value(dp, M) + 1;\n    if (x == M) x = 1, beginning++;\n    return x;\n}\n\nint check(int M)\n{\n    t = 0;\n    beginning = 0;\n    int cat = dfs(root, root, M);\n    if (cat == 1) beginning--;\n    if ((beginning + 1) / 2 <= A) return 1;\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    int cnt_odd = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (graph[i].size() == 1) root = i;\n        cnt_odd += (graph[i].size() % 2);\n    }\n    cout << (cnt_odd + 1) / 2 << \" \";\n    A = (cnt_odd + 1) / 2;\n    int L = 0, R = n;\n    while (L + 1 < R)\n    {\n        int M = (L + R) / 2;\n        if (check(M)) R = M;\n        else L = M;\n    }\n    cout << R;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    s.clear();\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl){\n                return 0;\n            }\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    if(x==1)\n        flag--;\n    /*if(x==83)\n        for(int i=0;i<a[x].size();i++)\n            if(a[x][i]!=fa)\n                PF(\"{%d} \",dp[a[x][i]]+1);*/\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==1){\n                dp[x]=t;\n                flag=-1;\n            }\n            else\n                flag=1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl){\n            return 0;\n        }\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    //PF(\"[%d]\",check(6));\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vals.size(); i++) {\n\t\t\tll rv = vals.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vals[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vals[i] + vals[rv] - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (maxS <= l) return 1ll;\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 2) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfl2 = fl;\n\t\n\tfl = true;\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint ret=1,isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tsort(v.begin(),v.end());\n\tint l=0,r=SZ(v)-1;\n\twhile(l<r){\n\t\tif(v[l]+v[r]+1<=B) l++;\n\t\tr--,res++;\n\t}\n\tif(l==r){\n\t\tif(v[l]+1==B){res++;return 1;}\n\t\treturn v[l]+1;\n\t}\n\treturn 1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"04.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, mid;\nvi adj[MX];\nbool ok;\n\nbool OK(vi v, int ind) {\n    if (v[ind]+1 > mid) return 0;\n    v.erase(v.begin()+ind);\n    for (int i = 0; i < sz(v)-1-i; ++i) if (v[i]+v[sz(v)-1-i] > mid) return 0;\n    return 1;\n}\n\nint test(int cur, int pre) {\n    if (!ok) return 0;\n    vi v; for (int i: adj[cur]) if (i != pre) v.pb(test(i,cur));\n    if (!ok) return 0;\n    \n    if (cur == 1) {\n        if (sz(v) % 2 == 1) v.pb(0);\n        sort(all(v));\n        for (int i = 0; i < sz(v)-1-i; ++i) if (v[i]+v[sz(v)-1-i] > mid) ok = 0;\n        return 0;\n    } else {\n        if (sz(v) % 2 == 0) v.pb(0);\n        sort(all(v));\n        int lo = 0, hi = sz(v);\n        while (lo < hi) {\n            int mid = (lo+hi)/2;\n            if (OK(v,mid)) hi = mid;\n            else lo = mid+1;\n        }\n        // cout << \"ZZ \" << cur << \" \" << lo << \" \" << sz(v) << \" \" << v[0] << \"\\n\";\n        if (lo == sz(v)) {\n            ok = 0;\n            return 0;\n        }\n        // cout << \"HAHA \" << ok << \" \" << cur << \" \" << v[lo] << \"\\n\";\n        return v[lo]+1;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        // int a = i+1,b = i+2; \n        int a,b; cin >> a >> b;\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    // cout << ok << \"\\n\";\n    int A = 0; FOR(i,1,N+1) if (sz(adj[i])&1) A++;\n    int lo = 1, hi = N-1; \n    while (lo < hi) {\n        mid = (lo+hi)/2;\n        ok = 1; test(1,0);\n        if (ok) hi = mid;\n        else lo = mid+1;\n    }\n    cout << A/2 << \" \" << lo;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e5+50;\n\nint n,f[N],A,B,fail;\nvector<int> g[N]; \n\nvoid dfs(int v,int p){\n\tint x=p>0;\n\tf[v]=p>0;\n\tfor(int d:g[v])if(d!=p){\n\t\t++x; dfs(d,v); f[v]+=f[d];\n\t}\n\tf[v]-=x/2;\n\t//printf(\"dfs %d,%d,f=%d\\n\",v,p,f[v]); \n}\n\nint G[N];\nvoid dp2(int v,int p){\n\tvector<int> a; if(p>0)a.pb(1);\n\tfor(int d:g[v])if(d!=p){dp2(d,v);a.pb(G[d]);}\n\tsort(all(a));if(a.size()&1)a.pop_back();\n\tif(a.empty()){G[v]=1;return;}\n\tint m=a.size();\n\tlop(i,0,m)if(a[i]+a[m-1-i]>B)fail=1;\n\tint L=0,R=m-1;\n\twhile(R-L>1){\n\t\tint mid=(L+R)>>1,Fail=0;\n\t\tvector<int> b;lop(i,0,m)if(i>0&&i!=mid)b.pb(a[i]);\n\t\tlop(i,0,b.size())if(b[i]+b[b.size()-1-i]>B)Fail=1;\n\t\tif(!Fail)R=mid;else L=mid;\n\t}\n\tG[v]=a[R]+1;//Pr(\"v=%d,g=%d\\n\",v,G[v]);\n}\n\nbool chk(int x){\n\tB=x,fail=0;\n\t//Pr(\"Chk %d\\n\",x); \n\tdp2(1,0);\n\treturn !fail;\n}\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\trep(i,1,n-1){\n\t\tint u,v;\n\t\tread(u),read(v); \n\t\tg[u].pb(v),g[v].pb(u); \n\t}\n\tdfs(1,0);\n\tA=f[1];\n\tint l=0,r=n-1;\n\twhile(r-l>1){\n\t\tint mid=(l+r)>>1;\n\t\tif(chk(mid))r=mid;else l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(!(v.size()&1)) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[100009], b[100009], sum, G, dp[100009]; vector<int>x[100009]; bool used[100009], flag = false;\n\nint solve(vector<int>F) {\n\tint res = 0;\n\tfor (int i = 0; i < F.size(); i++) res = max(res, F[i] + F[F.size() - 1 - i]);\n\treturn res;\n}\n\nint dfs(int pos) {\n\tif (flag == true) return (1 << 30);\n\tused[pos] = true;\n\tvector<int>I;\n\tfor (int i = 0; i < x[pos].size(); i++) {\n\t\tif (used[x[pos][i]] == true) continue;\n\t\tI.push_back(dfs(x[pos][i]) + 1);\n\t\tif (flag == true) return (1 << 30);\n\t}\n\tif (I.size() == 0) {\n\t\tdp[pos] = 0;\n\t\treturn 0;\n\t}\n\tsort(I.begin(), I.end());\n\tif (I[I.size() - 1] > G) {\n\t\tflag = true;\n\t\treturn (1 << 30);\n\t}\n\tif (x[pos].size() % 2 == 1) I.pop_back();\n\tif (I.size() % 2 == 0) {\n\t\tif (solve(I) > G) {\n\t\t\tflag = true;\n\t\t\treturn (1 << 30);\n\t\t}\n\t\telse {\n\t\t\tdp[pos] = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tint L = 0, R = I.size(), M, maxn = (1 << 30);\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tvector<int>J; for (int j = 0; j < I.size(); j++) { if (j != M) J.push_back(I[j]); }\n\t\t\tint ret = solve(J);\n\t\t\tif (ret <= G) { R = M; maxn = min(maxn, M); }\n\t\t\telse { L = M; }\n\t\t}\n\t\tif (maxn == (1 << 30)) {\n\t\t\tflag = true;\n\t\t\treturn (1 << 30);\n\t\t}\n\t\tdp[pos] = I[maxn];\n\t\treturn I[maxn];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) { if (x[i].size() % 2 == 1) sum++; }\n\tint L = 1, R = n + 1, M, minx = (1 << 30);\n\tfor (int i = 0; i < 20; i++) {\n\t\tM = (L + R) / 2; G = M;\n\t\tfor (int j = 1; j <= n; j++) used[j] = false; flag = false;\n\t\tint F = dfs(1);\n\t\tif (F <= M) { R = M; minx = M; }\n\t\telse { L = M; }\n\t}\n\tcout << sum / 2 << \" \" << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\n\nvector<int> T[MX];\nint N, m, val = 1;\n\nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( !val || X.empty() ) return 0;\n\tif( X.back() > m ) return val = 0;\n\n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n\t\tif( p == -1 ) return val = 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tint op = X.size()/2 < i ? X.size()-i-1 : X.size()-i;\n\t\tif( X[i] + X[op] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n\nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        assert(tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tll child = 0;\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\ttable.pb(solve(G[node][i],node,length));\n\t\tchild ++;\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\tnum = i;\n\t\t\ta++;\n\t\t}\n\t}\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = INF;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,0,mid);\n\t\t//p(dame);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\twhile (nt && extra.size()) {\n\t\textra.pop_back();\n\t\tnt--;\n\t}\n\tif(nt)ans = 1e9;\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\tif(all != ans1)return false;\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tmd = 1e9;\n\tans1 = (dfs(1,-1)>0)+all;\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nint dfs(const vector<vector<int> >& edges, int curr, int prev, int limit)\n{\n    multiset<int> ms;\n    for(int next : edges[curr]){\n        if(next == prev)\n            continue;\n        int x = dfs(edges, next, curr, limit);\n        if(x == -1)\n            return -1;\n        ms.insert(x);\n    }\n\n    vector<int> v;\n    while(!ms.empty()){\n        int x = *ms.rbegin();\n        ms.erase(--ms.end());\n\n        auto it = ms.upper_bound(limit - 1 - x);\n        if(it == ms.begin()){\n            v.push_back(x);\n        }\n        else{\n            -- it;\n            ms.erase(it);\n        }\n    }\n\n    if(!v.empty() && limit < v[0] + 1)\n        return -1;\n\n    if(v.empty())\n        return 1;\n    else if(v.size() == 1)\n        return v[0] + 1;\n    else if(v.size() == 2 && prev != -1)\n        return v[1] + 1;\n    else\n        return -1;\n}\n\npair<int, int> solve(const vector<vector<int> >& edges)\n{\n    int n = edges.size();\n    int ans = 1;\n    for(int i=0; i<n; ++i)\n        ans += (edges[i].size() - 1) / 2;\n\n    int left = 1;\n    int right = n;\n    while(left < right){\n        int mid = (left + right) / 2;\n        if(dfs(edges, 0, -1, mid) != -1)\n            right = mid;\n        else\n            left = mid + 1;\n    }\n\n    return make_pair(ans, left - 1);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > edges(n);\n    for(int i=0; i<n-1; ++i){\n        int a, b;\n        cin >> a >> b;\n        -- a;\n        -- b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    pair<int, int> ans = solve(edges);\n    cout << ans.first << ' ' << ans.second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\nconst int MAXN = 1e5 + 10;\n\nint n;\nvi g[MAXN];\n\nbool read() {\n\tif  (scanf(\"%d\", &n) < 1) {\n\t\treturn 0;\n\t}\n\tforn(i, n) {\n\t\tg[i].clear();\n\t}\n\tforn(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn 1;\n}\n\nconst int INF = 1e9;\n\npii dp[MAXN];\n\nbool can_part(const vi& lens, int B) {\n\tassert(is_sorted(all(lens)));\n\tassert(sz(lens) % 2 == 0);\n\n\tvi left;\n\tvi right;\n\tforn(i, sz(lens)) {\n\t\tif  (i < sz(lens) / 2) {\n\t\t\tleft.pb(lens[i]);\n\t\t} else {\n\t\t\tright.pb(lens[i]);\n\t\t}\n\t}\n\n\tassert(sz(left) == sz(right));\n\n\tint l1 = 0;\n\tint r1 = sz(left) - 1;\n\tint l2 = 0;\n\tint r2 = sz(right) - 1;\n\twhile (l1 <= r1) {\n\t\tassert(r1 - l1 == r2 - l2);\n\n\t\tint ptr = l1;\n\t\twhile (ptr + 1 <= r1 && left[ptr + 1] + right[r2] <= B) {\n\t\t\t++ptr;\n\t\t}\n\n\t\tif  (left[ptr] + right[r2] > B) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tl1 = ptr + 1;\n\t\tr2 = l2 + (r1 - l1 + 1) - 1;\n\t}\n\n\treturn 1;\n}\n\nvoid dfs(int v, int p, int B) {\n\tauto get_best_pos = [&](const vi& lens) -> int {\n\t\tint L = -1;\n\t\tint R = sz(lens);\n\t\tint best_pos = -1;\n\t\twhile (L != R - 1) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tvi nlens;\n\t\t\tforn(i, sz(lens)) {\n\t\t\t\tif  (i != M) {\n\t\t\t\t\tnlens.pb(lens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif  (can_part(nlens, B)) {\n\t\t\t\tbest_pos = M;\n\t\t\t\tR = M;\n\t\t\t} else {\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\treturn best_pos;\n\t};\n\n\tint paths = 0;\n\tvi lens;\n\tfor (int to : g[v]) {\n\t\tif  (to == p) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(to, v, B);\n\t\t\n\t\t// eprintf(\"to=%d, dp=(%d, %d)\\n\", to, dp[to].fst, dp[to].snd);\n\n\t\tint cur_paths, cur_len;\n\t\ttie(cur_paths, cur_len) = dp[to];\n\t\tif  (cur_len > B) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\t\n\n\t\tpaths += cur_paths;\n\t\tlens.pb(cur_len);\n\t}\n\n\tpaths -= sz(lens);\n\tsort(all(lens));\n\n\t// eprintf(\"v=%d, lens:\\n\", v);\n\t// for (int len : lens) {\n\t// \teprintf(\"%d \", len);\n\t// }\n\t// eprintf(\"\\n\");\n\n\tif  (sz(lens) % 2 == 0) {\n\t\tif  (p == -1) {\n\t\t\tif  (!can_part(lens, B)) {\n\t\t\t\tdp[v] = mp(INF, INF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdp[v] = mp(paths + sz(lens) / 2, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tif  (can_part(lens, B)) {\n\t\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, 1);\n\t\t\treturn;\t\t\t\n\t\t}\n\n\t\tvi nlens;\n\t\tforn(i, sz(lens) - 1) {\n\t\t\tnlens.pb(lens[i]);\n\t\t}\n\t\tint best_pos = get_best_pos(nlens);\n\t\tif  (best_pos == -1) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\n\n\t\tdp[v] = mp(paths + (sz(lens) - 2) / 2 + 2, nlens[best_pos] + 1);\n\t\treturn;\n\t}\n\n\t{\n\t\tint best_pos = get_best_pos(lens);\n\t\t// eprintf(\"v=%d, best_pos=%d\\n\", v, best_pos);\n\t\tif  (best_pos == -1) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\n\n\t\tif  (p == -1) {\n\t\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, lens[best_pos] + 1);\n\t\treturn;\n\t}\n\n\tassert(0);\n}\n\nbool can(int B, int& A) {\n\tdfs(0, -1, B);\n\tif  (dp[0].snd > B) {\n\t\treturn 0;\n\t}\n\tA = dp[0].fst;\n\treturn 1;\n}\n\npii solve() {\n\t// {\n\t// \tint A;\n\t// \tcan(2, A);\n\t// \treturn mp(0, 0);\n\t// }\n\n\tint L = 0;\n\tint R = n + 1;\n\twhile (L != R - 1) {\n\t\tint M = (L + R) / 2;\n\t\tint A;\n\t\tif  (can(M, A)) {\n\t\t\tR = M;\n\t\t} else {\n\t\t\tL = M;\n\t\t}\n\t}\n\tint A;\n\tassert(can(R, A));\n\treturn mp(A, R);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tint A, B;\n\t\ttie(A, B) = solve();\n\t\tprintf(\"%d %d\\n\", A, B);\n\t}\n\n#ifdef LOCAL\n\teprintf(\"Time: %.10f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tll child = 0;\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\ttable.pb(solve(G[node][i],node,length));\n\t\tchild ++;\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\tnum = i;\n\t\t\ta++;\n\t\t}\n\t}\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,0,mid);\n\t\t//p(dame);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nint n = 0;\nvector<int> edges[101010];\nbool visited[101010];\n\nint dfs(int v, int b, bool r = false) {\n    if (!r) {\n        fill(visited, visited + 101010, false);\n    }\n\n    visited[v] = true;\n    vector<int> lengths;\n\n    for (auto c : edges[v]) {\n        if (!visited[c]) {\n            int k = dfs(c, b, true);\n            if (!k || b < k) return 0;\n            lengths.push_back(k);\n        }\n    }\n\n    bool odd = (edges[v].size() % 2 == 1);\n    int hold = 0;\n    sort(lengths.begin(), lengths.end());\n    while (1 < lengths.size()) {\n        int k = lengths.back();\n        lengths.pop_back();\n        auto i = upper_bound(lengths.begin(), lengths.end(), b - k);\n        if (i == lengths.begin()) {\n            if ((r || odd) && !hold) {\n                hold = k;\n            } else {\n                return 0;\n            }\n        } else {\n            lengths.erase(i - 1);\n        }\n    }\n\n    if (r && !odd && hold) {\n        lengths.push_back(hold);\n    }\n\n    if (lengths.size()) {\n        return (lengths[0] < b) ? lengths[0] + 1 : 0;\n    } else {\n        return 1;\n    }\n}\n\n\ntuple<int, int> solve() {\n    int root = -1;\n    int a = 1;\n\n    rep(i, 0, n) {\n        size_t c = edges[i].size();\n        if (3 <= c) {\n            a += (c - 1) / 2;\n            root = i;\n        }\n    }\n\n    if (root < 0) {\n        return make_tuple(1, n - 1);\n    }\n\n    int ok = n - 1;\n    int ng = 1;\n\n    while (ng + 1 < ok) {\n        int mid = (ok + ng) / 2;\n        if (dfs(root, mid)) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n\n    return make_tuple(a, ok);\n}\n\nint main(int argc, const char * argv[]) {\n    int a, b;\n    \n    cin >> n;\n    rep(i, 0, n - 1) {\n        cin >> a >> b;\n        --a;\n        --b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    auto p = solve();\n\n    cout << get<0>(p) << ' ' << get<1>(p) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,x,y,ans,l,r,mid,tot,rt,f[N],a[N],g[N],head[N],d[N];\nstruct edge{int v,nxt;}e[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool dp(int u,int fa){\n    f[u]=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) if (!dp(v,u)) return 0;\n    //printf(\"+++++++%d+++++++\\n\",u);\n    //for (int i=head[u],v;i;i=e[i].nxt)\n        //if ((v=e[i].v)!=fa) printf(\"%d\\n\",f[v]);\n    int xb=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) a[++xb]=f[v]+1;\n    if ((xb&1)==0) a[++xb]=0;\n    sort(a+1,a+xb+1);//for (int i=1;i<=xb;i++) cout<<a[i]<<endl;\n    memset(g,-1,sizeof(int)*(xb+2));\n    int j,k; j=1;\n    for (int i=xb;i>=1;i--){\n        g[i]=g[i+1];//if (j>=i) g[i]=i-1;\n        for (;j<i && a[j]+a[i]<=mid;j++) g[i]=j;\n        j--;\n    }\n    j=0,k=0;\n    for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+1){k=i; break;}//cout<<\"orz\"<<k<<endl;\n    if (k==0){\n        j=1; for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+2) j=xb-i+2;\n        f[u]=a[j];\n    }\n    else{\n        j=0; for (int i=xb;i>j+1;i--) if (k!=i){j++; if (a[i]+a[j]>mid) return 0;}\n        f[u]=a[k];\n    }\n    if (u==rt && f[u]>mid) return 0;\n    return 1;\n}\n\nint main(){//freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){scanf(\"%d%d\",&x,&y); add(x,y); add(y,x); d[x]++; d[y]++;}\n    for (int i=1;i<=n;i++) if (d[i]&1) ans++;\n    for (int i=1;i<=n;i++) if (d[i]==1){rt=i; break;}// cout<<rt<<endl;\n    ans/=2; printf(\"%d \",ans);\n    l=1,r=n;\n    while (l<=r){\n        mid=(l+r)>>1; memset(f,0,sizeof f);\n        if (dp(rt,0)){ans=mid; r=mid-1;} else l=mid+1;\n    }//*/mid=2; if (dp(rt,0)) puts(\"orz\");\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint dfs1(int v, int r) {\n    int ch = 0, ret = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        ret += dfs1(e.to, v);\n    }\n    return ch / 2 + ret;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    int A = dfs1(0, -1);\n\n    int ok = N, ng = 0;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A + 1 << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n\n        }\n\n    dp[n]=X[ind].first+1;\n\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        assert(a<=n && b<=n);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n\n\n    int low=0;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define si scanf\n#define so printf\n#define N 200100\n#define M \n#define INF  \n#define nxt t[j]\ntemplate<typename TP>inline bool rd(TP& r)\n{\n\tr=0;\n\tchar tmp=getchar();\n\twhile(tmp<'0'||tmp>'9')\n\t{\n\t\tif(tmp==EOF)\n\t\t\treturn 0;\n\t\ttmp=getchar();\n\t}\n\twhile('0'<=tmp&&tmp<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+tmp-'0';\n\t\ttmp=getchar();\n\t}\n\treturn 1;\n\t\n} \nint n; \nint h[N],x[N*2],t[N*2],tot=1;\nint du[N],A;\nvoid add(int u,int v)\n{\n\t++tot;\n\tx[tot]=h[u];\n\th[u]=tot;\n\tt[tot]=v;\n\t++du[u];\n}\nint ln[N],l2[N];\nint f[N];\nbool ok(int mid,int u)\n{\n\tfor(int i=1;i<=ln[0];++i)\n\t\tif(i==mid)\n\t\t\tl2[i]=n+100;\n\t\telse\n\t\t\tl2[i]=ln[i];\n\tsort(l2+1,l2+ln[0]+1);\n\tfor(int i=1;i<ln[0];++i)\n\t\tif(l2[i]+l2[ln[0]-i]+1>u)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dp(int u)\n{\n\tsort(ln+1,ln+ln[0]+1);\n\tfor(int i=1;i<=ln[0]-1;++i)\n\t\tif(ln[i]+ln[ln[0]-i]+1>u)//无法配对 \n\t\t\treturn n+100;\n\tint l=1,r=ln[0],mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(ok(mid,u))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\treturn ln[l]+1;\n}\nbool dfs(int now,int u,int fa)\n{\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tif(dfs(nxt,u,now)==0)\n\t\t\t\treturn 0;\n\tln[0]=0;\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tln[++ln[0]]=f[nxt];\n\tif(du[now]&1)\n\t\tln[++ln[0]]=0;\n\tf[now]=dp(u);\n\tif(f[now]>u)\n\t\treturn 0; \n\treturn 1;\n}\nint main()\n{\n\trd(n);\n\tint u,v;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\trd(u),rd(v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(du[i]&1)\n\t\t\t++A;\n\tA>>=1;\n\tint l=1,r=n*10,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\t//memset(f,0x3f,sizeof(f));\n\t\tif(dfs(1,mid,0))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tso(\"%d %d\\n\",A,l-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (300006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=45;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nbool OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nint n, i, x, y, cnt, limit;\nvector<int> list[maxN];\nint dp[maxN];\nbool bad;\nvector<int> aux;\n\nbool good(int deny) {\n    int p1, p2;\n\n    p1 = 0; p2 = aux.size() - 1;\n    while (p1 < p2) {\n        if (deny == p1) {\n            p1++; continue;\n        }\n        if (deny == p2) {\n            p2--; continue;\n        }\n\n        if (aux[p1] + aux[p2] > limit) return false;\n        p1++; p2--;\n    }\n\n    return true;\n}\n\nvoid dfs(int node, int root) {\n    for (auto to : list[node])\n        if (to != root && bad == false)\n            dfs(to, node);\n\n    if (bad) return;\n\n    aux.clear();\n\n    for (auto to : list[node])\n        if (to != root)\n            aux.pb(dp[to] + 1);\n\n    if (node != 1 && aux.size() % 2 == 0) aux.pb(0), cnt++;\n    sort(aux.begin(), aux.end());\n    cnt -= aux.size() / 2;\n\n    if (aux.size() % 2 == 0) {\n        if (!good(-1)) bad = true;\n        return;\n    }\n\n    int ans = -1;\n    for (int step = 1 << 20; step > 0; step >>= 1)\n        if (ans + step < aux.size())\n            if (!good(ans + step))\n                ans += step;\n\n    ans++;\n    if (ans == aux.size()) {\n        bad = true;\n        return;\n    }\n\n    dp[node] = aux[ans];\n    if (dp[node] > limit) bad = true;\n}\n\nbool check(int _limit) {\n    cnt = 0;\n    limit = _limit;\n    bad = false;\n    dfs(1, 0);\n    if (bad) return false;\n    return true;\n}\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    for (i = 1; i < n; i++) {\n        cin >> x >> y;\n        list[x].pb(y);\n        list[y].pb(x);\n    }\n\n    int ans = 0;\n    for (int step = 1 << 20; step > 0; step >>= 1)\n        if (ans + step < n)\n            if (!check(ans + step))\n                ans += step;\n\n    //cerr << check(1);\n\n    check(ans + 1);\n    cout << cnt << ' ' << ans + 1;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nvector<int>g[110000];\nbool dame=false;\nint M;\nint v[110000];\nint dfs(int a,int b){\n\tvector<int>tmp;\n\tint sz=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tsz++;\n\t\tint t=dfs(g[a][i],a);\n\t\tif(t>M)dame=true;\n\t\tif(dame)return 0;\n\t\ttmp.push_back(t);\n\t}\n\tstd::sort(tmp.begin(),tmp.end());\n\tif(b==-1){\n\t\tfor(int i=0;i<tmp.size()/2;i++){\n\t\t\tif(tmp[i]+tmp[tmp.size()-1-i]>M)dame=true;\n\t\t}\n\t\treturn 0;\n\t}else if(sz%2==0){\n\t\tbool ok=true;\n\t\tfor(int i=0;i<tmp.size()/2;i++){\n\t\t\tif(tmp[i]+tmp[tmp.size()-1-i]>M)ok=false;\n\t\t}\n\t\tif(ok)return 1;\n\t\tint cnt=0;\n\t\tfor(int i=0;i+1<tmp.size()/2;i++){\n\t\t\tv[i]=tmp[i+1]+tmp[tmp.size()-2-i];\n\t\t\tif(v[i]>M)cnt++;\n\t\t}\n\t\tint at=-1;\n\t\tif(cnt==0)at=0;\n\t\tfor(int i=1;at==-1&&i+1<tmp.size();i++){\n\t\t\tint x=i-1;\n\t\t\tif(1+x>=tmp.size()/2)x=tmp.size()/2-2-(x-tmp.size()/2+1);\n\t\t\tif(v[x]>M&&v[x]+tmp[i-1]-tmp[i]<=M)cnt--;\n\t\t\tv[x]+=tmp[i-1]-tmp[i];\n\t\t\tif(cnt==0){\n\t\t\t\tat=i;break;\n\t\t\t}\n\t\t}\n\t\tif(at!=-1)ok=true;\n\t\tif(ok)return tmp[at]+1;\n\t\telse dame=true;\n\t\treturn 0;\n\t}else{\n\t\tint cnt=0;\n\t\tfor(int i=0;i<tmp.size()/2;i++){\n\t\t\tv[i]=tmp[i+1]+tmp[tmp.size()-1-i];\n\t\t\tif(v[i]>M)cnt++;\n\t\t}\n\t\tint at=-1;\n\t\tif(cnt==0)at=0;\n\t\tfor(int i=1;at==-1&&i<tmp.size();i++){\n\t\t\tint x=i-1;\n\t\t\tif(x>=tmp.size()/2)x=tmp.size()/2-1-(x-tmp.size()/2);\n\t\t\tif(v[x]>M&&v[x]+tmp[i-1]-tmp[i]<=M)cnt--;\n\t\t\tv[x]+=tmp[i-1]-tmp[i];\n\t\t\tif(cnt==0){\n\t\t\t\tat=i;break;\n\t\t\t}\n\t\t}\n\t\tif(at==-1){dame=true;return 0;}\n\t\treturn tmp[at]+1;\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);g[q].push_back(p);\n\t}\n\tint req=1;\n\tfor(int i=0;i<a;i++){\n\t\tif(g[i].size()>2)req+=(g[i].size()-1)/2;\n\t}\n\tint left=0;\n\tint right=a;\n\twhile(left+1<right){\n\t\tM=(left+right)/2;\n\t\tdame=false;\n\t\tdfs(0,-1);\n\t\tif(dame==false){\n\t\t\tright=M;\n\t\t}else left=M;\n\t}\n\tprintf(\"%d %d\\n\",req,right);\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nint32_t F(std::vector<int32_t>& a, int32_t K)\n{\n\tstd::sort(a.begin(),a.end());\n\tint lb = -1, ub = a.size();\n\twhile (ub - lb>1) {\n\t\tint mid = (ub + lb) / 2;\n\n\t\tbool f = true;\n\t\tint l = 0, r = a.size() - 1;\n\t\tfor (int i = 0; i < a.size() / 2;++i) {\n\t\t\tif (l == mid)l++;\n\t\t\tif (r == mid)r--;\n\t\t\tif (a[l] + a[r]>K)f = false;\n\t\t\tl++; r--;\n\t\t}\n\t\tif (f)ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\n\tstd::vector<int32_t> T;\n\tfor (auto& i : L) { T.push_back(i); }\n\tauto R = F(T, len_max);\n\tif(R==T.size()){\n\t\tfunc_ok = false;\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn T[R];\n\t}\n\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\tif(0){\n\n\t\tlen_max = 10;\n\t\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\t\tL.insert(9);\n\t\tL.insert(8);\n\t\tL.insert(4);\n\n\t\tif (L.size() % 2 == 0) {\n\t\t\tL.insert(0);\n\t\t}\n\n\t\twhile (L.size() >= 2) {\n\t\t\tauto iter2 = L.begin();\n\t\t\tauto iter1 = L.upper_bound(len_max - *iter2);\n\t\t\tif (iter1 == L.end()) {\n\t\t\t\tfunc_ok = false;\n\t\t\t\t//return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (iter1 == iter2) {\n\t\t\t\t++iter1;\n\t\t\t}\n\t\t\tL.erase(iter1);\n\t\t\tL.erase(iter2);\n\t\t}\n\t}\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nVI e[N];\nint l,r,mid,f[N],n;\ninline void dfs(int k) {\n\tfor (int t:e[k]) {\n\t\te[t].erase(find(e[t].begin(),e[t].end(),k));\n\t\tdfs(t);\n\t}\n}\ninline bool solve(int k) {\n\tint m=e[k].size(),i,L,R,MID;VI w(m);\n\tfor (i=0;i<m;i++) {\n\t\tif (!solve(e[k][i])) return false;\n\t\tw[i]=f[e[k][i]]+1;\n\t}\n\tif (~m&1) w.pb(0),m++;\n\tsort(w.begin(),w.end());\n\tL=0,R=m;\n\twhile (L!=R) {\n\t\tMID=(L+R)>>1;\n\t\tf[k]=w[MID];\n\t\tw.erase(w.begin()+MID);\n\t\tfor (i=0;i<m/2;i++)\n\t\t\tif (w[i]+w[m-2-i]>mid) break;\n\t\tw.insert(w.begin()+MID,f[k]);\n\t\tif (i==m/2) R=MID;\n\t\telse L=MID+1;\n\t}\n\tif (L==m) return false;\n\tf[k]=w[L];\n\treturn true;\n}\nint main()\n{\n\tint n=gi(),i,a,b,ans=0,rt;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\te[a].pb(b),e[b].pb(a);\n\t}\n\tfor (i=1;i<=n;i++) ans+=e[i].size()&1,e[i].size()==1?rt=i:0;\n\tdfs(rt);\n\tl=1,r=n;\n\twhile (l!=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (solve(rt)&&f[e[rt][0]]<mid) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<ans/2<<\" \"<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// when range [l, r), has property notP~P, want first P.\n// when return r, means not found.\ntemplate <typename T>\nT bs_first(T l, T r, function<bool (T)> f) {\n    assert(l < r);\n    T mid;\n    while (l != r) {\n        mid = l + (r-l)/2;\n        if (f(mid)) {\n            r = mid;\n        }else {\n            l = mid + 1;\n        }\n    }\n    return r;\n}\n\nvoid solve() {\n    int n; cin >> n;\n    vector<vector<int>> g(n+1);\n    vector<int> deg(n+1);\n    for (int _ = 1; _ < n; _++) {\n        int x,y;\n        cin >> x >> y;\n        deg[x]++;\n        deg[y]++;\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n    int root, cnt=0;\n    for (int i = 1; i <= n; i++) {\n        if (deg[i] & 1) cnt++;\n        if (deg[i] == 1) root=i;\n    }\n    int A = cnt/2;\n    int vir = 0; g[vir].emplace_back(root);\n    auto ck = [&](int x){\n        vector<int> dp(n+1);\n        function<bool(int,int)> dfs = [&](int u, int p){\n            vector<int> arm;\n            for (int v: g[u])if(v!=p){\n                if (!dfs(v, u)) return false;\n                arm.emplace_back(dp[v]);\n            }\n            if (arm.size()%2==0) arm.emplace_back(0);\n            sort(arm.begin(), arm.end());\n            int m = arm.size();\n            int i = bs_first<int>(0, m, [&](int i){\n                    int l=0, r=m-1;\n                    while (l<r) {\n                        if (l==i) l++;\n                        if (r==i) r--;\n                        if (l < r) {\n                            if (arm[l] + arm[r] > x) return false;\n                            l++; r--;\n                        }\n                    }\n                    return true;\n                    });\n            if (i == m) return false;\n            dp[u] = arm[i] + 1;\n            if (u == root) {\n                return dp[u] <= x+1;\n            } else {\n                return dp[u] <= x;\n            }\n        };\n        return dfs(root, vir);\n    };\n    int B = bs_first<int>(1, n+1, ck);    \n    cout << A << ' ' << B << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 2) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\tfl2 = fl;\n\tfl = true;\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    //if(V[1].size()%2) ++ans;\n    ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box%2)M++;\n\treturn 1;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i,lim) + 1);\n\t}\n\tint amari = 1;\n\twhile (num[node].size() > 1) {\n\t\tint b = *prev(num[node].end());\n\t\tnum[node].erase(prev(num[node].end()));\n\t\tauto it = num[node].upper_bound(lim - b);\n\t\t//if (it == num[node].begin() && num[node].size() % 2 == 1) {\n\t\t//\tif (b > lim)K = 0;\n\t\t//}\n\t\tif (it == num[node].begin() && amari) {\n\t\t\tamari--;\n\t\t\tif (b > lim)K = 0;\n\t\t}\n\t\telse if (it == num[node].begin()) {\n\t\t\tK = 0;\n\t\t\tnum[node].erase(num[node].begin());\n\t\t}\n\t\telse {\n\t\t\tnum[node].erase(prev(it));\n\t\t}\n\t}\n\tif (!node&&num[node].size() && *num[node].begin() > lim)K = 0;\n\tif (num[node].empty())return 0;\n\telse return *num[node].begin();\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tSearch(edge, dis, num, 0,mid);\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl)\n                return 0;\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=1;\n    if(s.size()%2==1)\n        flag=0;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        if(t>maxl)\n            return 0;\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==0)\n                dp[x]=t;\n            flag=-1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nint n;\nvector<vector<int>>hen;\nvector<int>ki;//is kisu\nint solve(int ter,int oya,int bgen){\n\t//解きます\n\t//cerr<<ter<<endl;\n\tmultiset<int>soi;\n\tif(ki[ter]){soi.ins(0);}\n\tfor(auto it:hen[ter]){\n\t\tif(it==oya){continue;}\n\t\tint kae=solve(it,ter,bgen);\n\t\tif(kae==-1){return -1;}\n\t\tsoi.ins(kae);\n\t}\n\t//bgen以下を作る貪欲法\n\t//soiは1あまる\n\t//setで殴りすぎlogがひどい\n\tint sta=-1;\n\twhile(soi.size()>1){\n\t\tint mae=*prev(soi.end());\n\t\tsoi.era(prev(soi.end()));\n\t\tauto itr=soi.upper_bound(bgen-mae);\n\t\tif(itr==soi.begin()){//ないので\n\t\t\tif(sta!=-1){return -1;}\n\t\t\telse{sta=mae;}\n\t\t}\n\t\telse{soi.era(prev(itr));}\n\t}\n\tif(sta>bgen){return -1;}\n\tif(soi.size()==1){sta=*soi.begin();}\n\tif(oya!=-1){return sta+1;}\n\telse{return 0;}\n}\nint main(void){\n\tint i;\n\tcin>>n;hen.res(n);ki.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\then[a].pub(b);ki[a]=(!ki[a]);\n\t\then[b].pub(a);ki[b]=(!ki[b]);\n\t}\n\tint A=0,ha=-1;\n\tfor(i=0;i<n;i++){if(ki[i]){A++;}if(hen[i].size()==1){ha=i;}}\n\tcout<<A/2<<\" \";\n\tint bmax=n,bmin=0;\n\twhile(bmax-bmin>1){\n\t\tint bgen=(bmax+bmin)/2;\n\t\tif(solve(ha,-1,bgen)!=-1){bmax=bgen;}\n\t\telse{bmin=bgen;}\n\t}\n\tcout<<bmax<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+20;\nint n;\nvector<int> g[N], h[N];\n\nint dfs(int x, int f, int d) {\n\th[x].clear();\n\tfor (int y:g[x]) if (y!=f) h[x].pb(dfs(y,x,d));\t\n\tif (h[x].size()%2==0) h[x].pb(0);\n\tif (h[x].size()==1) return h[x][0]+1;\n\tsort(h[x].begin(),h[x].end());\n\tint sz=h[x].size(),l=0,r=sz-1,ans=-1;\n\twhile (l<=r) {\n\t\tint ql=0,qr=sz-1,ok=1;\n\t\twhile (1) {\n\t\t\tif (ql==mid) ++ql;\n\t\t\tif (qr==mid) --qr;\n\t\t\tif (ql>qr) break;\n\t\t\tif (h[x][ql]+h[x][qr]>d) ok=0;\n\t\t\t++ql,--qr;\n\t\t}\n\t\tif (ok) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans<0?INF:h[x][ans]+1; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,2,n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tint cnt = 0, rt = 0;\n\tREP(i,1,n) if (g[i].size()&1) rt = i, ++cnt;\n\tcnt /= 2;\n\tint l = 0, r = n-1, ans;\n\twhile (l<=r) {\n\t\tif (dfs(rt,0,mid)<=mid+1) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\", cnt, ans);\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check_even(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint solve_even(vi & legs, int mx){\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check_even(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check_even(legs, lo, mx)) return legs[lo];\n    else if(check_even(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nint solve_odd(vi & legs, int mx){\n    int l = 0;\n    int r = sz(legs) - 1;\n    bool good = true;\n    while(l<=r){\n        if(legs[l]+legs[r]>mx) {\n            good = false; break;\n        }\n        l++; r--;\n    }\n    if(good) return 0;\n    int id = -1;\n    f0r(i, sz(legs)) if(legs[i]<=mx) id = i;\n    if(id == -1){\n        ok = false;\n        return legs.back();\n    }\n    legs.erase(legs.begin()+id);\n    return solve_even(legs, mx);\n}\nint root;\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src]) == 1 && src != root) return 0;\n    vi legs;\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        if(sz(adj[src])%2 == 0){\n            int l = 0;\n            int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx){\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        else{\n            if(sz(adj[src]) == 1){\n                if(legs.back()>mx) ok = false;\n                return legs.back();\n            }\n            int id = -1;\n            f0r(i, sz(legs)) if(legs[i]<=mx) id = i;\n            if(id == -1){\n                ok = false;\n                return legs.back();\n            }\n            legs.erase(legs.begin()+id);\n            int l = 0; int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx) {\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        return legs.back();\n\n    }\n    if(sz(adj[src])%2 == 0) return solve_even(legs, mx);\n    else return solve_odd(legs, mx);\n}\nint main(){\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    int lo = 1;\n    int hi = MAX;\n    root = 0;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(root, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(root, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(t.size()%2==0){\n\t\tif(t.back()>h)return out;\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=-1,r=t.size()-1;\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tcmin(out,t[r]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n-1;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001],d[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t\td[u]++;\n\t\td[v]++;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (d[i]%2) ans++;\n\t/*int ans=dfs(1,-1);*/\n\tprintf(\"%d \",ans/2);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nint a_dfs(const Graph& g, const int s)\n{\n    const int C = g.edge[s].size();\n    int sum = C / 2;\n    for (const int to : g.edge[s]) {\n        sum += a_dfs(g, to);\n    }\n    return sum;\n}\n\nint K;\nbool check(const vector<int>& a, const int ng, const int size)\n{\n    int tail = size - 1;\n    for (int i = 0; i < size; i++) {\n        if (tail == ng) {\n            tail--;\n        }\n        if (tail <= i) {\n            break;\n        }\n        const int sum = a[i] + a[tail];\n        if (sum + 1 > K) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool b_bfs(const Graph& g, const int s, vector<int>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> l;\n    for (const int to : g.edge[s]) {\n        const bool f = b_bfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        l.push_back(dp[to]);\n    }\n    sort(l.begin(), l.end());\n    if (C % 2 == 1) {\n        int inf = 0;\n        int sup = C;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            if (check(l, mid, C)) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == C or l[sup] + 1 > K) {\n            return false;\n        } else {\n            dp[s] = l[sup] + 1;\n            return true;\n        }\n    } else {\n        if (check(l, C, C)) {\n            dp[s] = 1;\n            return true;\n        } else if (l.back() + 1 > K) {\n            return false;\n        } else {\n            int inf = 0;\n            int sup = C - 1;\n            while (inf < sup) {\n                const int mid = (inf + sup) / 2;\n                if (check(l, mid, C - 1)) {\n                    sup = mid;\n                } else {\n                    if (inf == mid) {\n                        break;\n                    }\n                    inf = mid;\n                }\n            }\n            if (sup == C - 1 or l[sup] + 1 > K) {\n                return false;\n            } else {\n                dp[s] = l[sup] + 1;\n                return true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    vector<int> dim(N, 0);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n        dim[a]++;\n        dim[b]++;\n    }\n    int root = 0;\n    for (; root < N; root) {\n        if (dim[root] == 1) {\n            break;\n        }\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, root, used);\n    const int A = a_dfs(g, root) + 1;\n\n    vector<int> dp(N, 0);\n    int inf = 0;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        const bool ok = b_bfs(g, root, dp);\n        if (ok) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    b_bfs(g, root, dp);\n    const int B = sup - 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.begin();\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n    dp[n]=(*S.begin()).first+1;\n\n\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t;\n\nbool ok(int mid) {\n    REP (i, N) {\n\tint v = ord[N-1-i];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (t.size() % 2 == 0) t.push_back(0);\n\tsort(t.begin(), t.end());\n\tint m = t.size() / 2;\n\tdp[v] = -1;\n\tint pos = 0;\n\tREP (j, m) {\n\t    int c = t.rbegin()[j];\n\t    while (pos < (int)t.size() && t[pos] + c <= mid) pos++;\n\t    if (pos <= j) return false;\n\t    if (dp[v] == -1 && pos > j + 1) dp[v] = t[j];\n\t    if (pos == j+1) dp[v] = -1;\n\t}\n\tif (dp[v] == -1) dp[v] = t[m];\n    }\n    return dp[0] <= mid;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += (G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tif (len.size()%2==1) len.push_back(0);\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<=j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\tif (len[j]<=mid)\n\t\t\t{\n\t\t\t\ts.erase(j);\n\t\t\t\tt--;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1)\n\t{\n\t\tif (x==1) return 0;\n\t\tdis[x]=len[*s.begin()];\n\t}\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tint p1 = 0, p2 = son.size()-1;\n\twhile (p1 < p2)\n\t{\n\t\tif (p1 == r) p1++;\n\t\tif (p2 == r) p2--;\n\t\tif (son[p1] + son[p2] > B) return false;\n\t\tp1++; p2--;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size+1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=1001000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\n\tmit it;\n\tint w,dw,cnt;\n\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tcnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tw=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tif(n>90000)exit(1);\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=0;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\n#define pb push_back\n#define sz(a) int(a.size())\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,A,lim,f[N];\nvector<int> E[N];\nbool fl;\n\nbool check2(vector<int> &v,int mid) {\n\tint l=0,r=sz(v)-1;\n\twhile(l<r) {\n\t\tif(l==mid) { ++l;continue; }\n\t\tif(r==mid) { --r;continue; }\n\t\tif(v[l]+v[r]>lim) return 0;\n\t\t++l,--r;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int u,int fa) {\n\tvector<int> vec;\n\tfor(auto v:E[u]) if(v^fa) dfs(v,u),vec.pb(f[v]);\n\tif(vec.empty()) { f[u]=1;return; }\n\tif(sz(vec)&1^1) vec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=sz(vec);\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check2(vec,mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tif(l==sz(vec)) { fl=0;return; }\n\tf[u]=vec[l]+1;\n}\n\nbool check(int mid) {\n\tlim=mid;fl=1;dfs(1,0);\n\treturn fl&&f[1]<=lim+1;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tfor(int i=1;i<=n;i++)\n\t\tif(sz(E[i])&1) ++A;\n\tint l=0,r=n;\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<A/2<<' '<<l;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(!(v.size()&1)) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\tint l=0,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << (cnt+1)/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=1001000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\n\tmit it;\n\tint w,dw,cnt;\n\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tcnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tw=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n-1,d=1;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define pb push_back\nconst int N=1e5+5;\nint n;\nvector<int>lk[N],son[N];\n\nint A;\nnamespace GET_A\n{\nvoid dfs(int x,int fr)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tson[x].pb(y);\n\t\tdfs(y,x);\n\t}\n//\tcerr<<x<<\" \"<<son[x].size()<<endl;\n//\tfor(auto y:son[x])cerr<<y<<\" \";puts(\"\");\n\tif(x!=1)A+=son[x].size()/2;\n\telse A+=(son[x].size()+1)/2;\n}\n};\nnamespace GET_B\n{\nint len[N];\nint mid;\nbool dfs(int x)\n{\n\tif(!son[x].size())\n\t{\n\t\tlen[x]=1;\n\t\treturn 0;\n\t}\n\tvector<int>a;\n\tfor(auto y:son[x])\n\t{\n\t\tif(dfs(y))return 1;\n\t\ta.pb(len[y]);\n\t}\nif(x==1)\n{\n\tsort(a.begin(),a.end());\n\tint l=0,r=a.size()-1;\n\tif(r%2==0)\n\t{\n\t\tif(a[r]+1>mid)return 1;\n\t\t--r;\n\t}\n\twhile(l<r)\n\t{\n\t\tif(a[l]+a[r]+1>mid)return 1;\n\t\t++l;--r;\n\t}\n\treturn 0;\n}\n\tif(a.size()%2==0)a.pb(0);\n\tsort(a.begin(),a.end());\n\tint l=0,r=a.size()-1;\n\t--r;\n\twhile(l<r)\n\t{\n\t\tif(a[l]+a[r]+1>mid)return 1;\n\t\t++l;--r;\n\t}\n\tr=a.size()-1;l=0;\n\twhile(r&&a[r]+a[l]+1<=mid)\n\t{\n\t\t--r;++l;\n\t\tif(l==r)++l;\n\t}\n\tlen[x]=a[r]+1;\n\treturn 0;\n}\nbool ok()\n{\n\tif(dfs(1))return 0;\n\treturn 1;\n}\nint erfen()\n{\n\tint l=1,r=n;\n\twhile(l+1!=r)\n\t{\n\t\tmid=(l+r)/2;\n\t\tif(ok())r=mid;\n\t\telse l=mid;\n\t}\n//\tmid=5;\n//\tok();\n\treturn r;\n}\n};\n\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlk[x].pb(y);lk[y].pb(x);\n\t}\n\tGET_A::dfs(1,0);\n\tint B=GET_B::erfen();\n\tcout<<A<<\" \"<<B-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    f[x] = g[ans] + 1;\n    return 1;\n}\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(1, 0)) return 0;\n    return f[1] <= m + 1;\n}\nint main() {\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    std::cout << (m >>= 1) << ' ';\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans;  //<< std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int maxn = 100010;\n \nint n,A,B,mid,dp[maxn];\nvector<int> g[maxn];\n \nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            if (dp[v]!=-1) temp.push_back(dp[v]);\n        }\n    }\n   // sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n   // cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=0,rr=temp.size()-1;\n        int choose=-1;\n        while (ll<=rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n            while (p1<p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > mid) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                choose = x;\n                rr = x-1;\n            }\n            else ll = x+1;\n        }\n        if (choose==-1) return false;\n        dp[u] = temp[choose] + 1;\n        return true;\n    }\n    else {\n        for (int i=0;i<temp.size();i++)\n            if (temp[i] + temp[temp.size()-i-1] + 2 > mid) return false;\n        dp[u]=-1;\n        return true;\n    }\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n   // freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=1,r=n-1;\n    while (l<=r) {\n        mid = (l+r)/2;\n        if (visit(1,-1)) {\n            B = mid;\n            r = mid-1;\n        } else l = mid+1;\n    }\n    cout<<B;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nii mini(ii a, ii b)\n{\n\tif(a.fi<b.fi||(a.fi==b.fi&&a.se<b.se)) return a;\n\telse return b;\n}\n\nii dp[111111];\nvi adj[111111];\nint MID;\n\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t\tcnt+=dp[v].fi;\n\t}\n\tsort(vec.begin(),vec.end());\n\t/*\n\tint maxpath = 0;\n\twhile(!vec.empty())\n\t{\n\t\tif(vec.size()==1)\n\t\t{\n\t\t\tif(vec[0]+1<=mid)\n\t\t\t{\n\t\t\t\tmaxpath = max(maxpath, vec[0]+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tmaxpath = max(maxpath, 1);\n\t\t\t}\n\t\t\tvec.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint las = vec.back();\n\t\t\tif(vec.front()+2+las<=mid)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_front(0);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint mini = int(1e9);\n\t\tif(mid==1)\n\t\t{\n\t\t\tmini=vec[0]+1;\n\t\t}\n\t\tfor(int i=0;i<mid;i++)\n\t\t{\n\t\t\tif(i<mid-1-i) mini=min(mini,vec[i]+vec[mid-1-i]+2);\n\t\t\telse break;\n\t\t}\n\t\tif(mini==int(1e9)) mini=0;\n\t\tif(mini<=MID)\n\t\t{\n\t\t\tans=mid;\n\t\t\tlo=mid+1;\n\t\t}\n\t\telse hi=mid-1;\n\t}\n\tint maxpath = 0;\n\tint del=0;\n\tfor(int i=ans;i<vec.size();i++) \n\t{\n\t\tif(vec[i]+1<=MID)\n\t\t{\n\t\t\tdel++;\n\t\t}\n\t\tvec[i]=0;\n\t}\n\tcnt+=int(vec.size()) - ans;\n\tfor(int j=0;j<del;j++) vec.pop_back();\n\tsort(vec.begin(),vec.end());\n\t//cerr<<vec.size()<<'\\n';\n\tcnt+=int(vec.size())/2;\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=0;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = int(1e9);\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=min(res,vec[l]+vec[r]+2);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res==int(1e9)) res=0;\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tmaxpath = vec[ans]+1;\n\t\tif(maxpath>MID)\n\t\t{\n\t\t\tmaxpath=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t//cerr<<MID<<' '<<u<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tMID=n;\n\tdfs(0,-1);\n\tint res=dp[0].fi;\n\tif(dp[0].se>0) res++;\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=dp[0].fi;\n\t\tif(dp[0].se>0) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_LG = 17;\n\nvector<int> adj [MAX_N];\n\nint max_fold_without (const vector<int> &v, int idx) {\n  int lptr = 0;\n  if (lptr == idx) lptr++;\n  int rptr = (int) v.size() - 1;\n  if (rptr == idx) rptr--;\n\n  int mx = 0;\n  while (lptr < rptr) {\n    mx = max(mx, v[lptr] + v[rptr]);\n\n    lptr++;\n    if (lptr == idx) lptr++;\n    rptr--;\n    if (rptr == idx) rptr--;\n  }\n\n  return mx;\n}\n\nint dp [MAX_N]; // cheapest thing we can send up\nint cap;\nbool error;\nvoid dfs (int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n    }\n  }\n\n  vector<int> ups;\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      ups.push_back(dp[nxt]);\n    }\n  }\n\n  if ((int) adj[u].size() % 2 == 1) {\n    ups.push_back(0);\n  }\n  sort(ups.begin(), ups.end());\n\n  if (u == p) {\n    int fold = max_fold_without(ups, -1);\n    if (fold > cap) error = 1;\n    return;\n  }\n\n  if (max_fold_without(ups, (int) ups.size() - 1) > cap) {\n    error = 1;\n  } else if (max_fold_without(ups, 0) <= cap) {\n    dp[u] = ups[0];\n  } else {\n    int ans = 0;\n    for (int k = 1 << MAX_LG; k != 0; k /= 2) {\n      if (ans + k < (int) ups.size() && max_fold_without(ups, ans + k) > cap) {\n        ans += k;\n      }\n    }\n    dp[u] = ups[ans + 1];\n  }\n  dp[u]++;\n\n  if (dp[u] > cap) error = 1;\n}\n\nbool try_with (int _cap) {\n  cap = _cap;\n  error = 0;\n  dfs(1, 1);\n  return error;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int oddc = 0;\n  for (int i = 1; i <= n; i++) {\n    if ((int) adj[i].size() % 2 == 1) oddc++;\n  }\n  \n  int ans = 0;\n  for (int k = 1 << MAX_LG; k != 0; k /= 2) {\n    cap = ans + k;\n    error = 0;\n    dfs(1, 1);\n    if (error) {\n      ans += k;\n    }\n  }\n\n  cout << oddc / 2 << \" \" << ans + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\nint n;\nvector<int> g[N];\nint dp[N];\nint m;\n\nbool solve(int v, int par) {\n\tvector<int> a;\n\tif ((int)g[v].size() & 1) a.push_back(0);\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tif (!solve(u, v)) return false;\n\t\tif (dp[u] != -1)\n\t\t\ta.push_back(dp[u] + 1);\n\t}\n\tsort(a.begin(), a.end());\n/*\n\tprintf(\"%d :\", v);\n\tfor (int x : a)\n\t\tprintf(\" %d\", x);\n\tprintf(\"\\n\");\n*/\n\tif ((int)a.size() & 1) {\n\t\tint l = -1, r = (int)a.size();\n\t\twhile(r - l > 1) {\n\t\t\tint x = (l + r) / 2;\n\t\t\tint p1 = 0, p2 = (int)a.size() - 1;\n\t\t\tbool ok = true;\n\t\t\twhile(p1 < p2) {\n\t\t\t\tif (p1 == x) p1++;\n\t\t\t\tif (p2 == x) p2--;\n\t\t\t\tif (a[p1] + a[p2] > m) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp1++;\n\t\t\t\tp2--;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tr = x;\n\t\t\telse\n\t\t\t\tl = x;\n\t\t}\n\t\tif (r == (int)a.size()) return false;\n\t\tdp[v] = a[r];\n\t\treturn true;\n\t} else {\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\tif (a[i] + a[(int)a.size() - 1 - i] > m)\n\t\t\t\treturn false;\n\t\tdp[v] = -1;\n\t\treturn true;\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += (int)g[i].size() & 1;\n\tprintf(\"%d \", ans / 2);\n\tint l = 0, r = n;\n\twhile(r - l > 1) {\n\t\tm = (l + r) / 2;\n\t\tif (solve(0, -1))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m;\n\t}\n\tprintf(\"%d\\n\", r);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nbool OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back();\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len && len!=1) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m+1) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nll md;\nvvi g;\nll e;\nll dfs(int i,int p){\n    ll res=0;\n    ll cnt=0;\n    for(ll x:g[i])if(x!=p){\n        res+=dfs(x,i);\n        cnt++;\n    }\n    if(cnt)res-=(cnt-1)/2;\n    else res++;\n    return res;\n}\nll check(int i,int p){\n    vi v;\n    for(ll x:g[i])if(x!=p){\n        ll t=check(x,i);\n        if(t==-1)return -1;\n        v.pb(t);\n    }\n    if(i==e){\n        return 1;\n    }\n    sort(all(v));\n    if(!v.size())return 1;\n    if(v.size()%2==0){\n        bool b=true;\n        rep(j,v.size()/2)if(v[j]+v[v.size()-j-1]>md)b=false;\n        if(b)return 1;\n        v.pop_back();\n    }\n    if(v[0]>=md)return -1;\n    ll t=lb(v,md);\n    ll ok=t,ng=-1;\n    while(ok-ng>1){\n        ll k=(ok+ng)/2;\n        bool able=true;\n        int a=0,b=v.size()-1;\n        rep(j,v.size()/2){\n            if(a==k)a++;\n            if(b==k)b--;\n            if(v[a]+v[b]>md)able=false;\n            a++;b--;\n        }\n        if(able)ok=k;\n        else ng=k;\n    }\n    if(ok==t)return -1;\n    return v[ok]+1;\n}\nint main(){\n    ll n;cin>>n;\n    g=vvi(n);\n    rep(i,n-1){\n        ll a,b;cin>>a>>b;a--;b--;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    int ne=0;\n    while(g[ne].size()>1)ne++;\n    e=ne;\n    ll ans=dfs(ne,-1);\n    ll ok=n-1,ng=0;\n    while(ok-ng>1){\n        md=(ok+ng)/2;\n        if(check(ne,-1)!=-1)ok=md;\n        else ng=md;\n    }\n    cout<<ans<<' '<<ok<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin>>n;\n  vvi G(n);\n\n  // FOR(i,n-1) {\n  //   int a = i+1, b = rand()%(i+1);\n  //   G[a].pb(b);\n  //   G[b].pb(a);\n  // }\n\n  FOR(i,n-1) {\n    int a,b; cin>>a>>b;\n    --a; --b;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  { int a = 0;\n    FOR(i,n) if(G[i].size()&1) a += 1;\n    cout << a/2 << ' ';\n  }\n\n  auto ok = [&](int i, int b) -> bool {\n    function<int(int, int)> dfs = [&](int i, int p) -> int {\n      deque<int> rs;\n      for(int j : G[i]) if(j != p) {\n          int r = dfs(j,i);\n          if(r>b) throw 0;\n          rs.pb(r);\n      }\n      sort(all(rs));\n      if(p == -1) {\n        if(rs.size()&1) {\n          rs.pop_back();\n        }\n        FOR(i,rs.size()) if(rs[i]+rs[rs.size()-1-i] > b) throw 0;\n        return 0;\n      }else{\n        if((rs.size()&1) == 0) rs.push_front(0);\n        int lo = 0, hi = rs.size()-1;\n        auto ok = [&](int mi) -> bool {\n          deque<int> rs2;\n          FOR(i,rs.size()) if(i != mi) rs2.pb(rs[i]);\n          while(!rs2.empty()) {\n            if(rs2.front() + rs2.back() > b) return 0;\n            rs2.pop_front();\n            rs2.pop_back();\n          }\n          return 1;\n        };\n        if(ok(hi)) {\n          while(lo != hi) {\n            int mi = (lo+hi)/2;\n            if(ok(mi)) { hi = mi; }\n            else { lo = mi+1; }\n          }\n          // cout << b << \" \" << rs << \" \" << lo << endl;\n          return rs[lo]+1;\n        }else{\n          throw 0;\n        }\n      }\n    };\n    try {\n      dfs(i,-1);\n      return 1;\n    } catch(int){\n      return 0;\n    }\n  };\n\n  int ans = n+n;\n\n  int lo = 1, hi = n+n;\n  while(lo != hi) {\n    int mi = (lo+hi)/2;\n    if(ok(0, mi)) { hi = mi; }\n    else { lo = mi+1; }\n  }\n  ans=min(ans,lo);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> g[N];\nint A, newA, lim;\n\nint dfs(int u,int p) {\n\tmultiset<int> ms;\n\tfor (int v : g[u]) if (v != p) {\n\t\tms.insert(dfs(v, u) + 1);\n\t}\n\t\n\tvector<int> rem;\n\twhile (!ms.empty()) {\n\t\tmultiset<int>::iterator it = ms.end();\n\t\tint x = *(--it);\n\t\tms.erase(it);\n\t\tit = ms.upper_bound(lim - x);\n\t\tif (it == ms.begin()) rem.push_back(x);\n\t\telse ms.erase(--it), newA++; \n\t}\n\t\n\treverse(rem.begin(), rem.end());\n\twhile (!rem.empty() && rem.back() == lim) newA++, rem.pop_back();\n\tif (rem.empty()) return 0;\n\telse { newA += rem.size() - 1; return rem[0]; }\n}\n\nbool check() {\n\tnewA = 0;\n\tnewA += dfs(1, 1) > 0;\n\treturn newA == A;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v), g[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tA += g[i].size() & 1;\n\t}\n\tA /= 2;\n\tint l = 1, r = n;\n\twhile (l < r) {\n\t\tlim = l + r >> 1;\n\t\tif (check()) r = lim;\n\t\telse l = lim + 1;\n\t}\n\tcout << A << ' ' << l << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\n\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint isok=0,p=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tif(!isok) return 1;\n\tsort(all(v));\n\tint ret=0;\n\tfor(int l=0,r=SZ(v)-1;l<r;r--)\n\t\tif(v[l]+v[r]+1<=B) l++,ret++;\n\tif(ret*2==SZ(v)){res+=ret;return 1;}\n\tres+=SZ(v)-ret-1;\n\tmultiset<int> s;\n\tfor(int i=0;i<=ret*2;i++) s.insert(v[i]);\n\tfor(int i=ret*2;i>=0;i--){\n\t\tauto pos=s.find(v[i]);\n\t\tif(pos==s.end()) continue;\n\t\ts.erase(pos);\n\t\tauto it=s.upper_bound(B-1-v[i]);\n\t\tif(it!=s.begin()) s.erase(--it); else{p=v[i];break;}\n\t}\n\tif(p+1==B){res++;return 1;}\n\treturn p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,x,y,ans,l,r,mid,tot,rt,f[N],a[N],g[N],head[N],d[N];\nstruct edge{int v,nxt;}e[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool dp(int u,int fa){\n    f[u]=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) if (!dp(v,u)) return 0;\n    //printf(\"+++++++%d+++++++\\n\",u);\n    //for (int i=head[u],v;i;i=e[i].nxt)\n        //if ((v=e[i].v)!=fa) printf(\"%d\\n\",f[v]);\n    int xb=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) a[++xb]=f[v]+1;\n    if ((xb&1)==0) a[++xb]=0;\n    sort(a+1,a+xb+1);// for (int i=1;i<=xb;i++) cout<<a[i]<<endl;\n    memset(g,-1,sizeof(int)*(xb+1));\n    int j,k; j=1;\n    for (int i=xb;i>=1;i--){\n        for (;j<i && a[j]+a[i]<=mid;j++) g[i]=j;\n        j--;\n    }\n    j=0,k=0;\n    for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+1){k=i; break;}// cout<<k<<endl;\n    if (k==0){\n        j=1; for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+2) j=xb-i+2;\n        f[u]=a[j];\n    }\n    else{\n        j=0; for (int i=xb;i>j+1;i--) if (k!=i){j++; if (a[i]+a[j]>mid) return 0;}\n        f[u]=a[k];\n    }\n    if (u==rt && f[u]>mid) return 0;\n    return 1;\n}\n\nint main(){//freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){scanf(\"%d%d\",&x,&y); add(x,y); add(y,x); d[x]++; d[y]++;}\n    for (int i=1;i<=n;i++) if (d[i]&1) ans++;\n    for (int i=1;i<=n;i++) if (d[i]==1){rt=i; break;}\n    ans/=2; printf(\"%d \",ans);\n    l=1,r=n;\n    while (l<=r){\n        mid=(l+r)>>1; memset(f,0,sizeof f);\n        if (dp(rt,0)){ans=mid; r=mid-1;} else l=mid+1;\n    } //*/mid=2; if (dp(1,0)) puts(\"orz\");\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tif(a + table.front() > length){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\t//if(de < 0){\n\t\t//\tdame = true;\n\t\t//\treturn INF;\n\t\t//}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\tassert(node == num);\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\n\nint solve(int curr, int prev, int limit)\n{\n    vector<int> v;\n    for(int next : edges[curr]){\n        if(next == prev)\n            continue;\n        v.push_back(solve(next, curr, limit));\n        if(v.back() == -1)\n            return -1;\n    }\n    sort(v.begin(), v.end());\n\n    int n = v.size();\n    int i = 0;\n    int j = v.size() - 1;\n    vector<int> w;\n    while(i < j){\n        if(limit < v[i] + v[j] + 1){\n            w.push_back(v[j]);\n            -- j;\n        }\n        else{\n            ++ i;\n            -- j;\n        }\n    }\n    if(i == j)\n        w.push_back(v[j]);\n\n    if(!w.empty() && limit < w[0] + 1)\n        return -1;\n\n    if(w.empty())\n        return 1;\n    else if(w.size() == 1)\n        return w[0] + 1;\n    else if(w.size() == 2 && prev != -1)\n        return w[1] + 1;\n    else\n        return -1;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int a, b;\n        cin >> a >> b;\n        -- a;\n        -- b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    int ans = 1;\n    for(int i=0; i<n; ++i)\n        ans += (edges[i].size() - 1) / 2;\n\n    int left = 1;\n    int right = n;\n    while(left < right){\n        int mid = (left + right) / 2;\n        if(solve(0, -1, mid) != -1)\n            right = mid;\n        else\n            left = mid + 1;\n    }\n    cout << ans << ' ' << (left - 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005,INF=1<<30;\n\nint A[MAX],B[MAX],C[MAX],cnt[MAX];\nbool alive[MAX];\nvector<int> G[MAX];\n\nvoid DFS(int u,int p){\n    for(int to:G[u]){\n        if(to==p) continue;\n        DFS(to,u);\n        cnt[u]++;\n        A[u]+=A[to]+alive[to];\n    }\n    A[u]-=cnt[u]/2;\n    if(cnt[u]%2==0) alive[u]=1;\n}\n\nint lim;\nbool ok;\n\nvoid solve(int u,int p){\n    if(cnt[u]==0) return;\n    \n    vector<int> X;\n    if(cnt[u]%2==0) X.push_back(0);\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        solve(to,u);\n        X.push_back(C[to]+1);\n    }\n    sort(all(X));\n    \n    int M=si(X);\n    \n    int left=-1,right=M;\n    while(right-left>1){\n        int mid=(left+right)/2;\n        int l=0,r=M-1;\n        int ma=-1;\n        while(l<r){\n            if(l==mid) l++;\n            if(r==mid) r--;\n            \n            chmax(ma,X[l]+X[r]);\n            l++;\n            r--;\n        }\n        if(ma<=lim) right=mid;\n        else left=mid;\n    }\n    if(right==M) ok=false;\n    else{\n        C[u]=X[right];\n        if(C[u]>lim) ok=false;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    DFS(0,-1);\n    \n    int left=0,right=N;\n    \n    while(right-left>1){\n        ok=true;\n        lim=(left+right)/2;\n        for(int i=0;i<N;i++){\n            B[i]=0;\n            C[i]=0;\n        }\n        solve(0,-1);\n        \n        if(ok) right=lim;\n        else left=lim;\n    }\n    \n    cout<<A[0]<<\" \"<<right<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[110000];\nint n;\n\nbool check2(vector<int>& c, int idx, int k) {\n    vector<int> v = c;\n    v.erase(v.begin() + idx);\n\n    for (int i = 0; i < v.size()/2; i++) {\n        if (v[i] + v[v.size()-i-1] > k) {\n            //cout << \"oops \" << i << \" \" << v[i] << \" \" << n-i-1 << \" \" << v[n-i-1] << endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int v, int p, int k) {\n    vector<int> children;\n\n    for (int x : g[v]) if (x != p) {\n        children.push_back( dfs(x, v, k) );\n        if (children.back() > k) return k+2;\n    }\n\n    if (children.size() % 2 != 1) children.push_back(0);\n    sort(children.begin(), children.end());\n\n    int cc = children.size();\n    \n    int st = 0, ed = cc-1;\n    while (st < ed) {\n        int md = (st+ed)/2;\n\n        if (check2(children, md, k)) ed = md;\n        else st = md+1;\n    }\n\n    // cout << v+1 << \" \" << st << \" \" << check2(children,st,k) << \" \" << k << endl;\n    // if (children.size() >= 3) cout << children[0] << \" \" << children[1] << \" \" << children[2] << endl;\n\n    if (!check2(children,st,k)) return k+2;\n    return children[st]+1;\n}\n\nint check(int k) {\n    return dfs(0,-1,k) < k+2;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int u,v; cin >> u >> v; u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int ends = 0;\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() % 2 == 1) ends++;\n    }\n\n    int st = 1, ed = n-1;\n    // int st = 5, ed = 6;\n    while (st < ed) {\n        int md = (st+ed)/2;\n        if (check(md)) ed = md;\n        else st = md+1;\n    }\n\n    cout << ends/2 << \" \" << st << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ri register int\n\n#define SIZE 100000\n#define ll long long\n    //fread->read\n    bool Error=0;\n    inline char nc() {\n        static char buf[SIZE],*p1=buf+SIZE,*pend=buf+SIZE;\n        if (p1==pend) {\n            p1=buf;\n            pend=buf+fread(buf,1,SIZE,stdin);\n            if (pend==p1) {\n                Error=1;\n                return -1;\n            }\n        }\n        return *p1++;\n    }\n    inline bool blank(char ch) {\n        return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';\n    }\n    inline void read(ri &x) {\n        bool sign=0;\n        char ch=nc();\n        x=0;\n        for (; blank(ch); ch=nc());\n        if (Error)return;\n        if (ch=='-')sign=1,ch=nc();\n        for (; ch>='0'&&ch<='9'; ch=nc())x=x*10+ch-'0';\n        if (sign)x=-x;\n    }\n\n#undef ll\n#undef SIZE\n\nint n;\n\nint cnt,head[100005];\nstruct edge{\n\tint to,next;\n}e[100005<<1];\ninline void addedge(ri u,ri v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nint sz[100005],a[100005];\nbool ok;\nbool check0(ri t,ri mid,ri x){\n\tfor(ri i=1,j=t;i<=j;i++,j--){\n\t\tif(i==mid)\n\t\t\ti++;\n\t\tif(j==mid)\n\t\t\tj--;\n\t\tif((a[i]+a[j]>=x&&i!=j)||a[i]>=x)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\ninline void dfs(ri u,ri fa,ri x){\n\tri t=0;\n\tfor(ri i=head[u];i;i=e[i].next){\n\t\tri v=e[i].to;\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tdfs(v,u,x);\n\t}\n\tmemset(a,0,sizeof(a));\n\tfor(ri i=head[u];i;i=e[i].next){\n\t\tri v=e[i].to;\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\ta[++t]=sz[v];\n\t}\n\tcnt+=t/2;\n\tsort(a+1,a+t+1);\n\tri l=1,r=t,tmp=0;\n\twhile(r-l>1){\n\t\tri mid=(l+r)>>1;\n\t\tif(check0(t,mid,x)&&a[mid]<x)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid;\n\t}\n\tif(check0(t,l,x)&&a[l]<x)\n\t\ttmp=l;\n\telse if(check0(t,r,x)&&a[r]<x)\n\t\t\ttmp=r;\n\t\telse\n\t\t\tok=0;\n\tsz[u]=a[tmp]+1;\n}\ninline bool check(ri x){\n\tcnt=0;\n\tok=1;\n\tmemset(sz,0,sizeof(sz));\n\tdfs(1,0,x);\n\tfor(ri i=1;i<=n;i++)\n\t\tif(sz[i]>x)\n\t\t\tok=0;\n\treturn ok;\n}\n\nint main(){\n\tread(n);\n\tfor(ri i=1;i<n;i++){\n\t\tri u,v;\n\t\tread(u),read(v);\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tri l=1,r=n;\n\twhile(r-l>1){\n\t\tri mid=(l+r)>>1;\n\t\tif(check(mid))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid;\n\t}\n\tprintf(\"%d \",cnt+1);\n\tif(check(l))\n\t\tprintf(\"%d\",l-1);\n\telse\n\t\tprintf(\"%d\",r-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (300006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=30;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 1500000;\nconst int K = 50 ;\nvector < int > g[N];\nint cnt;\npair < int, int > dfs1(int v, int p = -1){\n    int c = 0;\n    int res = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto x = dfs1(u, v);\n        c += x.F;\n        res += x.S;\n    }\n    res -= c / 2;\n    c %= 2;\n    if (c == 0 && p != -1){\n        c++;\n        res++;\n    }\n    return {c, res};\n}\nint dfs2(int v, int x, int p = -1){\n    multiset < int > t;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto y = dfs2(u, x, v);\n        t.insert(y);\n    }\n    vector < int > f1;\n    while(t.size() > 1){\n        auto y = t.end();\n        y--;\n        auto q = t.begin();\n        int q1 = *q;\n        q++;\n        int q2 = *q;\n        if (q1 + q2 > x) break;\n        auto z = t.upper_bound(x - (*y));\n        while(z == t.end() || z == y) z--;\n        if (z == y) z--;\n        int v1 = *z;\n        int v2 = *y;\n        if (v1 + v2 > x){\n            f1.pb(v2);\n            t.erase(t.find(v2));\n            continue;\n        }\n        t.erase(t.find(v1));\n        t.erase(t.find(v2));\n        cnt--;\n    }\n    for (auto i: f1) t.insert(i);\n    if (t.size() == 0){;\n        cnt += (p != -1);\n        return 1;\n    }\n    if (p == -1) return 0;\n    if (*t.begin() + 1 > x){\n        cnt++;\n        return 1;\n    }\n    return (*t.begin()) + 1;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    int ans1 = dfs1(1).S;\n    int l = 0;\n    int r = n + 1;\n    while(r - l > 1){\n        int mid = (r + l) / 2;\n        cnt = 0;\n        dfs2(1, mid);\n        if (cnt <= ans1){\n            r = mid;\n        } else{\n            l = mid;\n        }\n    }\n    cout << ans1 << \" \" << r;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    assert(V[1].size()%2!=0);\n    ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> conn[100050];\nvector <int> son[100050];\nbool dchk[100050];\nvoid DFS1(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) {\n\t\tif (dchk[it]) continue;\n\t\tson[n].push_back(it);\n\t\tDFS1(it);\n\t}\n}\n\nint N;\nint tus;\nint dp[100050][2];\nvector <int> Vu[100050];\nvoid DFS2(int n) {\n\tdp[n][0] = 0;\n\tdp[n][1] = 0;\n\tVu[n].clear();\n\tfor (auto it : son[n]) {\n\t\tDFS2(it);\n\t\tdp[n][0] += dp[it][0];\n\t\tif (dp[it][1] >= tus) {\n\t\t\tdp[n][0]++;\n\t\t\tVu[n].push_back(1);\n\t\t}\n\t\telse Vu[n].push_back(dp[it][1]);\n\t}\n\tsort(all(Vu[n]));\n\n\tint st = 1, en = Vu[n].size() / 2, mi, rv = 0, i;\n\twhile (st <= en) {\n\t\tmi = (st + en) / 2;\n\t\tfor (i = 0; i < mi; i++) if (Vu[n][i] + Vu[n][2 * mi - 1 - i] + 1 > tus) break;\n\t\tif (i >= mi) {\n\t\t\trv = mi;\n\t\t\tst = mi + 1;\n\t\t}\n\t\telse en = mi - 1;\n\t}\n\tdp[n][0] += Vu[n].size() - rv;\n\tif (rv * 2 == Vu[n].size()) {\n\t\tdp[n][1] = 1;\n\t\treturn;\n\t}\n\n\tdp[n][0]--;\n\tint st2 = 0, en2 = 2 * rv - 1, mi2, rv2 = 2 * rv;\n\twhile (st2 <= en2) {\n\t\tmi2 = (st2 + en2) / 2;\n\t\tfor (i = 0; i < rv; i++) {\n\t\t\tint t1 = i, t2 = 2 * rv - i - 1;\n\t\t\tif (t1 >= mi2) t1++;\n\t\t\tif (t2 >= mi2) t2++;\n\t\t\tif (Vu[n][t1] + Vu[n][t2] + 1 > tus) break;\n\t\t}\n\t\tif (i >= rv) {\n\t\t\trv2 = mi2;\n\t\t\ten2 = mi2 - 1;\n\t\t}\n\t\telse st2 = mi2 + 1;\n\t}\n\tdp[n][1] = 1 + Vu[n][rv2];\n}\nint getv(int x) {\n\ttus = x;\n\tDFS2(1);\n\treturn dp[1][0] + !!(dp[1][1] - 1);\n}\nint main() {\n\tint i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i < N; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tconn[t1].push_back(t2);\n\t\tconn[t2].push_back(t1);\n\t}\n\tDFS1(1);\n\n\tint st = 2, en = N-1, mi, rv = N;\n\twhile (st <= en) {\n\t\tmi = (st + en) / 2;\n\t\tif (getv(mi) == getv(rv)) {\n\t\t\trv = mi;\n\t\t\ten = mi - 1;\n\t\t}\n\t\telse st = mi + 1;\n\t}\n\tprintf(\"%d %d\\n\", getv(rv), rv - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\n\nint A, B;\n\nbool flag;\n\nint dfs(int v, int p) {\n    vector<int> vec;\n    for(int u : G[v])\n        if(p != u) {\n            vec.push_back(dfs(u, v) + 1);\n            if(vec.back() > B) return mod;\n        }\n    sort(ALL(vec));\nx:;\n    if(vec.size() & 1) {\n        int ng = -1, ok = vec.size();\n    y:;\n        while(ng + 1 < ok) {\n            int mid = ng + ok >> 1;\n            int i = 0, j = vec.size() - 1;\n            while(i < j) {\n                if(mid == i) i++;\n                if(mid == j) j--;\n                if(vec[i] + vec[j] > B) {\n                    ng = mid;\n                    goto y;\n                }\n                i++;\n                j--;\n            }\n            if(ng != mid) ok = mid;\n        }\n        if(ok == (int)vec.size())\n            return mod;\n        else\n            return vec[ok];\n    } else {\n        bool ok = true;\n        rep(i, vec.size() - i) if(vec[i] + vec[n - i - 1] > B) ok = false;\n        if(ok) return 0;\n        vec.pop_back();\n        goto x;\n    }\n}\n\nbool isok() { return dfs(0, -1) <= B; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    A = 0;\n    rep(i, n) A += G[i].size() % 2;\n\n    A /= 2;\n\n    int ng = 0, ok = n;\n    while(ng < ok - 1) {\n        B = ok + ng >> 1;\n        (isok() ? ok : ng) = B;\n    }\n\n    cout << A << \" \" << ok << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n \n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n \nconst int N = 100100;\nint n;\nvector<int> g[N];\nint dp[N];\nint m;\n \nbool solve(int v, int par) {\n\tvector<int> a;\n\tif ((int)g[v].size() & 1) a.push_back(0);\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tif (!solve(u, v)) return false;\n\t\tif (dp[u] != -1)\n\t\t\ta.push_back(dp[u] + 1);\n\t}\n\tsort(a.begin(), a.end());\n/*\n\tprintf(\"%d :\", v);\n\tfor (int x : a)\n\t\tprintf(\" %d\", x);\n\tprintf(\"\\n\");\n*/\n\tif ((int)a.size() & 1) {\n\t\tint l = -1, r = (int)a.size();\n\t\twhile(r - l > 1) {\n\t\t\tint x = (l + r) / 2;\n\t\t\tint p1 = 0, p2 = (int)a.size() - 1;\n\t\t\tbool ok = true;\n\t\t\twhile(p1 < p2) {\n\t\t\t\tif (p1 == x) p1++;\n\t\t\t\tif (p2 == x) p2--;\n\t\t\t\tif (a[p1] + a[p2] > m) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp1++;\n\t\t\t\tp2--;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tr = x;\n\t\t\telse\n\t\t\t\tl = x;\n\t\t}\n\t\tif (r == (int)a.size()) return false;\n\t\tdp[v] = a[r];\n\t\treturn true;\n\t} else {\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\tif (a[i] + a[(int)a.size() - 1 - i] > m)\n\t\t\t\treturn false;\n\t\tdp[v] = -1;\n\t\treturn true;\n\t}\n}\n \nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n \n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += (int)g[i].size() & 1;\n\tprintf(\"%d \", ans / 2);\n\tint l = 0, r = n;\n\twhile(r - l > 1) {\n\t\tm = (l + r) / 2;\n\t\tif (solve(0, -1))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m;\n\t}\n\tprintf(\"%d\\n\", r);\n \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u));\n    if(vals.size() == 0) return 1;\n    if(vals.size()%2 == 0) {\n        if( u == 0 ){\n            for(int i = 0, j = vals.size()-1; i < j; i++, j--) if(vals[i] + vals[j] > B) return B+1;\n            return 0;\n        }\n        \n        vals.pb(0);\n    }\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size()-1;\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    //cout << \"leastUp \" << u << \": \" << vals[rb]+1 << endl;\n    return vals[rb]+ (u != 0);\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    return l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 10005;\n\nint n;\nvector<int> gph[MAXN];\nvector<int> dfn;\n\nint dp[MAXN];\n\nint query(int k){\n\tfor(auto &i : dfn){\n\t\tif(i == 1) break;\n\t\tvector<int> v;\n\t\tfor(auto &j : gph[i]) v.push_back(dp[j] + 1);\n\t\tsort(v.begin(), v.end());\n\t\tauto trial_pos = [&](int x){\n\t\t\tint l = 0, r = v.size() - 1;\n\t\t\tfor(int i=0; i<v.size()/2; i++){\n\t\t\t\tif(l == x) l++;\n\t\t\t\tif(r == x) r--;\n\t\t\t\tif(v[l] + v[r] > k) return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\t\tif(v.size() % 2 == 0){\n\t\t\tv.insert(v.begin(), 0);\n\t\t\tint s = 0, e = v.size();\n\t\t\twhile(s != e){\n\t\t\t\tint m = (s+e)/2;\n\t\t\t\tif(trial_pos(m)) e = m;\n\t\t\t\telse s = m + 1;\n\t\t\t}\n\t\t\tif(s == v.size()) return 0;\n\t\t\tdp[i] = v[s];\n\t\t}\n\t\telse{\n\t\t\tint s = 0, e = v.size();\n\t\t\twhile(s != e){\n\t\t\t\tint m = (s+e)/2;\n\t\t\t\tif(trial_pos(m)) e = m;\n\t\t\t\telse s = m + 1;\n\t\t\t}\n\t\t\tif(s == v.size()) return 0;\n\t\t\tdp[i] = v[s];\n\t\t}\n\t}\n\tvector<int> v;\n\tfor(auto &i : gph[1]) v.push_back(dp[i] + 1);\n\tsort(v.begin(), v.end());\n\tif(v.back() > k) return 0;\n\tif(v.size() % 2 == 1) v.pop_back();\n\tfor(int i=0; i<v.size()/2; i++){\n\t\tif(v[i] + v[v.size()-i-1] > k) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int x){\n\tdfn.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tgph[i].erase(find(gph[i].begin(), gph[i].end(), x));\n\t\tdfs(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1);\n\tint ans = n - 1;\n\tfor(int i=1; i<=n; i++){\n\t\tans -= ((i != 1) + gph[i].size()) / 2;\n\t}\n\tint s = 1, e = n;\n\treverse(dfn.begin(), dfn.end());\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(!query(m)) s = m+1;\n\t\telse e = m;\n\t}\n\tprintf(\"%d %d\\n\", ans, s);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int MAX=200040;\nconst ll MOD=1000000007;\nvector<int> conn[MAX],dir[MAX],tmp[MAX];\nint a,b,com=0,par[MAX],n;\nvoid dfs(int x,int p){\n    par[x]=p;\n    for(int i=0;i<conn[x].size();i++) if(conn[x][i]!=p) dfs(conn[x][i],x);\n}\nint div2(int v,int x,int y,int u){\n    if(y-x==1) return x;\n    int p=(x+y)/2,p1=0,p2=tmp[v].size()-1,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n        if(p1==p) p1++;\n        if(p2==p) p2--;\n    }\n    if(pos) return div2(v,x,p,u);\n    return div2(v,p,y,u);\n}\nint f(int x,int u){\n    tmp[x].clear();\n    if(dir[x].size()==0) return 0;\n    for(int i=0;i<dir[x].size();i++){\n        int t=f(dir[x][i],u)+1;\n        if(t==0) return -1;\n        tmp[x].push_back(t);\n    }\n    if(tmp[x].size()%2==0) tmp[x].push_back(0);\n    sort(tmp[x].begin(),tmp[x].end());\n    int t=div2(x,0,tmp[x].size()+1,u);\n    if(t==tmp[x].size()) return -1;\n    if(tmp[x][t]>u) return -1;\n    //printf(\"%d %d\\n\",x,tmp[x][t]);\n    return tmp[x][t];\n}\nint div22(int x,int y){\n    if(y-x==1) return x;\n    int p=(x+y)/2,u=f(com,p);\n    if(u==-1) return div22(p,y);\n    return div22(x,p);\n}\nint main(){\n    scanf(\" %d\",&n);\n    for(int i=0;i<n-1;i++){\n        int t1,t2;\n        scanf(\" %d %d\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(int i=1;i<=n;i++) if(conn[i].size()%2) com=max(i,com), a+=1;\n    a/=2;\n    dfs(com,0);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<conn[i].size();j++) if(conn[i][j]!=par[i]) dir[i].push_back(conn[i][j]);\n    }\n    b=div22(1,n)+1;\n    printf(\"%d %d\\n\",a,b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#  include <intrin.h>\n#  define __builtin_popcount __popcnt\n#endif\n\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <list>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) os << *i << (i == end(v) - 1 ? \"\" : \" \"); return os;\n}\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) is >> *i; return is;\n}\n\nvector<int> edg[101000];\n\nint dfs(int i, int max_sz, int parent = -1)\n{\n\tvector<int> arr;\n\tfor (int u : edg[i])\n\t{\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tint add = dfs(u, max_sz, i) + 1;\n\t\tarr.push_back(add);\n\t\tif (add > max_sz)\n\t\t\tthrow 1;\n\t}\n\n\t\n\tif (arr.size() % 2 == 0)\n\t{\n#if 0\n\t\tbool ok = true;\n\t\tfor (int i = 0, j = arr.size() - 1; i < j; i++, j--)\n\t\t{\n\t\t\tif ((arr[i] + arr[j]) > max_sz)\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok)\n\t\t\treturn 0;\n\t\tarr.pop_back();\n#endif\n\t\tarr.push_back(0);\n\t}\n\n\tsort(arr.begin(), arr.end());\n\n\t{\n\t\tint left = 0, right = arr.size();\n\t\twhile (left < right)\n\t\t{\n\t\t\tint m = (left + right) / 2;\n\n\t\t\tvector<int> tmp;\n\t\t\tfor (int j = 0; j < arr.size(); j++)\n\t\t\t{\n\t\t\t\tif (j != m)\n\t\t\t\t\ttmp.push_back(arr[j]);\n\t\t\t}\n\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0, j = tmp.size() - 1; i < j; i++, j--)\n\t\t\t{\n\t\t\t\tif ((tmp[i] + tmp[j]) > max_sz)\n\t\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tright = m;\n\t\t\telse\n\t\t\t\tleft = m + 1;\n\t\t}\n\n\t\tif (left == arr.size())\n\t\t\tthrow 1;\n\t\treturn arr[left];\n\t}\n}\n\nint main()\n{\n#if defined(_DEBUG) \n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedg[a].push_back(b);\n\t\tedg[b].push_back(a);\n\t}\n\n\tint A = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (edg[i].size() % 2 == 1)\n\t\t\tA++;\n\t}\n\n\tA /= 2;\n\n\tint left = 0, right = n;\n\twhile (left < right)\n\t{\n\t\tint m = (left + right) / 2;\n\t\ttry\n\t\t{\n\t\t\tdfs(0, m, -1);\n\t\t}\n\t\tcatch (int)\n\t\t{\n\t\t\tleft = m + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tright = m;\n\t}\n\n\tcout << A << \" \" << left;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(node == 5 && length == 5){\n\t\t\t//pe(b);\n\t\t}\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0 || de > table.size()){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}else{\n\t\t\tnum = i;\n\t\t}\n\t}\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\t//num = 5;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(!(v.size()&1)) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\tint l=0,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << (cnt+1)/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1 << 30;\nvector<int> G[100000];\nint dp[100000];\nbool check(vector<int> &vec, int m, int B) {\n\tvector<int> tmp;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (i != m) tmp.push_back(vec[i]);\n\t}\n\tint N = tmp.size();\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tif (tmp[i] + tmp[N - i - 1] > B) return 0;\n\t}\n\treturn 1;\n}\nint solve(int v, int p, int B) {\n\tif (dp[v] != -1) return dp[v];\n\tvector<int> child;\n\tfor (int u : G[v]) {\n\t\tif (u == p) continue;\n\t\tint ret = solve(u, v, B) + 1;\n\t\tif (ret > B) {\n\t\t\treturn dp[v] = 1 << 30;\n\t\t}\n\t\tchild.push_back(ret);\n\t}\n\tif (child.size() == 0) {\n\t\treturn dp[v] = 0;\n\t}\n\tsort(child.begin(), child.end());\n\tint N = child.size();\n\tif (N % 2==0) {\n\t\tbool ok = 1;\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tif (child[i] + child[N - i - 1] > B) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) return dp[v] = 0;\n\t\tchild.pop_back();\n\t\tN--;\n\t}\n\tint l = -1, r = N - 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(child, m, B)) r = m;\n\t\telse l = m;\n\t}\n\tif (check(child, r, B)) {\n\t\treturn dp[v] = child[r];\n\t}\n\treturn dp[v] = 1 << 30;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint root = 0;\n\tint odd = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() % 2) {\n\t\t\todd++;\n\t\t\troot = i;\n\t\t}\n\t}\n\tint l = -1, r = N;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tsolve(root, -1, m);\n\t\tif (dp[root] <= m) r = m;\n\t\telse l = m;\n\t}\n\tcout << odd / 2 << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\twhile((int)sak[u].size()>2){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif((int)sak[u].size()==2){\n\t\tit=sak[u].begin(),itt=it;\n\t\titt++;\n\t\tif(*it+*itt<=B) return 0;\n\t\tif(fa==-1){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn *it;\n\t}\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,res[N],A,B,l,r,mid;\nvector<int> e[N];\nbool ok;\nint rest(vector<int> &L){\n\tif (!(L.size()&1)) L.push_back(0);\n\tsort(L.begin(),L.end());\n\tfor (int l=0,r=L.size()-2;l<r;l++,r--)\n\tif (L[l]+L[r]>mid) ok=0;\n\tint p=L.size()-1,len=p;\n\twhile (p&&L[p]+L[len-p+(len-p>=p)]<=mid) p--;\n\treturn L[p];\n}\nvoid solve(int x,int fa){\n\tvector<int> L;\n\tfor (auto v:e[x])\n\tif (v!=fa) solve(v,x),L.push_back(res[v]+1);\n\tif (fa) res[x]=rest(L);\n\telse{\n\t\tif (L.size()&1) L.push_back(0);\n\t\tsort(L.begin(),L.end());\n\t\tfor (int l=0,r=L.size()-1;l<r;l++,r--)\n\t\tif (L[l]+L[r]>mid) ok=0;\n\t}\n}\nbool check(){\n\tok=1;\n\tsolve(1,0);\n\treturn ok&&res[1]<=mid;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tA=n-1;\n\tfor (int i=1;i<=n;i++) A-=e[i].size()/2;\n\tfor (l=0,r=n-1;l<r;){\n\t\tmid=(l+r)>>1;\n\t\tif (check()) r=mid;else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint N;\nvector<int> g[100010];\nint d[100010];\nint dp[100010];\n\nbool dfs(int v,int pre,int X){\n  vector<int> w;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    if(!dfs(nv,v,X))return false;\n    w.push_back(dp[nv]+1);\n  }\n  if(d[v])w.push_back(0);\n  sort(all(w));\n  int m=w.size();\n  if(m%2==0){ // r\n    rep(j,m)if(w[j]+w[m-1-j]>X)return false;\n  }else{\n    int lb=-1,ub=m;\n    while(ub-lb>1){\n      int mid=(lb+ub)/2;\n      bool ok=true;\n      int l=0,r=m-1;\n      if(l==mid)l++;\n      if(r==mid)r--;\n      while(l<r){\n        if(w[l]+w[r]>X)ok=false;\n        l++; if(l==mid)l++;\n        r--; if(r==mid)r--;\n      }\n      if(ok) ub=mid;\n      else lb=mid;\n    }\n    if(ub==m)return false;\n    dp[v]=w[ub];\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  cin>>N;\n  rep(i,N-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);g[b].push_back(a);\n  }\n  memset(dp,-1,sizeof(dp));\n\n  int A=0;\n  rep(i,N){\n    if((int)g[i].size()%2==1)A++;\n    d[i]=(int)g[i].size()%2;\n  }\n  A/=2;\n\n  int lb=0,ub=N;\n  while(ub-lb>1){\n    int mid=(lb+ub)/2;\n    if(dfs(0,-1,mid))ub=mid;\n    else lb=mid;\n  }\n  cout<<A<<\" \"<<ub<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nint n, ansA, leftover[MAXN];\nvector<int> adj[MAXN];\n\nint getA(int pos, int prev){\n\tint sum = 0;\n\tfor(int i : adj[pos]) if(i != prev){\n\t\tsum += getA(i, pos);\n\t}\n\tif(prev != 0)\n\t\tsum += (adj[pos].size()-1)/2;\n\telse\n\t\tsum += (adj[pos].size()+1)/2;\n\treturn sum;\n}\n\nbool possible(int pos, int prev, int b){\n\tvector<int> lens = {};\n\t// printf(\"Goto %d\\n\", pos);\n\tfor(int i : adj[pos]) if(i != prev){\n\t\tif(!possible(i, pos, b))\n\t\t\treturn false;\n\t\tlens.push_back(leftover[i]+1);\n\t}\n\tsort(lens.begin(), lens.end());\n\t// printf(\"Working with %d (%d)\\n\", pos, lens.size());\n\tmultiset<int> vacant;\n\tfor(int i = lens.size()-1; i >= 0; --i){\n\t\t// printf(\"(%d)\", lens[i]);\n\t\tint comp = b-lens[i];\n\t\tauto lb = vacant.lower_bound(-comp);\n\t\tif(lb != vacant.end()){\n\t\t\tvacant.erase(lb);\n\t\t}else{\n\t\t\tvacant.insert(-lens[i]);\n\t\t}\n\t}\n\t// printf(\"\\n\");\n\tif(vacant.size() > 2)\n\t\treturn false;\n\telse if(vacant.size() == 2){\n\t\tint u = -(*vacant.begin()); vacant.erase(vacant.begin());\n\t\tint v = -(*vacant.begin());\n\t\tassert(u >= v);\n\t\tif(u+v <= b)\n\t\t\tleftover[pos] = 0; // Case 1 : Combine two leftovers\n\t\telse if(u <= b)\n\t\t\tleftover[pos] = v; // Case 2 : Cut one leftover, extend the other\n\t\telse\n\t\t\treturn false;\n\n\t}else if(vacant.size() == 1){\n\t\tleftover[pos] = -(*vacant.begin());\n\t}else{\n\t\tleftover[pos] = 0;\n\t}\n\treturn true;\n}\n\nbool cekB(int b){\n\tmemset(leftover, 0, sizeof leftover);\n\t// printf(\"Ceking %d\\n\", b);\n\treturn (possible(1, 0, b) && leftover[1] <= b);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n-1; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tansA = getA(1, 0);\n\n\t// TODO: Get B!\n\tint L = 1, R = n;\n\twhile(L < R){\n\t\tint mid = (L+R)/2;\n\t\tif(cekB(mid)){\n\t\t\tR = mid;\n\t\t}else{\n\t\t\tL = mid+1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ansA, L);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(t.size()%2==0){\n\t\tif(t.back()>h)return out;\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=0,r=t.size();\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tif(f(t,l))cmin(out,t[l]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nvector<int>G[N];\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=G[u].size()/2;\n}\ninline void dfs_ans(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs_ans(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t}\n\tsort(G[u].begin(),G[u].end());\n\t/*\n\tprintf(\"%d: \",u);\n\tFor(i,0,G[u].size()-1)printf(\"%d \",G[u][i]);\n\tputs(\"\");\n\t*/\n\tif(G[u].size()&1)\n\t{\n\t\tdis[u]=G[u].back();\n\t\tint last=G[u].size()-2;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<=i)break;\n\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t{\n\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\tflag=0;\n\t\t\t}\n\t\t\tlast--;\n\t\t}\n\t}\n\telse\n\t{\n\t\tdis[u]=0;\n\t\tint last=G[u].size()-1,ret=0;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<=i)break;\n\t\t\tchkmax(ret,G[u][i]+G[u][last]);\n\t\t\tlast--;\n\t\t}\n\t\tif(ret>len)\n\t\t{\n\t\t\tif(G[u].back()>len)flag=0;\n\t\t\tdis[u]=G[u][G[u].size()-2];\n\t\t\tlast=G[u].size()-3;\n\t\t\tFor(i,0,G[u].size()-1)\n\t\t\t{\n\t\t\t\tif(last<=i)break;\n\t\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t\tlast--;\n\t\t\t}\n\t\t}\n\t}\n}\ninline bool check(int x)\n{\n\tFor(i,1,n)\n\t{\n\t\tG[i].clear();\n\t\tdis[i]=0;\n\t}\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\tif((G[1].size()&1)&&G[1].back()>len)flag=0;\n\t//printf(\"%d %d\\n\",len,flag);\n\treturn flag;\n}\nint main()\n{\n\tint x,y;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(G[1].size()&1)dp[1]++;\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int r;\n    for (r = 0; tree[r].size() > 1; ++r) {}\n\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(r, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int MAX=200040;\nconst ll MOD=1000000007;\nvector<int> conn[MAX],dir[MAX],tmp[MAX];\nint a,b,com=0,par[MAX],n;\nvoid dfs(int x,int p){\n    par[x]=p;\n    for(int i=0;i<conn[x].size();i++) if(conn[x][i]!=p) dfs(conn[x][i],x);\n}\nint simple(int v,int u){\n    int p1=0,p2=tmp[v].size()-2,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n    }\n    return pos;\n}\nint div2(int v,int x,int y,int u){\n    if(y-x==1) return x;\n    int p=(x+y)/2,p1=0,p2=tmp[v].size()-1,pos=1;\n    if(p1==p) p1++;\n    if(p2==p) p2--;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n        if(p1==p) p1++;\n        if(p2==p) p2--;\n    }\n    if(pos) return div2(v,x,p,u);\n    return div2(v,p,y,u);\n}\nint f(int x,int u){\n    tmp[x].clear();\n    if(dir[x].size()==0) return 0;\n    for(int i=0;i<dir[x].size();i++){\n        int t=f(dir[x][i],u)+1;\n        if(t==0) return -1;\n        tmp[x].push_back(t);\n    }\n    if(tmp[x].size()%2==0) tmp[x].push_back(0);\n    sort(tmp[x].begin(),tmp[x].end());\n    if(simple(x,u)==0) return -1;\n    int t=div2(x,0,tmp[x].size(),u);\n    if(tmp[x][t]>u) return -1;\n    //printf(\"%d %d\\n\",x,tmp[x][t]);\n    return tmp[x][t];\n}\nint div22(int x,int y){\n    if(y-x==1) return x;\n    int p=(x+y)/2,u=f(com,p);\n    if(u==-1) return div22(p,y);\n    return div22(x,p);\n}\nint main(){\n    scanf(\" %d\",&n);\n    for(int i=0;i<n-1;i++){\n        int t1,t2;\n        scanf(\" %d %d\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(int i=1;i<=n;i++) if(conn[i].size()%2) com=max(i,com), a+=1;\n    a/=2;\n    dfs(com,0);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<conn[i].size();j++) if(conn[i][j]!=par[i]) dir[i].push_back(conn[i][j]);\n    }\n    b=div22(0,n+1)+1;\n    printf(\"%d %d\\n\",a,b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)if(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\tif(u==1&&tt&1){\n\t\tif(now[tt]+1>mid)return false;tt--;\n\t\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);pre=i-1,suf=i;\n\t\twhile(1){\n\t\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\t\telse if(pre>0)tt--,pre--;\n\t\t\telse if(tt-suf==1){\n\t\t\t\tif(u==1)return false;\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else return false;\n\t\t}\n\t}else {\n\t\twhile(1){\n\t\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\t\telse if(pre>0)tt--,pre--;\n\t\t\telse if(tt-suf==1){\n\t\t\t\tif(u==1)return false;\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else return false;\n\t\t}\n\t}\n\t\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;//printf(\"%d\\n\",dp(1,1,3));\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}"
  },
  {
    "language": "C++",
    "code": "# include<bits/stdc++.h>\nusing namespace std;\n# define lowbit(x) ((x)&(-x))\n# define pi acos(-1.0)\n# define eps 1e-8\n# define MOD 1000000007\n# define INF 100000000\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(register int i=a; i<=n; ++i)\n# define FDR(i,a,n) for(register int i=a; i>=n; --i)\n# define bug puts(\"H\");\n# define lch p<<1,l,mid\n# define rch p<<1|1,mid+1,r\n# define mp make_pair\n# define pb push_back\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n# pragma comment(linker, \"/STACK:1024000000,1024000000\")\ntypedef long long LL;\ninline char nc(){\n    static char buf[1000000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int Scan(){\n    char ch=nc();int sum=0, f=1;\n    if (ch=='-') f=-1, ch=nc();\n    while(!(ch>='0'&&ch<='9'))ch=nc();\n    while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc();\n    return sum*f;\n}\nconst int N=100005;\n\nstruct Edge{int p, next;}edge[N<<1];\nint head[N], dee[N], cnt=1, dep[N];\nint ans;\n\nvoid add_edge(int u, int v){edge[cnt].p=v; edge[cnt].next=head[u]; head[u]=cnt++;}\nvoid dfs(int x, int fa)\n{\n    dep[x]=dep[fa]+1;\n    if (fa==0) ans+=(dee[x]+1)/2;\n    else ans+=(dee[x]-1)/2;\n    for (int i=head[x]; i; i=edge[i].next) {\n        int v=edge[i].p;\n        if (v==fa) continue;\n        dfs(v,x);\n    }\n}\nvoid dfs2(int x, int fa){\n    dep[x]=dep[fa]+1;\n    for (int i=head[x]; i; i=edge[i].next) {\n        int v=edge[i].p;\n        if (v==fa) continue;\n        dfs2(v,x);\n    }\n}\nint main ()\n{\n    int n, u, v;\n    scanf(\"%d\",&n);\n    FOR(i,1,n-1) scanf(\"%d%d\",&u,&v), add_edge(u,v), add_edge(v,u), ++dee[v], ++dee[u];\n    dfs(1,0);\n    int ma=0, p;\n    for (int i=1; i<=n; ++i) if (ma<dep[i]) ma=dep[i], p=i;\n    dfs2(p,0);\n    ma=0;\n    FOR(i,1,n) ma=max(ma,dep[i]);\n    printf(\"%d %d\\n\",ans,ma-1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint nt[N << 1], to[N << 1], head[N], cnt = 0;\n\nvoid add(int x, int y) {\n  to[++cnt] = y;\n  nt[cnt] = head[x];\n  head[x] = cnt;\n}\n\nint f[N], g[N], ans = 0;\nvoid predfs(int u, int fa) {\n  int s = 0, pos = 0, tmp = 0, mx = 0;\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    predfs(to[i], u);\n    ans = max(ans, mx + g[to[i]] + 1);\n    mx = max(mx, g[to[i]] + 1);\n    pos += f[to[i]];\n    tmp++;\n  }\n  g[u] = mx;\n  f[u] = pos + (tmp / 2);\n  if(u == 1) f[u] += tmp & 1;\n  if(!tmp) f[u] = 0;\n}\n\nint lmt, flg, up[N], A, B, num, st[N];\nmultiset<int> S;\nmultiset<int> :: iterator sit;\nvoid dfs(int u, int fa) {\n  if(!flg) return ;\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    dfs(to[i], u);\n  }\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    if(f[to[i]] + 1 > lmt) {\n      flg = 0;\n      return ;\n    }\n    S.insert(f[to[i]] + 1);\n  }\n  int top = 0;\n  while(S.size() > 1) {\n    int pos = *S.rbegin();\n    S.erase(S.find(pos));\n    if(*S.rbegin() + pos <= lmt) {\n      num++;\n      int tmp = *S.rbegin();\n      S.erase(S.find(tmp));\n    } else if(*S.begin() + pos > lmt) {\n      st[++top] = pos;\n    } else {\n      sit = S.upper_bound(lmt - pos);\n      sit--;\n      num++;\n      S.erase(sit);\n    }\n  }\n  if(S.size()) {\n    st[++top] = *S.begin();\n    S.clear();\n  }\n  f[u] = 0;\n  if(top) {\n    sort(st + 1, st + 1 + top);\n    if(top & 1) f[u] = st[1];\n    num += top / 2;\n  }\n}\n\nbool check(int x) {\n  flg = 1;\n  lmt = x, num = 0;\n  dfs(1, 0);\n//  printf(\"qwq%d %d\\n\", x, num);\n  return flg && num <= A;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for(int i = 2, x, y; i <= n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    add(x, y), add(y, x);\n  }\n  memset(f, 0x3f, sizeof f);\n  predfs(1, 0);\n  A = f[1];\n  int l = 1, r = ans;\n  while(l <= r) {\n    int mid = (l + r) >> 1;\n    if(check(mid)) r = mid - 1, B = mid;\n    else l = mid + 1;\n  }\n  printf(\"%d %d\\n\", A, B);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n#include<random>\n\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tif (d[j][i] != INF && d[i][k] != INF)chmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tvector<int> in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<int, vector<int>, greater<int>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tint n;\npublic:\n\tUnionFind(int size) : data(size, -1), n(size) { }\n\tbool merge(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tn -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint num() {//集合の数を返す\n\t\treturn n;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id, vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) {\n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\t\n\tll n;\n\tcin >> n;\n\tGraph g(n);\n\tREP(i, n - 1) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tadd_edge(g, u, v, 1, true, 1);\n\t}\n\tll a = 0;\n\tREP(i, n)a += g[i].size() % 2;\n\tll l = 0, r = n;\n\twhile (r - l > 1) {\n\t\tll m = (r + l) / 2;\n\t\tauto dfs = [&](auto dfs, ll v, ll par)->ll {\n\t\t\tmultiset<ll> a;\n\t\t\tif (g[v].size() % 2 == 1)a.insert(0);\n\t\t\tfor (auto e : g[v]) {\n\t\t\t\tif (e.to == par)continue;\n\t\t\t\tauto tmp = dfs(dfs, e.to, v);\n\t\t\t\tif (tmp > 0)a.insert(tmp);\n\t\t\t\telse if (tmp == -1)return -1;\n\t\t\t}\n\t\t\tArray ret;\n\t\t\twhile (a.size()) {\n\t\t\t\tauto itr = prev(a.end(), 1);\n\t\t\t\tll x = *itr;\n\t\t\t\ta.erase(itr);\n\t\t\t\titr = a.upper_bound(m - x);\n\t\t\t\tif (itr == a.begin())ret.push_back(x);\n\t\t\t\telse {\n\t\t\t\t\titr--;\n\t\t\t\t\ta.erase(itr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret.size() == 0)return 0;\n\t\t\telse if (ret.size() > 1)return -1;\n\t\t\telse return\tret[0] + 1;\n\t\t\t\n\t\t};\n\t\tif (dfs(dfs, 0, -1) != -1)r = m;\n\t\telse l = m;\n\t}\n\tcout <<a/2<<\" \"<< r << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\n// (個数, 最大値, 伸びてるやつ)\ntri dp[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    vp hoge;\n    each(v, G[u]){\n        if(v != p){\n            dfs(v, u);\n            hoge.pb(P(dp[v].th, v));\n        }\n    }\n    sort(all(hoge));\n    int cnt = len(hoge), mx = 0, res = 0;\n    if(cnt == 1){\n        dp[u] = dp[hoge[0].se];\n        dp[u].th++;\n    }else if(cnt >= 2){\n        if(cnt % 2){\n            // 上げる\n            rep(i,cnt/2){\n                res += dp[hoge[i].se].fi+dp[hoge[cnt-i-1].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n                cmx(mx, dp[hoge[cnt-i-1].se].se);\n            }\n            res += dp[hoge[cnt/2].se].fi;\n            cmx(mx, dp[hoge[cnt/2].se].se);\n            dp[u] = (tri){res, mx, hoge[cnt/2].fi+1};\n            // srep(i,1,cnt/2+1){\n            //     res += dp[hoge[i].se].fi+1;\n            //     cmx(mx, hoge[i].fi+1+hoge[cnt-i].fi+1);\n            //     cmx(mx, dp[hoge[i].se].se);\n            //     cmx(mx, dp[hoge[cnt-i].se].se);\n            // }\n            // res += dp[hoge[0].se].fi;\n            // cmx(mx, dp[hoge[0].se].se);\n            // dp[u] = (tri){res, mx, hoge[0].fi+1};\n        }else{\n            srep(i,1,cnt/2){\n                res += dp[hoge[i].se].fi+dp[hoge[cnt-i-1].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n                cmx(mx, dp[hoge[cnt-i-1].se].se);\n            }\n            // 最初\n            res += dp[hoge[0].se].fi;\n            cmx(mx, dp[hoge[0].se].se);\n            // 最後\n            res += dp[hoge[cnt-1].se].fi+1;\n            cmx(mx, max(dp[hoge[cnt-1].se].se, dp[hoge[cnt-1].se].th+1));\n            dp[u] = (tri){res, mx, hoge[0].fi+1};\n        }\n    }\n    // ashow(u, dp[u]);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        --a, --b;\n        G[a].pb(b), G[b].pb(a);\n    }\n    dfs(0, -1);\n    cout << dp[0].fi+1 << \" \" << max(dp[0].se, dp[0].th) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri) return false;\n        }\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    rep(i,MAX_N) dp[i] = 0;\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100009;\nint n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!fa && !s.empty()) {\n\t\tif (*s.begin() > limit) return -1;\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(rand()*rand()%n+1, 0) == -1) return 0;\n\treturn need == ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs1(rand()*rand()%n+1, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001],d[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l+1;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t\td[u]++;\n\t\td[v]++;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (d[i]%2) ans++;\n\t/*int ans=dfs(1,-1);*/\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\n\nint n;\nvector<int> adj[MAXN];\n\nint cnt[MAXN];\nint parlen[MAXN];\nint mxlen[MAXN];\nint limit;\n\nint cur[MAXN],ncur;\n\nbool dfs(int at,int par) {\n\t//printf(\"dfs(%d,%d)\\n\",at+1,par+1);\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i]; if(to==par) continue;\n\t\tif(!dfs(to,at)) return false;\n\t}\n\tcnt[at]=1,mxlen[at]=0; ncur=0;\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i]; if(to==par) continue;\n\t\tcnt[at]+=cnt[to];\n\t\tmxlen[at]=max(mxlen[at],mxlen[to]);\n\t\tcur[ncur++]=parlen[to];\n\t}\n\tsort(cur,cur+ncur);\n\tint pos=0,nskipped=0,mnskipped=-1,res=-1,single=-1;\n\tfor(int i=ncur-1;i>=0;--i) {\n\t\tif(pos>=i) {\n\t\t\tif(pos==i) {\n\t\t\t\tif(mnskipped==-1) mnskipped=cur[pos];\n\t\t\t\t++nskipped;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(cur[pos]+cur[i]>limit) {\n\t\t\tif(nskipped>0) { --nskipped; if(nskipped==0) mnskipped=-1; continue; }\n\t\t\tif(ncur%2==0&&single==-1) { mxlen[at]=max(mxlen[at],cur[i]); single=cur[i]; continue; }\n\t\t\tif(res==-1) { res=cur[i]+1; continue; }\n\t\t\treturn false;\n\t\t}\n\t\twhile(pos+1<i&&cur[pos+1]+cur[i]<=limit) {\n\t\t\tif(mnskipped==-1) mnskipped=cur[pos];\n\t\t\t++nskipped,++pos;\n\t\t}\n\t\tmxlen[at]=max(mxlen[at],cur[pos]+cur[i]);\n\t\t++pos;\n\t}\n\tnskipped%=2;\n\tif(nskipped==0&&res==-1) res=1;\n\tif(nskipped==1&&res==-1) res=mnskipped+1;\n\tparlen[at]=res; mxlen[at]=max(mxlen[at],parlen[at]); cnt[at]-=(ncur+1)/2;\n\t//printf(\"limit=%d: %d -> cnt=%d parlen=%d mxlen=%d\\n\",limit,at+1,cnt[at],parlen[at],mxlen[at]);\n\t//printf(\"cur:\"); REP(i,ncur) printf(\" %d\",cur[i]); puts(\"\");\n\treturn mxlen[at]<=limit;\t\t\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n-1) { int a,b; scanf(\"%d%d\",&a,&b); --a,--b; adj[a].PB(b); adj[b].PB(a); }\n\t//n=MAXN; REP(i,n-1) adj[0].PB(i+1),adj[i+1].PB(0);\n\n\tint rt=0; while(SZ(adj[rt])!=1) ++rt; //printf(\"rt=%d\\n\",rt+1);\n\tint x=adj[rt][0];\n\tlimit=INT_MAX;\n\tassert(dfs(x,rt));\n\tint rescnt=cnt[x];\n\tint l=0,r=mxlen[x];\n\twhile(l+1<r) {\n\t\tlimit=l+(r-l)/2;\n\t\tif(dfs(x,rt)) r=limit; else l=limit;\n\t}\n\tprintf(\"%d %d\\n\",rescnt,r);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nint n, m;\nvector<int> edge[100001];\n\nint dfs(int x, int p) {\n    multiset<int> child;\n    for (int i : edge[x]) {\n        if (i == p) continue;\n        int ret = dfs(i, x);\n        if (ret > m) return m + 5;\n        child.insert(ret);\n    }\n    if ((child.size() & 1) == 0) child.insert(0);\n    int v = -1;\n    while (child.size() > 1) {\n        int x = *child.rbegin();\n        child.erase(child.find(x));\n        auto it = child.upper_bound(m - x);\n        if (it == child.begin()) {\n            if (v != -1) return m + 5;\n            v = x;\n        }\n        else child.erase(prev(it));\n    }\n    if (v == -1) v = *child.begin();\n    return v + 1;\n}\n\nint check() {\n    return dfs(1, 0) <= m + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    int A = n - 1;\n    for (int i = 1; i <= n; ++i) A -= edge[i].size() >> 1;\n    int s = 1, e = n - 1;\n    while (s < e) {\n        m = (s + e) / 2;\n        if (check()) e = m;\n        else s = m + 1;\n    }\n    printf(\"%d %d\\n\", A, s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n), cnt(n);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        int ch = 0;\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] += dp[u];\n            ch += 1;\n        }\n        dp[x] -= ch / 2;\n        if (ch % 2 == 0 && x != 0) dp[x]++;\n    };\n\n    Dfs(0, -1);\n    int A = dp[0], B = n + 1;\n\n    auto Check = [&](int v) {\n        constexpr int kInf = 1'000'000'000;\n        function<void(int, int)> Dfs = [&](int x, int p) {\n            multiset<int> s;\n            dp[x] = kInf;\n            cnt[x] = 0;\n            for (int u : g[x]) {\n                if (u == p) continue;\n                Dfs(u, x);\n                if (dp[u] > v) return;\n                s.insert(dp[u]);\n                cnt[x] += cnt[u];\n            }\n            if (s.size() & 1) {\n                int z = -1;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        if (z != -1) return;\n                        z = r;\n                    } else {\n                        s.erase(prev(it));\n                        cnt[x]--;\n                    }\n                }\n                dp[x] = z;\n                if (x != 0) dp[x]++;\n                if (dp[x] > v) {\n                    dp[x] = kInf;\n                    return;\n                }\n            } else {\n                auto f = s;\n                bool ok = true;\n                int kc = cnt[x];\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        ok = false;\n                        break;\n                    }\n                    cnt[x]--;\n                    s.erase(prev(it));\n                }\n                if (ok) {\n                    dp[x] = x == 0 ? 0 : 1;\n                    cnt[x] += x == 0 ? 0 : 1;\n                    // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n                    // printf(\"cnt[%d] = %d\\n\", x + 1, cnt[x]);\n                    return;\n                }\n                cnt[x] = kc;\n                auto it = f.upper_bound(x == 0 ? v : v - 1);\n                if (it == f.begin()) return;\n                dp[x] = *prev(it);\n                if (x != 0) dp[x]++;\n                f.erase(prev(it));\n                int z = -1;\n                while (!f.empty()) {\n                    int r = *f.rbegin();\n                    f.erase(f.find(r));\n                    auto it = f.upper_bound(v - r); \n                    if (it == f.begin()) {\n                        if (z != -1) {\n                            dp[x] = kInf;\n                            return;\n                        }\n                        z = r;\n                    } else {\n                        f.erase(prev(it));\n                        cnt[x]--;\n                    }\n                }\n            }\n            // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n            // printf(\"cnt[%d] = %d\\n\", x + 1, cnt[x]);\n        };\n        // printf(\"Check v = %d\\n\", v);\n        Dfs(0, -1);\n        // printf(\"cnt = %d dp = %d\\n\", cnt[0], dp[0]);\n        return cnt[0] == A && dp[0] != kInf;\n    };\n\n    for (int d = 20; d >= 0; --d) {\n        if (B - (1 << d) <= 0) continue;\n        if (Check(B - (1 << d))) B -= (1 << d);\n    }\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n), cnt(n);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        int ch = 0;\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] += dp[u];\n            ch += 1;\n        }\n        dp[x] -= ch / 2;\n        if (ch % 2 == 0 && x != 0) dp[x]++;\n    };\n\n    Dfs(0, -1);\n    int A = dp[0], B = n + 1;\n\n    auto Check = [&](int v) {\n        constexpr int kInf = 1'000'000'000;\n        function<void(int, int)> Dfs = [&](int x, int p) {\n            multiset<int> s;\n            dp[x] = kInf;\n            cnt[x] = 0;\n            for (int u : g[x]) {\n                if (u == p) continue;\n                Dfs(u, x);\n                if (dp[u] > v) return;\n                s.insert(dp[u]);\n                cnt[x] += cnt[u];\n            }\n            if (s.size() & 1) {\n                int z = kInf;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        z = min(z, r);\n                    } else {\n                        s.erase(prev(it));\n                        cnt[x]--;\n                    }\n                }\n                dp[x] = z;\n                if (x != 0) dp[x]++;\n                if (dp[x] > v) {\n                    dp[x] = kInf;\n                    return;\n                }\n            } else {\n                auto f = s;\n                bool ok = true;\n                int kc = cnt[x], z = kInf;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        z = min(z, r);\n                    } else {\n                        cnt[x]--;\n                        s.erase(prev(it));\n                    }\n                }\n                if (z + 1 > v && x > 0) {\n                    dp[x] = 1;\n                    cnt[x]++;\n                } else {\n                    dp[x] = z + 1;\n                }\n            }\n        };\n        Dfs(0, -1);\n        return cnt[0] == A && dp[0] != kInf;\n    };\n\n    for (int d = 20; d >= 0; --d) {\n        if (B - (1 << d) <= 0) continue;\n        if (Check(B - (1 << d))) B -= (1 << d);\n    }\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(t.size()%2==0){\n\t\tif(t.back()>h)return out;\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=-1,r=t.size()-1;\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tif(f(t,r))cmin(out,t[r]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n-1;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::sort;\n\nconst int MAXN=1e5+5;\nint n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN],son[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(int son){\n\tfor(int l=1,r=::son[0];l<r;++l,--r){\n\t\tif(::son[l]==son) ++l;\n\t\tif(::son[r]==son) --r;\n\t\tif(dp[::son[l]]+dp[::son[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(){\n\tint l=1,r=son[0],mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa) ret&=treeDP(v,u);\n\t}\n\tif(!ret) return false;\n\tson[0]=0;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa) son[++son[0]]=v;\n\t}\n\tif(son[0]==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) son[++son[0]]=0;\n\tsort(son+1,son+son[0]+1,cmp_dp);\n\tint v=bin_chop_son();\n\tif(v>son[0]) return false;\n\tdp[u]=dp[son[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(1,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n    while(s.size()>2){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n          //  cout << *s.begin() << \" sf \" << val1 << endl;\n            p1=1;\n            break;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()==2){\n        if (*s.begin()+*s.rbegin()>k){\n            if (v==1){\n                p1=1;\n                return ;\n            }\n            else{\n                if (*s.rbegin()>k) p1=1;\n                z++;\n                dp[v]=*s.begin();\n            }\n        }\n        else{\n            z++;\n        }\n    }\n    else if (s.size()){\n        dp[v]=*s.begin();\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len && len!=1) judge = false;\n\telse dp[n] += children[r];\n\tif(dp[n]>m) judge = false;\n\tif(n==1 && dp[n]>m+1) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint K;\nbool dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    multiset<int> st;\n    st.insert(0);\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        const bool f = dp_dfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        st.insert(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = st.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        st.insert(0);\n    }\n\n    int mini = 10000;\n    while (not st.empty()) {\n        auto it = st.end();\n        it--;\n        const int v = *it;\n        st.erase(it);\n        auto upp = st.upper_bound(K - v - 1);\n        if (upp == st.begin()) {\n            return false;\n        }\n        upp--;\n        if (*upp == 0 or v == 0) {\n            mini = min(mini, *upp + v + 1);\n        }\n        st.erase(upp);\n    }\n    dp[s] = {sum, mini};\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    int inf = 0;\n    int sup = N + 1;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        if (dp_dfs(g, 0, dp)) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    dp_dfs(g, 0, dp);\n    cout << dp[0].first + (g.edge[0].size() % 2 == 0 ? 0 : 1) << \" \" << sup - 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    int A = 0;\n    for (int v = 0; v < N; ++v) A += tree[v].size() % 2;\n\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A / 2 << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool check2(int u, vector<int>& vec, int num, int cri, int& sm)\n{\n    vector<int> vec2;\n    if(num == len(vec)-1){\n        rep(i, len(vec)-2){\n            vec2.pb(vec[i]);\n        }\n        if(vec[num] == cri) return false;\n        dp[u] = vec[num] + 1;\n    }else{\n        rep(i, len(vec)-1){\n            if(i == num) continue;\n            vec2.pb(vec[i]);\n        }\n        if(vec[len(vec)-1] == cri) sm++;\n        if(vec[num] == cri) return false;\n        dp[u] = vec[num] + 1;\n    }\n    rep(i, len(vec2)){\n        if(vec2[i] + vec2[len(vec2)-i+1] + 2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri, int& sm)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri, sm)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        sm += len(vec)/2;\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        sm += len(vec)/2;\n        bool flag = true;\n        rep(i, len(vec)){\n            if(vec[i] + vec[len(vec)-i+1] + 2 > cri){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            dp[u] = 0;\n            return true;\n        }\n        if(check2(u, vec, 0, cri, sm)){\n            return true;\n        }else if(!check2(u, vec, len(vec)-1, cri, sm)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1, res = 0;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check2(u, vec, mid, cri, res)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            check2(u, vec, r, cri, sm);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool possible(int cri, int a)\n{\n    int sm = 0;\n    if(!dfs2(0, -1, cri, sm)) return false;\n    if(dp[0]) sm++;\n    assert(sm >= a);\n    return (sm == a);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,avx2,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 1e9 + 7;\nint n, _x;\nvector<int> g[maxn];\nint B = 0, A = 0;\nint get(vector<int> &a, int s) {\n\tint l = 0, r = a.size()-1, mx = 0;\n\twhile(l < r) {\n\t\tmx = max(mx, a[l] + a[r]);\n\t\tl++, r--;\n\t\tif(l == s) l++;\n\t\tif(r == s) r--;\n\t}\n\treturn mx;\n}\nll dfs(int v, int p, int h = 0) {\n\tvector<int> ch;\n\tif(g[v].size()&1) ch.pb(h);\n\tfor(auto i : g[v]) if(i != p) {\n\t\tint t = dfs(i, v, h+1);\n\t\tif(t == -1) return -1;\n\t\tif(t) ch.pb(t);\n\t}\n\tsort(all(ch));\n\tif(ch.size()%2 == 0) {\n\t\treturn get(ch, -1)-2*h <= _x ? 0 : -1;\n\t}\n\tp = 0;\n\tfor(int i = 1<<17; i>>=1;)\n\t\tif(get(ch, p+i)-2*h > _x) p += i;\n\tp += (get(ch, p)-2*h > _x);\n\treturn p >= ch.size() ? -1 : ch[p];\n}\nbool can(int x) {\n\t_x = x;\n\treturn dfs(1, 1) != -1;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tfor(int i = 1; i <= n; i++) A += g[i].size()&1; A/=2;\n\tfor(int i = 1<<17; i>>=1;) if(!can(B+i)) B += i;\n\tcout << A << \" \" << B+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e5+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nVI e[N];\nint l,r,mid,f[N];\ninline void dfs(int k) {\n\tfor (int t:e[k]) {\n\t\te[t].erase(find(e[t].begin(),e[t].end(),k));\n\t\tdfs(t);\n\t}\n}\ninline bool solve(int k) {\n\tint m=e[k].size(),i;\n\tVI w(m);\n\tfor (i=0;i<m;i++) {\n\t\tif (!solve(e[k][i])) return false;\n\t\tw[i]=f[e[k][i]]+1;\n\t}\n\tsort(w.begin(),w.end());\n\tif (k==1) {\n\t\tif (m&1) {\n\t\t\tif (w[m-1]>mid) return false;\n\t\t\tm--;\n\t\t}\n\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m+1-i]>mid) return false;\n\t} else {\n\t\tif (m&1) {\n\t\t\tf[k]=w[0];\n\t\t\tfor (i=1;i<=m/2;i++)\n\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\tf[k]=w[i];\n\t\t\t\t}\n\t\t} else {\n\t\t\tf[k]=0;\n\t\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) break;\n\t\t\tif (i<m/2) {\n\t\t\t\tif (w[m-1]>mid) return false;\n\t\t\t\tm--;\n\t\t\t\tf[k]=w[0];\n\t\t\t\tfor (i=1;i<m;i++)\n\t\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\t\tf[k]=w[i];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=gi(),i,a,b,ans=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\te[a].pb(b),e[b].pb(a);\n\t}\n\tans=1;\n\tfor (i=1;i<=n;i++) ans+=(e[i].size()-1)/2;\n\tdfs(1);\n\tl=1,r=n;\n\twhile (l!=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (solve(1)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<ans<<\" \"<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n    while(s.size()>2){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n          //  cout << *s.begin() << \" sf \" << val1 << endl;\n            p1=1;\n            break;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()==2){\n        if (*s.begin()+*s.rbegin()>k){\n            if (v==1){\n                p1=1;\n                return ;\n            }\n            else{\n                z++;\n                dp[v]=*s.begin();\n            }\n        }\n        else{\n            z++;\n        }\n    }\n    else if (s.size()){\n        dp[v]=*s.begin();\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=1,r=n+10;\n    while(r-l>1){\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w, h; };\nconst int INF = INT_MAX / 10;\nconst int MOD = 1e9 + 7;\n\nbool pos(vector<int> a, int ma) {\n\tint N = a.size();\n\tbool ok = true;\n\trep(i, N / 2) if (a[i] + a[N - 1 - i] > ma) ok = false;\n\treturn ok;\n}\n\nint dfs(int u, int p, vector<vector<int>>& G, int ma) {\n\tvector<int> a;\n\tfor (int v: G[u]) if (v != p) a.pb(dfs(v, u, G, ma));\n\tsort(a.begin(), a.end());\n\tint N = a.size();\n\tif (N % 2) {\n\t\tint lb = -1, ub = N;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tvector<int> b = a;\n\t\t\tb.erase(b.begin() + mid);\n\t\t\tif (pos(b, ma)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\treturn ub == N ? INF : a[ub] + 1;\n\t}\n\tif (pos(a, ma)) return 1;\n\tint i;\n\tfor (i = N - 1; i >= 0; i--) if (a[i] <= ma) break;\n\tif (i == -1) return INF;\n\ta.erase(a.begin() + i);\n\tN = a.size();\n\tif (N % 2) {\n\t\tint lb = -1, ub = N;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tvector<int> b = a;\n\t\t\tb.erase(b.begin() + mid);\n\t\t\tif (pos(b, ma)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\treturn ub == N ? INF : a[ub] + 1;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>> G(N);\n\trep(i, N - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tint A = 1;\n\trep(u, N) if (G[u].size() >= 3) A += (G[u].size() - 1) / 2;\n\t// cout << dfs(0, -1, G, 2) << endl;\n\tint lb = -1, ub = N;\n\twhile (ub - lb > 1) {\n\t\tint mid = (lb + ub) / 2;\n\t\tif (dfs(0, -1, G, mid) <= mid + 1) ub = mid;\n\t\telse lb = mid;\n\t}\n\tint B = ub;\n\tcout << A << ' ' << B << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[100010];\nint ans;\n\nint DFS1(int v,int p)\n{\n    int cnt = 0,sum = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        sum += DFS1(ne,v);\n        cnt++;\n    }\n    if(cnt == 0)return 1;\n    return sum - (cnt - 1) / 2;\n}\n\nint DFS2(int v,int p,int x)\n{\n    vector<int> V;\n    int cnt = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        V.push_back(DFS2(ne,v,x));\n        cnt++;\n    }\n    if(cnt == 0)\n    {\n        return 1;\n    }\n    sort(V.begin(),V.end());\n    if(V.back() > x)\n    {\n        return 0;\n    }\n    if(V[0] == 0)\n    {\n        return 0;\n    }\n    if(cnt % 2 == 0)\n    {\n        for(int i = 0; i < V.size() / 2 + 1; i++)\n        {\n            if(i == V.size() / 2)\n            {\n                return 1;\n            }\n            if(V[i] + V[V.size() - 1 - i] > x)\n            {\n                if(V.back() > x)\n                {\n                    return 0;\n                }\n                V.pop_back();\n                break;\n            }\n        }\n    }\n    int l = -1,r = V.size() - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        int L = 0,R = V.size() - 1;\n        for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n        {\n            if(i == V.size() / 2)\n            {\n                r = mid;\n                break;\n            }\n            if(L == mid)L++;\n            if(R == mid)R--;\n            if(V[L] + V[R] > x)\n            {\n                l = mid;\n                break;\n            }\n        }\n    }\n\n    int L = 0,R = V.size() - 2;\n    for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n    {\n        if(i == V.size() / 2)\n        {\n            return V[r] + 1;\n        }\n        if(L == r)L++;\n        if(R == r)R--;\n        if(V[L] + V[R] > x)\n        {\n            return 0;\n            break;\n        }\n    }\n}\n\nbool judge(int mid)\n{\n    int res;\n    for(int i = 1; i <= N; i++)if(G[i].size() == 1)\n    {\n        res = DFS2(i,0,mid);\n        break;\n    }\n    return (res != 0 && mid >= res - 1);\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    //ans = DFS1(1,0);\n    for(int i = 1; i <= N; i++)if(G[i].size() % 2)ans++;\n    ans /= 2;\n\n    int l = 0,r = N - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(judge(mid))r = mid;\n        else l = mid;\n    }\n\n    printf(\"%d %d\\n\",ans,r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint n,cnt,ans,tot,q[100010],inf=1e9,l1,r1,mi,v[100010];\nint x1[100010],r[200010],vt[200010],in[100010],mx;\nvoid adde(int a,int b)\n{\n\tr[++cnt]=x1[a];x1[a]=cnt;vt[cnt]=b;in[b]++;\n\tr[++cnt]=x1[b];x1[b]=cnt;vt[cnt]=a;in[a]++;\n} \nvoid dfs(int i,int fa)\n{\n\tint s,a,b,j,k;\n\tint l2,r2,m,st,ed;\n\ta=x1[i];v[i]=0;\n\twhile(a)\n\t{\n\t\tb=vt[a];\n\t\tif(b!=fa)dfs(b,i);\n\t\ta=r[a];\n\t}\n\ta=x1[i];cnt=0;\n\twhile(a)\n\t{\n\t\tb=vt[a];\n\t\tif(b!=fa)q[++cnt]=v[b]+1;\n\t\ta=r[a];\n\t}\n\tif(!(cnt&1))q[++cnt]=0;\n\tsort(q+1,q+1+cnt);\n\tl2=1;r2=cnt+1;\n\twhile(l2<r2)\n\t{\n\t\tm=(l2+r2)/2;j=1;\n\t\tst=1;ed=cnt;\n\t\twhile(st<ed)\n\t\t{\n\t\t\tif(st==m)st++;\n\t\t\tif(ed==m)ed--;\n\t\t\tif(q[st]+q[ed]>mi){j=0;break;}\n\t\t\tst++;ed--;\n\t\t}\n\t\tif(j)r2=m;\n\t\telse l2=m+1;\n\t} \n\tif(l2==cnt+1)v[i]=inf;\n\telse v[i]=q[l2];\n}\nbool jd(int mi)\n{\n\tdfs(1,0);\n\treturn (v[1]<=mi);\n}\t\nint main()\n{\n\tint i,s,a,b,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++)scanf(\"%d%d\",&a,&b),adde(a,b);\n\tans=1;\n\tfor(i=1;i<=n;i++)ans+=(in[i]-1)/2;\n\tl1=1;r1=n;\n\twhile(l1<r1)\n\t{\n\t\tmi=(l1+r1)/2;\n\t\tif(jd(mi))r1=mi;\n\t\telse l1=mi+1;\n\t}\n\tprintf(\"%d %d\",ans,l1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[100001];\nvector<int> tree[100001];\nvector<int> l[100001];\nint p[100001];\nint bye[100001];\n\nint ans1 = 0;\nint lim = 0;\n\nvoid dfs1(int x){\n    int cntt = 0;\n    for(auto &nxt: g[x]){\n        if(nxt == p[x]) continue;\n        tree[x].push_back(nxt);\n        p[nxt] = x;\n        dfs1(nxt);\n        cntt++;\n    }\n    ans1 += (cntt / 2);\n    if(x == 1 && (cntt % 2) == 1) ans1++;\n}\n\nbool dfs2(int x){\n    l[x].clear();\n    for(auto &nxt: tree[x]){\n        if(!dfs2(nxt)) return false;\n        //printf(\"bye %d -> %d: %d\\n\", nxt, x, bye[nxt]);\n        l[x].push_back(bye[nxt]+1);\n    }\n    sort(l[x].begin(), l[x].end());\n    int m = (int)l[x].size();\n    if(m % 2 == 0){\n        bool highpass = true;\n        for(int i=0;i<m;i++){\n            if(l[x][i] + l[x][m-1-i] > lim){\n                highpass = false;\n                break;\n            }\n        }\n        if(highpass){\n            bye[x] = 0;\n            return true;\n        }\n        if(x == 1) return false;\n        if(l[x][m-1] > lim) return false;\n        m--;\n    }\n    bye[x] = 0;\n    int ss = 0, ee = m-1, ans = m;\n    while(ss <= ee){\n        int mid = (ss + ee) / 2;\n        int s = 0, e = m-1;\n        bool can = true;\n        while(s < e){\n            if(s == mid) s++;\n            if(e == mid) e--;\n            if(s >= e) break;\n            if(l[x][s] + l[x][e] > lim){\n                can = false;\n                break;\n            }else{\n                s++; e--;\n            }\n        }\n        if(can){\n            ans = mid;\n            ee = mid - 1;\n        }else{\n            ss = mid + 1;\n        }\n    }\n    if(ans == m) return false;\n    bye[x] = l[x][ans];\n    return true;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<n;i++){\n        int aa, bb;\n        scanf(\"%d%d\", &aa, &bb);\n        g[aa].push_back(bb);\n        g[bb].push_back(aa);\n    }\n    p[1] = 1;\n    dfs1(1);\n    int ss = 1, ee = n+1, ans2 = n+1;\n    while(ss <= ee){\n        lim = (ss + ee) / 2;\n        //printf(\"%d\\n\", lim);\n        if(dfs2(1)){\n            ans2 = lim;\n            ee = lim - 1;\n        }else{\n            ss = lim + 1;\n        }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\nusing namespace std;\nusing llong = long long;\n\nllong n;\nvector<vector<llong>> g;\nvector<llong> depth;\n\nllong dfs(int u, int par) {\n    depth[u] = 1;\n    llong d = 1ll << 60ll;\n\n    for (auto v:g[u]) {\n        if (v == par) continue;\n        d = min(d, dfs(v, u));\n    }\n\n    if (d == (1ll << 60ll)) {\n        return depth[u];\n    }\n    else {\n        return depth[u] = d + 1;\n    }\n}\n\nint main() {\n    cin >> n;\n    g.resize(n + 1);\n    depth.resize(n + 1);\n    for (llong i = 0; i < n - 1; i++) {\n        llong a, b;\n        cin >> a >> b;\n        --a, --b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    llong a = 1;\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() >= 3) a++;\n    }\n\n    dfs(0, -1);\n    llong b = -1;\n    for (int i = 0; i < n; i++) {\n        b = max(b, depth[i]);\n    }\n\n    cout << a << ' ' << b << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nint cnt[100005];\n\nP solve(int len){\n\tmemset(used,false,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++){\n\t\tif(G[i].size()==1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tint prev=-1;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tprev=v;\n\t\tque.pop();\n\t\tused[v]=true;\n\t\tint sum=0;\n\t\tmultiset<int> vi;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tif(used[nv]){\n\t\t\t\tvi.insert(res[nv].second);\n\t\t\t\tsum+=res[nv].first;\n\t\t\t}else{\n\t\t\t\tcnt[nv]++;\n\t\t\t\tif(cnt[nv]+1==G[nv].size())que.push(nv);\n\t\t\t}\n\t\t}\n\t\tif(vi.size()==0){\n\t\t\tres[v]=P(1,1);\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag=false;\n\t\tint len_min=n+5;\n\t\twhile(vi.size()){\n\t\t\tint v=*vi.rbegin();\n\t\t\tmultiset<int>::iterator it2=vi.end();\n\t\t\tit2--;\n\t\t\tvi.erase(it2);\n\t\t\tmultiset<int>::iterator it=vi.upper_bound(len-v);\n\t\t\tif(it!=vi.begin()){\n\t\t\t\tit--;\n\t\t\t\tvi.erase(it);\n\t\t\t\tsum--;\n\t\t\t}else{\n\t\t\t\tflag=true;\n\t\t\t\tlen_min=min(len_min,v);\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}else if(len_min==len){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}\n\t\tres[v]=P(sum,len_min+1);\n\t\t//printf(\"%d %d %d\\n\",v,res[v].first,res[v].second);\n\t}\n\tif(res[prev].second==1){\n\t\tres[prev].first--;\n\t\tres[prev].second=len;\n\t}\n\treturn res[prev];\n}\n\n\nbool C(int num,int len){\n\tP rec=solve(len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tls.insert(tmp);\n\t}\n\tint lef = -1;\n\tint K = ls.size();\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\tif(K%2==0 && lef==-1){\n\t\t\t\tlef = a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(ls.size() == 0){\n\t\treturn 1;\n\t}else if(lef!=-1){\n\t\treturn lef + 1;\n\t}else{\n\t\treturn *ls.begin() + 1;\t\t\n\t}\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=0;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += deg%2;\n\t}\n\tA/=2;\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    return (f[x] = g[ans] + 1) <= m + 1;\n}\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(1, 0)) return 0;\n    return f[1] <= m + 1;\n}\nint main() {\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    std::cout << (m >>= 1) << std::ends;\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nvector<int> lis[100100];\nvector<int> cdp[100100];\nint dp[100100];\n\nbool dfs(int here, int p, int t) {\n    cdp[here].clear(); int i, j;\n    for (auto &there : lis[here]) {\n        if (there==p) continue;\n        if (!dfs(there,here,t)) return false;\n        cdp[here].push_back(dp[there]+1);\n    }\n    sort(cdp[here].begin(),cdp[here].end());\n    if (cdp[here].empty()) {\n        dp[here] = 0;\n        return true;\n    }\n    if (p<0) {\n        for (i=0,j=(int)cdp[here].size()/2*2-1;i<j;i++,j--) {\n            if (cdp[here][i]+cdp[here][j]>t) return false;\n        }\n        if (cdp[here].back()>t) return false;\n        return true;\n    }\n    if (cdp[here].size()%2==0) {\n        for (i=0,j=(int)cdp[here].size()-1;i<j;i++,j--) {\n            if (cdp[here][i]+cdp[here][j]>t) break;\n        }\n        if (i>=j) {\n            dp[here] = 0;\n            return true;\n        }\n        if (cdp[here].back()>t) return false;\n    }\n    int cur = 0;\n    for (i=1,j=((int)cdp[here].size()-1)/2*2;i<j;i++,j--) {\n        if (cdp[here][i]+cdp[here][j]>t) {\n            cur = i;\n            if (cdp[here][i-1]+cdp[here][j]>t) break;\n        }\n    }\n    if (i>=j) {\n        dp[here] = cdp[here][cur];\n        return true;\n    }\n    cur = ((int)cdp[here].size()-1)/2*2; int fl = 0;\n    for (i=0,j=((int)cdp[here].size()-1)/2*2;i<j;i++,j--) {\n        if (cdp[here][i]+cdp[here][j]>t) {\n            if (cdp[here][i]+cdp[here][j-1]>t) return false;\n            cur = j; fl = 1;\n        }\n        else {\n            if (fl) return false;\n            cur = j;\n        }\n    }\n    dp[here] = cdp[here][cur];\n    return true;\n}\n\nbool ok(int t) {\n    return dfs(0,-1,t);\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n-1;i++){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);--a;--b;\n        lis[a].push_back(b);\n        lis[b].push_back(a);\n    }\n    int r1 = 1;\n    for (i=0;i<n;i++) r1 += ((int)lis[i].size()-1)/2;\n    printf(\"%d \",r1);\n    int s = 0, e = n;\n    while(s<=e) {\n        int m = (s+e)>>1;\n        if (ok(m)) e = m-1;\n        else s = m+1;\n    }\n    printf(\"%d\\n\",s);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,avx2,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 103, mod = 1e9 + 7;\nint n, _x;\nvector<int> g[maxn];\nint B = 0, A = 0;\nint get(vector<int> &a, int s) {\n\tint l = 0, r = a.size()-1, mx = 0;\n\twhile(l < r) {\n\t\tmx = max(mx, a[l] + a[r]);\n\t\tl++, r--;\n\t\tif(l == s) l++;\n\t\tif(r == s) r--;\n\t}\n\treturn mx;\n}\nll dfs(int v, int p, int h = 0) {\n\tvector<int> ch;\n\tif(g[v].size()&1) ch.pb(h);\n\tfor(auto i : g[v]) if(i != p) {\n\t\tint t = dfs(i, v, h+1);\n\t\tif(t == -1) return -1;\n\t\tif(t) ch.pb(t);\n\t}\n\tsort(all(ch));\n\tif(ch.size()%2 == 0) {\n\t\treturn get(ch, -1)-2*h <= _x ? 0 : -1;\n\t}\n\tp = 0;\n\tfor(int i = 1<<17; i>>=1;)\n\t\tif(get(ch, p+i)-2*h > _x) p += i;\n\tp += (get(ch, p)-2*h > _x);\n\treturn p >= ch.size() ? -1 : ch[p];\n}\nbool can(int x) {\n\t_x = x;\n\treturn dfs(1, 1) != -1;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tfor(int i = 1; i <= n; i++) A += g[i].size()&1; A/=2;\n\tfor(int i = 1<<17; i>>=1;) if(!can(B+i)) B += i;\n\tcout << A << \" \" << B+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.begin();\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n    \n\n\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<int> g[100000];\nint c[100000];\nbool used[100000];\nbool nuee;\nint d;\nvoid dfs(int x){\n  if(nuee) return;\n  used[x]=1;\n  vector<int> v;\n  for(auto y:g[x]){\n    if(used[y]) continue;\n    dfs(y);\n    if(nuee) return;\n    v.push_back(c[y]+1);\n  }\n  if(v.empty()) return;\n  if(v.size()==1){\n    if(v[0]>d) nuee=1;\n    c[x]=v[0];\n    return;\n  }\n  if(v.size()%2==0) v.push_back(0);\n  sort(v.begin(), v.end());\n  int m=v.size();\n  bool ok0=0;\n  for(int i=0; i<m; i++){\n    int c1=0, c2=m-1;\n    bool ok=1;\n    for(int j=0; j<m/2; j++){\n      if(c1==i) c1++;\n      if(c2==i) c2--;\n      if(v[c1]+v[c2]>d){\n        ok=0;\n        break;\n      }\n      c1++; c2--;\n    }\n    if(ok){\n      ok0=1;\n      c[x]=v[i];\n      break;\n    }\n  }\n  if(!ok0){\n    nuee=1;\n  }\n}\n\nint main()\n{\n\tint n; cin>>n;\n  for(int i=0; i<n-1; i++){\n    int a, b;\n    cin>>a>>b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  int ct=0;\n  int v0;\n  for(int i=0; i<n; i++){\n    if(g[i].size()%2) ct++;\n    if(g[i].size()==1) v0=i;\n  }\n  cout<<ct/2<<\" \";\n  int d1=1, d2=2e5;\n  while(d1!=d2){\n    d=(d1+d2)/2;\n    fill(c, c+n, 0);\n    fill(used, used+n, 0);\n    nuee=0;\n    dfs(v0);\n    if(nuee) d1=d+1;\n    else d2=d;\n  }\n\tcout<<d1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? 100002 : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l-1;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tint ans=dfs(1,-1);\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\nll N;\nvector<vector<ll>> edge;\nvector<ll> ord;\nll m;\nbool jd;\n\nbool judge(ll sz,ll used,const vector<ll> &beet){\n  for(int i=0;2*i+2<sz;i++){\n    ll lf=(i>=used?beet[i+1]:beet[i]);\n    ll rg=((sz-i-2)>=used?beet[sz-i-2+1]:beet[sz-i-2]);\n    if(lf+rg+1>m){return false;}\n  }\n  return true;\n}\n\nll dfs(ll u,ll p){\n  vector<ll> beet(ord[u]+1);\n  ll sz=0;\n  for(auto &v:edge[u]){\n    if(v!=p){\n      beet[sz++]=dfs(v,u);\n    }\n  }\n  sort(beet.begin(),beet.begin()+sz,greater<ll>());\n  if((sz&1)==0){\n    beet[sz++]=0;\n    if(p==-1){jd&=judge(sz,sz-1,beet); return 0;}\n  }\n  ll lf=0,rg=sz;\n  while(rg-lf>1){\n    ll mid=(lf+rg)>>1;\n    if(judge(sz,mid,beet)){lf=mid;}\n    else{rg=mid;}\n  }\n  jd&=judge(sz,lf,beet);\n  jd&=(beet[lf]+1<=m);\n  return beet[lf]+1;\n}\n\nbool judge2(ll mid){\n  m=mid;\n  jd=true;\n  dfs(0,-1);\n  return jd;\n}\n\nint main(){\n  cin>>N;\n  edge.resize(N);\n  ord.resize(N,0);\n\n  for(int i=1;i<N;i++){\n    ll a,b;\n    cin>>a>>b;\n    a--; b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n    ord[a]++;\n    ord[b]++;\n  }\n\n  ll cnt=0;\n  for(auto &I:ord){cnt+=(I-1)/2;}\n  \n  ll l=0,r=N;\n  while(r-l>1){\n    ll mid=(l+r)>>1;\n    if(judge2(N-mid)){l=mid;}\n    else{r=mid;}\n  }\n  cout<<cnt+1<<\" \"<<N-l-1<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nii mini(ii a, ii b)\n{\n\tif(a.fi<b.fi||(a.fi==b.fi&&a.se<b.se)) return a;\n\telse return b;\n}\n\nii dp[111111];\nvi adj[111111];\nint MID;\n\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t\tcnt+=dp[v].fi;\n\t}\n\tsort(vec.begin(),vec.end());\n\t/*\n\tint maxpath = 0;\n\twhile(!vec.empty())\n\t{\n\t\tif(vec.size()==1)\n\t\t{\n\t\t\tif(vec[0]+1<=mid)\n\t\t\t{\n\t\t\t\tmaxpath = max(maxpath, vec[0]+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tmaxpath = max(maxpath, 1);\n\t\t\t}\n\t\t\tvec.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint las = vec.back();\n\t\t\tif(vec.front()+2+las<=mid)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_front(0);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint maxi = -int(1e9);\n\t\tfor(int i=0;i<mid;i++)\n\t\t{\n\t\t\tif(i<mid-1-i) maxi=max(maxi,vec[i]+vec[mid-1-i]+2);\n\t\t\tmaxi=max(maxi,vec[i]+1);\n\t\t}\n\t\tif(maxi<=MID)\n\t\t{\n\t\t\tans=mid;\n\t\t\tlo=mid+1;\n\t\t}\n\t\telse hi=mid-1;\n\t}\n\tint maxpath = 0;\n\tint del=0;\n\tfor(int i=ans;i<vec.size();i++) \n\t{\n\t\tif(vec[i]+1<=MID)\n\t\t{\n\t\t\tdel++;\n\t\t}\n\t\tvec[i]=0;\n\t}\n\tcnt+=int(vec.size()) - ans;\n\tfor(int j=0;j<del;j++) vec.pop_back();\n\tsort(vec.begin(),vec.end());\n\t//cerr<<vec.size()<<'\\n';\n\tcnt+=int(vec.size())/2;\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=0;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = -int(1e9);\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=max(res,vec[l]+vec[r]+2);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res==-int(1e9)) res=0;\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tmaxpath = vec[ans]+1;\n\t\tif(maxpath>MID)\n\t\t{\n\t\t\tmaxpath=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t//cerr<<MID<<' '<<u<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tMID=n;\n\tdfs(0,-1);\n\tint res=dp[0].fi;\n\tif(dp[0].se>0) res++;\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=dp[0].fi;\n\t\tif(dp[0].se>0) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nvector<int> G[100000];\nint ar[100000];\nint buffer[100000];\nint N;\nbool check(int B){\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tint p = 0;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tbuffer[p++] = ar[t]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v == 0){\n\t\t\t\tif(p % 2 == 1){\n\t\t\t\t\tbuffer[p++] = 0;\n\t\t\t\t}\n\t\t\t\tsort(buffer,buffer+p);\n\t\t\t\tint l = 0;\n\t\t\t\tint r = p-1;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tif(buffer[l] + buffer[r] > B){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tl++;\n\t\t\t\t\tr--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p % 2 == 0){\n\t\t\t\t\tbuffer[p++] = 0;\n\t\t\t\t}\n\t\t\t\tsort(buffer,buffer+p);\n\t\t\t\tint bf = 0;\n\t\t\t\tint bl = p;\n\t\t\t\twhile(bf != bl){\n\t\t\t\t\tint bc = (bf+bl)/2;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tif(bc != p){\n\t\t\t\t\t\tint l = 0;\n\t\t\t\t\t\tint r = p-1;\n\t\t\t\t\t\twhile(l < r){\n\t\t\t\t\t\t\tif(l == bc){\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(r == bc){\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(buffer[l] + buffer[r] > B){\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(OK){\n\t\t\t\t\t\tbl = bc;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbf = bc+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bf == p){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tar[v] = buffer[bf];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid Calc(){\n\tN = rei();\n\tfor(int i=0;i<N-1;i++){\n\t\tint a = rei()-1;\n\t\tint b = rei()-1;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint A = 0;\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tint b = 0;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint t = G[v][i];\n\t\t\tif(t != f){\n\t\t\t\tb++;\n\t\t\t\tsp.push({t,v});\n\t\t\t}\n\t\t}\n\t\tA -= b / 2;\n\t\tif(b % 2 == 0 && f != -1){\n\t\t\tA++;\n\t\t}\n\t}\n\tint bf = 1;\n\tint bl = N-1;\n\twhile(bf != bl){\n\t\tint bc = (bf+bl)/2;\n\t\tif(check(bc)){\n\t\t\tbl = bc;\n\t\t}\n\t\telse{\n\t\t\tbf = bc+1;\n\t\t}\n\t}\n\tcout << A << \" \" << bf << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nconst int N = 100050;\nint pre[N], nxt[N * 2], to[N * 2], cnt;\ninline void addEdge(int x, int y) {\n  nxt[cnt] = pre[x];\n  to[pre[x] = cnt++] = y;\n  nxt[cnt] = pre[y];\n  to[pre[y] = cnt++] = x;\n}\nint tmp[N * 2];\nint d[N];\nint B;\nint vis[N], time;\nbool check(int x, int fa, int *tmp, int &pp) {\n  int ss = d[x] - (fa != 0) + (d[x] & 1);\n  int l = 0;\n  if (d[x] & 1) tmp[l++] = 0;\n  for (int i = pre[x]; ~i; i = nxt[i]) if (to[i] != fa) {\n    int p = 0;\n    if (!check(to[i], x, tmp + ss, p)) return false;\n    if (p) tmp[l++] = p;\n  }\n  std::sort(tmp, tmp + l);\n  if (tmp[l - 1] > B) return false;\n  int i = l - 1, j = l - 2;\n  ++time;\n  int tt = 0;\n  while (~i) {\n    if (tt == l) return true;\n    if (tt == l - 1) {\n      pp = tmp[i] + 1;\n      return true;\n    }\n    while (j > 0 && tmp[j] + tmp[i] > B) --j;\n    if (tmp[j] + tmp[i] > B) return false;\n    vis[i] = vis[j] = time;\n    tt += 2;\n    while (i > 0 && vis[i] == time) --i;\n  }\n  return false;\n}\nint main() {\n  int n, x, y;\n  scanf(\"%d\", &n);\n  memset(pre, -1, sizeof pre);\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addEdge(x, y);\n    ++d[x]; ++d[y];\n  }\n  int l = 0;\n  for (int i = 1; i <= n; ++i)\n    l += (d[i] & 1);\n  l /= 2;\n  printf(\"%d\\n\", l);\n  int ll = 1, rr = n, xxx;\n  while (ll < rr) {\n    int mid = (ll + rr) / 2;\n    if (B = mid, check(1, 0, tmp, xxx)) rr = mid;\n    else ll = mid + 1;\n  }\n  printf(\"%d\\n\", ll);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)if(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\twhile(1){\n\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\telse if(pre>0)tt--,pre--;\n\t\telse if(tt-suf==1){\n\t\t\tif(u==1)return false;\n\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\telse return false;\n\t\t}else return false;\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    int A = 0;\n    for (int v = 0; v < N; ++v) A += tree[v].size() % 2;\n\n    int r;\n    for (r = 0; tree[r].size() > 1; ++r) {}\n\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(r, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A / 2 << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> vec[N];\nint head[N],deg[N];\nint n,x,y,tot,flag,A;\nstruct edge{int to,next;}e[N*2];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint check(vector<int> vec,int ban,int lim,int sz){\n\tif (ban!=-1)\n\t\tif (vec[ban]>lim) return 0;\n\tint L=0,R=sz-1;\n\tif (L==ban) L++;\n\tif (R==ban) R--;\n\twhile (L<=R){\n\t\tif (L==R){\n\t\t\tif (vec[L]>lim) return 0;\n\t\t}\n\t\telse\n\t\t\tif (vec[L]+vec[R]>lim) return 0;\n\t\tL++; R--;\n\t\tif (L==ban) L++;\n\t\tif (R==ban) R--;\n\t}\n\treturn 1;\n}\nint dfs(int x,int fa,int lim){\n\tif (!flag) return 0;\n\tvec[x].resize(0);\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa)\n\t\t\tvec[x].push_back(dfs(e[i].to,x,lim)+1);\n\tsort(vec[x].begin(),vec[x].end());\n\tint sz=vec[x].size();\n\tif (sz%2==0&&check(vec[x],-1,lim,sz))\n\t\treturn 0;\n\tint l=0,r=sz-1,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(vec[x],mid,lim,sz))\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif (ans==-1)\n\t\tflag=0;\n\telse return vec[x][ans];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t\tdeg[x]++; deg[y]++;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tA+=(deg[i]-1)/2;\n\tint l=1,r=n,ans=0;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tflag=1;\n\t\tdfs(1,1,mid);\n\t\tif (flag)\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",A+1,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n \nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n \nint all = 0;\n \nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\tint cnt = 0;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\tcnt++;\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tcnt++;\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\twhile (nt && extra.size()) {\n\t\textra.pop_back();\n\t\tnt--;\n\t}\n\t\n\tif(nt || cnt > 2)ans = 1e9;\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n \nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tans1 = all;\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nint cnt[100005];\n\nP solve(int len){\n\tmemset(used,false,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++){\n\t\tif(G[i].size()==1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tint prev=-1;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tprev=v;\n\t\tque.pop();\n\t\tused[v]=true;\n\t\tint sum=0;\n\t\tmultiset<int> vi;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tif(used[nv]){\n\t\t\t\tvi.insert(res[nv].second);\n\t\t\t\tsum+=res[nv].first;\n\t\t\t}else{\n\t\t\t\tcnt[nv]++;\n\t\t\t\tif(cnt[nv]+1==G[nv].size())que.push(nv);\n\t\t\t}\n\t\t}\n\t\tif(vi.size()==0){\n\t\t\tres[v]=P(1,1);\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag=false;\n\t\tint len_min=n+5;\n\t\twhile(vi.size()){\n\t\t\tint v=*vi.rbegin();\n\t\t\tmultiset<int>::iterator it2=vi.end();\n\t\t\tit2--;\n\t\t\tvi.erase(it2);\n\t\t\tmultiset<int>::iterator it=vi.upper_bound(len-v);\n\t\t\tif(it!=vi.begin()){\n\t\t\t\tit--;\n\t\t\t\tvi.erase(it);\n\t\t\t\tsum--;\n\t\t\t}else{\n\t\t\t\tflag=true;\n\t\t\t\tlen_min=min(len_min,v);\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}else if(len_min==len){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}\n\t\tres[v]=P(sum,len_min+1);\n\t\t//printf(\"%d %d %d\\n\",v,res[v].first,res[v].second);\n\t}\n\tif(res[prev].second==1){\n\t\tres[prev].first--;\n\t\tres[prev].second=len;\n\t}\n\treturn res[prev];\n}\n\n\nbool C(int num,int len){\n\tP rec=solve(len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root,int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to,root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size(); cnt += len / 2;\n\tif (len % 2==0) {\n\t\trep(i, len / 2) {\n\t\t\tif (v[i] + v[len - i - 1] > c)f = false;\n\t\t}\n\t\treturn 1;\n\t}\n\telse {\n\t\tmultiset<int> mt;\n\t\trep(i, len)mt.insert(v[i]);\n\t\trep(i, len / 2) {\n\t\t\tauto itr = mt.end(); itr--;\n\t\t\tint z = *itr; mt.erase(mt.find(z));\n\t\t\tint r = c - z;\n\t\t\tif (mt.count(r)) {\n\t\t\t\tmt.erase(mt.find(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt.insert(r);\n\t\t\t\tauto itr2 = mt.find(r);\n\t\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\titr2--; mt.erase(r);\n\t\t\t\tint zz = *itr2;\n\t\t\t\tif (zz + z > c) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\tmt.erase(itr2);\n\t\t\t}\n\t\t}\n\t\tint z = *mt.begin();\n\t\tif (z == c) {\n\t\t\tcnt++; z = 0;\n\t\t}\n\t\treturn z + 1;\n\t}\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa<<\" \"<<ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int) 1e5 + 10;\nint n;\nvector<int> adj[MAXN];\n\nint DFS(int u, int T, int par = -1) {\n    vector<int> a;\n    for (int i = 0; i < (int) adj[u].size(); ++i) {\n        int v = adj[u][i];\n        if (v != par) {\n            a.push_back(DFS(v, T, u));\n        }\n    }\n    if ((int) a.size() % 2 == 0) a.push_back(0);\n    sort(a.begin(), a.end());\n\n    int l = 0, r = (int) a.size() - 1, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        vector<int> b;\n        for (int i = 0; i < (int) a.size(); ++i) {\n            if (i != mid) {\n                b.push_back(a[i]);\n            }\n        }\n        bool check = true;\n        for (int i = 0; i < (int) b.size() / 2; ++i) {\n            if (b[i] + b[(int) b.size() - i - 1] > T) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (f == -1) {\n        return T + 3;\n    }\n    return a[f] + 1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int l = 1, r = n, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (DFS(1, mid) <= mid + 1) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) cnt += (int) adj[i].size() % 2;\n\n    printf(\"%d %d\\n\", cnt / 2, f);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint a[N],pre[N],nex[N],vis[N];\nint A,B;\n\ninline void rem(int x){\n\tvis[x]=1;\n\tint l=pre[x],r=nex[x];\n\tif(r) pre[r]=l;nex[l]=r;\n}\ninline int solve(int n){\n\tint tag=0;\n\tfor(int i=0;i<n;i++)\n\t\tnex[i]=i+1,pre[i+1]=i;\n\tnex[n]=pre[0]=0;\n\tfor(int i=0;i<=n;i++) vis[i]=0;\n\tfor(int i=n;i;i--){\n\t\tif(vis[i]) continue;\n\t\twhile(nex[tag]&&a[nex[tag]]+a[i]+1<=B) tag=nex[tag];\n\t\tif(tag==i) tag=pre[tag];\n\t\tif(!tag) return a[i];\n\t\trem(i);rem(tag);\n\t\tassert(tag<i);\n\t\ttag=pre[tag];\n\t}\n}\n\ninline int dfs(int x,int F=0){\n\tint isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tif(!isok) return 1;\n\tsort(all(v));\n\tint ret=0;\n\tfor(int l=0,r=SZ(v)-1;l<r;r--)\n\t\tif(v[l]+v[r]+1<=B) l++,ret++;\n\tif(ret*2==SZ(v)){res+=ret;return 1;}\n\tres+=SZ(v)-ret-1;\n\tfor(int i=0;i<=ret*2;i++)\n\t\ta[i+1]=v[i];\n\tint p=solve(ret*2+1);\n\tif(p+1==B){res++;return 1;}\n\treturn p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nvi G[maxn];\nint ans2=0;\nint cur;\nbool ok;\nint dfs(int u,int fa=-1)\n{\n    vi sonlen;\n    for(auto v:G[u])if(v!=fa)\n    {\n        int ret=dfs(v,u);\n        sonlen.push_back(ret+1);\n    }\n    if(sonlen.size()%2==0) sonlen.push_back(0);\n    sort(sonlen.begin(),sonlen.end());\n    int L=0,R=sonlen.size()-1,ret=-1;\n    while(L<=R)\n    {\n        int mid=L+R>>1;\n        bool yes=1;\n        for(int l=0,r=sonlen.size()-1;l<r;l++,r--)\n        {\n            if(l==mid) l++;\n            if(r==mid) r--;\n            if(sonlen[l]+sonlen[r]>cur) yes=0;\n        }\n        if(yes){\n            ret=mid;\n            R=mid-1;\n        }\n        else L=mid+1;\n    }\n    if(ret==-1){\n        ok=0;\n        ret=0;    \n    }\n    return sonlen[ret];\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1,u,v;i<n;i++)\n    {\n        cin>>u>>v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    int ans1=0,odd=0;\n    for(int i=1;i<=n;i++)\n        if(G[i].size()&1) odd++;\n    ans1=odd/2;\n    int L=1,R=n-1,ans2=-1;\n    while(L<=R)\n    {\n        cur=L+R>>1;\n        ok=1;\n        int ret=dfs(1);\n        //dbg(cur,ok);\n        if(ret>cur) ok=0;\n        if(ok)\n        {\n            ans2=cur;\n            R=cur-1;\n        }\n        else L=cur+1;\n    }\n    cout<<ans1<<\" \"<<ans2<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=100100,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\n\tmit it;\n\tint w,dw,cnt;\n\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\n\t\tS.clear();\n\t\tcnt=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tw=it->first,dw=lim-w;\n\nfuck:\n\t\t\tif((it->second)==0){S.erase(it);goto fuck;}\n\t\t\t(it->second)--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\n\ncao:\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tif((it->second)==0){S.erase(it);goto cao;}\n\t\t\t(it->second)--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=0;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define R register\nnamespace IO{\n\tchar buf[1<<15],*S,*T;\n\tinline char gc(){\n\t\tif (S==T){\n\t\t\tT=(S=buf)+fread(buf,1,1<<15,stdin);\n\t\t\tif (S==T) return EOF;\n\t\t}return *S++;\n\t}\n\tinline int read(){\n\t\tR int x; R bool f; R char c;\n\t\tfor (f=0; (c=gc())<'0'||c>'9'; f=c=='-');\n\t\tfor (x=c^'0'; (c=gc())>='0'&&c<='9'; x=(x<<1)+(x<<3)+(c^'0'));\n\t\treturn f?-x:x;\n\t}\n}\n#define MN 100005\nint d[MN],n,ans1,f[MN],h[MN],to[MN<<1],nt[MN<<1],en,rt,a[MN],cnt;bool flag;\ninline void ins(int u,int v){to[++en]=v; nt[en]=h[u]; h[u]=en;}\ninline void insw(int u,int v){++d[u],++d[v];ins(u,v);ins(v,u);}\ninline bool check2(int k,int ln){\n\tR int l=1,r=cnt;\n\tif (l==k) ++l;\n\tif (r==k) --r;\n\twhile(l<r){\n\t\tif (a[l]+a[r]>ln) return 0;\n\t\t++l,--r;\n\t\tif (l==k) ++l;\n\t\tif (r==k) --r;\n\t}return 1;\n}\nvoid dfs(int u,int ln,int fa=0){\n\tfor (R int i=h[u]; i; i=nt[i])\n\t\tif (to[i]!=fa) dfs(to[i],ln,u);\n\tcnt=0;for (R int i=h[u]; i; i=nt[i])\n\t\tif (to[i]!=fa) a[++cnt]=f[to[i]];\n\tif (!cnt) return (void)(f[u]=1);\n\tif (~cnt&1) a[++cnt]=0;\n\tstd::sort(a+1,a+cnt+1);\n\tR int l=1,r=cnt;while(l<r)\n\t\tif (check2(l+r>>1,ln)) r=l+r>>1;\n\t\telse l=l+r+2>>1;\n\tif (l==cnt&&!check2(cnt,ln)) flag=0;\n\tf[u]=a[l]+1;\n}\ninline bool check(int len){\n\tflag=1;dfs(rt,len);\n\treturn flag&&f[rt]<=len+1;\n}\nint main(){\n\tn=IO::read();for (R int i=1; i<n; ++i) insw(IO::read(),IO::read());\n\tfor (R int i=1; i<=n; ++i) if (d[i]&1) rt=i,++ans1;\n\tans1>>=1;R int l=1,r=n;while(l<r)\n\t\tif (check(l+r>>1)) r=l+r>>1;else l=l+r+2>>1;\n\tprintf(\"%d %d\\n\",ans1,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\n#define pb push_back\n#define sz(a) int(a.size())\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,A,lim,f[N],rt;\nvector<int> E[N];\nbool fl;\n\nbool check2(vector<int> &v,int mid) {\n\tint l=0,r=sz(v)-1;\n\twhile(l<r) {\n\t\tif(l==mid) { ++l;continue; }\n\t\tif(r==mid) { --r;continue; }\n\t\tif(v[l]+v[r]>lim) return 0;\n\t\t++l,--r;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int u,int fa) {\n\tvector<int> vec;\n\tfor(auto v:E[u]) if(v^fa) dfs(v,u),vec.pb(f[v]);\n\tif(sz(vec)&1^1) vec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=sz(vec);\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check2(vec,mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tif(l==sz(vec)) { fl=0;return; }\n\tf[u]=vec[l]+1;\n}\n\nbool check(int mid) {\n\tlim=mid;fl=1;dfs(rt,0);\n\treturn fl&&f[rt]<=lim+1;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tfor(int i=1;i<=n;i++)\n\t\tif(sz(E[i])&1) ++A,rt=i;\n\tint l=0,r=n;\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<A/2<<' '<<l;\n\tcheck(2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define pb push_back\nconst int N=1e5+5;\nint n;\nvector<int>lk[N],son[N];\n\nint A;\nnamespace GET_A\n{\nvoid dfs(int x,int fr)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tson[x].pb(y);\n\t\tdfs(y,x);\n\t}\n//\tcerr<<x<<\" \"<<son[x].size()<<endl;\n//\tfor(auto y:son[x])cerr<<y<<\" \";puts(\"\");\n\tif(x!=1)A+=son[x].size()/2;\n\telse A+=(son[x].size()+1)/2;\n}\n};\nnamespace GET_B\n{\nint len[N];\nint mid;\nbool len_xiao(int x,int y)\n{\n\treturn len[x]<len[y];\n}\nbool dfs(int x)\n{\n\tif(!son[x].size())\n\t{\n\t\tlen[x]=1;\n\t\treturn 0;\n\t}\n\tfor(auto y:son[x])\n\tif(dfs(y))return 1;\n\tsort(son[x].begin(),son[x].end(),len_xiao);\n\tint l=0,r=son[x].size()-1;\nif(x==1)\n{\n\tif(r%2==0)\n\t{\n\t\tif(len[son[x][r]]+1>mid)return 1;\n\t\t--r;\n\t}\n\twhile(l<r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+1>mid)return 1;\n\t\t++l;--r;\n\t}\n\treturn 0;\n}\n\tif(len[son[x][r]]+1>mid)return 1;\n\twhile(l<r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+1>mid)break;\n\t\t++l;--r;\n\t}\n\tif(l<=r&&son[x].size()%2==0)--r; \n\twhile(l<r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+1>mid)break;\n\t\t++l;--r;\n\t}\n\tif(l>r){len[x]=1;return 0;}\n\tlen[x]=len[son[x][r]]+1;\n\t--r;\n\twhile(l<r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+1>mid)return 1;\n\t\t++l;--r;\n\t}\n\treturn 0;\n}\nbool ok()\n{\n\tif(dfs(1))return 0;\n\treturn 1;\n}\nint erfen()\n{\n\tint l=1,r=n;\n\twhile(l+1!=r)\n\t{\n\t\tmid=(l+r)/2;\n\t\tif(ok())r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n};\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tcin>>n;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlk[x].pb(y);lk[y].pb(x);\n\t}\n\tGET_A::dfs(1,0);\n\tint B=GET_B::erfen();\n\tcout<<A<<\" \"<<B-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1 || res + 1 > B) return -1;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) return 0;\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\treturn ret;\n\t\t\t\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nconst int rt=1;int dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN],fson[MAXN];\ninline bool chk2(int k,int r)\n{\n\tfor(int p1=1,p2=k;p1<p2;p1++,p2--)\n\t{\n\t\tif(p1==r) p1++;if(p2==r) p2--;\n\t\tif(fson[p1]+fson[p2]>B) return false;\n\t}\n\treturn true;\n}\nbool dfs(int u,int la)\n{\n\tint k=0;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfson[++k]=f[v];\n\t}\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1)) fson[++k]=0;\n\tstd::sort(fson+1,fson+1+k);\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(chk2(k,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fson[l]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(rt,0)) return false;\n\tif(f[rt]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\taddEdge2(rt,1);\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0)data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if(v == pa) continue;\n\t\tif(! kt) return;\n\t\tchild++, dfs(v, u, lim);\n\t\tif(h[v] + 1 > lim) { kt = false; return; }\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t\tif(u == 1 && h[u] > lim) { kt = false; return; }\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++; dem /= 2;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << (dem + 1) / 2  << ' ' << ans;\n}\n/*\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\n\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tvector<int> vi;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvi.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vi.size()==0)return res[v]=P(1,1);\n\tsort(vi.begin(),vi.end());\n\tint l=0,r=(int)vi.size()-1;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vi[l]+vi[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP rec=dfs(0,-1,len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[200005];\nbool used[100005];\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tP mini=P(n+1,n+1);\n\tvector<int> vec;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvec.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vec.size()==0)return P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\tif(len_min==len){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.second==1 && res.first!=1)res.first--;\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nconst int rt=1;int dgr[MAXN];\nstruct E{int next,to;} e[MAXN];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN],fson[MAXN];\ninline bool chk2(int k,int r)\n{\n\tfor(int p1=1,p2=k;p1<p2;p1+=p1+1==r?2:1,p2-=p2-1==r?2:1)\n\t\tif(fson[p1]+fson[p2]>B) return false;\n\treturn true;\n}\nbool dfs(int u,int la)\n{\n\tint k=0;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfson[++k]=f[v];\n\t}\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1)) fson[++k]=0;\n\tstd::sort(fson+1,fson+1+k);\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(chk2(k,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fson[l]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(rt,0)) return false;\n\tif(f[rt]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\taddEdge2(rt,1);\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nint dfs(Graph<int> &g, int v, int p, int &mid) {\n  multiset<int, greater<int>> s;\n\n  for (int &nv : g[v]) {\n    if (nv != p) {\n      int ret = dfs(g, nv, v, mid);\n\n      if (ret == -1 || ret == mid) return -1;\n\n      s.insert(ret + 1);\n    }\n  }\n\n  bool odd = g[v].size() & 1;\n\n  while (s.size() > 1) {\n    int w = *begin(s); s.erase(s.begin());\n    auto itr = s.lower_bound(mid - w);\n\n    if (itr == s.end()) {\n      if (!odd) return -1;\n\n      odd = false;\n      continue;\n    }\n\n    s.erase(itr);\n  }\n\n  if (s.empty()) return 0;\n\n  return *begin(s);\n}\n\nvoid solve() {\n  int n; cin >> n;\n  Graph<int> g(n);\n  rep1(i,n) {\n    int a, b; cin >> a >> b; --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  int odd = 1;\n  rep(i,n) {\n    if (g[i].size() & 1) ++odd;\n  }\n\n  const int cnt = odd / 2;\n\n  int l = 0, r = n;\n\n  while (r - l > 1) {\n    int mid = (l + r) / 2;\n    if (dfs(g, 0, -1, mid) == -1) l = mid;\n    else r = mid;\n  }\n\n  cout << pii(cnt, r) << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100100;\nvi a[N];\nint n;\nint maxlen;\nint res;\n\nbool check(vi& ord, int pos) {\n\tif (ord[pos] + 1 > maxlen) {\n\t \treturn 0;\n\t}\n\tvi c;\n\tc.resize(sz(ord) - 1);\n\tint sz = 0;\n\tforn(i, sz(ord)) {\n\t\tif (i == pos)\n\t\t\tcontinue;\n\t\tc[sz++] = ord[i];\n\t}\t\n\tforn(i, sz(c) / 2) {\n\t\tif (c[i] + c[sz(c) - 1 - i] + 2 > maxlen) {\n\t\t \treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint calc(int v, int pr) {\n\tvi ord;       \n\tforn(i, sz(a[v])) {\n\t \tint to = a[v][i];\n\t \tif (to == pr)\n\t \t\tcontinue;\n\t \tint k = calc(to, v);\n\t\tif (k < 0) {\n\t\t \treturn -1;\n\t\t}\n\t\tord.pb(k);\n\t}\n\tsort(all(ord));\n\tif (!(sz(ord) & 1)) {\n\t\t//debug(sz(ord));\n\t\tforn(i, sz(ord) / 2) {\n\t\t \tif (ord[i] + ord[sz(ord) - 1 - i] + 2 > maxlen) {\n\t\t \t\treturn -1; \t\n\t\t \t}\n\t\t}\n\t\tres += sz(ord) / 2;\n\t\treturn 0;\n\t}\n\tif (!check(ord, sz(ord) - 1)) {\n\t \treturn -1;\n\t}\n\tint l = 0, r = sz(ord) - 1;\n\twhile (l < r) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(ord, m)) {\n\t\t \tr = m;\n\t\t} else {\n\t\t \tl = m + 1;\n\t\t}\n\t}\n\tres += sz(ord) / 2;\n\tif (!v)\n\t\tres++;\n\telse\n\tif (ord[l] + 1 == maxlen) {\n\t \tres ++;\n\t \treturn 0;\n\t}\n\treturn ord[l] + 1;\n}\n\nint main () {\n\t//std::ios::sync_with_stdio(false);\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tcin >> n;\n\tforn(i, n - 1) {\n\t \tint u, v;\n\t \tcin >> u >> v;\n\t \tu--, v--;\n\t \ta[u].pb(v);\n\t \ta[v].pb(u);\n\t}     \n\tint l = 1, r = n;\n\twhile (l < r) {\n\t    maxlen = (l + r) / 2;\n\t    res = 0;\n\t    if (calc(0, -1) < 0) {\n\t     \tl = maxlen + 1;\n\t    } else {\n\t     \tr = maxlen;\n\t    }\n\t}\n\tmaxlen = l;\n\tres = 0;\n\tdebug(maxlen);\n\tcalc(0, -1);\n\tcout << res << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N;\nvvll g;\n\nll dfs(ll u, ll v, ll x) {\n\tvll a;\n\tfor (ll w : g[v]) {\n\t\tif (u == w) { continue; }\n\t\tll k = dfs(v, w, x);\n\t\t//cout << w << \" \" << x << \" \" << k << endl;\n\n\t\tif (k == -1) { return -1; }\n\t\ta.push_back(k + 1);\n\t}\n\tsort(a.begin(), a.end());\n\tll M = a.size();\n\trep(i, M) {\n\t\tif (a[i] > x) { return -1; }\n\t}\n\n\tif (g[v].size() % 2 == 1) {\n\t\tbool b = 1;\n\t\trep(i, M) { if (a[i] + a[M - 1 - i] > x) { b = 0; } }\n\t\tif(b)return 0;\n\n\t\ta.pop_back();\n\t\tM--;\n\t}\n\t\n\n\trep(i, M - 1) { if (a[i] + a[M - 2 - i] > x) { return -1; } }\n\t\n\trep(i, M / 2) {\n\t\tif (a[i] + a[M - 1 - i] > x) {return a[M - 1 - i];}\n\t}\n\trep(i, M / 2) {\n\t\tll j = M / 2 - i;\n\t\tif (a[j] + a[M - j] > x) { return a[j]; }\n\t}\n\treturn a[0];\n}\n\nbool ch(ll x) {\n\tll leaf = 0;\n\trepn(i, N) { if (g[i].size() == 1) { leaf = i; break; } }\n\tll t = dfs(leaf, g[leaf][0], x);\n\tif (t!=-1&&t + 1 <= x) { return true; }\n\telse { return false; }\n}\nint main() {\n\tcin >> N;\n\tg.resize(N + 1);\n\trepn(i, N-1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tll cnt = 0;\n\trepn(i, N) { if (g[i].size() % 2 == 1) { cnt++; } }\n\tcout << cnt / 2 <<\" \";\n\n\tll l = 0;\n\tll r = N;\n\n\twhile (r - l > 1) {\n\t\tll m = (r + l) / 2;\n\t\tif (ch(m)) { r = m; }\n\t\telse { l = m; }\n\t}\n\n\tcout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 120000;\nint gfl = 0;\n\nvector<int> eds[MAXN];\nint n;\n\nint dfs1(int v, int x, int p) {\n\tvector<int> vv;\n\tfor (int u: eds[v]) {\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tvv.push_back(dfs1(u, x, v) + 1);\n\t}\n\tsort(vv.begin(), vv.end());\n\tfor (int u: vv)\n\t\tif (u > x) {\n\t\t\tgfl = 1;\n\t\t\treturn 0;\n\t\t}\n\tif ((p == -1 && vv.size() % 2 == 1) || (p != -1 && vv.size() % 2 == 0)) {\n\t\tif (!vv.empty())\n\t\t\tvv.pop_back();\n\t\telse\n\t\t\tvv.push_back(0);\n\t}\n\tif (p == -1) {\n\t\tfor (int i = 0; i < vv.size(); ++i) {\n\t\t\tif (vv[i] + vv[vv.size() - 1 - i] > x) {\n\t\t\t\tgfl = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\tfor (int i = 0; i < (int)vv.size() - 1; ++i) {\n\t\t\tif (vv[i] + vv[vv.size() - 2 - i] > x) {\n\t\t\t\tgfl = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint cur = vv.size() - 1;\n\t\twhile (cur > 0) {\n\t\t\tint oth = vv.size() - 2 - (cur - 1);\n\t\t\tif (oth >= cur)\n\t\t\t\t++oth;\n\t\t\tif (vv[cur] + vv[oth] > x)\n\t\t\t\tbreak;\n\t\t\t--cur;\n\t\t}\n\t\treturn vv[cur];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tint l = 0;\n\tint r = n;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) >> 1;\n\t\tgfl = 0;\n\t\tdfs1(0, mid, -1);\n\t\tif (gfl)\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid;\n\t}\n\tint a = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint c = eds[i].size() - 1;\n\t\tif (c)\n\t\t\t--c;\n\t\ta += (c + 1) / 2;\n\t}\n\tint c = eds[0].size();\n\ta += (c + 1) / 2;\n\tcout << a << \" \" << r << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n\n#include<set>\nstd::multiset<int> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int mid)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,mid)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>mid)return 0;\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\ts.clear();\n\t\tif(deg[o]&1)++cnt,s.insert(0);\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)++cnt,s.insert(f[e[p].to]+1);\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tint val=*s.rbegin();\n\t\t\ts.erase(s.find(val));\n\t\t\tstd::multiset<int>::iterator pl=s.upper_bound(mid-val);\n\t\t\tif(pl==s.begin())return 0;\n\t\t\t--pl;\n\t\t\ts.erase(pl);\n\t\t\tcnt-=2;\n\t\t}\n\t\tf[o]=*s.begin();\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,0,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(4);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,zero,b)\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a,T b){a=max(a,b);}\ntemplate<typename T> inline void minimize(T &a,T b){a=min(a,b);}\ntemplate<typename T> inline bool middle(T a,T b,T c){return b<=a && a<=c;}\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\ninline void outputVI(VI x){REP(i,SI(x)){cout << three(i,\" \",\"\") << x[i];}OUT(\"\");}\nconst int SIZE1=1e6+1000;\nconst int SIZE2=2020;\nconst int SIZE3=410;\nconst int SIZE=SIZE1;\nconst LL p=7+1e9;\nconst LL INF=1LL<<60;\nconst long double EPS=1e-7;\nstring S;\nut N,M,K,X,Y;\n// ut A,B,C,D,E,F,G,H,I,J,L,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE],nums[SIZE],maps[SIZE2][SIZE2],answer=zero;\n \n////////////////////////////////////////////////////////////////////////////////////////////\n \n////////////////////////////////////////////////////////////////////////////////////////////\nVI points[SIZE];\nbool reached[SIZE];\nint used[SIZE];\nbool able2(int x,int t){\n\tint s=0,e=points[x].size()-1;\n\twhile(s<=e){\n\t\tif(s==t){\n\t\t\ts++;\n\t\t}else if(e==t){\n\t\t\te--;\n\t\t}else{\n\t\t\tif(points[x][s]+points[x][e]>X) return false;\n\t\t\ts++;\n\t\t\te--;\n\t\t}\n\t}\n\treturn true;\n}\nint pack(int x){\n\tint s=0,e=points[x].size()-1;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tif(able2(x,f)) e=f-1;\n\t\telse s=f+1;\n\t}\n\tif(s==SI(points[x])) return -1;\n\treturn points[x][s];\n}\nbool able(int x){\n\tX=x;\n\tqueue<int> qu;\n\tREP(now,N+1) reached[now]=used[now]=0;\n\tREP(now,N+1) points[now].clear();\n\tEFOR(i,1,N){\n\t\tpoints[i].clear();\n\t\tif(SI(edges[i])==1) {\n\t\t\tqu.push(i);\n\t\t}\n\t}\n\n\twhile(!qu.empty()){\n\t\tint now=qu.front();\n\t\treached[now]=true;\n\t\n\t\tqu.pop();\n\t//\toutputVI(points[now]);\n\t//\tDEBUG(now);\n\t\tif(used[now]==SI(edges[now])){\n\t\t\tpoints[now].PB(0);\n\t\t\tif(SI(points[now])%2==0) points[now].PB(0);\n\t\t\tsort(ALL(points[now]));\n\t\t\treturn able2(now,0);\n\t\t}\n\t\tif(SI(points[now])%2==0) points[now].PB(0);\n\t\tsort(ALL(points[now]));\n\t\tint nokori=pack(now);\n\t\tif(nokori==-1) return false;\n\t\tREP(i,edges[now].size()){\n\t\t\tint next=edges[now][i];\n\t\t\tused[next]++;\n\t\t\tif(!reached[next] && used[next]>=SI(edges[next])-1){\n\t\t\t\tqu.push(next);\n\t\t\t\tpoints[next].PB(nokori+1);\n\t\t\t}else if(!reached[next]){\n\t\t\t\tpoints[next].PB(nokori+1);\t\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nLL solve(){\n\tcin >> N;\n\tint a,b;\n\tREP(i,N-1){\n\t\tcin >>a >> b;\n\t\tedges[a].PB(b);\n\t\tedges[b].PB(a);\n\t}\n\tint A=1;\n\tEFOR(i,1,N){\n\t\tA+=(SI(edges[i])-1)/2;\n\t}\n\tint s=0,e=N-1;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t//\tDEBUG(f);\n\t\tif(able(f)) e=f-1;\n\t\telse s=f+1;\n\t}\n\tcout << A <<\" \" << s << endl;\n\treturn 0;\n}\nsigned main(){\n//\tOUT(solve());\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\n\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint isok=0,p=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tif(!isok) return 1;\n\tsort(all(v));\n\tint ret=0;\n\tfor(int l=0,r=SZ(v)-1;l<r;r--)\n\t\tif(v[l]+v[r]+1<=B) l++,ret++;\n\tif(ret*2==SZ(v)){res+=ret;return 1;}\n\tmultiset<int> s;\n\tres+=SZ(v)-ret-1;\n\ts.clear();\n\tfor(int i=0;i<=ret*2;i++) s.insert(v[i]);\n\tfor(int i=ret*2;i>=0;i--){\n\t\tauto pos=s.find(v[i]);\n\t\tif(pos==s.end()) continue;\n\t\ts.erase(pos);\n\t\tauto it=s.upper_bound(B+1-v[i]);\n\t\tif(it!=s.begin()) s.erase(--it); else{p=v[i];break;}\n\t}\n\tif(p+1==B){res++;return 1;}\n\treturn p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"08.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        if(check(vec, 0, cri)){\n            if(vec[0] >= cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] >= cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri) return false;\n        }\n        dp[u] = 0;\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=100100,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\n\tmit it;\n\tint w,dw,cnt;\n\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\n\t\tS.clear();\n\t\tcnt=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tint maxw=-1;\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tw=it->first,dw=lim-w;\n\n\t\t\t(it->second)--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\n\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())\n\t\t\t{\n\t\t\t\tmaxw=w;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse it--;\n\n\t\t\t(it->second)--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)\n\t\t{\n\t\t\tif(maxw>0)\n\t\t\t{\n\t\t\t\tf[p]--;\n\t\t\t\tg[p]=maxw;\n\t\t\t}\n\t\t\telse g[p]=0;\n\t\t}\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=0;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(s.size() == 1 || other==s.end()) {\n\t\t\t\tdp[x].f += dp[x].s > 0;\n\t\t\t\tdp[x].s = y;\n\t\t\t\ts.erase(s.begin());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tdp[x].s += x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=150;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}assert(en^150);\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\n\ninline bool cmp(int a,int b){return F[a]<F[b];}\n\ninline bool dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tif(!dfs(vs[i].v,rt,x)) return false;\n\t\tv.push_back(vs[i].v);\n\t}\n\tif(v.size()==0){\n\t\tF[rt]=1;\n\t\treturn true;\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end(),cmp);\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tint tmp1=F[v[i]],tmp2=F[v[j]];\n\t\t\tfg&=(tmp1+tmp2)<=x;\n\t\t}\n\t\tif(fg) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l==v.size()) return false;\n\tF[rt]=F[v[l]]+1;\n\treturn F[rt]<=x+1;\n}\ninline bool check(int x)\n{\n\treturn dfs(Rt,0,x);\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(!(v.size()&1)) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\tint l=0,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, mid;\nvi adj[MX];\nbool ok;\n\nbool OK(vi v, int ind) {\n    // if (v[ind]+1 > mid) return 0;\n    v.erase(v.begin()+ind);\n    for (int i = 0; i < sz(v)-1-i; ++i) if (v[i]+v[sz(v)-1-i] > mid) return 0;\n    return 1;\n}\n\nint test(int cur, int pre) {\n    if (!ok) return 0;\n    vi v; for (int i: adj[cur]) if (i != pre) v.pb(test(i,cur));\n    if (!ok) return 0;\n    \n    if (cur == 1) {\n        if (sz(v) % 2 == 1) v.pb(0);\n        sort(all(v));\n        for (int i = 0; i < sz(v)-1-i; ++i) if (v[i]+v[sz(v)-1-i] > mid) ok = 0;\n        return 0;\n    } else {\n        if (sz(v) % 2 == 0) v.pb(0);\n        sort(all(v));\n        int lo = 0, hi = sz(v);\n        while (lo < hi) {\n            int mid = (lo+hi)/2;\n            if (OK(v,mid)) hi = mid;\n            else lo = mid+1;\n        }\n        // cout << \"ZZ \" << cur << \" \" << lo << \" \" << sz(v) << \" \" << v[0] << \"\\n\";\n        if (lo == sz(v)) {\n            ok = 0;\n            return 0;\n        }\n        if (v[lo]+1 > mid) {\n            ok = 0;\n            return 0;\n        }\n        // cout << \"HAHA \" << ok << \" \" << cur << \" \" << v[lo] << \"\\n\";\n        return v[lo]+1;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        // int a = i+1,b = i+2; \n        int a,b; cin >> a >> b;\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    // cout << ok << \"\\n\";\n    int A = 0; FOR(i,1,N+1) if (sz(adj[i])&1) A++;\n    int lo = 1, hi = N-1; \n    while (lo < hi) {\n        mid = (lo+hi)/2;\n        ok = 1; test(1,0);\n        if (ok) hi = mid;\n        else lo = mid+1;\n    }\n    cout << A/2 << \" \" << lo;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int INF = 100005;\nint N;\nvi G[100005];\nvi va[100005];\n\nint bin(vi &a, int r, int lim) {\n    auto g = [&](int mid) {\n        int i = 0, j = r - 1;\n        for (int k = 0; k < r / 2;) {\n            if (i == mid) i++;\n            else if (j == mid)j--;\n            else {\n                k++;\n                if (a[i++] + a[j--] > lim) {\n                    RT 0;\n                }\n            }\n        }\n        RT 1;\n    };\n\n    if (!g(r - 1))RT - 1;\n\n    int ok = r - 1, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        (g(mid) ? ok : ng) = mid;\n    }\n    RT ok;\n}\n\nint f(int u, int p, int lim) {\n    int C = sz(G[u]) - 1;\n\n    auto &a = va[u];\n    if (sz(a) < C) {\n        a.reserve(C);\n        a.resize(C);\n    }\n\n    for (int i = 0, j = 0; i < sz(G[u]); ++i) {\n        int v = G[u][i];\n        if (v != p) {\n            a[j++] = f(v, u, lim);\n        }\n    }\n    sort(all(a));\n    if (sz(a) && a.back() > lim)RT INF;\n\n    if (C % 2) {\n        rep(i, C / 2) if (a[i] + a[C - 2 - i] > lim)RT INF;\n        int k = bin(a, C, lim);\n        if (k == -1)RT INF;\n        RT a[k] + 1;\n    } else {\n        int chk = 1;\n        rep(i, C / 2) {\n            if (a[i] + a[C - 1 - i] > lim) {\n                chk = 0;\n                break;\n            }\n        }\n        if (chk)RT 1;\n\n        int k = bin(a, C - 1, lim);\n        if (k == -1)RT INF;\n        RT a[k] + 1;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    cin >> N;\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    int A = 0;\n    rep(i, N + 1)A += sz(G[i]) & 1;\n    A /= 2;\n    G[1].push_back(0);\n\n    int ng = 0, ok = N;\n    while (ok - ng > 1) {\n        int mid = (ng + ok) / 2;\n        int re = f(1, 0, mid);\n        (re - 1 <= mid ? ok : ng) = mid;\n    }\n    \n    int B = ok;\n    cout << A << ' ' << B << endl;\n    f(1, 0, 4);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=100005;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint num,n,l,r,mid,ans,rt,x,y,tag;\nint dp[N],head[N],d[N],f[N],g[N];\n\nvoid add(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num; d[x]++;\n}\n\nvoid dfs(int k,int pre,int w){\n\tint u,j,cnt=0,L,R,Mid,m; bool flag;\n\tif (!tag) return;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tdfs(u,k,w);\n\t}\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tf[++cnt]=dp[u];\n\t}\n\tif (!(cnt&1)) f[++cnt]=0;\n\tsort(f+1,f+1+cnt);\n\tif (cnt==1){\n\t\tdp[k]=f[1]+1;\n\t\tif (dp[k]-1>w) tag=0;\n\t\treturn;\n\t}\n\tL=1; R=cnt;\n\twhile (L<R){\n\t\tMid=L+(R-L)/2;\n\t\tm=0; flag=1;\n\t\tfor (j=1;j<=cnt;j++)\n\t\t\tif (j!=Mid) g[++m]=f[j];\n\t\tfor (j=1;j<=m/2;j++)\n\t\t\tif (g[j]+g[m-j+1]>w){\n\t\t\t\tflag=0; break;\n\t\t\t}\n\t\tif (flag) R=Mid;\n\t\telse L=Mid+1;\n\t\tif (Mid==cnt&&!flag) tag=0;\n\t}\n\tdp[k]=f[R]+1;\n\tif (dp[k]-1>w) tag=0;\n}\n\nbool check(int w){\n\ttag=1;\n\tdfs(rt,0,w);\n\tif (dp[rt]-1>w) tag=0;\n\treturn tag;\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (i=1;i<=n;i++)\n\t\tif (d[i]&1) ans++,rt=i;\n\tprintf(\"%d \",ans/2);\n\tl=1; r=n-1;\n\twhile (l<r){\n\t\tmid=l+(r-l)/2;\n\t\tif (check(mid)) r=mid;\n\t\telse l=mid+1; \n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, lng, num, md;\nvector<int> g[N];\npii fn;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\t++nt;\n\t\tst.insert(1 + dfs(v, u));\n\t}\n\tnum += nt/2;\n\tvector<int> go;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (st.size() && *it + bk <= md) {\n\t\t\tlng = max(lng, *it + bk);\n\t\t\tst.erase(it);\n\t\t} else {\n\t\t\tgo.pb(bk);\n\t\t\tlng = max(lng, bk);\n\t\t}\n\t}\n\tsort(go.begin(),go.end());\n\tif(nt%2 == 0 && go.size() > 2)lng = oo;\n\tif(nt%2 == 1 && go.size() > 1)lng = oo;\n\tif(!go.size())return 0;\n\treturn go[0];\n}\n\nbool check() {\n\tlng = num = 0;\n\tint res = dfs(1, -1);\n\tlng = max(lng, res);\n\tnum += (res > 0);\n\treturn lng <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n/*\tmd = 2;\n\tcout << check() << endl;\n\tcout << lng << \" \" << num << endl;\n\treturn 0;*/\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tfn = mp(num, lng);\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", fn.x, fn.y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n        if (dp[u]+1>k){\n            p1=1;\n            return ;\n        }\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n   vector <int> y;\n    while(s.size()>1){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n\n                y.pb(val1);\n                continue;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()){\n        y.pb(*s.begin());\n    }\n    if (y.size()>2){\n        p1=1;\n        return ;\n    }\n    if (y.size()){\n        sort(y.begin(),y.end());\n        for (int i=1;i<y.size();i++) z++;\n        dp[v]=y[0];\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t;\n\nbool ok(int mid) {\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (v == 0) {\n\t    int m = t.size()/2;\n\t    sort(t.begin(), t.end());\n\t    REP (j, m) if (t[j] + t[m*2-1-j] > mid) return false;\n\t    if (t.size() % 2 && t.back() > mid) return false;\n\t    return true;\n\t} else {\n\t    if (t.size() % 2 == 0) t.push_back(0);\n\t    sort(t.begin(), t.end());\n\t    int m = t.size() / 2;\n\t    dp[v] = -1;\n\t    int pos = 0;\n\t    REP (j, m) {\n\t\tint c = t.rbegin()[j];\n\t\twhile (pos < (int)t.size() && t[pos] + c <= mid) pos++;\n\t\tif (pos <= j) return false;\n\t\tif (dp[v] == -1 && pos > j + 1) dp[v] = t[j];\n\t\tif (pos == j+1) dp[v] = -1;\n\t    }\n\t    if (dp[v] == -1) dp[v] = t[m];\n\t}\n    }\n\n    assert(false);\n    return dp[0] <= mid;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += ((int)G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,avx2,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 1e9 + 7;\nint n, _x;\nvector<int> g[maxn];\nint B = 0, A = 0;\nint get(vector<int> &a, int s) {\n\tint l = 0, r = a.size()-1, mx = 0;\n\tif(l == s) l++;\n\tif(r == s) r--;\n\twhile(l < r) {\n\t\tmx = max(mx, a[l] + a[r]);\n\t\tl++, r--;\n\t\tif(l == s) l++;\n\t\tif(r == s) r--;\n\t}\n\treturn mx;\n}\nll dfs(int v, int p, int h = 0) {\n\tvector<int> ch;\n\tif(g[v].size()&1) ch.pb(h);\n\tfor(auto i : g[v]) if(i != p) {\n\t\tint t = dfs(i, v, h+1);\n\t\tif(t == -1) return -1;\n\t\tif(t) ch.pb(t);\n\t}\n\tsort(all(ch));\n\tif(ch.size()%2 == 0) {\n\t\treturn get(ch, -1)-2*h <= _x ? 0 : -1;\n\t}\n\tp = 0;\n\tfor(int i = 1<<17; i>>=1;)\n\t\tif(get(ch, p+i)-2*h > _x) p += i;\n\tp += (get(ch, p)-2*h > _x);\n\treturn p >= ch.size() ? -1 : ch[p];\n}\nbool can(int x) {\n\t_x = x;\n\treturn dfs(1, 1) != -1;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tfor(int i = 1; i <= n; i++) A += g[i].size()&1; A/=2;\n\tfor(int i = 1<<17; i>>=1;) if(!can(B+i)) B += i;\n\tcout << A << \" \" << B+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nint N;\nvint G[111111];\n\nint K;\n\nint dfs(int v,int p){\n    vint a;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        int tmp=dfs(u,v);\n        if(tmp==INF)return INF;\n        a.pb(tmp);\n    }\n\n    sort(all(a));\n    if(p==-1)return 0;\n    if(a.size()==0)return 1;\n\n    if(a.size()%2==0)a.pop_back();\n\n    int lb=-1,ub=a.size();\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n\n        bool f=true;\n        int l=0,r=a.size()-1;\n        rep(i,a.size()/2){\n            if(l==mid)l++;\n            if(r==mid)r--;\n            if(a[l]+a[r]>K)f=false;\n            l++;r--;\n        }\n        if(f)lb=mid;\n        else ub=mid;\n    }\n    if(lb==-1)return INF;\n    if(a[lb]+1>K)return INF;\n    return a[lb]+1;\n}\n\nbool C(int x){\n    K=x;\n    rep(i,N)if(G[i].size()==1)return dfs(i,-1)!=INF;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    int cnt=0;\n    rep(i,N)if(G[i].size()%2)cnt++;\n\n    int A=cnt/2;\n\n    int lb=0,ub=N;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        if(C(mid))ub=mid;\n        else lb=mid;\n    }\n\n    cout<<A<<\" \"<<ub<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans_a, ans_b;\n\t\n\tvoid write () {\n\t\tcout << ans_a << ' ' << ans_b << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint mxl;\n\t\t\n\t\tint rec (int v, int pr) {\n\t\t\tvi q;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint val = rec(to, v);\n\t\t\t\tif (val == -1 || val + 1 > mxl) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tq.pb(val + 1);\n\t\t\t}\n\t\t\tsort(all(q), greater<int>());\n\t\t\t\n\t\t\tif (!sz(q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint val0 = q[0];\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tq[0] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (j < sz(q) && (j <= i || q[j] == -1 || q[i] + q[j] > mxl)) {\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tif (j < sz(q)) {\n\t\t\t\t\tq[i] = q[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvi qq;\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tqq.pb(val0);\n\t\t\t}\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] != -1) {\n\t\t\t\t\tqq.pb(q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sz(qq) == 2 && qq[0] + qq[1] < mxl) {\n\t\t\t\tqq.clear();\n\t\t\t}\n\t\t\t\n\t\t\tif (sz(qq) == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (sz(qq) == 1) {\n\t\t\t\treturn qq[0];\n\t\t\t} else if (sz(qq) == 2) {\n\t\t\t\tif (sz(e[v]) & 1) {\n\t\t\t\t\treturn qq[1];\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\n\t\tbool check (int val) {\n\t\t\tmxl = val;\n\t\t\treturn rec(0, -1) != -1;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tans_a = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tif (sz(e[i]) & 1) {\n\t\t\t\t\tans_a++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_a /= 2;\n\t\t\t\n\t\t\tint lb = 0, rb = n - 1;\n\t\t\twhile (lb < rb) {\n\t\t\t\tint md = (lb + rb) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\trb = md;\n\t\t\t\t} else {\n\t\t\t\t\tlb = md + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_b = lb;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0, resb = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tresb += g[i].size()%2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tresa--; resb /= 2;\n\tint lb = -1, ub = n;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resb<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\tif(u.size() && u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size() - 1; i < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j == mid) j--;\n\t\t\t\tif(i < j && u[i] + u[j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check_even(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint root;\nint solve_even(vi & legs, int mx){\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check_even(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check_even(legs, lo, mx)) return legs[lo];\n    else if(check_even(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nint solve_odd(vi & legs, int mx){\n    int l = 0;\n    int r = sz(legs) - 1;\n    bool good = true;\n    while(l<=r){\n        if(legs[l]+legs[r]>mx) {\n            good = false; break;\n        }\n        l++; r--;\n    }\n    if(good) return 0;\n    int id = -1;\n    f0r(i, sz(legs)) if(legs[i]<mx) id = i;\n    if(id == -1){\n        ok = false;\n        return legs.back();\n    }\n    legs.erase(legs.begin()+id);\n    return solve_even(legs, mx);\n}\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src]) == 1) return 0;\n    vi legs;\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        int l = 0;\n        int r = sz(legs)-1;\n        while(l<=r){\n            if(legs[l]+legs[r]>mx){\n                ok = false; return legs.back();\n            }\n            l++; r--;\n        }\n        return legs.back();\n    }\n    if(sz(adj[src])%2 == 0) return solve_even(legs, mx);\n    else return solve_odd(legs, mx);\n}\nint main(){\n//    setIO(\"temp\");\n    setIO(\"\");\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    int cent = -1;\n    f0r(i, n) if(sz(adj[i])%2 == 0) cent = i;\n    if(cent == -1){\n        ps(a, 1); return 0;\n    }\n    root = cent;\n    int lo = 1;\n    int hi = MAX;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(cent, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(cent, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (x==1){\n\t\tif (top&1) ok&=check(top);\n\t\telse ok&=check(-1);\n\t\treturn;\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O+1)?stk[r]+1:(-1);\n\t}\n\telse{\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O+1)?stk[r]+1:(-1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=1,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A;\nvector<int> e[N];\n\nint g(vector<int> &v, int z){\n    for(int i = -(v.size() & 1), j = int(v.size()) - 1; i < j; i++, j--){\n        int t = v[j];\n        if(i >= 0) t += v[i];\n        if(t > z) return -1;\n    }\n    return 0;\n}\n\nint h(vector<int> &v, int m, int z){\n    if((m >= 0 ? v[m] : 0) + 1 > z) return -1;\n    vector<int> w;\n    for(int i = 0; i < v.size(); i++) if(i != m) w.push_back(v[i]);\n    return g(w, z);\n}\n\nint f(int x, int y, int z){\n    vector<int> v;\n    for(int i : e[x]){\n        if(i == y) continue;\n        v.push_back(f(i, x, z));\n        if(v.back() < 0) return -1;\n    }\n    if(v.empty()) return 1;\n    sort(v.begin(), v.end());\n    if(!y) return g(v, z);\n    int l = -(~v.size() & 1), r = v.size() - 1;\n    while(l < r){\n        int m = (l + r + 2) / 2;\n        if(h(v, m, z) >= 0) r = m - 1;\n        else l = m;\n    }\n    if(h(v, l, z) < 0) return -1;\n    return (l >= 0 ? v[l] : 0) + 1;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 0, x, y; i < n - 1; i++){\n        scanf(\"%d%d\", &x, &y);\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    A = n - 1;\n    for(int i = 1; i <= n; i++) A -= int(e[i].size()) / 2;\n    printf(\"%d \", A);\n    int l = 1, r = n;\n    while(l < r){\n        int m = (l + r) / 2;\n        if(f(1, 0, m) >= 0) r = m;\n        else l = m + 1;\n    }\n    printf(\"%d\\n\", l);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n\nusing namespace std;\n\n\nGraph<> tree;\nint A, B;\n\n// Aを求める\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\n// パスの最大長がB以下になるようにしたとき、\n// 親に送られるパスの最小値(無理ならINF)を返す\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    // ダミーを仕込んで奇数の場合に帰着させる\n    if (ch.size() % 2 == 0) ch.push_back(0);\n\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n\n    int r;\n    for (r = 0; tree[r].size() > 1; ++r) {}\n\n    A = 0;\n    dfs1(r, -1);\n    ++A;  // 根から出てくるパスを受け取る\n\n    // Bを二分探索\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(r, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, X;\nvector<int> G[100000];\nint dp[100000];\nP rooted[100000];\n\nint solve(vector<int> &A, int except) {\n  int r = A.size()-1, c = 0;\n  rep(l, A.size()) if (l != except) {\n    while (l < r && (r == except || A[l]+A[r] > X)) r--;\n    if (l >= r) break;\n    c++, r--;\n  }\n  //cout<<\"solve({\";rep(i, A.size()) if (i!=except)cout<<A[i]<<\",\";cout<<\"}, X=\"<<X<<\") = \"<<c<<\"\\n\";\n  return c;\n}\n\nvoid dfs(int x, int p) {\n  for (int t : G[x]) if (t != p) dfs(t, x);\n  int sum = 0;\n  vector<int> ds;\n  for (int t : G[x]) if (t != p) sum += rooted[t]._1, ds.pb(rooted[t]._2);\n  sort(all(ds));\n  int m = solve(ds, -1);\n  dp[x] = sum-m;\n  rooted[x] = P(dp[x]+1, 1);\n  if (ds.size() == 0) return;\n\n  int r = ds.size()-1;\n  while (r >= 0 && ds[r]+1 > X) r--;\n  if (r < 0) return;\n  int best = solve(ds, r);\n  int lo = -1, hi = r;\n  while (hi - lo > 1) {\n    int mid = (lo + hi) / 2;\n    if (solve(ds, mid) == best) hi = mid;\n    else lo = mid;\n  }\n  rooted[x] = min(rooted[x], P(sum-best, ds[hi]+1));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  X = N;\n  dfs(0, -1);\n  int best = dp[0];\n  int lo = 0, hi = N;\n  while (hi - lo > 1) {\n    int mid = (lo + hi) / 2;\n    X = mid;\n    dfs(0, -1);\n    if (dp[0] == best) hi = mid;\n    else lo = mid;\n  }\n  cout << best << \" \" << hi << \"\\n\";\n  //for (X=1; X<=N; X++) { dfs(0, -1);cout<<\"X=\"<<X<<\": \"<<dp[0]<<\"\\n\"; }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,x,y,ans,l,r,mid,tot,rt,f[N],a[N],g[N],head[N],d[N];\nstruct edge{int v,nxt;}e[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool dp(int u,int fa){\n    f[u]=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) if (!dp(v,u)) return 0;\n    //printf(\"+++++++%d+++++++\\n\",u);\n    //for (int i=head[u],v;i;i=e[i].nxt)\n        //if ((v=e[i].v)!=fa) printf(\"%d\\n\",f[v]);\n    int xb=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) a[++xb]=f[v]+1;\n    if ((xb&1)==0) a[++xb]=0;\n    sort(a+1,a+xb+1);//for (int i=1;i<=xb;i++) cout<<a[i]<<endl;\n    memset(g,-1,sizeof(int)*(xb+1));\n    int j,k; j=1;\n    for (int i=xb;i>=1;i--){\n        g[i]=g[i+1];\n        for (;j<i && a[j]+a[i]<=mid;j++) g[i]=j;\n        j--;\n    }\n    j=0,k=0;\n    for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+1){k=i; break;}// cout<<\"orz\"<<k<<endl;\n    if (k==0){\n        j=1; for (int i=xb;i>xb/2+1;i--) if (g[i]<xb-i+2) j=xb-i+2;\n        f[u]=a[j];\n    }\n    else{\n        j=0; for (int i=xb;i>j+1;i--) if (k!=i){j++; if (a[i]+a[j]>mid) return 0;}\n        f[u]=a[k];\n    }\n    if (u==rt && f[u]>mid) return 0;\n    return 1;\n}\n\nint main(){//freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){scanf(\"%d%d\",&x,&y); add(x,y); add(y,x); d[x]++; d[y]++;}\n    for (int i=1;i<=n;i++) if (d[i]&1) ans++;\n    for (int i=1;i<=n;i++) if (d[i]==1){rt=i; break;}// cout<<rt<<endl;\n    ans/=2; printf(\"%d \",ans);\n    l=1,r=n;\n    while (l<=r){\n        mid=(l+r)>>1; memset(f,0,sizeof f);\n        if (dp(rt,0)){ans=mid; r=mid-1;} else l=mid+1;\n    }//*/mid=3; if (dp(rt,0)) puts(\"orz\");\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            s.insert(dp[a[x][i]]+1);\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        if(t>maxl)\n            return 0;\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==0)\n                dp[x]=t;\n            flag=-1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    else\n        dp[x]=0;\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nvector<int> graph[N];\nint root;\nint A, t;\nint beginning;\n\nint find_value(vector<int> &dp, int M)\n{\n    int L = -1, R = dp.size();\n    while (L + 1 < R)\n    {\n        int mid = (L + R) / 2;\n        int j = dp.size() - 1;\n        int t = 1;\n        for (int i = 0; i < j; )\n        {\n            if (i == mid) i++;\n            if (j == mid) j--;\n            if (dp[i] + dp[j] > M) t = 0;\n            i++, j--;\n        }\n        if (t) R = mid;\n        else L = mid;\n    }\n    return dp[R];\n}\n\nint dfs(int v, int p, int M)\n{\n    vector<int> dp;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dp.push_back(dfs(u, v, M));\n    }\n    if (dp.size() % 2 == 0) dp.push_back(0), beginning++;\n    sort(all(dp));\n    int x = find_value(dp, M) + 1;\n    if (x == M) x = 1, beginning++;\n    return x;\n}\n\nint check(int M)\n{\n    t = 0;\n    beginning = 0;\n    dfs(root, root, M);\n    if ((beginning + 1) / 2 <= A) return 1;\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    int cnt_odd = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (graph[i].size() == 1) root = i;\n        cnt_odd += (graph[i].size() % 2);\n    }\n    cout << (cnt_odd + 1) / 2 << \" \";\n    A = (cnt_odd + 1) / 2;\n    int L = 0, R = n;\n    while (L + 1 < R)\n    {\n        int M = (L + R) / 2;\n        if (check(M)) R = M;\n        else L = M;\n    }\n    cout << R;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define si scanf\n#define so printf\n#define N 200100\n#define M \n#define INF  \n#define nxt t[j]\ntemplate<typename TP>inline bool rd(TP& r)\n{\n\tr=0;\n\tchar tmp=getchar();\n\twhile(tmp<'0'||tmp>'9')\n\t{\n\t\tif(tmp==EOF)\n\t\t\treturn 0;\n\t\ttmp=getchar();\n\t}\n\twhile('0'<=tmp&&tmp<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+tmp-'0';\n\t\ttmp=getchar();\n\t}\n\treturn 1;\n\t\n} \nint n; \nint h[N],x[N*2],t[N*2],tot=1;\nint du[N],A;\nvoid add(int u,int v)\n{\n\t++tot;\n\tx[tot]=h[u];\n\th[u]=tot;\n\tt[tot]=v;\n\t++du[u];\n}\nint ln[N],l2[N];\nint f[N];\nbool ok(int mid,int u)\n{\n\tfor(int i=1;i<=ln[0];++i)\n\t\tif(i==mid)\n\t\t\tl2[i]=n+100;\n\t\telse\n\t\t\tl2[i]=ln[i];\n\tsort(l2+1,l2+ln[0]+1);\n\tfor(int i=1;i<ln[0];++i)\n\t\tif(l2[i]+l2[ln[0]-i]+1>u)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dp(int u)\n{\n\tsort(ln+1,ln+ln[0]+1);\n\tfor(int i=1;i<=ln[0]-1;++i)\n\t\tif(ln[i]+ln[ln[0]-i]+1>u)//无法配对 \n\t\t\treturn n+100;\n\tint l=1,r=ln[0],mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(ok(mid,u))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\treturn ln[l]+1;\n}\nbool dfs(int now,int u,int fa)\n{\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tif(dfs(nxt,u,now)==0)\n\t\t\t\treturn 0;\n\tln[0]=0;\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tln[++ln[0]]=f[nxt];\n\tif(du[now]&1)\n\t\tln[++ln[0]]=0;\n\tf[now]=dp(u);\n\tif(f[now]>u)\n\t\treturn 0; \n\treturn 1;\n}\nint main()\n{\n\trd(n);\n\tint u,v;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\trd(u),rd(v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(du[i]&1)\n\t\t\t++A;\n\tA>>=1;\n\tint l=1,r=n,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tmemset(f,0x3f,sizeof(f));\n\t\tif(dfs(1,mid,0))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tso(\"%d %d\\n\",A,l-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  V<> deg(n);\n  for (int _ = 0; _ < n - 1; ++_) {\n    int u, v; cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    ++deg[u], ++deg[v];\n  }\n  cout << count_if(begin(deg), end(deg), [](int x) { return x & 1; }) / 2 << ' ';\n  auto chk = [&](int x) -> bool {\n    V<> dp(n, 1e9);\n    auto dfs = [&](const auto& dfs, int v, int p) -> void {\n      multiset<int> ms;\n      for (int w : g[v]) if (w != p) {\n        dfs(dfs, w, v);\n        ms.insert(dp[w] + 1);\n      }\n      if (~ms.size() & 1) ms.insert(0);\n      while (ms.size() >= 2) {\n        auto itr = ms.upper_bound(x - *prev(end(ms)));\n        if (itr == begin(ms)) return;\n        ms.erase(--itr);\n        ms.erase(prev(end(ms)));\n      }\n      dp[v] = *begin(ms);\n    };\n    int r = -1;\n    for (int v = 0; v < n; ++v) if (deg[v] == 1) {\n      r = v;\n      break;\n    }\n    dfs(dfs, r, -1);\n    return dp[r] <= x;\n  };\n  int ng = 0, ok = n - 1;\n  while (ok - ng > 1) {\n    int mid = ng + ok >> 1;\n    (chk(mid) ? ok : ng) = mid;\n  }\n  cout << ok << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,ed,B,g[N],f[N],q[N],deg[N];\nstruct E{int v,nxt;}e[N<<1];\ninline void adde(int x,int y){e[++ed].v=y;e[ed].nxt=g[x];g[x]=ed;}\nint dfs(int x,int y){\n\tint i;f[x]=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y&&!dfs(e[i].v,x))return 0;\n\tint t=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y)q[++t]=f[e[i].v]+1;\n\tif(!t)return 1;\n\tif(~t&1)q[++t]=0;\n\tsort(q+1,q+1+t);\n\tint l=1,r=t+1;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;\n\t\tint l1=0,r1=t+1;\n\t\tfor(i=1;i<=t/2;++i){\n\t\t\tif(++l1,l1==mid)++l1;\n\t\t\tif(--r1,r1==mid)--r1;\n\t\t\tif(q[l1]+q[r1]>B)break;\n\t\t}\n\t\tif(i<=t/2)l=mid+1;\n\t\telse r=mid;\n\t}\n\tif(l>t||q[l]>B)return 0;\n\treturn f[x]=q[l],1; \n}\n\nint main(){\n\t//freopen(\"aa.in\",\"r\",stdin);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);adde(y,x);\n\t\t++deg[x];++deg[y];\n\t}\n\tint tot=0;\n\tfor(i=1;i<=n;++i)if(deg[i]&1)++tot;\n\ttot>>=1;\n\tint l=1,r=n;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;B=mid;\n\t\tif(!dfs(1,1))l=mid+1;\n\t\telse r=mid;\n\t}\n\tprintf(\"%d %d\",tot,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u));\n    if(vals.size() == 0) return 1;\n    if(vals.size()%2 == 0) vals.pb(0);\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size()-1;\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    //cout << \"leastUp \" << u << \": \" << vals[rb]+1 << endl;\n    return vals[rb]+ (u != 0);\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    return 0 < l and l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    adj[0].pb(0);\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\n\nvector<int> T[MX];\nint N, m, val = 1;\n\nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( X.empty() ) return 0;\n\tif( X.back() > m ) val = 0;\n\n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tint op = X.size()/2 > i ? X.size()-i-1 : X.size()-i;\n\t\tif( X[i] + X[op] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n\nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    s.clear();\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl){\n                return 0;\n            }\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    if(x==1)\n        flag--;\n    /*if(x==83)\n        for(int i=0;i<a[x].size();i++)\n            if(a[x][i]!=fa)\n                PF(\"{%d} \",dp[a[x][i]]+1);*/\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==1){\n                dp[x]=t;\n                flag=-1;\n            }\n            else{\n                if(x!=1)\n                    flag=1;\n                else\n                    flag=-1;\n            }\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl){\n            return 0;\n        }\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    //PF(\"[%d]\",check(6));\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l+1;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tint ans=dfs(1,-1);\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<bool, Int> P;\n\n\nvector<int> edge[110000];\nint n, u, v;\n\nP check(vector<int> &tmp, int b){\n    int k = tmp.size();\n    if(k == 1)return P(true, tmp[0]);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-2-i] > b)return P(false, 0);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-1-i] > b)return P(true, tmp[k-1-i]);\n    for(int i = 0;i < k / 2 + 1;i++)\n        if(tmp[i] + tmp[k-i] > b)return P(true, tmp[0]);\n    return P(true, tmp[0]);\n}\n\nP dfs(int x, int b, int last = -1){\n    vector<int> tmp;\n    for(auto to: edge[x]){\n        if(to == last)continue;\n        auto p = dfs(to, b, x);\n        if(!p.first)return P(false, 0);\n        if(p.second == b)return P(false, 0);\n        tmp.push_back(p.second + 1);\n    }\n    sort(tmp.begin(), tmp.end());\n    int k = tmp.size();\n    if(tmp.size() % 2 == 0){\n        bool ok = true;\n        for(int i = 0;i < k/2;i++)\n            if(tmp[i] + tmp[k-1-i] > b)ok = false;\n        if(ok)return P(true, 0);\n        tmp.pop_back();\n    }\n    return check(tmp, b);\n}\n\nint main(){\n    cin >> n;\n    int a = 0;\n    for(int i = 0;i < n-1;i++){\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    for(int i = 1;i <= n;i++)if(edge[i].size() % 2)a++;\n    a/=2;\n\n    int bottom  = 0, top = n;\n    while(top - bottom > 1){\n        int mid = (top + bottom) / 2;\n        if(dfs(1, mid).first)top = mid;\n        else bottom = mid;\n    }\n    cout << a << \" \" << top << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nbool tmp[100005];\nP res[100005];\nint cnt[100005];\n\nP solve(int len){\n\tmemset(used,false,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++){\n\t\tif(G[i].size()==1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tint prev=-1;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tprev=v;\n\t\tque.pop();\n\t\tused[v]=true;\n\t\tint sum=0;\n\t\tvector<int> vi;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tif(used[nv]){\n\t\t\t\tvi.push_back(res[nv].second);\n\t\t\t\tsum+=res[nv].first;\n\t\t\t}else{\n\t\t\t\tcnt[nv]++;\n\t\t\t\tif(cnt[nv]+1==G[nv].size())que.push(nv);\n\t\t\t}\n\t\t}\n\t\tif(vi.size()==0){\n\t\t\tres[v]=P(1,1);\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vi.begin(),vi.end());\n\t\tint l=0,r=(int)vi.size()-1;\n\t\tfor(int i=0;i<(int)vi.size();i++){\n\t\t\ttmp[i]=false;\n\t\t}\n\t\twhile(l<r){\n\t\t\tif(vi[l]+vi[r]>len){\n\t\t\t\tr--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[l]=true;\n\t\t\ttmp[r]=true;\n\t\t\tsum--;\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t\tbool flag=false;\n\t\tint len_min=n+5;\n\t\tfor(int i=0;i<(int)vi.size();i++){\n\t\t\tif(!tmp[i]){\n\t\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}else if(len_min==len){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}\n\t\tres[v]=P(sum,len_min+1);\n\t\t//printf(\"%d %d %d\\n\",v,res[v].first,res[v].second);\n\t}\n\tif(res[prev].second==1){\n\t\tres[prev].first--;\n\t\tres[prev].second=len;\n\t}\n\treturn res[prev];\n}\n\n\nbool C(int num,int len){\n\tP rec=solve(len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring> \n#include<cstdio>\n#include<set>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nmultiset<int> s[MN+5];multiset<int>::iterator it;\nint n,f[MN+5],head[MN+5],cnt,ans,flag,mid,rt,d[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;++d[f];\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;++d[t];\n}\nvoid dfs(int x,int fa)\n{\n\ts[x].clear();f[x]=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa) dfs(e[i].to,x),s[x].insert(f[e[i].to]+1);\n\tint has=0,has2=0,size=s[x].size();\n\tif(!size) ++ans;ans-=(size-1)/2;\n\tif(s[x].size()&&(*(--(it=s[x].end())))>mid) return(void)(flag=0);\n\twhile(!s[x].empty())\n\t{\n\t\tit=s[x].end();--it;\n\t\tint v=*it;s[x].erase(it);\n\t\tit=s[x].upper_bound(mid-v);\n\t\tif(it==s[x].begin())\n\t\t{\n\t\t\tif(!has) has=v,f[x]=has;\n\t\t\telse if(~size&1)\n\t\t\t{\n\t\t\t\tif(!has2) has2=v,f[x]=has2;\n\t\t\t\telse return(void)(flag=0);\n\t\t\t}\n\t\t\telse return (void)(flag=0);\n\t\t}\n\t\telse s[x].erase(--it);\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tint l=1,r=n,res,Ans;\n\tfor(rt=1;~d[rt]&1;++rt);\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;ans=0;flag=1;\n\t\tdfs(rt,0);\n\t\t//cout<<\"Solve\"<<mid<<\" ok \"<<flag<<endl;\n\t\tif(flag) res=mid,r=mid-1,Ans=ans;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",Ans,res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\n\nii dp[111111];\nvi adj[111111];\nint MID;\nint tot;\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t\tcnt+=dp[v].fi;\n\t}\n\tsort(vec.begin(),vec.end());\n\t/*\n\tint maxpath = 0;\n\twhile(!vec.empty())\n\t{\n\t\tif(vec.size()==1)\n\t\t{\n\t\t\tif(vec[0]+1<=mid)\n\t\t\t{\n\t\t\t\tmaxpath = max(maxpath, vec[0]+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tmaxpath = max(maxpath, 1);\n\t\t\t}\n\t\t\tvec.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint las = vec.back();\n\t\t\tif(vec.front()+2+las<=mid)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_front(0);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint maxi = -int(1e9);\n\t\tfor(int i=0;i<mid;i++)\n\t\t{\n\t\t\tif(i<mid-1-i) maxi=max(maxi,vec[i]+vec[mid-1-i]+2);\n\t\t\tmaxi=max(maxi,vec[i]+1);\n\t\t}\n\t\tif(maxi<=MID)\n\t\t{\n\t\t\tans=mid;\n\t\t\tlo=mid+1;\n\t\t}\n\t\telse hi=mid-1;\n\t}\n\tint maxpath = 0;\n\tint del=0;\n\tfor(int i=ans;i<vec.size();i++) \n\t{\n\t\tif(vec[i]+1<=MID)\n\t\t{\n\t\t\tdel++;\n\t\t}\n\t\tvec[i]=0;\n\t}\n\tcnt+=int(vec.size()) - ans;\n\tfor(int j=0;j<del;j++) vec.pop_back();\n\tsort(vec.begin(),vec.end());\n\t//cerr<<vec.size()<<'\\n';\n\tcnt+=int(vec.size())/2;\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=0;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = -int(1e9);\n\t\t\twhile(l==mid) l++;\n\t\t\twhile(r==mid) r--;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=max(res,vec[l]+vec[r]+2);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tmaxpath = vec[ans]+1;\n\t\tif(maxpath>MID)\n\t\t{\n\t\t\tmaxpath=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t//cerr<<MID<<' '<<u+1<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttot+=(adj[i].size()&1);\n\t}\n\tMID=n;\n\tdfs(0,-1);\n\tint res=dp[0].fi;\n\tif(dp[0].se>0) res++;\n\tassert(res==tot/2);\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=dp[0].fi;\n\t\tif(dp[0].se>0) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A, newA;\nvector<int> G[N];\nint lim;\n\nint findA(int u, int p) {\n    int rem = 0;\n    for (int v : G[u]) if (v != p) {\n        rem += findA(v, u);\n    }\n    A += rem / 2; rem %= 2;\n    if (rem == 1) return rem;\n    return (u == 1) ? 0 : 1;\n}\n\nint dfs(int u, int p) {\n    multiset<int> s;\n    for (int v : G[u]) if (v != p) {\n        int cur = dfs(v, u) + 1;\n        s.insert(cur);\n    }\n\n    vector<int> rem;\n    while(s.size()) {\n        multiset<int>::iterator it = s.end(); --it;\n        int x = (*it);\n        s.erase(it);\n        it = s.upper_bound(lim - x);\n        if (it == s.begin()) {\n            rem.push_back(x);\n        } else --it, s.erase(it), ++newA;\n    }\n\n    reverse(rem.begin(), rem.end());\n    while(rem.size() && rem.back() == lim) ++newA, rem.pop_back();\n    if (rem.empty()) return 0;\n    else { newA += rem.size() - 1; return rem[0]; }\n}\n\nbool check() {\n    newA = 0;\n    newA += dfs(1, -1) != 0;\n    return newA <= A;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v); G[v].push_back(u);\n    }\n    A += findA(1, -1);\n\n    int l = 1, r = n;\n    while(l < r) {\n        lim = ((l + r) >> 1);\n        if (check()) r = lim; else l = lim + 1;\n    }\n    cout << A << ' ' << l << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\n\nint t, n, A = 1, newA;\nvector < int > adj[N];\n \n\nint dfs(int u, int pa, int lim) {\n    multiset < int > s;\n    multiset < int > :: iterator it;\n    for (int i = 0; i < adj[u].size() ; ++ i){\n\t\tint v = adj[u][i];\n\t\tif (v == pa) continue;\n        int cur = dfs(v, u, lim) + 1; s.insert(cur);\n    }\n    vector < int > data;\n    while(s.size()) {\n        it = s.end(); --it; int x = (*it);\n        s.erase(it);\n        it = s.upper_bound(lim - x);\n        if (it == s.begin()) data.pb(x);\n        else --it, s.erase(it), ++newA;\n    }\n    reverse(data.begin(), data.end());\n    while(data.size() && data.back() == lim) ++ newA, data.pop_back();\n    if (data.empty()) return 0;\n    else { newA += data.size() - 1; return data[0]; }\n}\nbool check(int lim){\n\tnewA = 0;\n    newA += dfs(1, 1, lim) != 0;\n    return newA <= A;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tFor(i, 1, n)  A += (adj[i].size() - 1) / 2;\n\tint l = 1, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << A << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\tint res=1,flag=sak[u].size()&1,vl;\n\twhile((int)sak[u].size()>1){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tif(!res){\n\t\t\t\tbo=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres--;\n\t\t\tsak[u].erase(itt);\n\t\t\tvl=v;\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif(!flag&&fa==-1&&!sak[u].empty()){\n\t\tbo=0;\n\t\treturn 0;\n\t}\n\tif(flag&&sak[u].empty()) return vl;\n\tif(sak[u].empty()) return 0;\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n\tfreopen(\"A.in\",\"r\",stdin);\n\tfreopen(\"A.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n \n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n \ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n \nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n \nconst int MX = 200005;\n \nvector<int> T[MX];\nint N, m, val = 1;\n \nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( X.empty() ) return 0;\n\tif( X.back() > m ) val = 0;\n \n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n      if( p == -1 ) val = 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tint op = X.size()/2 > i ? X.size()-i-1 : X.size()-i;\n\t\tif( X[i] + X[op] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n \nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <algorithm>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nconst int ms = 100100;\n\nstd::vector<int> edges[ms];\nstd::vector<std::pair<int, int>> dp[ms];\n\nvoid pre(int on, int par) {\n\tfor(int i = 0; i < (int) edges[on].size(); i++) {\n\t\tif(edges[on][i] == par) {\n\t\t\tstd::swap(edges[on][i], edges[on].back());\n\t\t\tedges[on].pop_back();\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tpre(edges[on][i], on);\n\t}\n\tdp[on].resize(edges[on].size());\n}\n\nint L;\nint solve(const std::vector<std::pair<int, int>> &a, int skip) {\n\tint ans = 0;\n\tfor(int l = 0, r = (int) a.size() - 1; l < r; l++) {\n\t\tif(l == skip) continue;\n\t\tif(r == skip) {\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tint s1 = L - a[l].first;\n\t\tint s2 = L - a[r].first;\n\t\tif(s1 + s2 <= L) {\n\t\t\tr--;\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nstd::pair<int, int> dfs(int on) {\n\t// returns (number of paths, rest of path going up)\n\tint sum = 0;\n\tfor(int i = 0; i < (int) edges[on].size(); i++) {\n\t\tdp[on][i] = dfs(edges[on][i]);\n\t\tif(dp[on][i].second == 0) {\n\t\t\tdp[on][i].first++;\n\t\t\tdp[on][i].second = L - 1;\n\t\t} else {\n\t\t\tdp[on][i].second--;\n\t\t}\n\t\tsum += dp[on][i].first;\n\t}\n\t// always when possible, pair shit up\n\tfor(auto &p : dp[on]) std::swap(p.first, p.second);\n\tstd::sort(dp[on].begin(), dp[on].end());\n\tint can = solve(dp[on], 1298739);\n\tif(2 * can == (int) dp[on].size()) {\n\t\treturn std::pair<int, int>(sum - can, 0);\n\t}\n\tint l = 0, r = (int) dp[on].size() - 1;\n\twhile(l != r) {\n\t\tint mid = (l + r + 1) / 2;\n\t\tif(solve(dp[on], mid) == can) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\tassert(solve(dp[on], l) == can);\n\treturn std::pair<int, int>(sum - can, dp[on][l].first);\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint n;\n\tstd::cin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tstd::cin >> u >> v;\n\t\tu--;v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpre(0, 0);\n\tint l = 1, r = n;\n\tL = n;\n\tint best = dfs(0).first;\n\twhile(l != r) {\n\t\tL = (l + r) / 2;\n\t\tif(dfs(0).first == best) {\n\t\t\tr = L;\n\t\t} else {\n\t\t\tl = L + 1;\n\t\t}\n\t}\n\tstd::cout << best << ' ' << l << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    if(len(vec) % 2){\n        sort(all(vec));\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] > cri) return false;\n        }\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nll N;\nvector<vll> G;\nll degree[100010];\n\nll dp[100010];\nbool dfs(ll v,ll p,const ll &x){\n  bool ret=true;\n  vll V;\n  for(ll u:G[v])if(p!=u){\n    ret &= dfs(u,v,x);\n    V.push_back(dp[u]+1);\n  }\n  if(!ret)return false;\n  sort(V.begin(),V.end());\n  if(V.size()&1){\n    ll low=-1,high=V.size();\n    while(high-low>1){\n      ll mid = (low+high)/2;\n      bool isok=V[mid]<=x;\n      ll l=0,r=V.size()-1;\n      for(ll i=0;i<V.size()/2;i++){\n        if(l==mid){\n          l++;\n        }\n        if(r==mid){\n          r--;\n        }\n        isok &= V[l]+V[r]<=x;\n        l++;\n        r--;\n      }\n      if(isok){\n        high = mid;\n      }else{\n        low = mid;\n      }\n    }\n    if(high==V.size()){\n      return false;\n    }\n    dp[v] = V[high];\n  }else{\n    bool isok=true;\n    ll l=0,r=V.size()-1;\n    for(ll i=0;i<V.size()/2;i++){\n      isok &= V[l]+V[r]<=x;\n      l++;\n      r--;\n    }\n    if(!isok){\n      //cerr<<\"!!\"<<endl;\n      ret &= V.back()<=x;\n      V.pop_back();\n      ll low=-1,high=V.size();\n      while(high-low>1){\n        ll mid = (low+high)/2;\n        isok=V[mid]<=x;\n        l=0,r=V.size()-1;\n        for(ll i=0;i<V.size()/2;i++){\n          if(l==mid){\n            l++;\n          }\n          if(r==mid){\n            r--;\n          }\n          isok &= V[l]+V[r]<=x;\n          l++;\n          r--;\n        }\n        if(isok){\n          high = mid;\n        }else{\n          low = mid;\n        }\n      }\n      if(high==V.size()){\n        return false;\n      }\n      dp[v] = V[high];\n    }\n  }\n  ret &= dp[v]<=x;\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll a,b;cin>>a>>b;a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    degree[a]++;\n    degree[b]++;\n  }\n  ll A=0;\n  for(ll i=0;i<N;i++){\n    A += degree[i]&1;\n  }\n  A /= 2;\n  ll low=-1,high=N;\n  while(high-low>1){\n    ll mid=(high+low)/2;\n    //debug(mid);\n    fill(dp,dp+N,0);\n    if(dfs(0,-1,mid)){\n      high = mid;\n    }else{\n      low = mid;\n    }\n    //debugArray(dp,N);\n  }\n  cout<<A<<\" \"<<high<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1 << 30;\nvector<int> G[100000];\nint dp[100000];\n\nbool check(vector<int>& vec, int m, int B) {\n\tvector<int> tmp;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (i != m) tmp.push_back(vec[i]);\n\t}\n\tint N = tmp.size();\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tif (tmp[i] + tmp[N - i - 1] > B) return 0;\n\t}\n\treturn 1;\n}\nint solve(int v, int p, int B) {\n\tif (dp[v] != -1) return dp[v];\n\tvector<int> child;\n\tfor (int u : G[v]) {\n\t\tif (u == p) continue;\n\t\tint ret = solve(u, v, B) + 1;\n\t\tif (ret > B) {\n\t\t\treturn dp[v] = 1 << 30;\n\t\t}\n\t\tchild.push_back(ret);\n\t}\n\tif (child.size() == 0) {\n\t\treturn dp[v] = 0;\n\t}\n\tsort(child.begin(), child.end());\n\tint N = child.size();\n\tif (N % 2 == 0) {\n\t\tbool ok = 1;\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tif (child[i] + child[N - i - 1] > B) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) return dp[v] = 0;\n\t\tchild.pop_back();\n\t\tN--;\n\t}\n\tint l = -1, r = N - 1;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(child, m, B)) r = m;\n\t\telse l = m;\n\t}\n\tif (check(child, r, B)) {\n\t\treturn dp[v] = child[r];\n\t}\n\treturn dp[v] = 1 << 30;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint root = 0;\n\tint odd = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() % 2) {\n\t\t\todd++;\n\t\t\troot = i;\n\t\t}\n\t}\n\tint l = -1, r = N;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tsolve(root, -1, m);\n\t\tif (dp[root] <= m) r = m;\n\t\telse l = m;\n\t}\n\tcout << odd / 2 << \" \" << r << endl;\n  \n  \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\n#include <iostream>\nusing namespace std;\n\nbool check(const vector<int> &tmp, int x) {\n        assert((int) tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        function<bool (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        if (!dfs(v, u)) return false;\n                        if (dp[v] + 1 > x) return false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return true;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                return false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        return false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        tmp = child;\n                        if (check(tmp, x)) {\n                                dp[u] = 0;\n                        } else {\n                                int lb = 0, ub = child.size();\n                                while (ub - lb > 0) {\n                                        tmp.clear();\n                                        int mid = (lb + ub) / 2;\n                                        for (int i = 0; i < child.size(); i ++) {\n                                                if (i != mid) {\n                                                        tmp.push_back(child[i]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                ub = mid;\n                                        } else {\n                                                lb = mid + 1;\n                                        }\n                                }\n                                if (ub == child.size()) {\n                                        return false;\n                                }\n                                dp[u] = child[ub];\n                        }\n                } else {\n                        vector<int> tmp;\n                        int lb = 0, ub = child.size();\n                        while (ub - lb > 0) {\n                                tmp.clear();\n                                int mid = (lb + ub) / 2;\n                                for (int i = 0; i < child.size(); i ++) {\n                                        if (i != mid) {\n                                                tmp.push_back(child[i]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        ub = mid;\n                                } else {\n                                        lb = mid + 1;\n                                }\n                        }\n                        if (ub == child.size()) {\n                                return false;\n                        }\n                        dp[u] = child[ub];\n                }\n                return true;\n        };\n        bool res = dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN = 100000+9;\nstruct E{\n\tint next,to;\n}edge[MAXN<<1];\nint head[MAXN],edge_num;\nint n;\nint degree[MAXN];\nint dp[MAXN];\nint A,B;\nint limit;\n\nvoid addedge(int x,int y){\n\tdegree[x]++;\n\tedge[++edge_num].next=head[x];\n\tedge[edge_num].to=y;\n\thead[x]=edge_num;\n}\n\nbool DP(int x,int fa){\n\tvector<int> vec;\n\tint cnt=0;\n\tif(degree[x]%2==1)\n\t\tvec.push_back(0);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tif(edge[i].to!=fa){\n\t\t\tif(!DP(edge[i].to,x))return false;\n\t\t\tif(dp[edge[i].to]!=-1)vec.push_back(dp[edge[i].to]+1);\n\t\t}\n\t}\n\n\tsort(vec.begin(),vec.end());\n\tif(vec.size()%2==1){\n\t\tint loc=-1;\n\t\tint l=0,r=vec.size()-1;\n\t\twhile(l<=r){\n\t\t\tint mid=l+r>>1;\n\t\t\tbool jud=1;\n\t\t\tint p1=0,p2=vec.size()-1;\n\t\t\twhile(p1<p2){\n\t\t\t\tif(p1==mid)p1++;\n\t\t\t\tif(p2==mid)p2--;\n\t\t\t\tif(vec[p1]+vec[p2]>limit){\n\t\t\t\t\tjud=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp1++;p2--;\n\t\t\t}\n\t\t\tif(jud){\n\t\t\t\tloc=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\tif(loc==-1){\n\t\t\treturn false;\n\t\t}\n\t\tdp[x]=vec[loc];\n\t\treturn true;\n\t}\n\telse{\n\t\tfor(int i=0,j=vec.size()-1;i<j;i++,j--){\n\t\t\tif(vec[i]+vec[j]>limit){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//dp[x]=-1;\n\t\treturn true;\n\t}\n}\n\nbool check(int len){\n\tlimit=len;\n\tmemset(dp,0,sizeof(dp));\n\treturn DP(1,0);\n}\n\nvoid solve(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid)){\n\t\t\tr=mid-1;\n\t\t\tB=mid;\n\t\t}\n\t\telse\n\t\t\tl=mid+1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a,b);\n\t\taddedge(b,a);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(degree[i]%2==1)\n\t\t\tA++;\n\t}\n\tA/=2;\n\tsolve();\n\tprintf(\"%d %d\\n\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005,INF=1<<30;\n\nint A[MAX],C[MAX],cnt[MAX];\nbool alive[MAX];\nvector<int> G[MAX];\n\nvoid DFS(int u,int p){\n    for(int to:G[u]){\n        if(to==p) continue;\n        DFS(to,u);\n        cnt[u]++;\n        A[u]+=A[to]+alive[to];\n    }\n    A[u]-=cnt[u]/2;\n    if(cnt[u]%2==0) alive[u]=1;\n}\n\nint lim;\nbool ok;\n\nvoid solve(int u,int p){\n    if(cnt[u]==0) return;\n    \n    vector<int> X;\n    if(cnt[u]%2==0) X.push_back(0);\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        solve(to,u);\n        X.push_back(C[to]+1);\n    }\n    sort(all(X));\n    \n    int M=si(X);\n    \n    if(M==1){\n        C[u]=X[0];\n        if(C[u]>lim) ok=false;\n        \n        return;\n    }\n    \n    int left=-1,right=M;\n    while(right-left>1){\n        int mid=(left+right)/2;\n        int l=0,r=M-1;\n        int ma=-1;\n        while(l<r){\n            if(l==mid) l++;\n            if(r==mid) r--;\n            \n            chmax(ma,X[l]+X[r]);\n            l++;\n            r--;\n        }\n        if(ma<=lim) right=mid;\n        else left=mid;\n    }\n    if(right==M) ok=false;\n    else{\n        C[u]=X[right];\n        if(C[u]>lim) ok=false;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    DFS(0,-1);\n    \n    int left=0,right=N;\n    \n    while(right-left>1){\n        ok=true;\n        lim=(left+right)/2;\n        for(int i=0;i<N;i++) C[i]=0;\n        solve(0,-1);\n        \n        if(ok) right=lim;\n        else left=lim;\n    }\n    \n    cout<<A[0]<<\" \"<<right<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ran 100010\nint n,res,W;\nvector<int> e[ran];\nint sz[ran];\nvoid dfs1(int x,int fat){\n\tint cnt = 0;\n\tsz[x] = 0;\n\tfor(vector<int>::iterator it = e[x].begin(); it != e[x].end(); it++){\n\t\tint y = *it;\n\t\tif(y == fat)continue;\n\t\tdfs1(y, x);\n\t\tcnt ++;\n\t\tsz[x] += sz[y];\n\t}\n\tsz[x] += cnt / 2;\n\tif(x == fat)sz[x] += cnt % 2;\n}\nbool dfs(int x,int fat){\n\tvector<int> e;\n\tfor(vector<int>::iterator it = ::e[x].begin(); it != ::e[x].end(); it++){\n\t\tint y = *it;\n\t\tif(y == fat)continue;\n\t\tif(!dfs(y, x))return false;\n\t\te.push_back(sz[y] + 1);\n\t}\n\tif(x == fat){\n\t\tif(e.size() % 2)e.push_back(0);\n\t\tsort(e.begin(), e.end());\n\t\tint L = e.size();\n\t\tfor(int i=0,j=L-1; i<j; i++,j--)\n\t\t\tif(e[i] + e[j] > W)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif(e.size() % 2 == 0)e.push_back(0);\n\tsort(e.begin(), e.end());\n\tint L = e.size();\n\tint lo = 0, hi = L;\n\twhile(lo != hi){\n\t\tint mi = (lo + hi)/2;\n\t\tbool flag = true;\n\t\tfor(int i=0,j=L-1;;){\n\t\t\tif(i==mi)i++;\n\t\t\tif(j==mi)j--;\n\t\t\tif(i>j)break;\n\t\t\tif(e[i] + e[j] > W){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;j--;\n\t\t}\n\t\tif(flag)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t}\n\tif(hi == L)return false;\n\tsz[x] = e[lo];\n\treturn true;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs1(1,1);\n\tprintf(\"%d \",sz[1]);\n\tint lo = 1, hi = n-1;\n\twhile(lo != hi){\n\t\tW = (lo + hi)/2;\n\t\tif(dfs(1, 1))\n\t\t\thi = W;\n\t\telse\n\t\t\tlo = W+1;\n\t}\n\tprintf(\"%d\\n\",lo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    f[x] = g[ans] + 1;\n    return 1;\n}\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(1, 0)) return 0;\n    return f[1] <= m + 1;\n}\nint main() {\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    std::cout << (m >>= 1) << std::ends;\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int nmax = 100010;\nint deg[nmax],dp[nmax];\nbool fix[nmax];\nvector < int > graph[nmax];\nint N,u;\nbool check2(int x,int B, vector<int>& kids)\n{\n\tint l = 0, r = kids.size() - 1;\n\tif((kids[x]+1) > B) return false;\n\twhile( l < r)\n\t{\n\t\tif(l == x) l++;\n\t\tif(r == x) r--;\n\t\tif(l >= r  || r < 0) return true;\n\t\tif((kids[l] + kids[r] )> B) return false;\n\t\tl++,r--;\n\t}\n\treturn true;\n}\nbool dfs(int u, int x)\n{\n\tfix[u] = true;\n\tbool ret = true;\n\t//cout << \"in vertex \" << u << \" trying \" << x << endl;\n\tvector< int > kids;\n\tfor(int i = 0; i < graph[u].size(); ++i)\n\t{\n\t\tif(fix[graph[u][i]]) continue;\n\t\tret&=dfs(graph[u][i],x);\n\t\tkids.push_back(dp[graph[u][i]]);\n\t}\n\tif(!ret) return ret;\n\tif((kids.size()&1)==0) kids.push_back(0);\n\tsort(kids.begin(), kids.end());\n\tint l = 0, r = kids.size() - 1;\n\t\n\t//cout << \"out to \" << u;\n\t//cout << \"\\n\\t\";\n\t//for(int i = 0 ; i < kids.size(); ++i)\n\t//\tcout << kids[i] << ' ';\n\t//cout << endl;\n\tbool isGood = check2(r, x, kids);\n\twhile((r - l) > 1)\n\t{\n\t\tint mid = (r+l) >> 1;\n\t\tif(check2(mid, x, kids))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\n\t}\n\tif(check2(l, x, kids)) r = l;\n\tif(!isGood) return false;\n\tdp[u] = kids[r]+1;\n\treturn true;\n}\nbool check(int x)\n{\n\tfor(int i = 1;i<=N;++i)dp[i]=N,fix[i]=false;\n\treturn dfs(u,x);\n}\nint bs()\n{\n\tint l = 1, r = N-1;\n\twhile((r-l) > 1)\n\t{\n\t\tint mid = (l+r) >> 1;\n\t\tif(check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n\tif(check(l))\n\t\treturn l;\n\treturn r;\n\n}\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0 ;i < N-1;++i)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tint A=0,B=0;\n\tfor(int i = 1;i<=N;++i)\n\t{\n\t\tif(deg[i]&1) A++;\n\t\tif(deg[i] == 1) u = i;\n\t}\n\tA = (A+1)/2;\n\tcout << A << ' ' << bs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tif(it!=d.begin() && *d.begin()+*it>x) --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0, resb = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tresb += g[i].size()%2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tresa++; resb /= 2;\n\tif(resa!=resb) return -1;\n\tint lb = -1, ub = n;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resb<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nint a_dfs(const Graph& g, const int s)\n{\n    const int C = g.edge[s].size();\n    int sum = (s == 0 ? (C + 1) / 2 : C / 2);\n    for (const int to : g.edge[s]) {\n        sum += a_dfs(g, to);\n    }\n    return sum;\n}\n\nint K;\nbool check(const vector<int>& a, const int ng, const int size)\n{\n    int tail = size - 1;\n    for (int i = 0; i < size; i++) {\n        if (tail == ng) {\n            tail--;\n        }\n        if (tail <= i) {\n            break;\n        }\n        const int sum = a[i] + a[tail];\n        if (sum + 1 > K) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool b_bfs(const Graph& g, const int s, vector<int>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> l;\n    for (const int to : g.edge[s]) {\n        const bool f = b_bfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        l.push_back(dp[to]);\n    }\n    sort(l.begin(), l.end());\n    if (C % 2 == 1) {\n        int inf = 0;\n        int sup = C;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            if (check(l, mid, C)) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == C or l[sup] + 1 > K) {\n            return false;\n        } else {\n            dp[s] = l[sup] + 1;\n            return true;\n        }\n    } else {\n        if (check(l, C, C)) {\n            dp[s] = 1;\n            return true;\n        } else if (l.back() + 1 > K) {\n            return false;\n        } else {\n            int inf = 0;\n            int sup = C - 1;\n            while (inf < sup) {\n                const int mid = (inf + sup) / 2;\n                if (check(l, mid, C - 1)) {\n                    sup = mid;\n                } else {\n                    if (inf == mid) {\n                        break;\n                    }\n                    inf = mid;\n                }\n            }\n            if (sup == C - 1 or l[sup] + 1 > K) {\n                return false;\n            } else {\n                dp[s] = l[sup] + 1;\n                return true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n    const int A = a_dfs(g, 0);\n\n    vector<int> dp(N, 0);\n    int inf = 0;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        const bool ok = b_bfs(g, 0, dp);\n        if (ok) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    b_bfs(g, 0, dp);\n    const int B = sup - 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nint dfs(Graph<int> &g, int v, int p, const int &mid) {\n  multiset<int, greater<int>> s;\n\n  for (int &nv : g[v]) {\n    if (nv != p) {\n      int val = dfs(g, nv, v, mid);\n\n      if (val == -1 || val == mid) return -1;\n\n      s.insert(val + 1);\n    }\n  }\n\n  bool odd = g[v].size() & 1;\n  int ret = 0;\n\n  while (s.size() > 1) {\n    int w = *begin(s); s.erase(s.begin());\n    auto itr = s.lower_bound(mid - w);\n\n    if (itr == s.end()) {\n      if (!odd) {\n        if (ret != 0) return -1;\n        ret = w;\n      }\n      else odd = false;\n      continue;\n    }\n\n    s.erase(itr);\n  }\n\n  if (s.empty()) return ret;\n\n  if (ret != 0) return -1;\n\n  return *begin(s);\n}\n\nvoid solve() {\n  int n; cin >> n;\n  Graph<int> g(n);\n  rep1(i,n) {\n    int a, b; cin >> a >> b; --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  int odd = 1;\n  rep(i,n) {\n    if (g[i].size() & 1) ++odd;\n  }\n\n  const int cnt = odd / 2;\n\n  int l = 0, r = n;\n\n  while (r - l > 1) {\n    int mid = (l + r) / 2;\n    if (dfs(g, 0, -1, mid) == -1) l = mid;\n    else r = mid;\n  }\n\n  cout << pii(cnt, r) << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nll f[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        st.insert(sum[v]+1);\n    }\n    while(st.size())\n    {\n        int x=*st.rbegin();\n        st.erase(st.find(x));\n        if(st.size()==0)\n        {\n            if(x+1<=m) sum[u]=x;\n            else f[u]++;\n            break;\n        }\n        it=st.upper_bound(m-x);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;st.erase(st.find(*it));\n        }\n    }\n    if(u==1&&sum[u]) f[u]++;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=1,r=n,ans;\n    dfs(1,0,0);\n    assert(f[1]==n-1);\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        dfs(1,0,m);\n        if(f[1]<=dp[1]) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint to[N << 1],nex[N << 1],beg[N],deg[N],Ans[N],rest[N],A[N];\nint e,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline void dfs(int x,int fa) {\n\tint cur = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tdfs(to[i],x),cur++;\n\t}\n\tans -= cur / 2,cur &= 1;\n\tif(!cur && x > 1) ans++;\n}\n\ninline int check(int Ban,int top,int val) {\n\tint pos = top,tot = 0;\n\tFor(i,1,top) {\n\t\tif(i == Ban) continue;\n\t\twhile(pos && (A[i] + A[pos] > val || pos == Ban)) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\treturn tot;\n}\n\ninline void Dp(int x,int fa,int val) {\n\tint total = 0,top = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tDp(to[i],x,val);\n\t}\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\ttotal += Ans[to[i]];\n\t\tA[++top] = rest[to[i]];\n\t}\n\tsort(A + 1,A + top + 1);\n\twhile(top && A[top] >= val) top--;\n\tint pos = top,tot = 0;\n//\tdebug(top);\n\tFor(i,1,top) {\n\t\twhile(A[i] + A[pos] > val) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\tint l = 0,r = top;\n\twhile(l < r) {\n\t\tint mid = (l + r + 1) >> 1;\n//\t\tdebug(mid);\n\t\tif(check(mid,top,val) < tot) r = mid - 1;\n\t\telse l = mid;\n\t}\n//\tdebug(l);\n\trest[x] = A[l] + 1;Ans[x] = total - tot;\n\tif(!l && x > 1) Ans[x]++;\n//\tcout << x << \" \" << Ans[x] << \" \" << total << \" \" << tot << \" \" << rest[x] << endl;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n - 1) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tint l = 0,r = n;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n//\t\tdebug(mid);\n\t\tDp(1,0,mid);\n//\t\tdebug(Ans[1]);\n//\t\tcout << \"------\" << endl;\n\t\tif(Ans[1] > ans) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\tprintf(\"%d %d\\n\",ans,l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<ll,int> pr;\n\nconst int inf = 2e8;\nconst int maxn = 100020;\nconst ll mod = 1e9 + 7;\nstruct node{\n\tint next,to,w;\n}e[maxn * 2];\n\nint head[maxn],cnt,rt,sz[maxn],n,deg[maxn];\nint len,flag;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\n\nvoid dfs(int x,int fa){\n\tfore(i,x){\n\t\tif ( e[i].to == fa ) continue;\n\t\tdfs(e[i].to,x);\n\t\tdeg[x]++;\t\n\t}\n}\nstruct cmp{\n\tbool operator () (int x,int y){ return x > y; }\n};\nmultiset <int,cmp> vec[maxn];\nint dfs2(int x,int fa){\n\tfore(i,x){\n\t\tif ( e[i].to == fa ) continue;\n\t\tvec[x].insert(dfs2(e[i].to,x));\n\t\tif ( !flag ) return 0;\n\t}\n//\tsort(vec[x].begin(),vec[x].end());\n\tif ( !vec[x].size() ) return 1;\n\tif ( x == 1 ){\n\t\tif ( vec[x].size() & 1 ) flag &= *vec[x].begin() <= len;\n\t\tvec[x].erase(vec[x].begin());\n\t\tif ( vec[x].size() ){\n\t\t\tauto it = vec[x].end();\n\t\t\tfor (auto it2 = vec[x].begin() ; it2 != vec[x].end() ; ++it2){\n\t\t\t\t--it;\n\t\t\t\tflag &= ((*it) + (*it2)) <= len;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint l = 0;\n\tif ( !(vec[x].size() & 1) ){\n\t\tif ( *vec[x].begin() > len ){ flag = 0; return 0; }\n\t\tvec[x].erase(vec[x].begin());\n\t}\n\n\t\tint cnt = 0;\n\t\tfor (auto it = vec[x].begin() ; it != vec[x].end() ; ++it){\n\t\t\tif ( *it > len ){ flag =0 ; return 0; }\n\t\t\tif ( (*it) * 2 <= len ) break;\n\t\t\tauto it2 = vec[x].lower_bound(len - *it);\n\t\t\tif ( it2 == vec[x].end() ){\n\t\t\t\tif ( !l ) l = (*it) + 1;\n\t\t\t\telse{ flag = 0; return 0; }\n\t\t\t}\n\t\t\telse vec[x].erase(it2);\n\t//\t\tvec[x].erase(it);\n\t\t\t++cnt;\n\t\t\tif ( cnt >= vec[x].size() ) break;\n\t\t}\n\t\tauto it = vec[x].end();\n\t\tif ( !l ) l = (*(--it)) + 1;\n\t\n\treturn l;\n}\nint check(int mid){\n\trep(i,1,n) vec[i].clear();\n\tflag = 1;\n\tlen = mid;\n\tdfs2(1,0);\n\treturn flag;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n - 1){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y) , adde(y,x);\n\t}\n\tdfs(1,0);\n\tint A = 0,B = 0;\n\trep(i,1,n){\n\t\tif ( i == 1 ) A += (deg[i] + 1) / 2;\n\t\telse A += deg[i] / 2;\n\t}\n\tint l = 1 , r = n;\n\twhile ( l <= r ){\n\t\tint mid = (l + r) >> 1;\n\t\tif ( check(mid) ) B = mid , r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout<<A<<\" \"<<B<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n\telse{\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=0,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (f[1]>O+1) ok=0;\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tint ans=dfs(1,-1);\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[100111];\nint l[100101];\nint j[1];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[1];\n\nP u[1];\nqueue<int> q;\nstack<int> s;\n\nvector<int> v[100101];\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\nvoid f(int n,int m)\n{\n  vector<int> s;\n  for(int h=0;h<v[n].size();h++)\n  if(v[n][h]!=m)\n  {\n    f(v[n][h],n);\n    s.push_back(l[v[n][h]]+1);\n  }\n  sort(s.begin(),s.end());\n  if(s.size()%2)\n  {\n    int a=0,b=s.size()-1;\n    for(;a<b;)\n    {\n      int h=(a+b)/2;\n      int c=0,d=s.size()-1;\n      int x=0;\n      for(;c<d;)\n      {\n        if(c==a) c++;\n        else if(d==a) d--;\n        else\n        {\n          x=max(x,s[c]+s[d]);\n          c++,d--;\n        }\n      }\n      if(x<=k) b=h;\n      else a=h+1;\n    }\n    l[n]=o[n]=s[a];\n    int c=0,d=s.size()-1;\n    \n    for(;c<d;)\n    {\n      if(c==a) c++;\n      else if(d==a) d--;\n      else\n      {\n        o[n]=max(o[n],s[c]+s[d]);\n        c++,d--;\n      }\n    }\n  }\n  else if(s.size())\n  {\n    l[n]=o[n]=0;\n    int c=0,d=s.size()-1;\n    for(;c<d;c++,d--)\n      o[n]=max(o[n],s[c]+s[d]);\n    if(o[n]<=k||m==0) return;\n    o[n]=s.back();\n    \n    \n    int a=0,b=s.size()-2;\n    for(;a<b;)\n    {\n      int h=(a+b)/2;\n      int c=0,d=s.size()-2;\n      int x=0;\n      for(;c<d;)\n      {\n        if(c==a) c++;\n        else if(d==a) d--;\n        else\n        {\n          x=max(x,s[c]+s[d]);\n          c++,d--;\n        }\n      }\n      if(x<=k) b=h;\n      else a=h+1;\n    }\n    l[n]=s[a];\n    c=0,d=s.size()-2;\n    \n    for(;c<d;)\n    {\n      if(c==a) c++;\n      else if(d==a) d--;\n      else\n      {\n        o[n]=max(o[n],s[c]+s[d]);\n        c++,d--;\n      }\n    }\n  }\n  else l[n]=o[n]=0;\n}\n\nint main()\n{\n  scanf(\"%d\",&a);\n  for(int t=1;t<a;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    v[n].push_back(m);\n    v[m].push_back(n);\n  }\n  for(int t=1;t<=a;t++)\n    e+=v[t].size()%2;\n  printf(\"%d \",e/2);\n  n=1,m=a-1;\n  for(;n<m;)\n  {\n    k=(n+m)/2;\n    f(1,0);\n    //for(int t=1;t<=a;t++)\n    //  printf(\"%d \",o[t]);\n    //puts(\"\");\n    for(int t=1;t<=a;t++)\n      if(o[t]>k)\n      {\n        n=k+1;\n        goto qwe;\n      }\n    m=k;\n    qwe:;\n  }\n  printf(\"%d\",n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[110000];\nint n;\n\nint dfs(int v, int p, int k) {\n    vector<int> children;\n\n    for (int x : g[v]) if (x != p) {\n        children.push_back( dfs(x, v, k) );\n        if (children.back() == -1) return -1;\n    }\n\n    sort(children.begin(), children.end(), [](int a, int b){ return a < b; });\n\n    bool tend = (g[v].size() % 2 == 1);\n\n    int left = 0;\n    for (int i = 0; i < children.size(); i++) {\n        if (i+1 == children.size()) {\n            if (left != 0) return -1;\n            left = children[i];\n            break;\n        }\n\n        if (children[i] + children.back() <= k) {\n            children.pop_back();\n        }\n        else if (left == 0) {\n            if (tend) tend = false;\n            else left = children.back();\n            children.pop_back();\n            i--;\n        }\n        else return -1;\n    }\n\n    int ret = (p == -1 ? left : left + 1);\n\n    // cout << v+1 << \" \" << p+1 << \" \" << ret << endl;\n    if (ret > k) return -1;\n    return ret;\n}\n\nint check(int k) {\n    return dfs(0,-1,k) != -1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int u,v; cin >> u >> v; u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int ends = 0;\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() % 2 == 1) ends++;\n    }\n\n    int st = 1, ed = n-1;\n    // int st = 2, ed = 3;\n    while (st < ed) {\n        int md = (st+ed)/2;\n        if (check(md)) ed = md;\n        else st = md+1;\n    }\n\n    cout << ends/2 << \" \" << st << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> edges[100000];\n\nbool check2(const vector<int>& v, int omit, int K){\n    int sz = v.size();\n    int i = 0, j = sz-1;\n    while(true){\n        if(i == omit) i++;\n        if(j == omit) j--;\n        if(i >= j) return true;\n        if(v[i] + v[j] > K) return false;\n        i++; j--;\n    }\n}\n\nint find_opt(const vector<int>& v, int K){\n    int sz = v.size();\n    int ng = -1, ok = sz;\n    while(ok-ng>1){\n        int mid = (ng+ok)/2;\n        (check2(v, mid, K) ? ok : ng) = mid;\n    }\n    return (ok == sz ? -1 : v[ok]);\n}\n\nint dfs(int i, int par, int K){\n    vector<int> v;\n    for(auto j : edges[i]){\n        if(j == par) continue;\n        int ret = dfs(j, i, K);\n        if(ret == -1 || ret+1 > K) return -1;\n        v.push_back(ret+1);\n    }\n    if(v.size() % 2 == 0) v.push_back(0);\n    sort(v.begin(), v.end());\n\n    return find_opt(v, K);\n}\n\nbool check(int K){\n    int result = dfs(0, -1, K);\n    if(edges[0].size() % 2 == 1){\n        return (result != -1);\n    }else{\n        return (result == 0);\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    int A = 0;\n    for(int i=0; i<N; i++){\n        if(edges[i].size() % 2 == 1) A++;\n    }\n    A /= 2;\n\n    int ng = 0, ok = N;\n    while(ok-ng>1){\n        int mid = (ok+ng)/2;\n        (check(mid) ? ok : ng) = mid;\n    }\n    int B = ok;\n\n    cout << A << \" \" << B << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint ret=1,isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tsort(v.begin(),v.end());\n\tint l=0,r=SZ(v)-1;\n\tfor(;l<r;)\n\t\tif(v[l]+v[r]+1<=B) l++,r--,res++; else r--,res++;\n\tif(l==r){\n\t\tif(v[l]+1>=B){res++;return 1;}\n\t\treturn v[l]+1;\n\t}\n\treturn 1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;dfs(1);\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A+1,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nint n = 0;\nvector<int> edges[101010];\nbool visited[101010];\n\nint dfs(int v, int b, bool r = false) {\n    if (!r) {\n        fill(visited, visited + 101010, false);\n    }\n\n    visited[v] = true;\n    vector<int> lengths;\n\n    for (auto c : edges[v]) {\n        if (!visited[c]) {\n            int k = dfs(c, b, true);\n            if (k < 0 || b < k) return -1;\n            lengths.push_back(k);\n        }\n    }\n\n    bool odd = (lengths.size() % 2 == 1);\n    int hold = -1;\n    sort(lengths.begin(), lengths.end());\n    while (1 < lengths.size()) {\n        int k = lengths.back();\n        lengths.pop_back();\n        auto i = upper_bound(lengths.begin(), lengths.end(), b - k);\n        if (i == lengths.begin()) {\n            if ((odd || r) && hold < 0) {\n                hold = k;\n            } else {\n                return -1;\n            }\n        } else {\n            lengths.erase(i - 1);\n        }\n    }\n\n    if (r && !odd && 0 < hold) {\n        lengths.push_back(hold);\n    }\n\n    if (lengths.size() == 0) {\n        return 1;\n    } else {\n        return lengths[0] + 1;\n    }\n}\n\n\ntuple<int, int> solve() {\n    int root = -1;\n    int a = 1;\n\n    rep(i, 0, n) {\n        size_t c = edges[i].size();\n        if (3 <= c) {\n            a += (c - 1) / 2;\n            root = i;\n        }\n    }\n\n    if (root < 0) {\n        return make_tuple(1, n - 1);\n    }\n\n    int ok = n - 1;\n    int ng = 1;\n\n    while (ng + 1 < ok) {\n        int mid = (ok + ng) / 2;\n        if (0 <= dfs(root, mid)) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n\n    return make_tuple(a, ok);\n}\n\nint main(int argc, const char * argv[]) {\n    int a, b;\n    \n    cin >> n;\n    rep(i, 0, n - 1) {\n        cin >> a >> b;\n        --a;\n        --b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    auto p = solve();\n\n    cout << get<0>(p) << ' ' << get<1>(p) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nint n = 0;\nvector<int> edges[101010];\nbool visited[101010];\n\nint dfs(int v, int b, bool r = false) {\n    if (!r) {\n        fill(visited, visited + 101010, false);\n    }\n\n    visited[v] = true;\n    vector<int> lengths;\n\n    for (auto c : edges[v]) {\n        if (!visited[c]) {\n            int k = dfs(c, b, true);\n            if (!k || b < k) return 0;\n            lengths.push_back(k);\n        }\n    }\n\n    if (edges[v].size() & 1) {\n        lengths.push_back(0);\n    }\n\n    int hold = 0;\n    sort(lengths.begin(), lengths.end());\n    while (1 < lengths.size()) {\n        int k = lengths.back();\n        lengths.pop_back();\n        auto i = upper_bound(lengths.begin(), lengths.end(), b - k);\n        if (i == lengths.begin()) {\n            if (r && !hold) {\n                hold = k;\n            } else {\n                return 0;\n            }\n        } else {\n            lengths.erase(i - 1);\n        }\n    }\n\n    if (hold) {\n        lengths.push_back(hold);\n    }\n\n    if (lengths.size()) {\n        return lengths[0] + 1;\n    } else {\n        return 1;\n    }\n}\n\n\ntuple<int, int> solve() {\n    int root = -1;\n    int a = 1;\n\n    rep(i, 0, n) {\n        size_t c = edges[i].size();\n        if (3 <= c) {\n            a += (c - 1) / 2;\n            root = i;\n        }\n    }\n\n    if (root < 0) {\n        return make_tuple(1, n - 1);\n    }\n\n    int ok = n - 1;\n    int ng = 1;\n\n    while (ng + 1 < ok) {\n        int mid = (ok + ng) / 2;\n        if (dfs(root, mid)) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n\n    return make_tuple(a, ok);\n}\n\nint main(int argc, const char * argv[]) {\n    int a, b;\n    \n    cin >> n;\n    rep(i, 0, n - 1) {\n        cin >> a >> b;\n        --a;\n        --b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    auto p = solve();\n\n    cout << get<0>(p) << ' ' << get<1>(p) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nint dp[100005], seq[100005], deg[100005], lst[100005], to[200005], pre[200005], tot; \ninline void add_edge(int u, int v)\n{\n\tto[tot] = v; \n\tpre[tot] = lst[u];\n\tdeg[v]++; \n\tlst[u] = tot++;\n}\nbool dfs(int u, int lim, int fa = -1)\n{\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (to[i] != fa && !dfs(to[i], lim, u))\n\t\t\treturn false; \n\t}\n\tint len = 0; \n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (to[i] != fa)\n\t\t\tseq[len++] = dp[to[i]] + 1; \n\t}\n\tif (len & 1 ^ (fa != -1))\n\t\tseq[len++] = 0; \n\tstd::sort(seq, seq + len); \n\tif (~fa)\n\t{\n\t\tint l = 0, r = len - 2; \n\t\twhile (l < r)\n\t\t{\n\t\t\tif (seq[l++] + seq[r--] > lim)\n\t\t\t\treturn false; \n\t\t}\n\t\tint idx = len - 1; \n\t\twhile (idx && seq[idx] + seq[len - 1 - idx + (idx << 1 < len)] <= lim)\n\t\t\tidx--; \n\t\tdp[u] = seq[idx]; \n\t}\n\telse\n\t{\n\t\tint l = 0, r = len - 1; \n\t\twhile (l < r)\n\t\t{\n\t\t\tif (seq[l++] + seq[r--] > lim)\n\t\t\t\treturn false; \n\t\t}\n\t}\n\treturn true; \n}\nint main()\n{\n\t// freopen(\"ARC088-F.in\", \"r\", stdin); \n\tmemset(lst, -1, sizeof(lst)); \n\tint n; \n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; \n\t\tscanf(\"%d%d\", &u, &v); \n\t\tadd_edge(--u, --v);\n\t\tadd_edge(v, u); \n\t}\n\tint a = 0, l = 0, r = n - 1, ans; \n\tfor (int i = 0; i < n; i++)\n\t\ta += deg[i] & 1; \n\twhile (l <= r)\n\t{\n\t\tint m = l + r >> 1; \n\t\tif (dfs(0, m))\n\t\t{\n\t\t\tans = m; \n\t\t\tr = m - 1; \n\t\t}\n\t\telse\n\t\t\tl = m + 1;\n\t}\n\tprintf(\"%d %d\\n\", a + 1 >> 1, ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[100001];\nvector<int> v[100001];\nint val,dp[100001];\nbool bad;\nint dfss(int x,int p){\n\tint res=0;\n\tfor(int i:edge[x]){\n\t\tif(i==p)\tcontinue;\n\t\tres+=dfss(i,x);\n\t}\n\treturn (edge[x].size()-1)/2+res;\n}\n\nint dfs(int x,int p){\n\tv[x].clear();\n\tfor(int i:edge[x]){\n\t\tif(i==p)\tcontinue;\n\t\tv[x].push_back(dfs(i,x)+1);\n\t}\n\tsort(v[x].begin(),v[x].end());\n\tdp[x]=0;\n\tif(v[x].size()&1){\n\t\tint L=0,R=v[x].size();\n\t\twhile(L<R){\n\t\t\tint M=(L+R)/2,st=0,en=v[x].size()-1;\n\t\t\tdp[x]=0;\n\t\t\twhile(st<en){\n\t\t\t\tif(st==M){\n\t\t\t\t\tst++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(en==M){\n\t\t\t\t\ten--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[x]=max(dp[x],v[x][st++]+v[x][en--]);\n\t\t\t}\n\t\t\tif(dp[x]>val)\n\t\t\t\tL=M+1;\n\t\t\telse\n\t\t\t\tR=M;\n\t\t}\n\t\tif(R==v[x].size()){\n\t\t\tbad=true;\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tif(v[x][L]>val)\n\t\t\t\tbad=true;\n\t\t\treturn v[x][L];\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\tdp[x]=max(dp[x],v[x][i]+v[x][v[x].size()-i-1]);\n\t\tif(dp[x]>val){\n\t\t\tif(v[x].back()>val){\n\t\t\t\tbad=true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint L=0,R=v[x].size()-1;\n\t\t\twhile(L<R){\n\t\t\t\tint M=(L+R)/2,st=0,en=v[x].size()-1;\n\t\t\t\tdp[x]=0;\n\t\t\t\twhile(st<en){\n\t\t\t\t\tif(st==M){\n\t\t\t\t\t\tst++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n\t\t\t\t\tif(en==M){\n\t\t\t\t\t\ten--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[x]=max(dp[x],v[x][st++]+v[x][en--]);\n\t\t\t\t}\n\t\t\tif(dp[x]>val)\n\t\t\t\tL=M+1;\n\t\t\telse\n\t\t\t\tR=M;\n\t\t\t}\n\t\t\tif(R==v[x].size()-1){\n\t\t\t\tbad=true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(v[x][L]>val)\n\t\t\t\t\tbad=true;\n\t\t\t\treturn v[x][L];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\nbool check(int x){\n\tbad=false;\n\tval=x;\n\tdfs(1,0);\n\tif(bad)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0,u,v;i<n-1;i++){\n\t\tcin>>u>>v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tint l=1,r=100000;\n\twhile(l<r){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<dfss(1,0)+1<<' '<<l<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tll child = 0;\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\ttable.pb(solve(G[node][i],node,length));\n\t\tchild ++;\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn 0;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\tnum = i;\n\t\t\ta++;\n\t\t}\n\t}\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,0,mid);\n\t\tassert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nvoid getEdge(int src){\n    edges.clear();\n    int u = src;\n    int v = par[0][src];\n    int cent;\n    if(sz(adj[u])%2 == 1 && sz(adj[v])%2 == 1) return;\n    if(sz(adj[u])%2 == 0) {\n        dfs_vert(u);\n        cent = u;\n    }\n    else {\n        dfs_vert(v);\n        cent = v;\n    }\n    set<int> s;\n    for(auto ee: edges){\n        pi e = mp(ee, par[0][ee]);\n        if(sz(adj[e.f])%2 == 1) s.insert(dist(cent, e.f));\n        if(sz(adj[e.s])%2 == 1) s.insert(dist(cent, e.s));\n    }\n    vi tmp; for(int x: s) tmp.eb(x);\n    f0r(i, sz(tmp)) ckmax(ans, tmp[i]+tmp[sz(tmp)-1-i]);\n}\nint main(){\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    vi pts;\n    f0r(i, n) if(sz(adj[i])%2 == 1) pts.eb(i);\n    f1r(i, 1, n){\n        if(vis[i]) continue;\n        getEdge(i);\n    }\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[100001];\nvector<int> tree[100001];\nvector<int> l[100001];\nint p[100001];\nint bye[100001];\n\nint ans1 = 0;\nint lim = 0;\n\nvoid dfs1(int x){\n    int cntt = 0;\n    for(auto &nxt: g[x]){\n        if(nxt == p[x]) continue;\n        tree[x].push_back(nxt);\n        p[nxt] = x;\n        dfs1(nxt);\n        cntt++;\n    }\n    ans1 += (cntt / 2);\n    if(x == 1 && (cntt % 2) == 1) ans1++;\n}\n\nbool dfs2(int x){\n    l[x].clear();\n    for(auto &nxt: tree[x]){\n        if(!dfs2(nxt)) return false;\n        //printf(\"bye %d -> %d: %d\\n\", nxt, x, bye[nxt]);\n        l[x].push_back(bye[nxt]+1);\n    }\n    int m = (int)l[x].size();\n    if(m%2 == 0){\n        l[x].push_back(0);\n        m++;\n    }\n    sort(l[x].begin(), l[x].end());\n    bye[x] = 0;\n    int ss = 0, ee = m-1, ans = m;\n    while(ss <= ee){\n        int mid = (ss + ee) / 2;\n        int s = 0, e = m-1;\n        bool can = true;\n        while(s < e){\n            if(s == mid) s++;\n            if(e == mid) e--;\n            if(s >= e) break;\n            if(l[x][s] + l[x][e] > lim){\n                can = false;\n                break;\n            }else{\n                s++; e--;\n            }\n        }\n        if(can){\n            ans = mid;\n            ee = mid - 1;\n        }else{\n            ss = mid + 1;\n        }\n    }\n    if(ans == m) return false;\n    bye[x] = l[x][ans];\n    return true;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<n;i++){\n        int aa, bb;\n        scanf(\"%d%d\", &aa, &bb);\n        g[aa].push_back(bb);\n        g[bb].push_back(aa);\n    }\n    p[1] = 1;\n    dfs1(1);\n    int ss = 1, ee = n+1, ans2 = n+1;\n    while(ss <= ee){\n        lim = (ss + ee) / 2;\n        //printf(\"%d\\n\", lim);\n        if(dfs2(1)){\n            ans2 = lim;\n            ee = lim - 1;\n        }else{\n            ss = lim + 1;\n        }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n}\n"
  },
  {
    "language": "C++",
    "code": "//created by missever\n\n#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\n\nint add(int x, int y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n}\n\nint mul(int x, int y) {\n    LL z = 1LL * x * y;\n    return z - z / mod * mod;\n}\n\nvector<int> g[maxn];\nmap<int, int> q[maxn];\nint m;\nint c[maxn];\n\nbool dfs(int u, int fa) {\n    q[u].clear();\n    for(auto v : g[u]) {\n        if(v == fa) continue;\n        if(!dfs(v, u)) return false;\n        q[u][c[v]]++;\n    }\n    int n = g[u].size() - (fa != 0);\n    if(!(n & 1)) q[u][0]++;\n    for(int i = 0; i < n / 2; i++) {\n        auto e = q[u].end();\n        e--;\n        int x = (*e).first;\n        if(--q[u][x] == 0) q[u].erase(x);\n        e = q[u].upper_bound(m - x);\n        if(e == q[u].begin()) return false;\n        e--;\n        int y = (*e).first;\n        if(--q[u][y] == 0) q[u].erase(y);\n    }\n    c[u] = (*q[u].begin()).first + (u != 1);\n    //cout<<u<<\" \"<<c[u]<<endl;\n    return c[u] <= m;\n\n}\n\nint pdfs(int u, int fa) {\n    int t = 0;\n    for(auto v : g[u]) {\n        if(v == fa) continue;\n        t += pdfs(v, u);\n    }\n    int n = g[u].size() - (fa != 0);\n    t += n / 2;\n    if(u == 1 && (n & 1)) t++;\n    return t;\n}\n\n\nint main() {\n#ifdef CX_TEST\n    freopen(\"E:\\\\program--GG\\\\test_in.txt\", \"r\", stdin);\n#endif\n    int n, i, u, v;\n    scanf(\"%d\", &n);\n    for(i = 1; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int l = 1, r = n;\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        m = mid;\n        //cout<<mid<<endl;\n        if(dfs(1, 0)) r = mid;\n        else l = mid + 1;\n    }\n    printf(\"%d %d\\n\", pdfs(1, 0), r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(s.size() == 1 || other==s.end()) {\n\t\t\t\tdp[x].f += dp[x].s > 0;\n\t\t\t\tdp[x].s = y;\n\t\t\t\ts.erase(s.begin());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tdp[x].s += x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tcout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll ans=0;\n\tFOR(i,1,n)ans+=v[i].size()&1;\n\tans /= 2;\n\tassert(tryy(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tson.erase(son.begin()+r);\n\tfor (int i=0;i<son.size()/2;i++)\n\t{\n\t\tint j = son.size() - 1 - i;\n\t\tif (son[i] + son[j] > B) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size == 0)\n\t{\n\t\tdp[u] = 1;\n\t}\n\telse if (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (g[i].size() == 1)\n\t\t{\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n-1; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN = 100000+9;\nstruct E{\n\tint next,to;\n}edge[MAXN<<1];\nint head[MAXN],edge_num;\nint n;\nint degree[MAXN];\nint dp[MAXN];\nint A,B;\nint limit;\n\nvoid addedge(int x,int y){\n\tdegree[x]++;\n\tedge[++edge_num].next=head[x];\n\tedge[edge_num].to=y;\n\thead[x]=edge_num;\n}\n\nbool DP(int x,int fa){\n\tvector<int> vec;\n\tint cnt=0;\n\tif(degree[x]%2==1)\n\t\tvec.push_back(0);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tif(edge[i].to!=fa){\n\t\t\tif(!DP(edge[i].to,x))return false;\n\t\t\tif(dp[edge[i].to]!=-1)vec.push_back(dp[edge[i].to]+1);\n\t\t}\n\t}\n\n\tsort(vec.begin(),vec.end());\n\tif(vec.size()%2==1){\n\t\tint loc=-1;\n\t\tint l=0,r=vec.size()-1;\n\t\twhile(l<=r){\n\t\t\tint mid=l+r>>1;\n\t\t\tbool jud=1;\n\t\t\tint p1=0,p2=vec.size()-1;\n\t\t\twhile(p1<p2){\n\t\t\t\tif(p1==mid)p1++;\n\t\t\t\tif(p2==mid)p2--;\n\t\t\t\tif(vec[p1]+vec[p2]>limit){\n\t\t\t\t\tjud=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp1++;p2--;\n\t\t\t}\n\t\t\tif(jud){\n\t\t\t\tloc=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\tif(loc==-1){\n\t\t\treturn false;\n\t\t}\n\t\tdp[x]=vec[loc];\n\t\treturn true;\n\t}\n\telse{\n\t\tfor(int i=0,j=vec.size()-1;i<j;i++,j--){\n\t\t\tif(vec[i]+vec[j]>limit){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdp[x]=-1;return true;\n\t}\n}\n\nbool check(int len){\n\tlimit=len;\n\tmemset(dp,0,sizeof(dp));\n\treturn DP(1,0);\n}\n\nvoid solve(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid)){\n\t\t\tr=mid-1;\n\t\t\tB=mid;\n\t\t}\n\t\telse\n\t\t\tl=mid+1;\n\t}\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a,b);\n\t\taddedge(b,a);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(degree[i]%2==1)\n\t\t\tA++;\n\t}\n\tA/=2;\n\tsolve();\n\tprintf(\"%d %d\\n\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls,cls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tif(tmp>L) return -1;\n\t\tls.insert(tmp);\n\t}\n\tcls = ls;\n\tint K = ls.size();\n\n\tif(K%2==0){\n\t\t{\n\t\t\tbool perfect = 1;\n\t\t\tvector<int> v;\n\t\t\tfor(int x:ls) v.pb(x);\n\t\t\trep(i,K/2) if(v[i]+v[K-1-i]>L) perfect = 0;\n\t\t\tif(perfect) return 1;\n\t\t}\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\n\tint lef = -1;\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\tif(lef!=-1) return -1;\n\t\t\tlef = a;\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(ls.size()==1) lef = *ls.begin();\n\treturn lef + 1;\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=0;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += deg%2;\n\t}\n\tA/=2;\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int N=100001;\nint n,cnt,head[N],du[N];\nstruct xint{int to,next;}e[N*2];\nvoid addedge(int x,int y){\n\te[++cnt]=(xint){y,head[x]};head[x]=cnt;\n\te[++cnt]=(xint){x,head[y]};head[y]=cnt;\n\tdu[x]++;du[y]++;\n}\nint Mid,p[N],f[N],a[N];\nint top,stk[N];bool mk[N];\nbool Check(){\n\tref(i,1,p[0])mk[i]=0;\n\tint pos=1;top=0;\n\tdef(i,p[0],1)if(!mk[i]){\n\t\tif(pos>i)pos=i;\n\t\twhile(top>0&&stk[top]>=i)top--;\n\t\twhile(pos<i&&p[pos]+p[i]<=Mid)stk[++top]=pos,pos++;\n\t\tif(!top)return 0;\n\t\tmk[stk[top]]=1;top--;mk[i]=1;\n\t}\n\treturn 1;\n}\nbool check(int x){\n\ta[0]=0;\n\tref(i,1,p[0])if(i!=x)a[++a[0]]=p[i];\n\tif(a[0]&1)a[0]--;\n\tref(i,1,a[0])mk[i]=0;\n\tint pos=1;top=0;\n\tdef(i,a[0],1)if(!mk[i]){\n\t\tif(pos>i)pos=i;\n\t\twhile(top>0&&stk[top]>=i)top--;\n\t\twhile(pos<i&&a[pos]+a[i]<=Mid)stk[++top]=pos,pos++;\n\t\tif(!top)return 0;\n\t\tmk[stk[top]]=1;top--;mk[i]=1;\n\t}\n\treturn 1;\n}\nvoid dfs(int fa,int x){\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint y=e[i].to;if(y==fa)continue;dfs(x,y);\n\t}\n\tp[0]=0;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tp[++p[0]]=f[y]+1;\n\t\tif(p[p[0]]>Mid){f[x]=1e9;return;}\n\t}\n\tif(!p[0]){f[x]=0;return;}\n\tsort(p+1,p+p[0]+1);\n\tif(x==1&&!(p[0]&1)){\n\t\tif(!Check())f[x]=1e9;else f[x]=0;\n\t\treturn;\n\t}\n\tif(!(p[0]&1)&&Check()){f[x]=0;return;}\n\tint l=1,r=p[0]+1;\n\twhile(l<r){\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))r=mid;else l=mid+1;\n\t}\n\tif(l==p[0]+1){f[x]=1e9;return;}\n\tf[x]=p[l];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tref(i,2,n){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t}\n\tint tot=0;\n\tref(i,1,n)if(du[i]&1)tot++;\n\tcout<<tot/2<<\" \";\n\tint L=1,R=n-1;\n\twhile(L<R){\n\t\tmemset(f,0,sizeof f);\n\t\tMid=(L+R)>>1;\n\t\tdfs(0,1);\n\t\tif(f[1]<=Mid)R=Mid;else L=Mid+1;\n\t}\n\tcout<<L<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    vector<int> tmp;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n        tmp.push_back(t + 1);\n    }\n\n    if((p == -1) ^ (st.size() % 2)) {\n        if(p != -1) {\n            for(int i = 0; i < (int)tmp.size() - 1; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n            }\n        }\n        else {\n            for(int i = 0; i < (int)tmp.size(); i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 1 - i ] > X) return -1;\n            }\n        }\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return v;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len && len!=1) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi g;\nvi dp;\n\nbool ff(vi& a,int I,int L){\n\tint N=a.size();\n\tbool B=1;\n\tfor(int i=0;i<N/2;i++) if(a[(i<I?i:i+1)]+a[(N-i-1>I?N-i-1:N-i-2)]>L) B=0;\n\treturn B;\n}\n\nbool f(int v,int p,int L){\n\tbool B=1;\n\tvi a;\n\tfor(auto u:g[v]) if(u!=p){\n\t\tB&=f(u,v,L)&&dp[u]!=L;\n\t\ta.push_back(dp[u]+1);\n\t}\n\tif(!B) return 0;\n\tsort(a.begin(),a.end());\n\tint N=a.size();\n\tif(N%2==0){\n\t\tfor(int i=0;i<N/2;i++) if(a[i]+a[N-i-1]>L) return 0;\n\t}\n\telse{\n\t\tint l=-1,r=N;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(ff(a,m,L)) r=m;\n\t\t\telse l=m;\n\t\t}\n\t\tif(r==N) return 0;\n\t\tdp[v]=a[r];\n\t}\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint A=0,v,l=0,r=n-1;\n\tfor(int i=0;i<n;i++){\n\t\tint S=g[i].size();\n\t\tA+=S%2;\n\t\tif(S==1) v=i;\n\t}\n\tA/=2;\n\twhile(r-l>1){\n\t\tdp=vi(n);\n\t\tint m=(l+r)/2;\n\t\tif(f(v,-1,m)) r=m;\n\t\telse l=m;\n\t}\n\tcout<<A<<' '<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tint ans=dfs(1,-1);\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN = 100000+9;\nstruct E{\n\tint next,to;\n}edge[MAXN<<1];\nint head[MAXN],edge_num;\nint n;\nint degree[MAXN];\nint dp[MAXN];\nint A,B;\nint limit;\n\nvoid addedge(int x,int y){\n\tdegree[x]++;\n\tedge[++edge_num].next=head[x];\n\tedge[edge_num].to=y;\n\thead[x]=edge_num;\n}\n\nbool DP(int x,int fa){\n\tvector<int> vec;\n\tint cnt=0;\n\tif(degree[x]%2==1)\n\t\tvec.push_back(0);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tif(edge[i].to!=fa){\n\t\t\tif(!DP(edge[i].to,x))return false;\n\t\t\tif(dp[edge[i].to]!=-1)vec.push_back(dp[edge[i].to]+1);\n\t\t}\n\t}\n\n\tsort(vec.begin(),vec.end());\n\tif(vec.size()%2==1){\n\t\tint loc=-1;\n\t\tint l=0,r=vec.size()-1;\n\t\twhile(l<=r){\n\t\t\tint mid=l+r>>1;\n\t\t\tbool jud=1;\n\t\t\tint p1=0,p2=vec.size()-1;\n\t\t\twhile(p1<p2){\n\t\t\t\tif(p1==mid)p1++;\n\t\t\t\tif(p2==mid)p2--;\n\t\t\t\tif(vec[p1]+vec[p2]>limit){\n\t\t\t\t\tjud=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp1++;p2--;\n\t\t\t}\n\t\t\tif(jud){\n\t\t\t\tloc=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\tif(loc==-1){\n\t\t\treturn false;\n\t\t}\n\t\tdp[x]=vec[loc];\n\t\treturn true;\n\t}\n\telse{\n\t\tfor(int i=0,j=vec.size()-1;i<j;i++,j--){\n\t\t\tif(vec[i]+vec[j]>limit){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//dp[x]=-1;\n\t\treturn true;\n\t}\n}\n\nbool check(int len){\n\tlimit=len;\n\tmemset(dp,0,sizeof(dp));\n\treturn DP(1,0);\n}\n\nvoid solve(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tint mid=l+r>>1;\n\t\tif(check(mid)){\n\t\t\tr=mid-1;\n\t\t\tB=mid;\n\t\t}\n\t\telse\n\t\t\tl=mid+1;\n\t}\n}\n\nint main(){\n\tfreopen(\"in.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a,b);\n\t\taddedge(b,a);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(degree[i]%2==1)\n\t\t\tA++;\n\t}\n\tA/=2;\n\tsolve();\n\tprintf(\"%d %d\\n\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define ii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n\nconst int N = 1e5 + 10;\nconst int  oo = 1e9;\n\nint n, A, cur ,nex;\nvector<int> vi[N];\nint rem[N];\n\nvoid findA(int u, int pre){ // return the\n    int cnt = 0;\n    for(int v: vi[u])   if(v != pre)    {\n        findA(v, u);\n        cnt ++;\n    }\n    A += cnt / 2;\n    if(u == 1 && cnt % 2 == 1) A ++;\n    return;\n}\nint dfs(int pre, int u)    {\n    multiset<int> st;\n\n    for(int v: vi[u])   if(v != pre)    {\n        int tmp = dfs(u, v);\n        st.insert(tmp + 1);\n    }\n    int dem = 0;\n    while(st.size() > 0)    {\n        std::multiset<int>::iterator it = st.end(); it --;\n        int x = (*it);\n        st.erase(it);\n\n        it = upper_bound(st.begin(), st.end(), cur - x);\n        if(it == st.begin())    {\n            rem[++dem] = x;\n        }else {\n            --it; st.erase(it);\n            nex ++;\n        }\n    }\n\n    reverse(rem + 1, rem + 1+ dem);\n    while(dem > 0 && rem[dem] == cur)  nex++, dem --;\n    if(dem > 0) {\n        nex += dem - 1;\n        return rem[1];\n    }\n    return 0;\n}\n\nbool check()    {\n    nex = 0;\n    nex += dfs(1, 1) > 0;\n    return nex <= A;\n}\n\nsigned main() {\n    //freopen(\"test.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    FOR(i, 1, n - 1)    {\n        int x, y; cin >> x >> y;\n        vi[x].pb(y);\n        vi[y].pb(x);\n    }\n    findA(1, 1);\n    int l = 1, r = n;\n    while(r > l)    {\n        cur = ( l + r) / 2;\n        if(check()) r = cur;\n        else l = cur + 1;\n    }\n\n    cout << A << ' ' << l;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nvector<int> G[100005];\n\nint dfs(int v, int prev)\n{\n\tif(prev != -1 && G[v].size() == 1) return 1;\n\t\n\tint ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tret += dfs(G[v][i], v);\n\t}\n\tif(prev == -1) ret -= (int)G[v].size() / 2;\n\telse ret -= ((int)G[v].size() - 2) / 2;\n\treturn ret;\n}\n\nint dfs2(int v, int prev, int bound)\n{\n\tif(bound <= 0) return -1;\n\tif(prev != -1 && G[v].size() == 1) return 1;\n\t\n\tvector<int> vec;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tint res = dfs2(G[v][i], v, bound);\n\t\tif(res < 0) return -1;\n\t\tvec.push_back(res);\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tif(prev == -1){\n\t\tint l = 0, r = vec.size()-1;\n\t\tbool flag = false;\n\t\twhile(1){\n\t\t\tif(l >= r) return 1;\n\t\t\tif(vec[l] + vec[r] > bound) break;;\n\t\t\tl++, r--;\n\t\t}\n\t}\n\telse{\n\t\tif(G[v].size() % 2) vec.insert(vec.begin(), 0);\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif(vec[i] + 1 > bound) continue;\n\t\t\tint l = 0, r = vec.size()-1;\n\t\t\tbool flag = false;\n\t\t\twhile(1){\n\t\t\t\tif(l == i) l++;\n\t\t\t\tif(r == i) r--;\n\t\t\t\tif(l >= r) return vec[i] + 1;\n\t\t\t\tif(vec[l] + vec[r] > bound) break;\n\t\t\t\tl++, r--;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint a, b;\n\tfor(int i = 1; i <= N-1; i++){\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\t\n\tint ansA, ansB;\n\tansA = dfs(1, -1);\n\t\n\tint lb = 0, ub = N, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(dfs2(1, -1, mid) >= 0) ub = mid;\n\t\telse lb = mid;\n\t}\n\tansB = ub;\n\t\n\tcout << ansA << \" \" << ansB << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int nmax = 100010;\nint deg[nmax],dp[nmax];\nbool fix[nmax];\nvector < int > graph[nmax];\nint N,u;\nbool check2(int x,int B, vector<int>& kids)\n{\n\tint l = 0, r = kids.size() - 1;\n\tif((kids[x]+1) > B) return false;\n\twhile( l < r)\n\t{\n\t\tif(l == x) l++;\n\t\tif(r == x) r--;\n\t\tif(l >= r  || r < 0) return true;\n\t\tif((kids[l] + kids[r]+2 )> B) return false;\n\t\tl++,r--;\n\t}\n\treturn true;\n}\nbool dfs(int u, int x)\n{\n\tfix[u] = true;\n\tbool ret = true;\n\t//cout << \"in vertex \" << u << \" trying \" << x << endl;\n\tvector< int > kids;\n\tfor(int i = 0; i < graph[u].size(); ++i)\n\t{\n\t\tif(fix[graph[u][i]]) continue;\n\t\tret&=dfs(graph[u][i],x);\n\t\tkids.push_back(dp[graph[u][i]]);\n\t}\n\tif(!ret) return ret;\n\tbool isfake = false;\n\tif((kids.size()&1)==0){ isfake = true; kids.push_back(-1);}\n\tsort(kids.begin(), kids.end());\n\tint l = 0, r = kids.size() - 1;\n\t\n\t//cout << \"out to \" << u;\n\t//cout << \"\\n\\t\";\n\t//for(int i = 0 ; i < kids.size(); ++i)\n\t//\tcout << kids[i] << ' ';\n\t//cout << endl;\n\tbool isGood = check2(r, x, kids);\n\twhile((r - l) > 1)\n\t{\n\t\tint mid = (r+l) >> 1;\n\t\tif(check2(mid, x, kids))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\n\t}\n\tif(check2(l, x, kids)) r = l;\n\tif(!isGood) return false;\n\t//cout << \"\\tchose\" << kids[r] << endl;\n\tdp[u] = kids[r]+1;\n\tif(kids[r] == 0 && isfake) dp[u] = 0;\n\treturn true;\n}\nbool check(int x)\n{\n\tfor(int i = 1;i<=N;++i)dp[i]=N,fix[i]=false;\n\treturn dfs(u,x);\n}\nint bs()\n{\n\tint l = 1, r = N-1;\n\twhile((r-l) > 1)\n\t{\n\t\tint mid = (l+r) >> 1;\n\t\tif(check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\t//cout << l << ' ' << r << ' ' << mid << endl;\n\t}\n\tif(check(l))\n\t\treturn l;\n\treturn r;\n\n}\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0 ;i < N-1;++i)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tint A=0,B=0;\n\tfor(int i = 1;i<=N;++i)\n\t{\n\t\tif(deg[i]&1) A++;\n\t\tif(deg[i] == 1) u = i;\n\t}\n\tA = (A+1)/2;\n\tcout << A << ' ' << bs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt,x);\n\t\tv.push_back(F[vs[i].v]);\n\t}\n\tif(!(v.size()&1)) v.push_back(0);\n\tsort(v.begin(),v.end());\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tF[rt]=rs+1;\n}\ninline bool check(int x)\n{\n\tdfs(Rt,0,x); return F[Rt]<=x+1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1;//,Rt=du[i]==1? i:Rt;\n\tRt=1;\n\tint l=0,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\nint cnt[MAX];\nmultiset<int> vv[MAX];\nmultiset<int> tmp[MAX];\n\nbool can;\nint mx;\nvector<int> unf[MAX];\nint C;\ninline void dfs(int b, int pr = -1) {\n\tvv[b].clear();\n\tunf[b].clear();\n\tint deg = 0;\n\tfor (int go : v[b]) {\n\t\tif (go == pr)continue;\n\t\tdfs(go, b);\n\t\tdeg++;\n\t\tvv[b].insert(dp[go] + 1);\n\t}\n\ttmp[b] = vv[b];\n\tC += deg/2;\n\tif (deg % 2 && b == 0) {\n\t\tC++;\n\t}\n\tif (vv[b].size()) {\n\t\tint la = (*vv[b].rbegin());\n\t\tif (la > mx) {\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (vv[b].size() > 1) {\n\t\tint bc = *vv[b].rbegin();\n\t\tvv[b].erase(prev(vv[b].end()));\n\t\tint able = mx - bc;\n\t\tauto it = vv[b].upper_bound(able);\n\t\tif (it == vv[b].begin()) {\n\t\t\tunf[b].push_back(bc);\n\t\t\tcontinue;\n\t\t}\n\t\tit = prev(it);\n\t\tvv[b].erase(it);\n\t}\n\tif (vv[b].size()) {\n\t\tunf[b].push_back(*vv[b].begin());\n\t}\n\tvv[b].clear();\n\tif (deg%2&&unf[b].size() > 1) {\n\t\tcan = true;\n\t\tdp[b] = 0;\n\t\treturn;\n\t}\n\tif (deg % 2) {\n\t\tdp[b] = unf[b][0];\n\t\treturn;\n\t}\n\telse {\n\t\tif (unf[b].size() == 0) {\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (b == 0) {\n\t\t\t\tcan = true;\n\t\t\t\tdp[b] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvv[b] = tmp[b];\n\t\t\tunf[b].clear();\n\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\twhile (vv[b].size() > 1) {\n\t\t\t\tint bc = *vv[b].rbegin();\n\t\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\t\tint able = mx - bc;\n\t\t\t\tauto it = vv[b].upper_bound(able);\n\t\t\t\tif (it == vv[b].begin()) {\n\t\t\t\t\tunf[b].push_back(bc);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit = prev(it);\n\t\t\t\tvv[b].erase(it);\n\t\t\t}\n\t\t\tif (vv[b].size()) {\n\t\t\t\tunf[b].push_back(*vv[b].begin());\n\t\t\t}\n\t\t\tif (unf[b].size() == 1) {\n\t\t\t\tdp[b] = unf[b][0];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\nbool ok(int len) {\n\tcan = false;\n\tmx = len;\n\tC = 0;\n\tdfs(0);\n\treturn can == false;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint mint = 1;\n\tint maxt = n;\n\twhile (mint + 1 < maxt) {\n\t\tint mid = (mint + maxt) >> 1;\n\t\tif (ok(mid)) {\n\t\t\tmaxt = mid;\n\t\t}\n\t\telse {\n\t\t\tmint = mid + 1;\n\t\t}\n\t}\n\tif (ok(mint)) {\n\t\tok(mint);\n\t\tcout <<C<<\" \"<< mint << endl;\n\t}\n\telse {\n\t\tok(maxt);\n\t\tcout << C<<\" \"<<maxt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <climits>\n#include <bitset>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0;\n    char ch = Advance();\n    while (!isdigit(ch))\n        ch = Advance();\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer;\n}\n\nconst int MAXN = 100000;\n\nvector<int> g[1 + MAXN];\nint limit, splits[1 + MAXN];\n\nint DFS(int node, int father) {\n    multiset<int> sons;\n    for (auto &son : g[node])\n        if (son != father) {\n            sons.insert(DFS(son, node));\n            if (sons.find(-1) != sons.end())\n                return -1;\n        }\n    if (sons.empty())\n        return 1;\n    if (sons.size() == 1)\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    int n = sons.size();\n    if (sons.size() % 2) {\n        for (int i = 1; 2 * i <= n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n    else {\n        for (int i = 1; 2 * i < n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() + *sons.rbegin() + 1 <= limit)\n            return 1;\n        if (node == 1)\n            return -1;\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n}\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int first = 1, left = 2, right = n, second = n;\n    for (int i = 3; i <= n; i++)\n        splits[i] = splits[i / 2] + splits[i - i / 2] + 1;\n    for (int i = 1; i <= n; i++)\n        first += splits[g[i].size()];\n    while (left <= right) {\n        limit = (left + right) / 2;\n        if (DFS(1, 0) != -1) {\n            second = limit;\n            right = limit - 1;\n        }\n        else\n            left = limit + 1;\n    }\n    second--;\n    printf(\"%d %d\\n\", first, second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\n\nvector<int> T[MX];\nint N, m, val = 1;\n\nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( X.empty() ) return 0;\n\tif( X.back() > m ) val = 0;\n\n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tif( X[i] + X[X.size()-i-1] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n\nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::multiset<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.insert(DFS(to, i, len) + 1);\n\t}\n\tint edges = lens.size() + 1;\n\n\tif (edges == 1) return 0;\n\tif (edges % 2 == 1) lens.insert(0);\n\n\tfor (int i = 0; i < (edges - 1) / 2; ++i) {\n\t\tauto mit = std::prev(lens.end());\n\t\tint mx = *mit;\n\t\tlens.erase(mit);\n\t\tauto d = lens.upper_bound(len - mx);\n\t\tif (d == lens.begin()) return INF;\n\t\tlens.erase(std::prev(d));\n\t}\n\treturn *lens.begin();\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 1;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<=j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\tif (len[j]<=mid)\n\t\t\t{\n\t\t\t\ts.erase(j);\n\t\t\t\tt--;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1) dis[x]=len[*s.begin()];\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n#include<cassert>\n#include<set>\nstruct kk\n{\n\tint v;\n};\nbool operator <(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nbool cmp(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nstd::multiset<kk> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int k)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,k)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tassert(pv%2==0);\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>k)return 0;\n\t}\n\telse\n\t{\n\t\tpv=0;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)v[++pv]=f[e[p].to]+1;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tint ans=0;\n\t\tfor(register int l=1,r=pv,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\t{\n\t\t\tfor(register int x=mid==1?2:1,y=mid==pv?pv-1:pv;x<y;)\n\t\t\t{\n\t\t\t\tif(v[x]+v[y]>k)goto skip;\n\t\t\t\t++x,--y;\n\t\t\t\tif(x==mid)++x;\n\t\t\t\tif(y==mid)--y;\n\t\t\t}\n\t\t\tans=mid;\n\t\t\tr=mid-1;\n\t\t\tcontinue;\n\t\t\tskip:;\n\t\t\tl=mid+1;\n\t\t}\n\t\tif(ans==0)return 0;\n\t\tf[o]=v[ans];\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,1,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(3);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root, int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to, root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size();\n\tmultiset<int> mt;\n\trep(i, len)mt.insert(v[i]);\n\twhile(len>=2) {\n\t\tcnt++;\n\t\tauto itr = mt.end(); itr--;\n\t\tint z = *itr; mt.erase(mt.find(z)); len--;\n\t\tint r = c - z;\n\t\tif (mt.count(r)) {\n\t\t\tmt.erase(mt.find(r)); len--;\n\t\t}\n\t\telse {\n\t\t\tmt.insert(r);\n\t\t\tauto itr2 = mt.find(r);\n\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\tmt.erase(itr2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titr2--; mt.erase(r);\n\t\t\tint zz = *itr2;\n\t\t\tmt.erase(itr2); len--;\n\t\t}\n\t}\n\tint z = 0;\n\tif (len == 1) {\n\t\tz = *mt.begin();\n\t}\n\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa << \" \" << ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A;\nvector<int> e[N];\n\nint g(vector<int> &v, int z){\n    for(int i = -(v.size() & 1), j = int(v.size()) - 1; i < j; i++, j--){\n        int t = v[j];\n        if(i >= 0) t += v[i];\n        if(t > z) return -1;\n    }\n    return 0;\n}\n\nint h(vector<int> &v, int m, int z){\n    if((m >= 0 ? v[m] : 0) + 1 > z) return -1;\n    vector<int> w;\n    for(int i = 0; i < v.size(); i++) if(i != m) w.push_back(v[i]);\n    return g(w, z);\n}\n\nint f(int x, int y, int z){\n    vector<int> v;\n    for(int i : e[x]){\n        if(i == y) continue;\n        v.push_back(f(i, x, z));\n        if(v.back() < 0) return -1;\n    }\n    if(v.empty()) return 1;\n    sort(v.begin(), v.end());\n    if(!y) return g(v, z);\n    int l = -(~v.size() & 1), r = v.size() - 1;\n    while(l < r){\n        int m = (l + r + 2) / 2;\n        if(h(v, m, z) >= 0) l = m;\n        else r = m - 1;\n    }\n    if(h(v, l, z) < 0) return -1;\n    r = (l >= 0 ? v[l] : 0) + 1;\n    return r;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 0, x, y; i < n - 1; i++){\n        scanf(\"%d%d\", &x, &y);\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    A = n - 1;\n    for(int i = 1; i <= n; i++) A -= int(e[i].size()) / 2;\n    printf(\"%d \", A);\n    int l = 1, r = n;\n    while(l < r){\n        int m = (l + r) / 2;\n        if(f(1, 0, m) >= 0) r = m;\n        else l = m + 1;\n    }\n    printf(\"%d\\n\", l);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=1001000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tint cnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tmit it;\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tint w=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif(it->second==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif(it->second==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=1;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int maxn=100005;\nvector<int>E[maxn];\nint n,deg[maxn],dp[maxn],lim;\nbool dfs(int u,int fa){\n\tbool res=1;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)res&=dfs(v,u);\n\t}\n\tstatic int c[maxn],tot;\n\ttot=0;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)c[++tot]=dp[v];\n\t}\n\tif(deg[u]&1)c[++tot]=0;\n\tsort(c+1,c+1+tot);\n\tint l=1,h=tot;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1,curl=1,curr=tot,Max=0;\n\t\tREP(i,1,tot>>1){\n\t\t\tif(curl==mid)curl++;\n\t\t\tif(curr==mid)curr--;\n\t\t\tchkmax(Max,c[curl]+c[curr]);\n\t\t}\n\t\tif(Max<=lim)h=mid-1;\n\t\telse l=mid+1;\n\t}\n\tres&=(l<=tot);\n\tdp[u]=c[l]+1;\n\treturn res;\n}\nbool check(int x){\n\tlim=x;\n\treturn dfs(1,0)&(dp[1]-1<=lim);\n}\nint main(){\n\tint u,v;\n\tn=read();\n\tREP(i,1,n-1){\n\t\tu=read(),v=read();\n\t\tE[u].pb(v),deg[u]++;\n\t\tE[v].pb(u),deg[v]++;\n\t}\n\tint ans=0;\n\tREP(i,1,n)ans+=(deg[i]&1);\n\twrite(ans>>1,' ');\n\tint l=1,h=n-1;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1;\n\t\tif(check(mid))h=mid-1;\n\t\telse l=mid+1;\n\t}write(l,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n    }\n\n    if((p == -1) ^ (st.size() % 2)) {\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return -1;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        assert((int) tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        res = false;\n                                        return;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        res = false;\n                                        return;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nconst int MAXN = 1e5 + 10;\n\nstruct Edge {\n  int v, next;\n}edge[MAXN << 1];\nint head[MAXN], tail, n, deg[MAXN];\nvoid insert(int u, int v) {\n  edge[++tail] = (Edge) {v, head[u]}; head[u] = tail;\n}\nnamespace solver1 {\n  int f[MAXN];\n  int bound;\n  bool dfs(int u, int fa) {\n    std::vector <int> dps;\n    for (int i = head[u]; i; i = edge[i].next) {\n      int v = edge[i].v;\n      if (v == fa) continue;\n      if (!dfs(v, u)) return 0;\n      if (f[v] > bound) return 0;\n      dps.push_back(f[v]);\n    }\n    if (deg[u] & 1) dps.push_back(0);\n    std::sort(dps.begin(), dps.end());\n    int l = 0, r = dps.size() - 1;\n    while(l <= r) {\n      int mid = (l + r) >> 1;\n      bool flag = 1;\n      for (int i = 0, j = dps.size() - 1; i < j; i++, j--) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (dps[i] + dps[j] > bound) {flag = 0; break;}\n      } \n      if (flag) {\n        f[u] = dps[mid];\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    f[u]++;\n    return f[u];\n  }\n  bool check() {\n    memset(f, -1, sizeof f);\n    return dfs(1, 0) \n      && f[1] <= bound + 1;\n  }\n  void main() {\n    int ans1 = 0;\n    for (int i = 1; i <= n; i++) { \n      if (deg[i] & 1) ans1++; \n    }\n    ans1 /= 2;\n    printf(\"%d \", ans1);\n    int l = 1, r = n, ans2 = 0;\n    deg[1]++;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      bound = mid;\n      if (check()) {\n        ans2 = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans2);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    insert(a, b);\n    insert(b, a);\n    deg[a]++; deg[b]++;\n  }\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5;\nvector<int> g[N];\nvector<int> path[N];\n\nint ans = 0;\n\nvoid dfs(int u, int p, int x) {\n  for (int v : g[u]) if (v != p) {\n    dfs(v, u, x);\n    path[u].push_back(path[v].back() + 1);\n  }\n\n  if (path[u].size() % 2 == 0) {\n    ans++;\n    path[u].push_back(0);\n  }\n\n  sort(path[u].begin(), path[u].end());\n\n  int ok = path[u].size();\n  int ng = -1;\n\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n\n    int mx = 0;\n    auto tmp = path[u];\n    tmp.erase(tmp.begin() + mid);\n\n    for (int i = 0; i * 2 + 1 < tmp.size(); i++) {\n      mx = max(mx, tmp[i] + tmp[tmp.size() - 1 - i]);\n    }\n\n    if (mx <= x) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n  ans -= path[u].size() / 2;\n \n  if (ok == path[u].size()) throw -1;\n  swap(path[u][ok], path[u].back());\n  \n  if (p == -1) {\n    if (path[u].back() > x) throw -1;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int ok = n - 1;\n  int ng = -1;\n  while (ok - ng > 1) {\n    ans = 0;\n    for (int i = 0; i < n; i++) {\n      path[i].clear();\n    }\n    int mid = (ok + ng) / 2;\n    try {\n      dfs(0, -1, mid);\n      ok = mid;\n    } catch (...) {\n      ng = mid;\n    }\n  }\n\n  cout << ans << ' ' << ok << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n;\nvi g[N];\n\nbool check(vi&f,int B,int skip) {\n  for(int i=0,j=sz(f)-1;i<j;++i,--j) {\n    if(i == skip) ++i;\n    if(j == skip) --j;\n    if(i < j && f[i] + f[j] > B)\n      return false;\n  }\n  return true;\n}\n\nint dfs(int c,int fa,int B) {\n  vi f;\n  for(auto t : g[c]) if(t != fa) {\n    f.pb(dfs(t , c , B));\n  }\n  if(~sz(f) & 1) f.pb(0);\n  sort(all(f));\n  if(!check(f , B , sz(f) - 1))\n    throw 1;\n  int l = -1 , r = sz(f) - 1;\n  while(l + 1 < r) {\n    int mid = (l + r) >> 1;\n    (check(f , B , mid) ? r : l) = mid;\n  }\n  return f[r] + 1;\n}\n\nbool check(int B,int rt) {\n  try {\n    int d = dfs(rt , 0 , B);\n    if(d > B + 1)\n      return false;\n    return true;\n  } catch(...) {\n    return false;\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,1,n) {\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  int A = 0;\n  rep(i,1,n+1) A += sz(g[i]) & 1;\n  int rt = 1;\n  while(~sz(g[rt]) & 1) rt++;\n  A >>= 1;\n  int l = 0 , r = n;\n  while(l + 1 < r) {\n    int mid = (l + r) >> 1;\n    (check(mid , rt) ? r : l) = mid;\n  }\n  printf(\"%d %d\\n\",A,r);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#  include <intrin.h>\n#  define __builtin_popcount __popcnt\n#endif\n\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <list>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) os << *i << (i == end(v) - 1 ? \"\" : \" \"); return os;\n}\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) is >> *i; return is;\n}\n\nvector<int> edg[101000];\n\nint dfs(int i, int max_sz, int parent = -1)\n{\n\tvector<int> arr;\n\tfor (int u : edg[i])\n\t{\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tint add = dfs(u, max_sz, i) + 1;\n\t\tarr.push_back(add);\n\t\tif (add > max_sz)\n\t\t\tthrow 1;\n\t}\n\n\tsort(arr.begin(), arr.end());\n\tif (arr.size() % 2 == 0)\n\t{\n\t\tbool ok = true;\n\t\tfor (int i = 0, j = arr.size() - 1; i < j; i++, j--)\n\t\t{\n\t\t\tif ((arr[i] + arr[j]) > max_sz)\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok)\n\t\t\treturn 0;\n\t\tarr.pop_back();\n\t}\n\n\t{\n\t\tint left = 0, right = arr.size();\n\t\twhile (left < right)\n\t\t{\n\t\t\tint m = (left + right) / 2;\n\n\t\t\tvector<int> tmp;\n\t\t\tfor (int j = 0; j < arr.size(); j++)\n\t\t\t{\n\t\t\t\tif (j != m)\n\t\t\t\t\ttmp.push_back(arr[j]);\n\t\t\t}\n\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0, j = tmp.size() - 1; i < j; i++, j--)\n\t\t\t{\n\t\t\t\tif ((tmp[i] + tmp[j]) > max_sz)\n\t\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tright = m;\n\t\t\telse\n\t\t\t\tleft = m + 1;\n\t\t}\n\n\t\tif (left == arr.size())\n\t\t\tthrow 1;\n\t\treturn arr[left];\n\t}\n}\n\nint main()\n{\n#if defined(_DEBUG) \n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedg[a].push_back(b);\n\t\tedg[b].push_back(a);\n\t}\n\n\tint A = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (edg[i].size() % 2 == 1)\n\t\t\tA++;\n\t}\n\n\tA /= 2;\n\n\tint left = 0, right = n + 1;\n\twhile (left < right)\n\t{\n\t\tint m = (left + right) / 2;\n\t\ttry\n\t\t{\n\t\t\tdfs(0, m, -1);\n\t\t}\n\t\tcatch (int)\n\t\t{\n\t\t\tleft = m + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tright = m;\n\t}\n\n\tcout << A << \" \" << left;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> edge;\n\nbool isok(const vector<int>& v, int rem, int k) {\n    int j = (int)v.size() - 1;\n    for (int i = 0; ; i++) {\n        if (i == rem) ++i;\n        if (j == rem) --j;\n        if (i >= j) return true;\n        if (v[i] + v[j] > k) return false;\n        --j;\n    }\n}\n\nint dfs(int p, int par, int k) {\n    vector<int> v;\n    for (int i : edge[p]) {\n        if (i == par) continue;\n        int a = dfs(i, p, k) + 1;\n        if (a > k) return a;\n        v.push_back(a);\n    }\n    if (v.size() % 2 == 0) v.push_back(0);\n    sort(v.begin(), v.end());\n    if (isok(v, 0, k))\n        return v[0];\n    if (!isok(v, (int)v.size() - 1, k))\n        return k + 1;\n\n    int ok = (int)v.size() - 1, ng = 0;\n    while (ng < ok - 1) {\n        int m = (ok + ng) / 2;\n        if (isok(v, m, k))\n            ok = m;\n        else ng = m;\n    }\n    return v[ok];\n}\n\nint main() {\n    cin >> n;\n    edge.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n    int a = 1;\n    for (int i = 0; i < n; i++)\n        a += (edge[i].size() + 1) / 2 - 1;\n\n    int ok = n - 1, ng = 0;\n    while (ng < ok - 1) {\n        int m = (ok + ng) / 2;\n        if (dfs(0, -1, m) <= m)\n            ok = m;\n        else ng = m;\n    }\n    cout << a << \" \" << ok << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nvector<int> graph[N];\nint root;\nint A, t;\nint beginning;\n\nint find_value(vector<int> &dp, int M)\n{\n    int L = -1, R = dp.size();\n    while (L + 1 < R)\n    {\n        int mid = (L + R) / 2;\n        int j = dp.size() - 1;\n        int t = 1;\n        for (int i = 0; i < j; )\n        {\n            if (i == mid) i++;\n            if (j == mid) j--;\n            if (dp[i] + dp[j] > M) t = 0;\n            i++, j--;\n        }\n        if (t) R = mid;\n        else L = mid;\n    }\n    return dp[R];\n}\n\nint dfs(int v, int p, int M)\n{\n    vector<int> dp;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dp.push_back(dfs(u, v, M));\n    }\n    if (dp.size() % 2 == 0) dp.push_back(0), beginning++;\n    sort(all(dp));\n    int x = find_value(dp, M) + 1;\n    if (x == M + 1) x = 1, beginning += 2;\n    //cout << \"vertex \" << v << \" \" << x << \"\\n\";\n    return x;\n}\n\nint check(int M)\n{\n    t = 0;\n    beginning = 0;\n    int cat = dfs(root, root, M);\n    if (cat == 1) beginning--;\n    //cout << \"if M = \" << M << \" \" << beginning << \"\\n\";\n    if ((beginning + 1) / 2 <= A) return 1;\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    int cnt_odd = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (graph[i].size() == 1) root = i;\n        cnt_odd += (graph[i].size() % 2);\n    }\n    cout << (cnt_odd + 1) / 2 << \" \";\n    A = (cnt_odd + 1) / 2;\n    int L = 0, R = n;\n    while (L + 1 < R)\n    {\n        int M = (L + R) / 2;\n        if (check(M)) R = M;\n        else L = M;\n    }\n    cout << R;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <ctime>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nbool tmp[100005];\nP res[100005];\nint cnt[100005];\n\nP solve(int len){\n\tmemset(used,false,sizeof(used));\n\tmemset(cnt,0,sizeof(cnt));\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++){\n\t\tif(G[i].size()==1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tint prev=-1;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tprev=v;\n\t\tque.pop();\n\t\tused[v]=true;\n\t\tint sum=0;\n\t\tvector<int> vi;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i];\n\t\t\tif(used[nv]){\n\t\t\t\tvi.push_back(res[nv].second);\n\t\t\t\tsum+=res[nv].first;\n\t\t\t}else{\n\t\t\t\tcnt[nv]++;\n\t\t\t\tif(cnt[nv]+1==G[nv].size())que.push(nv);\n\t\t\t}\n\t\t}\n\t\tif(vi.size()==0){\n\t\t\tres[v]=P(1,1);\n\t\t\tcontinue;\n\t\t}\n\t\tsort(vi.begin(),vi.end());\n\t\tint l=0,r=(int)vi.size()-1;\n\t\tfor(int i=0;i<(int)vi.size();i++){\n\t\t\ttmp[i]=false;\n\t\t}\n\t\twhile(l<r){\n\t\t\tif(vi[l]+vi[r]>len){\n\t\t\t\tr--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[l]=true;\n\t\t\ttmp[r]=true;\n\t\t\tsum--;\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t\tbool flag=false;\n\t\tint len_min=n+5;\n\t\tfor(int i=0;i<(int)vi.size();i++){\n\t\t\tif(!tmp[i]){\n\t\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}else if(len_min==len){\n\t\t\tsum++;\n\t\t\tlen_min=0;\n\t\t}\n\t\tres[v]=P(sum,len_min+1);\n\t\t//printf(\"%d %d %d\\n\",v,res[v].first,res[v].second);\n\t}\n\tif(res[prev].second==1){\n\t\tres[prev].first--;\n\t}\n\treturn res[prev];\n}\n\n\nbool C(int num,int len){\n\tP rec=solve(len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define fdi(a,b) for(int i=a-1;i>=b;--i)\n#define fdj(a,b) for(int j=a-1;j>=b;--j)\n#define fdo(a,b) for(int o=a-1;o>=b;--o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n////////////////////\n\nint const N = 1e5 + 41;\n\nvector<int> e[N];\nint n, d[N], q[N], m;\nint a, b;\n\nvoid dfs(int x, int p = -1){\n\td[x] = 0;\n\tq[x] = 0;\n\tvector<int> h;\n\tfi(0, sz(e[x])){\n\t\tint y = e[x][i];\n\t\tif(y == p) continue;\n\t\tdfs(y, x);\n\t\th.pb(d[y] + 1);\n\t\tq[x] += q[y];\n\t}\n\tsort(h.begin(), h.end());\n\tif(sz(h) == 1){\n\t\tif(h[0] < m){\n\t\t\td[x] = h[0];\n\t\t}else{\n\t\t\tq[x] += 1;\n\t\t}\n\t}else if(sz(h) == 2){\n\t\tint v = sz(h);\n\t\tif(h[0] + h[1] <= m){\n\t\t\tv -= 1;\n\t\t}else if(h[0] < m){\n\t\t\tv -= 1;\n\t\t\td[x] = h[0];\n\t\t}\n\t\tq[x] += v;\n\t}else if(sz(h) > 2){\n\t\tint v = sz(h);\n\t\tif(h[1] + h[2] <= m && h[0] < m){\n\t\t\tv -= 2;\n\t\t\td[x] = h[0];\n\t\t}else if(h[0] + h[2] <= m && h[1] < m){\n\t\t\tv -= 2;\n\t\t\td[x] = h[1];\n\t\t}else if(h[0] + h[1] <= m && h[2] < m){\n\t\t\tv -= 2;\n\t\t\td[x] = h[1];\n\t\t}else{\n\t\t\tif(h[0] + h[1] <= m) v -= 1;\n\t\t}\n\t\tq[x] += v;\n\t}\n}\n\nint calc(int m){\n\t::m = m;\n\tdfs(0);\n\tint res = q[0];\n\tif(d[0] > 0) res += 1;\n\treturn res;\n}\n\nvoid solve(){\n\tif(n == 2){\n\t\ta = 1;\n\t\tb = 1;\n\t\treturn;\n\t}\n\tint l = 0;\n\tint r = N;\n\ta = calc(n);\n\twhile(r-l>1){\n\t\tint m = (l+r)/2;\n\t\tif(calc(m) == a) r = m;\n\t\telse l = m;\n\t}\n\tb = r;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n-1){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\t--x;--y;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d %d\\n\",a,b);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring> \n#include<cstdio>\n#include<set>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nmultiset<int> s[MN+5];multiset<int>::iterator it;\nint n,f[MN+5],head[MN+5],cnt,ans,flag,mid;\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\ts[x].clear();f[x]=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa) dfs(e[i].to,x),s[x].insert(f[e[i].to]+1);\n\tint has=0,has2=0,tms=s[x].size()+1>>1,size=s[x].size();\n\tif(!size) ++ans;ans-=(size-1)/2;\n\tif(s[x].size()&&(*(--(it=s[x].end())))>mid) return(void)(flag=0);\n\tfor(int j=1;!s[x].empty();++j)\n\t{\n\t\tit=s[x].end();--it;\n\t\tint v=*it;s[x].erase(it);\n\t\tit=s[x].upper_bound(mid-v);\n\t\tif(it==s[x].begin())\n\t\t{\n\t\t\tif(!has) has=v,f[x]=has;\n\t\t\telse if(~size&1)\n\t\t\t{\n\t\t\t\tif(!has2) has2=v,f[x]=has2;\n\t\t\t\telse return(void)(flag=0);\n\t\t\t}\n\t\t\telse return (void)(flag=0);\n\t\t}\n\t\telse s[x].erase(--it);\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tint l=1,r=n,res,Ans;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;ans=0;flag=1;\n\t\tdfs(1,0);\n\t\t//cout<<\"Solve\"<<mid<<\" ok \"<<flag<<endl;\n\t\tif(flag) res=mid,r=mid-1,Ans=ans;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",Ans,res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    //if(V[1].size()%2) ++ans;\n    ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<ll>> vvll;\nconst ll inf = 1e16;\nconst ll md = 1000000007;\nvi to[100005];\nint deg[100005];\nvi par;\nint dp0[100005];\nint dp[100005];\nvi dp_uu;\nint n;\n\nint dfs(int u, int ou) {\n  par[u] = ou;\n  int to_leaf = 0;\n  for (int ku : to[u]) {\n    if (ku == ou) continue;\n    to_leaf = dfs(ku, u) + 1;\n  }\n  if (to_leaf >= 0) {\n    if (deg[ou] == 2 && ou != 0)\n      return to_leaf;\n    else {\n      dp0[u] = to_leaf;\n      return -10;\n    }\n  }\n  dp_uu.push_back(u);\n  return -10;\n}\n\nbool check(int m) {\n  rep(i, n) dp[i] = dp0[i];\n  //cout << \"m=\" << m << endl;\n  for (int u : dp_uu) {\n    vi dists(0);\n    for (int ku : to[u]) {\n      if (ku == par[u]) continue;\n      dists.push_back(dp[ku] + 1);\n    }\n    sort(dists.begin(), dists.end());\n    //cout << \"u=\" << u << endl;\n    //for (int d : dists) cout << d << \" \";\n    //cout << endl;\n    int n_child = dists.size();\n    if (dists[n_child - 1] > m) return false;\n\n    //cout << n_child << \" \" << (n_child & 1) << endl;\n    if ((n_child & 1) == 0) {\n      bool success = true;\n      rep(i, n_child / 2) if (dists[i] + dists[n_child - 1 - i] > m) {\n        //cout << \"fail\" << dists[i] << \" \" << dists[n_child - 1 - i] << endl;\n        n_child--;\n        success = false;\n        break;\n      }\n      if (success) {\n        dp[u] = 0;\n        continue;\n      }\n    }\n\n    int l = -1, r = n_child;\n    while (l + 1 < r) {\n      int c = (l + r) / 2;\n      int i = 0, j = n_child - 1;\n      bool ok = true;\n      rep(_, n_child / 2) {\n        if (i == c) i++;\n        if (j == c) j--;\n        if (dists[i] + dists[j] > m) {\n          if (c == n_child - 1) return false;\n          ok = false;\n          break;\n        }\n        i++;\n        j--;\n      }\n      if (ok)\n        r = c;\n      else\n        l = c;\n    }\n    dp[u] = dists[r];\n  }\n  if ((deg[0] & 1) == 0 && dp[0] > 0) return false;\n  return true;\n}\n\nint main() {\n  cin >> n;\n  par.resize(n, -1);\n  rep(i, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    to[a].push_back(b);\n    to[b].push_back(a);\n    deg[a]++;\n    deg[b]++;\n  }\n  //奇数次数の頂点数を求める\n  int n_odd_deg = 0;\n  rep(i, n) if (deg[i] & 1 == 1) n_odd_deg++;\n\n  //木DPの為に枝を縮める\n  dfs(0, -1);\n\n  //二分探索でBを決める\n  int l = -1, r = n;\n  while (l + 1 < r) {\n    int m = (l + r) / 2;\n    //cout << l << \" \" << m << \" \" << r << endl;\n    if (check(m))\n      r = m;\n    else\n      l = m;\n  }\n\n  cout << n_odd_deg / 2 << \" \" << r << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (x==1){\n\t\tif (top&1) ok&=check(top);\n\t\telse ok&=check(-1);\n\t\treturn;\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O)?stk[r]+1:(-1);\n\t}\n\telse{\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O)?stk[r]+1:(-1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=1,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint n; \nconst int INF = int(1e9);\nconst int N = 123456;\nii dp[N];\nvi adj[N];\n\nint threshold;\n\nvoid dfs(int u, int p=-1)\n{\n\tint sum = 0;\n\tdeque<int> V;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\tsum+=dp[v].fi;\n\t\tV.pb(dp[v].se);\n\t}\n\tsort(V.begin(),V.end());\n\twhile(!V.empty()&&V.back()>=threshold)\n\t{\n\t\tV.pop_back(); V.push_front(0); sum++;\n\t}\n\tdeque<int> tmp = V;\n\tint tmps = sum;\n\t{\n\t\tint mnup=INF;\n\t\tif(!V.empty())\n\t\t{\n\t\t\tmnup = V[0]+1; V.pop_front();\n\t\t}\n\t\twhile(!V.empty())\n\t\t{\n\t\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t\t{\n\t\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t\t}\n\t\t\tif(V.back()+1<=threshold)\n\t\t\t{\n\t\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t\t}\n\t\t}\n\t\tdp[u] = mp(sum,mnup);\n\t}\n\tV=tmp; sum=tmps;\n\t{\n\t\tint mnup=INF;\n\t\twhile(!V.empty())\n\t\t{\n\t\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t\t{\n\t\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t\t}\n\t\t\tif(V.back()+1<=threshold)\n\t\t\t{\n\t\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t\t}\n\t\t}\n\t\tdp[u]=min(dp[u],mp(sum,mnup));\n\t}\n\t//cerr<<threshold<<\" | \"<<u<<' '<<sum<<' '<<mnup<<'\\n';\n}\n\nint calc(int C)\n{\n\tthreshold=C;\n\tdfs(0,-1); \n\treturn dp[0].fi;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tint bestres = calc(n+1);\n\tint lo=1; int hi=n;\n\tint ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint v=calc(mid);\n\t\tif(v<=bestres)\n\t\t{\n\t\t\tans=mid; hi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tcout<<bestres<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n    \n\n\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> G[100100];\nint N,Y,U,A;\n\nint dfs(int x, int l, int m)\n{\n\tvector<int> u;\n\tfor (auto &y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x,m)+1);\n\t}\n\tsort(u.begin(),u.end());\n\tint ret = 0;\n\tif (u.size() % 2 == 0){\n\t\tint y = 1;\n\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t}\n\t\tif (!y){\n\t\t\tif (u.back() <= m) u.pop_back(), U++;\n\t\t\telse Y = 0;\n\t\t}\n\t\telse U += u.size() / 2;\n\t}\n\tif (u.size() % 2){\n\t\tint l = 0, r = u.size()-1, a = u.size();\n\t\twhile (l <= r){\n\t\t\tint mm = (l + r) / 2;\n\t\t\tint y = 1;\n\t\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\t\tif (i == mm) i++;\n\t\t\t\tif (j == mm) j--;\n\t\t\t\tif (i >= j) break;\n\t\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t\t}\n\t\t\tif (u[mm] > m) y = 0;\n\t\t\tif (y){\n\t\t\t\ta = mm;\n\t\t\t\tr = mm - 1;\n\t\t\t}\n\t\t\telse l = mm + 1;\n\t\t}\n\t\tif (a == u.size()) Y = 0;\n\t\telse ret = u[a], U += u.size() / 2;\n\t}\n\treturn ret;\n}\n\nint chk(int m)\n{\n\tY = 1;\n\tU = 0;\n\tint l = dfs(1,0,m);\n\tif (l > m) Y = 0;\n\tif (l > 0) U++;\n\tif (U != A) Y = 0;\n\treturn Y;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\tint a = 0;\n\tfor (int i=1;i<=N;i++) a += G[i].size() % 2;\n\ta /= 2;\n\tA = a;\n\n\tint l = 1, r = N, b = N;\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (chk(m)){\n\t\t\tb = m;\n\t\t\tr = m - 1;\n\t\t}\n\t\telse l = m + 1;\n\t}\n\n\tprintf (\"%d %d\\n\",a,b);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(i >= j) continue;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u) + 1);\n    if(vals.size() == 0) return 0;\n    if(vals.size()%2 == 0) {\n        if( u == 0 ){\n            sort(vals.begin(), vals.end());\n            for(int i = 0, j = vals.size()-1; i < j; i++, j--) if(vals[i] + vals[j] > B) return B+1;\n            return 0;\n        }\n        vals.pb(0);\n    }\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size()-1;\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    //cout << \"leastUp \" << u << \": \" << vals[rb]+1 << endl;\n    return vals[rb];\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    return l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tint tmp = DFS(to, i, len);\n\t\tif (tmp == INF) return INF;\n\t\tlens.push_back(tmp + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint to[N << 1],nex[N << 1],beg[N],deg[N],Ans[N],rest[N],A[N];\nint e,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline void dfs(int x,int fa) {\n\tint cur = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tdfs(to[i],x),cur++;\n\t}\n\tans -= cur / 2,cur &= 1;\n\tif(!cur && x > 1) ans++;\n}\n\ninline int check(int Ban,int top,int val) {\n\tint pos = top,tot = 0;\n\tFor(i,1,top) {\n\t\tif(i == Ban) continue;\n\t\twhile(pos && (A[i] + A[pos] > val || pos == Ban)) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n\treturn tot;\n}\n\ninline void Dp(int x,int fa,int val) {\n\tint total = 0,top = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tDp(to[i],x,val);\n\t}\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\ttotal += Ans[to[i]];\n\t\tA[++top] = rest[to[i]];\n\t}\n\tsort(A + 1,A + top + 1);\n\twhile(top && A[top] >= val) top--;A[top + 1] = 0;\n\tint pos = top,tot = 0;\n\tFor(i,1,top) {\n\t\twhile(A[i] + A[pos] > val) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n\tint l = 1,r = top + 1;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid,top,val) < tot) l = mid + 1;\n\t\telse r = mid;\n\t}\n\trest[x] = A[l] + 1;Ans[x] = total - tot;\n\tif(l == top + 1 && x > 1) Ans[x]++;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n - 1) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tint l = 1,r = n;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n\t\tDp(1,0,mid);\n\t\tif(Ans[1] > ans) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\tprintf(\"%d %d\\n\",ans,l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\n\nint dfs(int cur,int pre,int T) {\n\tvector<int> V;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tint ret=dfs(e,cur,T);\n\t\tif(ret==-2) return -2;\n\t\tif(ret>=0) V.push_back(ret+1);\n\t}\n\tif(E[cur].size()%2) V.push_back(0);\n\tsort(ALL(V));\n\tfor(int y=(int)V.size()-1,x=y-1;y>=0;y--) {\n\t\tif(V[y]==-1) continue;\n\t\tx=min(x,y-1);\n\t\twhile(1) {\n\t\t\tif(x<0) break;\n\t\t\tif(V[x]==-1 || V[x]+V[y]>T) {\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tV[x]=-1;\n\t\t\t\tV[y]=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint ma=-1;\n\tint num=0;\n\tFORR(v,V) {\n\t\tma=max(ma,v);\n\t\tif(v>=0) num++;\n\t}\n\tif(num>=2) return -2;\n\treturn ma;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tint A=0;\n\tFOR(i,N) if(E[i].size()%2==1) A++;\n\t\n\tint B=1<<20;\n\tfor(i=19;i>=0;i--) {\n\t\tif(dfs(0,-1,B-(1<<i))!=-2) B-=1<<i;\n\t}\n\t\n\tcout<<A/2<<\" \"<<B<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint n; \nconst int INF = int(1e9);\nconst int N = 123456;\nii dp[N];\nvi adj[N];\n\nint threshold;\n\nvoid dfs(int u, int p=-1)\n{\n\tint sum = 0;\n\tdeque<int> V;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\tsum+=dp[v].fi;\n\t\tV.pb(dp[v].se);\n\t}\n\tsort(V.begin(),V.end());\n\twhile(!V.empty()&&V.back()>=INF)\n\t{\n\t\tV.pop_back(); V.push_front(0); sum++;\n\t}\n\tint mnup=INF;\n\twhile(!V.empty())\n\t{\n\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t{\n\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t}\n\t\tif(V.back()+1<=threshold)\n\t\t{\n\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t}\n\t\tmnup=min(mnup,1); V.pop_back(); sum++;\n\t}\n\tdp[u] = mp(sum,mnup);\n\t//cerr<<threshold<<\" | \"<<u<<' '<<sum<<' '<<mnup<<'\\n';\n}\n\nint calc(int C)\n{\n\tthreshold=C;\n\tdfs(0,-1); \n\treturn dp[0].fi;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tint bestres = calc(n+1);\n\tint lo=1; int hi=n;\n\tint ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint v=calc(mid);\n\t\tif(v<=bestres)\n\t\t{\n\t\t\tans=mid; hi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tcout<<bestres<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nconst int rt=1;int dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN];\nbool dfs(int u,int la)\n{\n\tstd::vector<int> fv;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfv.push_back(f[v]);\n\t}\n\tint k=fv.size();\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1)) fv.push_back(0),k++;\n\tstd::sort(fv.begin(),fv.end());\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tfor(int p1=1,p2=k;p1<p2;p1++,p2--)\n\t\t{\n\t\t\tif(p1==mid) p1++;if(p2==mid) p2--;\n\t\t\tif(fv[p1-1]+fv[p2-1]>B) {l=mid+1;continue;}\n\t\t}\n\t\tr=mid-1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fv[l-1]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(rt,0)) return false;\n\tif(f[rt]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tls.insert(tmp);\n\t}\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()) return -1;\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(ls.size() == 0) return 1;\n\telse return *ls.begin() + 1;\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=1;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += (deg-1)/2;\n\t}\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){ for (ll o=63, x=-1;;){ ll m=(o+x)/2; if (a<(1LL<<m))o=m; else x=m; if (o-x==1)return x; } }\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> inline void coutv(deque<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvvll cinGraph(ll nodeNum, ll edgeNum, bool isDirected){//無向false、有向true\n\tvvll to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u; cin >> v >> u;\n\t\tv--; u--;\n\t\tto[v].push_back(u);\n\t\tif (!isDirected) to[u].push_back(v);\n\t}\n\treturn move(to);\n}\n\n\nll N;\nvvll to;\nll X;\n\nll dfs(ll v, ll p){\n\tvll buf;\n\tEACH(u, to[v]){\n\t\tif (u==p) continue;\n\t\t\n\t\tll val = dfs(u, v) + 1;\n\t\tif (val >= X+1) return INF;\n\n\t\tbuf.push_back(val);\n\t}\n\tsort(ALL(buf));\n\tll cNum = sz(buf);\n\n\t//組めるかチェック\n\tvll rembuf;\n\twhile (!buf.empty()){\n\t\tll x = buf.back();  buf.pop_back();\n\t\tll val = X-x;\n\t\tauto it = upper_bound(ALL(buf), val);\n\t\tif (it==buf.begin()){//解なし\n\t\t\trembuf.push_back(x);\n\t\t}\n\t\telse{\n\t\t\tit--;\n\t\t\tbuf.erase(it);\n\t\t}\n\t}\n\tsort(ALL(rembuf));\n\tll remNum = sz(rembuf);\n\n\tif (p!=-1){\n\t\tif (cNum%2==0){\n\t\t\tif (remNum==0) return 0;\n\t\t\telse if (remNum==2) return rembuf[0];\n\t\t\telse return INF;\n\t\t}\n\t\telse{//奇数\n\t\t\tif (remNum==1) return rembuf[0];\n\t\t\telse return INF;\n\t\t}\n\t}\n\telse{//root\n\t\tif (cNum%2==0){\n\t\t\tif (remNum==0) return 0;\n\t\t\telse return INF;\n\t\t}\n\t\telse{//奇数\n\t\t\tif (remNum==1) return rembuf[0];\n\t\t\telse return INF;\n\t\t}\n\t}\n}\n\n\nvoid solve()\n{\n\tcin >> N;\n\tto = cinGraph(N, N-1, false);\n\n\tll A=1;\n\trep(v, 0, N-1){\n\t\tll s = sz(to[v]);\n\t\tA += (s-1)/2;\n\t}\n\n\tll ok = N-1;\n\tll ng=0;\n\twhile (abs(ok-ng)>1){\n\t\tll x = (ok+ng)/2;\n\n\t\tX = x;\n\t\tll r = dfs(0, -1);\n\n\t\tif (r!=INF) ok=x; else ng=x;\n\t}\n\n\tcout << A << \" \" << ok << '\\n';\n\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) {ui b=0;while(x){x>>=1;++b;}return b;}\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bsh(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsl(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass F {\npublic:\n    int N,root;\n    vector<vector<int>> E;\n\n    bool isOk(vector<int> &L, int b, int out) {\n        int i = 0, j = L.size()-1;\n        while (i < j) {\n            if (i == out) { ++i; continue; }\n            if (j == out) { --j; continue; }\n            if (L[i] + L[j] > b) return false;\n//            cerr << L[i] << \"+\" <<  L[j] << endl;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    bool canBuild(int u, int p, int b, int &length) {\n        vector<int> L;\n        for (int v:E[u]) {\n            if (v!=p) {\n                int l;\n                if (!canBuild(v,u,b,l)) return false;\n                L.push_back(l);\n            }\n        }\n\n        if (root == u && L.size() % 2 == 0) {\n            sort(L.begin(),L.end());\n            return isOk(L,b,-1);\n        }\n\n        if (L.size() % 2 == 0) L.push_back(0);\n        sort(L.begin(),L.end());\n        if (L.back() > b) {\n//            cerr << L.back() << \" too high\\n\";\n            return false;\n        }\n\n//        cerr << \"vertex \" << u+1 << ' ' << L;\n        int r = bsl(0, (int)L.size()-1, [&](int i) { return isOk(L, b, i); });\n        if (r == -1) return false;\n//        cerr << \"up: \" << L[r]+1 << endl;\n        length = L[r]+1;\n        return true;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N-1; ++i) {\n            int a,b; cin >> a >> b; --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        int A = 1;\n        for (int i = 0; i < N; ++i) {\n            A += (E[i].size()-1) / 2;\n            if (E[i].size() > 2) root = i;\n        }\n        int B = 0;\n        if (A == 1) B = N-1;\n        else {\n            B = bsl(1, N-1, [&](int b){\n                int z;\n//                cerr << \"Test \" << b << endl;\n               return canBuild(root, -1, b, z);\n            });\n        }\n\n        cout << A << ' ' << B << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tF solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() >= INF) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int ok = N, ng = 0;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nint n = 0;\nvector<int> edges[101010];\nbool visited[101010];\n\nint dfs(int v, int b, bool r = false) {\n    if (!r) {\n        fill(visited, visited + 101010, false);\n    }\n\n    visited[v] = true;\n    vector<int> lengths;\n\n    for (auto c : edges[v]) {\n        if (!visited[c]) {\n            int k = dfs(c, b, true);\n            if (k < 0 || b < k) return -1;\n            lengths.push_back(k);\n        }\n    }\n\n    bool odd = (edges[v].size() % 2 == 1);\n    int hold = -1;\n    sort(lengths.begin(), lengths.end());\n    while (1 < lengths.size()) {\n        int k = lengths.back();\n        lengths.pop_back();\n        auto i = upper_bound(lengths.begin(), lengths.end(), b - k);\n        if (i == lengths.begin()) {\n            if ((odd || r) && hold < 0) {\n                hold = k;\n            } else {\n                return -1;\n            }\n        } else {\n            lengths.erase(i - 1);\n        }\n    }\n\n    if (r && !odd && 0 < hold) {\n        lengths.push_back(hold);\n    }\n\n    if (lengths.size() == 0) {\n        return 1;\n    } else {\n        return lengths[0] + 1;\n    }\n}\n\n\ntuple<int, int> solve() {\n    int root = -1;\n    int a = 1;\n\n    rep(i, 0, n) {\n        size_t c = edges[i].size();\n        if (3 <= c) {\n            a += (c - 1) / 2;\n            root = i;\n        }\n    }\n\n    if (root < 0) {\n        return make_tuple(1, n - 1);\n    }\n\n    int ok = n - 1;\n    int ng = 1;\n\n    while (ng + 1 < ok) {\n        int mid = (ok + ng) / 2;\n        if (0 <= dfs(root, mid)) {\n            ok = mid;\n        } else {\n            ng = mid;\n        }\n    }\n\n    return make_tuple(a, ok);\n}\n\nint main(int argc, const char * argv[]) {\n    int a, b;\n    \n    cin >> n;\n    rep(i, 0, n - 1) {\n        cin >> a >> b;\n        --a;\n        --b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    auto p = solve();\n\n    cout << get<0>(p) << ' ' << get<1>(p) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nint32_t F(std::vector<int32_t>& a, int32_t K)\n{\n\tstd::sort(a.begin(),a.end());\n\tint lb = -1, ub = a.size();\n\twhile (ub - lb>1) {\n\t\tint mid = (ub + lb) / 2;\n\n\t\tbool f = true;\n\t\tint l = 0, r = a.size() - 1;\n\t\tfor (int i = 0; i < a.size() / 2;++i) {\n\t\t\tif (l == mid)l++;\n\t\t\tif (r == mid)r--;\n\t\t\tif (a[l] + a[r]>K)f = false;\n\t\t\tl++; r--;\n\t\t}\n\t\tif (f)ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\nif(0){\n\tstd::vector<int32_t> T;\n\tfor (auto& i : L) { T.push_back(i); }\n\tauto R = F(T, len_max);\n\tif(R==T.size()){\n\t\tfunc_ok = false;\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn T[R];\n\t}\n}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.upper_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\tif(0){\n\n\t\tlen_max = 10;\n\t\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\t\tL.insert(9);\n\t\tL.insert(8);\n\t\tL.insert(4);\n\n\t\tif (L.size() % 2 == 0) {\n\t\t\tL.insert(0);\n\t\t}\n\n\t\twhile (L.size() >= 2) {\n\t\t\tauto iter2 = L.begin();\n\t\t\tauto iter1 = L.upper_bound(len_max - *iter2);\n\t\t\tif (iter1 == L.end()) {\n\t\t\t\tfunc_ok = false;\n\t\t\t\t//return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (iter1 == iter2) {\n\t\t\t\t++iter1;\n\t\t\t}\n\t\t\tL.erase(iter1);\n\t\t\tL.erase(iter2);\n\t\t}\n\t}\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.begin();\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,-1));\n        if(ip==S.begin()){\n            break;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                break;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n   while(S.size()>1){\n    auto ip=S.end();--ip;\n    --ok;\n    S.erase(ip);\n   }\n   dp[n]=(*S.begin()).first+1;\n   if(n!=1 && dp[n]>=mid || (n==1 && dp[n]>mid)){\n    dp[n]=1;--ok;\n   }\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    ++ans;\n    while(high-low>1){\n       ok=ans;\n        int mid=(high+low)/2;\n\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int mid)\n{\n\tvector<int>son;\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, mid))return false;\n\t\t//if(dp[to] != -1)\n\t\tson.push_back(dp[to] + 1);\n\t}\n\tif (son.size() == 0)\n\t{\n\t\tdp[x] = 0;\n\t\treturn true;\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > mid)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = 0;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\tint flag = 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tflag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > mid)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)return false;\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\t\n\tif(u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size(); i + 1 < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j - 1 == mid) j--;\n\t\t\t\tif(i + 1 < j && u[i++] + u[--j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nint top,s[N];\nbool dfs(int u,int p,int m)\n{\n    sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        if(!dfs(v,u,m)) return false;\n    }\n    top=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        s[++top]=sum[v]+1;\n    }\n    if(u==1)\n    {\n        if(top&1) s[++top]=0;\n        sort(s+1,s+1+top);\n        for(int i=1,j=top;i<j;i++,j--)\n            if(s[i]+s[j]>m) return false;\n        return true;\n    }\n    if(top%2==0) s[++top]=0;\n    sort(s+1,s+1+top);\n    int l=1,r=top,ans=-1;\n    while(l<=r)\n    {\n        int mid=l+r>>1;\n        bool flag=true;\n        for(int i=1,j=top;i<j;i++,j--)\n        {\n            if(i==mid) i++;\n            if(j==mid) j--;\n            if(i>j) break;\n            if(s[i]+s[j]>m) {flag=false;break;}\n        }\n        if(flag) ans=s[mid],r=mid-1;\n        else l=mid+1;\n    }\n    if(ans==-1) return false;\n    sum[u]=ans;\n    return true;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=1,r=n,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        if(dfs(1,0,m)) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100100;\n\nint n,A,B,mid,dp[maxn];\nvector<int> g[maxn];\n\nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            if (dp[v]!=-1) temp.push_back(dp[v]);\n        }\n    }\n    sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n  //  cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=-1,rr=temp.size();\n        while (ll+1<rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n           // cout<<x<<endl;\n            while (p1<p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > mid) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                rr = x;\n            }\n            else ll = x;\n        }\n       // cout<<rr<<endl;\n        if (rr==temp.size()) return false;\n        dp[u] = temp[rr] + 1;\n        return true;\n    }\n    else {\n        for (int i=0;i<temp.size();i++)\n            if (temp[i] + temp[temp.size()-i-1] + 2 > mid) return false;\n        dp[u]=-1;\n        return true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n  //  freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=0,r=n;\n    while (l<=r) {\n        mid = (l+r)/2;\n        if (visit(1,-1)) {\n            B = mid;\n            r = mid-1;\n        } else l = mid+1;\n    }\n    cout<<B;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    f[x] = g[ans] + 1;\n    return 1;\n}\nint root = 0;\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(root, 0)) return 0;\n    return f[root] <= m + 1;\n}\nint main() {\n    freopen(\"05.in\", \"r\", stdin);\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    for (int i = 1; i <= n; i++)\n        if (d[i] == 1) {\n            root = i;\n            break;\n        }\n    std::cout << (m >>= 1) << ' ';\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n\nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0)data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if(v == pa) continue;\n\t\tif(! kt) return;\n\t\tchild++, dfs(v, u, lim);\n\t\tif(h[v] + 1 > lim) { kt = false; return; }\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t\tif(u == 1 && h[u] > lim) { kt = false; return; }\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++; dem /= 2;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem  << ' ' << ans;\n}\n/*\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x, bool deg) {\n        if (deg) assert(tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x, false)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x, false)) {\n                                        res = false;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x, false)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x, false)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x, true)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int L=1e5+10;\nvector<int> es[L];\nint m;\nint f(int r,int p) {\n\tvector<int> len;\n\tfor(int i:es[r]){\n\t\tif(i==p)continue;\n\t\tint v=f(i,r);\n\t\tif(v>m){\n\t\t\treturn m+1;\n\t\t}\n\t\tlen.push_back(v);\n\t}\n\tif(len.size()%2==0){\n\t\tlen.push_back(0);\n\t}\n\tsort(len.begin(),len.end());\n\tint low=-1;\n\tint hi=len.size();\n\twhile(low+1<hi){\n\t\tint c=(low+hi)/2;\n\t\tint h=0;\n\t\tint t=len.size()-1;\n\t\tif(h==c)h++;\n\t\tif(t==c)t--;\n\t\tbool ok=true;\n\t\twhile(h<t){\n\t\t\tif(len[h]+len[t]>m){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th++;\n\t\t\tt--;\n\t\t\tif(h==c)h++;\n\t\t\tif(t==c)t--;\n\t\t}\n\t\tif(ok){\n\t\t\thi=c;\n\t\t}\n\t\telse{\n\t\t\tlow=c;\n\t\t}\n\t}\n\tif(hi<len.size()){\n\t\t//cerr << m << \", \" << r << \", \" << p << \", \" << len[hi]+1 << endl;\n\t\treturn len[hi]+1;\n\t}\n\treturn m+1;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfor(int i=0;i<N-1;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tes[a].push_back(b);\n\t\tes[b].push_back(a);\n\t}\n\tint c=0;\n\tint s=0;\n\tfor(int i=1;i<=N;i++){\n\t\tc+=es[i].size()%2;\n\t\tif(es[i].size()==1){\n\t\t\ts=i;\n\t\t}\n\t}\n\n\tint low=0,hi=N-1;\n\twhile(low+1<hi){\n\t\tm=(low+hi)/2;\n\t\t//cerr << low << \", \" << hi << \", \" << m << \": \" << f(s,0) << endl;\n\t\tif(f(es[s][0],s)<=m){\n\t\t\thi=m;\n\t\t}\n\t\telse{\n\t\t\tlow=m;\n\t\t}\n\t}\n\tcout << c/2 << \" \" << hi << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint a[N],pre[N],nex[N],vis[N];\nint A,B;\n\ninline void rem(int x){\n\tvis[x]=1;\n\tint l=pre[x],r=nex[x];\n\tpre[r]=l;nex[l]=r;\n}\ninline int solve(int n){\n\tint tag=0;\n\tfor(int i=0;i<n;i++)\n\t\tnex[i]=i+1,pre[i+1]=i;\n\tfor(int i=0;i<=n;i++) vis[i]=0;\n\tfor(int i=n;i;i--){\n\t\tif(vis[i]) continue;\n\t\twhile(nex[tag]&&a[nex[tag]]+a[i]+1<=B) tag=nex[tag];\n\t\tif(tag==i) tag=pre[tag];\n\t\tif(!tag) return a[i];\n\t\trem(i);rem(tag);\n\t\ttag=pre[tag];\n\t}\n}\n\ninline int dfs(int x,int F=0){\n\tint isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tif(!isok) return 1;\n\tsort(all(v));\n\tint ret=0;\n\tfor(int l=0,r=SZ(v)-1;l<r;r--)\n\t\tif(v[l]+v[r]+1<=B) l++,ret++;\n\tif(ret*2==SZ(v)){res+=ret;return 1;}\n\tres+=SZ(v)-ret-1;\n\tfor(int i=0;i<=ret*2;i++)\n\t\ta[i+1]=v[i];\n\tint p=solve(ret*2+1);\n\tif(p+1==B){res++;return 1;}\n\treturn p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root, int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to, root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size();\n\tmultiset<int> mt;\n\trep(i, len)mt.insert(v[i]);\n\twhile(len>=2) {\n\t\tcnt++;\n\t\tauto itr = mt.end(); itr--;\n\t\tint z = *itr; mt.erase(mt.find(z)); len--;\n\t\tint r = c - z;\n\t\tif (mt.count(r)) {\n\t\t\tmt.erase(mt.find(r)); len--;\n\t\t}\n\t\telse {\n\t\t\tmt.insert(r);\n\t\t\tauto itr2 = mt.find(r);\n\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\tmt.erase(itr2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titr2--;\n\t\t\tint zz = *itr2;\n\t\t\tmt.erase(itr2); len--;\n\t\t}\n\t}\n\tint z = 0;\n\tif (len == 1) {\n\t\tz = *mt.begin();\n\t}\n\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa << \" \" << ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint B, r;\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j, t = 0;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--) {\n\t\tif (v[i] + v[j] <= B) r++, i++;\n\t\telse {\n\t\t\tif (t) r++;\n\t\t\tt = v[j];\n\t\t}\n\t}\n\tif (i == j) {\n\t\tif (t) r++;\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\tassert(i >= 0);\n\t\treturn v[i];\n\t}\n\treturn t;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, t, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\ttr = 1;\n\tfor (i = 1; i <= n; i++) tr += (g[i].size() - 1) / 2;\n\tB = n;\n\tt = f(1, 1);\n\tif (t) r++;\n\tassert(r == tr);\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tt = f(1, 1);\n\t\tif (t) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box%2)M++;\n\treturn 1;\n}\n\nint even(multiset<int>ms, int lim) {\n\tint box = MOD, ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tif (a > lim) {\n\t\t\tK = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (it == ms.begin()) {\n\t\t\tif (box != MOD && ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse if (box != MOD) {\n\t\t\t\tret = a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbox = a;\n\t\t\t}\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tret %= MOD;\n\tif (ms.size())return *ms.begin();\n\treturn ret;\n}\n\nbool even_zero(multiset<int>ms, int lim) {\n\twhile (ms.size()) {\n\t\tif (*ms.begin() + *prev(ms.end()) > lim)return false;\n\t\tms.erase(ms.begin());\n\t\tms.erase(prev(ms.end()));\n\t}\n\treturn true;\n}\n\nint odd(multiset<int>ms, int lim) {\n\tint ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (a > lim) {\n\t\t\tK = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tif (it == ms.begin()) {\n\t\t\tif (ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = a;\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tif(ms.size())return *ms.begin();\n\treturn ret;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i, lim) + 1);\n\t}\n\t//cout << \"node \" << node << endl;\n\t//for (auto i : num[node]) {\n\t//\tcout << i << \" \";\n\t//}\n\t//cout << endl;\n\tif (num[node].empty()) {\n\t\treturn 0;\n\t}\n\tif (!node&&num[node].size() % 2 == 0) {\n\t\tif (even_zero(num[node], lim)) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tK = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (num[node].size() % 2 == 1) {\n\t\treturn odd(num[node], lim);\n\t}\n\telse {\n\t//\tassert(0);\n\t\treturn even(num[node], lim);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tauto box = Search(edge, dis, num, 0, mid);\n\t\tif (box > mid)K = 0;\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=100005;\nvi v[N];\nint root=-1,dp[N],n;\nvoid dfs(int u,int val,int par=-1)\n{\n  dp[u]=0;\n  vi tmp;\n  for(int v1:v[u])\n    {\n      if(v1==par) continue;\n      dfs(v1,val,u);\n      tmp.pb(v1);\n    }\n  if(sz(tmp)%2==0) tmp.pb(0);\n  sort(all(tmp),[](int i,int j){return dp[i]<dp[j];});\n  int low=0,high=sz(tmp)-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      int i=0,j=sz(tmp)-1;\n      bool ok=true;\n      while(i<j)\n\t{\n\t  if(i==mid) i++;\n\t  else if(j==mid) j--;\n\t  else if(dp[tmp[i]]+dp[tmp[j]]>val) { ok=false; break; }\n\t  else i++,j--;\n\t}\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  dp[u]=dp[tmp[low]]+1;\n}\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  int x,y;\n  cin>>n;\n  rep(i,1,n) cin>>x>>y,v[x].pb(y),v[y].pb(x);\n  rep(i,1,n+1) if(sz(v[i])==1) root=i;\n  assert(root!=-1);\n  root=1;\n  int cnt=0;\n  rep(i,1,n+1) cnt+=(sz(v[i])&1);\n  int low=0,high=n-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      dfs(root,mid);\n      bool ok=true;\n      rep(i,1,n+1) ok&=(dp[i]<=mid+1);\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  cout<<cnt/2<<\" \"<<low<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nint n;\nvector <int> E[200020];\nint d[200020];\n\nint good(vector <int> h, int mxl) {\n\trep(i, szz(h)/2) if(h[i] + h[szz(h)-1-i] > mxl) return 0;\n\treturn 1;\n}\n\nint dfs(int x, int fa, int mxl) {\n\tif(szz(E[x]) - (fa != -1) == 0) { d[x] = 0; return 1; }\n\tvector <int> L;\n\tfor(int e : E[x]) if(e != fa) {\n\t\tif(!dfs(e, x, mxl)) return 0;\n\t\tL.pb(d[e]);\n\t}\n\tsort(all(L));\n\tif(szz(L) % 2 == 0) {\n\t\tif(good(L, mxl - 2)) { d[x] = 0; return 1; }\n\t\tif(fa == -1) { return 0; }\n\t\tint low = 0, high = szz(L) - 1, res = -1;\n\t\twhile(low <= high) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tvector <int> nh;\n\t\t\trep(i, szz(L)) if(i != mid) nh.pb(L[i]);\n\t\t\tint ok = 1;\n\t\t\tif(nh.back() + 1 > mxl) ok = 0;\n\t\t\tnh.pop_back();\n\t\t\tif(good(nh, mxl - 2) == 0) ok = 0;\n\t\t\tif(ok) res = mid, high = mid - 1;\n\t\t\telse low = mid + 1;\n\t\t}\n\t\tif(res == -1 || L[res] + 1 > mxl) return 0;\n\t\td[x] = L[res] + 1;\n\t\treturn 1;\n\t}\n\telse {\n\t\tint low = 0, high = szz(L) - 1, res = -1;\n\t\twhile(low <= high) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tvector <int> nh;\n\t\t\trep(i, szz(L)) if(i != mid) nh.pb(L[i]);\n\t\t\tint ok = 1;\n\t\t\tif(good(nh, mxl - 2) == 0) ok = 0;\n\t\t\tif(ok) res = mid, high = mid - 1;\n\t\t\telse low = mid + 1;\n\t\t}\n\t\tif(res == -1 || L[res] + 1 > mxl) return 0;\n\t\td[x] = L[res] + 1;\n\t\treturn 1;\n\t}\n}\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\trep(i, n-1) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\t\n\tint odd = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(szz(E[i]) & 1) ++odd;\n\t}\n\t\n\tprintf(\"%d \", odd / 2);\n\tint low = 1, high = n-1, res = -1;\n\twhile(low <= high) {\n\t\tint mid = (low + high) >> 1;\n\t\tif(dfs(1, -1, mid)) res = mid, high = mid - 1;\n\t\telse low = mid + 1;\n\t}\n\tprintf(\"%d\\n\", res);\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tson.erase(son.begin()+r);\n\tfor (int i=0;i<son.size()/2;i++)\n\t{\n\t\tint j = son.size() - 1 - i;\n\t\tif (son[i] + son[j] > B) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size == 0)\n\t{\n\t\tdp[u] = 1;\n\t}\n\telse if (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n-1; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X;\nvector<vector<int> > adj;\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n    }\n\n    if((p == -1) ^ (st.size() % 2)) {\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return -1;\n            it2--;\n            st.erase(it2);\n        }\n        return *st.begin();\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int a = 0;\n    for(int i = 0; i < N; i++) {\n        a += (adj[i].size() + 1) / 2 - 1;\n    }\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", 1 + a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nvector<int> vec;\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tvec.clear();\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tvec.push_back(res[G[v][i]].second);\n\t\t}\n\t}\n\tif(vec.size()==0)return res[v]=P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=(int)vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tprintf(\"%d\\n\",n);\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 100010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\t/*\tif(u == 2){\n\t\t\tcout << \"WHAT \" << endl;\n\t\t\tfor (int i = 0; i < extra.size(); ++i){\n\t\t\t\tcout << extra[i].second << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << \"F\" << endl;\n\t\t}*/\n\twhile (nt-- && extra.size()) {\n\t\textra.pop_back();\n\t}\n\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 1 , hi = 200000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tans1 = all;\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls,cls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tif(tmp>L) return -1;\n\t\tls.insert(tmp);\n\t}\n\tcls = ls;\n\tint K = ls.size();\n\tbool can = 1;\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\tcan = 0;\n\t\t\tbreak;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(can){\n\t\tif(ls.size()==0) return 1;\n\t\telse return *ls.begin() + 1;\n\t}\n\tif(K%2==1) return -1;\n\n\tls = cls;\n\tauto it = ls.end();\n\tit--;\n\tls.erase(it);\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\treturn -1;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\treturn *ls.begin() + 1;\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=0;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += deg%2;\n\t}\n\tA/=2;\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int ok = N, ng = 0;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,res[N],A,B,l,r,mid;\nvector<int> e[N];\nbool ok;\nint rest(vector<int> &L){\n\tif (!(L.size()&1)) L.push_back(0);\n\tsort(L.begin(),L.end());\n\tfor (int l=0,r=L.size()-2;l<r;l++,r--)\n\tif (L[l]+L[r]>mid) ok=0;\n\tint p=L.size()-1,len=p;\n\twhile (p&&L[p]+L[len-p+(len-p>=p)]<=mid) p--;\n\treturn L[p];\n}\nvoid solve(int x,int fa){\n\tvector<int> L;\n\tfor (auto v:e[x])\n\tif (v!=fa) solve(v,x),L.push_back(res[v]+1);\n\tif (fa) res[x]=rest(L);\n\telse{\n\t\tif (L.size()&1) L.push_back(0);\n\t\tsort(L.begin(),L.end());\n\t\tfor (int l=0,r=L.size();l<r;l++,r--)\n\t\tif (L[l]+L[r]>mid) ok=0;\n\t}\n}\nbool check(){\n\tok=1;\n\tsolve(1,0);\n\treturn ok&&res[1]<=mid;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tA=n-1;\n\tfor (int i=1;i<=n;i++) A-=e[i].size()/2;\n\tfor (l=0,r=n-1;l<r;){\n\t\tmid=(l+r)>>1;\n\t\tif (check()) r=mid;else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nll f[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        st.insert(sum[v]+1);\n    }\n    while(st.size())\n    {\n        int x=*st.rbegin();\n        st.erase(st.find(x));\n        if(st.size()==0)\n        {\n            if(x+1<=m) sum[u]=x;\n            else f[u]++;\n            break;\n        }\n        it=st.upper_bound(m-x);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;st.erase(st.find(*it));\n        }\n    }\n    if(u==1&&sum[u]) f[u]++;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=1,r=n,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        bool flag=false;\n        for(int i=1;i<=3;i++)\n        {\n            int x=rand()%n+1;\n            dfs(x,0,m);\n            if(f[x]<=dp[1])\n            {\n                flag=true;break;\n            }\n        }\n        if(flag) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>pat[101000];\nvector<int>ko[101000];\nbool flag[101000];\nint deg[101000];\nvoid dfs(int node)\n{\n\tflag[node] = true;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]])\n\t\t{\n\t\t\tdfs(pat[node][i]);\n\t\t\tko[node].push_back(pat[node][i]);\n\t\t}\n\t}\n}\nint calc(int node, int med)\n{\n\tvector<int>vec;\n\tfor (int i = 0; i < ko[node].size(); i++)vec.push_back(calc(ko[node][i], med));\n\tsort(vec.begin(), vec.end());\n\tif (vec.size() % 2 == 0)\n\t{\n\t\tbool f = true;\n\t\tfor (int i = 0; i < vec.size() / 2; i++)if (vec[i] + vec[vec.size() - 1 - i]>med)f = false;\n\t\tif (f)return 1;\n\t\tif (vec[vec.size() - 1]>med)return 10000000;\n\t\tvec.pop_back();\n\t\tint b = 0, e = vec.size();\n\t\tfor (;;)\n\t\t{\n\t\t\tif (b == e)break;\n\t\t\tint m = (b + e) / 2;\n\t\t\tvector<int>z;\n\t\t\tfor (int i = 0; i < vec.size(); i++)if (m != i)z.push_back(vec[i]);\n\t\t\tbool g = true;\n\t\t\tfor (int i = 0; i < z.size() / 2; i++)if (z[i] + z[z.size() - 1 - i]>med)g = false;\n\t\t\tif (g)e = m;\n\t\t\telse b = m + 1;\n\t\t}\n\t\tif (b == vec.size())return 10000000;\n\t\telse return vec[b] + 1;\n\t}\n\telse\n\t{\n\t\tint b = 0, e = vec.size();\n\t\tfor (;;)\n\t\t{\n\t\t\tif (b == e)break;\n\t\t\tint m = (b + e) / 2;\n\t\t\tvector<int>z;\n\t\t\tfor (int i = 0; i < vec.size(); i++)if (m != i)z.push_back(vec[i]);\n\t\t\tbool g = true;\n\t\t\tfor (int i = 0; i < z.size() / 2; i++)if (z[i] + z[z.size() - 1 - i]>med)g = false;\n\t\t\tif (g)e = m;\n\t\t\telse b = m + 1;\n\t\t}\n\t\tif (b == vec.size())return 10000000;\n\t\telse return vec[b] + 1;\n\t}\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)pat[i].clear(), ko[i].clear(), flag[i] = false, deg[i] = 0;\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t\tdeg[za]++, deg[zb]++;\n\t}\n\tint root;\n\tfor (int i = 0; i < num; i++)if (deg[i] == 1)root = i;\n\tdfs(root);\n\tint beg = 1, end = num - 1;\n\tfor (;;)\n\t{\n\t\tif (beg == end)break;\n\t\tint med = (beg + end) / 2;\n\t\tif (calc(root, med) <= med + 1)end = med;\n\t\telse beg = med + 1;\n\t}\n\tint r = 0;\n\tfor (int i = 0; i < num; i++)r += deg[i] % 2;\n\tprintf(\"%d %d\\n\", r / 2, beg);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst int INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> e[100000];\nint ansa = 1;\n\nbool checker(vector<int> vec, int mid, int x) {\n    int i = 0, j = vec.size()-1;\n    bool ok = true;\n    rep(_,vec.size()/2) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (vec[i]+vec[j] > x) {\n            ok = false;\n            break;\n        }\n        i++; j--;\n    }\n    return ok;\n}\n\nint dfs(int v, int par, int x) {\n    vector<int> vec;\n    rep(i,e[v].size()) {\n        if (e[v][i] == par) continue;\n        int z = dfs(e[v][i], v, x);\n        if (z == INF) {\n            return INF;\n        }\n        vec.push_back(z);\n    }\n    if (vec.size() == 0) {\n        return 1;\n    }\n    if (vec.size() == 1) {\n        return vec[0]+1;\n    }\n    sort(vec.begin(), vec.end());\n    if (vec.size()%2 == 0) {\n        bool ok = true;\n        rep(i,vec.size()/2) {\n            if (vec[i]+vec[vec.size()-1-i] > x) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return 1;\n        }\n        if (vec[vec.size()-1] > x) return INF;\n        vec.pop_back();\n    }\n    int st = 0, en = vec.size(), mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (checker(vec, mid, x)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    if (!checker(vec, st, x)) {\n        return INF;\n    }\n    return vec[st]+1;\n}\n\nbool solve(int x) {\n    int z = dfs(0, 0, x);\n    if (z-1 > x) return false;\n    return true;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n    rep(i,n) {\n        if (e[i].size() > 2) {\n            ansa += (e[i].size()-2+1)/2;\n        }\n    }\n    int st = 1, en = n, mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (solve(mid)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    cout << ansa << \" \" << en << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    vector<int> tmp;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n        tmp.push_back(t + 1);\n    }\n    \n    sort(tmp.begin(), tmp.end());\n\n    if((p == -1) ^ (st.size() % 2)) {\n        if(p != -1) {\n            for(int i = 0; i < (int)tmp.size() - 1; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n            }\n        }\n        else {\n            for(int i = 0; i < (int)tmp.size(); i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 1 - i ] > X) return -1;\n            }\n        }\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return v;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nconst int MAXN = 1e5 + 10;\n\nstruct Edge {\n  int v, next;\n}edge[MAXN << 1];\nint head[MAXN], tail, n, deg[MAXN];\nvoid insert(int u, int v) {\n  edge[++tail] = (Edge) {v, head[u]}; head[u] = tail;\n}\nnamespace solver1 {\n  int f[MAXN];\n  int bound, root;\n  bool dfs(int u, int fa) {\n    std::vector <int> dps;\n    for (int i = head[u]; i; i = edge[i].next) {\n      int v = edge[i].v;\n      if (v == fa) continue;\n      if (!dfs(v, u)) return 0;\n      if (f[v] > bound) return 0;\n      dps.push_back(f[v]);\n    }\n    if (deg[u] & 1) dps.push_back(0);\n    std::sort(dps.begin(), dps.end());\n    int l = 0, r = dps.size() - 1;\n    while(l <= r) {\n      int mid = (l + r) >> 1;\n      bool flag = 1;\n      for (int i = 0, j = dps.size() - 1; i < j; i++, j--) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (dps[i] + dps[j] > bound) {flag = 0; break;}\n      } \n      if (flag) {\n        f[u] = dps[mid];\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    f[u]++;\n    return f[u];\n  }\n  bool check() {\n    memset(f, -1, sizeof f);\n    return dfs(root, 0) \n      && f[root] <= bound + 1;\n  }\n  void main() {\n    int ans1 = 0;\n    for (int i = 1; i <= n; i++) { \n      if (deg[i] & 1) ans1++, root = i; \n    }\n    ans1 /= 2;\n    printf(\"%d \", ans1);\n    int l = 1, r = n, ans2 = 0;\n    deg[root]++;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      bound = mid;\n      if (check()) {\n        ans2 = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans2);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    insert(a, b);\n    insert(b, a);\n    deg[a]++; deg[b]++;\n  }\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u) + 1);\n    if(vals.size() == 0) return 0;\n    if(vals.size()%2 == 0) {\n        if( u == 0 ){\n            sort(vals.begin(), vals.end());\n            for(int i = 0, j = vals.size()-1; i < j; i++, j--) if(vals[i] + vals[j] > B) return B+1;\n            return 0;\n        }\n        vals.pb(0);\n    }\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size()-1;\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    //cout << \"leastUp \" << u << \": \" << vals[rb]+1 << endl;\n    return vals[rb];\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    return l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[100001];\nvector<int> tree[100001];\nvector<int> l[100001];\nint p[100001];\nint bye[100001];\n\nint ans1 = 0;\nint lim = 0;\n\nvoid dfs1(int x){\n    int cntt = 0;\n    for(auto &nxt: g[x]){\n        if(nxt == p[x]) continue;\n        tree[x].push_back(nxt);\n        p[nxt] = x;\n        dfs1(nxt);\n        cntt++;\n    }\n    ans1 += (cntt / 2);\n    if(x == 1 && (cntt % 2) == 1) ans1++;\n}\n\nbool dfs2(int x){\n    l[x].clear();\n    for(auto &nxt: tree[x]){\n        if(!dfs2(nxt)) return false;\n        //printf(\"bye %d -> %d: %d\\n\", nxt, x, bye[nxt]);\n        l[x].push_back(bye[nxt]+1);\n    }\n    int m = (int)l[x].size();\n    if(x == 1){\n        sort(l[x].begin(), l[x].end());\n        for(auto &val: l[x]){\n            if(val > lim) return false;\n        }\n        if(m%2 == 0){\n            for(int i=0;i<m;i++){\n                if(l[x][i] + l[x][m-1-i] > lim) return false;\n            }\n        }else{\n            for(int i=0;i<m-1;i++){\n                if(l[x][i] + l[x][m-2-i] > lim) return false;\n            }\n        }\n        return true;\n    }\n    if(m%2 == 0){\n        l[x].push_back(0);\n        m++;\n    }\n    sort(l[x].begin(), l[x].end());\n    for(auto &val: l[x]){\n        if(val > lim) return false;\n    }\n    bye[x] = 0;\n    int ss = 0, ee = m-1, ans = m;\n    while(ss <= ee){\n        int mid = (ss + ee) / 2;\n        int s = 0, e = m-1;\n        bool can = true;\n        while(s < e){\n            if(s == mid) s++;\n            if(e == mid) e--;\n            if(s >= e) break;\n            if(l[x][s] + l[x][e] > lim){\n                can = false;\n                break;\n            }else{\n                s++; e--;\n            }\n        }\n        if(can){\n            ans = mid;\n            ee = mid - 1;\n        }else{\n            ss = mid + 1;\n        }\n    }\n    if(ans == m) return false;\n    bye[x] = l[x][ans];\n    return true;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<n;i++){\n        int aa, bb;\n        scanf(\"%d%d\", &aa, &bb);\n        g[aa].push_back(bb);\n        g[bb].push_back(aa);\n    }\n    p[1] = 1;\n    dfs1(1);\n    int ss = 0, ee = n+1, ans2 = n+1;\n    while(ss <= ee){\n        lim = (ss + ee) / 2;\n        //printf(\"%d\\n\", lim);\n        if(dfs2(1)){\n            ans2 = lim;\n            ee = lim - 1;\n        }else{\n            ss = lim + 1;\n        }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint B, r;\nint a[100001];\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\treturn v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\tB = n;\n\tif (f(1, 1)) r++;\n\ttr = r;\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tif (f(1, 1)) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <climits>\n#include <bitset>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0;\n    char ch = Advance();\n    while (!isdigit(ch))\n        ch = Advance();\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer;\n}\n\nconst int MAXN = 100000;\n\nvector<int> g[1 + MAXN];\nint limit, splits[1 + MAXN];\n\nint DFS(int node, int father) {\n    multiset<int> sons;\n    for (auto &son : g[node])\n        if (son != father) {\n            sons.insert(DFS(son, node));\n            if (sons.find(-1) != sons.end())\n                return -1;\n        }\n    if (sons.empty())\n        return 1;\n    if (sons.size() == 1)\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    int n = sons.size();\n    if (sons.size() % 2) {\n        for (int i = 1; 2 * i <= n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n    else {\n        for (int i = 1; 2 * i < n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() + *sons.rbegin() + 1 <= limit)\n            return 1;\n        if (node == 1)\n            return 0;\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n}\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int first = 1, left = 2, right = n, second = n;\n    for (int i = 3; i <= n; i++)\n        splits[i] = splits[i / 2] + splits[i - i / 2] + 1;\n    for (int i = 1; i <= n; i++)\n        first += splits[g[i].size()];\n    while (left <= right) {\n        limit = (left + right) / 2;\n        if (DFS(1, 0) != -1) {\n            second = limit;\n            right = limit - 1;\n        }\n        else\n            left = limit + 1;\n    }\n    second--;\n    printf(\"%d %d\\n\", first, second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint K;\nbool dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    multiset<int> st;\n    if (s != 0) {\n        st.insert(0);\n    }\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        const bool f = dp_dfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        st.insert(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = st.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        st.insert(0);\n    }\n\n    int mini = 10000;\n    while (not st.empty()) {\n        auto it = st.end();\n        it--;\n        const int v = *it;\n        st.erase(it);\n        auto upp = st.upper_bound(K - v - 1);\n        if (upp == st.begin()) {\n            return false;\n        }\n        upp--;\n        if (*upp == 0 or v == 0) {\n            mini = min(mini, *upp + v + 1);\n        }\n        st.erase(upp);\n    }\n    dp[s] = {sum, mini};\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    int inf = -1;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        if (dp_dfs(g, 0, dp)) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    dp_dfs(g, 0, dp);\n    show(dp);\n    cout << dp[0].first + 1 << \" \" << sup - 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n       \n        }\n            \n    dp[n]=X[ind].first+1;\n   \n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n   \n   \n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n   \n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define si scanf\n#define so printf\n#define N 200100\n#define M \n#define INF  \n#define nxt t[j]\ntemplate<typename TP>inline bool rd(TP& r)\n{\n\tr=0;\n\tchar tmp=getchar();\n\twhile(tmp<'0'||tmp>'9')\n\t{\n\t\tif(tmp==EOF)\n\t\t\treturn 0;\n\t\ttmp=getchar();\n\t}\n\twhile('0'<=tmp&&tmp<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+tmp-'0';\n\t\ttmp=getchar();\n\t}\n\treturn 1;\n\t\n} \nint n; \nint h[N],x[N*2],t[N*2],tot=1;\nint du[N],A;\nvoid add(int u,int v)\n{\n\t++tot;\n\tx[tot]=h[u];\n\th[u]=tot;\n\tt[tot]=v;\n\t++du[u];\n}\nint ln[N],l2[N];\nint f[N];\nbool ok(int mid,int u)\n{\n\tfor(int i=1;i<=ln[0];++i)\n\t\tif(i==mid)\n\t\t\tl2[i]=n+100;\n\t\telse\n\t\t\tl2[i]=ln[i];\n\tsort(l2+1,l2+ln[0]+1);\n\tfor(int i=1;i<ln[0];++i)\n\t\tif(l2[i]+l2[ln[0]-i]+1>u)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dp(int u)\n{\n\tsort(ln+1,ln+ln[0]+1);\n\tfor(int i=1;i<=ln[0]-1;++i)\n\t\tif(ln[i]+ln[ln[0]-i]+1>u)//无法配对 \n\t\t\treturn n+100;\n\tint l=1,r=ln[0],mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(ok(mid,u))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\treturn ln[l]+1;\n}\nbool dfs(int now,int u,int fa)\n{\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tif(dfs(nxt,u,now)==0)\n\t\t\t\treturn 0;\n\tln[0]=0;\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tln[++ln[0]]=f[nxt];\n\tif(du[now]&1)\n\t\tln[++ln[0]]=0;\n\tf[now]=dp(u);\n\tif(f[now]>u)\n\t\treturn 0; \n\treturn 1;\n}\nint main()\n{\n\trd(n);\n\tint u,v;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\trd(u),rd(v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(du[i]&1)\n\t\t\t++A;\n\tA>>=1;\n\tint l=1,r=n,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\t//memset(f,0x3f,sizeof(f));\n\t\tif(dfs(1,mid,0))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tso(\"%d %d\\n\",A,l-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nint N;\nvector<int> paths[100500];\nint A, B;\n\nint dfs(int border, int now, int from) {\n    multiset<int> st;\n    for(auto to : paths[now]) {\n        if(to == from) continue;\n        int tmp = dfs(border, to, now);\n        if(tmp == -1) return -1;\n        st.insert(tmp + 1);\n    }\n    if(paths[now].size() % 2 == 1) st.insert(0);\n    int ansval = -1;\n    /*\n    cerr << \"--\" << now << \"--\" << endl;\n    for(auto val: st) cerr << val << \" \";\n    cerr << endl;\n    */\n    auto itr = st.end();\n    while(true) {\n        if(itr == st.begin()) break;\n        itr--;\n        int val = *itr;\n        itr = st.erase(itr);\n        auto itr2 = st.upper_bound(border - val);\n        if(itr2 == st.begin()) {\n            if(ansval != -1) {\n                //cerr << \"NG: \" << now << endl;;\n                return -1;\n            }\n            else {\n                ansval = val;\n                continue;\n            }\n        }\n        itr2--;\n        if(itr == itr2) {\n            if(itr == st.end()) itr--;\n            else itr++;\n        }\n        itr2 = st.erase(itr2);\n    }\n    //cerr << ansval << endl;\n    if(now == 0) return 0;\n    else return ansval;\n}\n\nbool f(int border) {\n    //cerr << \"-----\" << border << \"--------\" << endl;\n    int ret = dfs(border, 0, -1);\n    if(ret == 0) return true;\n    else return false;\n}\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 1; i <= N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        paths[a].push_back(b);\n        paths[b].push_back(a);\n    }\n    A = 1;\n    for(int i = 0; i < N; i++) {\n        A += (paths[i].size() - 1) / 2;\n    }\n    int ok = 1e6;\n    int ng = 0;\n    while(ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        if(f(mid)) ok = mid;\n        else ng = mid;\n    }\n    B = ok;\n    cout << A << \" \" << B << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nint dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN];\nbool dfs(int u,int la)\n{\n\tstd::vector<int> fv;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfv.push_back(f[v]);\n\t}\n\tint k=fv.size();\n\tif(!k) {f[u]=1;return true;}\n\tif((k&1)&&la) fv.push_back(0),k++;\n\tstd::sort(fv.begin(),fv.end());\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tfor(int p1=1,p2=k;p1<p2;p1++,p2--)\n\t\t{\n\t\t\tif(p1==mid) p1++;if(p2==mid) p2--;\n\t\t\tif(fv[p1-1]+fv[p2-1]>B) {l=mid+1;continue;}\n\t\t}\n\t\tr=mid-1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fv[l-1]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(1,0)) return false;\n\tif(f[1]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring> \n#include<cstdio>\n#include<set>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nmultiset<int> s[MN+5];\nint n,f[MN+5],head[MN+5],cnt,ans,flag,mid;\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\ts[x].clear();f[x]=0;multiset<int>::iterator it;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa) dfs(e[i].to,x),s[x].insert(f[e[i].to]+1);\n\tint has=0,has2=0,tms=s[x].size()+1>>1,size=s[x].size();if(!size) ++ans;ans-=(size-1)/2;\n\tif(s[x].size()&&(*(--(it=s[x].end())))>mid) return(void)(flag=0);\n\tfor(int j=1;!s[x].empty();++j)\n\t{\n\t\tit=s[x].end();--it;\n\t\tint v=*it;s[x].erase(it);\n\t\tit=s[x].upper_bound(mid-v);\n\t\tif(it==s[x].begin())\n\t\t{\n\t\t\tif(!has) has=v,f[x]=has;\n\t\t\telse if(~size&1)\n\t\t\t{\n\t\t\t\tif(!has2) has2=v,f[x]=has2;\n\t\t\t\telse return(void)(flag=0);\n\t\t\t}\n\t\t}\n\t\telse s[x].erase(--it);\n\t}\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tint l=1,r=n,res,Ans;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;ans=0;flag=1;\n\t\tdfs(1,0);\n\t\t//cout<<\"Solve\"<<mid<<\" ok \"<<flag<<endl;\n\t\tif(flag) res=mid,r=mid-1,Ans=ans;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",Ans,res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint to[N << 1],nex[N << 1],beg[N],deg[N],Ans[N],rest[N],A[N];\nint e,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline void dfs(int x,int fa) {\n\tint cur = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tdfs(to[i],x),cur++;\n\t}\n\tans -= cur / 2,cur &= 1;\n\tif(!cur) ans++;\n}\n\ninline int check(int Ban,int top,int val) {\n\tint pos = top,tot = 0;\n\tFor(i,1,top) {\n\t\tif(i == Ban) continue;\n\t\twhile(pos && (A[i] + A[pos] > val || pos == Ban)) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\treturn tot;\n}\n\ninline void Dp(int x,int fa,int val) {\n\tint total = 0,top = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tDp(to[i],x,val);\n\t}\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\ttotal += Ans[to[i]];\n\t\tA[++top] = rest[to[i]];\n\t}\n\tsort(A + 1,A + top + 1);\n\twhile(top && A[top] >= val) top--;\n\tint pos = top,tot = 0;\n//\tdebug(top);\n\tFor(i,1,top) {\n\t\twhile(A[i] + A[pos] > val) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\tint l = 0,r = top;\n\twhile(l < r) {\n\t\tint mid = (l + r + 1) >> 1;\n//\t\tdebug(mid);\n\t\tif(check(mid,top,val) < tot) r = mid - 1;\n\t\telse l = mid;\n\t}\n//\tdebug(l);\n\trest[x] = A[l] + 1;Ans[x] = total - tot;\n\tif(!l && x > 1) Ans[x]++;\n//\tcout << x << \" \" << Ans[x] << \" \" << total << \" \" << tot << \" \" << rest[x] << endl;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n - 1) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tint l = 0,r = n;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n//\t\tdebug(mid);\n\t\tDp(1,0,mid);\n//\t\tdebug(Ans[1]);\n//\t\tcout << \"------\" << endl;\n\t\tif(Ans[1] > ans) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\tprintf(\"%d %d\\n\",ans,l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005,INF=1<<30;\n\nint A[MAX],C[MAX],cnt[MAX];\nvector<int> G[MAX];\n\nvoid DFS(int u,int p){\n    for(int to:G[u]){\n        if(to==p) continue;\n        DFS(to,u);\n        cnt[u]++;\n        A[u]+=A[to]+(cnt[to]%2==0);\n    }\n    A[u]-=cnt[u]/2;\n}\n\nint lim;\nbool ok;\n\nvoid solve(int u,int p){\n    if(cnt[u]==0) return;\n    \n    vector<int> X;\n    if(cnt[u]%2==0) X.push_back(0);\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        solve(to,u);\n        X.push_back(C[to]+1);\n    }\n    sort(all(X));\n    \n    int M=si(X);\n    \n    int left=-1,right=M;\n    while(right-left>1){\n        int mid=(left+right)/2;\n        int l=0,r=M-1;\n        int ma=-1;\n        while(l<r){\n            if(l==mid) l++;\n            if(r==mid) r--;\n            \n            chmax(ma,X[l]+X[r]);\n            l++;\n            r--;\n        }\n        if(ma<=lim) right=mid;\n        else left=mid;\n    }\n    if(right==M) ok=false;\n    else{\n        C[u]=X[right];\n        if(C[u]>lim) ok=false;\n    }\n    \n    if(u==0&&right) ok=false;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    DFS(0,-1);\n    \n    int left=0,right=N;\n    \n    while(right-left>1){\n        ok=true;\n        lim=(left+right)/2;\n        for(int i=0;i<N;i++) C[i]=0;\n        solve(0,-1);\n        \n        if(ok) right=lim;\n        else left=lim;\n    }\n    \n    cout<<A[0]<<\" \"<<right<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 120000;\nint gfl = 0;\n\nvector<int> eds[MAXN];\nint n;\n\nint dfs1(int v, int x, int p) {\n\tvector<int> vv;\n\tfor (int u: eds[v]) {\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tvv.push_back(dfs1(u, x, v) + 1);\n\t}\n\tsort(vv.begin(), vv.end());\n\tfor (int u: vv)\n\t\tif (u > x) {\n\t\t\tgfl = 1;\n\t\t\treturn 0;\n\t\t}\n\tif (vv.size() % 2 == 0) {\n\t\tint fl = 0;\n\t\tfor (int i = 0; i < vv.size(); ++i)\n\t\t\tif (vv[i] + vv[vv.size() - 1 - i] > x) {\n\t\t\t\tfl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!fl)\n\t\t\treturn 0;\n\t}\n\tif ((p == -1 && vv.size() % 2 == 1) || (p != -1 && vv.size() % 2 == 0)) {\n\t\tif (!vv.empty())\n\t\t\tvv.pop_back();\n\t\telse\n\t\t\tvv.push_back(0);\n\t}\n\tif (p == -1) {\n\t\tfor (int i = 0; i < vv.size(); ++i) {\n\t\t\tif (vv[i] + vv[vv.size() - 1 - i] > x) {\n\t\t\t\tgfl = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\tfor (int i = 0; i < (int)vv.size() - 1; ++i) {\n\t\t\tif (vv[i] + vv[vv.size() - 2 - i] > x) {\n\t\t\t\tgfl = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint cur = vv.size() - 1;\n\t\twhile (cur > 0) {\n\t\t\tint oth = vv.size() - 2 - (cur - 1);\n\t\t\tif (oth >= cur)\n\t\t\t\t++oth;\n\t\t\tif (vv[cur] + vv[oth] > x)\n\t\t\t\tbreak;\n\t\t\t--cur;\n\t\t}\n\t\treturn vv[cur];\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tint l = 0;\n\tint r = n;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) >> 1;\n\t\tgfl = 0;\n\t\tdfs1(0, mid, -1);\n\t\tif (gfl)\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid;\n\t}\n\tint a = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint c = eds[i].size() - 1;\n\t\tif (c)\n\t\t\t--c;\n\t\ta += (c + 1) / 2;\n\t}\n\tint c = eds[0].size();\n\ta += (c + 1) / 2;\n\tcout << a << \" \" << r << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nint32_t F(std::vector<int32_t>& a, int32_t K)\n{\n\tstd::sort(a.begin(),a.end());\n\tint lb = -1, ub = a.size();\n\twhile (ub - lb>1) {\n\t\tint mid = (ub + lb) / 2;\n\n\t\tbool f = true;\n\t\tint l = 0, r = a.size() - 1;\n\t\tfor (int i = 0; i < a.size() / 2;++i) {\n\t\t\tif (l == mid)l++;\n\t\t\tif (r == mid)r--;\n\t\t\tif (a[l] + a[r]>K)f = false;\n\t\t\tl++; r--;\n\t\t}\n\t\tif (f)ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\n\tstd::vector<int32_t> T;\n\tfor (auto& i : L) { T.push_back(i); }\n\tauto R = F(T, len_max);\n\tif(R==T.size()){\n\t\tfunc_ok = false;\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn T[R];\n\t}\n\n\t//while (L.size()>=2) {\n\t//\tauto iter2 = L.begin();\n\t//\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t//\tif (iter1 == L.end()) {\n\t//\t\tfunc_ok = false;\n\t//\t\treturn 0;\n\t//\t}\n\t//\tif (iter1 == iter2) {\n\t//\t\t++iter1;\n\t//\t}\n\t//\tL.erase(iter1);\n\t//\tL.erase(iter2);\n\t//}\n\t//return *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst int INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> e[100000];\nint ansa = 1;\n\nbool checker(vector<int> vec, int mid, int x) {\n    int i = 0, j = vec.size()-1;\n    bool ok = true;\n    rep(_,vec.size()/2) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (vec[i]+vec[j] > x) {\n            ok = false;\n            break;\n        }\n        i++; j--;\n    }\n    return ok;\n}\n\nint dfs(int v, int par, int x) {\n    vector<int> vec;\n    rep(i,e[v].size()) {\n        if (e[v][i] == par) continue;\n        int z = dfs(e[v][i], v, x);\n        if (z == INF) {\n            return INF;\n        }\n        vec.push_back(z);\n    }\n    if (vec.size() == 0) {\n        return 1;\n    }\n    if (vec.size() == 1) {\n        return vec[0]+1;\n    }\n    sort(vec.begin(), vec.end());\n    if (vec.size()%2 == 0) {\n        bool ok = true;\n        rep(i,vec.size()/2) {\n            if (vec[i]+vec[vec.size()-1-i] > x) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return 1;\n        }\n        if (v == 0) return INF;\n        if (vec[vec.size()-1] > x) return INF;\n        vec.pop_back();\n    }\n    int st = -1, en = vec.size(), mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (checker(vec, mid, x)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    if (en == vec.size()) {\n        return INF;\n    }\n    return vec[en]+1;\n}\n\nbool solve(int x) {\n    int z = dfs(0, 0, x);\n    if (z-1 > x) return false;\n    return true;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n    rep(i,n) {\n        if (e[i].size() > 2) {\n            ansa += (e[i].size()-2+1)/2;\n        }\n    }\n    int st = 1, en = n, mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (solve(mid)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    cout << ansa << \" \" << en << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n\nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0)data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res <= len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if(v == pa) continue;\n\t\tif(! kt) return;\n\t\tchild++, dfs(v, u, lim);\n\t\tif(h[v] + 1 > lim) { kt = false; return; }\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++; dem /= 2;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem  << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint root;\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src])%2 == 1) return 0;\n    vi legs;\n    if(sz(adj[src])%2 == 0) for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        int l = 0;\n        int r = sz(legs)-1;\n        while(l<=r){\n            if(legs[l]+legs[r]>mx){\n                ok = false; return legs.back();\n            }\n            l++; r--;\n        }\n        return legs.back();\n    }\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check(legs, lo, mx)) return legs[lo];\n    else if(check(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nvoid getEdge(int src){\n    edges.clear();\n    int u = src;\n    int v = par[0][src];\n    if(sz(adj[u])%2 == 1 && sz(adj[v])%2 == 1) return;\n    if(sz(adj[u])%2 == 0) dfs_vert(u);\n    else dfs_vert(v);\n    set<int> s;\n    int cent;\n    for(auto ee: edges){\n        pi e = mp(ee, par[0][ee]);\n        if(sz(adj[e.f])%2 == 0) cent = e.f;\n        if(sz(adj[e.s])%2 == 0) cent = e.s;\n    }\n    root = cent;\n    int lo = 1;\n    int hi = MAX;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(cent, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(cent, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n}\nint main(){\n//    setIO(\"temp\");\n    setIO(\"\");\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    vi pts;\n    f0r(i, n) if(sz(adj[i])%2 == 1) pts.eb(i);\n    f1r(i, 1, n){\n        if(vis[i]) continue;\n        getEdge(i);\n    }\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\n\nint A, B;\n\nbool flag;\n\nint dfs(int v, int p) {\n    vector<int> vec;\n    for(int u : G[v])\n        if(p != u) {\n            vec.push_back(dfs(u, v) + 1);\n            if(vec.back() > B) return mod;\n        }\n    sort(ALL(vec));\nx:;\n    if(vec.size() & 1) {\n        int ng = -1, ok = vec.size();\n        while(ng + 1 < ok) {\n        y:;\n            int mid = ng + ok >> 1;\n            int i = 0, j = vec.size() - 1;\n            while(i < j) {\n                if(mid == i) i++;\n                if(mid == j) j--;\n                if(vec[i] + vec[j] > B) {\n                    ng = mid;\n                    goto y;\n                }\n                i++;\n                j--;\n            }\n            if(ng != mid) ok = mid;\n        }\n        if(ok == (int)vec.size())\n            return mod;\n        else\n            return vec[ok];\n    } else {\n        bool ok = true;\n        rep(i, vec.size() - i) if(vec[i] + vec[n - i - 1] > B) ok = false;\n        if(ok) return 0;\n        vec.pop_back();\n        goto x;\n    }\n}\n\nbool isok() { return dfs(0, -1) <= B; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    A = 0;\n    rep(i, n) A += G[i].size() % 2;\n\n    A /= 2;\n\n    int ng = 0, ok = n;\n    while(ng < ok - 1) {\n        B = ok + ng >> 1;\n        (isok() ? ok : ng) = B;\n    }\n\n    cout << A << \" \" << ok << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n\n        }\n\n    dp[n]=X[ind].first+1;\n\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        assert(a<=n && b<=n);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n\n\n    int low=0;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri, int& sm)\n{\n    multiset<int> ng;\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri, sm)) return false;\n            ng.insert(dp[v]);\n            vec.pb(dp[v]);\n        }\n    }\n    if(len(vec) % 2){\n        sort(all(vec));\n        sm += len(vec)/2;\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        while(!ng.empty()){\n            if(len(ng) == 1){\n                int val = *ng.begin();\n                if(cri >= val+1){\n                    dp[u] = val + 1;\n                    return true;\n                }else{\n                    dp[u] = 1;\n                    sm++;\n                    return true;\n                }\n            }else{\n                int val = *(--ng.end());\n                ng.erase(--ng.end());\n                if(val == cri){\n                    sm++;\n                    ng.insert(0);\n                }else{\n                    auto it = ng.upper_bound(cri-val-2);\n                    if(it == ng.begin()){\n                        sm++;\n                    }else{\n                        --it;\n                        ng.erase(it);\n                        sm++;\n                    }\n                }\n            }\n        }\n        dp[u] = 0;\n    }\n    return true;\n}\n\nbool possible(int cri, int a)\n{\n    int sm = 0;\n    if(!dfs2(0, -1, cri, sm)) return false;\n    if(dp[0]) sm++;\n    assert(sm >= a);\n    return (sm == a);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int> > edges;\n\nvector<int> dp;\n\nint dfs(int now, int from, int len)\n{\n    multiset<int> l;\n\n    for (auto v : edges[now]) if (v != from)\n    {\n        if (dfs(v, now, len)) return 1;\n        l.insert(dp[v]);\n    }\n    if (!(l.size() % 2)) l.insert(0);\n\n    vector<int> rem;\n    while (!l.empty())\n    {\n        int t = *(--l.end());\n        l.erase(--l.end());\n        if (l.empty())\n        {\n            rem.push_back(t);\n            break;\n        }\n        auto itr = l.upper_bound(len - t);\n        if (itr == l.begin()) rem.push_back(t);\n        else l.erase(--itr);\n    }\n    if (rem.size() > 1) return 1;\n\n    dp[now] = rem[0] + 1;\n    return 0;\n}\n\nbool isAble(int b)\n{\n    dp = vector<int>(N, -1);\n    if (dfs(0, -1, b) || dp[0] > b+1) return false;\n    return true;\n}\n\nint main()\n{\n    cin >> N;\n    edges.resize(N);\n    for (int i=0; i<N-1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    int A = 0;\n    for (int i=0; i<N; i++) if ((int)edges[i].size() & 1) A++;\n    A /= 2;\n\n    cout << A << \" \";\n\n    int l = 0, r = N-1;\n    while (r - l >1)\n    {\n        int c = (l + r) / 2;\n        if (isAble(c)) r = c;\n        else l = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\n\ninline bool cmp(int a,int b){return F[a]<F[b];}\n\ninline bool dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tif(!dfs(vs[i].v,rt,x)) return false;\n\t\tv.push_back(vs[i].v);\n\t}\n\tif(v.size()==0){\n\t\tF[rt]=1;\n\t\treturn true;\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end(),cmp);\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tint tmp1=F[v[i]],tmp2=F[v[j]];\n\t\t\tfg&=(tmp1+tmp2)<=x;\n\t\t}\n\t\tif(fg) r=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tif(rs==n+1) return false;\n\tF[rt]=F[rs]+1;\n\treturn F[rt]<=x+1;\n}\ninline bool check(int x)\n{\n\treturn dfs(Rt,0,x);\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\n\nint A, B;\n\nbool flag;\n\nint dfs(int v, int p) {\n    vector<int> vec;\n    for(int u : G[v])\n        if(p != u) {\n            vec.push_back(dfs(u, v) + 1);\n            if(vec.back() > B) flag = true;\n        }\n    if(flag) return 0;\n    sort(ALL(vec));\nx:;\n    if(vec.size() & 1) {\n        int ng = -1, ok = vec.size();\n        while(ng + 1 < ok) {\n            int mid = ng + ok >> 1;\n            int i = 0, j = vec.size() - 1;\n            while(i < j) {\n                if(mid == i) i++;\n                if(mid == j) j--;\n                if(vec[i] + vec[j] > B) {\n                    ng = mid;\n                    break;\n                }\n                i++;\n                j--;\n            }\n            if(ng != mid) ok = mid;\n        }\n        if(ok == (int)vec.size())\n            return flag = true;\n        else\n            return vec[ok];\n    } else {\n        bool ok = true;\n        rep(i, vec.size() - i) if(vec[i] + vec[n - i - 1] > B) ok = false;\n        if(ok) return 0;\n        vec.pop_back();\n        goto x;\n    }\n}\n\nbool isok() {\n    flag = false;\n    int x = dfs(0, -1);\n    if(flag) return false;\n    return x <= B;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    A = 0;\n    rep(i, n) A += G[i].size() % 2;\n\n    A /= 2;\n\n    int ng = 0, ok = n;\n    while(ng < ok - 1) {\n        B = ok + ng >> 1;\n        (isok() ? ok : ng) = B;\n    }\n\n    cout << A << \" \" << ok << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        int ch = 0;\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] += dp[u];\n            ch += 1;\n        }\n        dp[x] -= ch / 2;\n        if (ch % 2 == 0) dp[x]++;\n    };\n\n    Dfs(0, -1);\n    int A = dp[0], B = n + 1;\n\n    auto Check = [&](int v) {\n        constexpr int kInf = 1'000'000'000;\n        function<void(int, int)> Dfs = [&](int x, int p) {\n            multiset<int> s;\n            dp[x] = kInf;\n            for (int u : g[x]) {\n                if (u == p) continue;\n                Dfs(u, x);\n                if (dp[u] > v) return;\n                s.insert(dp[u]);\n            }\n            if (s.size() & 1) {\n                int z = -1;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        if (z != -1) return;\n                        z = r;\n                    } else {\n                        s.erase(prev(it));\n                    }\n                }\n                dp[x] = z;\n                if (x != 0) dp[x]++;\n                if (dp[x] > v) {\n                    dp[x] = kInf;\n                    return;\n                }\n            } else {\n                auto f = s;\n                bool ok = true;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        ok = false;\n                        break;\n                    }\n                    s.erase(prev(it));\n                }\n                if (ok) {\n                    dp[x] = x == 0 ? 0 : 1;\n                    // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n                    return;\n                }\n                auto it = f.upper_bound(x == 0 ? v : v - 1);\n                if (it == f.begin()) return;\n                dp[x] = *prev(it);\n                if (x != 0) dp[x]++;\n                f.erase(prev(it));\n                int z = -1;\n                while (!f.empty()) {\n                    int r = *f.rbegin();\n                    f.erase(f.find(r));\n                    auto it = f.upper_bound(v - r); \n                    if (it == f.begin()) {\n                        if (z != -1) {\n                            dp[x] = kInf;\n                            return;\n                        }\n                        z = r;\n                    } else {\n                        f.erase(prev(it));\n                    }\n                }\n            }\n            // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n        };\n        // printf(\"Check v = %d\\n\", v);\n        Dfs(0, -1);\n        return dp[0] != kInf;\n    };\n\n    for (int d = 20; d >= 0; --d) {\n        if (B - (1 << d) <= 0) continue;\n        if (Check(B - (1 << d))) B -= (1 << d);\n    }\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector< int > g[100000];\nint dp[100001];\nint ans;\n\nint rec(int idx, int ptr)\n{\n  deque< int > connect;\n  for(auto &to : g[idx]) {\n    if(to == ptr) continue;\n    connect.emplace_back(rec(to, idx) + 1);\n    dp[idx] += dp[to];\n  }\n  // connect が 1 だけ余裕がある場合があり\n  sort(begin(connect), end(connect));\n  dp[idx] += connect.size() / 2;\n\n  int odd = 0;\n  if(connect.size() % 2 == 1) {\n    odd = connect.front();\n    connect.pop_front();\n  }\n\n  while(!connect.empty()) {\n    ans = max(connect.front() + connect.back(), ans);\n    connect.pop_front();\n    connect.pop_back();\n  }\n\n\n  return (odd);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  int result = rec(0, -1);\n  if(result != 0) {\n    dp[0]++;\n    ans = max(ans, result);\n  }\n\n  cout << dp[0] << \" \" << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box%2)M++;\n\treturn 1;\n}\n\nint even(multiset<int>ms, int lim) {\n\tint box = MOD, ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tif (a > lim)K = 0;\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (it == ms.begin()) {\n\t\t\tif (box != MOD && ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse if (box != MOD) {\n\t\t\t\tret = a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbox = a;\n\t\t\t}\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tret %= MOD;\n\tif (ms.size())return *ms.begin();\n\treturn ret;\n}\n\nint odd(multiset<int>ms, int lim) {\n\tint ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (a > lim)K = 0;\n\t\tif (it == ms.begin()) {\n\t\t\tif (ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = a;\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tif(ms.size())return *ms.begin();\n\treturn ret;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i, lim) + 1);\n\t}\n\tif (num[node].empty()) {\n\t\treturn 0;\n\t}\n\tif (num[node].size() % 2 == 1) {\n\t\treturn odd(num[node], lim);\n\t}\n\telse {\n\t\tassert(0);\n\t\treturn even(num[node], lim);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tauto box = Search(edge, dis, num, 0, mid);\n\t\tif (box > mid)K = 0;\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstatic_assert(sizeof(long) >= 8, \"long too short\");\n\nvector<int> adj[100000];\nvector<int> data1[100000];\n\nint solvea(int n) {\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n        ans += adj[i].size() % 2;\n    return ans / 2;\n}\n\nint dfs(int u, int p, int b) {\n    auto &v = data1[u];\n    v.clear();\n    v.reserve(adj[u].size() + 1);\n\n    for (int c : adj[u]) {\n        if (c != p) {\n            v.push_back(dfs(c, u, b));\n        }\n    }\n    if (adj[u].size() % 2)\n        v.push_back(0);\n    sort(v.begin(), v.end());\n\n    if (p < 0) {\n        int ans = 0;\n        for (int i = 0, j = v.size() - 1; i < j; i++, j--)\n            ans = max(ans, v[i] + v[j]);\n        return ans;\n    } else {\n        int l = 0, r = v.size();\n        while (l < r) {\n            int k = (l + r) / 2;\n            bool ok = true;\n            for (int i = 0, j = v.size() - 1; i < j; i++, j--) {\n                if (i == k)\n                    i++;\n                if (j == k)\n                    j--;\n                if (i >= j)\n                    break;\n                if (v[i] + v[j] > b) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok)\n                r = k;\n            else\n                l = k + 1;\n        }\n        if (r < (int) v.size())\n            return v[r] + 1;\n        return b + 1;\n    }\n}\n\nbool checkb(int b) {\n    return dfs(0, -1, b) <= b;\n}\n\nint solveb(int n) {\n    int l = 1, r = n - 1;\n    while (l < r) {\n        int m = (l + r) / 2;\n        if (checkb(m))\n            r = m;\n        else\n            l = m + 1;\n    }\n    return r;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--, b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int a = solvea(n);\n    int b = solveb(n);\n    printf(\"%d %d\\n\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t\t\t\t\t\nusing namespace std;\n\t\t\t\ntypedef long long ll;\n#define mp make_pair\n#define pub push_back\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define db long double\n#define sz(a) (int)a.size()\n\nint n;\nvector<int> g[100007];\n\nint calcCnt(int v, int pred){\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tans += calcCnt(to, v);\n\t\tcnt++;\n\t}\n\tif (v != 0) cnt--;\n\tans += (cnt + 1) / 2;\n\treturn ans;\n}\n\nbool f;\nint ww;\n\nint dfs(int v, int pred){\n\tif (g[v].size() == 1 && g[v][0] == pred) return 0;\n\tmultiset<int> se;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tse.insert(dfs(to, v) + 1);\n\t}\n\tif (v == 0){\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\tif ((*se.begin()) > ww) f = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t} else {\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\treturn (*se.begin());\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nbool can(int val){ \n\tf = 1; ww = val;\n\tdfs(0, -1);\n\treturn f;\n}\n\nint main(){\n\tsrand(123321);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pub(b);\n\t\tg[b].pub(a);\n\t}\n\n\tint vl = 0, vr = 1e9 + 7;\n\twhile(vl + 1 < vr){\n\t\tint vm = (vl + vr) >> 1;\n\t\tif (can(vm))\n\t\t\tvr = vm;\n\t\telse\n\t\t\tvl = vm;\n\t}\n\tcout << calcCnt(0, -1) << ' ' << vr;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[100000];\n\nbool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\tif (edge[v].size() == 1) {\n\t\treturn 0;\n\t}\n\tif (edge[v].size() == 2) {\n\t\tfor (auto& e : edge[v]) {\n\t\t\tif (e != parent) { return 1 + func(e, v); }\n\t\t}\n\t}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (*L.begin() > len_max) {\n\t\tfunc_ok = false;\n\t\treturn 0;\n\t}\n\n\twhile (L.size()>=3) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\treturn *L.rbegin();\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\tif (L.size() == 1) {\n\t\treturn *L.begin();\n\t}\n\t//if(L.size()==2)\n\tif (*(L.begin()) + *(++L.begin()) <= len_max) {\n\t\treturn 0;\n\t}\n\treturn *L.rbegin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t\tif (vals.back() > l) fl = false;\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vals.size(); i++) {\n\t\t\tll rv = vals.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vals[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vals[i] + vals[rv] - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (maxS <= l) return 1ll;\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool fl2 = true;\nbool check(int l) {\n\tfl = true;\n\tfl2 = true;\n\n\tif (l == 2) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfl2 = fl;\n\t\n\tfl = true;\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (gr[i].size() == 1) {\n\t\t\tdp(i, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn max(fl, fl2);\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\n\nint n;\nvector<int> adj[MAXN];\n\nint cnt[MAXN];\nint parlen[MAXN];\nint mxlen[MAXN];\nint limit;\n\nint cur[MAXN],ncur;\n\nbool dfs(int at,int par) {\n\t//printf(\"dfs(%d,%d)\\n\",at+1,par+1);\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i]; if(to==par) continue;\n\t\tif(!dfs(to,at)) return false;\n\t}\n\tcnt[at]=1,mxlen[at]=0; ncur=0;\n\tREPSZ(i,adj[at]) {\n\t\tint to=adj[at][i]; if(to==par) continue;\n\t\tcnt[at]+=cnt[to];\n\t\tmxlen[at]=max(mxlen[at],mxlen[to]);\n\t\tcur[ncur++]=parlen[to];\n\t}\n\tsort(cur,cur+ncur);\n\tint pos=0,nskipped=0,mnskipped=-1,res=-1,single=-1;\n\tfor(int i=ncur-1;i>=0;--i) {\n\t\tif(pos>=i) {\n\t\t\tif(pos==i) {\n\t\t\t\tif(mnskipped==-1) mnskipped=cur[pos];\n\t\t\t\t++nskipped;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(cur[pos]+cur[i]>limit) {\n\t\t\tif(nskipped>0) { --nskipped; continue; }\n\t\t\tif(ncur%2==0&&single==-1) { mxlen[at]=max(mxlen[at],cur[i]); single=cur[i]; continue; }\n\t\t\tif(res==-1) { res=cur[i]+1; continue; }\n\t\t\treturn false;\n\t\t}\n\t\twhile(pos+1<i&&cur[pos+1]+cur[i]<=limit) {\n\t\t\tif(mnskipped==-1) mnskipped=cur[pos];\n\t\t\t++nskipped,++pos;\n\t\t}\n\t\tmxlen[at]=max(mxlen[at],cur[pos]+cur[i]);\n\t\t++pos;\n\t}\n\tnskipped%=2;\n\tif(nskipped==0&&res==-1) res=1;\n\tif(nskipped==1&&res==-1) res=mnskipped+1;\n\tparlen[at]=res; mxlen[at]=max(mxlen[at],parlen[at]); cnt[at]-=(ncur+1)/2;\n\t//printf(\"limit=%d: %d -> cnt=%d parlen=%d mxlen=%d\\n\",limit,at+1,cnt[at],parlen[at],mxlen[at]);\n\t//printf(\"cur:\"); REP(i,ncur) printf(\" %d\",cur[i]); puts(\"\");\n\treturn mxlen[at]<=limit;\t\t\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n-1) { int a,b; scanf(\"%d%d\",&a,&b); --a,--b; adj[a].PB(b); adj[b].PB(a); }\n\n\tint rt=0; while(SZ(adj[rt])!=1) ++rt; //printf(\"rt=%d\\n\",rt+1);\n\tint x=adj[rt][0];\n\tlimit=INT_MAX;\n\tassert(dfs(x,rt));\n\tint rescnt=cnt[x];\n\tint l=0,r=mxlen[x];\n\twhile(l+1<r) {\n\t\tlimit=l+(r-l)/2;\n\t\tif(dfs(x,rt)) r=limit; else l=limit;\n\t}\n\tprintf(\"%d %d\\n\",rescnt,r);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e5+50;\n\nint n,f[N],A,B,fail;\nvector<int> g[N]; \n\nvoid dfs(int v,int p){\n\tint x=p>0;\n\tf[v]=p>0;\n\tfor(int d:g[v])if(d!=p){\n\t\t++x; dfs(d,v); f[v]+=f[d];\n\t}\n\tf[v]-=x/2;\n\tPr(\"dfs %d,%d,f=%d\\n\",v,p,f[v]); \n}\n\nint G[N];\nvoid dp2(int v,int p){\n\tvector<int> a; if(p>0)a.pb(1);\n\tfor(int d:g[v])if(d!=p){dp2(d,v);a.pb(G[d]);}\n\tsort(all(a));if(a.size()&1){\n\t\tint Z=0;for(int l=1,r=a.size()-1;l<=r;++l,--r)if(a[l]+a[r]>B)Z=1;\n\t\tif(!Z){G[v]=1;return;}\n\t\ta.pop_back();\n\t}\n\tif(a.empty()){G[v]=1;return;}\n\tint m=a.size();\n\tlop(i,0,m)if(a[i]+a[m-1-i]>B)fail=1;\n\tint L=0,R=m-1;\n\twhile(R-L>1){\n\t\tint mid=(L+R)>>1,Fail=0;\n\t\tvector<int> b;lop(i,0,m)if(i>0&&i!=mid)b.pb(a[i]);\n\t\tlop(i,0,b.size())if(b[i]+b[b.size()-1-i]>B)Fail=1;\n\t\tif(!Fail)R=mid;else L=mid;\n\t}\n\tG[v]=a[R]+1;Pr(\"v=%d,g=%d\\n\",v,G[v]);\n}\n\nbool chk(int x){\n\tB=x,fail=0;\n\tPr(\"Chk %d\\n\",x); \n\tdp2(1,0);\n\treturn !fail;\n}\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\nfreopen(\"d.in\",\"r\",stdin);freopen(\"m.out\",\"w\",stdout); \n#endif\n\tread(n); \n\trep(i,1,n-1){\n\t\tint u,v;\n\t\tread(u),read(v); \n\t\tg[u].pb(v),g[v].pb(u); \n\t}\n\tdfs(1,0);\n\tA=f[1];\n\tint l=0,r=n-1;\n\twhile(r-l>1){\n\t\tint mid=(l+r)>>1;\n\t\tif(chk(mid))r=mid;else l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> vec[N];\nint head[N],deg[N];\nint n,x,y,tot,flag,A;\nstruct edge{int to,next;}e[N*2];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint check(vector<int> vec,int ban,int lim,int sz){\n\tint now=sz; \n\tif (ban!=-1){ \n\t\tif (vec[ban]>lim) return 0;\n\t\tnow--;\n\t}\n\tint L=0,R=sz-1;\n\tif (L==ban) L++;\n\tif (R==ban) R--;\n\tif (now&1){\n\t\tif (vec[R]>lim) return 0;\n\t\tR--;\n\t\tif (R==ban) R--;\n\t}\n\twhile (L<=R){\n\t\tif (L==R){\n\t\t\tif (vec[L]>lim) return 0;\n\t\t}\n\t\telse\n\t\t\tif (vec[L]+vec[R]>lim) return 0;\n\t\tL++; R--;\n\t\tif (L==ban) L++;\n\t\tif (R==ban) R--;\n\t}\n\treturn 1;\n}\nint dfs(int x,int fa,int lim){\n\tif (!flag) return 0;\n\tvec[x].resize(0);\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa)\n\t\t\tvec[x].push_back(dfs(e[i].to,x,lim)+1);\n\tsort(vec[x].begin(),vec[x].end());\n\tint sz=vec[x].size();\n\tif (sz%2==0&&check(vec[x],-1,lim,sz))\n\t\treturn 0;\n\tif (x==1&&sz%2==0)\n\t\treturn flag=0,233;\n\tint l=0,r=sz-1,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(vec[x],mid,lim,sz))\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\t/*printf(\"%d %d\\n\",x,ans);\n\tfor (int i=0;i<vec[x].size();i++)\n\t\tprintf(\"%d \",vec[x][i]);\n\tputs(\"\");*/\n\tif (ans==-1)\n\t\tflag=0;\n\telse return vec[x][ans];\n} \nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t\tdeg[x]++; deg[y]++;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tA+=(deg[i]-1)/2;\n\tint l=1,r=n,ans=0;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tflag=1;\n\t\tdfs(1,1,mid);\n\t\tif (flag)\n\t\t\tans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t\t//printf(\"23333 %d %d\\n\",mid,flag);\n\t}\n\tprintf(\"%d %d\",A+1,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? 100002 : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 1;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n\nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0)data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res <= len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i];\n\t\tif(! kt) return;\n\t\tif(v != pa) child++, dfs(v, u, lim);\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++; dem /= 2;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem  << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100100;\nvi a[N];\nint n;\nint maxlen;\nint res;\n\nbool check(vi& ord, int pos) {\n\tif (ord[pos] + 1 > maxlen) {\n\t \treturn 0;\n\t}\n\tvi c;\n\tc.resize(sz(ord) - 1);\n\tint sz = 0;\n\tforn(i, sz(ord)) {\n\t\tif (i == pos)\n\t\t\tcontinue;\n\t\tc[sz++] = ord[i];\n\t}\t\n\tforn(i, sz(c) / 2) {\n\t\tif (c[i] + c[sz(c) - 1 - i] + 2 > maxlen) {\n\t\t \treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint calc(int v, int pr) {\n\tvi ord;\n\tforn(i, sz(a[v])) {\n\t \tint to = a[v][i];\n\t \tif (to == pr)\n\t \t\tcontinue;\n\t \tint k = calc(to, v);\n\t\tif (k < 0) {\n\t\t \treturn -1;\n\t\t}\n\t\tord.pb(k);\n\t}\n\tsort(all(ord));\n\tif (!(sz(ord) & 1)) {\n\t\t//debug(sz(ord));\n\t\tforn(i, sz(ord) / 2) {\n\t\t \tif (ord[i] + ord[sz(ord) - 1 - i] + 2 > maxlen) {\n\t\t \t\treturn -1; \t\n\t\t \t}\n\t\t}\n\t\tres += sz(ord) / 2;\n\t\treturn 0;\n\t}\n\tif (!check(ord, sz(ord) - 1)) {\n\t \treturn -1;\n\t}\n\tint l = 0, r = sz(ord) - 1;\n\twhile (l < r) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(ord, m)) {\n\t\t \tr = m;\n\t\t} else {\n\t\t \tl = m + 1;\n\t\t}\n\t}\n\tres += sz(ord) / 2;\n\tif (!v)\n\t\tres++;\n\treturn ord[l] + 1;\n}\n\nint main () {\n\t//std::ios::sync_with_stdio(false);\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tcin >> n;\n\tforn(i, n - 1) {\n\t \tint u, v;\n\t \tcin >> u >> v;\n\t \tu--, v--;\n\t \ta[u].pb(v);\n\t \ta[v].pb(u);\n\t}     \n\tint l = 1, r = n - 1;\n\twhile (l < r) {\n\t    maxlen = (l + r) / 2;\n\t    res = 0;\n\t    if (calc(0, -1) < 0) {\n\t     \tl = maxlen + 1;\n\t    } else {\n\t     \tr = maxlen;\n\t    }\n\t}\n\tmaxlen = l;\n\tres = 0;\n\tcalc(0, -1);\n\tcout << res << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nint a = 0;\n\nvoid dfsa(int now, int past){\n    int tmp = 0;\n    for (int next : e[now]){\n        if (next == past) continue;\n        tmp++;\n        dfsa(next, now);\n    }\n    a += tmp / 2;\n    if (now == 0 && tmp % 2) a++;\n}\n\nbool good;\nint c;\n\nint dfs(int now, int past){\n    if (!good) return 0;\n    VI a;\n    for (int next : e[now]){\n        if (next == past) continue;\n        a.push_back(dfs(next, now) + 1);\n    }\n    sort(ALL(a));\n    int n = a.size();\n    REP(i,n) if (a[i] > c) good = false;\n    if (n % 2 == 0){\n        int ret = 0;\n        if (now == 0) ret = 1e9;\n        REP(i,n/2){\n            if (a[i] + a[n-1-i] > c){\n                if (ret == 0){\n                    ret = a[i];\n                }else{\n                    good = false;\n                }\n            }\n            // if (a[i] + a[n-1-i] > c) good = false;\n        }\n        // cout << \"e\" << now << good << endl;\n        return ret;\n    }\n    if (a[n-1] > c) good = false;\n    REP(i,n/2){\n        if (a[i] + a[n-2-i] > c) good = false;\n    }\n    int ok = n-1, ng = -1;\n    while (ok - ng > 1){\n        int mi = (ok + ng) / 2;\n        bool f = true;\n        REP(i,n/2){\n            int x = i;\n            if (x >= mi) x++;\n            int y = n - 1 - i;\n            if (y <= mi) y--;\n            if (a[x] + a[y] > c) f = false;\n        }\n        if (f) ok = mi;\n        else ng = mi;\n    }\n    // cout << now << \" \" << a[ok] << endl;\n    return a[ok];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--;b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n\n    dfsa(0, -1);\n\n    int ok = n, ng = 0;\n    while (ok - ng > 1){\n        c = (ok + ng) / 2;\n        // cout << c << endl;\n        good = true;\n        dfs(0, -1);\n        if (good) ok = c;\n        else ng = c;\n    }\n\n\n    cout << a << \" \" << ok << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint maxi = 0;\nvoid dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> v{1};\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        dp_dfs(g, to, dp);\n        v.push_back(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = v.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        v.push_back(0);\n    }\n    sort(v.begin(), v.end());\n    for (int i = 0; i < v.size(); i++) {\n        maxi = max(maxi, v[i] + v[v.size() - i - 1]);\n    }\n    dp[s] = {sum, (size % 2 == 0 ? 1 + v.back() : 1 + v[size - 1])};\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    dp_dfs(g, 0, dp);\n    show(dp);\n    cout << dp[0].first + 1 << \" \" << maxi - 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =1002;\nconst int MOD =1000000007;\nvector<int> hen[100000];\nbool used[100000];\nint ok,ng,mid;\nint dfs(int a,bool a0){\n  used[a]=true;\n  vector<int> v;\n  for(auto&& i:hen[a])if(!used[i]){\n    int b=dfs(i,false);\n    if(b==-1)return -1;\n    v.push_back(b+1);\n  }\n  sort(v.begin(),v.end());\n  if(v.size()%2==0){\n    bool t=true;\n      for(int i=0;i*2<v.size();i++){\n        if(v[i]+v[v.size()-1-i]>mid){\n          t=false;\n          break;\n        }\n      }\n    if(t)return 0;\n    if(v[v.size()-1]>mid||a0)return -1;\n    v.pop_back();\n  }\n  \n    int ok2=v.size(),ng2=-1,mid2;\n    while(abs(ok2-ng2)>1){\n      mid2=(ok2+ng2)/2;\n      bool t=true;\n      for(int i=0;i*2<v.size()-1;i++){\n        if(v[i+(i>=mid2)]+v[v.size()-2-i+(v.size()-2-i>=mid2)]>mid){\n          t=false;\n          break;\n        }\n      }\n      if(t)ok2=mid2;\n      else ng2=mid2;\n    }\n    return v[mid2];\n    \n  \n}\nsigned main(){\n int n,a,b,ansa=1;\n cin>>n;\n for(int i=0;i<n-1;i++){\n   cin>>a>>b;\n   a--;b--;\n   hen[a].push_back(b);\n   hen[b].push_back(a);\n }\n for(int i=0;i<n;i++)ansa+=(hen[i].size()-1)/2;\n  ng=0;ok=n;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    fill(used,used+n,false);\n    int y=dfs(0,true);\n    if(y==-1||y>mid)ng=mid;\n    else ok=mid;\n  }\n  cout<<ansa<<' '<<mid<<endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\nconst int INF = TEN(9);\n\nV<int> g[maxn];\nint r;\n\nint dfs(int v, int p, int l) {\n\tV<int> vec;\n\tfor (int to : g[v]) if (to != p) {\n\t\tint res = dfs(to, v, l);\n\t\tif (res == -1 || res > l) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(res);\n\t}\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tif (sz % 2 == 0) {\n\t\t{\n\t\t\t//all\n\t\t\tint nl = 0, nr = sz - 1;\n\t\t\tbool f = 1;\n\t\t\trep(i, sz / 2) {\n\t\t\t\tif (vec[nl] + vec[nr] > l) {\n\t\t\t\t\tf = 0;\n\t\t\t\t}\n\t\t\t\t++nl; --nr;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tvec.pop_back();\n\t\t--sz;\t\t\n\t}\n\n\t//sz : odd\n\n\tauto valid = [&](int p) {\n\t\tint nl = 0, nr = sz - 1;\n\t\tbool f = 1;\n\n\t\trep(i, sz / 2) {\n\t\t\tif (nl == p) ++nl;\n\t\t\tif (nr == p) --nr;\n\t\t\tif (vec[nl] + vec[nr] > l) {\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t\t++nl; --nr;\n\t\t}\n\t\treturn f;\n\t};\n\n\tint lo = 0, hi = sz;\n\tif (!valid(0)) {\n\t\treturn -1;\n\t}\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (valid(m)) lo = m;\n\t\telse hi = m;\n\t}\n\treturn vec[lo] + 1;\n}\n\nbool ok(int l) {\n\tint res = dfs(r, -1, l);\n\treturn (res != -1);\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\n\trep(i, N) if (g[i].size() == 1) {\n\t\tr = i;\n\t\tbreak;\n\t}\n\n\tint A = 0;\n\trep(i, N) if (g[i].size() % 2 == 1) ++A;\n\n\tint lo = 0, hi = N;\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", A / 2, hi);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int up)\n{\n\tvector<int>son;\n\tif (edge[x].size() & 1)son.push_back(0);\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, up))return false;\n\t\tif(dp[to] != -1)son.push_back(dp[to] + 1);\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > up)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = -1;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\tint flag = 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tflag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > up)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (son[le] > up)return false;\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nVI e[N];\nint l,r,mid,f[N];\ninline void dfs(int k) {\n\tfor (int t:e[k]) {\n\t\te[t].erase(find(e[t].begin(),e[t].end(),k));\n\t\tdfs(t);\n\t}\n}\ninline bool solve(int k) {\n\tint m=e[k].size(),i;\n\tVI w(m);\n\tfor (i=0;i<m;i++) {\n\t\tif (!solve(e[k][i])) return false;\n\t\tw[i]=f[e[k][i]]+1;\n\t}\n\tsort(w.begin(),w.end());\n\tif (k==1) {\n\t\tif (m&1) {\n\t\t\tif (w[m-1]>mid) return false;\n\t\t\tm--;\n\t\t}\n\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) return false;\n\t} else {\n\t\tif (m&1) {\n\t\t\tf[k]=w[0];\n\t\t\tfor (i=1;i<=m/2;i++)\n\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\tf[k]=w[i];\n\t\t\t\t}\n\t\t} else {\n\t\t\tf[k]=0;\n\t\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) break;\n\t\t\tif (i<m/2) {\n\t\t\t\tif (w[m-1]>mid) return false;\n\t\t\t\tm--;\n\t\t\t\tf[k]=w[0];\n\t\t\t\tfor (i=1;i<=m/2;i++)\n\t\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\t\tf[k]=w[i];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=gi(),i,a,b,ans=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\te[a].pb(b),e[b].pb(a);\n\t}\n\tans=1;\n\tfor (i=1;i<=n;i++) ans+=(e[i].size()-1)/2;\n\tdfs(1);\n\tl=1,r=n;\n\twhile (l!=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (solve(1)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<ans<<\" \"<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\nbool check(const vector<int> &tmp, int x) {\n        assert((int) tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        function<bool (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        if (!dfs(v, u)) return false;\n                        if (dp[v] + 1 > x) return false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return true;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                return false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        return false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        return false;\n                                }\n                        }\n                        return true;\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                return false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                return false;\n                        }\n                }\n                return true;\n        };\n        bool res = dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        int prevlb = -1, prevub = -1;\n        while (ub - lb > 0) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n                if (lb == prevlb && ub == prevub) break;\n                prevlb = lb, prevub = ub;\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1000009;\nint root, n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!s.empty() && (!fa || *s.begin() == limit)) {\n\t\tif (*s.begin() > limit) return -1;\n\t\ts.clear();\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(root, 0) == -1) return 0;\n\treturn need <= ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++) if (e[i].size() == 1) root = i;\n\t//root = rand() % n + 1;\n\tdfs1(root, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[100010];\nint ans;\n\nint DFS1(int v,int p)\n{\n    int cnt = 0,sum = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        sum += DFS1(ne,v);\n        cnt++;\n    }\n    if(cnt == 0)return 1;\n    return sum - (cnt - 1) / 2;\n}\n\nint DFS2(int v,int p,int x)\n{\n    vector<int> V;\n    int cnt = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        V.push_back(DFS2(ne,v,x));\n        cnt++;\n    }\n    if(cnt == 0)\n    {\n        return 1;\n    }\n    sort(V.begin(),V.end());\n    if(V.back() > x)\n    {\n        return 0;\n    }\n    if(V[0] == 0)\n    {\n        return 0;\n    }\n    if(cnt % 2 == 0)\n    {\n        for(int i = 0; i < V.size() / 2 + 1; i++)\n        {\n            if(i == V.size() / 2)\n            {\n                return 1;\n            }\n            if(V[i] + V[V.size() - 1 - i] > x)\n            {\n                if(V.back() > x)\n                {\n                    return 0;\n                }\n                V.pop_back();\n                break;\n            }\n        }\n    }\n    int l = -1,r = V.size() - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        int L = 0,R = V.size() - 1;\n        for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n        {\n            if(i == V.size() / 2)\n            {\n                r = mid;\n                break;\n            }\n            if(L == mid)L++;\n            if(R == mid)R--;\n            if(V[L] + V[R] > x)\n            {\n                l = mid;\n                break;\n            }\n        }\n    }\n\n    int L = 0,R = V.size() - 2;\n    for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n    {\n        if(i == V.size() / 2)\n        {\n            return V[r] + 1;\n        }\n        if(L == r)L++;\n        if(R == r)R--;\n        if(V[L] + V[R] > x)\n        {\n            return 0;\n            break;\n        }\n    }\n}\n\nbool judge(int mid)\n{\n    int res;\n    for(int i = 1; i <= N; i++)if(G[i].size() == 1)\n    {\n        res = DFS2(1,0,mid);\n        break;\n    }\n    return (res != 0 && mid >= res - 1);\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    //ans = DFS1(1,0);\n    for(int i = 1; i <= N; i++)if(G[i].size() % 2)ans++;\n    ans /= 2;\n\n    int l = 0,r = N - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(judge(mid))r = mid;\n        else l = mid;\n    }\n\n    printf(\"%d %d\\n\",ans,r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(l==son) ++l;\n\t\tif(r==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tif(!treeDP(v,u)) return false;\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(1,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\nconst int N = 200010;\nint n;\nvector<int> v[N];\nint f[N],g[N];\nint mi = 1e9;\nvoid dfs(int x,int fa){\n\tf[x] = 1;\n\tg[x] = 1;\n\tfor(auto t:v[x]) if(t!=fa){\n\t\tg[x] = max(g[x],f[t]+1);\n\t\tg[x] = max(g[x],g[t]);\n\t\tf[x] = min(f[x],f[t]+1);\n\t\tdfs(t,x);\n\t}\n\tif(x==1){\n\t\tvector<int> s;\n\t\tfor(auto t:v[x]) if(t!=fa){\n\t\t\ts.push_back(f[t]+1);\n\t\t}\n\t\tsort(s.begin(),s.end());\n\t\t//mx = v[1];\n\t\tif(s.size()>1) mi = s[1];\n\t}\n}\nint d[N];\nint ans,A;\nvoid dfs2(int x,int fa,int f1,int g1){\n\tvector<PII> s;\n\ts.push_back(mp(f1,fa));\n\tint tmp = max(g1,g[x]);\n\tfor(auto t:v[x]) if(t!=fa){\n\t\t//dfs2(t,x);\n\t\ts.push_back(mp(f[t]+1,t));\n\t}\n\tsort(s.begin(),s.end());\n\tif(s.size()>1){\n\t\ttmp = max(tmp,s[0].X+s[1].X-1);\n\t\tans = min(ans,tmp);\n\t}\n\tvector<int> pre,suf;\n\tpre.resize(s.size());\n\tpre[0] = (s[0].Y==fa?g1:g[s[0].Y]);\n\tfor(int i = 0;i<s.size();i++){\n\t\tpre[i] = max(pre[i-1],(s[i].Y==fa?g1:g[s[i].Y]));\n\t}\n\tsuf.resize(s.size());\n\tsuf[s.size()-1] =  (s[s.size()-1].Y==fa?g1:g[s[s.size()-1].Y]);\n\tfor(int i = suf.size()-1;i>=0;i--){\n\t\tsuf[i] =  max(suf[i+1],(s[i].Y==fa?g1:g[s[i].Y]));\n\t}\n\tint t;\n\tfor(int i = 0;i<s.size();i++) if((t=s[i].Y)!=fa){\n\t\tint t  = s[i].Y;\n\t\tif(t!=s[0].Y)\n\t\t\tdfs2(t,x,s[0].X+1,max((i>0?pre[i-1]:0),(i<s.size()-1?suf[i+1]:0)));\n\t\telse\n\t\t\tdfs2(t,x,s[1].X+1,max((i>0?pre[i-1]:0),(i<s.size()-1?suf[i+1]:0)));\n\t\t//s.push_back(mp(f[t]+1,t));\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i =1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tif(n==2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) if(v[i].size()==1) A++;\n\tA--;\n\tdfs(1,0);\n\tans =n;\n\tdfs2(1,0,mi+1,g[1]);\n\tcout<<A<<' '<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\tif(u.size() && u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size() - 1; i < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j == mid) j--;\n\t\t\t\tif(i < j && u[i] + u[j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0, r = -1;\n\trep(i, n){\n\t\tif(e[i].size() % 2) A++;\n\t\tif(e[i].size() == 1) r = i;\n\t}\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(r, r, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5;\nvector<int> g[N];\nvector<int> path[N];\n\nvoid dfs(int u, int p, int x) {\n  for (int v : g[u]) if (v != p) {\n    dfs(v, u, x);\n    path[u].push_back(path[v].back() + 1);\n  }\n\n  if (path[u].size() % 2 == 0) {\n    path[u].push_back(0);\n  }\n\n  sort(path[u].begin(), path[u].end());\n\n  int ok = path[u].size();\n  int ng = -1;\n\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n\n    int mx = 0;\n    auto tmp = path[u];\n    tmp.erase(tmp.begin() + mid);\n\n    for (int i = 0; i * 2 + 1 < tmp.size(); i++) {\n      mx = max(mx, tmp[i] + tmp[tmp.size() - 1 - i]);\n    }\n\n    if (mx <= x) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n \n  if (ok == path[u].size()) throw -1;\n  swap(path[u][ok], path[u].back());\n  \n  if (p == -1) {\n    if (path[u].back() > x) throw -1;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      ans += (g[i].size() + 1) / 2;\n    } else {\n      ans += (g[i].size() - 1) / 2;\n    }\n  }\n\n  int ok = n - 1;\n  int ng = -1;\n  while (ok - ng > 1) {\n    for (int i = 0; i < n; i++) {\n      path[i].clear();\n    }\n    int mid = (ok + ng) / 2;\n    try {\n      dfs(0, -1, mid);\n      ok = mid;\n    } catch (...) {\n      ng = mid;\n    }\n  }\n\n  cout << ans << ' ' << ok << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin>>n;\n  vvi G(n);\n  FOR(i,n-1) {\n    int a,b; cin>>a>>b;\n    --a; --b;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  { int a = 0;\n    FOR(i,n) if(G[i].size()&1) a += 1;\n    cout << a/2 << ' ';\n  }\n\n  auto ok = [&](int i, int b) -> bool {\n    function<int(int, int)> dfs = [&](int i, int p) -> int {\n      deque<int> rs;\n      for(int j : G[i]) if(j != p) {\n          int r = dfs(j,i);\n          if(r>b) throw 0;\n          rs.pb(r);\n      }\n      sort(all(rs));\n      if(p == -1) {\n        if(rs.size()&1) {\n          rs.pop_back();\n        }\n        FOR(i,rs.size()) if(rs[i]+rs[rs.size()-1-i] > b) throw 0;\n        return 0;\n      }else{\n        if((rs.size()&1) == 0) rs.pb(0);\n        int r0 = rs.front(); rs.pop_front();\n        while(!rs.empty()) {\n          if(rs.front()+rs.back() > b) {\n            if(r0+rs.back() > b) throw 0;\n            r0 = rs.front(); rs.pop_front(); rs.pop_back();\n          }else{\n            rs.pop_front();\n            rs.pop_back();\n          }\n        }\n        return r0+1;\n      }\n    };\n    try {\n      dfs(i,-1);\n      return 1;\n    } catch(int){\n      return 0;\n    }\n  };\n\n  vi IS(n); iota(all(IS),0);\n  random_shuffle(all(IS));\n\n  int ans = n+n;\n\n  FOR(k,min<int>(10,IS.size())) {\n    int lo = 1, hi = n+n;\n    while(lo != hi) {\n      int mi = (lo+hi)/2;\n      if(ok(IS[k], mi)) { hi = mi; }\n      else { lo = mi+1; }\n    }\n    ans=min(ans,lo);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],f[N],sum[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nint top,s[N];\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        s[++top]=sum[v]+1;\n    }\n    sort(s+1,s+1+top);\n    for(int i=1;i<=top;i++) st.insert(s[i]);\n    for(int i=top;i>=1;i--)\n    {\n        if(!st.count(s[i])) continue;\n        st.erase(st.find(s[i]));\n        if(st.size()==0)\n        {\n            if(s[i]+1<=m) sum[u]=s[i];\n            else f[u]++;\n            break;\n        }\n        it=st.upper_bound(m-s[i]);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;\n            st.erase(st.find(*it));\n        }\n    }\n    top=0;\n    if(u==1&&sum[u]) f[u]++;\n}\nbool judge(int m)\n{\n    dfs(1,0,m);\n    return f[1]<=dp[1];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=(n-1)/dp[1]+((n-1)%dp[1]!=0),r=n-1,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        if(judge(m)) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\twhile (nt && extra.size()) {\n\t\textra.pop_back();\n\t\tnt--;\n\t}\n\tif(nt)ans = 1e9;\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tans1 = all;\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (x==1){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (top&1) ok&=check(top);\n\t\telse ok&=check(-1);\n\t\treturn;\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O)?stk[r]+1:(-1);\n\t}\n\telse{\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=(stk[r]+1<=O)?stk[r]+1:(-1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=1,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos > 0) data.erase(data.begin() + pos);\n\tint l = 0, r = data.size() - 1; \n\twhile (l < r) if (data[l++].fi + data[r--].fi > lim) return false; \n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nbool dfs(int u, int pa, int lim){ \n\tvector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if( v == pa) continue; \n\t\tif(! dfs(v, u, lim)) return false;\n\t\tif( ++ h[v] > lim) return false;\n\t\tdata.pb(ii(h[v], v));\n\t}\n\tif(data.size() == 0) return true;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return false;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) return false;\n\t\th[u] = h[res];\n\t\tif(u == 1 && h[u] > lim) return false; \n\t}\n\treturn true;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n)  dem += (adj[i].size() - 1) / 2;;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tmemset(h, 0, sizeof h);\n\t\tint mid = (l + r)/2;\n\t\tif(dfs(1, 1, mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem + 1 << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tif(n!=1 && v[n].size()==1){\n\t\tdp[n] = 1;\n\t\treturn true;\n\t}\n\tbool judge = true;\n\tmap<int,int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren[-dp[s]]++;\n\t\t}\n\t}\n\twhile(!children.empty()){\n\t\tdecltype(children)::iterator it = children.begin();\n\t\tint mi = it -> first;\n\t\tchildren[mi]--;\n\t\tif(children[mi]==0){\n\t\t\tchildren.erase(mi);\n\t\t}\n\t\tif(-mi>m){\n\t\t\tjudge = false;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tif(children.empty()){\n\t\t\t\tdp[n] = -mi;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecltype(children)::iterator p = children.lower_bound(-m-mi);\n\t\t\tint pv = p -> first;\n\t\t\tif(children.count(pv)){\n\t\t\t\tchildren[pv]--;\n\t\t\t\tif(children[pv]==0) children.erase(pv);\n\t\t\t}else{\n\t\t\t\tif(v[n].size()%2==0){\n\t\t\t\t\tjudge = false; break;\n\t\t\t\t}else{\n\t\t\t\t\tif(dp[n]==0) dp[n] = 1e9;\n\t\t\t\t\telse if(dp[n]==1e9) dp[n] = -mi;\n\t\t\t\t\telse{\n\t\t\t\t\t\tjudge = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(v[n].size()==2 || (n==1 && v[n].size()==1)) dp[n]++;\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge; \n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 0;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tif(a + table.front() > length){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\t//if(de < 0){\n\t\t//\tdame = true;\n\t\t//\treturn INF;\n\t\t//}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\tassert(node == num);\n\t\treturn 0;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.begin();\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,-1));\n        if(ip==S.begin()){\n            break;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                break;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n   while(S.size()>1){\n    auto ip=S.end();--ip;\n    --ok;\n    S.erase(ip);\n   }\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    ++ans;\n    while(high-low>1){\n       ok=ans;\n        int mid=(high+low)/2;\n        for(int i=1;i<=n;++i) dp[i]=1000000000;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    for(int i=1;i<=n;++i) dp[i]=1000000000;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int MAX=5040;\nconst ll MOD=1000000007;\nvector<int> conn[MAX],dir[MAX],tmp[MAX];\nint a,b,com=0,par[MAX],n;\nvoid dfs(int x,int p){\n    par[x]=p;\n    for(int i=0;i<conn[x].size();i++) if(conn[x][i]!=p) dfs(conn[x][i],x);\n}\nint div2(int v,int x,int y,int u){\n    if(y-x==1) return x;\n    int p=(x+y)/2,p1=0,p2=tmp[v].size()-1,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n        if(p1==p) p1++;\n        if(p2==p) p2--;\n    }\n    if(pos) return div2(v,x,p,u);\n    return div2(v,p,y,u);\n}\nint f(int x,int u){\n    tmp[x].clear();\n    if(dir[x].size()==0) return 0;\n    for(int i=0;i<dir[x].size();i++){\n        int t=f(dir[x][i],u)+1;\n        if(t==0) return -1;\n        tmp[x].push_back(t);\n    }\n    if(tmp[x].size()%2==0) tmp[x].push_back(0);\n    sort(tmp[x].begin(),tmp[x].end());\n    int t=div2(x,0,tmp[x].size()+1,u);\n    if(t==tmp[x].size()) return -1;\n    if(tmp[x][t]>u) return -1;\n    //printf(\"%d %d\\n\",x,tmp[x][t]);\n    return tmp[x][t];\n}\nint div22(int x,int y){\n    if(y-x==1) return x;\n    int p=(x+y)/2,u=f(com,p);\n    if(u==-1) return div22(p,y);\n    return div22(x,p);\n}\nint main(){\n    scanf(\" %d\",&n);\n    for(int i=0;i<n-1;i++){\n        int t1,t2;\n        scanf(\" %d %d\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(int i=1;i<=n;i++) if(conn[i].size()%2) com=max(i,com), a+=1;\n    a/=2;\n    dfs(com,0);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<conn[i].size();j++) if(conn[i][j]!=par[i]) dir[i].push_back(conn[i][j]);\n    }\n    b=div22(1,n)+1;\n    printf(\"%d %d\\n\",a,b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n \n \nii dp[111111];\nvi adj[111111];\nint MID;\nint tot;\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t}\n\tsort(vec.begin(),vec.end());\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\tint maxpath=0;\n\tif(vec.size()%2==0) vec.push_front(0);\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=-1;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = -int(1e9);\n\t\t\twhile(l==mid) l++;\n\t\t\twhile(r==mid) r--;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=max(res,vec[l]+vec[r]);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1) maxpath=MID+100;\n\t\telse maxpath = vec[ans]+1;\n\t}\n\t//cerr<<MID<<' '<<u+1<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttot+=(adj[i].size()&1);\n\t}\n\tMID=n;\n\tint res=tot/2;\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=res;\n\t\tif(dp[0].se>MID+1) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint root;\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src])%2 == 1) return 0;\n    vi legs;\n    if(sz(adj[src])%2 == 0) for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        int l = 0;\n        int r = sz(legs)-1;\n        while(l<=r){\n            if(legs[l]+legs[r]>mx){\n                ok = false; return legs.back();\n            }\n            l++; r--;\n        }\n        return legs.back();\n    }\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check(legs, lo, mx)) return legs[lo];\n    else if(check(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nvoid getEdge(int src){\n    edges.clear();\n    int u = src;\n    int v = par[0][src];\n    if(sz(adj[u])%2 == 1 && sz(adj[v])%2 == 1) return;\n    if(sz(adj[u])%2 == 0) dfs_vert(u);\n    else dfs_vert(v);\n    set<int> s;\n    int cent;\n    for(auto ee: edges){\n        pi e = mp(ee, par[0][ee]);\n        if(sz(adj[e.f])%2 == 0) cent = e.f;\n        if(sz(adj[e.s])%2 == 0) cent = e.s;\n    }\n    root = cent;\n    int lo = 1;\n    int hi = MAX;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(cent, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(cent, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n}\nint main(){\n    setIO(\"temp\");\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    vi pts;\n    f0r(i, n) if(sz(adj[i])%2 == 1) pts.eb(i);\n    f1r(i, 1, n){\n        if(vis[i]) continue;\n        getEdge(i);\n    }\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\n\ntemplate <typename UnaryPredicate>\nint binsearch(int l, int r, UnaryPredicate p) {\n    assert (l <= r);\n    -- l;\n    while (r - l > 1) {\n        int m = l + (r - l) / 2;  // avoid overflow\n        (p(m) ? r : l) = m;\n    }\n    return r;\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    REP (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    constexpr int root = 0;\n    int a = 0; {\n        vector<char> used(n);\n        function<void (int, int)> use_chain = [&](int i, int parent) {\n            used[i] = true;\n            for (int j : g[i]) if (j != parent and not used[j]) {\n                use_chain(j, i);\n                break;\n            }\n        };\n        function<void (int, int)> go = [&](int i, int parent) {\n            int count_not_used = 0;\n            for (int j : g[i]) if (j != parent) {\n                if (not used[j]) {\n                    count_not_used += 1;\n                    use_chain(j, i);\n                }\n                go(j, i);\n            }\n            a += (count_not_used + 1) / 2;\n        };\n        go(root, -1);\n    }\n    int b = binsearch(1, n, [&](int b) {\n        int count_chain = 0;\n        function<int (int, int)> go = [&](int i, int parent) {\n            map<int, int> chain;\n            for (int j : g[i]) if (j != parent) {\n                int length = go(j, i);\n                if (length - 1 >= 1) {\n                    chain[length - 1] += 1;\n                }\n            }\n            for (auto it = chain.begin(); it != chain.end(); ) {\n                // pop\n                int length, count; tie(length, count) = *it;\n                chain[length] = 0;\n                // make pairs\n                while (count) {\n                    it = chain.lower_bound(b - length);\n                    if (it == chain.end()) break;\n                    if (it->first == length) {\n                        assert (it->second == 0);\n                        count_chain -= count / 2;\n                        count %= 2;\n                    } else {\n                        int delta = min(count, it->second);\n                        count_chain -= delta;\n                        count -= delta;\n                        it->second -= delta;\n                    }\n                    if (not it->second) {\n                        chain.erase(it);\n                    }\n                }\n                // write back\n                if (count) {\n                    chain[length] = count;\n                } else {\n                    chain.erase(length);\n                }\n                // increment\n                it = chain.lower_bound(length + 1);\n            }\n            if (chain.empty()) {\n                if (i == root) {\n                    return -1;\n                } else {\n                    count_chain += 1;\n                    return b;\n                }\n            } else {\n                return chain.rbegin()->first;\n            }\n        };\n        go(root, -1);\n        return count_chain <= a;\n    });\n    // output\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nstd::vector<int>g[100005];\nint in[100005];\nint cntA[100005];\nint parent[100005];\nint depth[100005];\nint seq[100005];\nint t[100005];\nint bad[100005];\nint order[100005];\nint total = 0;\n\nvoid dfs(int u,int have){\n    order[++total] = u;\n    int need = in[u]-have;\n    if(u!=1) need--;\n    if(need<0) need = 0;\n    //printf(\"u = %d: %d\\n\",u,need);\n    cntA[u] = need/2+need%2;\n    for(int v: g[u]){ \n        if(parent[v]!=0) continue;\n        parent[v] = u;\n        dfs(v,1);\n    }\n}\n\nint isGood(int n,int upper){\n    if(n%2){ \n        if(t[n]>upper) return 0;\n        return isGood(n-1,upper);\n    }\n    else{\n        for(int i = 1; i <= n/2; i++){\n            if(t[i]+t[n-i+1]>upper) return 0;\n        }\n        return 1;\n    }\n}\n\nvoid dp(int u,int upper){\n    bad[u] = 0;\n    if(in[u]==1){ \n        depth[u] = 0;\n        return ;\n    }\n    int size = 0;\n    for(int v: g[u]){\n        if(parent[v]==u) seq[++size] = depth[v]+1;\n    }\n    std::sort(seq+1,seq+1+size);\n    if(in[u]%2){\n        for(int i = 1; i <= size; i++) t[i] = seq[i];\n        if(isGood(size,upper)) depth[u] = 0;\n        else{\n            int L = 1, R = size;\n            int res = -1;\n            while(L<=R){\n                int M = (L+R)/2;\n                int tSize = 0;\n                for(int i = 1; i <= size; i++) if(i!=M) t[++tSize] = seq[i];\n                if(isGood(tSize,upper)){\n                    res = M;\n                    R = M-1;\n                } \n                else L = M+1;\n            }\n            if(res==-1){\n                bad[u] = 1;\n                return ;\n            }\n            else{\n                depth[u] = seq[res];\n            }\n        }\n    }\n    else{\n        int L = 1, R = size;\n        int res = -1;\n        while(L<=R){\n            int M = (L+R)/2;\n            int tSize = 0;\n            for(int i = 1; i <= size; i++) if(i!=M) t[++tSize] = seq[i];\n            if(isGood(tSize,upper)){\n                res = M;\n                R = M-1;\n            } \n            else L = M+1;\n        }\n        if(res==-1){\n            bad[u] = 1;\n            return ;\n        }\n        else{\n            depth[u] = seq[res];\n        }\n    }\n}\n\nint isOk(int s,int n,int upper){\n    for(int i = n; i >= 2; i--){\n        int u = order[i];\n        dp(u,upper);\n        if(bad[u]) return 0;\n        //else printf(\"depth[%d] = %d\\n\",u,depth[u]);\n    }\n    int size = 0;\n    for(int v: g[s]){\n        seq[++size] = depth[v]+1;\n    }\n    std::sort(seq+1,seq+1+size);\n    for(int i = 1; i <= size; i++) t[i] = seq[i];\n    if(isGood(size,upper)) return 1;\n    else return 0;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0; i < n-1; i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        in[u]++, in[v]++;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    parent[1] = -1;\n    dfs(1,0);\n    int ansA = 0;\n    for(int i = 1; i <= n; i++) ansA += cntA[i];\n    int L = 1, R = n;\n    int ansB = -1;\n    while(L<=R){\n        int M = (L+R)/2;\n        if(isOk(1,n,M)){\n            ansB = M;\n            R = M-1;\n        }\n        else L = M+1;\n    }\n    //int ansB = isOk(1,n,4);\n    printf(\"%d %d\\n\",ansA,ansB);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n    for(int i=1;i<=n;++i){\n        if(V[i].size()%2) ++all;\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    ans=all;\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box%2)M++;\n\treturn 1;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\t//cout << node << endl;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i,lim) + 1);\n\t}\n\t//cout <<\"node \"<< node << endl;\n\t//for (auto i : num[node]) {\n\t//\tcout << i << \" \";\n\t//}\n\t//cout << endl;\n\twhile (num[node].size() > 1) {\n\t\tint b = *prev(num[node].end());\n\t\tnum[node].erase(prev(num[node].end()));\n\t\tauto it = num[node].upper_bound(lim - b);\n\t\tif (it == num[node].begin() && num[node].size() % 2 == 1) {\n\t\t\tif (b > lim)K = 0;\n\t\t}\n\t\telse if (it == num[node].begin()) {\n\t\t\tK = 0;\n\t\t\tnum[node].erase(num[node].begin());\n\t\t}\n\t\telse {\n\t\t\tnum[node].erase(prev(it));\n\t\t}\n\t}\n\tif (!node&&num[node].size() && *num[node].begin() > lim)K = 0;\n\t//cout << node << \" \" << num[node].size() << endl;\n\tif (num[node].empty())return 0;\n\telse return *num[node].begin();\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tSearch(edge, dis, num, 0,mid);\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nvi G[maxn];\nint ans2=0;\nint cur;\nbool ok;\nint dfs(int u,int fa=-1)\n{\n    vi sonlen;\n    for(auto v:G[u])if(v!=fa)\n    {\n        int ret=dfs(v,u);\n        sonlen.push_back(ret+1);\n    }\n    sort(sonlen.begin(),sonlen.end());\n    if(sonlen.size()&1)\n    {\n        int L=0,R=sonlen.size()-1,ret=-1;\n        while(L<=R)\n        {\n            int mid=L+R>>1;\n            bool yes=1;\n            for(int l=0,r=sonlen.size()-1;l<r;l++,r--)\n            {\n                if(l==mid) l++;\n                if(r==mid) r--;\n                if(sonlen[l]+sonlen[r]>cur) yes=0;\n            }\n            if(yes){\n                ret=mid;\n                R=mid-1;\n            }\n            else L=mid+1;\n        }\n        if(ret==-1){\n            ok=0;\n            ret=0;    \n        }\n        return sonlen[ret];\n    }\n    else{\n        for(int l=0,r=sonlen.size()-1;l<r;l++,r--)\n            if(sonlen[l]+sonlen[r]>cur) ok=0;\n        return 0;\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1,u,v;i<n;i++)\n    {\n        cin>>u>>v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    int ans1=0,odd=0;\n    for(int i=1;i<=n;i++)\n        if(G[i].size()&1) odd++;\n    ans1=odd/2;\n    int L=1,R=n-1,ans2=-1;\n    while(L<=R)\n    {\n        cur=L+R>>1;\n        ok=1;\n        int ret=dfs(1);\n        //dbg(cur,ok);\n        if(ret>cur) ok=0;\n        if(ok)\n        {\n            ans2=cur;\n            R=cur-1;\n        }\n        else L=cur+1;\n    }\n    cout<<ans1<<\" \"<<ans2<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <array>\n#include <functional>\n#include <iterator>\n#include <map>\n#include <utility>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int SIZE = 100009;\nint dp1[SIZE];\nint dp2[SIZE];\nvector<int> adj[SIZE];\nint N;\nint bound;\n\nint buf[SIZE];\nint buf2[SIZE];\nint timestamp;\n\nvoid f(int u, int p)\n{\n    dp1[u] = 0;\n    for(int to: adj[u])\n        if(to != p)\n        {\n            f(to, u);\n            dp1[u] += dp1[to];\n        }\n    int total = 0;\n    for(int to: adj[u])\n        if(to != p)\n        {\n            int l = dp2[to] + 1;\n            dp1[u] += l / bound;\n            l %= bound;\n            if(l)\n                buf[total++] = l;\n        }\n\n    sort(buf, buf + total);\n    ++timestamp;\n    int last = 0;\n    for(int i = total - 1; i >= 0; i--)\n        if(buf2[i] != timestamp)\n        {\n            buf2[i] = timestamp;\n            auto idx = (upper_bound(buf, buf + i, bound - buf[i]) - buf) - 1;\n\n            dp1[u]++;\n            if(idx >= 0 && buf2[idx] != timestamp)\n                buf2[idx] = timestamp;\n            else\n                last = buf[i];\n        }\n    if(last)\n        dp1[u]--;\n\n    dp2[u] = last;\n}\n\nint main()\n{\n    RD(N);\n    for(int i: RG(N - 1))\n    {\n        int a, b;\n        RD(a, b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n\n    int l = 0, r = N;\n\n    bound = N;\n    f(1, 0);\n\n    int A = dp1[1] + (dp2[1] + bound - 1) / bound;\n\n\n    while(l + 1 < r)\n    {\n        int m = (l + r) / 2;\n        bound = m;\n\n        f(1, 0);\n        if(dp1[1] + (dp2[1] + bound - 1) / bound > A)\n            l = m;\n        else\n            r = m;\n    }\n\n\n    WTL(A, r);\n\n\n\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int) 1e5 + 10;\nint n;\nvector<int> adj[MAXN];\n\nint DFS(int u, int T, int par = -1) {\n    vector<int> a;\n    for (int i = 0; i < (int) adj[u].size(); ++i) {\n        int v = adj[u][i];\n        if (v != par) a.push_back(DFS(v, T, u));\n    }\n    if ((int) a.size() % 2 == 0 && par != -1) a.push_back(0);\n    sort(a.begin(), a.end());\n\n    if ((int) a.size() % 2 == 0) {\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (a[i] + a[(int) a.size() - i - 1] > T) return T + 3;\n        return 0;\n    }\n\n    int l = 0, r = (int) a.size() - 1, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        vector<int> b;\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (i != mid) b.push_back(a[i]);\n        bool check = true;\n        for (int i = 0; i < (int) b.size() / 2; ++i) {\n            if (b[i] + b[(int) b.size() - i - 1] > T) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (f == -1) {\n        // printf(\"#%d: %d\\n\", u, T + 3);\n        return T + 3;\n    }\n    // printf(\"#%d: %d\\n\", u, a[f] + 1);\n    return a[f] + 1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int l = 1, r = n, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (DFS(1, mid) <= mid + 1) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) cnt += (int) adj[i].size() % 2;\n\n    printf(\"%d %d\\n\", cnt / 2, f);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A, B, newA;\nvector<int> G[N];\nbool invalid;\nint lim;\n\nint findA(int u, int p) {\n    int rem = 0;\n    for (int v : G[u]) if (v != p) {\n        rem += findA(v, u);\n    }\n    A += rem / 2; rem %= 2;\n    if (rem % 2) return rem;\n    return (u == 1) ? rem : 1;\n}\n\nint dfs(int u, int p) {\n    if (invalid) return 0;\n    multiset<int> s;\n    for (int v : G[u]) if (v != p) {\n        int cur = dfs(v, u) + 1;\n        s.insert(cur);\n    }\n\n    vector<int> rem;\n    while(s.size()) {\n        multiset<int>::iterator it = s.end(); --it;\n        int x = (*it);\n        s.erase(it);\n        it = s.upper_bound(lim - x);\n        if (it == s.begin()) {\n            rem.push_back(x);\n        } else --it, s.erase(it), ++newA;\n    }\n\n    reverse(rem.begin(), rem.end());\n    while(rem.size() && rem.back() == lim) ++newA, rem.pop_back();\n\n    if (rem.size() > 1) { invalid = true; return 0; }\n    if (rem.size() == 0) return 0;\n    return rem[0];\n}\n\nbool check() {\n    newA = 0;\n    invalid = false;\n    newA += dfs(1, -1) != 0;\n\n    if (newA > A) invalid = true;\n    return !invalid;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v); G[v].push_back(u);\n    }\n    A += findA(1, -1);\n\n    int l = 1, r = n;\n    while(l < r) {\n        lim = ((l + r) >> 1);\n        if (check()) r = lim; else l = lim + 1;\n    }\n    cout << A << ' ' << l << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    vector<int> tmp;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n        tmp.push_back(t + 1);\n    }\n\n    sort(tmp.begin(), tmp.end());\n\n    if((p == -1) ^ (st.size() % 2)) {\n        if(p != -1) {\n            for(int i = 0; i < (int)tmp.size() - 1; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n            }\n        }\n        else {\n            for(int i = 0; i < (int)tmp.size(); i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 1 - i ] > X) return -1;\n            }\n        }\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return v;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        if(p != -1) {\n            for(int i = 0; i < (int)tmp.size() - 2; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 3 - i ] > X) return -1;\n            }\n        }\n        else {\n            for(int i = 0; i < (int)tmp.size() - 1; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n            }\n        }\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return v;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n \n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n \ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n \nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n \nconst int MX = 200005;\n \nvector<int> T[MX];\nint N, m, val = 1;\n \nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( X.empty() ) return 0;\n\tif( X.back() > m ) val = 0;\n \n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n      if( p == -1 )return val = 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tif( X[i] + X[X.size()-i-1] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n \nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\n\nint A, B;\n\nint s;\n\nint dfs(int v, int p) {\n    vector<int> vec;\n    for(int u : G[v])\n        if(p != u) {\n            vec.push_back(dfs(u, v) + 1);\n            if(vec.back() > B) return mod;\n        }\n    if(vec.empty()) return 0;\n    sort(ALL(vec));\nx:;\n    if(vec.size() & 1) {\n        int ng = -1, ok = vec.size();\n    y:;\n        while(ng + 1 < ok) {\n            int mid = ng + ok >> 1;\n            int i = 0, j = (int)vec.size() - 1;\n            while(i < j) {\n                if(vec[i] + vec[j] > B) {\n                    ng = mid;\n                    goto y;\n                }\n                i++;\n                j--;\n                if(mid == i) i++;\n                if(mid == j) j--;\n            }\n            ok = mid;\n        }\n        if(ok >= (int)vec.size())\n            return mod;\n        else\n            return vec[ok];\n    } else {\n        bool ok = true;\n        rep(i, vec.size() - i) if(vec[i] + vec[n - i - 1] > B) ok = false;\n        if(ok) return 0;\n        vec.pop_back();\n        goto x;\n    }\n}\n\nbool isok() { return dfs(s, -1) <= B; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    A = 0;\n    rep(i, n) A += G[i].size() % 2;\n\n    A /= 2;\n\n    s = 0;\n    while(G[s].size() != 1)\n        s++;\n\n    int ng = 0, ok = n;\n    while(ng < ok - 1) {\n        B = ok + ng >> 1;\n        (isok() ? ok : ng) = B;\n    }\n\n    cout << A << \" \" << ok << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md,ans1=0;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\tint cnt = 0;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\tcnt++;\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tcnt++;\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\twhile (nt && extra.size()) {\n\t\textra.pop_back();\n\t\tnt--;\n\t}\n\tif(nt || cnt>1)ans = 1e9;\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tans1 = all;\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans1, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nvi G[maxn];\nint ans2=0;\nint cur;\nbool ok;\nint dfs(int u,int fa=-1)\n{\n    vi sonlen;\n    for(auto v:G[u])if(v!=fa)\n    {\n        int ret=dfs(v,u);\n        sonlen.push_back(ret+1);\n    }\n    if(fa==-1&&G[u].size()%2==0)\n    {\n        sort(sonlen.begin(),sonlen.end());\n        for(int l=0,r=sonlen.size()-1;l<r;l++,r--)\n            if(sonlen[l]+sonlen[r]>cur) ok=0;\n        return 0;\n    }\n    if(sonlen.size()%2==0) sonlen.push_back(0);\n    sort(sonlen.begin(),sonlen.end());\n    int L=0,R=sonlen.size()-1,ret=-1;\n    while(L<=R)\n    {\n        int mid=L+R>>1;\n        bool yes=1;\n        for(int l=0,r=sonlen.size()-1;l<r;l++,r--)\n        {\n            if(l==mid) l++;\n            if(r==mid) r--;\n            if(sonlen[l]+sonlen[r]>cur) yes=0;\n        }\n        if(yes){\n            ret=mid;\n            R=mid-1;\n        }\n        else L=mid+1;\n    }\n    if(ret==-1){\n        ok=0;\n        ret=0;    \n    }\n    return sonlen[ret];\n}\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=1,u,v;i<n;i++)\n    {\n        cin>>u>>v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    int ans1=0,odd=0;\n    for(int i=1;i<=n;i++)\n        if(G[i].size()&1) odd++;\n    ans1=odd/2;\n    int L=1,R=n-1,ans2=-1;\n    while(L<=R)\n    {\n        cur=L+R>>1;\n        ok=1;\n        int ret=dfs(1);\n        //dbg(cur,ok);\n        if(ret>cur) ok=0;\n        if(ok)\n        {\n            ans2=cur;\n            R=cur-1;\n        }\n        else L=cur+1;\n    }\n    cout<<ans1<<\" \"<<ans2<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1 || res + 1 > B) return -1;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) return 0;\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\t\tret = a[i];\n\t\t\t}\n\t\treturn ret;\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,res[N],A,B,l,r,mid;\nvector<int> e[N];\nbool ok;\nint rest(vector<int> &L){\n    if (!(L.size()&1)) L.push_back(0);\n    sort(L.begin(),L.end());\n    for (int l=0,r=L.size()-2;l<r;l++,r--)\n    if (L[l]+L[r]>mid) ok=0;\n    int p=L.size()-1,len=p;\n    while (p&&L[p]+L[len-p+(len-p>=p)]<=mid) p--;\n    return L[p];\n}\nvoid solve(int x,int fa){\n    vector<int> L;\n    for (int i=0;i<e[x].size();i++){\n        int v=e[x][i];\n        if (v==fa) continue;\n        solve(v,x);\n        L.push_back(res[v]+1);\n    }\n    res[x]=rest(L);\n}\nbool check(){\n    ok=1;\n    solve(1,0);\n    return ok&&res[1]<=mid;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    A=n-1;\n    for (int i=1;i<=n;i++) A-=e[i].size()/2;\n    for (l=0,r=n-1;l<r;){\n        mid=(l+r)>>1;\n        if (check()) r=mid;else l=mid+1;\n    }\n    printf(\"%d %d\\n\",A,l);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[100000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\tif (edge[v].size() == 1) {\n\t\treturn 0;\n\t}\n\tif (edge[v].size() == 2) {\n\t\tfor (auto& e : edge[v]) {\n\t\t\tif (e != parent) { return 1 + func(e, v); }\n\t\t}\n\t}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\treturn *L.rbegin();\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, deg[N];\nvector<int> G[N];\n\nbool check(const vector<int>& A, int x, int m){\n\tint l = 0, r = int(A.size()) - 1;\n\twhile(l < r){\n\t\tif(l == x) ++l;\n\t\tif(r == x) --r;\n\t\tif(A[l] + A[r] > m) return false;\n\t\t++l, --r;\n\t}\n\treturn true;\n}\n\nint dp[N];\n\nbool DFS(int o, int f, int lim){\n\n\tvector<int> val;\n\t\n\tint ch = 0;\n\tfor(int v : G[o]){\n\t\tif(v == f) continue;\n\t\t++ch;\n\t\tif(!DFS(v, o, lim)) return false;\n\t\tval.pb(dp[v]);\n\t}\n\n\tif(ch % 2 == 0) val.pb(0);\n\tsort(val.begin(), val.end());\n\n\tint L = 0, R = int(val.size()) - 1;\n\tif(!check(val, R, lim)) return false;\n\n\twhile(L < R){\n\t\tint mid = (L + R) >> 1;\n\t\tif(check(val, mid, lim)) R = mid;\n\t\telse L = mid + 1;\n\t}\n\tdp[o] = val[L] + 1;\n\n\treturn true;\n}\n\nint main(){\n\t\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t\tdeg[u]++, deg[v]++;\n\t}\n\n\tint root = 0, a = 0;\n\tFor(i, 1, n) if(deg[i] == 1){\n\t\troot = i;\n\t\tbreak;\n\t}\n\tFor(i, 1, n) if(deg[i] & 1) ++a;\n\n\tint L = 1, R = n - 1;\n\twhile(L < R){\n\t\tint mid = (L + R) >> 1;\n\t\tif(DFS(root, 0, mid) && dp[root] <= mid + 1) R = mid;\n\t\telse L = mid + 1;\n\t}\n\n\tprintf(\"%d %d\\n\", a / 2, L);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=100005;\nvi v[N];\nint root=-1,dp[N],n;\nvi tmp;\nvoid dfs(int u,int val,int par=-1)\n{\n  dp[u]=0;\n  for(int v1:v[u])\n    {\n      if(v1==par) continue;\n      dfs(v1,val,u);\n    }\n  for(int v1:v[u]) if(v1!=par) tmp.pb(dp[v1]);\n  if(sz(tmp)%2==0) tmp.pb(0);\n  sort(all(tmp));\n  int low=0,high=sz(tmp)-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      int i=0,j=sz(tmp)-1;\n      bool ok=true;\n      while(i<j)\n\t{\n\t  if(i==mid) i++;\n\t  else if(j==mid) j--;\n\t  else if(tmp[i]+tmp[j]>val) { ok=false; break; }\n\t  else i++,j--;\n\t}\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  int i=0,j=sz(tmp)-1;\n  bool ok=true;\n  while(i<j)\n    {\n      if(i==low) i++;\n      else if(j==low) j--;\n      else if(tmp[i]+tmp[j]>val) { ok=false; break; }\n      else i++,j--;\n    }\n  if(!ok) dp[u]=val+100;\n  else dp[u]=tmp[low]+1;\n  tmp.clear();\n}\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  int x,y;\n  cin>>n;\n  rep(i,1,n) cin>>x>>y,v[x].pb(y),v[y].pb(x);\n  rep(i,1,n+1) if(sz(v[i])==1) root=i;\n  assert(root!=-1);\n  int cnt=0;\n  rep(i,1,n+1) cnt+=(sz(v[i])&1);\n  int low=0,high=n-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      dfs(root,mid);\n      bool ok=true;\n      rep(i,1,n+1) ok&=(dp[i]<=mid+1);\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  cout<<cnt/2<<\" \"<<low<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector <int> G[100005];\npair <long long, long long> DP[2][100005];\nlong long DP2[100005];\nint aux;\nbool ok;\nint a = 0;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    for(int i = 1; i <= N; i++)\n        if(G[i].size() % 2 == 1)\n            a++;\n}\ninline bool cmp(int a, int b)\n{\n    return DP2[a] < DP2[b];\n}\nbool check2(int pos, int node)\n{\n    int left = 0, right=  G[node].size() - 1;\n    while(left < right)\n    {\n        if(left == pos)\n        {\n            left++;\n            continue;\n        }\n        if(right == pos)\n        {\n            right--;\n            continue;\n        }\n        if(DP2[G[node][left]] + DP2[G[node][right]] > aux)\n            return 0;\n        left++;\n        right--;\n    }\n    int add = 0;\n    if(node == 1)\n        add = 1;\n    if(DP2[G[node][pos]] + 1 > aux + add)\n        return 0;\n    return 1;\n}\nint binS(int node)\n{\n    int mid, left = 0, right = G[node].size() - 1, sol = -1;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check2(mid, node))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    return sol;\n}\nvoid DFS(int node, int father)\n{\n    if(ok == 0)\n        return;\n    int cnt = 0;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father || neighb == 0)\n            continue;\n        DFS(neighb, node);\n        ++cnt;\n    }\n\n    for(auto it = G[node].begin(); it != G[node].end(); it = next(it))\n    {\n        if(*it == father)\n        {\n            G[node].erase(it);\n            break;\n        }\n\n    }\n    if(node != 1)\n    {\n        if(G[node].size() % 2 == 0)\n        G[node].push_back(0);\n    if(cnt == 0)\n    {\n        DP2[node] = 1;\n        return;\n    }\n    sort(G[node].begin(), G[node].end(), cmp);\n    int p = binS(node);\n    if(p == -1)\n    {\n        ok = 0;\n        return;\n    }\n    DP2[node] = DP2[G[node][p]] + 1;\n    }\n    else\n    {\n        sort(G[node].begin(), G[node].end(), cmp);\n        if(G[node].size() % 2 == 1)\n        {\n            int p = binS(node);\n            if(p == -1)\n            {\n                ok = 0;\n                return;\n            }\n        }\n        else\n        {\n            int left = 0, right=  G[node].size() - 1;\n            while(left < right)\n            {\n\n                if(DP2[G[node][left]] + DP2[G[node][right]] > aux)\n                {\n                    ok = 0;\n                    break;\n                }\n                left++;\n                right--;\n            }\n        }\n    }\n\n}\nbool check(int B)\n{\n    aux = B;ok = 1;\n    DFS(1, -1);\n    return ok;\n}\nvoid binS2()\n{\n    int left = 1, right = N, mid, sol = N;\n    while(left <= right)\n    {\n        mid = (left+ right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << a / 2 << \" \" << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    binS2();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            s.insert(dp[a[x][i]]+1);\n    bool flag=0;\n    if((s.size()+(x==1))%2==1)\n        flag=1;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        if(t>maxl)\n            return 0;\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==1)\n                return 0;\n            flag=1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    else\n        dp[x]=0;\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector <int> G[100005];\npair <long long, long long> DP[2][100005];\nlong long DP2[100005];\nint aux;\nbool ok;\nint a = 0;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    for(int i = 1; i <= N; i++)\n        if(G[i].size() % 2 == 1)\n            a++;\n}\ninline bool cmp(int a, int b)\n{\n    return DP2[a] < DP2[b];\n}\nbool check2(int pos, int node)\n{\n    int left = 0, right=  G[node].size() - 1;\n    while(left < right)\n    {\n        if(left == pos)\n        {\n            left++;\n            continue;\n        }\n        if(right == pos)\n        {\n            right--;\n            continue;\n        }\n        if(DP2[G[node][left]] + DP2[G[node][right]] > aux)\n            return 0;\n        left++;\n        right--;\n    }\n    int add = 0;\n    if(node == 1)\n        add = 1;\n    if(DP2[G[node][pos]] + 1 > aux + add)\n        return 0;\n    return 1;\n}\nint binS(int node)\n{\n    int mid, left = 0, right = G[node].size() - 1, sol = -1;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check2(mid, node))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    return sol;\n}\nvoid DFS(int node, int father)\n{\n    if(ok == 0)\n        return;\n    int cnt = 0;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father || neighb == 0)\n            continue;\n        DFS(neighb, node);\n        ++cnt;\n    }\n\n    for(auto it = G[node].begin(); it != G[node].end(); it = next(it))\n    {\n        if(*it == father)\n        {\n            G[node].erase(it);\n            break;\n        }\n\n    }\n\n    if(G[node].size() % 2 == 0)\n        G[node].push_back(0);\n    if(cnt == 0)\n    {\n        DP2[node] = 1;\n        return;\n    }\n    sort(G[node].begin(), G[node].end(), cmp);\n    int p = binS(node);\n    if(p == -1)\n    {\n        ok = 0;\n        return;\n    }\n    DP2[node] = DP2[G[node][p]] + 1;\n}\nbool check(int B)\n{\n    aux = B;ok = 1;\n    DFS(1, -1);\n    return ok;\n}\nvoid binS2()\n{\n    int left = 1, right = N, mid, sol = N;\n    while(left <= right)\n    {\n        mid = (left+ right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << a / 2 << \" \" << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    binS2();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100009;\nint root, n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!fa && !s.empty()) {\n\t\tif (*s.begin() > limit) return -1;\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(root, 0) == -1) return 0;\n\treturn need == ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++) if (e[i].size() == 1) root = i;\n\tdfs1(root, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans_a, ans_b;\n\t\n\tvoid write () {\n\t\tcout << ans_a << ' ' << ans_b << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint root;\n\t\tint mxl;\n\t\t\n\t\tint rec (int v, int pr) {\n\t\t\tvi q;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint val = rec(to, v);\n\t\t\t\tif (val == -1 || val + 1 > mxl) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tq.pb(val + 1);\n\t\t\t}\n\t\t\tsort(all(q), greater<int>());\n\t\t\t\n\t\t\tif (!sz(q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint val0 = q[0];\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tq[0] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (j < sz(q) && (j <= i || q[j] == -1 || q[i] + q[j] > mxl)) {\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tif (j < sz(q)) {\n\t\t\t\t\tassert(q[i] != -1);\n\t\t\t\t\tassert(q[j] != -1);\n\t\t\t\t\tq[i] = q[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvi qq;\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tqq.pb(val0);\n\t\t\t}\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] != -1) {\n\t\t\t\t\tqq.pb(q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sz(qq) == 2 && qq[0] + qq[1] <= mxl) {\n\t\t\t\tqq.clear();\n\t\t\t}\n\t\t\t\n\t\t\tif (sz(qq) == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (sz(qq) == 1) {\n\t\t\t\treturn qq[0];\n\t\t\t} else if (sz(qq) == 2) {\n\t\t\t\treturn qq[1];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\n\t\tbool check (int val) {\n\t\t\tmxl = val;\n\t\t\treturn rec(root, -1) != -1;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\troot = 0;\n\t\t\twhile (sz(e[root]) > 1) {\n\t\t\t\troot++;\n\t\t\t}\n\t\t\t\n\t\t\tans_a = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tif (sz(e[i]) & 1) {\n\t\t\t\t\tans_a++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_a /= 2;\n\t\t\t\n\t\t\tumx(ans_a, 1);\n\t\t\t\n\t\t\tint lb = 0, rb = 1000000000;\n\t\t\twhile (lb < rb) {\n\t\t\t\tint md = (lb + rb) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\trb = md;\n\t\t\t\t} else {\n\t\t\t\t\tlb = md + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_b = lb;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nint N, A, B;\nvi adj[NMAX];\n\n\nint findA(int u, int p){\n    int res = adj[u].size()/2;\n    if(u != 0 and adj[u].size() % 2 == 0) res --;\n    for(int v : adj[u]) if(v != p) res += findA(v, u);\n    return res;\n}\n\nint check(vi &v, int excl){\n    for(int i = 0, j = v.size()-1; i < j; i++, j--){\n        if (i == excl) i++;\n        if (j == excl) j--;\n        if(v[i] + v[j] > B) return false;\n    }\n    return true;\n}\n\nint leastUp(int u, int p){\n    vi vals;\n    for(int v : adj[u]) if (v != p) vals.pb(leastUp(v, u));\n    if(vals.size() == 0) return 1;\n    if(vals.size()%2 == 0) {\n        if( u == 0 ){\n            sort(vals.begin(), vals.end());\n            for(int i = 0, j = vals.size()-1; i < j; i++, j--) if(vals[i] + vals[j] > B) return B+1;\n            return 0;\n        }\n        \n        vals.pb(0);\n    }\n    sort(vals.begin(), vals.end());\n    if(vals.back() > B) return B+1;\n    int lb = -1, rb = vals.size()-1;\n    while(lb+1 != rb) {\n        int mb = (lb+rb)/2;\n        if(check(vals, mb)) rb = mb;\n        else lb = mb;\n    }\n    //cout << \"leastUp \" << u << \": \" << vals[rb]+1 << endl;\n    return vals[rb]+ (u != 0);\n}\n\nint ok(int b){\n    B = b;\n    //cout << \"B = \" << b << endl;\n    int l = leastUp(0, 0);\n    return l <= B;\n}\n\nsigned main(){\n    fast_io();\n    cin >> N;\n    adj[0].pb(0);\n    FOR(i, 0, N-1){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n    A = findA(0, 0);\n    int lb = 0, rb = N;\n    while(lb + 1 != rb) {\n        int mb = (lb+rb)/2;\n        if(ok(mb)) rb = mb;\n        else lb = mb;\n    }\n\n    cout << A << \" \" << rb << endl; \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n), cnt(n);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        int ch = 0;\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] += dp[u];\n            ch += 1;\n        }\n        dp[x] -= ch / 2;\n        if (ch % 2 == 0 && x != 0) dp[x]++;\n    };\n\n    Dfs(0, -1);\n    int A = dp[0], B = n + 1;\n\n    auto Check = [&](int v) {\n        constexpr int kInf = 1'000'000'000;\n        function<void(int, int)> Dfs = [&](int x, int p) {\n            multiset<int> s;\n            dp[x] = kInf;\n            cnt[x] = 0;\n            for (int u : g[x]) {\n                if (u == p) continue;\n                Dfs(u, x);\n                if (dp[u] > v) return;\n                s.insert(dp[u]);\n                cnt[x] += cnt[u];\n            }\n            if (s.size() & 1) {\n                int z = kInf;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        z = min(z, r);\n                    } else {\n                        s.erase(prev(it));\n                        cnt[x]--;\n                    }\n                }\n                dp[x] = z;\n                if (x != 0) dp[x]++;\n                if (dp[x] > v) {\n                    dp[x] = kInf;\n                    return;\n                }\n            } else {\n                auto f = s;\n                bool ok = true;\n                int kc = cnt[x], z = kInf;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        z = min(z, r);\n                    } else {\n                        cnt[x]--;\n                        s.erase(prev(it));\n                    }\n                }\n                if (z + 1 > v && x > 0) {\n                    dp[x] = 1;\n                    cnt[x]++;\n                } else {\n                    dp[x] = z + 1;\n                }\n                // cnt[x] = kc;\n                // auto it = f.upper_bound(x == 0 ? v : v - 1);\n                // if (it == f.begin()) return;\n                // dp[x] = *prev(it);\n                // if (x != 0) dp[x]++;\n                // f.erase(prev(it));\n                // int z = -1;\n                // while (!f.empty()) {\n                    // int r = *f.rbegin();\n                    // f.erase(f.find(r));\n                    // auto it = f.upper_bound(v - r); \n                    // if (it == f.begin()) {\n                        // ;\n                    // } else {\n                        // f.erase(prev(it));\n                        // cnt[x]--;\n                    // }\n                // }\n            }\n            // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n            // printf(\"cnt[%d] = %d\\n\", x + 1, cnt[x]);\n        };\n        // printf(\"Check v = %d\\n\", v);\n        Dfs(0, -1);\n        // printf(\"cnt = %d dp = %d\\n\", cnt[0], dp[0]);\n        return cnt[0] == A && dp[0] != kInf;\n    };\n\n    for (int d = 20; d >= 0; --d) {\n        if (B - (1 << d) <= 0) continue;\n        if (Check(B - (1 << d))) B -= (1 << d);\n    }\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define ii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n\nconst int N = 1e5 + 10;\nconst int  oo = 1e9;\n\nint n, A, cur ,nex;\nvector<int> vi[N];\nbool kt[N];\n\nvoid findA(int u, int pre){ // return the\n    int cnt = 0;\n    for(int v: vi[u])   if(v != pre)    {\n        findA(v, u);\n        cnt ++;\n    }\n    A += cnt / 2;\n    if(u == 1 && cnt % 2 == 1) A ++;\n    return;\n}\nint dfs(int pre, int u)    {\n    multiset<int> st;\n\n    for(int v: vi[u])   if(v != pre)    {\n        int tmp = dfs(u, v);\n        st.insert(tmp + 1);\n    }\n    vector<int> rem;\n    while(st.size() > 0)    {\n        std::multiset<int>::iterator it = st.end(); it --;\n        int x = (*it);\n        st.erase(it);\n\n        it = upper_bound(st.begin(), st.end(), cur - x);\n        if(it == st.begin())    {\n            rem.pb(x);\n        }else {\n            --it; st.erase(it);\n            nex ++;\n        }\n    }\n\n    reverse(rem.begin(), rem.end());\n    while(rem.size() > 0 && rem.back() == cur)  nex++, rem.pop_back();\n    if(rem.size() > 0)  {\n        nex += rem.size() - 1;\n        return rem[0];\n    }\n    return 0;\n}\n\nbool check()    {\n    nex = 0;\n    nex += dfs(1, 1) > 0;\n    return nex <= A;\n}\n\nsigned main() {\n    //freopen(\"test.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    FOR(i, 1, n - 1)    {\n        int x, y; cin >> x >> y;\n        vi[x].pb(y);\n        vi[y].pb(x);\n    }\n    findA(1, 1);\n    int l = 0, r = n;\n    while(r > l)    {\n        cur = ( l + r) / 2;\n        if(check()) r = cur;\n        else l = cur + 1;\n    }\n\n    cout << A << ' ' << l;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tif(t.back()>h)return inf;\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(!a&&t.size()%2==0)return out;\n\tif(t.size()%2==0){\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=-1,r=t.size()-1;\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tif(f(t,r))cmin(out,t[r]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n-1;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\nint dp[100009];\nint m;\n\nbool solve(int v, int p) {\n    vector<int> a;\n    if((int)G[v].size() & 1) a.push_back(0);\n    for(int u : G[v]) {\n        if(u == p) continue;\n        if(!solve(u, v)) return false;\n        if(dp[u] != -1) a.push_back(dp[u] + 1);\n    }\n    sort(ALL(a));\n    int sz = (int)a.size();\n    if(sz & 1) {\n        int ng = -1, ok = sz;\n        while(ok - ng > 1) {\n            int x = (ng + ok) >> 1;\n            int i = 0, j = sz - 1;\n            bool b = true;\n            while(i < j) {\n                if(i == x) i++;\n                if(j == x) j--;\n                if(a[i] + a[j] > m) {\n                    b = false;\n                    break;\n                }\n                i++;\n                j--;\n            }\n            (b ? ok : ng) = x;\n        }\n        if(ok == sz) return false;\n        dp[v] = a[ok];\n        return true;\n    } else {\n        rep(i, sz) if(a[i] + a[sz - 1 - i] > m) return false;\n        dp[v] = -1;\n        return true;\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    int ans = 0;\n    rep(i, n) ans += (int)G[i].size() & 1;\n    cout << ans / 2 << \" \";\n    int ng = 0, ok = n;\n    while(ok - ng > 1) {\n        m = (ng + ok) >> 1;\n        (solve(0, -1) ? ok : ng) = m;\n    }\n\n    cout << ok << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n#include<cassert>\n#include<set>\nstd::multiset<int> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int mid)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,mid)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>mid)return 0;\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\ts.clear();\n\t\tif(deg[o]&1)++cnt,s.insert(0);\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)++cnt,s.insert(f[e[p].to]+1);\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tint val=*s.rbegin();\n\t\t\ts.erase(s.find(val));\n\t\t\tif(*s.begin()+val>mid)return 0;\n\t\t\tstd::multiset<int>::iterator pl=s.upper_bound(mid-val);\n\t\t\t--pl;\n\t\t\ts.erase(pl);\n\t\t\tcnt-=2;\n\t\t}\n\t\tassert(s.size()==1);\n\t\tf[o]=*s.begin();\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,1,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(3);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun>=sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else\n            ind=high;\n    dp[n]=X[ind].first+1;\n    if(dp[n]>mid){\n        ok=-1000000000;\n        dp[n]=1000000000;\n    }\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n    for(int i=1;i<=n;++i){\n        if(V[i].size()%2) ++all;\n    }\n    all=all/2;\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    ans=all;\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]!=1000000000){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]!=1000000000){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n        if (dp[u]+1>k){\n            p1=1;\n            return ;\n        }\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n   vector <int> y;\n    while(s.size()>1){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n            if (y.size()){\n                p1=1;\n                break;\n            }\n            else{\n                y.pb(val1);\n                continue;\n            }\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()){\n        y.pb(*s.begin());\n    }\n    if (y.size()>1){\n        p1=1;\n        return ;\n    }\n    if (y.size()){\n        dp[v]=y[0];\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint B, r;\nint a[100001];\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) return v[i];\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\tB = n;\n\tif (f(1, 1)) r++;\n\ttr = r;\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tif (f(1, 1)) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrt(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-15;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\n// 問題文の解読をすると、「A個の長さB以下のパスで頂点を埋め尽くしてください」となります\n// 取り敢えずB=∞としてAを考えます。パス1個は一筆書きです。\n// よって、奇数次数の頂点の数/2がAの最小値になります。\n// Aが決まったので、Bを考えます。\n// パスの組み合わせがつらい＋Bの「「「最小値」」」なので二分探索を。これでO(logN)を犠牲にBも固定できます。\n// A,Bを固定して作れるかの判定ですが、木DPといいますかDFSといいますかみたいので解けます。\n// 適当に根を決めてDFS関数を走らせるのですが、返すのは「その点を通過する、その点を根とする部分木を端点とするあるパスの長さ」です。\n// で、関数内の処理ですが、子の頂点の結果は全部パスの長さで、これらを内部でつなぎ合わせて1本だけ上に伸ばしたいです。\n// ここで、子の数が偶数なら、またその時に限り「部分木の根は必ずパスの端点」です。\n// で、子の結果を上手く組み合わせますが、子が奇数個の時を考えます。\n//\t奇数個の時は、一つ（短いほうが嬉しい）だけ上に伸ばして、後は内部で組み合わせます。\n//\tただ、そもそも可能か調べたいので、一番大きな辺以外を組み合わせて大丈夫か調べます。\n//\t組み合わせは貪欲に左端と右端を組み合わせたのが最適です。\n//\tこれを通過したら、次に大きな辺、その次、…と行きたいですが、愚直にやるとTLEします。で、さっき調べたものとどこが違うかを考えます。\n//\t最初はa[0]とa[-2]、a[1]とa[-3]、…で、次はa[0]とa[-1]、a[1]とa[-3]で、以降全く同じです。\n//\tということで、次はa[0]+a[-1]<=mを判定してTrueならa[-2]を抜いても成立することになります。\n//\tその次も同様に考えると、a[1]+a[-2]<=m…という感じで進んでいきます。\n//\tが、子は奇数個なので、真ん中で処理が変わります。真ん中=(cとします)を抜いた時とその1個前を抜いた時のdiffで必要なのはa[c-1]+a[c+1]<=mです。\n//\tその後もずっと続いてa[1]+a[-1]<=mが成立すればa[0]を使っていいので、そのパスの長さ+1(部分木から1伸びるので)\n// 子が偶数個なら、根も使わなくてはならないので、それ=0を加えると奇数の場合に帰着できます。\n// で、判定ができたので、解けます。冗長かつ難解な解説でごめんなさい…\n\nint n;\nvint edge[100010];\n\nint solve(int cur, int parent, int m) {\n\t// 子供の結果が欲しい\n\tvint v;\n\trep(i, edge[cur].size()) {\n\t\tif (edge[cur][i] == parent)\tcontinue;\n\t\tint ret = solve(edge[cur][i], cur, m);\n\t\tif (ret == -1)\treturn -1;\n\t\tv.push_back(ret);\n\t}\n\t// 奇数次なら自分自身=0のパスを追加します。\n\tif (edge[cur].size() & 1)\tv.push_back(0);\n\t// 別に区別つけなくていいよね。ってことでソート\n\tsort(all(v));\n\t// 根なら別に細かいこと考えなくていいので。\n\tif (parent == -1) {\n\t\tfor (int i = 0; i < v.size() - i - 1; i++) {\n\t\t\tif (v[i] + v[v.size() - i - 1] > m)\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\t// 一番大きなv[v.size()-1]を除いてダメならダメ\n\t\tfor (int i = 0; i < (v.size() - 1) >> 1; i++) {\n\t\t\tif (v[i] + v[v.size() - i - 2] > m)\treturn -1;\n\t\t}\n\t\t// 後ろから見て駄目な箇所を探す。それを除くと以降の整合性は取れる。\n\t\tfor (int i = v.size() - 1; i > v.size() - 1 - i; i--) {\n\t\t\tif (v[i] + v[v.size() - 1 - i] > m)\treturn v[i] + 1;\n\t\t}\n\t\tfor (int i = (v.size() - 1) >> 1; i > 0; i--) {\n\t\t\tif (v[i] + v[v.size() - i] > m)\treturn v[i] + 1;\n\t\t}\n\t\treturn v[0] + 1;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint a, b;\tcin >> a >> b;\ta--;\tb--;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tint A = 0;\n\trep(i, n)\tA += (edge[i].size() & 1);\n\tA >>= 1;\n\tint left = 0, right = n;\n\trep(i, 100) {\n\t\tint mid = (left + right) >> 1;\n\t\tif (solve(0, -1, mid) == -1)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\tcout << A << \" \" << right << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nint n;\nvector<int> G[100100];\nint root;\n\nint calc2(vector<int>& c, int k) {\n    int L = (int)c.size();\n    int lb = -1, ub = L;\n    while (ub - lb > 1) {\n        int mid = (lb + ub) / 2;\n        int max_len = 0;\n        int l = 0, r = L-1;\n        while (true) {\n            if (l == mid) l++;\n            if (r == mid) r--;\n            if (l >= r) break;\n            max_len = max(max_len, c[l] + c[r]);\n            l++;\n            r--;\n        }\n        if (max_len <= k) {\n            ub = mid;\n        } else {\n            lb = mid;\n        }\n    }\n    return (ub == L ? inf : c[ub]+1); \n}\n\nint calc(int v, int p, int k) {\n    vector<int> c;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        int u = G[v][i];\n        if (u != p) {\n            c.push_back(calc(u, v, k));\n        }\n    }\n    int L = (int)c.size();\n    if (L == 0) return 1;\n    sort(ALL(c));\n    if (L % 2 == 0) {\n        int max_len = 0;\n        for (int i = 0; i < L / 2; i++) {\n            max_len = max(max_len, c[i] + c[L-i-1]);\n        }\n        if (max_len <= k) return 1;\n        if (c[L-1] > k) return inf;\n        c.pop_back();\n        return calc2(c, k);\n    } else {\n        return calc2(c, k);\n    }\n}\n\nbool check(int k) {\n    return calc(root, -1, k) <= k+1;\n}\n\nvoid solve() {\n    int num_odd;\n    root = -1;\n    for (int i = 0; i < n; i++) {\n        int d = (int)G[i].size();\n        if (d % 2 == 1) {\n            num_odd++;\n            if (root < 0 && d == 1) root = i;\n        }\n    }\n\n    int lb = 0, ub = n;\n    while (ub - lb > 1) {\n        int mid = (lb + ub) / 2;\n        if (check(mid)) {\n            ub = mid;\n        } else {\n            lb = mid;\n        }\n    }\n    cout << num_odd / 2 << \" \" << ub << endl;\n}\n\nvoid input() {\n    cin >> n;\n    int a, b;\n    for (int i = 0; i < n-1; i++) {\n        cin >> a >> b;\n        a--; b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector< int > g[100000];\nint dp[100001];\n\nint rec(int idx, int ptr, int limited)\n{\n  dp[idx] = 0;\n\n  deque< int > connect;\n  for(auto &to : g[idx]) {\n    if(to == ptr) continue;\n    connect.emplace_back(rec(to, idx, limited) + 1);\n    dp[idx] += dp[to];\n  }\n\n  sort(begin(connect), end(connect));\n\n  while(!connect.empty() && connect.front() + connect.back() > limited) {\n    connect.pop_back();\n    ++dp[idx];\n  }\n\n  int odd = 0;\n  if(connect.size() % 2 == 1) {\n    odd = connect.front();\n    connect.pop_front();\n  }\n\n  dp[idx] += connect.size() / 2;\n\n  return (odd);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  if(rec(0, -1, 1145141919) != 0) dp[0]++;\n  int beet = dp[0];\n\n  auto check = [&](int v)\n  {\n    int result = rec(0, -1, v);\n    if(result != 0) dp[0]++;\n    return (dp[0] == beet);\n  };\n\n  int low = N, high = -1;\n  while(low - high > 1) {\n    int mid = (low + high) / 2;\n    if(check(mid)) low = mid;\n    else high = mid;\n  }\n\n  cout << beet << \" \" << low << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int> > edges;\n\nvector<int> dp;\n\nint dfs(int now, int from, int len)\n{\n    multiset<int> l;\n\n    for (auto v : edges[now]) if (v != from)\n    {\n        if (dfs(v, now, len)) return 1;\n        l.insert(dp[v]);\n    }\n    if (!(l.size() % 2)) l.insert(0);\n\n    vector<int> rem;\n    while (!l.empty())\n    {\n        int t = *(--l.end());\n        l.erase(--l.end());\n        if (l.empty())\n        {\n            rem.push_back(t);\n            break;\n        }\n        auto itr = l.upper_bound(len - t);\n        if (itr == l.begin()) rem.push_back(t);\n        else l.erase(--itr);\n    }\n    if (rem.size() > 1) return 1;\n\n    dp[now] = rem[0] + 1;\n    return 0;\n}\n\nbool isAble(int b)\n{\n    dp = vector<int>(N, -1);\n    if (dfs(0, -1, b) || dp[0] > b+1 || (edges[0].size() % 2 == 0 && dp[0] > 1)) return false;\n    return true;\n}\n\nint main()\n{\n    cin >> N;\n    edges.resize(N);\n    for (int i=0; i<N-1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    int A = 0;\n    for (int i=0; i<N; i++) if ((int)edges[i].size() & 1) A++;\n    A /= 2;\n\n    cout << A << \" \";\n\n    int l = 0, r = N-1;\n    while (r - l >1)\n    {\n        int c = (l + r) / 2;\n        if (isAble(c)) r = c;\n        else l = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint n; \nconst int INF = int(1e9);\nconst int N = 123456;\nii dp[N];\nvi adj[N];\n\nint threshold;\n\nvoid dfs(int u, int p=-1)\n{\n\tint sum = 0;\n\tdeque<int> V;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\tsum+=dp[v].fi;\n\t\tV.pb(dp[v].se);\n\t}\n\tsort(V.begin(),V.end());\n\twhile(!V.empty()&&V.back()>=threshold)\n\t{\n\t\tV.pop_back(); V.push_front(0); sum++;\n\t}\n\tint mnup=INF;\n\twhile(!V.empty())\n\t{\n\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t{\n\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t}\n\t\tif(V.back()+1<=threshold)\n\t\t{\n\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t}\n\t}\n\tdp[u] = mp(sum,mnup);\n\t//cerr<<threshold<<\" | \"<<u<<' '<<sum<<' '<<mnup<<'\\n';\n}\n\nint calc(int C)\n{\n\tthreshold=C;\n\tdfs(0,-1); \n\treturn dp[0].fi;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tint bestres = calc(n+1);\n\tint lo=1; int hi=n;\n\tint ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint v=calc(mid);\n\t\tif(v<=bestres)\n\t\t{\n\t\t\tans=mid; hi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tcout<<bestres<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvector<int> g[100005];\n\nint dfs(int m, int d, int from){\n  vector<int> ch;\n  for(auto to : g[d]) if(to!=from){\n    int r = dfs(m, to ,d);\n    if(r > m) return INF;\n    ch.pb(r);\n  }\n  // dbg(m,d,ch);\n  int sz = ch.size();\n  if(sz==0) return 1;\n  if(sz==1) return ch[0]+1;\n\n  sort(all(ch));\n  auto check = [&](int mid){\n    int l = 0, r = sz-1;\n    while(l<r){\n      if(l==mid) l++;\n      if(r==mid) r--;\n      if(l>=r) break;\n      if(ch[l]+ch[r] > m) return false;\n      l++;\n      r--;\n    }\n    return true;\n  };\n  if(sz%2==0){\n    if(check(-1)) return 1;\n    else sz--;\n  }\n\n  if(check(0)) return ch[0]+1;\n  if(!check(sz-1)) return INF;\n  int l = 0, r = sz-1;\n  while(r-l>1){\n    int mid = (l+r)/2;\n    if(check(mid)) r = mid;\n    else l = mid;\n  }\n  return ch[r]+1;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n\n  int a = 1;\n  rep(i,n) a += (g[i].size()-1)/2;\n\n  int d = 0;\n  while(g[d].size()!=1) d++;\n\n  int l = 0, r = n;\n  while(r-l>1){\n    int m = (r+l)/2;\n    if(dfs(m, d, -1) <= m+1) r = m;\n    else l = m;\n  }\n\n  cout << a << \" \" << r << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nconst int N = 100050;\nint pre[N], nxt[N * 2], to[N * 2], cnt;\ninline void addEdge(int x, int y) {\n  nxt[cnt] = pre[x];\n  to[pre[x] = cnt++] = y;\n  nxt[cnt] = pre[y];\n  to[pre[y] = cnt++] = x;\n}\nint tmp[N * 7];\nint d[N];\nint B;\nint vis[N], time;\nbool check(int x, int fa, int *tmp, int &pp) {\n  int ss = d[x] + 1;\n  int l = 0;\n  if (d[x] & 1) tmp[l++] = 0;\n  for (int i = pre[x]; ~i; i = nxt[i]) if (to[i] != fa) {\n    int p = 0;\n    if (!check(to[i], x, tmp + ss, p)) return false;\n    if (p) tmp[l++] = p;\n  }\n  std::sort(tmp, tmp + l);\n  if (tmp[l - 1] > B) return false;\n  int i = l - 1, j = 0;\n  ++time;\n  while (i > j) {\n    while (j > 0 && (vis[j] == time || tmp[i] + tmp[j] > B)) --j;\n    while (j < i - 1 && (vis[j] == time || tmp[j + 1] + tmp[i] <= B)) ++j;\n    vis[i] = vis[j] = time;\n    --i;\n  }\n  if (~l & 1) return true;\n  j = 0;\n  while (vis[j] == time) ++j;\n  pp = j;\n  return true;\n  return false;\n}\nint main() {\n  int n, x, y;\n  scanf(\"%d\", &n);\n  memset(pre, -1, sizeof pre);\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addEdge(x, y);\n    ++d[x]; ++d[y];\n  }\n  int l = 0;\n  for (int i = 1; i <= n; ++i)\n    l += (d[i] & 1);\n  l /= 2;\n  printf(\"%d\\n\", l);\n  int ll = 1, rr = n * 2, xxx;\n  while (ll < rr) {\n    int mid = (ll + rr) / 2;\n    if (B = mid, check(1, 0, tmp, xxx)) rr = mid;\n    else ll = mid + 1;\n  }\n  printf(\"%d\\n\", ll);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    vector<int> tmp;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n        tmp.push_back(t + 1);\n    }\n\n    if((p == -1) ^ (st.size() % 2)) {\n        for(int i = 0; i < (int)tmp.size() - 1; i++) {\n            if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n        }\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return v;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, cnt;\nint f[N];\nint sum[N];\nbool flag;\nvector<int> G[N];\n\nvoid dfs(int u, int p, int x) {\n\tvector<int> go;\n\tfor (auto v : G[u]) {\n\t\tif (v == p) continue;\n\t\tdfs(v, u, x), go.push_back(f[v] + 1);\n\t}\n\tint sz = go.size();\n\tcnt += sz / 2;\n\tif (sz % 2 == 0) go.push_back(0), sz++;\n\telse if (u == 1) cnt++;\n\tsort(go.begin(), go.end());\n\t// bubbletea prevoi 2017\n\tfor (int i = 0; i < sz; ++i) sum[i] = 0;\n\tfor (int i = 0; i <= sz / 2; ++i) {\n        if (i < sz - i - 2 && sz - i - 2 < sz) {\n            if (go[i] + go[sz - i - 2] > x) sum[sz - i - 1]++;\n        }\n        if (i < sz - i - 1 && sz - i - 1 < sz) {\n            if (go[i] + go[sz - i - 1] > x) sum[i + 1]++, sum[sz - i - 1]--;\n        }\n        if (i < sz - i && sz - i < sz) {\n            if (go[i] + go[sz - i] > x) sum[0]++, sum[i]--;\n        }\n\t}\n\tfor (int i = 1; i < sz; ++i) sum[i] += sum[i - 1];\n\tfor (int i = 0; i < sz; ++i) {\n\t\tif (!sum[i] && go[i] <= x) { f[u] = go[i]; return; }\n\t}\n\tflag = 1;\n}\n\nint check(int x) {\n\tflag = cnt = 0, dfs(1, 1, x); \n\treturn (!flag) ? cnt : 0;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tint l = 1, r = n;\n\twhile (l < r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid; else l = mid + 1;\n\t}\n\tcout << check(l) << ' ' << l;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48; \n    return x *= f;\n}\n\nconst int N = 100000;\nint st[N + 5], to[(N << 1) + 5], nxt[(N << 1) + 5], e = 1;\n\ninline void addedge(int u, int v) {\n    to[++ e] = v; nxt[e] = st[u]; st[u] = e;\n    to[++ e] = u; nxt[e] = st[v]; st[v] = e;\n}\n\nstd::multiset<int> s;\ntypedef std::multiset<int> :: iterator sit;\n\nint LIM = N + 5;\nint f[N + 5], g[N + 5];\nvoid dfs(int u, int fa = 0) {\n    f[u] = g[u] = 0;\n    for(int i = st[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if(v != fa) dfs(v, u), f[u] += f[v];\n    }\n\n    s.clear();\n    for(int i = st[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if(v != fa) s.insert(g[v] + 1); \n    }\n    \n    int ret = oo;\n\n    while(s.size()) {\n        int x = (*s.rbegin());\n        sit it = s.upper_bound(LIM - x);\n\n        ++ f[u];\n        if(it == s.begin() || s.size() == 1) {\n            if(x < LIM) {\n                chkmin(ret, x);\n                s.erase(s.find(*s.rbegin()));\n            } else {\n                s.erase(s.find(*s.rbegin()));\n            }\n        } else {\n            -- it;\n            s.erase(s.find(*it));\n            s.erase(s.find(*s.rbegin()));\n        }\n    }\n    if(ret != oo && u > 1) g[u] = ret, -- f[u];\n\n}\n\nint x, y, n;\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    read(n);\n    for(int i = 1; i < n; ++i) {\n        read(x), read(y);\n        addedge(x, y);\n    }\n\n    dfs(1);\n    int A = f[1];\n\n    int L = 1, R = n;\n    while(L < R) {\n        LIM = (L + R) >> 1;\n\n        dfs(1);\n        if(f[1] > A) L = LIM + 1; else R = LIM;\n    }\n\n    printf(\"%d %d\\n\", A, R);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\td.insert(dfs(v)+1);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0;\n\trep(i, n) resa += (g[i].size()-1)/2;\n\tint lb = 0, ub = n-1;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(0);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resa+1<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt, lo, hi, mi, ta, tb;\nvector< int > v[100005];\nmultiset< int > mm;\nmultiset< int >::iterator it;\n\nint dfs(int a, int b) {\n\tmultiset< int > re = multiset< int >();\n\tfor (int i = 0; i < v[a].size(); i++)\n\t\tif (v[a][i] != b) {\n\t\t\tint tt = dfs(v[a][i], a);\n\t\t\tif (tt == -1 || tt + 1 > mi) {\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tre.insert(tt + 1);\n\t\t}\n\tint ret = 0;\n\t//printf(\"%d:\", a); for (it = re.begin(); it != re.end(); it++) printf(\" %d\", *it); printf(\"\\n\");\n\tmm = re;\n\twhile (!re.empty()) {\n\t\tit = re.end();\n\t\tit--;\n\t\tta = *it;\n\t\tre.erase(it);\n\t\tit = re.upper_bound(mi - ta);\n\t\tif (it == re.begin()) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = ta;\n\t\t\telse {\n\t\t\t\tif (mm.size() % 2 == 0) {\n\t\t\t\t\tre = mm;\n\t\t\t\t\tit = re.end();\n\t\t\t\t\tit--;\n\t\t\t\t\tre.erase(it);\n\t\t\t\t\tret = 0;\n\t\t\t\t\twhile (!re.empty()) {\n\t\t\t\t\t\tit = re.end();\n\t\t\t\t\t\tit--;\n\t\t\t\t\t\tta = *it;\n\t\t\t\t\t\tre.erase(it);\n\t\t\t\t\t\tit = re.upper_bound(mi - ta);\n\t\t\t\t\t\tif (it == re.begin()) {\n\t\t\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\t\t\tret = ta;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tre.clear();\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tit--;\n\t\t\t\t\t\t\tre.erase(it);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"ret %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tit--;\n\t\t\tre.erase(it);\n\t\t}\n\t}\n\t//printf(\"re %d\\n\", ret);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tv[ta].push_back(tb);\n\t\tv[tb].push_back(ta);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt += v[i].size() % 2;\n\tlo = 1, hi = n + 1;\n\twhile (lo < hi) {\n\t\tmi = (lo + hi) / 2;\n\t\t//printf(\"mi %d\\n\", mi);\n\t\tif (dfs(1, 0) != -1)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\tprintf(\"%d %d\\n\", cnt / 2, lo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint mx;\nint num;\n\nvoid pre(int v, int p)\n{\n\tint cnt = 0;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tpre(to, v);\n\t\t++cnt;\n\t}\n\n\tnum += (cnt / 2);\n\tif (p == -1) {\n\t\tif (cnt & 1) ++num;\n\t}\n}\n\nint dfs(int v, int p, int x)\n{\n\tvi vec;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tint u = dfs(to, v, x);\n\t//\tcout << \"DEBUG \" << to << \" \" << u << endl;\n\t\tif (u == -1 || u >= x) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(u + 1);\n\t}\n\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tmultiset<int> ss;\n\tfor (int x : vec) {\n\t\tss.insert(x);\n\t}\n\n\tint ng_cnt = 0;\n\tint val = -1;\n\n\twhile (ss.size() >= 2) {\n\t\tint a = *ss.rbegin();\n\t\tss.erase(ss.lower_bound(a));\n\t\tauto it = ss.upper_bound(x - a);\n\n\t\tif (v == 3) {\n\t\t//\tputs(\"wo\");\n\t\t}\n\n\t\tif (it == ss.begin()) {\n\t\t//\tif (v == 3) puts(\"f1\");\n\t\t\tif (ng_cnt > 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tng_cnt++;\n\t\t\tval = a;\n\t\t} else {\n\t\t\t//if (v == 3) puts(\"f2\");\t\t\t\n\t\t\t--it;\n\t\t\tss.erase(it);\n\t\t}\n\t}\n\n\t//ng_cnt <= 1, ss.size() <= 1\n\n\tif (p == -1) {\n\t\tif (sz & 1) {\n\t\t//\tcout << ng_cnt << \" \" << ss.size() << endl;\n\t\t\tif (ng_cnt + ss.size() > 1) {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tif (ng_cnt || ss.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ss.size() && ng_cnt) {\n\t\treturn min(*ss.begin(), val);\n\t} else if (ng_cnt) {\n\t\treturn val;\n\t} else if (ss.size()) {\n\t\treturn *ss.begin();\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nbool ok(int x)\n{\n\tint t = dfs(0, -1, x);\n\tcout << t << endl;\n\treturn (t != -1);\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tpre(0, -1);\n\n\tint lo = 0, hi = N;\n\tok(2);\n/*\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tcout << num << \" \" << hi << endl;*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int N=100001;\nint n,cnt,head[N],du[N];\nstruct xint{int to,next;}e[N*2];\nvoid addedge(int x,int y){\n\te[++cnt]=(xint){y,head[x]};head[x]=cnt;\n\te[++cnt]=(xint){x,head[y]};head[y]=cnt;\n\tdu[x]++;du[y]++;\n}\nint Mid,p[N],f[N],a[N];\nint top,stk[N];bool mk[N];\nbool Check(){\n\tref(i,1,p[0])mk[i]=0;\n\tint pos=1;top=0;\n\tdef(i,p[0],1)if(!mk[i]){\n\t\tif(pos>i)pos=i;\n\t\twhile(top>0&&stk[top]>=i)top--;\n\t\twhile(pos<i&&p[pos]+p[i]<=Mid)stk[++top]=pos,pos++;\n\t\tif(!top)return 0;\n\t\tmk[stk[top]]=1;top--;mk[i]=1;\n\t}\n\treturn 1;\n}\nbool check(int x){\n\ta[0]=0;\n\tref(i,1,p[0])if(i!=x)a[++a[0]]=p[i];\n\tif(a[0]&1)a[0]--;\n\tref(i,1,a[0])mk[i]=0;\n\tint pos=1;top=0;\n\tdef(i,a[0],1)if(!mk[i]){\n\t\tif(pos>i)pos=i;\n\t\twhile(top>0&&stk[top]>=i)top--;\n\t\twhile(pos<i&&a[pos]+a[i]<=Mid)stk[++top]=pos,pos++;\n\t\tif(!top)return 0;\n\t\tmk[stk[top]]=1;top--;mk[i]=1;\n\t}\n\treturn 1;\n}\nvoid dfs(int fa,int x){\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint y=e[i].to;if(y==fa)continue;dfs(x,y);\n\t}\n\tp[0]=0;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tp[++p[0]]=f[y]+1;\n\t\tif(p[p[0]]>Mid){f[x]=1e9;return;}\n\t}\n\tif(!p[0]){f[x]=0;return;}\n\tsort(p+1,p+p[0]+1);\n\tif(x==1&&!(p[0]&1)){\n\t\tif(!Check())f[x]=1e9;else f[x]=0;\n\t\treturn;\n\t}\n\tint l=1,r=p[0]+1;\n\twhile(l<r){\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))r=mid;else l=mid+1;\n\t}\n\tif(l==p[0]+1){f[x]=1e9;return;}\n\tf[x]=p[l];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tref(i,2,n){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t}\n\tint tot=0;\n\tref(i,1,n)if(du[i]&1)tot++;\n\tcout<<tot/2<<\" \";\n\tint L=1,R=n-1;\n\twhile(L<R){\n\t\tmemset(f,0,sizeof f);\n\t\tMid=(L+R)>>1;\n\t\tdfs(0,1);\n\t\tif(f[1]<=Mid)R=Mid;else L=Mid+1;\n\t}\n\tcout<<L<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 233366666\nusing namespace std;\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint deg[100005],head[100005],nxt[200005],v[200005];\nint dp[100005],n,tot=0,root=-1,tar;\ninline void add(int a,int b)\n{tot++;nxt[tot]=head[a];head[a]=tot;v[tot]=b;}\nvoid dfs(int pos,int f)\n{vector <int> vec;\nint sz=0,l,r,i,ts;\nfor (i=head[pos];i;i=nxt[i])\n{if (v[i]==f) continue;\ndfs(v[i],pos);sz++;\nvec.push_back(dp[v[i]]);\n}\nif (!(sz&1)) vec.push_back(0),sz++;\nsort(vec.begin(),vec.end());\nl=0;r=sz-1;\nts=sz>>1;\nwhile (l<=r)\n{int mid=(l+r)>>1,p1=0,p2=sz-1,tag=1;\nfor (i=1;i<=ts;i++)\n{if (p1==mid) p1++;\nif (p2==mid) p2--;\nif (vec[p1]+vec[p2]>tar) {tag=0;break;}\np1++;p2--;\n}\nif (tag) {r=mid-1;}\nelse {l=mid+1;}\n}\nif (l==sz) {dp[pos]=inf;}\nelse {dp[pos]=vec[l]+1;}\n}\ninline bool chk(int mid)\n{tar=mid;dfs(root,0);\nreturn (dp[root]<=mid+1);\n}\nint main (){\n\tint i,a,b,cnt=0;\n\tn=read();\n\tfor (i=1;i<n;i++)\n\t{a=read();b=read();\n\tadd(a,b);add(b,a);\n\tdeg[a]++;deg[b]++;\n\t}\n\tfor (i=1;i<=n;i++)\n\t{if (deg[i]&1)\n\t{cnt++;root=i;}\n\t}\n\tcnt>>=1;\n\tint l=1,r=n;\n\twhile (l<=r)\n\t{int mid=(l+r)>>1;\n\tif (chk(mid)) {r=mid-1;}\n\telse {l=mid+1;}\n\t}\n\tprintf (\"%d %d\\n\",cnt,l);\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n;\nvector<int> G[100009];\n\nint A, B;\n\nbool flag;\n\nint dfs(int v, int p) {\n    vector<int> vec;\n    for(int u : G[v])\n        if(p != u) {\n            vec.push_back(dfs(u, v) + 1);\n            if(vec.back() > B) flag = true;\n        }\n    if(flag) return 0;\n    sort(ALL(vec));\nx:;\n    if(vec.size() & 1) {\n        int ng = -1, ok = vec.size();\n        while(ng + 1 < ok) {\n            int mid = ng + ok >> 1;\n            int i = 0, j = vec.size() - 1;\n            while(i < j) {\n                if(mid == i) i++;\n                if(mid == j) j--;\n                if(vec[i] + vec[j] > B) {\n                    ng = mid;\n                    break;\n                }\n                i++;\n                j--;\n            }\n            if(ng != mid) ok = mid;\n        }\n        if(ok == (int)vec.size())\n            return flag = true;\n        else\n            return vec[ok];\n    } else {\n        bool ok = true;\n        rep(i, vec.size() - i) if(vec[i] + vec[n - i - 1] > B) ok = false;\n        if(ok) return 1;\n        vec.pop_back();\n        goto x;\n    }\n}\n\nbool isok() {\n    flag = false;\n    int x = dfs(0, -1);\n    if(flag) return false;\n    return x <= B;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    A = 0;\n    rep(i, n) A += G[i].size() % 2;\n\n    A /= 2;\n\n    int ng = 0, ok = n;\n    while(ng < ok - 1) {\n        B = ok + ng >> 1;\n        (isok() ? ok : ng) = B;\n    }\n\n    cout << A << \" \" << ok - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int nmax = 100010;\nint deg[nmax],dp[nmax];\nbool fix[nmax];\nvector < int > graph[nmax];\nint N,u;\nbool check2(int x,int B, vector<int>& kids)\n{\n\tint l = 0, r = kids.size() - 1;\n\tif((kids[x]+1) > B) return false;\n\twhile( l < r)\n\t{\n\t\tif(l == x) l++;\n\t\tif(r == x) r--;\n\t\tif(l >= r  || r < 0) return true;\n\t\tif((kids[l] + kids[r]+2 )> B) return false;\n\t\tl++,r--;\n\t}\n\treturn true;\n}\nbool dfs(int u, int x)\n{\n\tfix[u] = true;\n\tbool ret = true;\n\t//cout << \"in vertex \" << u << \" trying \" << x << endl;\n\tvector< int > kids;\n\tfor(int i = 0; i < graph[u].size(); ++i)\n\t{\n\t\tif(fix[graph[u][i]]) continue;\n\t\tret&=dfs(graph[u][i],x);\n\t\tkids.push_back(dp[graph[u][i]]);\n\t}\n\tif(!ret) return ret;\n\tbool isfake = false;\n\tif((kids.size()&1)==0){ isfake = true; kids.push_back(-1);}\n\tsort(kids.begin(), kids.end());\n\tint l = 0, r = kids.size() - 1;\n\t\n\t//cout << \"out to \" << u;\n\t//cout << \"\\n\\t\";\n\t//for(int i = 0 ; i < kids.size(); ++i)\n\t//\tcout << kids[i] << ' ';\n\t//cout << endl;\n\tbool isGood = check2(r, x, kids);\n\twhile((r - l) > 1)\n\t{\n\t\tint mid = (r+l) >> 1;\n\t\tif(check2(mid, x, kids))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\n\t}\n\tif(check2(l, x, kids)) r = l;\n\tif(!isGood) return false;\n\t//cout << \"\\tchose\" << kids[r] << endl;\n\tdp[u] = kids[r]+1;\n\treturn true;\n}\nbool check(int x)\n{\n\tfor(int i = 1;i<=N;++i)dp[i]=N,fix[i]=false;\n\treturn dfs(u,x);\n}\nint bs()\n{\n\tint l = 1, r = N-1;\n\twhile((r-l) > 1)\n\t{\n\t\tint mid = (l+r) >> 1;\n\t\tif(check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\t//cout << l << ' ' << r << ' ' << mid << endl;\n\t}\n\tif(check(l))\n\t\treturn l;\n\treturn r;\n\n}\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0 ;i < N-1;++i)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tint A=0,B=0;\n\tfor(int i = 1;i<=N;++i)\n\t{\n\t\tif(deg[i]&1) A++;\n\t\tif(deg[i] == 1) u = i;\n\t}\n\tA = (A+1)/2;\n\tcout << A << ' ' << bs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define ii pair<int, int>\n#define fi first\n#define se second\n#define pb push_back\n\nconst int N = 1e5 + 10;\nconst int  oo = 1e9;\n\nint n, A, cur, nex;\nvector<int> vi[N];\nint rem[N];\n\nvoid findA(int u, int pre){ // return the\n    int cnt = 0;\n    for(int v: vi[u])   if(v != pre)    {\n        findA(v, u);\n        cnt ++;\n    }\n    A += cnt / 2;\n    if(u == 1 && cnt % 2 == 1) A ++;\n    return;\n}\nint dfs(int pre, int u)    {\n    multiset<int> st;\n\n    for(int v: vi[u])   if(v != pre)    {\n        int tmp = dfs(u, v);\n        st.insert(tmp + 1);\n    }\n    int dem = 0;\n    while(st.size() > 0)    {\n        std::multiset<int>::iterator it = st.end(); it --;\n        int x = (*it);\n        st.erase(it);\n\n        it = upper_bound(st.begin(), st.end(), cur - x);\n        if(it == st.begin())    {\n            rem[++dem] = x;\n        } else {\n            --it; st.erase(it);\n            nex ++;\n        }\n    }\n\n    reverse(rem + 1, rem + 1 + dem);\n    while(dem > 0 && rem[dem] == cur)  nex++, dem --;\n    if(dem > 0) {\n        nex += dem - 1;\n        return rem[1];\n    }\n    return 0;\n}\n\nbool check()    {\n    nex = 0;\n    nex += dfs(1, 1) > 0;\n    return nex <= A;\n}\n\nsigned main() {\n    //freopen(\"test.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    FOR(i, 1, n - 1)    {\n        int x, y; cin >> x >> y;\n        vi[x].pb(y);\n        vi[y].pb(x);\n    }\n    findA(1, 1);\n    int l = 1, r = n;\n    while(r > l)    {\n        cur = ( l + r) / 2;\n        if(check()) r = cur;\n        else l = cur + 1;\n    }\n\n    cout << A << ' ' << l;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root,int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to,root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size(); cnt += len / 2;\n\tif (len % 2==0) {\n\t\tbool g = true;\n\t\trep(i, len / 2) {\n\t\t\tif (v[i] + v[len - i - 1] > c)g = false;\n\t\t}\n\t\tif (g)return 1;\n\t\telse {\n\t\t\tv.pop_back(); len--;\n\t\t}\n\t}\n\t\tmultiset<int> mt;\n\t\trep(i, len)mt.insert(v[i]);\n\t\trep(i, len / 2) {\n\t\t\tauto itr = mt.end(); itr--;\n\t\t\tint z = *itr; mt.erase(mt.find(z));\n\t\t\tint r = c - z;\n\t\t\tif (mt.count(r)) {\n\t\t\t\tmt.erase(mt.find(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt.insert(r);\n\t\t\t\tauto itr2 = mt.find(r);\n\t\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\titr2--; mt.erase(r);\n\t\t\t\tint zz = *itr2;\n\t\t\t\tif (zz + z > c) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\tmt.erase(itr2);\n\t\t\t}\n\t\t}\n\t\tint z = *mt.begin();\n\t\tif (z == c) {\n\t\t\tcnt++; z = 0;\n\t\t}\n\t\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa<<\" \"<<ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\n\ninline bool cmp(int a,int b){return F[a]<F[b];}\n\ninline bool dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tif(!dfs(vs[i].v,rt,x)) return false;\n\t\tv.push_back(vs[i].v);\n\t}\n\tif(v.size()==0){\n\t\tF[rt]=1;\n\t\treturn true;\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end(),cmp);\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tint tmp1=F[v[i]],tmp2=F[v[j]];\n\t\t\tfg&=(tmp1+tmp2)<=x;\n\t\t}\n\t\tif(fg) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l==n+1) return false;\n\tF[rt]=F[l]+1;\n\treturn F[rt]<=x+1;\n}\ninline bool check(int x)\n{\n\treturn dfs(Rt,0,x);\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tson.erase(son.begin()+r);\n\tfor (int i=0;i<son.size()/2;i++)\n\t{\n\t\tint j = son.size() - 1 - i;\n\t\tif (son[i] + son[j] > B) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size == 0)\n\t{\n\t\tdp[u] = 1;\n\t}\n\telse if (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n-1; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nvector<int> to[maxn];\nint lim;\nbool can;\nint solve(int cur, int par){\n\tvector<int> f;\n\tfor(int nxt : to[cur]){\n\t\tif(nxt == par) continue;\n\t\tf.push_back(solve(nxt, cur));\n\t}\n\tif(f.size() % 2 == 0) f.push_back(0);\n\tsort(f.begin(), f.end());\n\tint len = f.size();\n\tint lo = 0, hi = len - 1, ans = -1;\n\twhile(lo <= hi){\n\t\tint mid = (lo + hi)>>1;\n\t\tauto get = [&](int x){\n\t\t\tif(x >= mid) x++;\n\t\t\treturn f[x];\n\t\t};\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < (len - 1)/2; i++){\n\t\t\tint ri = (len - 2) - i;\n\t\t\tok &= get(i) + get(ri) <= lim;\n\t\t}\n\t\tif(ok) ans = mid, hi = mid - 1;\n\t\telse lo = mid + 1;\n\t}\n\tif(ans == -1){\n\t\tcan = false;\n\t\treturn 0;\n\t}\n\treturn f[ans] + 1;\n}\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tto[a].push_back(b);\n\t\tto[b].push_back(a);\n\t}\n\tint A = 0;\n\tfor(int i = 0; i < n; i++) A += to[i].size()%2;\n\tint leaf = -1;\n\tfor(int i = 0; i < n; i++) if(to[i].size() == 1) leaf = i;\n\tassert(~leaf);\n\tint lo = 1, hi = n - 1, ans = n;\n\twhile(lo <= hi){\n\t\tint mid = (lo + hi)>>1;\n\t\tlim = mid;\n\t\tcan = true;\n\t\tif(solve(leaf, -1) <= lim + 1 && can){\n\t\t\tans = mid;\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << A/2 << \" \" << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int up)\n{\n\tvector<int>son;\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, up))return false;\n\t\tif(dp[to] != -1)son.push_back(dp[to] + 1);\n\t}\n\tif (son.size() == 0)\n\t{\n\t\tdp[x] = 0;\n\t\treturn true;\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > up)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = -1;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\tint flag = 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tflag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > up)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (son[le] > up)return false;\n\t\tint i = 0;\n\t\tint j = son.size() - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (i == le)i++;\n\t\t\tif (j == le)j--;\n\t\t\tif (i<j)\n\t\t\t{\n\t\t\t\tif (son[i] + son[j] > up)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.begin();\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,-1));\n        if(ip==S.begin()){\n            break;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                break;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n   while(S.size()>1){\n    auto ip=S.end();--ip;\n    --ok;\n    S.erase(ip);\n   }\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=1;--ok;\n   }\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    ++ans;\n    while(high-low>1){\n       ok=ans;\n        int mid=(high+low)/2;\n        for(int i=1;i<=n;++i) dp[i]=1000000000;\n        dfs(1,mid);\n        if(ok>=0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    for(int i=1;i<=n;++i) dp[i]=1000000000;\n    dfs(1,low);\n    if(ok>=0){\n        cout << ans << \" \" << low << endl;\n    }\n    else\n        cout << ans << \" \" << high << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\n\nint n, lim, ans, dt[N];\n\nvector<int> adj[N], arr;\n\nbool can (int C, int P) {\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(!can(T, C)) return false;\n\t}\n\tarr.clear();\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(dt[T]+1 > lim) return false;\n\t\tarr.push_back(dt[T]+1);\n\t}\n\tsort(arr.begin(), arr.end());\n\tint N = arr.size();\n\tif(N % 2 == 0) {\n\t\tbool F = false;\n\t\tfor(int i=0;i<N/2;i++) {\n\t\t\tif(arr[i] + arr[N-1-i] > lim) F = true;\n\t\t}\n\t\tif(!F) {dt[C] = 0; return true;}\n\t\tarr.pop_back();\n\t}\n\tint S = 0, E = N;\n\twhile(S<E) {\n\t\tint M = (S+E)/2, L = 0, R = N-1;\n\t\tbool F = false;\n\t\twhile(1) {\n\t\t\tif(L == M) L++;\n\t\t\tif(R == M) R--;\n\t\t\tif(L >= R) break;\n\t\t\tif(arr[L] + arr[R] > lim) {F = true; break;}\n\t\t\tL++; R--;\n\t\t}\n\t\tF ? S = M+1 : E = M;\n\t}\n\tif(S == n) return false;\n\tdt[C] = arr[S];\n\treturn true;\n}\n\nbool can () {\n\tif(!can(1, 0)) return false;\n\treturn (adj[1].size() % 2 || dt[1] == 0);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tans = n-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tans -= (int)adj[i].size() / 2;\n\t}\n\tprintf(\"%d \",ans);\n\tint S = 0, E = n;\n\twhile(S<E) {\n\t\tlim = (S+E)/2;\n\t\tcan() ? E = lim : S = lim+1;\n\t}\n\tprintf(\"%d\\n\",S);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    f[x] = g[ans] + 1;\n    return 1;\n}\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(1, 0)) return 0;\n    return f[1] <= m + 1;\n}\nint main() {\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    std::cout << (m >>= 1) << std::ends;\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans;  //<< std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos > 0) data.erase(data.begin() + pos);\n\tint l = 0, r = data.size() - 1; \n\twhile (l < r) if (data[l++].fi + data[r--].fi > lim) return false; \n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nbool dfs(int u, int pa, int lim){ \n\tvector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if( v == pa) continue; \n\t\tif(! dfs(v, u, lim)) return false;; \n\t\tif(h[v] + 1 > lim) return false;\n\t\tdata.pb(ii(++ h[v], v));\n\t}\n\tif(data.size() == 0) return true;\n\tsort(data.begin(), data.end());\n\t//if(u == 6){\n\t//\tFor(i, 0, (int)data.size() - 1) cout << data[i].fi << ' ' << data[i].se <<\"\\n\";\n\t//}\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return false;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) return false;\n\t\th[u] = h[res];\n\t\tif(u == 1 && h[u] > lim) return false; \n\t}\n\treturn true;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++;\n\tint l = 0, r = n, ans;\n\t//cout << \"\\n\";\n\t//cout << dfs(1, 1, 3) << endl;\n\twhile(l <= r){\n\t\tmemset(h, 0, sizeof h);\n\t\tint mid = (l + r)/2;\n\t\tif(dfs(1, 1, mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << (dem + 1) / 2  << ' ' << ans;\n}\n/*\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define MAX 100002\nint n;\nvector<int> v[MAX];\nint dp[MAX],cnt[MAX];\nmultiset<int> vv[MAX];\nmultiset<int> tmp[MAX];\n\nbool can;\nint mx;\nvector<int> unf[MAX];\nint C;\ninline void dfs(int b, int pr = -1) {\n\tvv[b].clear();\n\tunf[b].clear();\n\tint deg = 0;\n\tfor (int go : v[b]) {\n\t\tif (go == pr)continue;\n\t\tdfs(go, b);\n\t\tdeg++;\n\t\tvv[b].insert(dp[go] + 1);\n\t}\n\ttmp[b] = vv[b];\n\tC += deg/2;\n\tif (deg % 2 && b == 0) {\n\t\tC++;\n\t}\n\tif (vv[b].size()) {\n\t\tint la = (*vv[b].rbegin());\n\t\tif (la > mx) {\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (vv[b].size() > 1) {\n\t\tint bc = *vv[b].rbegin();\n\t\tvv[b].erase(prev(vv[b].end()));\n\t\tint able = mx - bc;\n\t\tauto it = vv[b].upper_bound(able);\n\t\tif (it == vv[b].begin()) {\n\t\t\tunf[b].push_back(bc);\n\t\t\tcontinue;\n\t\t}\n\t\tit = prev(it);\n\t\tvv[b].erase(it);\n\t}\n\tif (vv[b].size()) {\n\t\tunf[b].push_back(*vv[b].begin());\n\t}\n\tvv[b].clear();\n\tif (deg%2&&unf[b].size() > 1) {\n\t\tcan = true;\n\t\tdp[b] = 0;\n\t\treturn;\n\t}\n\tif (deg % 2) {\n\t\tdp[b] = unf[b][0];\n\t\treturn;\n\t}\n\telse {\n\t\tif (unf[b].size() == 0) {\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (b == 0) {\n\t\t\t\tcan = true;\n\t\t\t\tdp[b] = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvv[b] = tmp[b];\n\t\t\tunf[b].clear();\n\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\twhile (vv[b].size() > 1) {\n\t\t\t\tint bc = *vv[b].rbegin();\n\t\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\t\tint able = mx - bc;\n\t\t\t\tauto it = vv[b].upper_bound(able);\n\t\t\t\tif (it == vv[b].begin()) {\n\t\t\t\t\tunf[b].push_back(bc);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit = prev(it);\n\t\t\t\tvv[b].erase(it);\n\t\t\t}\n\t\t\tif (vv[b].size()) {\n\t\t\t\tunf[b].push_back(*vv[b].begin());\n\t\t\t}\n\t\t\tif (unf[b].size() == 1) {\n\t\t\t\tdp[b] = unf[b][0];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\nbool ok(int len) {\n\tcan = false;\n\tmx = len;\n\tC = 0;\n\tdfs(0);\n\treturn can == false;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint mint = 1;\n\tint maxt = n;\n\twhile (mint + 1 < maxt) {\n\t\tint mid = (mint + maxt) >> 1;\n\t\tif (ok(mid)) {\n\t\t\tmaxt = mid;\n\t\t}\n\t\telse {\n\t\t\tmint = mid + 1;\n\t\t}\n\t}\n\tif (ok(mint)) {\n\t\tok(mint);\n\t\tcout <<C<<\" \"<< mint << endl;\n\t}\n\telse {\n\t\tok(maxt);\n\t\tcout << C<<\" \"<<maxt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define fdi(a,b) for(int i=a-1;i>=b;--i)\n#define fdj(a,b) for(int j=a-1;j>=b;--j)\n#define fdo(a,b) for(int o=a-1;o>=b;--o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n////////////////////\n\nint const N = 1e5 + 41;\nint const INF = 1e9 + 41;\n\nvector<int> e[N];\nint n, d[N], q[N], m;\nint a, b;\n\nint getmatch(multiset<int> &t, int x){\n\tif(sz(t) == 0) return INF;\n\tmultiset<int> :: iterator it = t.upper_bound(x);\n\tif(it == t.begin()) return INF;\n\t--it;\n\treturn (*it);\n}\n\nvoid dfs(int x, int p = -1){\n\td[x] = 0;\n\tq[x] = 0;\n\tvector<int> h;\n\tfi(0, sz(e[x])){\n\t\tint y = e[x][i];\n\t\tif(y == p) continue;\n\t\tdfs(y, x);\n\t\th.pb(d[y] + 1);\n\t\tq[x] += q[y];\n\t}\n\tsort(h.begin(), h.end());\n\tmultiset<int> t;\n\tfdi(sz(h), 0){\n\t\tint v0 = h[i];\n\t\tint v1 = m - v0;\n\t\tint k = getmatch(t, v1);\n\t\tif(k + v0 <= m){\n\t\t\tt.erase(t.find(k));\n\t\t\tq[x] += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tt.insert(v0);\n\t}\n\tq[x] += sz(t);\n\tif(sz(t) > 0){\n\t\tint v0 = (*t.begin());\n\t\tif(v0 < m){\n\t\t\t--q[x];\n\t\t\td[x] = v0;\n\t\t}\n\t}\n}\n\nint calc(int m){\n\t::m = m;\n\tdfs(0);\n\tint res = q[0];\n\tif(d[0] > 0) res += 1;\n\treturn res;\n}\n\nvoid solve(){\n\tif(n == 2){\n\t\ta = 1;\n\t\tb = 1;\n\t\treturn;\n\t}\n\tint l = 0;\n\tint r = N;\n\ta = calc(n);\n\twhile(r-l>1){\n\t\tint m = (l+r)/2;\n\t\tif(calc(m) == a) r = m;\n\t\telse l = m;\n\t}\n\tb = r;\n\t/*fi(0, n+1){\n\t\tif(calc(i) == a){\n\t\t\tb = i;\n\t\t\tbreak;\n\t\t}\n\t}*/\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n-1){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\t--x;--y;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d %d\\n\",a,b);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define N 200010\nusing namespace std;\nint n,con,h[N<<1],in[N],Rt,f[N];\nstruct edge\n{\n\tint to,ne;\n}e[N<<1];\nint read()\n{\n\tint x=0,f=1; \n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')\n\t\t\tf=-1; \n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tx=x*10+ch-'0'; \n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nvoid add(int u,int v)\n{\n\te[++con].to=v;\n\te[con].ne=h[u];\n\th[u]=con;\n}\nvoid dfs(int rt,int pr,int x)\n{\n\tvector<int>v; \n\tv.clear();\n\tfor(int i=h[rt];i;i=e[i].ne)\n\tif(e[i].to!=pr) \n\t{\n\t\tdfs(e[i].to,rt,x);\n\t\tv.push_back(f[e[i].to]);\n\t}\n\tif(!(v.size()&1)) \n\t\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tint l=0,r=v.size()-1,rs=n+1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) \n\t\t\t\ti++; \n\t\t\tif(j==mid) \n\t\t\t\tj--;\n\t\t\tfg&=(v[i]+v[j])<=x;\n\t\t}\n\t\tif(fg) \n\t\t\t\n\t\tr=mid-1,rs=v[mid];\n\t\telse l=mid+1;\n\t}\n\tf[rt]=rs+1;\n}\nbool check(int x)\n{\n\tdfs(Rt,0,x); \n\treturn f[Rt]<=x+1;\n}\nint main()\n{\n\tn=read(); \n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=read(),v=read();\n\t\tadd(u,v);\n\t\tin[u]++;\n\t\tadd(v,u);\n\t\tin[v]++;\n\t}\n\tint cnt=0; \n\tfor(int i=1;i<=n;i++) \n\t\tcnt+=in[i]&1,Rt=in[i]==1?i:Rt;\n\tint l=0,r=n,ans=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) \n\t\t\tr=mid-1,ans=mid;\n\t\telse \n\t\t\tl=mid+1;\n\t}\n\tcout<<(cnt+1)/2<<\" \"<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst int INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> e[100000];\nint ansa = 1;\n\nbool checker(vector<int> vec, int mid, int x) {\n    int i = 0, j = vec.size()-1;\n    bool ok = true;\n    rep(_,vec.size()/2) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (vec[i]+vec[j] > x) {\n            ok = false;\n            break;\n        }\n        i++; j--;\n    }\n    return ok;\n}\n\nint dfs(int v, int par, int x) {\n    vector<int> vec;\n    rep(i,e[v].size()) {\n        if (e[v][i] == par) continue;\n        int z = dfs(e[v][i], v, x);\n        if (z == INF) {\n            return INF;\n        }\n        vec.push_back(z);\n    }\n    if (vec.size() == 0) {\n        return 1;\n    }\n    if (vec.size() == 1) {\n        return vec[0]+1;\n    }\n    sort(vec.begin(), vec.end());\n    if (vec.size()%2 == 0) {\n        bool ok = true;\n        rep(i,vec.size()/2) {\n            if (vec[i]+vec[vec.size()-1-i] > x) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return 1;\n        }\n        if (v == 0) return INF;\n        if (vec[vec.size()-1] > x) return INF;\n        vec.pop_back();\n    }\n    int st = -1, en = vec.size(), mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (checker(vec, mid, x)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    if (en == vec.size()) {\n        return INF;\n    }\n    return vec[en]+1;\n}\n\nbool solve(int x) {\n    int z = dfs(0, 0, x);\n    if (z-1 > x) return false;\n    return true;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n    if (n == 2) {\n        cout << 1 << \" \" << 1 << endl;\n        return 0;\n    }\n    rep(i,n) {\n        if (e[i].size() > 2) {\n            ansa += (e[i].size()-2+1)/2;\n        }\n    }\n    int st = 1, en = n, mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (solve(mid)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    cout << ansa << \" \" << en << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int up)\n{\n\tvector<int>son;\n\tif (edge[x].size() & 1)son.push_back(0);\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, up))return false;\n\t\tif(dp[to] != -1)son.push_back(dp[to] + 1);\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > up)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = -1;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\tint flag = 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tflag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > up)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (son[le] > up)return false;\n\t\tint i = 0;\n\t\tint j = son.size() - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (i == le)i++;\n\t\t\tif (j == le)j--;\n\t\t\tif (i<j)\n\t\t\t{\n\t\t\t\tif (son[i] + son[j] > up)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n\nconst int N = 100100;\nVI edges[N];\nint deg[N];\nint a;\n\nint dp[N];\nint dp2[N];\n\nconst int DEBUG = 1;\n\nconst int inf = 1e8;\n\nvoid dfs(int v, int par, int b) {\n  int ch = -1;\n  REP(i, 0, edges[v].size()) {\n    int w = edges[v][i];\n    if (par == w) { continue; }\n    dfs(w, v, b);\n    ch = w;\n  }\n  if (par == -1) {\n    dp[v] = dp[ch];\n    dp2[v] = dp2[ch] + 1;\n    dp[v] += dp2[v] / b;\n    dp2[v] %= b;\n    return;\n  }\n  int mi = inf;\n  int tot = 0;\n  int aux = 0;\n  VI cap;\n  REP(i, 0, edges[v].size()) {\n    int w = edges[v][i];\n    if (par == w) { continue; }\n    tot += dp[w];\n    if (dp2[w] == 0) { continue; }\n    cap.push_back(dp2[w]);\n    mi = min(mi, dp2[w]);\n  }\n  int pos = 0;\n  vector<bool> used;\n  \n  dp[v] = tot;\n  if (aux == 0) {\n    dp2[v] = 1;\n  } else {\n    dp[v] += aux - 1;\n    assert (mi != inf);\n    dp2[v] = mi + 1;\n    dp[v] += dp2[v] / b;\n    dp2[v] %= b;\n  }\n  if (DEBUG) {\n    cerr << \"v = \" << v << \" dp=\" << dp[v] << \"  dp2=\" << dp2[v] << endl;\n  }\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  REP(i, 0, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n    deg[a] += 1;\n    deg[b] += 1;\n  }\n  a = 1;\n  REP(i, 0, n) {\n    if (deg[i] >= 3) {\n      a += (deg[i] - 1) / 2;\n    }\n  }\n  int leaf = -1;\n  REP(i, 0, n) {\n    if (deg[i] == 1) {\n      leaf = i;\n      break;\n    }\n  }\n  int pass = n;\n  int fail = 0;\n  while (pass - fail > 1) {\n    int mid = (pass + fail) / 2;\n    REP(i, 0, n) {\n      dp[i] = dp2[i] = -1;\n    }\n    dfs(leaf, -1, mid);\n    if (PI(dp[leaf], dp2[leaf]) <= PI(a, 0)) {\n      pass = mid;\n    } else {\n      fail = mid;\n    }\n  }\n  cout << a << \" \" << (pass - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, D[101000], M;\nvector<int>E[101000];\nbool Pos(int a, int pp) {\n\tint i;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tif (E[a][i] == pp)continue;\n\t\tif (!Pos(E[a][i], a))return false;\n\t}\n\tvector<int>TP;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tif (E[a][i] != pp)TP.push_back(D[E[a][i]] + 1);\n\t}\n\tsort(TP.begin(), TP.end());\n\tif (!TP.empty() && TP.back() > M)return false;\n\tint sz = TP.size();\n\tif (sz%2 == 0) {\n\t\tfor (i = 0; i <sz; i++) if (TP[i] + TP[sz - i - 1] > M)break;\n\t\tif (i == sz) {\n\t\t\tD[a] = 0;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif (!pp)return false;\n\t\t\tint b = 0, e = sz - 2, mid, rr = -1;\n\t\t\twhile (b <= e) {\n\t\t\t\tmid = (b + e) >> 1;\n\t\t\t\tfor (i = 0; i < sz - 2; i++) {\n\t\t\t\t\tint b = i, e = sz - i - 2;\n\t\t\t\t\tif (b >= mid)b++;\n\t\t\t\t\tif (e <= mid)e--;\n\t\t\t\t\tif (TP[b] + TP[e] > M)break;\n\t\t\t\t}\n\t\t\t\tif (i == sz - 2)rr = mid, e = mid - 1;\n\t\t\t\telse b = mid + 1;\n\t\t\t}\n\t\t\tif (rr == -1)return false;\n\t\t\tD[a] = TP[rr];\n\t\t\treturn true;\n\t\t}\n\t}\n\telse {\n\t\tint b = 0, e = sz - 1, mid, rr = -1;\n\t\twhile (b <= e) {\n\t\t\tmid = (b + e) >> 1;\n\t\t\tfor (i = 0; i < sz - 1; i++) {\n\t\t\t\tint b = i, e = sz - i - 1;\n\t\t\t\tif (b >= mid)b++;\n\t\t\t\tif (e <= mid)e--;\n\t\t\t\tif (TP[b] + TP[e] > M)break;\n\t\t\t}\n\t\t\tif (i == sz - 1)rr = mid, e = mid - 1;\n\t\t\telse b = mid + 1;\n\t\t}\n\t\tif (rr == -1)return false;\n\t\tD[a] = TP[rr];\n\t\treturn true;\n\t}\n}\nint main() {\n\tint i, a, b, S = 0;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tS += (E[i].size() - 1) / 2;\n\t}\n\tint  e = n, r = 0;\n\tb = 1;\n\twhile (b <= e) {\n\t\tM = (b + e) >> 1;\n\t\tif (Pos(1, 0)) {\n\t\t\tr = M;\n\t\t\te = M - 1;\n\t\t}\n\t\telse b = M + 1;\n\t}\n\tprintf(\"%d %d\\n\", S + 1, r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nvector<int> lis[100100];\nvector<int> cdp[100100];\nint dp[100100];\n\nbool dfs(int here, int p, int t) {\n    cdp[here].clear(); int i, j;\n    for (auto &there : lis[here]) {\n        if (there==p) continue;\n        if (!dfs(there,here,t)) return false;\n        cdp[here].push_back(dp[there]+1);\n    }\n    sort(cdp[here].begin(),cdp[here].end());\n    if (cdp[here].empty()) {\n        dp[here] = 0;\n        return true;\n    }\n    if (p<0) {\n        for (i=0,j=(int)cdp[here].size()/2*2-1;i<j;i++,j--) if (cdp[here][i]+cdp[here][j]>t) return false;\n        if (cdp[here].back()>t) return false;\n        return true;\n    }\n    if (cdp[here].size()%2==0) {\n        for (i=0,j=(int)cdp[here].size()-1;i<j;i++,j--) if (cdp[here][i]+cdp[here][j]>t) break;\n        if (i>=j) {\n            dp[here] = 0;\n            return true;\n        }\n        if (cdp[here].back()>t) return false;\n    }\n    int cur = 0;\n    for (i=1,j=(int)(cdp[here].size()-1)/2*2;i<j;i++,j--) {\n        if (cdp[here][i]+cdp[here][j]>t) {\n            cur = i;\n            if (cdp[here][i-1]+cdp[here][j]>t) return false;\n        }\n    }\n    dp[here] = cdp[here][cur];\n    return true;\n}\n\nbool ok(int t) {\n    return dfs(0,-1,t);\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n-1;i++){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);--a;--b;\n        lis[a].push_back(b);\n        lis[b].push_back(a);\n    }\n    int r1 = 1;\n    for (i=0;i<n;i++) r1 += (lis[i].size()+1)/2-1;\n    printf(\"%d \",r1);\n    int s = 0, e = n;\n    while(s<=e) {\n        int m = (s+e)>>1;\n        if (ok(m)) e = m-1;\n        else s = m+1;\n    }\n    printf(\"%d\\n\",s);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nVI e[N];\nint l,r,mid,f[N];\ninline void dfs(int k) {\n\tfor (int t:e[k]) {\n\t\te[t].erase(find(e[t].begin(),e[t].end(),k));\n\t\tdfs(t);\n\t}\n}\ninline bool solve(int k) {\n\tint m=e[k].size(),i;\n\tVI w(m);\n\tfor (i=0;i<m;i++) {\n\t\tif (!solve(e[k][i])) return false;\n\t\tw[i]=f[e[k][i]]+1;\n\t}\n\tsort(w.begin(),w.end());\n\tif (k==1) {\n\t\tif (m&1) {\n\t\t\tif (w[m-1]>mid) return false;\n\t\t\tm--;\n\t\t}\n\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m+1-i]>mid) return false;\n\t} else {\n\t\tif (m&1) {\n\t\t\tf[k]=w[0];\n\t\t\tfor (i=1;i<=m/2;i++)\n\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\tf[k]=w[i];\n\t\t\t\t}\n\t\t} else {\n\t\t\tf[k]=0;\n\t\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) break;\n\t\t\tif (i<m/2) {\n\t\t\t\tif (w[m-1]>mid) return false;\n\t\t\t\tm--;\n\t\t\t\tf[k]=w[0];\n\t\t\t\tfor (i=1;i<m;i++)\n\t\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\t\tf[k]=w[i];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=gi(),i,a,b,ans=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\te[a].pb(b),e[b].pb(a);\n\t}\n\tans=1;\n\tfor (i=1;i<=n;i++) ans+=(e[i].size()-1)/2;\n\tdfs(1);\n\tl=1,r=n;\n\twhile (l!=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (solve(1)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<ans<<\" \"<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n#include<cassert>\n#include<set>\nstruct kk\n{\n\tint v;\n};\nbool operator <(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nbool cmp(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nstd::multiset<kk> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int mid)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,mid)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>mid)return 0;\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\ts.clear();\n\t\tif(deg[o]&1)++cnt,s.insert((kk){0});\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)++cnt,s.insert((kk){f[e[p].to]+1});\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tkk val=*s.begin();\n\t\t\ts.erase(s.find(val));\n\t\t\tif(s.rbegin()->v+val.v>mid)return 0;\n\t\t\tkk tmp=(kk){mid-val.v};\n\t\t\tstd::multiset<kk>::iterator pl=s.lower_bound(tmp);\n\t\t\ts.erase(pl);\n\t\t\tcnt-=2;\n\t\t}\n\t\tassert(s.size()==1);\n\t\tf[o]=s.begin()->v;\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,1,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(3);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi g;\nvi dp;\n\nbool ff(vi& a,int I,int L){\n\tint N=a.size();\n\tbool B=1;\n\tfor(int i=0;i<(N-1)/2;i++) if(a[(i<I?i:i+1)]+a[(N-i-1>I?N-i-1:N-i-2)]>L) B=0;\n\treturn B;\n}\n\nbool f(int v,int p,int L){\n\tbool B=1;\n\tvi a;\n\tfor(auto u:g[v]) if(u!=p){\n\t\tB&=f(u,v,L)&&dp[u]!=L;\n\t\ta.push_back(dp[u]+1);\n\t}\n\tif(!B) return 0;\n\tsort(a.begin(),a.end());\n\tint N=a.size(),l=-1,r=N;\n\tif(N%2==0){\n\t\tfor(int i=0;i<N/2;i++) if(a[i]+a[N-i-1]>L) B=0;\n\t\tif(B) return 1;\n\t}\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tif(ff(a,m,L)) r=m;\n\t\telse l=m;\n\t}\n\tif(r==N) return 0;\n\tdp[v]=a[r];\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint A=0,v,l=0,r=n-1;\n\tfor(int i=0;i<n;i++){\n\t\tint S=g[i].size();\n\t\tA+=S%2;\n\t\tif(S==1) v=i;\n\t}\n\tA/=2;\n\twhile(r-l>1){\n\t\tdp=vi(n);\n\t\tint m=(l+r)/2;\n\t\tif(f(v,-1,m)) r=m;\n\t\telse l=m;\n\t}\n\tdp=vi(n);\n\tcout<<A<<' '<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100009;\nint root, n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!s.empty() && (!fa || *s.begin() == limit)) {\n\t\ts.clear();\n\t\tif (*s.begin() > limit) return -1;\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(root, 0) == -1) return 0;\n\treturn need <= ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++) if (e[i].size() == 1) root = i;\n\tdfs1(root, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\n\nii dp[111111];\nvi adj[111111];\nint MID;\nint tot;\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t\tcnt+=dp[v].fi;\n\t}\n\tsort(vec.begin(),vec.end());\n\t/*\n\tint maxpath = 0;\n\twhile(!vec.empty())\n\t{\n\t\tif(vec.size()==1)\n\t\t{\n\t\t\tif(vec[0]+1<=mid)\n\t\t\t{\n\t\t\t\tmaxpath = max(maxpath, vec[0]+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tmaxpath = max(maxpath, 1);\n\t\t\t}\n\t\t\tvec.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint las = vec.back();\n\t\t\tif(vec.front()+2+las<=mid)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_front(0);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\t/*\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint maxi = -int(1e9);\n\t\tfor(int i=0;i<mid;i++)\n\t\t{\n\t\t\tif(i<mid-1-i) maxi=max(maxi,vec[i]+vec[mid-1-i]+2);\n\t\t\tmaxi=max(maxi,vec[i]+1);\n\t\t}\n\t\tif(maxi<=MID)\n\t\t{\n\t\t\tans=mid;\n\t\t\tlo=mid+1;\n\t\t}\n\t\telse hi=mid-1;\n\t}\n\tint maxpath = 0;\n\tint del=0;\n\tfor(int i=ans;i<vec.size();i++) \n\t{\n\t\tif(vec[i]+1<=MID)\n\t\t{\n\t\t\tdel++;\n\t\t}\n\t\tvec[i]=0;\n\t}\n\tcnt+=int(vec.size()) - ans;\n\tfor(int j=0;j<del;j++) vec.pop_back();\n\tsort(vec.begin(),vec.end());\n\t//cerr<<vec.size()<<'\\n';\n\tcnt+=int(vec.size())/2;\n\t*/\n\tint maxpath=0;\n\tif(vec.size()%2==0) vec.push_front(0);\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=-1;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = -int(1e9);\n\t\t\twhile(l==mid) l++;\n\t\t\twhile(r==mid) r--;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=max(res,vec[l]+vec[r]);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1) maxpath=MID+100;\n\t\telse maxpath = vec[ans]+1;\n\t}\n\t//cerr<<MID<<' '<<u+1<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttot+=(adj[i].size()&1);\n\t}\n\tMID=n;\n\tint res=tot/2;\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=res;\n\t\tif(dp[0].se>MID+1) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  rep(i,0,n){\n    if(g[i].size()&1)res++;\n  }\n  ll ok=n,ng=0;\n  while(ok-ng>=2){\n    ll mid=(ok+ng)/2;\n    bool sw=true;\n    auto dfs=[&](auto &&f,ll k,ll par)->ll{\n      vector<ll>v;\n      if(g[k].size()&1)v.PB(0);\n      for(auto to:g[k]){\n        if(to==par)continue;\n        ll p=f(f,to,k);\n        if(p!=-1)v.PB(p);\n      }\n      sort(ALL(v));\n      ll sz=v.size();\n      rep(i,0,sz/2){\n        if(v[i]+v[sz-i-1]>mid)sw=false;\n      }\n      if(sz%2==0){\n        return -1;\n      }\n      else{\n        ll ok=sz-1,ng=-1;\n        while(ok-ng>=2){\n          ll mid2=(ok+ng)/2;\n          vector<ll>tmp;\n          rep(i,0,sz)if(i!=mid2)tmp.PB(v[i]);\n          bool sw2=true;\n          rep(i,0,sz/2){\n            if(v[i]+v[sz-i-2]>=mid)sw2=false;\n          }\n          if(sw)ok=mid2;\n          else ng=mid2;\n        }\n        return v[ok]+1;\n      }\n    };\n    dfs(dfs,0,-1);\n    if(sw)ok=mid;\n    else ng=mid;\n  }\n  cout<<res/2 spa ok<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n     dp[n]=(*S.begin()).first+1;\n     S.erase(S.begin());\n    while(!S.empty()){\n        it=S.begin();\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(vec[l]==son) ++l;\n\t\tif(vec[r]==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid,ret=vec.size();\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1,ret=mid;\n\t\telse l=mid+1;\n\t}\n\treturn ret;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tret&=treeDP(v,u);\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(!ret) return false;\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\nint n,A,B,mid,dp[maxn];\nvector<int> g[maxn];\n\nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            temp.push_back(dp[v]);\n        }\n    }\n   // sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n   // cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=0,rr=temp.size()-1;\n        int choose=-1;\n        while (ll<=rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n            while (p1<=p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > mid) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                choose = x;\n                rr = x-1;\n            }\n            else ll = x+1;\n        }\n        if (choose==-1) return false;\n        dp[u] = temp[choose] + 1;\n        return true;\n    }\n    else {\n        for (int i=0;i<temp.size();i++)\n            if (temp[i] + temp[temp.size()-i-1] + 2 > mid) return false;\n        dp[u]=0;\n        return true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n  //  freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=1,r=n-1;\n    while (l<=r) {\n        mid = (l+r)/2;\n        if (visit(1,-1)) {\n            B = mid;\n            r = mid-1;\n        } else l = mid+1;\n    }\n    cout<<B;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        dp.resize(N);\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    vec dp;\n    bool dfs(int v, int B, int p = -1){\n        vec val;\n        for(auto e: G[v]) if(e.to != p){\n            if(!dfs(e.to, B, v)) return false;\n            val.pb(dp[e.to]);\n        }\n        Sort(val);\n        if(p != -1){\n            if(SZ(G[v]) % 2){\n                val.pb(0);\n                Sort(val);\n            }\n            int n = SZ(val);\n            assert(n % 2);\n\n            int i0 = -1, i1 = n;\n            while(i1 - i0 > 1){\n                int i = (i0 + i1) / 2;\n                vec tmp;\n                REP(j, n) if(j != i) tmp.pb(val[j]);\n                bool f = true;\n                REP(j, SZ(tmp) / 2) if(tmp[j] + tmp[SZ(tmp) - 1 - j] > B) f = false;\n                if(f) i1 = i;\n                else i0 = i;\n            }\n            if(i1 == n) return false;\n            else dp[v] = val[i1] + 1;\n            \n        }else{\n            if(val.back() > B) return false;\n            if(SZ(G[v]) % 2) val.pop_back();\n            REP(i, SZ(val) / 2) if(val[i] + val[SZ(val) - 1 - i] > B) return false;\n        }\n        return true;\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int a, b; cin >> a >> b;\n        G.add_Undirected_edge(a - 1, b - 1);\n    }\n    int cnt = 0;\n    REP(i, N) if(SZ(G.G[i]) % 2) cnt++;\n    //debug(cnt);\n\n    int A = cnt / 2;\n    int B0 = 0, B1 = N;\n    while(B1 - B0 > 1){\n        int B = (B0 + B1) / 2;\n        if(G.dfs(0, B)) B1 = B;\n        else B0 = B;\n    }\n    cout << A << \" \" << B1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\ts.erase(j);\n\t\t\tj--;\n\t\t\tt--;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1) dis[x]=len[*s.begin()];\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e5 + 5;\n \nint n;\nvector<int> g[N];\nint A, newA, lim;\n \nint dfs(int u,int p) {\n\tmultiset<int> ms;\n\tfor (int v : g[u]) if (v != p) {\n\t\tms.insert(dfs(v, u) + 1);\n\t}\n\t\n\tvector<int> rem;\n\twhile (!ms.empty()) {\n\t\tmultiset<int>::iterator it = ms.end();\n\t\tint x = *(--it);\n\t\tms.erase(it);\n\t\tit = ms.upper_bound(lim - x);\n\t\tif (it == ms.begin()) rem.push_back(x);\n\t\telse ms.erase(--it), newA++; \n\t}\n\t\n\treverse(rem.begin(), rem.end());\n\twhile (!rem.empty() && rem.back() == lim) newA++, rem.pop_back();\n\tif (rem.empty()) return 0;\n\telse { newA += rem.size() - 1; return rem[0]; }\n}\n \nbool check() {\n\tnewA = 0;\n\tnewA += dfs(1, 1) > 0;\n\treturn newA == A;\n}\n \nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v), g[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tA += g[i].size() & 1;\n\t}\n\tA /= 2;\n\tint l = 1, r = n;\n\twhile (l < r) {\n\t\tlim = l + r >> 1;\n\t\tif (check()) r = lim;\n\t\telse l = lim + 1;\n\t}\n\tcout << A << ' ' << l << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\n\nint n;\nvector<int> gph[MAXN];\nvector<int> dfn;\n\nint dp[MAXN];\n\nint query(int k){\n\tfor(auto &i : dfn){\n\t\tif(i == 1) break;\n\t\tvector<int> v;\n\t\tfor(auto &j : gph[i]) v.push_back(dp[j] + 1);\n\t\tsort(v.begin(), v.end());\n\t\tauto trial_pos = [&](int x){\n\t\t\tint l = 0, r = v.size() - 1;\n\t\t\tfor(int i=0; i<v.size()/2; i++){\n\t\t\t\tif(l == x) l++;\n\t\t\t\tif(r == x) r--;\n\t\t\t\tif(v[l] + v[r] > k) return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\t\tif(v.size() % 2 == 0){\n\t\t\tv.insert(v.begin(), 0);\n\t\t}\n        int s = 0, e = v.size();\n        while(s != e){\n            int m = (s+e)/2;\n            if(trial_pos(m)) e = m;\n            else s = m + 1;\n        }\n        if(s == v.size() || v[s] >= k) return 0;\n        dp[i] = v[s];\n\t}\n\tvector<int> v;\n\tfor(auto &i : gph[1]) v.push_back(dp[i] + 1);\n\tsort(v.begin(), v.end());\n\tif(v.back() > k) return 0;\n\tif(v.size() % 2 == 1) v.pop_back();\n\tfor(int i=0; i<v.size()/2; i++){\n\t\tif(v[i] + v[v.size()-i-1] > k) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int x){\n\tdfn.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tgph[i].erase(find(gph[i].begin(), gph[i].end(), x));\n\t\tdfs(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1);\n\tint ans = n - 1;\n\tfor(int i=1; i<=n; i++){\n\t\tans -= ((i != 1) + gph[i].size()) / 2;\n\t}\n\tint s = 1, e = n;\n\treverse(dfn.begin(), dfn.end());\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(!query(m)) s = m+1;\n\t\telse e = m;\n\t}\n\tprintf(\"%d %d\\n\", ans, s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nconst int MAXN = 1e5 + 10;\n\nstruct Edge {\n  int v, next;\n}edge[MAXN << 1];\nint head[MAXN], tail, n, deg[MAXN];\nvoid insert(int u, int v) {\n  edge[++tail] = (Edge) {v, head[u]}; head[u] = tail;\n}\nnamespace solver1 {\n  int f[MAXN];\n  int bound;\n  bool dfs(int u, int fa) {\n    std::vector <int> dps;\n    for (int i = head[u]; i; i = edge[i].next) {\n      int v = edge[i].v;\n      if (v == fa) continue;\n      if (!dfs(v, u)) return 0;\n      if (f[v] > bound) return 0;\n      dps.push_back(f[v]);\n    }\n    if (deg[u] & 1) dps.push_back(0);\n    std::sort(dps.begin(), dps.end());\n    int l = 0, r = dps.size() - 1;\n    while(l <= r) {\n      int mid = (l + r) >> 1;\n      bool flag = 1;\n      for (int i = (mid == 0 ? 1 : 0), j = ((int) dps.size() - 1 == mid ? dps.size() - 2 : dps.size() - 1); i <= j; i += 1 + (i + 1 == mid), j -= 1 + (j - 1 == mid)) {\n        if (dps[i] + dps[j] > bound) {flag = 0; break;}\n      } \n      if (flag) {\n        f[u] = dps[mid];\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    f[u]++;\n    return f[u];\n  }\n  bool check() {\n    memset(f, -1, sizeof f);\n    return dfs(1, 0) \n      && f[1] <= bound + 1;\n  }\n  void main() {\n    int ans1 = 0;\n    for (int i = 1; i <= n; i++) { \n      if (deg[i] & 1) ans1++; \n    }\n    ans1 /= 2;\n    printf(\"%d \", ans1);\n    int l = 1, r = n, ans2 = 0;\n    deg[1]++;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      bound = mid;\n      if (check()) {\n        ans2 = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans2);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    insert(a, b);\n    insert(b, a);\n    deg[a]++; deg[b]++;\n  }\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int mid)\n{\n\tvector<int>son;\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, mid))return false;\n\t\tif(dp[to] != -1)son.push_back(dp[to] + 1);\n\t}\n\tif (son.size() == 0)\n\t{\n\t\tdp[x] = 0;\n\t\treturn true;\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > mid)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = -1;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\tint flag = 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tflag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > mid)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)return false;\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 10005;\n\nint n;\nvector<int> gph[MAXN];\nvector<int> dfn;\n\nint dp[MAXN];\n\nint query(int k){\n\tfor(auto &i : dfn){\n\t\tif(i == 1) break;\n\t\tvector<int> v;\n\t\tfor(auto &j : gph[i]) v.push_back(dp[j] + 1);\n\t\tsort(v.begin(), v.end());\n\t\tauto trial_pos = [&](int x){\n\t\t\tint l = 0, r = v.size() - 1;\n\t\t\tfor(int i=0; i<v.size()/2; i++){\n\t\t\t\tif(l == x) l++;\n\t\t\t\tif(r == x) r--;\n\t\t\t\tif(v[l] + v[r] > k) return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\t\tif(v.size() % 2 == 0){\n\t\t\tv.insert(v.begin(), 0);\n\t\t}\n        int s = 0, e = v.size();\n        while(s != e){\n            int m = (s+e)/2;\n            if(trial_pos(m)) e = m;\n            else s = m + 1;\n        }\n        if(s == v.size() || v[s] >= k) return 0;\n        dp[i] = v[s];\n\t}\n\tvector<int> v;\n\tfor(auto &i : gph[1]) v.push_back(dp[i] + 1);\n\tsort(v.begin(), v.end());\n\tif(v.back() > k) return 0;\n\tif(v.size() % 2 == 1) v.pop_back();\n\tfor(int i=0; i<v.size()/2; i++){\n\t\tif(v[i] + v[v.size()-i-1] > k) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int x){\n\tdfn.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tgph[i].erase(find(gph[i].begin(), gph[i].end(), x));\n\t\tdfs(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1);\n\tint ans = n - 1;\n\tfor(int i=1; i<=n; i++){\n\t\tans -= ((i != 1) + gph[i].size()) / 2;\n\t}\n\tint s = 1, e = n;\n\treverse(dfn.begin(), dfn.end());\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(!query(m)) s = m+1;\n\t\telse e = m;\n\t}\n\tprintf(\"%d %d\\n\", ans, s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size(); i + 1 < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j - 1 == mid) j--;\n\t\t\t\tif(i + 1 < j && u[i++] + u[--j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) lo = mid;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo < 0 ? inf : u[lo] + 1;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tif(u.back() > B) return inf;\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\n\nvector<int> T[MX];\nint N, m, val = 1;\n\nint dfs(int x, int p = -1){\n\tvector<int> X;\n\tfor(int c : T[x]){\n\t\tif( c == p ) continue;\n\t\tX.push_back(dfs(c, x)+1);\n\t}\n\tsort(X.begin(), X.end());\n\tif( X.empty() ) return 0;\n\tif( X.back() > m ) val = 0;\n\n\tif( X.size()%2 == 0){\n\t\tint ch = 1;\n\t\tfor(int i = 0; i < X.size()/2; i++){\n\t\t\tif( X[i] + X[X.size()-i-1] > m ) ch = 0;\n\t\t}\n\t\tif( ch ) return 0;\n\t\tif( p == -1 ) val = 0;\n\t\tX.pop_back();\n\t}\n\tint ch = 1;\n\tfor(int i = 0; i < X.size()/2; i++){\n\t\tif( X[i] + X[X.size()-i-2] > m ) ch = 0;\n\t}\n\tif( !ch ) val = 0;\n\tfor(int i = X.size()-1; i > 0; i--){\n\t\tint op = X.size()/2 > i ? X.size()-i-1 : X.size()-i;\n\t\tif( X[i] + X[op] > m ) return X[i];\n\t}\n\treturn X[0];\n}\n\nint main()\n{\n\tint cnt = 1;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tif( T[i].size() >= 3 ) cnt += (T[i].size() - 1) / 2;\n\t}\n\tint s = 1, e = N;\n\twhile(s <= e){\n\t\tm = (s+e) / 2;\n\t\tval = 1;\n\t\tdfs(1);\n\t\tif( val ) e = m-1;\n\t\telse s = m+1;\n\t}swap(s, e);\n\tprintf(\"%d %d\\n\", cnt, e);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nvoid calcnum(int root, int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tcalcnum(to, root); tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2)cnt++;\n}\nint c;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size();\n\tmultiset<int> mt;\n\trep(i, len)mt.insert(v[i]);\n\tvector<int> rest;\n\twhile(len) {\n\t\tcnt++;\n\t\tauto itr = mt.end(); itr--;\n\t\tint z = *itr; mt.erase(mt.find(z)); len--;\n\t\tint r = c - z;\n\t\tif (mt.count(r)) {\n\t\t\tmt.erase(mt.find(r)); len--;\n\t\t}\n\t\telse {\n\t\t\tmt.insert(r);\n\t\t\tauto itr2 = mt.find(r);\n\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\tmt.erase(itr2);\n\t\t\t\trest.push_back(z);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titr2--; mt.erase(r);\n\t\t\tmt.erase(itr2); len--;\n\t\t}\n\t}\n\tif (rest.size()) {\n\t\tcnt--;\n\t\treturn rest[rest.size() - 1] + 1;\n\t}\n\telse return 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > 0)cnt++;\n\treturn cnt == ansa;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tcalcnum(0, -1);\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa << \" \" << ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 233366666\nusing namespace std;\ninline int read()\n{int x=0;\nchar c=getchar();\nwhile (c<'0'||c>'9') c=getchar();\nwhile (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\nreturn x;\n}\nint deg[100005],head[100005],nxt[200005],v[200005];\nint dp[100005],n,tot=0,root=-1,tar;\ninline void add(int a,int b)\n{tot++;nxt[tot]=head[a];head[a]=tot;v[tot]=b;}\nvoid dfs(int pos,int f)\n{int l,r,i,ts,num=0;\nfor (i=head[pos];i;i=nxt[i])\n{if (v[i]==f) continue;\ndfs(v[i],pos);num++;\n}\nint tp[num+2],sz=0;\nfor (i=head[pos];i;i=nxt[i])\n{if (v[i]==f) continue;\ntp[++sz]=dp[v[i]];\n}\nif (!(sz&1)) tp[++sz]=0;\nsort(tp+1,tp+sz+1);\nl=1;r=sz;ts=sz>>1;\nwhile (l<=r)\n{int mid=(l+r)>>1,p1=1,p2=sz,tag=1;\nfor (i=1;i<=ts;i++)\n{if (p1==mid) p1++;\nif (p2==mid) p2--;\nif (tp[p1]+tp[p2]>tar) {tag=0;break;}\np1++;p2--;\n}\nif (tag) {r=mid-1;}\nelse {l=mid+1;}\n}\nif (l==sz+1) {dp[pos]=inf;}\nelse {dp[pos]=tp[l]+1;}\n}\ninline bool chk(int mid)\n{tar=mid;dfs(root,0);\nreturn (dp[root]<=mid+1);\n}\nint main (){\n\tint i,a,b,cnt=0;\n\tn=read();\n\tfor (i=1;i<n;i++)\n\t{a=read();b=read();\n\tadd(a,b);add(b,a);\n\tdeg[a]++;deg[b]++;\n\t}\n\tfor (i=1;i<=n;i++)\n\t{if (deg[i]&1)\n\t{cnt++;root=i;}\n\t}\n\tcnt>>=1;\n\tint l=1,r=n;\n\twhile (l<=r)\n\t{int mid=(l+r)>>1;\n\tif (chk(mid)) {r=mid-1;}\n\telse {l=mid+1;}\n\t}\n\tprintf (\"%d %d\\n\",cnt,l);\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\tif(u.size() && u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size(); i + 1 < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j - 1 == mid) j--;\n\t\t\t\tif(i + 1 < j && u[i++] + u[--j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tvector<int> vec;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvec.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vec.size()==0)return P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.second==1 && res.first!=1)res.first--;\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tint p1 = 0, p2 = son.size()-1;\n\twhile (p1 < p2)\n\t{\n\t\tif (p1 == r) p1++;\n\t\tif (p2 == r) p2--;\n\t\tif (son[p1] + son[p2] > B) return false;\n\t\tp1++; p2--;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,tot=0;\nconst int INF=1e9;\nstruct data {\n\tint next,num;\n}edge[200005];\nint head[200001],d[200001];\nvoid add(int u,int v) {\n\tedge[++tot].next=head[u];\n\tedge[tot].num=v;\n\thead[u]=tot;\n}\nint dfs(int x,int fa) {\n\tint cnt=0;\n\tint sum=0;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tcnt++;\n\t\tsum+=dfs(kx,x);\n\t}\n\tif (x==1) return sum-cnt/2;\n\tif (cnt%2) return sum-cnt/2;\n\treturn sum-cnt/2+1;\n}\nint calc(int x,int fa,int lim) {\n\tvector <int> v;\n\tfor (int i=head[x];i!=-1;i=edge[i].next) {\n\t\tint kx=edge[i].num;\n\t\tif (kx==fa) continue;\n\t\tint now=calc(kx,x,lim);\n\t\tif (now==INF) return INF;\n\t\tv.push_back(now);\n\t}\n\tint sz=v.size();\n\tsort(v.begin(),v.end());\n\tif (sz%2==0) {\n\t\tbool judge=1;\n\t\tfor (int i=0;i<sz;i++)\n\t\t\tif (v[i]+v[sz-i-1]>lim) {\n\t\t\t\tjudge=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (judge) return 1;\n\t\tsz--;\n\t}\n\tint l=0,r=sz;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tbool judge=1;\n\t\tvector <int> v2;\n\t\tfor (int i=0;i<sz;i++) if (i!=mid) v2.push_back(v[i]);\n\t\tfor (int i=0;i<sz-1;i++) if (v2[i]+v2[sz-i-2]>lim) {\n\t\t\tjudge=0;\n\t\t\tbreak;\n\t\t}\n\t\tif (judge) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\tif (l==sz) return INF;\n\tif (x==1&&v[l]>lim) return INF;\n\tif (x==1) return 0;\n\tif (v[l]+1>lim) return INF;\n\treturn v[l]+1;\n}\nint work() {\n\tint l=1,r=2e5;\n\twhile (l<r) {\n\t\tint mid=(l+r)/2;\n\t\tif (calc(1,-1,mid)!=INF) r=mid;\n\t\t\telse l=mid+1;\n\t}\n\treturn l;\n}\nint main() {\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t\td[u]++;\n\t\td[v]++;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (d[i]%2) ans++;\n\t/*int ans=dfs(1,-1);*/\n\tprintf(\"%d \",ans);\n\tint ans2=work();\n\tprintf(\"%d\\n\",ans2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint n,cnt,ans,tot,q[100010],inf=1e9,l1,r1,mi,v[100010];\nint x1[100010],r[200010],vt[200010],in[100010],mx,root;\nvoid adde(int a,int b)\n{\n\tr[++cnt]=x1[a];x1[a]=cnt;vt[cnt]=b;in[b]++;\n\tr[++cnt]=x1[b];x1[b]=cnt;vt[cnt]=a;in[a]++;\n} \nvoid dfs(int i,int fa)\n{\n\tint s,a,b,j,k;\n\tint l2,r2,m,st,ed;\n\ta=x1[i];v[i]=0;\n\twhile(a)\n\t{\n\t\tb=vt[a];\n\t\tif(b!=fa)dfs(b,i);\n\t\ta=r[a];\n\t}\n\ta=x1[i];cnt=0;\n\twhile(a)\n\t{\n\t\tb=vt[a];\n\t\tif(b!=fa)q[++cnt]=v[b]+1;\n\t\ta=r[a];\n\t}\n\tif(!(cnt&1))q[++cnt]=0;\n\tsort(q+1,q+1+cnt);\n\tl2=1;r2=cnt+1;\n\twhile(l2<r2)\n\t{\n\t\tm=(l2+r2)/2;j=1;\n\t\tst=1;ed=cnt;\n\t\twhile(st<ed)\n\t\t{\n\t\t\tif(st==m)st++;\n\t\t\tif(ed==m)ed--;\n\t\t\tif(q[st]+q[ed]>mi){j=0;break;}\n\t\t\tst++;ed--;\n\t\t}\n\t\tif(j)r2=m;\n\t\telse l2=m+1;\n\t} \n\tif(l2==cnt+1)v[i]=inf;\n\telse v[i]=q[l2];\n}\nbool jd(int mi)\n{\n\tdfs(root,0);\n\treturn (v[root]<=mi);\n}\t\nint main()\n{\n\tint i,s,a,b,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++)scanf(\"%d%d\",&a,&b),adde(a,b);\n\tans=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tans+=(in[i]-1)/2;\n\t\tif(in[i]==1)root=i;\n\t}\n\tl1=1;r1=n;\n\twhile(l1<r1)\n\t{\n\t\tmi=(l1+r1)/2;\n\t\tif(jd(mi))r1=mi;\n\t\telse l1=mi+1;\n\t}\n\tprintf(\"%d %d\",ans,l1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 2 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nbool OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nll f[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n      \tassert(sum[v]+1<=m);\n        st.insert(sum[v]+1);\n    }\n    while(st.size())\n    {\n        int x=*st.rbegin();\n        st.erase(st.find(x));\n        if(st.size()==0)\n        {\n            if(x+1<=m) sum[u]=x;\n            else f[u]++;\n            break;\n        }\n        it=st.upper_bound(m-x);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;st.erase(st.find(*it));\n        }\n    }\n    if(u==1&&sum[u]) f[u]++;\n}\nbool judge(int m)\n{\n    dfs(1,0,m);\n    return f[1]<=dp[1];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=(n-1)/dp[1],r=n,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        if(judge(m)) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nconst int N = 100050;\nint pre[N], nxt[N * 2], to[N * 2], cnt;\ninline void addEdge(int x, int y) {\n  nxt[cnt] = pre[x];\n  to[pre[x] = cnt++] = y;\n  nxt[cnt] = pre[y];\n  to[pre[y] = cnt++] = x;\n}\nint tmp[N * 7];\nint d[N];\nint B;\nint vis[N], time;\nbool check(int x, int fa, int *tmp, int &pp) {\n  int ss = d[x] + 1;\n  int l = 0;\n  if (d[x] & 1) tmp[l++] = 0;\n  for (int i = pre[x]; ~i; i = nxt[i]) if (to[i] != fa) {\n    int p = 0;\n    if (!check(to[i], x, tmp + ss, p)) return false;\n    if (p) tmp[l++] = p;\n  }\n  std::sort(tmp, tmp + l);\n  if (tmp[l - 1] > B) return false;\n  int i = l - 1, j = 0;\n  ++time;\n  while (i > j) {\n    while (j > 0 && tmp[i] + tmp[j] > B) --j;\n    while (j < i - 1 && tmp[j + 1] + tmp[i] <= B) ++j;\n    vis[i] = vis[j] = time;\n    --i;\n  }\n  if (~l & 1) return true;\n  j = 0;\n  while (vis[j] == time) ++j;\n  pp = j;\n  return true;\n  return false;\n}\nint main() {\n  int n, x, y;\n  scanf(\"%d\", &n);\n  memset(pre, -1, sizeof pre);\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addEdge(x, y);\n    ++d[x]; ++d[y];\n  }\n  int l = 0;\n  for (int i = 1; i <= n; ++i)\n    l += (d[i] & 1);\n  l /= 2;\n  printf(\"%d\\n\", l);\n  int ll = 1, rr = n * 2, xxx;\n  while (ll < rr) {\n    int mid = (ll + rr) / 2;\n    if (B = mid, check(1, 0, tmp, xxx)) rr = mid;\n    else ll = mid + 1;\n  }\n  printf(\"%d\\n\", ll);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int) 1e5 + 10;\nint n;\nvector<int> adj[MAXN];\n\nint DFS(int u, int T, int par = -1) {\n    vector<int> a;\n    for (int i = 0; i < (int) adj[u].size(); ++i) {\n        int v = adj[u][i];\n        if (v != par) a.push_back(DFS(v, T, u));\n    }\n    if ((int) a.size() % 2 == 0) a.push_back(0);\n    sort(a.begin(), a.end());\n\n    int l = 0, r = (int) a.size() - 1, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        vector<int> b;\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (i != mid) b.push_back(a[i]);\n        bool check = true;\n        for (int i = 0; i < (int) b.size() / 2; ++i) {\n            if (b[i] + b[(int) b.size() - i - 1] > T) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (f == -1) {\n        return T + 3;\n    }\n    return a[f] + 1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int l = 1, r = n, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (DFS(1, mid) <= mid + 1) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) cnt += (int) adj[i].size() % 2;\n\n    assert(f != n);\n    printf(\"%d %d\\n\", cnt / 2, f);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t;\n\nbool ok(int mid) {\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (v == 0 && t.size() % 2 == 0) {\n\t    sort(t.begin(), t.end());\n\t    REP (j, t.size()/2) if (t[j] + t.rbegin()[j] > mid) return false;\n\t    return true;\n\t} else {\n\t    if (t.size() % 2 == 0) t.push_back(0);\n\t    sort(t.begin(), t.end());\n\t    int m = t.size() / 2;\n\t    dp[v] = -1;\n\t    int pos = 0;\n\t    REP (j, m) {\n\t\tint c = t.rbegin()[j];\n\t\twhile (pos < (int)t.size() && t[pos] + c <= mid) pos++;\n\t\tif (pos <= j) return false;\n\t\tif (dp[v] == -1 && pos > j + 1) dp[v] = t[j];\n\t\tif (pos == j+1) dp[v] = -1;\n\t    }\n\t    if (dp[v] == -1) dp[v] = t[m];\n\t}\n    }\n    return dp[0] <= mid;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += ((int)G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define ele int\nusing namespace std;\n#define maxn 200010\nconst ele INF=1e9;\nstruct edge{\n\tele v;\n\tedge *nxt;\n}ep[maxn<<1],*ecnt;\nele n,r,d[maxn],f[maxn];\nedge *h[maxn];\ninline void addedge(ele u,ele v){\n\tedge *p=ecnt++;\n\tp->v=v; p->nxt=h[u];\n\th[u]=p;\n}\nvoid dfs(ele p,ele i,ele B){\n\tvector<ele> lst;\n\tfor (edge *j=h[i]; j; j=j->nxt)\n\t\tif (j->v!=p){\n\t\t\tdfs(i,j->v,B);\n\t\t\tlst.push_back(f[j->v]);\n\t\t}\n\tif (lst.size()%2==0) lst.push_back(0);\n\tsort(lst.begin(),lst.end());\n\tf[i]=INF;\n\tfor (int r=0; r<lst.size(); ++r){\n\t\tele u=0,v=lst.size()-1;\n\t\tbool flag=true;\n\t\twhile (u<v){\n\t\t\tif (u==r) ++u;\n\t\t\tif (v==r) --v;\n\t\t\tif (u<v && lst[u]+lst[v]>B){ flag=false; break; }\n\t\t\t++u; --v;\n\t\t}\n\t\tif (flag){ f[i]=lst[r]+1; break; }\n\t}\n}\ninline bool test(ele B){\n\tdfs(-1,r,B);\n\treturn f[r]<=B+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tecnt=ep; memset(h,0,sizeof(h)); memset(d,0,sizeof(d));\n\tfor (int i=0; i<n-1; ++i){\n\t\tele x,y;\n\t\tscanf(\"%d%d\",&x,&y); --x,--y;\n\t\taddedge(x,y); addedge(y,x);\n\t\t++d[x]; ++d[y];\n\t}\n\tele cnt=0;\n\tfor (int i=0; i<n; ++i)\n\t\tif (d[i]&1) ++cnt,r=i;\n\tele L=0,R=n-1;\n\twhile (R-L>1){\n\t\tele mid=(L+R)>>1;\n\t\tif (test(mid)) R=mid; else L=mid;\n\t}\n\tprintf(\"%d %d\\n\",cnt/2,R);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl)\n                return 0;\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    if(x==1)\n        flag--;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        if(t>maxl)\n            return 0;\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==1)\n                dp[x]=t;\n            flag=-1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int MAX=200040;\nconst ll MOD=1000000007;\nvector<int> conn[MAX],dir[MAX],tmp[MAX];\nint a,b,com=0,par[MAX],n;\nvoid dfs(int x,int p){\n    par[x]=p;\n    for(int i=0;i<conn[x].size();i++) if(conn[x][i]!=p) dfs(conn[x][i],x);\n}\nint simple(int v,int u){\n    int p1=0,p2=tmp[v].size()-2,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n    }\n    return pos;\n}\nint div2(int v,int x,int y,int u){\n    if(y-x==1) return x;\n    int p=(x+y)/2,p1=0,p2=tmp[v].size()-1,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n        if(p1==p) p1++;\n        if(p2==p) p2--;\n    }\n    if(pos) return div2(v,x,p,u);\n    return div2(v,p,y,u);\n}\nint f(int x,int u){\n    tmp[x].clear();\n    if(dir[x].size()==0) return 0;\n    for(int i=0;i<dir[x].size();i++){\n        int t=f(dir[x][i],u)+1;\n        if(t==0) return -1;\n        tmp[x].push_back(t);\n    }\n    if(tmp[x].size()%2==0) tmp[x].push_back(0);\n    sort(tmp[x].begin(),tmp[x].end());\n    if(simple(x,u)==0) return -1;\n    int t=div2(x,0,tmp[x].size(),u);\n    if(tmp[x][t]>u) return -1;\n    //printf(\"%d %d\\n\",x,tmp[x][t]);\n    return tmp[x][t];\n}\nint div22(int x,int y){\n    if(y-x==1) return x;\n    int p=(x+y)/2,u=f(com,p);\n    if(u==-1) return div22(p,y);\n    return div22(x,p);\n}\nint main(){\n    scanf(\" %d\",&n);\n    for(int i=0;i<n-1;i++){\n        int t1,t2;\n        scanf(\" %d %d\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(int i=1;i<=n;i++) if(conn[i].size()%2) com=max(i,com), a+=1;\n    a/=2;\n    dfs(com,0);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<conn[i].size();j++) if(conn[i][j]!=par[i]) dir[i].push_back(conn[i][j]);\n    }\n    b=div22(0,n+1)+1;\n    printf(\"%d %d\\n\",a,b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 200005\n#define pb push_back\nusing namespace std;\nint i,j,k,l,s,n,m,last[N],to[M],Next[M],q[N],fa[N],si[N],ans,tot,x,y,dis[N],a[N];\nvector<int>GT;\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline void build() {\n\tint l=0,r=1; q[1]=1,dis[1]=1;\n\twhile (l<r) {\n\t\tint k=q[++l];\n\t\tfor (int i=last[k];i;i=Next[i]) if (fa[k]!=to[i]) fa[q[++r]=to[i]]=k,dis[to[i]]=dis[k]+1;\n\t}\n}\ninline bool work(int x,int y,int z) {\n\tint L=0,R=GT.size()-1;\n\tif (L==x) L++;\n\tif (R==x) R--;\n\twhile (L<=R) {\t\n\t\tif (GT[L]+GT[R]-2*y+1>z) return false;\n\t\tL++,R--;\n\t\tif (L==x) L++;\n\t\tif (R==x) R--;\n\t}\n\treturn true;\n}\ninline int Find(int x,int y) {\n\tint L=0,R=GT.size()-1,s=GT.size();\n\twhile (L<=R) {\n\t\tint mid=(L+R)>>1;\n\t\tif (work(mid,x,y)) s=mid,R=mid-1;\n\t\telse L=mid+1;\n\t}\n\treturn s;\n}\ninline bool check(int x) {\n\tfor (int i=n;i;i--) {\n\t\tGT.clear();\n\t\tfor (int j=last[q[i]];j;j=Next[j]) {\n\t\t\tif (to[j]==fa[q[i]]) continue;\n\t\t\tGT.pb(a[to[j]]);\n\t\t}\n\t\tsort(GT.begin(),GT.end());\n\t\tif (!GT.size()) {\n\t\t\ta[q[i]]=dis[q[i]];\n\t\t\tcontinue;\n\t\t}\n \t\tif (GT.size()&1) {\n\t\t\tif (GT.size()==1) {\n\t\t\t\ta[q[i]]=GT[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint gt=Find(dis[q[i]],x);\n\t\t\tif (gt>=GT.size()) return false;\n\t\t\ta[q[i]]=GT[gt];\n\t\t}\n\t\telse if (i!=1) {\n\t\t\tGT.pb(dis[q[i]]);\n\t\t\tsort(GT.begin(),GT.end());\n\t\t\tint gt=Find(dis[q[i]],x);\n\t\t\tif (gt>=GT.size()) return false;\n\t\t\ta[q[i]]=GT[gt];\n\t\t}\n\t\telse {\n\t\t\tfor (int j=0;j<GT.size()/2;j++) if (GT[j]+GT[GT.size()-j-1]-1>x) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (a[1]>x) return false;\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tbuild();\n\tfor (i=n;i;i--) {\n\t\tif (!si[q[i]]) si[q[i]]++;\n\t\tans+=si[q[i]]>>1;\n\t\tsi[fa[q[i]]]++;\n\t}\n\tans+=si[1]&1;\n\tprintf(\"%d \",ans);\n\tint l=0,r=n;\n\tans=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid)) r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d\\n\",ans-1);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n \ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,ee,st[N<<1],du[N],Rt,F[N];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\n\ninline bool cmp(int a,int b){return F[a]<F[b];}\n\ninline bool dfs(int rt,int pr,int x)\n{\n\tvector <int> v; v.clear();\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tif(!dfs(vs[i].v,rt,x)) return false;\n\t\tv.push_back(vs[i].v);\n\t}\n\tif(v.size()==0){\n\t\tF[rt]=1;\n\t\treturn true;\n\t}\n\tif(du[rt]&1) v.push_back(0);\n\tsort(v.begin(),v.end(),cmp);\n\t// printf(\"son of node %d len of %d\\n\",rt,x);\n\t// for(int i=0;i<v.size();i++) printf(\"%d \",v[i]); puts(\"\");\n\tint l=0,r=v.size()-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1,fg=1;\n\t\tfor(int i=0,j=v.size()-1;i<j;i++,j--)\n\t\t{\n\t\t\tif(i==mid) i++; if(j==mid) j--;\n\t\t\tint tmp1=F[v[i]],tmp2=F[v[j]];\n\t\t\tfg&=(tmp1+tmp2)<=x;\n\t\t}\n\t\tif(fg) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l==v.size()) return false;\n\tF[rt]=F[v[l]]+1;\n\treturn F[rt]<=x+1;\n}\ninline bool check(int x)\n{\n\treturn dfs(Rt,0,x);\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); du[u]++;\n\t\taddedge(v,u); du[v]++;\n\t}\n\tint cnt=0; for(int i=1;i<=n;i++) \n\t\tcnt+=du[i]&1,Rt=du[i]==1? i:Rt;\n\t//Rt=1;\n\tint l=1,r=n,B=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid-1,B=mid;\n\t\telse l=mid+1;\n\t}\n\tcout << cnt/2 << \" \" << B << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) { assert(b==0); return 0; }\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=45;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0)data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if(v == pa) continue;\n\t\tif(! kt) return;\n\t\tchild++, dfs(v, u, lim);\n\t\tif(h[v] + 1 > lim) { kt = false; return; }\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t\tif(u == 1 && h[u] > lim) { kt = false; return; }\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if(adj[i].size() % 2) dem ++;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << (dem + 1) / 2  << ' ' << ans;\n}\n/*\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len && len!=1) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m+1) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 1;\n\tfor(int i=1;i<=N;i++){\n\t\tA += (v[i].size()-1)/2;\n\t}\n\tint l = 1,r = N;\n\twhile(l+1<r){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box%2)M++;\n\treturn 1;\n}\n\nint even(multiset<int>ms, int lim) {\n\tint box = MOD, ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tif (a > lim)K = 0;\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (it == ms.begin()) {\n\t\t\tif (box != MOD && ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse if (box != MOD) {\n\t\t\t\tret = a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbox = a;\n\t\t\t}\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tret %= MOD;\n\tif (ms.size())return *ms.begin();\n\treturn ret;\n}\n\nint odd(multiset<int>ms, int lim) {\n\tint ret = MOD;\n\twhile (ms.size() > 1) {\n\t\tint a = *ms.rbegin();\n\t\tauto it = ms.upper_bound(lim - a);\n\t\tif (a > lim)K = 0;\n\t\tif (it == ms.begin()) {\n\t\t\tif (ret != MOD) {\n\t\t\t\tK = 0;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = a;\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t\telse {\n\t\t\tms.erase(prev(it));\n\t\t\tms.erase(prev(ms.end()));\n\t\t}\n\t}\n\tif(ms.size())return *ms.begin();\n\treturn ret;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i, lim) + 1);\n\t}\n\t//cout << \"node \" << node << endl;\n\t//for (auto i : num[node]) {\n\t//\tcout << i << \" \";\n\t//}\n\t//cout << endl;\n\tif (num[node].size() % 2 == 1) {\n\t\t//cout << node << \" \" << odd(num[node], lim) << endl;\n\t\treturn odd(num[node], lim);\n\t}\n\telse {\n\t\t//cout << node << \" \" << even(num[node], lim) << endl;\n\t\treturn even(num[node], lim);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tauto box = Search(edge, dis, num, 0, mid);\n\t\tif (box > mid)K = 0;\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\nusing namespace std;\nusing pii = pair<int,int>;\n\nint n,L;\npii dp[100001];\nvector<int> adj[100001];\n\nvoid dfs(int cur,int p) {\n    dp[cur] = pii(0,0);\n    multiset<int> tr;\n    for(auto &it:adj[cur]) if(it!=p) {\n        dfs(it,cur);\n        dp[cur].fi += dp[it].fi;\n        if(dp[it].se+1==L) dp[cur].fi++;\n        else tr.insert(dp[it].se+1);\n    }\n\n    int mx=0;\n    while(sz(tr)>1) {\n        auto it=prev(tr.end());\n        auto jt=tr.upper_bound(L-*it);\n        if(jt==tr.begin()) {\n            if(mx) dp[cur].fi++;\n            mx = *it;\n        } else {\n            jt--;\n            if(jt==it) jt--;\n            dp[cur].fi++;\n            tr.erase(jt);\n        }\n        tr.erase(it);\n    }\n    if(!tr.empty()) {\n        if(mx) dp[cur].fi++;\n        mx = *tr.begin();\n    }\n    dp[cur].se = mx;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    for(int i=1,u,v;i<n;i++) {\n        scanf(\"%d%d\",&u,&v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    if(n==2) {\n        puts(\"1 1\");\n        return 0;\n    }\n\n    L=n;\n\n    int root=0;\n    for(int i=1;i<=n;i++) if(sz(adj[i])>1) {\n        root=i;\n        break;\n    }\n    dfs(root,0);\n    \n    int dt=dp[root].first+(dp[root].se>0);\n    int lo=0,up=n;\n    while(up-lo>1) {\n        L=(lo+up)>>1;\n        dfs(root,0);\n        if(dp[root].fi+(dp[root].se>0) > dt) lo=L;\n        else up=L;\n    }\n    printf(\"%d %d\\n\",dt,up);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,zero,b)\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a,T b){a=max(a,b);}\ntemplate<typename T> inline void minimize(T &a,T b){a=min(a,b);}\ntemplate<typename T> inline bool middle(T a,T b,T c){return b<=a && a<=c;}\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\ninline void outputVI(VI x){REP(i,SI(x)){cout << three(i,\" \",\"\") << x[i];}OUT(\"\");}\nconst int SIZE1=1e6+1000;\nconst int SIZE2=2020;\nconst int SIZE3=410;\nconst int SIZE=SIZE1;\nconst LL p=7+1e9;\nconst LL INF=1LL<<60;\nconst long double EPS=1e-7;\nstring S;\nut N,M,K,X,Y;\n// ut A,B,C,D,E,F,G,H,I,J,L,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE],nums[SIZE],maps[SIZE2][SIZE2],answer=zero;\n \n////////////////////////////////////////////////////////////////////////////////////////////\n \n////////////////////////////////////////////////////////////////////////////////////////////\nVI points[SIZE];\nbool reached[SIZE];\nint used[SIZE];\nbool able2(int x,int t){\n\tint s=0,e=points[x].size()-1;\n\twhile(s<=e){\n\t\tif(s==t){\n\t\t\ts++;\n\t\t}else if(e==t){\n\t\t\te--;\n\t\t}else{\n\t\t\tif(points[x][s]+points[x][e]>X) return false;\n\t\t\ts++;\n\t\t\te--;\n\t\t}\n\t}\n\treturn true;\n}\nint pack(int x){\n\tint s=0,e=points[x].size()-1;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tif(able2(x,f)) e=f-1;\n\t\telse s=f+1;\n\t}\n\tif(s==SI(points[x])) return -1;\n\treturn points[x][s];\n}\nbool able(int x){\n\tX=x;\n\tqueue<int> qu;\n\tEFOR(i,1,N){\n\t\tpoints[i].clear();\n\t\tif(SI(edges[i])==1) {\n\t\t\tqu.push(i);\n\t\t}\n\t}\n\n\twhile(!qu.empty()){\n\t\tint now=qu.front();\n\t\treached[now]=true;\n\t\tqu.pop();\n\t//\toutputVI(points[now]);\n\t\t//DEBUG(now);\n\t\tif(used[now]==SI(edges[now])){\n\t\t\tpoints[now].PB(0);\n\t\t\tif(SI(points[now])%2==0) points[now].PB(0);\n\t\t\tsort(ALL(points[now]));\n\t\t\treturn able2(now,0);\n\t\t}\n\t\tif(SI(points[now])%2==0) points[now].PB(0);\n\t\tsort(ALL(points[now]));\n\t\tint nokori=pack(now);\n\t\tif(nokori==-1) return false;\n\t\tREP(i,edges[now].size()){\n\t\t\tint next=edges[now][i];\n\t\t\tused[next]++;\n\t\t\tif(!reached[next] && used[next]>=SI(edges[next])-1){\n\t\t\t\tqu.push(next);\n\t\t\t\tpoints[next].PB(nokori+1);\n\t\t\t}else if(!reached[next]){\n\t\t\t\tpoints[next].PB(nokori+1);\t\n\t\t\t}\n\t\t}\n\t}\n}\nLL solve(){\n\tcin >> N;\n\tint a,b;\n\tREP(i,N-1){\n\t\tcin >>a >> b;\n\t\tedges[a].PB(b);\n\t\tedges[b].PB(a);\n\t}\n\tint A=1;\n\tEFOR(i,1,N){\n\t\tA+=(SI(edges[i])-1)/2;\n\t}\n\tint s=0,e=N-1;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tif(able(f)) e=f-1;\n\t\telse s=f+1;\n\t}\n\tcout << A <<\" \" << s << endl;\n\treturn 0;\n}\nsigned main(){\n//\tOUT(solve());\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int L=1e5+10;\nvector<int> es[L];\nint m;\nint f(int r,int p) {\n\tvector<int> len;\n\tfor(int i:es[r]){\n\t\tif(i==p)continue;\n\t\tint v=f(i,r);\n\t\tif(v>=m){\n\t\t\treturn m+1;\n\t\t}\n\t\tlen.push_back(v);\n\t}\n\tif(len.size()%2==0){\n\t\tlen.push_back(0);\n\t}\n\tsort(len.begin(),len.end());\n\tint low=-1;\n\tint hi=len.size();\n\twhile(low+1<hi){\n\t\tint c=(low+hi)/2;\n\t\tint h=0;\n\t\tint t=len.size()-1;\n\t\tif(h==c)h++;\n\t\tif(t==c)t--;\n\t\tbool ok=true;\n\t\twhile(h<t){\n\t\t\tif(len[h]+len[t]>m){\n\t\t\t\tok=false;\n\t\t\t}\n\t\t\th++;\n\t\t\tt--;\n\t\t\tif(h==c)h++;\n\t\t\tif(t==c)t--;\n\t\t}\n\t\tif(ok){\n\t\t\thi=c;\n\t\t}\n\t\telse{\n\t\t\tlow=c;\n\t\t}\n\t}\n\tif(hi<len.size()){\n\t\treturn len[hi]+1;\n\t}\n\treturn m+1;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tfor(int i=0;i<N-1;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tes[a].push_back(b);\n\t\tes[b].push_back(a);\n\t}\n\tint c=0;\n\tint s=0;\n\tfor(int i=1;i<=N;i++){\n\t\tc+=es[i].size()%2;\n\t\tif(es[i].size()==1){\n\t\t\ts=i;\n\t\t}\n\t}\n\n\tint low=0,hi=N-1;\n\twhile(low+1<hi){\n\t\tm=(low+hi)/2;\n\t\t//cerr << low << \", \" << hi << \", \" << m << \": \" << f(s,0) << endl;\n\t\tif(f(es[s][0],s)<=m){\n\t\t\thi=m;\n\t\t}\n\t\telse{\n\t\t\tlow=m;\n\t\t}\n\t}\n\tcout << c/2 << \" \" << hi << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nint a_dfs(const Graph& g, const int s)\n{\n    const int C = g.edge[s].size();\n    int sum = C / 2;\n    for (const int to : g.edge[s]) {\n        sum += a_dfs(g, to);\n    }\n    return sum;\n}\n\nint K;\nbool check(const vector<int>& a, const int ng, const int size)\n{\n    int tail = size - 1;\n    for (int i = 0; i < size; i++) {\n        if (tail == ng) {\n            tail--;\n        }\n        if (tail <= i) {\n            break;\n        }\n        const int sum = a[i] + a[tail];\n        if (sum + 1 > K) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool b_bfs(const Graph& g, const int s, vector<int>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> l;\n    for (const int to : g.edge[s]) {\n        const bool f = b_bfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        l.push_back(dp[to]);\n    }\n    sort(l.begin(), l.end());\n    if (C % 2 == 1) {\n        int inf = 0;\n        int sup = C;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            if (check(l, mid, C)) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == C or l[sup] + 1 > K) {\n            return false;\n        } else {\n            dp[s] = l[sup] + 1;\n            return true;\n        }\n    } else {\n        if (check(l, C, C)) {\n            dp[s] = 1;\n            return true;\n        } else if (l.back() + 1 > K) {\n            return false;\n        } else {\n            int inf = 0;\n            int sup = C - 1;\n            while (inf < sup) {\n                const int mid = (inf + sup) / 2;\n                if (check(l, mid, C - 1)) {\n                    sup = mid;\n                } else {\n                    if (inf == mid) {\n                        break;\n                    }\n                    inf = mid;\n                }\n            }\n            if (sup == C - 1 or l[sup] + 1 > K) {\n                return false;\n            } else {\n                dp[s] = l[sup] + 1;\n                return true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    vector<int> dim(N, 0);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n        dim[a]++;\n        dim[b]++;\n    }\n    int root = 0;\n    for (; root < N; root++) {\n        if (dim[root] == 1) {\n            break;\n        }\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, root, used);\n    const int A = a_dfs(g, root) + 1;\n\n    vector<int> dp(N, 0);\n    int inf = 0;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        const bool ok = b_bfs(g, root, dp);\n        if (ok) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    b_bfs(g, root, dp);\n    const int B = sup - 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\n#define pb push_back\n#define sz(a) int(a.size())\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,A,lim,f[N];\nvector<int> E[N];\nbool fl;\n\nbool check2(vector<int> &v,int mid) {\n\tint l=0,r=sz(v)-1;\n\twhile(l<r) {\n\t\tif(l==mid) { ++l;continue; }\n\t\tif(r==mid) { --r;continue; }\n\t\tif(v[l]+v[r]>lim) return 0;\n\t\t++l,--r;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int u,int fa) {\n\tvector<int> vec;\n\tfor(auto v:E[u]) if(v^fa) dfs(v,u),vec.pb(f[v]);\n\tif(vec.empty()) { f[u]=1;return; }\n\tif(sz(vec)&1^1) vec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=sz(vec);\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check2(vec,mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tif(l==sz(vec)) { fl=0;return; }\n\tf[u]=vec[l]+1;\n}\n\nbool check(int mid) {\n\tlim=mid;fl=1;dfs(1,0);\n\treturn fl&&f[1]<=lim+1;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tfor(int i=1;i<=n;i++)\n\t\tif(sz(E[i])&1) ++A;\n\tint l=0,r=n;\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<A/2<<' '<<l;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)\n\t\tif(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\twhile(1){\n\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\telse if(pre>0)tt--,pre--;\n\t\telse if(tt-suf==1){\n\t\t\tif(pre>0&&pre%2){\n\t\t\t\tif(now[tt]+now[1]+2<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse if(now[suf]+now[1]+2<=mid){f[u]=now[tt]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else {\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}else return false;\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;//printf(\"%d\\n\",dp(1,1,2));\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100009;\nint n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!fa && !s.empty()) {\n\t\tif (*s.begin() > limit) return -1;\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(1, 0) == -1) return 0;\n\treturn need == ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs1(1, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t\t\t\t\t\nusing namespace std;\n\t\t\t\ntypedef long long ll;\n#define mp make_pair\n#define pub push_back\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define db long double\n \nint n;\nvector<int> g[100007];\n \nint calcCnt(int v, int pred){\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tans += calcCnt(to, v);\n\t\tcnt++;\n\t}\n\tif (v != 0) cnt--;\n\tans += (cnt + 1) / 2;\n\treturn ans;\n}\n \nbool f;\nint ww;\n \nint dfs(int v, int pred){\n\tif (g[v].size() == 1 && g[v][0] == pred) return 0;\n\tvector<int> t;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tt.pub(dfs(to, v) + 1);\n\t}\n\tsort(all(t));\n\tif (t.back() > ww){\n\t\tf = 0;\n\t\treturn 0;\n\t}\n\tif (v == 0){\n\t\tif (t.size() % 2 == 1) t.pop_back();\n\t\tfor (int i = 0; i < t.size() / 2; i++){\n\t\t\tif (t[i] + t[(int)t.size() - i - 1] > ww){\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (t.size() % 2 == 0){\n\t\t\tbool ok = 1;\n\t\t\tfor (int i = 0; i < t.size() / 2; i++) if (t[i] + t[(int)t.size() - 1 - i] > ww) ok = 0;\n\t\t\tif (ok) return 0;\n\t\t\tt.pop_back();\n\t\t}\n\t\tint vl = -1, vr = t.size();\n\t\twhile(vl + 1 < vr){\n\t\t\tint vm = (vl + vr) >> 1;\n\t\t\tbool ok = 1;\n\t\t\tvector<int> tmp;\n\t\t\tfor (int i = 0; i < t.size(); i++) if (i != vm) tmp.pub(t[i]);\n\t\t\tfor (int i = 0; i < tmp.size() / 2; i++) if (tmp[i] + tmp[(int)tmp.size() - i - 1] > ww){\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tvr = vm;\n\t\t\telse\n\t\t\t\tvl = vm;\n\t\t}\n\t\tif (vr == t.size()){\n\t\t\tf = 0;\n\t\t\treturn 0;\n\t\t} \n\t\treturn t[vr];\n\t}\n}\n \nbool can(int val){ \n\tf = 1; ww = val;\n\tdfs(0, -1);\n\treturn f;\n}\n \nint main(){\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pub(b);\n\t\tg[b].pub(a);\n\t}\n \n\tint vl = 0, vr = 1e9 + 7;\n\twhile(vl + 1 < vr){\n\t\tint vm = (vl + vr) >> 1;\n\t\tif (can(vm))\n\t\t\tvr = vm;\n\t\telse\n\t\t\tvl = vm;\n\t}\n\tcout << calcCnt(0, -1) << ' ' << vr;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<bool, Int> P;\n\n\nvector<int> edge[110000];\nint n, u, v;\n\nP check(vector<int> &tmp, int b){\n    int k = tmp.size();\n    if(k == 1)return P(true, tmp[0]);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-2-i] > b)return P(false, 0);\n    for(int i = 0;i < k / 2;i++)\n        if(tmp[i] + tmp[k-1-i] > b)return P(true, tmp[k-1-i]);\n    for(int i = k/2+1;i > 0;i--)\n        if(tmp[i] + tmp[k-i] > b)return P(true, tmp[i]);\n    return P(true, tmp[0]);\n}\n\nP dfs(int x, int b, int last = -1){\n    vector<int> tmp;\n    for(auto to: edge[x]){\n        if(to == last)continue;\n        auto p = dfs(to, b, x);\n        if(!p.first)return P(false, 0);\n        if(p.second == b)return P(false, 0);\n        tmp.push_back(p.second + 1);\n    }\n    sort(tmp.begin(), tmp.end());\n    int k = tmp.size();\n    if(tmp.size() % 2 == 0){\n        bool ok = true;\n        for(int i = 0;i < k/2;i++)\n            if(tmp[i] + tmp[k-1-i] > b)ok = false;\n        if(ok)return P(true, 0);\n        tmp.pop_back();\n    }\n    return check(tmp, b);\n}\n\nint main(){\n    cin >> n;\n    int a = 0;\n    for(int i = 0;i < n-1;i++){\n        cin >> u >> v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    for(int i = 1;i <= n;i++)if(edge[i].size() % 2)a++;\n    a/=2;\n\n    int bottom  = 0, top = n;\n    while(top - bottom > 1){\n        int mid = (top + bottom) / 2;\n        if(dfs(1, mid).first)top = mid;\n        else bottom = mid;\n    }\n    cout << a << \" \" << top << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n;\nvi g[N];\n\nbool check(vi&f,int B,int skip) {\n  for(int i=0,j=sz(f)-1;i<j;++i,--j) {\n    if(i == skip) ++i;\n    if(j == skip) --j;\n    if(i < j && f[i] + f[j] > B)\n      return false;\n  }\n  return true;\n}\n\nint dfs(int c,int fa,int B) {\n  vi f;\n  for(auto t : g[c]) if(t != fa) {\n    f.pb(dfs(t , c , B));\n  }\n  if(~sz(f) & 1) f.pb(0);\n  sort(all(f));\n  if(!check(f , B , sz(f) - 1))\n    throw 1;\n  int l = -1 , r = sz(f) - 1;\n  while(l + 1 < r) {\n    int mid = (l + r) >> 1;\n    (check(f , B , mid) ? r : l) = mid;\n  }\n  return f[r] + 1;\n}\n\nbool check(int B,int rt) {\n  try {\n    int d = dfs(rt , 0 , B);\n    if(d > B + 1)\n      return false;\n    return true;\n  } catch(...) {\n    return false;\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,1,n) {\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  int A = 0;\n  rep(i,1,n+1) A += sz(g[i]) & 1;\n  int rt = 1;\n  while(~sz(g[rt]) & 1) rt++;\n  A >>= 1;\n  int l = 1 , r = n;\n  while(l + 1 < r) {\n    int mid = (l + r) >> 1;\n    (check(mid , rt) ? r : l) = mid;\n  }\n  printf(\"%d %d\\n\",A,r);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\n\nint n;\nvector<int> gph[MAXN];\nvector<int> dfn;\n\nint dp[MAXN];\n\nint query(int k){\n\tfor(auto &i : dfn){\n\t\tif(i == 1) break;\n\t\tvector<int> v;\n\t\tfor(auto &j : gph[i]) v.push_back(dp[j] + 1);\n\t\tsort(v.begin(), v.end());\n\t\tauto trial_pos = [&](int x){\n\t\t\tint l = 0, r = v.size() - 1;\n\t\t\tfor(int i=0; i<v.size()/2; i++){\n\t\t\t\tif(l == x) l++;\n\t\t\t\tif(r == x) r--;\n\t\t\t\tif(v[l] + v[r] > k) return 0;\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\t\tif(v.size() % 2 == 0){\n\t\t\tv.insert(v.begin(), 0);\n\t\t}\n\t\tint s = 0, e = v.size();\n\t\twhile(s != e){\n\t\t\tint m = (s+e)/2;\n\t\t\tif(trial_pos(m)) e = m;\n\t\t\telse s = m + 1;\n\t\t}\n\t\tif(s == v.size() || v[s] >= k) return 0;\n\t\tdp[i] = v[s];\n\t}\n\tvector<int> v;\n\tfor(auto &i : gph[1]) v.push_back(dp[i] + 1);\n\tsort(v.begin(), v.end());\n\tif(v.back() > k) return 0;\n\tif(v.size() % 2 == 1) v.pop_back();\n\tfor(int i=0; i<v.size()/2; i++){\n\t\tif(v[i] + v[v.size()-i-1] > k) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int x){\n\tdfn.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tgph[i].erase(find(gph[i].begin(), gph[i].end(), x));\n\t\tdfs(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1);\n\tint ans = n - 1;\n\tfor(int i=1; i<=n; i++){\n\t\tans -= ((i != 1) + gph[i].size()) / 2;\n\t}\n\tint s = 1, e = n;\n\treverse(dfn.begin(), dfn.end());\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(!query(m)) s = m+1;\n\t\telse e = m;\n\t}\n\tprintf(\"%d %d\\n\", ans, s);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root,int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to,root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size();\n\tif (len % 2==0) {\n\t\tbool g = true;\n\t\trep(i, len / 2) {\n\t\t\tif (v[i] + v[len - i - 1] > c)g = false;\n\t\t}\n\t\tif (g)return 1;\n\t\telse {\n\t\t\tv.pop_back(); len--;\n\t\t}\n\t}\n\t\tmultiset<int> mt;\n\t\trep(i, len)mt.insert(v[i]);\n\t\trep(i, len / 2) {\n\t\t\tauto itr = mt.end(); itr--;\n\t\t\tint z = *itr; mt.erase(itr);\n\t\t\tint r = c - z;\n\t\t\tif (mt.count(r)) {\n\t\t\t\tmt.erase(mt.find(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt.insert(r);\n\t\t\t\tauto itr2 = mt.find(r);\n\t\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\titr2--; mt.erase(r);\n\t\t\t\tint zz = *itr2;\n\t\t\t\tif (zz + z > c) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\tmt.erase(itr2);\n\t\t\t}\n\t\t}\n\t\tint z = *mt.begin();\n\t\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa<<\" \"<<ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(s.size() == 1 || other==s.end()) {\n\t\t\t\tdp[x].f += dp[x].s > 0;\n\t\t\t\tdp[x].s = y;\n\t\t\t\ts.erase(s.begin());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tdp[x].s += x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=45;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}assert(en^45);\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\n\nbool good;\nint c;\n\nint iso(VI &a){\n    int n = a.size();\n    int ok = n-1, ng = -1;\n    while (ok - ng > 1){\n        int mi = (ok + ng) / 2;\n        bool f = true;\n        REP(i,n/2){\n            int x = i;\n            if (x >= mi) x++;\n            int y = n - 1 - i;\n            if (y <= mi) y--;\n            if (a[x] + a[y] > c) f = false;\n        }\n        if (f) ok = mi;\n        else ng = mi;\n    }\n    return a[ok];\n}\n\nint dfs(int now, int past){\n    if (!good) return 0;\n    VI a;\n    for (int next : e[now]){\n        if (next == past) continue;\n        a.push_back(dfs(next, now) + 1);\n    }\n    sort(ALL(a));\n    int n = a.size();\n    // cout << now << \" \" << n << endl;\n    if (n == 0) return 0;\n    if (a.back() > c) good = false;\n    if (n % 2 == 0){\n        // cout << \"even\" << endl;\n        bool f = true;\n        REP(i,n/2){\n            if (a[i] + a[n-1-i] > c) f = false;\n        }\n        if (f) return 0;\n        a.pop_back();\n        return iso(a);\n    }\n    REP(i,n/2){\n        if (a[i] + a[n-2-i] > c) good = false;\n    }\n    return iso(a);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--;b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n\n    int a = 0;\n    REP(i,n) a += (e[i].size() % 2);\n    a = (a + 1) / 2;\n\n    int root;\n    REP(i,n) if (e[i].size() == 1) root = i;\n\n    // cout << \"root\" << root << endl;\n\n    int ok = n, ng = 0;\n    while (ok - ng > 1){\n        c = (ok + ng) / 2;\n        // cout << c << endl;\n        good = true;\n        dfs(root, -1);\n        if (good) ok = c;\n        else ng = c;\n    }\n\n\n    cout << a << \" \" << ok << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\nlong long int mod = 1000000007;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll number1,ll number2){\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1 , number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1 , number1);\n    }\n}\n\nll i,j,k,ii,jj,n,m;\nll a,b,c,d,e,g,h,r,num,sum;\nll x[500005],y[500005],z[500005];\nll ans;\nbool used[500005];\nbool dame;\n\nvoid bfs(ll v,ll color,ll cost){\n    x[v] = color;\n    if(G[v].size() % 2 == 1 && v != color){\n        //pe(\"color = \");p(color);\n       // pe(\"cost = \");p(cost);\n        ans = min(ans,cost);\n        return;\n    }\n    for(int i = 0;i < G[v].size(); i ++){\n        ll nv = G[v][i];\n        if(x[nv] != color){\n            bfs(nv,color,cost + 1);\n        }\n    }\n    return;\n}\n\nint main(){\n    cin >> n;\n    for(i=0;i<n-1;i++){\n        cin >> a >> b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    a = 0;\n    b = 0;\n    for(i=1;i<=n;i++){\n        if(G[i].size() % 2 == 1){\n            a++;\n        }\n    }\n    a = a / 2;\n    pe(a);\n    for(i=1;i<=n;i++){\n        if(G[i].size() % 2 == 1){\n            ans = INF;\n            bfs(i,i,0);\n            num = max(num,ans);\n        }\n    }\n    for(i=num;i<=n;i++){\n        if(i * a + 1 >= n){\n            p(i);\n            return 0;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    s.clear();\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl)\n                return 0;\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    if(x==1)\n        flag--;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        if(t>maxl)\n            return 0;\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==1)\n                dp[x]=t;\n            flag=-1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tint tmp = DFS(to, i, len);\n\t\tif (tmp == INF) return INF;\n\t\tlens.push_back(tmp + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() || lens[hi] > len ? INF : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 0,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin>>n;\n  vvi G(n);\n  FOR(i,n-1) {\n    int a,b; cin>>a>>b;\n    --a; --b;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  { int a = 0;\n    FOR(i,n) if(G[i].size()&1) a += 1;\n    cout << a/2 << ' ';\n  }\n\n  auto ok = [&](int i, int b) -> bool {\n    function<int(int, int)> dfs = [&](int i, int p) -> int {\n      deque<int> rs;\n      for(int j : G[i]) if(j != p) {\n          int r = dfs(j,i);\n          if(r>b) throw 0;\n          rs.pb(r);\n      }\n      sort(all(rs));\n      if(p == -1) {\n        if(rs.size()&1) {\n          rs.pop_back();\n        }\n        FOR(i,rs.size()) if(rs[i]+rs[rs.size()-1-i] > b) throw 0;\n        return 0;\n      }else{\n        if((rs.size()&1) == 0) rs.pb(0);\n        int r0 = rs.front(); rs.pop_front();\n        while(!rs.empty()) {\n          if(rs.front()+rs.back() > b) {\n            if(r0+rs.back() > b) throw 0;\n            r0 = rs.front(); rs.pop_front(); rs.pop_back();\n          }else{\n            rs.pop_front();\n            rs.pop_back();\n          }\n        }\n        return r0+1;\n      }\n    };\n    try {\n      dfs(i,-1);\n      return 1;\n    } catch(int){\n      return 0;\n    }\n  };\n\n  vi IS(n); iota(all(IS),0);\n  random_shuffle(all(IS));\n\n  int ans = n+n;\n\n  FOR(k,min<int>(4,IS.size())) {\n    int lo = 1, hi = n+n;\n    while(lo != hi) {\n      int mi = (lo+hi)/2;\n      if(ok(IS[k], mi)) { hi = mi; }\n      else { lo = mi+1; }\n    }\n    ans=min(ans,lo);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define pconent(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \" \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e5 + 5;\nint n;\nvi adj[maxn];\nint mi;\npi dp[maxn];\n\nint func(vi& vals, int x) {\n    int ptr = sz(vals) - 1;\n    int num = 0;\n    FOR(i, 0, sz(vals)) if (i != x) {\n        while (ptr > i && vals[i] + vals[ptr] > mi) {\n            ptr--;\n        }\n        if (ptr == x) ptr--;\n        if (ptr <= i) {\n            break;\n        }\n        num++;\n        ptr--;\n    }\n    return num;\n}\n\npi calc(int u, int p) {\n    pi& res = dp[u];\n    if (res != mp(-1, -1)) return res;\n    res = mp(INF, INF);\n    vi vals;\n    int tot = 0;\n    for (int v : adj[u]) {\n        if (v != p) {\n            pi r = calc(v, u);\n            tot += r.fi;\n            vals.pb(r.se + 1);\n        }\n    }\n    vi tmp = vals;\n    sort(all(vals));\n    int mx = func(vals, sz(vals) - 1);\n    int lo = 0, hi = sz(vals) - 1;\n    while (lo < hi) {\n        int m = lo + hi >> 1;\n        if (func(vals, m) < mx) {\n            lo = m + 1;\n        }\n        else {\n            hi = m;\n        }\n    }\n    int m = lo + hi >> 1;\n    int cnt = 0;\n    for (int v : adj[u]) {\n        if (v != p) {\n            int sum = tot + sz(tmp) - mx - 1;\n            if (tmp[cnt] < vals[m]) {\n                sum++;\n            }\n            if (tmp[cnt] == mi) {\n                chkmin(res, mp(sum + 1, 0));\n            }\n            else {\n                chkmin(res, mp(sum, tmp[cnt]));\n            }\n            cnt++;\n        }\n    }\n    chkmin(res, mp(tot + sz(tmp) - func(vals, -1), 0));\n    return res;\n}\n\ninline int ff(pi p) {\n    return p.fi + (p.se > 0);\n}\n\nvoid solve() {\n    cin >> n;\n    FOR(i, 0, n - 1) {\n        int u, v; cin >> u >> v; u--, v--;\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    fill_n(dp, n, mp(-1, -1));\n    mi = n;\n    pi mn = calc(0, -1);\n    int lo = 1, hi = n;\n    while (lo < hi) {\n        mi = lo + hi >> 1;\n        fill_n(dp, n, mp(-1, -1));\n        if (ff(calc(0, -1)) > ff(mn)) {\n            lo = mi + 1;\n        }\n        else {\n            hi = mi;\n        }\n    }\n    mi = lo + hi >> 1;\n    cout << ff(mn) << \" \" << mi << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    solve();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint mx;\nint num;\n\nvoid pre(int v, int p)\n{\n\tint cnt = 0;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tpre(to, v);\n\t\t++cnt;\n\t}\n\n\tnum += (cnt / 2);\n\tif (p == -1) {\n\t\tif (cnt & 1) ++num;\n\t}\n}\n\nint dfs(int v, int p, int x)\n{\n\tvi vec;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tint u = dfs(to, v, x);\n\t\tif (u == -1 || u >= x) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(u + 1);\n\t}\n\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tmultiset<int> ss;\n\tfor (int x : vec) {\n\t\tss.insert(x);\n\t}\n\n\tint ng_cnt = 0;\n\tint val = -1;\n\n\twhile (ss.size() >= 2) {\n\t\tint a = *ss.rbegin();\n\t\tss.erase(ss.lower_bound(a));\n\t\tauto it = ss.upper_bound(x - a);\n\n\t\tif (it == ss.begin()) {\n\t\t\tif (ng_cnt > 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tng_cnt++;\n\t\t\tval = a;\n\t\t} else {\t\t\n\t\t\t--it;\n\t\t\tss.erase(it);\n\t\t}\n\t}\n\n\t//ng_cnt <= 1, ss.size() <= 1\n\n\tif (p == -1) {\n\t\tif (sz & 1) {\n\t\t\tif (ng_cnt + ss.size() > 1) {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tif (ng_cnt || ss.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ss.size() && ng_cnt) {\n\t\treturn min(*ss.begin(), val);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nbool ok(int x)\n{\n\tint t = dfs(0, -1, x);\n\t//cout << t << endl;\n\treturn (t != -1);\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tpre(0, -1);\n\n\tint lo = 0, hi = N;\n\t//ok(2);\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tcout << num << \" \" << hi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    s.clear();\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa){\n            if(dp[a[x][i]]+1>maxl){\n                return 0;\n            }\n            s.insert(dp[a[x][i]]+1);\n        }\n    int flag=0;\n    if(s.size()%2==1)\n        flag=1;\n    if(x==1)\n        flag--;\n    /*if(x==83)\n        for(int i=0;i<a[x].size();i++)\n            if(a[x][i]!=fa)\n                PF(\"{%d} \",dp[a[x][i]]+1);*/\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==-1){\n                return 0;\n            }\n            if(flag==1){\n                dp[x]=t;\n                flag=-1;\n            }\n            else\n                flag=1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl){\n            return 0;\n        }\n        s.erase(dp[x]);\n    }\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    //freopen(\"data.in\",\"r\",stdin);\n    //freopen(\"data.out\",\"w\",stdout);\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    //PF(\"[%d]\",check(6));\n    l=1,r=n;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 200010;\n\nstruct edge{int to, next;} e[N];\nint du[N], head[N], a[N], f[N];\nint n, x, y, cnt, tot, ans1, ans2, rt;\nbool fl;\n\nvoid ins(int x, int y)\n{\n    e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt; ++du[x];\n}\n\nbool check2(int mid, int len)\n{\n    int i = 1, j = tot;\n    if (i == mid) ++i;\n    if (j == mid) --j;\n\n    for(; i < j;)\n    {\n        if (a[i] + a[j] > len) return 0;\n        ++i, --j;\n        if (i == mid) ++i;\n        if (j == mid) --j;\n    }\n    return 1;\n}\n\nvoid dfs(int x, int y, int len)\n{\n    for(int i = head[x]; i; i = e[i].next)\n        if (e[i].to != y) dfs(e[i].to, x, len);\n    tot = 0;\n    for(int i = head[x]; i; i = e[i].next)\n        if (e[i].to != y) a[++tot] = f[e[i].to];\n    if (!tot) {f[x] = 1; return;}\n\n    if (!(tot & 1)) a[++tot] = 0;\n    sort(a + 1, a + tot + 1);\n\n    int l = 1, r = tot, U = n + 1;\n    while (l <= r)\n    {\n        int mid = (l + r) >> 1;\n        if (check2(mid, len)) U = a[mid], r = mid - 1; else l = mid + 1;\n    }\n    if (U == n + 1) fl = 1;\n    f[x] = U + 1;\n}\n\nbool check(int len)\n{\n    bool fl = 0; dfs(rt, 0, len);\n    return !fl && f[rt] <= len + 1;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    FOR(i, 2, n)\n    {\n        scanf(\"%d%d\", &x, &y);\n        ins(x, y); ins(y, x);\n    }\n    FOR(i, 1, n) if (du[i] & 1) rt = i, ++ans1;\n    ans1 >>= 1;\n    int l = 1, r = n;\n    while (l <= r)\n    {\n        int mid = (l + r) >> 1;\n        if (check(mid)) r = mid - 1, ans2 = mid; else l = mid + 1;\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define pb push_back\nconst int N=1e5+5;\nint n;\nvector<int>lk[N],son[N];\n\nint A;\nnamespace GET_A\n{\nvoid dfs(int x,int fr)\n{\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tson[x].pb(y);\n\t\tdfs(y,x);\n\t}\n//\tcerr<<x<<\" \"<<son[x].size()<<endl;\n//\tfor(auto y:son[x])cerr<<y<<\" \";puts(\"\");\n\tA+=son[x].size()/2;\n}\n};\nnamespace GET_B\n{\nint len[N];\nint mid;\nbool len_xiao(int x,int y)\n{\n\treturn len[x]<len[y];\n}\nbool dfs(int x)\n{\n\tif(!son[x].size())\n\t{\n\t\tlen[x]=1;\n\t\treturn 0;\n\t}\n\tfor(auto y:son[x])\n\tif(dfs(y))return 1;\n\tsort(son[x].begin(),son[x].end(),len_xiao);\n\tint l=0,r=son[x].size()-1;\n\tif(r%2==1)\n\t{\n\t\tif(len[son[x][r]]+1>mid)return 1;\n\t\t--r;\n\t}\n\twhile(l!=r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+2>mid)break;\n\t\t++l;--r;\n\t}\n\tlen[x]=len[son[x][r]]+1;\n\t--r;\n\twhile(l<r)\n\t{\n\t\tif(len[son[x][l]]+len[son[x][r]]+2>mid)break;\n\t\t++l;--r;\n\t}\n\treturn 0;\n}\nbool ok()\n{\n\tif(dfs(1))return 0;\n\tif(len[1]>mid)return 0;\n\treturn 1;\n}\nint erfen()\n{\n\tint l=1,r=n;\n\twhile(l+1!=r)\n\t{\n\t\tmid=(l+r)/2;\n\t\tif(ok())r=mid;\n\t\telse l=mid;\n\t}\n\treturn r;\n}\n};\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tcin>>n;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlk[x].pb(y);lk[y].pb(x);\n\t}\n\tGET_A::dfs(1,0);\n\t++A;\n\tint B=GET_B::erfen();\n\tcout<<A<<\" \"<<B-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  rep(i,0,n){\n    if(g[i].size()&1)res++;\n  }\n  ll ok=n,ng=0;\n  while(ok-ng>=2){\n    ll mid=(ok+ng)/2;\n    bool sw=true;\n    auto dfs=[&](auto &&f,ll k,ll par)->ll{\n      vector<ll>v;\n      if(g[k].size()&1)v.PB(0);\n      for(auto to:g[k]){\n        if(to==par)continue;\n        ll p=f(f,to,k);\n        if(p!=-1)v.PB(p);\n      }\n      sort(ALL(v));\n      ll sz=v.size();\n      rep(i,0,sz/2){\n        if(v[i]+v[sz-i-1]>mid)sw=false;\n      }\n      if(sz%2==0){\n        return -1;\n      }\n      else{\n        ll ok=sz-1,ng=-1;\n        while(ok-ng>=2){\n          ll mid2=(ok+ng)/2;\n          vector<ll>tmp;\n          rep(i,0,sz)if(i!=mid2)tmp.PB(v[i]);\n          bool sw2=true;\n          rep(i,0,sz/2){\n            if(tmp[i]+tmp[sz-i-2]>=mid)sw2=false;\n          }\n          if(sw)ok=mid2;\n          else ng=mid2;\n        }\n        return v[ok]+1;\n      }\n    };\n    dfs(dfs,0,-1);\n    if(sw)ok=mid;\n    else ng=mid;\n  }\n  cout<<res/2 spa ok<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 100010 * 2;\nconst int INF = 1<<30;\n\nvector<int> g[maxn];\nint father[maxn];\nint root = 1;\nbool flg;\nint dp[maxn];\nint n;\n\nvoid link(int u, int v)\n{\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nbool check2(int r, vector<int> son, int B)\n{\n\tson.erase(son.begin()+r);\n\tfor (int i=0;i<son.size();i++)\n\t{\n\t\tint j = son.size() - 1- i;\n\t\tif (son[i] + son[j] > B) return false;\n\t}\n\treturn true;\n}\n\nvoid dfs2(int u, int f, int B)\n{\n\tvector<int> son; son.clear();\n\tfor (int i=0;i<g[u].size();i++)\n\t{\n\t\tint v = g[u][i];\n\t\tif (v == f) continue;\n\t\tdfs2(v,u,B);\n\t\tson.push_back(dp[v]);\n\t}\n\tsort(son.begin(), son.end());\n\tint size = son.size();\n\n\tif (size % 2 == 1) //u为偶度点\n\t{\n\t\tint lb = 0, ub = size-1; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tif (!check2(lb,son,B)) flg = false; //无论怎么样都满足不了要求\n\t\tdp[u] = son[lb] + 1;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n\telse //u为奇度点\n\t{\n\t\tson.push_back(0); //如果选中0表示u作为新的起点，如果没有选中，表示有一个儿子是通过u出去的\n\t\tsort(son.begin(), son.end());\n\t\tint lb = 0, ub = size; //[lb,ub]\n\t\twhile (ub - lb >= 1)\n\t\t{\n\t\t\tint mid = (ub + lb)/2;\n\t\t\tif (check2(mid,son,B)) ub = mid;\n\t\t\telse lb = mid+1;\n\t\t}\n\t\tdp[u] = son[lb] + 1;\n\t\tif (!check2(lb,son,B)) flg = false;\n\t\tif (dp[u] > B && u != root) flg = false; \n\t}\n}\n\nbool check1(int B)\n{\n\tfor (int i=0;i<=n+10;i++) dp[i] = INF;\n\tflg = true;\n\tdfs2(root,0,B);\n\t//cout<<B<<\" \"<<flg<<\" \"<<dp[root]<<endl;\n\tif (flg == false || dp[root] > B+1) return false;\n\telse return true;\n}\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tlink(u,v);\n\t}\n\n\tint oddNum = 0;\n\tfor (int i=1;i<=n;i++) oddNum += g[i].size() % 2;\n\tint A = oddNum / 2;\n\n\tint Blb = 0, Bub = n-1; //[Blb,Bub]\n\twhile (Bub - Blb >= 1)\n\t{\n\t\tint mid = (Blb + Bub)/2;\n\t\tif (check1(mid)) Bub = mid;\n\t\telse Blb = mid+1;\n\t}\n\n\tprintf(\"%d %d\\n\",A,Bub);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100100;\n\nint n,A,B,mid,dp[maxn];\nvector<int> g[maxn];\n\nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            temp.push_back(dp[v]);\n        }\n    }\n    sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n  //  cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=-1,rr=temp.size();\n        while (ll+1<rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n           // cout<<x<<endl;\n            while (p1<p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > mid) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                rr = x;\n            }\n            else ll = x;\n        }\n       // cout<<rr<<endl;\n        if (rr==temp.size()) return false;\n        dp[u] = temp[rr] + 1;\n        return true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n  //  freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=0,r=n;\n    while (l<=r) {\n        mid = (l+r)/2;\n        if (visit(1,-1)) {\n            B = mid;\n            r = mid-1;\n        } else l = mid+1;\n    }\n    cout<<B;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt, lo, hi, mi, ta, tb;\nvector< int > v[100005];\nmultiset< int > mm;\nmultiset< int >::iterator it;\n\nint dfs(int a, int b) {\n\tmultiset< int > re = multiset< int >();\n\tfor (int i = 0; i < v[a].size(); i++)\n\t\tif (v[a][i] != b) {\n\t\t\tint tt = dfs(v[a][i], a);\n\t\t\tif (tt == -1 || tt + 1 > mi) {\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tre.insert(tt + 1);\n\t\t}\n\tint ret = 0;\n\t//printf(\"%d:\", a); for (it = re.begin(); it != re.end(); it++) printf(\" %d\", *it); printf(\"\\n\");\n\tmm = re;\n\twhile (!re.empty()) {\n\t\tit = re.end();\n\t\tit--;\n\t\tta = *it;\n\t\tre.erase(it);\n\t\tit = re.upper_bound(mi - ta);\n\t\tif (it == re.begin()) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = ta;\n\t\t\telse {\n\t\t\t\tif (b != 0 && mm.size() % 2 == 0) {\n\t\t\t\t\tre = mm;\n\t\t\t\t\tit = re.end();\n\t\t\t\t\tit--;\n\t\t\t\t\tre.erase(it);\n\t\t\t\t\tret = 0;\n\t\t\t\t\twhile (!re.empty()) {\n\t\t\t\t\t\tit = re.end();\n\t\t\t\t\t\tit--;\n\t\t\t\t\t\tta = *it;\n\t\t\t\t\t\tre.erase(it);\n\t\t\t\t\t\tit = re.upper_bound(mi - ta);\n\t\t\t\t\t\tif (it == re.begin()) {\n\t\t\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\t\t\tret = ta;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tre.clear();\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tit--;\n\t\t\t\t\t\t\tre.erase(it);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"ret %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tit--;\n\t\t\tre.erase(it);\n\t\t}\n\t}\n\t//printf(\"re %d\\n\", ret);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tv[ta].push_back(tb);\n\t\tv[tb].push_back(ta);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt += v[i].size() % 2;\n\tlo = 1, hi = n + 1;\n\twhile (lo < hi) {\n\t\tmi = (lo + hi) / 2;\n\t\t//printf(\"mi %d\\n\", mi);\n\t\tif (dfs(1, 0) != -1)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\tprintf(\"%d %d\\n\", cnt / 2, lo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)\n\t\tif(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\twhile(1){\n\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\telse if(pre>0)tt--,pre--;\n\t\telse if(tt-suf==1){\n\t\t\tif(u==1)return false;\n\t\t\tif(pre>0&&pre%2){\n\t\t\t\tif(now[tt]+now[1]+2<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t//\t\telse if(now[suf]+now[1]+2<=mid){f[u]=now[tt]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else {\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}else return false;\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;//printf(\"%d\\n\",dp(1,1,2));\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint B, r;\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\tassert(i >= 0);\n\t\treturn v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\ttr = 0;\n\tfor (i = 1; i <= n; i++) tr += g[i].size() % 2;\n\ttr >>= 1;\n\tB = n;\n\tif (f(1, 1)) r++;\n\tassert(r == tr);\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tif (f(1, 1)) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nvector<int> lis[100100];\nvector<int> cdp[100100];\nint dp[100100];\n\nbool dfs(int here, int p, int t) {\n    cdp[here].clear(); int i, j;\n    for (auto &there : lis[here]) {\n        if (there==p) continue;\n        if (!dfs(there,here,t)) return false;\n        cdp[here].push_back(dp[there]+1);\n    }\n    sort(cdp[here].begin(),cdp[here].end());\n    if (cdp[here].empty()) {\n        dp[here] = 0;\n        return true;\n    }\n    if (p<0) {\n        for (i=0,j=(int)cdp[here].size()/2*2-1;i<j;i++,j--) {\n            if (cdp[here][i]+cdp[here][j]>t) return false;\n        }\n        if (cdp[here].back()>t) return false;\n        return true;\n    }\n    if (cdp[here].size()%2==0) {\n        for (i=0,j=(int)cdp[here].size()-1;i<j;i++,j--) {\n            if (cdp[here][i]+cdp[here][j]>t) break;\n        }\n        if (i>=j) {\n            dp[here] = 0;\n            return true;\n        }\n        if (cdp[here].back()>t) return false;\n    }\n    int cur = 0;\n    for (i=1,j=((int)cdp[here].size()-1)/2*2;i<j;i++,j--) {\n        if (cdp[here][i]+cdp[here][j]>t) {\n            cur = i;\n            if (cdp[here][i-1]+cdp[here][j]>t) break;\n        }\n    }\n    if (i>=j) {\n        dp[here] = cdp[here][cur];\n        return true;\n    }\n    cur = ((int)cdp[here].size()-1)/2*2; int fl = 0;\n    for (i=0,j=((int)cdp[here].size()-1)/2*2-1;i<j;i++,j--) {\n        if (cdp[here][i]+cdp[here][j]>t) return false;\n        if (cdp[here][i]+cdp[here][j+1]<=t&&!fl) cur = j;\n        else fl = 1;\n    }\n    dp[here] = cdp[here][cur];\n    return true;\n}\n\nbool ok(int t) {\n    return dfs(0,-1,t);\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d\",&n);\n    for (i=0;i<n-1;i++){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);--a;--b;\n        lis[a].push_back(b);\n        lis[b].push_back(a);\n    }\n    int r1 = 1;\n    for (i=0;i<n;i++) r1 += ((int)lis[i].size()-1)/2;\n    printf(\"%d \",r1);\n    int s = 0, e = n;\n    while(s<=e) {\n        int m = (s+e)>>1;\n        if (ok(m)) e = m-1;\n        else s = m+1;\n    }\n    printf(\"%d\\n\",s);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[100009], b[100009], sum, G, dp[100009]; vector<int>x[100009]; bool used[100009], flag = false;\n\nint solve(vector<int>F) {\n\tint res = 0;\n\tfor (int i = 0; i < F.size(); i++) res = max(res, F[i] + F[F.size() - 1 - i]);\n\treturn res;\n}\n\nint dfs(int pos) {\n\tif (flag == true) return (1 << 30);\n\tused[pos] = true;\n\tvector<int>I;\n\tfor (int i = 0; i < x[pos].size(); i++) {\n\t\tif (used[x[pos][i]] == true) continue;\n\t\tI.push_back(dfs(x[pos][i]) + 1);\n\t\tif (flag == true) return (1 << 30);\n\t}\n\tif (I.size() == 0) {\n\t\tdp[pos] = 0;\n\t\treturn 0;\n\t}\n\tsort(I.begin(), I.end());\n\tif (I[I.size() - 1] > G) {\n\t\tflag = true;\n\t\treturn (1 << 30);\n\t}\n\tdp[pos] = (1 << 30);\n\tif (I.size() % 2 == 0) {\n\t\tif (solve(I) <= G) {\n\t\t\tdp[pos] = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (x[pos].size() % 2 == 1) I.pop_back();\n\tif (I.size() % 2 == 1) {\n\t\tint L = 0, R = I.size(), M, maxn = (1 << 30);\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tvector<int>J; for (int j = 0; j < I.size(); j++) { if (j != M) J.push_back(I[j]); }\n\t\t\tint ret = solve(J);\n\t\t\tif (ret <= G) { R = M; maxn = min(maxn, M); }\n\t\t\telse { L = M; }\n\t\t}\n\t\tif (maxn != (1 << 30)) {\n\t\t\tdp[pos] = min(dp[pos], I[maxn]);\n\t\t}\n\t}\n\tif (dp[pos] == (1 << 30)) {\n\t\tflag = true;\n\t}\n\treturn dp[pos];\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) { if (x[i].size() % 2 == 1) sum++; }\n\tint L = 1, R = n + 1, M, minx = (1 << 30);\n\tfor (int i = 0; i < 20; i++) {\n\t\tM = (L + R) / 2; M = 4; G = M;\n\t\tfor (int j = 1; j <= n; j++) used[j] = false; flag = false;\n\t\tint F = dfs(1);\n\t\tif (F <= M) { R = M; minx = M; }\n\t\telse { L = M; }\n\t}\n\tcout << sum / 2 << \" \" << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> edge[100001];\nvector<int> v[100001];\nint val,dp[100001];\nbool bad;\nint dfss(int x,int p){\n\tint res=0;\n\tfor(int i:edge[x]){\n\t\tif(i==p)\tcontinue;\n\t\tres+=dfss(i,x);\n\t}\n\treturn (edge[x].size()-1)/2+res;\n}\n\nint dfs(int x,int p){\n\tv[x].clear();\n\tfor(int i:edge[x]){\n\t\tif(i==p)\tcontinue;\n\t\tv[x].push_back(dfs(i,x)+1);\n\t}\n\tsort(v[x].begin(),v[x].end());\n\tdp[x]=0;\n\tif(v[x].size()&1){\n\t\tint L=0,R=v[x].size();\n\t\twhile(L<R){\n\t\t\tint M=(L+R)/2,st=0,en=v[x].size()-1;\n\t\t\tdp[x]=0;\n\t\t\twhile(st<en){\n\t\t\t\tif(st==M){\n\t\t\t\t\tst++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(en==M){\n\t\t\t\t\ten--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[x]=max(dp[x],v[x][st++]+v[x][en--]);\n\t\t\t}\n\t\t\tif(dp[x]>val)\n\t\t\t\tL=M+1;\n\t\t\telse\n\t\t\t\tR=M;\n\t\t}\n\t\tif(R==v[x].size()){\n\t\t\tbad=true;\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tif(v[x][L]>val)\n\t\t\t\tbad=true;\n\t\t\treturn v[x][L];\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\tdp[x]=max(dp[x],v[x][i]+v[x][v[x].size()-i-1]);\n\t\tif(dp[x]>val){\n\t\t\tif(x==1){\n\t\t\t\tbad=true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(v[x].back()>val){\n\t\t\t\tbad=true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint L=0,R=v[x].size()-1;\n\t\t\twhile(L<R){\n\t\t\t\tint M=(L+R)/2,st=0,en=v[x].size()-2;\n\t\t\t\tdp[x]=0;\n\t\t\t\twhile(st<en){\n\t\t\t\t\tif(st==M){\n\t\t\t\t\t\tst++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(en==M){\n\t\t\t\t\t\ten--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[x]=max(dp[x],v[x][st++]+v[x][en--]);\n\t\t\t\t}\n\t\t\t\tif(dp[x]>val)\n\t\t\t\t\tL=M+1;\n\t\t\t\telse\n\t\t\t\t\tR=M;\n\t\t\t}\n\t\t\tif(R==v[x].size()-1){\n\t\t\t\tbad=true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn v[x][L];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\nbool check(int x){\n\tbad=false;\n\tval=x;\n\tdfs(1,0);\n\tif(bad)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0,u,v;i<n-1;i++){\n\t\tcin>>u>>v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tint l=1,r=100000;\n\twhile(l<r){\n\t\tint mid=(l+r)/2;\n\t\tif(check(mid))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<dfss(1,0)+1<<' '<<l<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 100010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, ans = 0, md;\nvector<int> g[N];\n\nint all = 0;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tint add = 1 + dfs(v, u);\n\t\t++nt;\n\t\tst.insert(add);\n\t}\n\n\tnt = nt / 2;\n\tall += nt;\n\tvector<pii> extra;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tif (!st.size()) {\n\t\t\textra.pb(mp(0, bk));\n\t\t\tans = max(ans, bk);\n\t\t\tcontinue;\n\t\t}\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (*it + bk <= md) {\n\t\t\tst.erase(it);\n\t\t\textra.pb(mp(1, *it + bk));\n\t\t\tans = max(ans, *it + bk);\n\t\t} else {\n\t\t\tans = max(ans, bk);\n\t\t\textra.pb(mp(0, bk));\n\t\t}\n\t}\n\tsort(extra.begin(), extra.end());\n\t/*\tif(u == 2){\n\t\t\tcout << \"WHAT \" << endl;\n\t\t\tfor (int i = 0; i < extra.size(); ++i){\n\t\t\t\tcout << extra[i].second << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << \"F\" << endl;\n\t\t}*/\n\twhile (nt-- && extra.size()) {\n\t\textra.pop_back();\n\t}\n\n\tif (extra.size() > 1)ans = 1e9;\n\tif (extra.size() && extra[0].first == 1)ans = 1e9;\n\tif (extra.size())return extra[0].second;\n\treturn 0;\n}\n\nbool check() {\n\tall = 0;\n\tans = 0;\n\tint res = dfs(1, -1);\n\tans = max(ans, res);\n\tall += (res > 0);\n\treturn ans <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\t/*md = 3;\n\tans = 0;\n\tcout << \"HH \" << dfs(1,-1) << endl;\n\tcout << ans << endl;\n\treturn 0;*/\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tbest = md;\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", all, best);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge && ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tif(children[len-1]>m) return false;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 0,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all(C) std::begin(C), std::end(C)\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nint32_t F(std::vector<int32_t>& a, int32_t K)\n{\n\tstd::sort(a.begin(),a.end());\n\tint lb = -1, ub = a.size();\n\twhile (ub - lb>1) {\n\t\tint mid = (ub + lb) / 2;\n\n\t\tbool f = true;\n\t\tint l = 0, r = a.size() - 1;\n\t\tfor (int i = 0; i < a.size() / 2;++i) {\n\t\t\tif (l == mid)l++;\n\t\t\tif (r == mid)r--;\n\t\t\tif (a[l] + a[r]>K)f = false;\n\t\t\tl++; r--;\n\t\t}\n\t\tif (f)ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tint32_t zero =1;\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0); ++zero;\n\t}\n\tL.insert(0);\n\n\tif (0)\n\t{\n\t\tstd::vector<int32_t> T;\n\t\tfor (auto& i : L) { T.push_back(i); }\n\t\tauto R = F(T, len_max);\n\t\tif (R == T.size()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn T[R];\n\t\t}\n\t}\n\tint32_t res;\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tif (*iter1 == 0) { --zero; if (zero == 0) { res = *iter2; } }\n\t\tif (*iter2 == 0) { --zero; if (zero == 0) { res = *iter2; } }\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn res;\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\tif(1){\n\n\t\tlen_max = 3;\n\t\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\t\tL.insert(2);\n\t\tL.insert(1);\n\t\tL.insert(1);\n\n\t\tif (L.size() % 2 == 0) {\n\t\t\tL.insert(0);\n\t\t}\n\n\t\twhile (L.size() >= 2) {\n\t\t\tauto iter2 = L.begin();\n\t\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\t\tif (iter1 == L.end()) {\n\t\t\t\tfunc_ok = false;\n\t\t\t\t//return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (iter1 == iter2) {\n\t\t\t\t++iter1;\n\t\t\t}\n\t\t\tL.erase(iter1);\n\t\t\tL.erase(iter2);\n\t\t}\n\t}\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 200005\n#define pb push_back\nusing namespace std;\nint i,j,k,l,s,n,m,last[N],to[M],Next[M],q[N],fa[N],si[N],ans,tot,x,y,dis[N],a[N];\nvector<int>GT;\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline void build() {\n\tint l=0,r=1; q[1]=1,dis[1]=1;\n\twhile (l<r) {\n\t\tint k=q[++l];\n\t\tfor (int i=last[k];i;i=Next[i]) if (fa[k]!=to[i]) fa[q[++r]=to[i]]=k,dis[to[i]]=dis[k]+1;\n\t}\n}\ninline bool work(int x,int y,int z) {\n\tint L=0,R=GT.size()-1;\n\tif (L==x) L++;\n\tif (R==x) R--;\n\twhile (L<=R) {\t\n\t\tif (GT[L]+GT[R]-2*y+1>z) return false;\n\t\tL++,R--;\n\t\tif (L==x) L++;\n\t\tif (R==x) R--;\n\t}\n\treturn true;\n}\ninline int Find(int x,int y) {\n\tint L=0,R=GT.size()-1,s=GT.size();\n\twhile (L<=R) {\n\t\tint mid=(L+R)>>1;\n\t\tif (work(mid,x,y)) s=mid,R=mid-1;\n\t\telse L=mid+1;\n\t}\n\treturn s;\n}\ninline bool check(int x) {\n\tfor (int i=n;i;i--) {\n\t\tGT.clear();\n\t\tfor (int j=last[q[i]];j;j=Next[j]) {\n\t\t\tif (to[j]==fa[q[i]]) continue;\n\t\t\tGT.pb(a[to[j]]);\n\t\t}\n\t\tsort(GT.begin(),GT.end());\n\t\tif (!GT.size()) {\n\t\t\ta[q[i]]=dis[q[i]];\n\t\t\tcontinue;\n\t\t}\n \t\tif (GT.size()&1) {\n\t\t\tif (GT.size()==1) {\n\t\t\t\ta[q[i]]=GT[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint gt=Find(dis[q[i]],x);\n\t\t\tif (gt>=GT.size()) return false;\n\t\t\ta[q[i]]=GT[gt];\n\t\t}\n\t\telse {\n\t\t\tGT.pb(dis[q[i]]);\n\t\t\tsort(GT.begin(),GT.end());\n\t\t\tint gt=Find(dis[q[i]],x);\n\t\t\tif (gt>=GT.size()) return false;\n\t\t\ta[q[i]]=GT[gt];\n\t\t}\n\t}\n\tif (a[1]>x) return false;\n\treturn true;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tbuild();\n\tfor (i=n;i;i--) {\n\t\tif (!si[q[i]]) si[q[i]]++;\n\t\tans+=si[q[i]]>>1;\n\t\tsi[q[i]]%=2;\n\t\tsi[fa[q[i]]]++;\n\t}\n\tans+=si[1];\n\tprintf(\"%d \",ans);\n\tint l=0,r=n;\n\tans=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid)) r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d\\n\",ans-1);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos > 0) data.erase(data.begin() + pos);\n\tint l = 0, r = data.size() - 1; \n\twhile (l < r) if (data[l++].fi + data[r--].fi > lim) return false; \n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nbool dfs(int u, int pa, int lim){ \n\tvector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if( v == pa) continue; \n\t\tif(! dfs(v, u, lim)) return false;\n\t\tif( ++ h[v] > lim) return false;\n\t\tdata.pb(ii(h[v], v));\n\t}\n\tif(data.size() == 0) return true;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return false;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) return false;\n\t\th[u] = h[res];\n\t\tif(u == 1 && h[u] > lim) return false; \n\t}\n\treturn true;\n}\nint findA(int u, int p) {\n    int rem = 0;\n    for (int v : G[u]) if (v != p) {\n        rem += findA(v, u);\n    }\n    A += rem / 2; rem %= 2;\n    if (rem == 1) return rem;\n    return (u == 1) ? 0 : 1;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tdem = findA(1, -1);\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tmemset(h, 0, sizeof h);\n\t\tint mid = (l + r)/2;\n\t\tif(dfs(1, 1, mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem + 1 << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=100005;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint num,n,l,r,mid,ans,rt,x,y,tag;\nint dp[N],head[N],d[N],f[N],g[N];\n\nvoid add(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num; d[x]++;\n}\n\nvoid dfs(int k,int pre,int w){\n\tint u,j,cnt=0,L,R,Mid,m; bool flag;\n\tif (!tag) return;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tdfs(u,k,w);\n\t}\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tf[++cnt]=dp[u];\n\t}\n\tif (!(cnt&1)) f[++cnt]=0;\n\tsort(f+1,f+1+cnt);\n\tif (cnt==1){\n\t\tdp[k]=f[1]+1;\n\t\tif (dp[k]-1>w) tag=0;\n\t\treturn;\n\t}\n\tL=1; R=cnt;\n\twhile (L<R){\n\t\tMid=L+(R-L)/2;\n\t\tm=0; flag=1;\n\t\tfor (j=1;j<=cnt;j++)\n\t\t\tif (j!=Mid) g[++m]=f[j];\n\t\tfor (j=1;j<=m/2;j++)\n\t\t\tif (g[j]+g[m-j+1]>w){\n\t\t\t\tflag=0; break;\n\t\t\t}\n\t\tif (flag) R=Mid;\n\t\telse L=Mid+1;\n\t\tif (Mid==cnt&&!flag) tag=0;\n\t}\n\tdp[k]=f[R]+1;\n\tif (dp[k]-1>w) tag=0;\n}\n\nbool check(int w){\n\ttag=1;\n\tdfs(rt,0,w);\n\tif (dp[rt]-1>w) tag=0;\n\treturn tag;\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (i=1;i<=n;i++)\n\t\tif (d[i]&1) ans++,rt=i;\n\tprintf(\"%d \",ans/2);\n\tl=1; r=n;\n\twhile (l<r){\n\t\tmid=l+(r-l)/2;\n\t\tif (check(mid)) r=mid;\n\t\telse l=mid+1; \n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define ele int\nusing namespace std;\n#define maxn 200010\nconst ele INF=1e9;\nstruct edge{\n\tele v;\n\tedge *nxt;\n}ep[maxn<<1],*ecnt;\nele n,r,d[maxn],f[maxn];\nedge *h[maxn];\ninline void addedge(ele u,ele v){\n\tedge *p=ecnt++;\n\tp->v=v; p->nxt=h[u];\n\th[u]=p;\n}\nvoid dfs(ele p,ele i,ele B){\n\tvector<ele> lst;\n\tfor (edge *j=h[i]; j; j=j->nxt)\n\t\tif (j->v!=p){\n\t\t\tdfs(i,j->v,B);\n\t\t\tlst.push_back(f[j->v]);\n\t\t}\n\tif (lst.size()%2==0) lst.push_back(0);\n\tsort(lst.begin(),lst.end());\n\tf[i]=INF;\n\tfor (int r=0; r<lst.size(); ++r){\n\t\tele u=0,v=lst.size()-1;\n\t\tbool flag=true;\n\t\twhile (u<v){\n\t\t\tif (u==r) ++u;\n\t\t\tif (v==r) --v;\n\t\t\tif (u<v && lst[u]+lst[v]>B){ flag=false; break; }\n\t\t\t++u; --v;\n\t\t}\n\t\tif (flag){ f[i]=lst[r]+1; break; }\n\t}\n}\ninline bool test(ele B){\n\tdfs(-1,r,B);\n\treturn f[r]<=B+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tecnt=ep; memset(h,0,sizeof(h)); memset(d,0,sizeof(d));\n\tfor (int i=0; i<n-1; ++i){\n\t\tele x,y;\n\t\tscanf(\"%d%d\",&x,&y); --x,--y;\n\t\taddedge(x,y); addedge(y,x);\n\t\t++d[x]; ++d[y];\n\t}\n\tele cnt=0;\n\tfor (int i=0; i<n; ++i){\n\t\tif (d[i]==1) r=i;\n\t\tif (d[i]&1) ++cnt;\n\t}\n\tele L=0,R=n-1;\n\twhile (R-L>1){\n\t\tele mid=(L+R)>>1;\n\t\tif (test(mid)) R=mid; else L=mid;\n\t}\n\tprintf(\"%d %d\\n\",cnt/2,R);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n//#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n        if (dp[u]+1>k){\n            p1=1;\n            return ;\n        }\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n   vector <int> y;\n    while(s.size()>1){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n\n                y.pb(val1);\n                continue;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()){\n        y.pb(*s.begin());\n    }\n    if (y.size()>2){\n        p1=1;\n        return ;\n    }\n    if (v==1 && y.size()>1) p1=1;\n    if (y.size()){\n        sort(y.begin(),y.end());\n        for (int i=1;i<y.size();i++) z++;\n        dp[v]=y[0];\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint dp[MAXN];\nint l,r,n,sum,ans;\nmultiset<int> s;\nvector<int> a[MAXN];\nbool dfs(int x,int fa,int maxl){\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            if(dfs(a[x][i],x,maxl)==0)\n                return 0;\n    for(int i=0;i<a[x].size();i++)\n        if(a[x][i]!=fa)\n            s.insert(dp[a[x][i]]+1);\n    bool flag=0;\n    if(a[x].size()%2==0)\n        flag=1;\n    while(s.size()>1){\n        int t=*s.rbegin();\n        s.erase(s.find(t));\n        multiset<int>::iterator it=s.lower_bound(maxl-t+1);\n        if(it==s.begin()){\n            if(flag==1)\n                return 0;\n            flag=1;\n        }\n        else{\n            it--;\n            s.erase(it);\n        }\n    }\n    if(s.size()==1){\n        dp[x]=*s.begin();\n        if(dp[x]>maxl)\n            return 0;\n        s.erase(dp[x]);\n    }\n    else\n        dp[x]=0;\n    return 1;\n}\nbool check(int maxl){\n    memset(dp,0,sizeof dp);\n    s.clear();\n    if(dfs(1,0,maxl))\n        return 1;\n    return 0;\n}\nint u,v;\nint main(){\n    SF(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        SF(\"%d%d\",&u,&v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n        if(a[i].size()%2==1)\n            sum++;\n    sum/=2;\n    PF(\"%d \",sum);\n    l=1,r=n;\n    //PF(\"{%d}\",check(2));\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)){\n            ans=mid;\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root,int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to,root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size(); cnt += len / 2;\n\tif (len % 2==0) {\n\t\trep(i, len / 2) {\n\t\t\tif (v[i] + v[len - i - 1] > c)f = false;\n\t\t}\n\t\treturn 1;\n\t}\n\telse {\n\t\tmultiset<int> mt;\n\t\trep(i, len)mt.insert(v[i]);\n\t\trep(i, len / 2) {\n\t\t\tauto itr = mt.end(); itr--;\n\t\t\tint z = *itr; mt.erase(mt.find(z));\n\t\t\tint r = c - z;\n\t\t\tif (mt.count(r)) {\n\t\t\t\tmt.erase(mt.find(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt.insert(r);\n\t\t\t\tauto itr2 = mt.find(r);\n\t\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\titr2--; mt.erase(r);\n\t\t\t\tint zz = *itr2;\n\t\t\t\tif (zz + z > c) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\tmt.erase(itr2);\n\t\t\t}\n\t\t}\n\t\tint z = *mt.begin();\n\t\tif (z == c) {\n\t\t\tcnt++; z = 0;\n\t\t}\n\t\treturn z + 1;\n\t}\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa<<\" \"<<ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF - 2 : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 1;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\t//if (edge[v].size() == 1) {\n\t//\treturn 0;\n\t//}\n\t//if (edge[v].size() == 2) {\n\t//\tfor (auto& e : edge[v]) {\n\t//\t\tif (e != parent) { return 1 + func(e, v); }\n\t//\t}\n\t//}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,d[SZ],up[SZ]; Edg\nint pr[SZ],seg[SZ];\nint qmin(int l,int r)\n{\n\tint ans=1e9; ++l, ++r;\n\tfor(l+=M-1,r+=M+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) ans=min(ans,seg[l^1]);\n\t\tif(r&1) ans=min(ans,seg[r^1]);\n\t}\n\treturn ans;\n}\nbool mat(int l1,int r1,int r2)\n{\n\tif(l1>r1) return 1;\n\t//for i in [l1,r1]\n\t//pr[i]>=r2+l1-i\n\treturn qmin(l1,r1)>=l1+r2;\n}\nbool chk(int x,int l,int f=0)\n{\n\tvector<int> ch;\n\tfor esb(x,e,b) if(b!=f)\n\t{\n\t\tbool s=chk(b,l,x);\n\t\tif(!s||up[b]>l) return 0;\n\t\tch.pb(up[b]);\n\t}\n\tsort(ch.begin(),ch.end());\n\tint s=ch.size();\n\tif(s%2==0) //easy\n\t{\n\t\tbool bad=0;\n\t\tfor(int i=0;i<s/2;++i)\n\t\t\tif(ch[i]+ch[s-1-i]>l) bad=1;\n\t\tif(!bad) {up[x]=1; return 1;} --s;\n\t}\n\tfor(int i=0,j=s-1;i<s;++i)\n\t{\n\t\twhile(j>=0&&ch[i]+ch[j]>l) --j;\n\t\tpr[i]=j;\n\t}\n\tM=1; while(M<=s+3) M<<=1;\n\tfor(int i=0;i<s;++i) seg[i+M+1]=pr[i]+i;\n\tfor(int i=M-1;i>=1;--i)\n\t\tseg[i]=min(seg[i+i],seg[i+i+1]);\n\tup[x]=-1;\n\tfor(int i=0;i<s;++i)\n\t{\n\t\tbool c1=0;\n\t\tif(i<s/2)\n\t\t\tc1=mat(0,i-1,s-1)&&mat(i+1,s/2,s-i-1);\n\t\telse\n\t\t\tc1=mat(0,s-i-2,s-1)&&mat(s-i-1,s/2-1,i-1);\n\t\tif(!c1) continue;\n\t\tup[x]=ch[i]+1; break;\n\t}\n\tif(up[x]==-1) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,a,b;i<n;++i)\n\t\tscanf(\"%d%d\",&a,&b),adde(a,b),++d[a],++d[b];\n\tint ans=n,ro=1;\n\tfor(int i=n;i>=1;--i)\n\t\tif(d[i]&1) ro=i;\n\tfor(int i=1;i<=n;++i)\n\t\tans-=(d[i]-(i!=ro)+1)/2;\n\tprintf(\"%d \",ans);\n\tint l=0,r=n;\n\twhile(l<r)\n\t{\n\t\tint m=(l+r)>>1;\n\t\tbool s=chk(ro,m);\n\t\tif(s&&up[ro]<=m+1) r=m; else l=m+1;\n\t}\n\tprintf(\"%d\\n\",l);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  V<> deg(n);\n  for (int _ = 0; _ < n - 1; ++_) {\n    int u, v; cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    ++deg[u], ++deg[v];\n  }\n  cout << count_if(begin(deg), end(deg), [](int x) { return x & 1; }) / 2 << ' ';\n  auto chk = [&](int x) -> bool {\n    V<> dp(n, 1e9);\n    auto dfs = [&](const auto& dfs, int v, int p) -> void {\n      V<> a;\n      for (int w : g[v]) if (w != p) {\n        dfs(dfs, w, v);\n        a.push_back(dp[w] + 1);\n      }\n      if (~a.size() & 1) a.push_back(0);\n      sort(begin(a), end(a));\n      int m = a.size(), ng = -1, ok = m;\n      while (ok - ng > 1) {\n        int mid = ng + ok >> 1;\n        V<> b;\n        for (int i = 0; i < m; ++i) if (i != mid) {\n          b.push_back(a[i]);\n        }\n        int mx = 0;\n        for (int i = 0; i < m / 2; ++i) {\n          mx = max(mx, b[i] + b[b.size() + ~i]);\n        }\n        (mx <= x ? ok : ng) = mid;\n      }\n      if (ok == m) return;\n      dp[v] = a[ok];\n    };\n    dfs(dfs, 0, -1);\n    return dp[0] <= x;\n  };\n  int ng = 0, ok = n - 1;\n  while (ok - ng > 1) {\n    int mid = ng + ok >> 1;\n    (chk(mid) ? ok : ng) = mid;\n  }\n  cout << ok << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nconst int rt=1;int dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN];\nbool dfs(int u,int la)\n{\n\tstd::vector<int> fv;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfv.push_back(f[v]);\n\t}\n\tint k=fv.size();\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1)) fv.push_back(0),k++;\n\tstd::sort(fv.begin(),fv.end());\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tfor(int p1=1,p2=k;p1<p2;p1++,p2--)\n\t\t{\n\t\t\tif(p1==mid) p1++;if(p2==mid) p2--;\n\t\t\tif(fv[p1-1]+fv[p2-1]>B) {l=mid+1;continue;}\n\t\t}\n\t\tr=mid-1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fv[l-1]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(rt,0)) return false;\n\tif(f[rt]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w, h; };\nconst int INF = INT_MAX / 10;\nconst int MOD = 1e9 + 7;\n\nbool pos(vector<int> a, int ma) {\n\tint N = a.size();\n\tbool ok = true;\n\trep(i, N / 2) if (a[i] + a[N - 1 - i] > ma) ok = false;\n\treturn ok;\n}\n\nint dfs(int u, int p, vector<vector<int>>& G, int ma) {\n\tvector<int> a;\n\tfor (int v: G[u]) if (v != p) a.pb(dfs(v, u, G, ma));\n\tsort(a.begin(), a.end());\n\tint N = a.size();\n\tif (N % 2) {\n\t\tint lb = -1, ub = N;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tvector<int> b = a;\n\t\t\tb.erase(b.begin() + mid);\n\t\t\tif (pos(b, ma)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\treturn ub == N ? INF : a[ub] + 1;\n\t}\n\tif (pos(a, ma)) return 1;\n\tint i;\n\tfor (i = N - 1; i >= 0; i--) if (a[i] <= ma) break;\n\tif (i == -1) return INF;\n\ta.erase(a.begin() + i);\n\tN = a.size();\n\tif (N % 2) {\n\t\tint lb = -1, ub = N;\n\t\twhile (ub - lb > 1) {\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tvector<int> b = a;\n\t\t\tb.erase(b.begin() + mid);\n\t\t\tif (pos(b, ma)) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\treturn ub == N ? INF : a[ub] + 1;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>> G(N);\n\trep(i, N - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tint A = 1;\n\trep(u, N) if (G[u].size() >= 3) A += (G[u].size() - 1) / 2;\n\t// cout << dfs(0, -1, G, 2) << endl;\n\tint lb = -1, ub = N;\n\tint r;\n\trep(u, N) if (G[u].size() == 1) r = u;\n\twhile (ub - lb > 1) {\n\t\tint mid = (lb + ub) / 2;\n\t\tif (dfs(r, -1, G, mid) - 1 <= mid) ub = mid;\n\t\telse lb = mid;\n\t}\n\tint B = ub;\n\tcout << A << ' ' << B << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst int MN = 100100;\nvi g[MN];\nint dp[MN];\nint rt,b;\nint ds(int u, int p) {\n\tif(dp[u] != -1) return dp[u];\n\tvi w;\n\tfor(int i=0;i<g[u].size();i++) {\n\t\tint v = g[u][i];\n\t\tif(v == p) continue;\n\t\tw.push_back(ds(v,u));\n\t}\n\tif(!(w.size()&1)) {w.push_back(0);}\n\tsort(w.begin(),w.end());\n\tint s = 0,e = w.size()-1;\n\tint ls = -1;\n\twhile(s <= e) {\n\t\tint st = 0,ed = w.size()-1;\n\t\tint m = (s+e)/2;\n\t\tbool pp = true;\n\t\twhile(1) {\n\t\t\tif(st == m) {st++;}\n\t\t\tif(ed == m) {ed--;}\n\t\t\tif(st > ed) break;\n\t\t\tif(w[st]+w[ed] > b) {\n\t\t\t\tpp = false;break;\n\t\t\t}\n\t\t\tst++;ed--;\n\t\t}\n\t\tif(pp) {\n\t\t\tls = m;e = m-1;\n\t\t} else {\n\t\t\ts = m+1;\n\t\t}\n\t}\n\tif(ls < 0) {dp[u] = MN*9;} else {\n\t\tdp[u] = w[ls]+1;\n\t}\n\treturn dp[u];\n}\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n-1;i++) {\n\t\tint a,b;\n\t\tcin >> a >> b;a--;b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint no = 0;\n\tfor(int i=0;i<n;i++) {\n\t\tif(g[i].size() == 1) {rt = i;}\n\t\tif(g[i].size()&1) {no++;}\n\t}\n\tint s = 1,e = n;\n\tint ls = n;\n\twhile(s <= e) {\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint m = (s+e)/2;\n\t\tb = m;\n\t\tds(rt,-1);\n\t\tbool po = true;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(dp[i] > b + (i==rt?1:0)) {\n\t\t\t\tpo = false;break;\n\t\t\t}\n\t\t}\n\t\tif(po) {\n\t\t\tls = m;e = m-1;\n\t\t} else {\n\t\t\ts = m+1;\n\t\t}\n\t}\n\tcout << no/2 << \" \" << ls << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 1500000;\nconst int K = 50 ;\nvector < int > g[N];\nint cnt;\npair < int, int > dfs1(int v, int p = -1){\n    int c = 0;\n    int res = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto x = dfs1(u, v);\n        c += x.F;\n        res += x.S;\n    }\n    res -= c / 2;\n    c %= 2;\n    if (c == 0 && p != -1){\n        c++;\n        res++;\n    }\n    return {c, res};\n}\nint dfs2(int v, int x, int p = -1){\n    multiset < int > t;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto y = dfs2(u, x, v);\n        t.insert(y);\n    }\n    vector < int > f1;\n    while(t.size() > 1){\n        auto y = t.end();\n        y--;\n        auto q = t.begin();\n        int q1 = *q;\n        q++;\n        int q2 = *q;\n        if (q1 + q2 > x) break;\n        if (*y + *t.begin() > x){\n            f1.pb(*y);\n            t.erase(t.find(*y));\n            continue;\n        }\n        auto z = t.upper_bound(x - (*y));\n        while(z == t.end() || z == y || x - (*z) < (*y)) z--;\n        if (z == y) z--;\n        int v1 = *z;\n        int v2 = *y;\n        t.erase(t.find(v1));\n        t.erase(t.find(v2));\n        cnt--;\n    }\n    for (auto i: f1) t.insert(i);\n    if (t.size() == 0){;\n        cnt += (p != -1);\n        return 1;\n    }\n    if (p == -1) return 0;\n    if (*t.begin() + 1 > x){\n        cnt++;\n        return 1;\n    }\n    return (*t.begin()) + 1;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    int ans1 = dfs1(1).S;\n    int l = 0;\n    int r = n + 1;\n    while(r - l > 1){\n        int mid = (r + l) / 2;\n        cnt = 0;\n        dfs2(1, mid);\n        if (cnt <= ans1){\n            r = mid;\n        } else{\n            l = mid;\n        }\n    }\n    cout << ans1 << \" \" << r;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5;\n\nvi g[MAXN];\n\nint dp[MAXN];\nint prv[MAXN];\nint vv[MAXN], top_vv;\nint sorted[MAXN], top_sorted;\n\nvoid dfs(int s) {\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]) {\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\tsorted[top_sorted++] = s;\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\tint cnt = 0;\n\tREPN(i, 1, n) {\n\t\tcnt += SZ(g[i]) % 2;\n\t}\n\tcnt /= 2;\n\t\n\tdfs(1);\n\t\n\tint l = 0, r = n - 1;\n\tfor(; l + 1 < r; ) {\n\t\tint lim = (l + r) >> 1;\n\t\tbool good = true;\n\t\tREP(i, 0, n) {\n\t\t\tint s = sorted[i];\n\t\t\tdp[s] = 0;\n\t\t\ttop_vv = 0;\n\t\t\tREP(j, 0, SZ(g[s])) {\n\t\t\t\tint to = g[s][j];\n\t\t\t\tif (to != prv[s]) {\n\t\t\t\t\tvv[top_vv++] = dp[to] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (top_vv % 2 == 0) {\n\t\t\t\tvv[top_vv++] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tsort(vv, vv + top_vv);\n\t\t\t\n\t\t\tif (vv[top_vv - 1] > lim) {\n\t\t\t\tgood = false;\n\t\t\t} else {\n\t\t\t\tfor(int ind_r = top_vv / 2, ind_l = top_vv / 2 - 1; ind_l >= 0; ind_l--, ind_r++) {\n\t\t\t\t\tif (vv[ind_r] + vv[ind_l] > lim) {\n\t\t\t\t\t\tgood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (good) {\n\t\t\t\tint ind = top_vv - 1;\n\t\t\t\tfor(ind--; ind >= 0; ind--) {\n\t\t\t\t\tif (ind >= top_vv / 2) {\n\t\t\t\t\t\tif (vv[ind + 1] + vv[top_vv - 2 - ind] > lim) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (vv[ind + 1] + vv[top_vv - 1 - ind] > lim) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t\tdp[s] = vv[ind];\n\t\t\t}\n\t\t\t\n\t\t\tif (!good) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (good) {\n\t\t\tr = lim;\n\t\t} else {\n\t\t\tl = lim;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\", cnt, r);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n;\nvector<int> e[100010];\n\nint par[100010];\n\nint X;\n\nint dfs(int a){\n\tvector<int> v;\n\tfor(int b:e[a]){\n\t\tif(par[a] == b) continue;\n\t\tpar[b]=a;\n\t\tv.pb(dfs(b)+1);\n\t}\n\tsort(all(v));\n\tint cc = v.size();\n\tif(a == 1){\n\t\tif(cc % 2){\n\t\t\tif(v[cc-1] > X) throw 1;\n\t\t\tfor(int l=0,r=cc-2; l<r; ++l,--r) if(v[l]+v[r]>X) throw 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfor(int l=0,r=cc-1; l<r; ++l,--r) if(v[l]+v[r]>X) throw 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if(e[a].size() % 2){\n\t\tbool just = true;\n\t\tfor(int l=0, r=cc-1; l<r; ++l, --r){\n\t\t\tif(v[l] + v[r] > X){\n\t\t\t\tjust = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(just){\n\t\t\treturn 0;\n\t\t}\n\t\tif(v[cc-1] > X) throw 1;\n\t\tfor(int l=1, r=cc-2; l<r; ++l, --r){\n\t\t\tif(v[l] + v[r] > X){\n\t\t\t\tjust = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn v[0];\n\t} else {\n\t\tfor(int l=0, r=cc-2; l<r; ++l, --r) if(v[l] + v[r] > X) throw 1;\n\t\tint l=-1, r=cc-1;\n\t\twhile(l+1 < r){\n\t\t\tint mid = (l+r)/2;\n\t\t\tbool fok = 1;\n\t\t\tfor(int pl=0, pr=cc-1; pl<pr;){\n\t\t\t\tif(pl == mid){ ++pl; continue; }\n\t\t\t\tif(pr == mid){ --pr; continue; }\n\t\t\t\tif(v[pl] + v[pr] > X){\n\t\t\t\t\tfok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++pl; --pr;\n\t\t\t}\n\t\t\tif(fok) r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\treturn v[r];\n\t}\n}\n\nbool check(int x){\n\tX = x;\n\tfill(par+1, par+n+1, 0);\n\ttry {\n\t\tdfs(1);\n\t\treturn 1;\n\t} catch(int t){ return 0; }\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<n; ++i){\n\t\tint a, b; read(a, b);\n\t\te[a].pb(b); e[b].pb(a);\n\t}\n\tint oc = count_if(e+1, e+n+1, [](auto& v){ return v.size()%2; });\n\tprintf(\"%d \", oc/2);\n\t\n\tint L = 0, R = n-1;\n\twhile(L+1 < R){\n\t\tint mid = (L+R)/2;\n\t\tif(check(mid)) R = mid; else L = mid;\n\t}\n\t\n\tprintf(\"%d\\n\", R);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 100005\n\nint n,m,tot,pps,pp;\nint now[maxn],pre[maxn*2],son[maxn*2],deg[maxn],f[maxn];\n\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\ninline void print(int x){\n\tif (x<0){putchar('-'); x=-x;}\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\n\nvoid add(int a,int b){son[++tot]=b,pre[tot]=now[a],now[a]=tot;}\nvoid link(int a,int b){add(a,b),add(b,a),++deg[a],++deg[b];}\n\nint top;\nint stack[maxn];\nbool can;\n\nbool check1(int x){\n\tfor (int i=1,j=top;i<j;i++,j--){\n\t\tif (i==x) ++i; if (j==x) --j; if (i>=j) break;\n\t\tif (stack[i]+stack[j]>pps) return 0;\n\t}\n\treturn 1;\n}\n\nvoid tree_dp(int x,int fa){\n\tif (!can) return;\n\tfor (int p=now[x];p;p=pre[p])\n\t\tif (son[p]!=fa) tree_dp(son[p],x);\n\ttop=0;\n\tfor (int p=now[x];p;p=pre[p])\n\t\tif (son[p]!=fa) stack[++top]=f[son[p]];\n\tif (~top&1) stack[++top]=0;\n\tsort(stack+1,stack+top+1);\n\tint l=1,r=top,res=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (check1(mid)) res=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif (res==-1){can=0; return;}\n\tf[x]=stack[res]+1;\n}\n\nbool check(int x){\n\tmemset(f,0,sizeof(f));\n\tpps=x,can=1; tree_dp(pp,0);\n\t//\tfor (int i=1;i<=n;i++) printf(\"%d %d\\n\",i,f[i]);\n\treturn can&&f[pp]<=x+1;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),link(x,y);\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) ans+=deg[i]&1; cout<<(ans>>1)<<' ';\n\tfor (int i=1;i<=n;i++) if (deg[i]==1){pp=i; break;}\n\tint l=1,r=n,res=n+1;\n\twhile (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid)) r=mid-1,res=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\tint res=1,flag=sak[u].size()&1,vl;\n\twhile((int)sak[u].size()>1){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tif(!res){\n\t\t\t\tbo=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres--;\n\t\t\tsak[u].erase(itt);\n\t\t\tvl=v;\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif(flag&&sak[u].empty()) return vl;\n\tif(sak[u].empty()) return 0;\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  rep(i,0,n){\n    if(g[i].size()&1)res++;\n  }\n  ll ok=n,ng=0;\n  while(ok-ng>=2){\n    ll mid=(ok+ng)/2;\n    bool sw=true;\n    auto dfs=[&](auto &&f,ll k,ll par)->ll{\n      vector<ll>v;\n      if(g[k].size()&1)v.PB(0);\n      for(auto to:g[k]){\n        if(to==par)continue;\n        ll p=f(f,to,k);\n        if(p!=-1)v.PB(p);\n      }\n      sort(ALL(v));\n      ll sz=v.size();\n      //cout<<k<<endl;\n      //debug(v,sz);\n      rep(i,0,sz/2){\n        //cout<<i spa sz-i-1-(sz&1) spa v[i] spa v[sz-i-1-(sz&1)]<<endl;\n        if(v[i]+v[sz-i-1-(sz&1)]>mid)sw=false;\n      }\n      if(sz%2==0){\n        return -1;\n      }\n      else{\n        ll ok=sz-1,ng=-1;\n        while(ok-ng>=2){\n          ll mid2=(ok+ng)/2;\n          vector<ll>tmp;\n          rep(i,0,sz)if(i!=mid2)tmp.PB(v[i]);\n          bool sw2=true;\n          rep(i,0,sz/2){\n            //cout<<i spa sz-i-2 spa tmp[i] spa tmp[sz-i-2]<<endl;\n            if(tmp[i]+tmp[sz-i-2]>mid)sw2=false;\n          }\n          if(sw2)ok=mid2;\n          else ng=mid2;\n        }\n        return v[ok]+1;\n      }\n    };\n    dfs(dfs,0,-1);\n    if(sw)ok=mid;\n    else ng=mid;\n  }\n  cout<<res/2 spa ok<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nvector<int> vec;\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tvec.clear();\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tvec.push_back(res[G[v][i]].second);\n\t\t}\n\t}\n\tif(vec.size()==0)return res[v]=P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=(int)vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<' ';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\n#ifdef ONLINE_JUDGE\nconst int N = 1e6+50;\n#else\nconst int N = 1+10;\n#endif\n\n\nint n;\nvector<int> g[N], h[N];\n\nint dfs(int x, int f, int d) {\n\tfor (int y:g[x]) if (y!=f) h[x].pb(dfs(y,x,d));\t\n\tif (h[x].empty()) return 1;\n\tif (h[x].size()%2==0) h[x].pb(0);\n\tsort(h[x].begin(),h[x].end());\n\tint sz=h[x].size(),l=0,r=sz-1,ans=-1;\n\twhile (l<=r) {\n\t\tint ql=0,qr=sz-1,ok=1;\n\t\twhile (1) {\n\t\t\tif (ql==mid) ++ql;\n\t\t\tif (qr==mid) --qr;\n\t\t\tif (ql>qr) break;\n\t\t\tif (h[x][ql]+h[x][qr]>d) ok=0;\n\t\t\t++ql,--qr;\n\t\t}\n\t\tif (ok) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans<0?INF:h[x][ans]+1; \n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,2,n) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v),g[v].pb(u);\n\t}\n\tint cnt = 0;\n\tREP(i,1,n) cnt += g[i].size()&1;\n\tcnt /= 2;\n\tint l = 0, r = n-1, ans;\n\twhile (l<=r) {\n\t\tif (dfs(1,0,mid)<=mid+1) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\", cnt, ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,d[SZ],up[SZ]; Edg\nint pr[SZ],seg[SZ];\nint qmin(int l,int r)\n{\n\tint ans=1e9; ++l, ++r;\n\tfor(l+=M-1,r+=M+1;l^r^1;l>>=1,r>>=1)\n\t{\n\t\tif(~l&1) ans=min(ans,seg[l^1]);\n\t\tif(r&1) ans=min(ans,seg[r^1]);\n\t}\n\treturn ans;\n}\nbool mat(int l1,int r1,int r2)\n{\n\tif(l1>r1) return 1;\n\t//for i in [l1,r1]\n\t//pr[i]>=r2+l1-i\n\treturn qmin(l1,r1)>=l1+r2;\n}\nbool chk(int x,int l,int f=0)\n{\n\tvector<int> ch;\n\tfor esb(x,e,b) if(b!=f)\n\t{\n\t\tbool s=chk(b,l,x);\n\t\tif(!s||up[b]>l) return 0;\n\t\tch.pb(up[b]);\n\t}\n\tsort(ch.begin(),ch.end());\n\tint s=ch.size();\n\tif(s%2==0) //easy\n\t{\n\t\tbool bad=0;\n\t\tfor(int i=0;i<s/2;++i)\n\t\t\tif(ch[i]+ch[s-1-i]>l) bad=1;\n\t\tif(!bad) {up[x]=1; return 1;} --s;\n\t}\n\tfor(int i=0,j=s-1;i<s;++i)\n\t{\n\t\twhile(j>=0&&ch[i]+ch[j]>l) --j;\n\t\tpr[i]=j;\n\t}\n\tM=1; while(M<=s+3) M<<=1;\n\tfor(int i=0;i<s;++i) seg[i+M+1]=pr[i]+i;\n\tfor(int i=M-1;i>=1;--i)\n\t\tseg[i]=min(seg[i+i],seg[i+i+1]);\n\tup[x]=-1;\n\tfor(int i=0;i<s;++i)\n\t{\n\t\tbool c1=0;\n\t\tif(i<s/2)\n\t\t\tc1=mat(0,i-1,s-1)&&mat(i+1,s/2,s-i-1);\n\t\telse\n\t\t\tc1=mat(0,s-i-2,s-1)&&mat(s-i-1,s/2-1,i-1);\n\t\tif(!c1) continue;\n\t\tup[x]=ch[i]+1; break;\n\t}\n\tif(up[x]==-1) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,a,b;i<n;++i)\n\t\tscanf(\"%d%d\",&a,&b),adde(a,b),++d[a],++d[b];\n\tint ans=n,ro=1;\n\tfor(int i=n;i>=1;--i)\n\t\tif(d[i]&1) ro=i;\n\tfor(int i=1;i<=n;++i)\n\t\tans-=(d[i]-(i!=ro)+1)/2;\n\tprintf(\"%d \",ans);\n\tint l=0,r=n;\n\twhile(l<r)\n\t{\n\t\tint m=(l+r)>>1;\n\t\tbool s=chk(ro,m);\n\t\tif(s&&up[ro]<=m+1) r=m; else l=m+1;\n\t}\n\tprintf(\"%d\\n\",l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define ele int\nusing namespace std;\n#define maxn 200010\nconst ele INF=1e9;\nstruct edge{\n\tele v;\n\tedge *nxt;\n}ep[maxn<<1],*ecnt;\nele n,d[maxn],f[maxn];\nedge *h[maxn];\ninline void addedge(ele u,ele v){\n\tedge *p=ecnt++;\n\tp->v=v; p->nxt=h[u];\n\th[u]=p;\n}\nvoid dfs(ele p,ele i,ele B){\n\tvector<ele> lst;\n\tfor (edge *j=h[i]; j; j=j->nxt)\n\t\tif (j->v!=p){\n\t\t\tdfs(i,j->v,B);\n\t\t\tlst.push_back(f[j->v]);\n\t\t}\n\tif (lst.size()%2==0) lst.push_back(0);\n\tsort(lst.begin(),lst.end());\n\tf[i]=INF;\n\tfor (int r=0; r<lst.size(); ++r){\n\t\tele u=0,v=lst.size()-1;\n\t\tbool flag=true;\n\t\twhile (u<v){\n\t\t\tif (u==r) ++u;\n\t\t\tif (v==r) --v;\n\t\t\tif (u<v && lst[u]+lst[v]>B){ flag=false; break; }\n\t\t\t++u; --v;\n\t\t}\n\t\tif (flag){ f[i]=lst[r]+1; break; }\n\t}\n}\ninline bool test(ele B){\n\tdfs(-1,0,B);\n\treturn f[0]<=B+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tecnt=ep; memset(h,0,sizeof(h)); memset(d,0,sizeof(d));\n\tfor (int i=0; i<n-1; ++i){\n\t\tele x,y;\n\t\tscanf(\"%d%d\",&x,&y); --x,--y;\n\t\taddedge(x,y); addedge(y,x);\n\t\t++d[x]; ++d[y];\n\t}\n\tele cnt=0;\n\tfor (int i=0; i<n; ++i)\n\t\tif (d[i]&1) ++cnt;\n\tele L=0,R=n-1;\n\twhile (R-L>1){\n\t\tele mid=(L+R)>>1;\n\t\tif (test(mid)) R=mid; else L=mid;\n\t}\n\tprintf(\"%d %d\\n\",cnt/2,R);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<int> > ed;\nvector<int> dp;\nvector<int> v;\nvector<int> t;\nint INF = (int)1 << 30;\nint N;\nint m;\nbool f;\nint dfs(int a) {\n\tif (!f) {\n\t\treturn -2;\n\t}\n\tv[a] = 1;\n\tvector<int> b;\n\tint k;\n\tfor (int i = 0; i < ed[a].size(); i++) {\n\n\t\tif (v[ed[a][i]] == 0) {\n\t\t\tk = dfs(ed[a][i]);\n\t\t\tif (k != -1) {\n\t\t\t\tb.push_back(k);\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\treturn -2;\n\t\t}\n\t}\n\n\tif ((int)ed[a].size() % 2 == 1) {\n\t\tb.push_back(0);\n\t}\n\tsort(b.begin(), b.end());\n\t\n\tif (b.size() % 2 == 0) {\n\t\tfor (int i = 0; i < (int)b.size()/2; i++) {\n\t\t\tif (b[i] + b[(int)b.size() - 1 - i] > m) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\telse {\n\t\tfor (int i = 0; i < (int)(b.size() - 1) / 2; i++) {\n\t\t\tif (b[i] + b[(int)b.size() - 2 - i] > m) {\n\t\t\t\tf = false;\n\t\t\t}\n\t\t}\n\t\tint res;\n\t\tif (f) {\n\t\t\tres = b.back();\n\t\t\tint l = 0;\n\t\t\tfor (int i = (int)b.size() - 1; i >= 1; i--) {\n\t\t\t\tif (l < i) {\n\t\t\t\t\tif (b[i] + b[(int)b.size() - 1 - i] > m) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] + b[(int)b.size() - i] > m) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t\tres = b[i - 1];\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\treturn res + 1;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\n\tint res = 0;\n\tint a, b;\n\ted.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\ted[a].push_back(b);\n\t\ted[b].push_back(a);\n\t}\n\tint u = N;\n\tint d = 0;\n\twhile (u - d > 1) {\n\t\tdp.clear();\n\t\tdp.resize(N, INF);\n\t\tv.clear();\n\t\tv.resize(N, 0);\n\t\tm = (u + d) / 2;\n\t\tf = true;\n\t\tdfs(0);\n\t\tif (f) {\n\t\t\tu = m;\n\t\t}\n\t\telse {\n\t\t\td = m;\n\t\t}\n\t}\n\tres = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (ed[i].size() % 2 == 1) {\n\t\t\tres++;\n\t\t}\n\t}\n\tcout << (res/2) <<\" \" <<u << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\tif(u.size() && u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size() - 1; i < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j == mid) j--;\n\t\t\t\tif(i < j && u[i] + u[j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0, r = -1;\n\trep(i, n){\n\t\tif(e[i].size() % 2) A++;\n\t\tif(e[i].size() == 1) r = i;\n\t}\n\t//assert(A % 2 == 0 && r >= 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(r, r, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tassert(A != 3 || hi != 2);\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X;\nvector<vector<int> > adj;\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n    }\n\n    if(st.size() % 2) {\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - *it1);\n            if(it2 == st.begin()) return -1;\n            it2--;\n            st.erase(it2);\n        }\n        return *st.begin();\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - *it1);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int a = 0;\n    for(int i = 0; i < N; i++) {\n        a += (adj[i].size() + 1) / 2 - 1;\n    }\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", 1 + a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nii mini(ii a, ii b)\n{\n\tif(a.fi<b.fi||(a.fi==b.fi&&a.se<b.se)) return a;\n\telse return b;\n}\n\nii dp[111111];\nvi adj[111111];\nint MID;\n\nvoid dfs(int u, int p)\n{\n\tint cnt=0;\n\tdeque<int> vec;\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i]; if(v==p) continue;\n\t\tdfs(v,u);\n\t\tvec.pb(dp[v].se);\n\t\tcnt+=dp[v].fi;\n\t}\n\tsort(vec.begin(),vec.end());\n\t/*\n\tint maxpath = 0;\n\twhile(!vec.empty())\n\t{\n\t\tif(vec.size()==1)\n\t\t{\n\t\t\tif(vec[0]+1<=mid)\n\t\t\t{\n\t\t\t\tmaxpath = max(maxpath, vec[0]+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tmaxpath = max(maxpath, 1);\n\t\t\t}\n\t\t\tvec.pop_back();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint las = vec.back();\n\t\t\tif(vec.front()+2+las<=mid)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_front(0);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tint lo = 0; int hi = int(vec.size()); int ans = 0; //[ans, int(vec.size()) - 1] will be killed\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint maxi = -int(1e9);\n\t\tfor(int i=0;i<mid;i++)\n\t\t{\n\t\t\tif(i<mid-1-i) maxi=max(maxi,vec[i]+vec[mid-1-i]+2);\n\t\t\tmaxi=max(maxi,vec[i]+1);\n\t\t}\n\t\tif(maxi<=MID)\n\t\t{\n\t\t\tans=mid;\n\t\t\tlo=mid+1;\n\t\t}\n\t\telse hi=mid-1;\n\t}\n\tint maxpath = 0;\n\tint del=0;\n\tfor(int i=ans;i<vec.size();i++) \n\t{\n\t\tif(vec[i]+1<=MID)\n\t\t{\n\t\t\tdel++;\n\t\t}\n\t\tvec[i]=0;\n\t}\n\tcnt+=int(vec.size()) - ans;\n\tfor(int j=0;j<del;j++) vec.pop_back();\n\tsort(vec.begin(),vec.end());\n\t//cerr<<vec.size()<<'\\n';\n\tcnt+=int(vec.size())/2;\n\tif(vec.size()%2==1)\n\t{\n\t\tlo = 0; hi = int(vec.size())-1; ans=0;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tint mid=(lo+hi)>>1;\n\t\t\tint l = 0; int r = int(vec.size())-1;\n\t\t\tint res = -int(1e9);\n\t\t\twhile(l==mid) l++;\n\t\t\twhile(r==mid) r--;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tres=max(res,vec[l]+vec[r]+2);\n\t\t\t\tl++; r--;\n\t\t\t\twhile(l==mid) l++;\n\t\t\t\twhile(r==mid) r--;\n\t\t\t}\n\t\t\tif(res==-int(1e9)) res=0;\n\t\t\tif(res<=MID)\n\t\t\t{\n\t\t\t\tans=mid; hi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tmaxpath = vec[ans]+1;\n\t\tif(maxpath>MID)\n\t\t{\n\t\t\tmaxpath=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t//cerr<<MID<<' '<<u<<' '<<cnt<<' '<<maxpath<<'\\n';\n\tdp[u] = mp(cnt,maxpath);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tMID=n;\n\tdfs(0,-1);\n\tint res=dp[0].fi;\n\tif(dp[0].se>0) res++;\n\tint lo=1; int hi=n; int ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tMID=(lo+hi)>>1;\n\t\tdfs(0,-1);\n\t\tint res2=dp[0].fi;\n\t\tif(dp[0].se>0) res2++;\n\t\tif(res2==res)\n\t\t{\n\t\t\tans=MID; hi=MID-1;\n\t\t}\n\t\telse lo=MID+1;\n\t}\n\tcout<<res<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_LG = 17;\n\nvector<int> adj [MAX_N];\n\nint max_fold_without (const vector<int> &v, int idx) {\n  int lptr = 0;\n  if (lptr == idx) lptr++;\n  int rptr = (int) v.size() - 1;\n  if (rptr == idx) rptr--;\n\n  int mx = 0;\n  while (lptr < rptr) {\n    mx = max(mx, v[lptr] + v[rptr]);\n\n    lptr++;\n    if (lptr == idx) lptr++;\n    rptr--;\n    if (rptr == idx) rptr--;\n  }\n\n  return mx;\n}\n\nint dp [MAX_N]; // cheapest thing we can send up\nint cap;\nbool error;\nvoid dfs (int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n    }\n  }\n\n  vector<int> ups;\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      ups.push_back(dp[nxt]);\n    }\n  }\n\n  if ((int) adj[u].size() % 2 == 1) {\n    ups.push_back(0);\n  }\n  sort(ups.begin(), ups.end());\n\n  if (u == p) {\n    int fold = max_fold_without(ups, -1);\n    if (fold > cap) error = 1;\n    return;\n  }\n\n  if (max_fold_without(ups, (int) ups.size() - 1) > cap) {\n    error = 1;\n  } else if (max_fold_without(ups, 0) <= cap) {\n    dp[u] = ups[0];\n  } else {\n    int ans = 0;\n    for (int k = MAX_LG; k != 0; k /= 2) {\n      if (ans + k < (int) ups.size() && max_fold_without(ups, ans + k) > cap) {\n        ans += k;\n      }\n    }\n    dp[u] = ups[ans + 1];\n  }\n  dp[u]++;\n\n  if (dp[u] > cap) error = 1;\n}\n\nbool try_with (int _cap) {\n  cap = _cap;\n  error = 0;\n  dfs(1, 1);\n  return error;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int oddc = 0;\n  for (int i = 1; i <= n; i++) {\n    if ((int) adj[i].size() % 2 == 1) oddc++;\n  }\n  \n  int ans = 0;\n  for (int k = 1 << MAX_LG; k != 0; k /= 2) {\n    cap = ans + k;\n    error = 0;\n    dfs(1, 1);\n    if (error) {\n      ans += k;\n    }\n  }\n\n  cout << oddc / 2 << \" \" << ans + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5;\nvector<int> g[N];\nvector<int> path[N];\nint ans = 0;\n\nvoid dfs(int u, int p, int x) {\n  for (int v : g[u]) if (v != p) {\n    dfs(v, u, x);\n    path[u].push_back(path[v].back() + 1);\n  }\n\n  if (p == -1 && path[u].size() % 2 == 1) {\n    ans++;\n  }\n\n  if (path[u].size() % 2 == 0) {\n    path[u].push_back(0);\n  }\n\n  sort(path[u].begin(), path[u].end());\n\n  int ok = path[u].size();\n  int ng = -1;\n\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n\n    int mx = 0;\n    auto tmp = path[u];\n    tmp.erase(tmp.begin() + mid);\n\n    for (int i = 0; i * 2 + 1 < tmp.size(); i++) {\n      mx = max(mx, tmp[i] + tmp[tmp.size() - 1 - i]);\n    }\n\n    if (mx <= x) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n  ans += path[u].size() / 2;\n \n  if (ok == path[u].size()) throw -1;\n  swap(path[u][ok], path[u].back());\n  \n  if (p == -1) {\n    if (path[u].back() > x) throw -1;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int ok = n - 1;\n  int ng = -1;\n  while (ok - ng > 1) {\n    ans = 0;\n    for (int i = 0; i < n; i++) {\n      path[i].clear();\n    }\n    int mid = (ok + ng) / 2;\n    try {\n      dfs(0, -1, mid);\n      ok = mid;\n    } catch (...) {\n      ng = mid;\n    }\n  }\n\n  cout << ans << ' ' << ok << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t\t\t\t\t\nusing namespace std;\n\t\t\t\ntypedef long long ll;\n#define mp make_pair\n#define pub push_back\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define db long double\n#define sz(a) (int)a.size()\n\nint n;\nvector<int> g[100007];\n\nint calcCnt(int v, int pred){\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tans += calcCnt(to, v);\n\t\tcnt++;\n\t}\n\tif (v != 0) cnt--;\n\tans += (cnt + 1) / 2;\n\treturn ans;\n}\n\nbool f;\nint ww;\n\nint dfs(int v, int pred){\n\tif (g[v].size() == 1 && g[v][0] == pred) return 0;\n\tmultiset<int> se;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tse.insert(dfs(to, v) + 1);\n\t}\n\tif (v == 0){\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\tif ((*se.begin()) > ww) f = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t} else {\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\treturn (*se.begin());\n\t\t\t}\n\t\t\tif (se.size() == 2){\n\t\t\t\tif ((*(--se.end())) + (*se.begin()) <= ww) return 0;\n\t\t\t\tif ((*(--se.end())) > ww) f = 0;\n\t\t\t\treturn *se.begin();\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t}\n}\n\nbool can(int val){ \n\tf = 1; ww = val;\n\tdfs(0, -1);\n\treturn f;\n}\n\nint main(){\n\tsrand(123321);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pub(b);\n\t\tg[b].pub(a);\n\t}\n\n\tint vl = 0, vr = 1e9 + 7;\n\twhile(vl + 1 < vr){\n\t\tint vm = (vl + vr) >> 1;\n\t\tif (can(vm))\n\t\t\tvr = vm;\n\t\telse\n\t\t\tvl = vm;\n\t}\n\tcout << calcCnt(0, -1) << ' ' << vr;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll INF = 1e8, SZ = 1e5 + 10;\n\nll n;\nvector<vector<ll>> gr;\nbool used[SZ];\n\nbool fl = true;\n\nll bst(vector<ll> &vec, int ln) {\n\tint l = -1, r = vec.size() - 1;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tvector<ll> vec2 = vec;\n\t\tvec2.erase(vec2.begin() + mid);\n\t\tll maxS = 0;\n\t\tfor (int i = 0; i < vec2.size(); i++) {\n\t\t\tll rv = vec2.size() - i - 1;\n\t\t\tif (i == rv) {\n\t\t\t\tmaxS = max(maxS, vec2[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxS = max(maxS, vec2[i] + vec2[rv] - 1);\n\t\t\t}\n\t\t}\n\t\tif (maxS > ln) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t}\n\n\treturn vec[r];\n}\n\nll dp(int v, int l) {\n\tused[v] = 1;\n\n\tvector<ll> vals;\n\tfor (auto to : gr[v]) {\n\t\tif (!used[to]) {\n\t\t\tvals.push_back(dp(to, l) + 1);\n\t\t}\n\t}\n\n\tif (gr[v].size() == 1 && vals.size() == 1) {\n\t\tif (vals[0] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (gr[v].size() == 1) return 1;\n\tif (gr[v].size() == 2) return vals[0];\n\n\tsort(vals.begin(), vals.end());\n\tif (gr[v].size() % 2 == 1) {\n\t\tif (vals.back() > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tvals.pop_back();\n\t}\n\tfor (int i = 0; i < vals.size() - 1; i++) {\n\t\tll rev = vals.size() - 2 - i;\n\t\tif (i == rev && vals[i] > l) {\n\t\t\tfl = false;\n\t\t}\n\t\tif (i != rev && vals[i] + vals[rev] - 1 > l) {\n\t\t\tfl = false;\n\t\t}\n\t}\n\n\tif (!fl) return 0;\n\n\treturn bst(vals, l);\n}\n\nbool check(int l) {\n\tfl = true;\n\n\tif (l == 5) {\n\t\tcout << \"\";\n\t}\n\tfor (int i = 0; i < n; i++) used[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() == 1) dp(i, l);\n\t}\n\n\treturn fl;\n}\n\nint main() {\n\tfastInp;\n\n\tcin >> n;\n\n\tgr.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\n\tll cnt = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (gr[i].size() > 2) cnt += (gr[i].size() - 3) / 2 + 1;\n\t}\n\n\tcout << cnt + 1 << \" \";\n\n\tint l = 0, r = INF;\n\twhile (r - l > 1) {\n\t\tint mid = (l + r) / 2;\n\t\tif (check(mid)) {\n\t\t\tr = mid;\n\t\t}\n\t\telse {\n\t\t\tl = mid;\n\t\t}\n\t}\n\n\tcout << r - 1;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root, int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to, root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size();\n\tmultiset<int> mt;\n\trep(i, len)mt.insert(v[i]);\n\twhile(len>=2) {\n\t\tcnt++;\n\t\tauto itr = mt.end(); itr--;\n\t\tint z = *itr; mt.erase(mt.find(z)); len--;\n\t\tint r = c - z;\n\t\tif (mt.count(r)) {\n\t\t\tmt.erase(mt.find(r)); len--;\n\t\t}\n\t\telse {\n\t\t\tmt.insert(r);\n\t\t\tauto itr2 = mt.find(r);\n\t\t\tif (itr2 == mt.begin())continue;\n\t\t\titr2--; mt.erase(r); len--;\n\t\t\tint zz = *itr2;\n\t\t\tmt.erase(itr2);\n\t\t}\n\t}\n\tint z = 0;\n\tif (len == 1) {\n\t\tz = *mt.begin();\n\t\tif (z == c) {\n\t\t\tcnt++; z = 0;\n\t\t}\n\t}\n\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa << \" \" << ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (300006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tFOR(i,1,25){\n\t\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\t\tdp[x]=pi(0,0);\n\t\t\tmultiset<ll,greater<ll>> s;\n\t\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\t\tif(dp[i].s+1==d){\n\t\t\t\t\t++ dp[x].f;\n\t\t\t\t}else{\n\t\t\t\t\ts.ins(dp[i].s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(s.size()>1){\n\t\t\t\tll y=*s.begin();\n\t\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\t\tif(other==s.end()) break;\n\t\t\t\tif(other==s.begin())++other;\n\t\t\t\tassert(y+*other+1 <= d);\n\t\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t\t++dp[x].f;\n\t\t\t}\n\t\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\t\telse dp[x].s = x != 1;\n\t\t\tif(x==1){\n\t\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t\t}\n\t\t};\n\t\tauto bstar=[&](ll x){\n\t\t\tdfs(1,1,x);\n\t\t\treturn dp[1].f <= i;\n\t\t};\n\t\tll st=1, en=n+1;\n\t\twhile(en-st>1){\n\t\t\tll mid=(st+en)>>1;\n\t\t\tif(bstar(mid))en=mid;\n\t\t\telse st=mid;\n\t\t}\n\t\tif(en==n+1)continue;\n\t\tcout<<i<<' '<<en-1<<'\\n';\n\t\treturn 0;\n\t}\n\tassert(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvector<int> g[100005];\n\nint dfs(int m, int d, int from){\n  vector<int> ch;\n  for(auto to : g[d]) if(to!=from){\n    int r = dfs(m, to ,d);\n    if(r > m) return INF;\n    ch.pb(r);\n  }\n  // dbg(m,d,ch);\n  int sz = ch.size();\n  if(sz==0) return 1;\n  if(sz==1) return ch[0]+1;\n\n  sort(all(ch));\n  auto check = [&](int mid){\n    int l = 0, r = sz-1;\n    while(l<r){\n      if(l==mid) l++;\n      if(r==mid) r--;\n      if(l>=r) break;\n      if(ch[l]+ch[r] > m) return false;\n      l++;\n      r--;\n    }\n    return true;\n  };\n  if(sz%2==0 && check(-1)) return 1;\n\n  if(check(0)) return ch[0]+1;\n  if(!check(sz-1)) return INF;\n  int l = 0, r = sz-1;\n  while(r-l>1){\n    int mid = (l+r)/2;\n    if(check(mid)) r = mid;\n    else l = mid;\n  }\n  return ch[r]+1;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n\n  int a = 1;\n  rep(i,n) a += (g[i].size()-1)/2;\n\n  int d = 0;\n  while(g[d].size()!=1) d++;\n\n  int l = 0, r = n;\n  while(r-l>1){\n    int m = (r+l)/2;\n    if(dfs(m, d, -1) <= m+1) r = m;\n    else l = m;\n  }\n\n  cout << a << \" \" << r << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100009;\nint n, a, b, ans, l, r, mid, limit, need;\nvector<int> e[maxn];\n\nvoid dfs1(int u, int fa) {\n\tint cnt = 0;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\tdfs1(e[u][i], u);\n\t\t\tcnt++;\n\t\t}\n\tif (!fa) ans += (cnt + 1) / 2;\n\telse ans += cnt / 2;\n}\n\nmultiset<int>::iterator it, p;\nint dfs2(int u, int fa) {\n\tint tmp; multiset<int> s;\n\tfor (int i=0; i<e[u].size(); i++)\n\t\tif (e[u][i] != fa) {\n\t\t\ts.insert(tmp = dfs2(e[u][i], u) + 1);\n\t\t\tif (!tmp) return -1;\n\t\t}\n\t//printf(\"~ %d %d\\n\", u, s.size());\n\twhile (s.size() >= 2) {\n\t\tp = --s.end(); tmp = *p;\n\t\tif (tmp > limit) return -1;\n\t\ts.erase(p); need++;\n\t\tit = s.upper_bound(limit-tmp);\n\t\t//printf(\"%d\", tmp);\n\t\tif (it != s.begin()) {\n\t\t\tit--;\n\t\t\ts.erase(it);\n\t\t//\tprintf(\" %d\", *it);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tif (!fa && !s.empty()) {\n\t\tif (*s.begin() > limit) return -1;\n\t\tneed++;\n\t}\n\treturn !s.empty() ? *s.begin() : 0;\n}\n\nbool check(int x) {\n\tlimit = x; need = 0;\n\t//printf(\"-------------  %d  -------------------\\n\", limit);\n\tif (dfs2(n/2+1, 0) == -1) return 0;\n\treturn need == ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n-1; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tdfs1(n/2+1, 0);\n\tl = 1; r = n-1;\n\twhile (l < r) {\n\t\tmid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans, l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nconst int rt=1;int dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN],fson[MAXN];\ninline bool chk2(int k,int r)\n{\n\tfor(int p1=1,p2=k;p1<p2;p1+=p1+1==r?2:1,p2-=p2-1==r?2:1)\n\t\tif(fson[p1]+fson[p2]>B) return false;\n\treturn true;\n}\nbool dfs(int u,int la)\n{\n\tint k=0;\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfson[++k]=f[v];\n\t}\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1)) fson[++k]=0;\n\tstd::sort(fson+1,fson+1+k);\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(chk2(k,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fson[l]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(rt,0)) return false;\n\tif(f[rt]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\taddEdge2(rt,1);\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\nint cnt[MAX];\nmultiset<int> vv[MAX];\nmultiset<int> tmp[MAX];\n\nbool can;\nint mx;\nvector<int> unf[MAX];\nint C;\ninline void dfs(int b, int pr = -1) {\n\tvv[b].clear();\n\tunf[b].clear();\n\tint deg = 0;\n\tfor (int go : v[b]) {\n\t\tif (go == pr)continue;\n\t\tdfs(go, b);\n\t\tdeg++;\n\t\tvv[b].insert(dp[go] + 1);\n\t}\n\ttmp[b] = vv[b];\n\tC += deg/2;\n\tif (deg % 2 && b == 0) {\n\t\tC++;\n\t}\n\tif (vv[b].size()) {\n\t\tint la = (*vv[b].rbegin());\n\t\tif (la > mx) {\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (vv[b].size() > 1) {\n\t\tint bc = *vv[b].rbegin();\n\t\tvv[b].erase(prev(vv[b].end()));\n\t\tint able = mx - bc;\n\t\tauto it = vv[b].upper_bound(able);\n\t\tif (it == vv[b].begin()) {\n\t\t\tunf[b].push_back(bc);\n\t\t\tcontinue;\n\t\t}\n\t\tit = prev(it);\n\t\tvv[b].erase(it);\n\t}\n\tif (vv[b].size()) {\n\t\tunf[b].push_back(*vv[b].begin());\n\t}\n\tvv[b].clear();\n\tif (deg%2&&unf[b].size() > 1) {\n\t\tcan = true;\n\t\tdp[b] = 0;\n\t\treturn;\n\t}\n\tif (deg % 2) {\n\t\tdp[b] = unf[b][0];\n\t\treturn;\n\t}\n\telse {\n\t\tif (unf[b].size() == 0) {\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tvv[b] = tmp[b];\n\t\t\tunf[b].clear();\n\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\twhile (vv[b].size() > 1) {\n\t\t\t\tint bc = *vv[b].rbegin();\n\t\t\t\tvv[b].erase(prev(vv[b].end()));\n\t\t\t\tint able = mx - bc;\n\t\t\t\tauto it = vv[b].upper_bound(able);\n\t\t\t\tif (it == vv[b].begin()) {\n\t\t\t\t\tunf[b].push_back(bc);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit = prev(it);\n\t\t\t\tvv[b].erase(it);\n\t\t\t}\n\t\t\tif (vv[b].size()) {\n\t\t\t\tunf[b].push_back(*vv[b].begin());\n\t\t\t}\n\t\t\tif (unf[b].size() == 1) {\n\t\t\t\tdp[b] = unf[b][0];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcan = true;\n\t\t\tdp[b] = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\nbool ok(int len) {\n\tcan = false;\n\tmx = len;\n\tC = 0;\n\tdfs(0);\n\treturn can == false;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint mint = 1;\n\tint maxt = n;\n\twhile (mint + 1 < maxt) {\n\t\tint mid = (mint + maxt) >> 1;\n\t\tif (ok(mid)) {\n\t\t\tmaxt = mid;\n\t\t}\n\t\telse {\n\t\t\tmint = mid + 1;\n\t\t}\n\t}\n\tif (ok(mint)) {\n\t\tok(mint);\n\t\tcout <<C<<\" \"<< mint << endl;\n\t}\n\telse {\n\t\tok(maxt);\n\t\tcout << C<<\" \"<<maxt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) { assert(b==0); return 0; }\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=100;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nVI e[N];\nint l,r,mid,f[N];\ninline void dfs(int k) {\n\tfor (int t:e[k]) {\n\t\te[t].erase(find(e[t].begin(),e[t].end(),k));\n\t\tdfs(t);\n\t}\n}\ninline bool solve(int k) {\n\tint m=e[k].size(),i;\n\tVI w(m);\n\tfor (i=0;i<m;i++) {\n\t\tif (!solve(e[k][i])) return false;\n\t\tw[i]=f[e[k][i]]+1;\n\t}\n\tsort(w.begin(),w.end());\n\tif (k==1) {\n\t\tif (m&1) {\n\t\t\tif (w[m-1]>mid) return false;\n\t\t\tm--;\n\t\t}\n\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) return false;\n\t} else {\n\t\tif (m&1) {\n\t\t\tf[k]=w[0];\n\t\t\tfor (i=1;i<=m/2;i++)\n\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\tf[k]=w[i];\n\t\t\t\t}\n\t\t} else {\n\t\t\tf[k]=0;\n\t\t\tfor (i=0;i<m/2;i++) if (w[i]+w[m-1-i]>mid) break;\n\t\t\tif (i<m/2) {\n\t\t\t\tif (w[m-1]>mid) return false;\n\t\t\t\tm--;\n\t\t\t\tf[k]=w[0];\n\t\t\t\tfor (i=1;i<m;i++)\n\t\t\t\t\tif (w[i]+w[m-i]>mid) {\n\t\t\t\t\t\tif (f[k]+w[m-i]>mid) return false;\n\t\t\t\t\t\tf[k]=w[i];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=gi(),i,a,b,ans=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\te[a].pb(b),e[b].pb(a);\n\t}\n\tans=1;\n\tfor (i=1;i<=n;i++) ans+=(e[i].size()-1)/2;\n\tdfs(1);\n\tl=1,r=n;\n\twhile (l!=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (solve(1)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<ans<<\" \"<<l<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#  include <intrin.h>\n#  define __builtin_popcount __popcnt\n#endif\n\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <list>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) os << *i << (i == end(v) - 1 ? \"\" : \" \"); return os;\n}\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) is >> *i; return is;\n}\n\nvector<int> edg[101000];\n\nint dfs(int i, int max_sz, int parent = -1)\n{\n\tvector<int> arr;\n\tfor (int u : edg[i])\n\t{\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tint add = dfs(u, max_sz, i) + 1;\n\t\tarr.push_back(add);\n\t\tif (add > max_sz)\n\t\t\tthrow 1;\n\t}\n\n\t\n\tif (arr.size() % 2 == 0)\n\t{\n#if 0\n\t\tbool ok = true;\n\t\tfor (int i = 0, j = arr.size() - 1; i < j; i++, j--)\n\t\t{\n\t\t\tif ((arr[i] + arr[j]) > max_sz)\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok)\n\t\t\treturn 0;\n\t\tarr.pop_back();\n#endif\n\t\tarr.push_back(0);\n\t}\n\n\tsort(arr.begin(), arr.end());\n\n\t{\n\t\tint left = 0, right = arr.size();\n\t\twhile (left < right)\n\t\t{\n\t\t\tint m = (left + right) / 2;\n\n\t\t\tvector<int> tmp;\n\t\t\tfor (int j = 0; j < arr.size(); j++)\n\t\t\t{\n\t\t\t\tif (j != m)\n\t\t\t\t\ttmp.push_back(arr[j]);\n\t\t\t}\n\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0, j = tmp.size() - 1; i < j; i++, j--)\n\t\t\t{\n\t\t\t\tif ((tmp[i] + tmp[j]) > max_sz)\n\t\t\t\t\tok = false;\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tright = m;\n\t\t\telse\n\t\t\t\tleft = m + 1;\n\t\t}\n\n\t\tif (left == arr.size())\n\t\t\tthrow 1;\n\t\treturn arr[left];\n\t}\n}\n\nint main()\n{\n#if defined(_DEBUG) \n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedg[a].push_back(b);\n\t\tedg[b].push_back(a);\n\t}\n\n\tint A = 0;\n\tint leaf_i = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (edg[i].size() % 2 == 1)\n\t\t\tA++;\n\t\tif (edg[i].size() == 1)\n\t\t\tleaf_i = i;\n\t}\n\n\tA /= 2;\n\n\tint left = 0, right = n;\n\twhile (left < right)\n\t{\n\t\tint m = (left + right) / 2;\n\t\ttry\n\t\t{\n\t\t\tdfs(leaf_i, m, -1);\n\t\t}\n\t\tcatch (int)\n\t\t{\n\t\t\tleft = m + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tright = m;\n\t}\n\n\tcout << A << \" \" << left;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint in[MAX_N];\nvi G[MAX_N];\nint dp[MAX_N];\nint M;\n\nvoid dfs(int v, int p) {\n\tmultiset<int> S;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(n == p) continue;\n\t\tdfs(n, v);\n\t\tif(dp[n] != -1) S.insert(-(dp[n] + 1));\n\t}\n\tif(in[v] % 2) S.insert(0);\n\twhile(!S.empty()) {\n\t\tint t = -(*S.begin());\n\t\tS.erase(S.begin());\n\t\tauto b = S.lower_bound(-(M - t));\n\t\tif(b != S.end()) {\n\t\t\tS.erase(b);\n\t\t}\n\t\telse {\n\t\t\tif(dp[v] == -1) dp[v] = t;\n\t\t\telse dp[v] = M + 1;\n\t\t}\n\t}\n}\n\nbool ok(int m) {\n\tM = m;\n\tmemset(dp, -1, sizeof(dp));\n\tdfs(0, -1);\n\tif(dp[0] == -1) return true;\n\telse return false;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tin[a]++; in[b]++;\n\t}\n\tint A = 0;\n\trep(i, 0, N) {\n\t\tA += in[i] % 2;\n\t}\n\tint lv = 0, rv = N;\n\twhile(rv - lv > 1) {\n\t\tint m = (lv + rv) / 2;\n\t\tif(ok(m)) rv = m;\n\t\telse lv = m;\n\t}\n\tcout << A / 2 << \" \" << rv << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n    for(int i=1;i<=n;++i){\n        if(V[i].size()%2) ++all;\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    assert(all==ans);\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nint n;\nvector<vector<int>>hen;\nvector<int>ki;//is kisu\nint solve(int ter,int oya,int bgen){\n\t//解きます\n\t//cerr<<ter<<endl;\n\tmultiset<int>soi;\n\tif(ki[ter]){soi.ins(0);}\n\tfor(auto it:hen[ter]){\n\t\tif(it==oya){continue;}\n\t\tint kae=solve(it,ter,bgen);\n\t\tif(kae==-1){return -1;}\n\t\tsoi.ins(kae);\n\t}\n\t//bgen以下を作る貪欲法\n\t//soiは1あまる\n\t//setで殴りすぎlogがひどい\n\twhile(soi.size()>1){\n\t\tint mae=*prev(soi.end());\n\t\tsoi.era(prev(soi.end()));\n\t\tauto itr=soi.upper_bound(bgen-mae);\n\t\tif(itr==soi.begin()){return -1;}//ないので\n\t\tsoi.era(prev(itr));\n\t}\n\tif(oya!=-1){return (*soi.begin())+1;}\n\telse{return 0;}\n}\nint main(void){\n\tint i;\n\tcin>>n;hen.res(n);ki.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\then[a].pub(b);ki[a]=(!ki[a]);\n\t\then[b].pub(a);ki[b]=(!ki[b]);\n\t}\n\tint A=0,ha=-1;\n\tfor(i=0;i<n;i++){if(ki[i]){A++;}if(hen[i].size()==1){ha=i;}}\n\tcout<<A/2<<\" \";\n\tint bmax=n,bmin=0;\n\twhile(bmax-bmin>1){\n\t\tint bgen=(bmax+bmin)/2;\n\t\tif(solve(ha,-1,bgen)!=-1){bmax=bgen;}\n\t\telse{bmin=bgen;}\n\t}\n\tcout<<bmax<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<vector<ll>>g(n);\n  rep(i,0,n-1){\n    ll u,v;cin>>u>>v;u--;v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n  rep(i,0,n){\n    if(g[i].size()&1)res++;\n  }\n  ll ok=n,ng=0;\n  while(ok-ng>=2){\n    ll mid=(ok+ng)/2;\n    bool sw=true;\n    auto dfs=[&](auto &&f,ll k,ll par)->ll{\n      vector<ll>v;\n      if(g[k].size()&1)v.PB(0);\n      for(auto to:g[k]){\n        if(to==par)continue;\n        ll p=f(f,to,k);\n        if(p!=-1)v.PB(p);\n      }\n      sort(ALL(v));\n      ll sz=v.size();\n      rep(i,0,sz/2){\n        if(v[i]+v[sz-i-1]>mid)sw=false;\n      }\n      if(sz%2==0){\n        return -1;\n      }\n      else{\n        ll ok=sz-1,ng=-1;\n        while(ok-ng>=2){\n          ll mid2=(ok+ng)/2;\n          vector<ll>tmp;\n          rep(i,0,sz)if(i!=mid2)tmp.PB(v[i]);\n          bool sw2=true;\n          rep(i,0,sz/2){\n            //cout<<i spa sz-i-2 spa tmp[i] spa tmp[sz-i-2]<<endl;\n            if(tmp[i]+tmp[sz-i-2]>mid)sw2=false;\n          }\n          if(sw)ok=mid2;\n          else ng=mid2;\n        }\n        return v[ok]+1;\n      }\n    };\n    dfs(dfs,0,-1);\n    if(sw)ok=mid;\n    else ng=mid;\n  }\n  cout<<res/2 spa ok<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1) return -1;\n\t\t\telse if(res == B) ++tot, res = 0;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2 + 1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) \n\t\t\t{\n\t\t\t\ttot += a.size() / 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\ttot += (a.size() + 1) / 2;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\ttot += a.size() / 2;\n\t\treturn ret;\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn tot <= A;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(dp[n]>m) judge = false;\n\t//if(n==1 && dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 0,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint B, r;\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\tassert(i >= 0);\n\t\treturn v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, t, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\ttr = 1;\n\tfor (i = 1; i <= n; i++) tr += (g[i].size() - 1) / 2;\n\ttr >>= 1;\n\tB = n;\n\tt = f(1, 1);\n\tif (t) r++;\n\tassert(r == tr);\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tt = f(1, 1);\n\t\tif (t) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[100001];\nvector<int> tree[100001];\nvector<int> l[100001];\nint p[100001];\nint bye[100001];\n\nint ans1 = 0;\nint lim = 0;\n\nvoid dfs1(int x){\n    int cntt = 0;\n    for(auto &nxt: g[x]){\n        if(nxt == p[x]) continue;\n        tree[x].push_back(nxt);\n        p[nxt] = x;\n        dfs1(nxt);\n        cntt++;\n    }\n    ans1 += (cntt / 2);\n    if(x == 1 && (cntt % 2) == 1) ans1++;\n}\n\nbool dfs2(int x){\n    l[x].clear();\n    for(auto &nxt: tree[x]){\n        if(!dfs2(nxt)) return false;\n        //printf(\"bye %d -> %d: %d\\n\", nxt, x, bye[nxt]);\n        l[x].push_back(bye[nxt]+1);\n    }\n    int m = (int)l[x].size();\n    if(m%2 == 0){\n        l[x].push_back(0);\n        m++;\n    }\n    sort(l[x].begin(), l[x].end());\n    for(auto &val: l[x]){\n        if(val > lim) return false;\n    }\n    bye[x] = 0;\n    int ss = 0, ee = m-1, ans = m;\n    while(ss <= ee){\n        int mid = (ss + ee) / 2;\n        int s = 0, e = m-1;\n        bool can = true;\n        while(s < e){\n            if(s == mid) s++;\n            if(e == mid) e--;\n            if(s >= e) break;\n            if(l[x][s] + l[x][e] > lim){\n                can = false;\n                break;\n            }else{\n                s++; e--;\n            }\n        }\n        if(can){\n            ans = mid;\n            ee = mid - 1;\n        }else{\n            ss = mid + 1;\n        }\n    }\n    if(ans == m) return false;\n    bye[x] = l[x][ans];\n    return true;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<n;i++){\n        int aa, bb;\n        scanf(\"%d%d\", &aa, &bb);\n        g[aa].push_back(bb);\n        g[bb].push_back(aa);\n    }\n    p[1] = 1;\n    dfs1(1);\n    int ss = 1, ee = n+1, ans2 = n+1;\n    while(ss <= ee){\n        lim = (ss + ee) / 2;\n        //printf(\"%d\\n\", lim);\n        if(dfs2(1)){\n            ans2 = lim;\n            ee = lim - 1;\n        }else{\n            ss = lim + 1;\n        }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,ed,B,g[N],f[N],q[N],deg[N];\nstruct E{int v,nxt;}e[N<<1];\ninline void adde(int x,int y){e[++ed].v=y;e[ed].nxt=g[x];g[x]=ed;}\nint dfs(int x,int y){\n\tint i;f[x]=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y&&!dfs(e[i].v,x))return 0;\n\tint t=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y)q[++t]=f[e[i].v]+1;\n\tif(!t)return 1;\n\tif(~t&1)q[++t]=0;\n\tsort(q+1,q+1+t);\n\tif(q[t]>B)return 0;\n\tint l=1,r=t+1;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;\n\t\tint l1=0,r1=t+1;\n\t\tfor(i=1;i<=t/2;++i){\n\t\t\tif(++l1,l1==mid)++l1;\n\t\t\tif(--r1,r1==mid)--r1;\n\t\t\tif(q[l1]+q[r1]>B)break;\n\t\t}\n\t\tif(i<=t/2)l=mid+1;\n\t\telse r=mid;\n\t}\n\tif(l>t)return 0;\n\treturn f[x]=q[l],1; \n}\n\nint main(){\n\t//freopen(\"aa.in\",\"r\",stdin);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);adde(y,x);\n\t\t++deg[x];++deg[y];\n\t}\n\tint tot=0;\n\tfor(i=1;i<=n;++i)if(deg[i]&1)++tot;\n\ttot>>=1;\n\tint l=1,r=n;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;B=mid;\n\t\tif(!dfs(1,1))l=mid+1;\n\t\telse r=mid;\n\t}\n\tprintf(\"%d %d\",tot,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint K;\nbool dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    multiset<int> st;\n    st.insert(0);\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        const bool f = dp_dfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        st.insert(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = st.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        st.insert(0);\n    }\n\n    int mini = 10000;\n    while (not st.empty()) {\n        auto it = st.end();\n        it--;\n        const int v = *it;\n        st.erase(it);\n        auto upp = st.upper_bound(K - v - 1);\n        if (upp == st.begin()) {\n            return false;\n        }\n        upp--;\n        if (*upp == 0 or v == 0) {\n            mini = min(mini, *upp + v + 1);\n        }\n        st.erase(upp);\n    }\n    dp[s] = {sum, mini};\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    int inf = 0;\n    int sup = N + 1;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        if (dp_dfs(g, 0, dp)) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    dp_dfs(g, 0, dp);\n    cout << dp[0].first + 1 << \" \" << sup - 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define si scanf\n#define so printf\n#define N 200100\n#define M \n#define INF  \n#define nxt t[j]\ntemplate<typename TP>inline bool rd(TP& r)\n{\n\tr=0;\n\tchar tmp=getchar();\n\twhile(tmp<'0'||tmp>'9')\n\t{\n\t\tif(tmp==EOF)\n\t\t\treturn 0;\n\t\ttmp=getchar();\n\t}\n\twhile('0'<=tmp&&tmp<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+tmp-'0';\n\t\ttmp=getchar();\n\t}\n\treturn 1;\n\t\n} \nint n; \nint h[N],x[N*2],t[N*2],tot=1;\nint du[N],A;\nvoid add(int u,int v)\n{\n\t++tot;\n\tx[tot]=h[u];\n\th[u]=tot;\n\tt[tot]=v;\n\t++du[u];\n}\nint ln[N],l2[N];\nint f[N];\nbool ok(int mid,int u)\n{\n\tfor(int i=1;i<=ln[0];++i)\n\t\tif(i==mid)\n\t\t\tl2[i]=n+100;\n\t\telse\n\t\t\tl2[i]=ln[i];\n\tsort(l2+1,l2+ln[0]+1);\n\tfor(int i=1;i<ln[0];++i)\n\t\tif(l2[i]+l2[ln[0]-i]+1>u)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dp(int u)\n{\n\tsort(ln+1,ln+ln[0]+1);\n\tfor(int i=1;i<=ln[0]-1;++i)\n\t\tif(ln[i]+ln[ln[0]-i]+1>u)//无法配对 \n\t\t\treturn n*12;\n\tln[ln[0]+1]=n*12;\n\tint l=1,r=ln[0]+1,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tif(ok(mid,u))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tif(l>ln[0])\n\t\treturn n*12;\n\treturn ln[l]+1;\n}\nbool dfs(int now,int u,int fa)\n{\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tif(dfs(nxt,u,now)==0)\n\t\t\t\treturn 0;\n\tln[0]=0;\n\tfor(int j=h[now];j;j=x[j])\n\t\tif(nxt!=fa)\n\t\t\tln[++ln[0]]=f[nxt];\n\tif(du[now]&1)\n\t\tln[++ln[0]]=0;\n\tf[now]=dp(u);\n\tif(f[now]>u)\n\t\treturn 0; \n\treturn 1;\n}\nint main()\n{\n\trd(n);\n\tint u,v;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\trd(u),rd(v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(du[i]&1)\n\t\t\t++A;\n\tA>>=1;\n\tint l=1,r=n*10,mid;\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\t//memset(f,0x3f,sizeof(f));\n\t\tif(dfs(1,mid,0))\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tso(\"%d %d\\n\",A,l-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[101000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\tif (edge[v].size() == 1) {\n\t\treturn 0;\n\t}\n\tif (edge[v].size() == 2) {\n\t\tfor (auto& e : edge[v]) {\n\t\t\tif (e != parent) { return 1 + func(e, v); }\n\t\t}\n\t}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1) return -1;\n\t\t\telse if(res == B) ++tot, res = 0;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2 + 1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) \n\t\t\t{\n\t\t\t\ttot += a.size() / 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\ttot += a.size() / 2;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\ttot += a.size() / 2;\n\t\treturn ret;\n\t\t\t\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn tot <= A;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, a[100009], b[100009], sum, G, dp[100009]; vector<int>x[100009]; bool used[100009], flag = false;\n\nint solve(vector<int>F) {\n\tint res = 0;\n\tfor (int i = 0; i < F.size(); i++) res = max(res, F[i] + F[F.size() - 1 - i]);\n\treturn res;\n}\n\nint dfs(int pos) {\n\tif (flag == true) return (1 << 30);\n\tused[pos] = true;\n\tvector<int>I;\n\tfor (int i = 0; i < x[pos].size(); i++) {\n\t\tif (used[x[pos][i]] == true) continue;\n\t\tI.push_back(dfs(x[pos][i]) + 1);\n\t\tif (flag == true) return (1 << 30);\n\t}\n\tif (I.size() == 0) {\n\t\tdp[pos] = 0;\n\t\treturn 0;\n\t}\n\tsort(I.begin(), I.end());\n\tif (I[I.size() - 1] > G) {\n\t\tflag = true;\n\t\treturn (1 << 30);\n\t}\n\tdp[pos] = (1 << 30);\n\tif (I.size() % 2 == 0) {\n\t\tif (solve(I) <= G) {\n\t\t\tdp[pos] = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (x[pos].size() % 2 == 1) I.pop_back();\n\tif (I.size() % 2 == 0) {\n\t\tif (solve(I) <= G) {\n\t\t\tdp[pos] = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (I.size() % 2 == 1) {\n\t\tint L = 0, R = I.size(), M, maxn = (1 << 30);\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tvector<int>J; for (int j = 0; j < I.size(); j++) { if (j != M) J.push_back(I[j]); }\n\t\t\tint ret = solve(J);\n\t\t\tif (ret <= G) { R = M; maxn = min(maxn, M); }\n\t\t\telse { L = M; }\n\t\t}\n\t\tif (maxn != (1 << 30)) {\n\t\t\tdp[pos] = min(dp[pos], I[maxn]);\n\t\t}\n\t}\n\tif (dp[pos] == (1 << 30)) {\n\t\tflag = true;\n\t}\n\treturn dp[pos];\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tx[a[i]].push_back(b[i]);\n\t\tx[b[i]].push_back(a[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) { if (x[i].size() % 2 == 1) sum++; }\n\tint L = 1, R = n + 1, M, minx = (1 << 30);\n\tfor (int i = 0; i < 20; i++) {\n\t\tM = (L + R) / 2; G = M;\n\t\tfor (int j = 1; j <= n; j++) used[j] = false; flag = false;\n\t\tint F = dfs(1);\n\t\tif (F <= M) { R = M; minx = M; }\n\t\telse { L = M; }\n\t}\n\tcout << sum / 2 << \" \" << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint mx;\nint num;\n\nvoid pre(int v, int p)\n{\n\tint cnt = 0;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tpre(to, v);\n\t\t++cnt;\n\t}\n\n\tnum += (cnt / 2);\n\tif (p == -1) {\n\t\tif (cnt & 1) ++num;\n\t}\n}\n\nint dfs(int v, int p, int x)\n{\n\tvi vec;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tint u = dfs(to, v, x);\n\t//\tcout << \"DEBUG \" << to << \" \" << u << endl;\n\t\tif (u == -1 || u >= x) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(u + 1);\n\t}\n\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tmultiset<int> ss;\n\tfor (int x : vec) {\n\t\tss.insert(x);\n\t}\n\n\tint ng_cnt = 0;\n\tint val = -1;\n\n\twhile (ss.size() >= 2) {\n\t\tint a = *ss.rbegin();\n\t\tss.erase(ss.lower_bound(a));\n\t\tauto it = ss.upper_bound(x - a);\n\n\t\tif (v == 3) {\n\t\t//\tputs(\"wo\");\n\t\t}\n\n\t\tif (it == ss.begin()) {\n\t\t//\tif (v == 3) puts(\"f1\");\n\t\t\tif (ng_cnt > 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tng_cnt++;\n\t\t\tval = a;\n\t\t} else {\n\t\t\t//if (v == 3) puts(\"f2\");\t\t\t\n\t\t\t--it;\n\t\t\tss.erase(it);\n\t\t}\n\t}\n\n\t//ng_cnt <= 1, ss.size() <= 1\n\n\tif (p == -1) {\n\t\tif (sz & 1) {\n\t\t//\tcout << ng_cnt << \" \" << ss.size() << endl;\n\t\t\tif (ng_cnt + ss.size() > 1) {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tif (ng_cnt || ss.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ss.size() && ng_cnt) {\n\t\treturn min(*ss.begin(), val);\n\t} else if (ng_cnt) {\n\t\treturn val;\n\t} else if (ss.size()) {\n\t\treturn *ss.begin();\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nbool ok(int x)\n{\n\tint t = dfs(0, -1, x);\n\t//cout << t << endl;\n\treturn (t != -1);\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tpre(0, -1);\n\n\tint lo = 0, hi = N;\n\t//ok(2);\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tcout << num << \" \" << hi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int maxn=100005;\nvector<int>E[maxn];\nint n,deg[maxn],dp[maxn],lim;\nbool dfs(int u,int fa){\n\tbool res=1;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)res&=dfs(v,u);\n\t}\n\tstatic int c[maxn],tot;\n\ttot=0;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)c[++tot]=dp[v];\n\t}\n\tif(deg[u]&1)c[++tot]=0;\n\tsort(c+1,c+1+tot);\n\tc[tot+1]=n;\n\tint l=1,h=tot;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1,curl=1,curr=tot,Max=0;\n\t\tREP(i,1,tot>>1){\n\t\t\tif(curl==mid)curl++;\n\t\t\tif(curr==mid)curr--;\n\t\t\tchkmax(Max,c[curl]+c[curr]);\n\t\t\tcurl++,curr--;\n\t\t}\n\t\tif(Max<=lim)h=mid-1;\n\t\telse l=mid+1;\n\t}\n\tres&=(l<=tot);\n\tdp[u]=c[l]+1;\n\treturn res=1;\n}\nbool check(int x){\n\tlim=x;\n\treturn dfs(1,0)&(dp[1]-1<=lim);\n}\nint main(){\n\tint u,v;\n\tn=read();\n\tREP(i,1,n-1){\n\t\tu=read(),v=read();\n\t\tE[u].pb(v),deg[u]++;\n\t\tE[v].pb(u),deg[v]++;\n\t}\n\tint ans=0;\n\tREP(i,1,n)ans+=(deg[i]&1);\n\twrite(ans>>1,' ');\n\tint l=1,h=n-1;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1;\n\t\tif(check(mid))h=mid-1;\n\t\telse l=mid+1;\n\t}write(l,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(l==son) ++l;\n\t\tif(r==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tret&=treeDP(v,u);\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(!ret) return false;\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<int> g[100000];\nint c[100000];\nbool used[100000];\nbool nuee;\nint d;\nvoid dfs(int x){\n  if(nuee) return;\n  used[x]=1;\n  vector<int> v;\n  for(auto y:g[x]){\n    if(used[y]) continue;\n    dfs(y);\n    if(nuee) return;\n    v.push_back(c[y]+1);\n  }\n  if(v.empty()) return;\n  if(v.size()==1){\n    if(v[0]>d) nuee=1;\n    c[x]=v[0];\n    return;\n  }\n  if(v.size()%2==0) v.push_back(0);\n  sort(v.begin(), v.end());\n  int m=v.size();\n  bool ok0=0;\n  for(int i=0; i<m; i++){\n    int c1=0, c2=m-1;\n    bool ok=1;\n    for(int j=0; j<m/2; j++){\n      if(c1==i) c1++;\n      if(c2==i) c2--;\n      if(v[c1]+v[c2]>d){\n        ok=0;\n        break;\n      }\n      c1++; c2--;\n    }\n    if(ok){\n      ok0=1;\n      c[x]=v[i];\n      break;\n    }\n  }\n  if(!ok0){\n    nuee=1;\n  }\n}\n\nint main()\n{\n\tint n; cin>>n;\n  for(int i=0; i<n-1; i++){\n    int a, b;\n    cin>>a>>b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  int ct=0;\n  for(int i=0; i<n; i++){\n    if(g[i].size()%2) ct++;\n  }\n  cout<<ct/2<<\" \";\n  int d1=1, d2=2e5;\n  while(d1!=d2){\n    d=(d1+d2)/2;\n    fill(c, c+n, 0);\n    fill(used, used+n, 0);\n    nuee=0;\n    dfs(0);\n    if(nuee) d1=d+1;\n    else d2=d;\n  }\n\tcout<<d1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri) return false;\n        }\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    rep(i,n) dp[i] = 0;\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    vector<int> dp(n);\n    function<void(int, int)> Dfs = [&](int x, int p) {\n        int ch = 0;\n        for (int u : g[x]) {\n            if (u == p) continue;\n            Dfs(u, x);\n            dp[x] += dp[u];\n            ch += 1;\n        }\n        dp[x] -= ch / 2;\n        if (ch % 2 == 0) dp[x]++;\n    };\n\n    Dfs(0, -1);\n    int A = dp[0], B = n + 1;\n\n    auto Check = [&](int v) {\n        constexpr int kInf = 1'000'000'000;\n        function<void(int, int)> Dfs = [&](int x, int p) {\n            multiset<int> s;\n            dp[x] = kInf;\n            for (int u : g[x]) {\n                if (u == p) continue;\n                Dfs(u, x);\n                if (dp[u] > v) return;\n                s.insert(dp[u]);\n            }\n            if (s.size() & 1) {\n                int z = -1;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        if (z != -1) return;\n                        z = r;\n                    } else {\n                        s.erase(prev(it));\n                    }\n                }\n                dp[x] = z;\n                if (x != 0) dp[x]++;\n                if (dp[x] > v) {\n                    dp[x] = kInf;\n                    return;\n                }\n            } else {\n                auto f = s;\n                bool ok = true;\n                while (!s.empty()) {\n                    int r = *s.rbegin();\n                    s.erase(s.find(r));\n                    auto it = s.upper_bound(v - r); \n                    if (it == s.begin()) {\n                        ok = false;\n                        break;\n                    }\n                    s.erase(prev(it));\n                }\n                if (ok) {\n                    dp[x] = x == 0 ? 0 : 1;\n                    // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n                    return;\n                }\n                auto it = f.upper_bound(x == 0 ? v : v - 1);\n                if (it == f.begin()) return;\n                f.erase(prev(it));\n                int z = -1;\n                while (!f.empty()) {\n                    int r = *f.rbegin();\n                    f.erase(f.find(r));\n                    auto it = f.upper_bound(v - r); \n                    if (it == f.begin()) {\n                        if (z != -1) {\n                            dp[x] = kInf;\n                            return;\n                        }\n                        z = r;\n                    } else {\n                        f.erase(prev(it));\n                    }\n                }\n                dp[x] = *prev(it);\n                if (x != 0) dp[x]++;\n            }\n            // printf(\"dp[%d] = %d\\n\", x + 1, dp[x]);\n        };\n        // printf(\"Check v = %d\\n\", v);\n        Dfs(0, -1);\n        return dp[0] != kInf;\n    };\n\n    for (int d = 20; d >= 0; --d) {\n        if (B - (1 << d) <= 0) continue;\n        if (Check(B - (1 << d))) B -= (1 << d);\n    }\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\nconst int N = 100050;\nint pre[N], nxt[N * 2], to[N * 2], cnt;\ninline void addEdge(int x, int y) {\n  nxt[cnt] = pre[x];\n  to[pre[x] = cnt++] = y;\n  nxt[cnt] = pre[y];\n  to[pre[y] = cnt++] = x;\n}\nint tmp[N * 7];\nint d[N];\nint B;\nint vis[N], time;\nbool check(int x, int fa, int *tmp, int &pp) {\n  int ss = d[x] + 1;\n  int l = 0;\n  if (d[x] & 1) tmp[l++] = 0;\n  for (int i = pre[x]; ~i; i = nxt[i]) if (to[i] != fa) {\n    int p = 0;\n    if (!check(to[i], x, tmp + ss, p)) return false;\n    if (p) tmp[l++] = p;\n  }\n  std::sort(tmp, tmp + l);\n  if (tmp[l - 1] > B) return false;\n  int i = l - 1, j = l - 2;\n  ++time;\n  int tt = 0;\n  while (~i) {\n    if (tt == l) return true;\n    if (tt == l - 1) {\n      pp = tmp[i] + 1;\n      return true;\n    }\n    while (j > 0 && tmp[j] + tmp[i] > B) --j;\n    if (tmp[j] + tmp[i] > B) return false;\n    vis[i] = vis[j] = time;\n    tt += 2;\n    while (i > 0 && vis[i] == time) --i;\n  }\n  return false;\n}\nint main() {\n  int n, x, y;\n  scanf(\"%d\", &n);\n  memset(pre, -1, sizeof pre);\n  for (int i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addEdge(x, y);\n    ++d[x]; ++d[y];\n  }\n  int l = 0;\n  for (int i = 1; i <= n; ++i)\n    l += (d[i] & 1);\n  l /= 2;\n  printf(\"%d\\n\", l);\n  int ll = 1, rr = n * 2, xxx;\n  while (ll < rr) {\n    int mid = (ll + rr) / 2;\n    if (B = mid, check(1, 0, tmp, xxx)) rr = mid;\n    else ll = mid + 1;\n  }\n  printf(\"%d\\n\", ll);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n    for(int i=1;i<=n;++i){\n        if(V[i].size()%2) ++all;\n    }\n    all=all/2;\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    assert(ans==all);\n    ans=all;\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\tif (len[j]<=mid)\n\t\t\t{\n\t\t\t\ts.erase(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tt--;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1) dis[x]=len[*s.begin()];\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "10\n1 2\n2 3\n3 4\n2 5\n6 5\n6 7\n7 8\n5 9\n10 5\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check_even(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint solve_even(vi & legs, int mx){\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check_even(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check_even(legs, lo, mx)) return legs[lo];\n    else if(check_even(legs, hi, mx)) return hi;\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nint solve_odd(vi & legs, int mx){\n    int l = 0;\n    int r = sz(legs) - 1;\n    bool good = true;\n    while(l<=r){\n        if(legs[l]+legs[r]>mx) {\n            good = false; break;\n        }\n        l++; r--;\n    }\n    if(good) return 0;\n    int id = -1;\n    f0r(i, sz(legs)) if(legs[i]<mx) id = i;\n    if(id == -1){\n        ok = false;\n        return legs.back();\n    }\n    legs.erase(legs.begin()+id);\n    return solve_even(legs, mx);\n}\nint root;\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src]) == 1) return 0;\n    vi legs;\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        if(sz(adj[src])%2 == 0){\n            int l = 0;\n            int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx){\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        else{\n            if(sz(adj[src]) == 1){\n                if(legs.back()>mx) ok = false;\n                return legs.back();\n            }\n            int id = -1;\n            f0r(i, sz(legs)) if(legs[i]<mx) id = i;\n            if(id == -1){\n                ok = false;\n                return legs.back();\n            }\n            legs.erase(legs.begin()+id);\n            int l = 0; int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx) {\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        return legs.back();\n\n    }\n    if(sz(adj[src])%2 == 0) return solve_even(legs, mx);\n    else return solve_odd(legs, mx);\n}\nint main(){\n    setIO(\"\");\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    int lo = 1;\n    int hi = MAX;\n    f0r(i, n) if(sz(adj[i])>1) root = i;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(root, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(root, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nstd::vector<int> vec, adj[100005]; \nint dp[100005]; \nbool dfs(int u, int lim, int fa = -1)\n{\n\tfor (int v : adj[u])\n\t{\n\t\tif (v != fa && !dfs(v, lim, u))\n\t\t\treturn false; \n\t}\n\tvec.clear(); \n\tfor (int v : adj[u])\n\t{\n\t\tif (v != fa)\n\t\t\tvec.pb(dp[v] + 1); \n\t}\n\tif (vec.size() & 1 ^ (fa != -1))\n\t\tvec.pb(0); \n\tstd::sort(vec.begin(), vec.end()); \n\tif (~fa)\n\t{\n\t\tint l = 0, r = vec.size() - 2; \n\t\twhile (l < r)\n\t\t{\n\t\t\tif (vec[l++] + vec[r--] > lim)\n\t\t\t\treturn false; \n\t\t}\n\t\tint idx = vec.size() - 1; \n\t\twhile (idx && vec[idx] + vec[vec.size() - 1 - idx + (idx << 1 < vec.size())] <= lim)\n\t\t\tidx--; \n\t\tdp[u] = vec[idx]; \n\t}\n\telse\n\t{\n\t\tint l = 0, r = vec.size() - 1; \n\t\twhile (l < r)\n\t\t{\n\t\t\tif (vec[l++] + vec[r--] > lim)\n\t\t\t\treturn false; \n\t\t}\n\t}\n\treturn true; \n}\nint main()\n{\n\t// freopen(\"ARC088-F.in\", \"r\", stdin); \n\tint n; \n\tscanf(\"%d\", &n); \n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; \n\t\tscanf(\"%d%d\", &u, &v); \n\t\tadj[--u].pb(--v);\n\t\tadj[v].pb(u); \n\t}\n\tint a = 0, l = 0, r = n - 1, ans; \n\tfor (int i = 0; i < n; i++)\n\t\ta += adj[i].size() & 1;\n\twhile (l <= r)\n\t{\n\t\tint m = l + r >> 1; \n\t\tif (dfs(0, m))\n\t\t{\n\t\t\tans = m; \n\t\t\tr = m - 1; \n\t\t}\n\t\telse\n\t\t\tl = m + 1;\n\t}\n\tprintf(\"%d %d\\n\", a + 1 >> 1, ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n;\nvvi g;\nvi dp;\n\nbool ff(vi& a,int I,int L){\n\tint N=a.size();\n\tbool B=1;\n\tfor(int i=0;i<(N-1)/2;i++) if(a[(i<I?i:i+1)]+a[(N-i-1>I?N-i-1:N-i-2)]>L) B=0;\n\treturn B;\n}\n\nbool f(int v,int p,int L){\n\tbool B=1;\n\tvi a;\n\tfor(auto u:g[v]) if(u!=p){\n\t\tB&=f(u,v,L)&&dp[u]!=L;\n\t\ta.push_back(dp[u]+1);\n\t}\n\tif(!B) return 0;\n\tsort(a.begin(),a.end());\n\tint N=a.size();\n\tif(N%2==0){\n\t\tfor(int i=0;i<N/2;i++) if(a[i]+a[N-i-1]>L) B=0;\n\t\tif(B) return 1;\n\t\ta.pop_back();\n\t\tN--;\n\t}\n\tint l=-1,r=N;\n\twhile(r-l>1){\n\t\tint m=(l+r)/2;\n\t\tif(ff(a,m,L)) r=m;\n\t\telse l=m;\n\t}\n\tif(r==N) return 0;\n\tdp[v]=a[r];\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint A=0,v,l=0,r=n-1;\n\tfor(int i=0;i<n;i++){\n\t\tint S=g[i].size();\n\t\tA+=S%2;\n\t\tif(S==1) v=i;\n\t}\n\tA/=2;\n\twhile(r-l>1){\n\t\tdp=vi(n);\n\t\tint m=(l+r)/2;\n\t\tif(f(v,-1,m)) r=m;\n\t\telse l=m;\n\t}\n\tdp=vi(n);\n\tcout<<A<<' '<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  {\n    Int A=0;\n    for(Int i=0;i<n;i++)\n      A+=G[i].size()&1;\n    cout<<A/2<<\" \";\n  }\n\n  auto check=\n    [&](Int x)->Int{\n      Int ng=0;\n      function<Int(Int, Int)> dfs=\n        [&](Int v,Int p){\n          vector<Int> vs;\n          for(Int u:G[v]){\n            if(u==p) continue;            \n            vs.emplace_back(dfs(u,v)+1);\n          }\n          \n          if(G[v].size()&1)\n            vs.emplace_back(0);\n          sort(vs.begin(),vs.end());\n          \n          Int k=vs.size();\n          if(p<0){\n            assert(~k&1);\n            for(Int i=0;i<k/2;i++)\n              if(vs[i]+vs[k-(i+1)]>x) return ng=1;\n            return 0;\n          }\n          \n          assert(k&1);\n          \n          auto check2=\n            [&](Int y)->Int{\n              vector<Int> us;\n              for(Int i=0;i<k;i++)\n                if(i!=y) us.emplace_back(vs[i]);\n              Int l=us.size();\n              assert(~l&1);\n              for(Int i=0;i<l/2;i++)\n                if(us[i]+us[l-(i+1)]>x) return 0;\n              return 1;\n            };\n          \n          Int l=-1,r=k;\n          while(l+1<r){\n            Int m=(l+r)>>1;\n            if(check2(m)) r=m;\n            else l=m;\n          }\n          if(r==k) return ng=1;\n          return vs[r];\n        };\n      \n      dfs(0,-1);\n      return !ng;\n    };\n    \n  Int l=0,r=n;\n  while(l+1<r){\n    Int m=(l+r)>>1;\n    if(check(m)) r=m;\n    else l=m;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops,Ofast\")\n#pragma GCC target(\"avx,sse,sse2,ssse3,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<18, mod = 1e9 + 7;\nint n;\nvector<int> g[maxn];\nint fi[maxn], se[maxn], B = 0;\nvoid pfs(int v, int p) {\n\tfi[v] = se[v] = 1<<30;\n\tfor(auto &i : g[v]) if(i != p) {\n\t\tpfs(i, v);\n\t\t//cout << v << \" -> \" << i << '\\n';\n\t\tint t = 1+((g[i].size()&1)? 0 : fi[i]);\n\t\tif(t < fi[v]) se[v] = fi[v], fi[v] = t;\n\t\telse if(t < se[v]) se[v] = t;\n\t}\n\t//cout << v << \" \" << fi[v] << \" \" << se[v] << '\\n';\n}\nvoid dfs(int v, int p, int par) {\n\t//cout << v << \" \" << fi[v] << \" \" << se[v] << \" \" << par << '\\n';\n\tB = max(B, min(fi[v], par));\n\tfor(auto &i : g[v]) if(i != p) {\n\t\tdfs(i, v, 1 +  min(par, (fi[i]+1 == fi[v] || (g[i].size()&1) ? se[v] : fi[v])));\n\t}\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tint A = 0;\n\tfor(int i = 1; i <= n; i++) A += (g[i].size()&1);\n\tA /= 2;\n\tif(n == 2) B = 1;\n\telse {\n\t\tint r=  1;\n\t\twhile(g[r].size()&1) r++;\n\t\tpfs(r, r);\n\t\tdfs(r, r, 1<<30);\n\t}\n\tcout << A << \" \" << B;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nint a = 0;\n\nvoid dfsa(int now, int past){\n    int tmp = 0;\n    for (int next : e[now]){\n        if (next == past) continue;\n        tmp++;\n        dfsa(next, now);\n    }\n    a += tmp / 2;\n    if (now == 0 && tmp % 2) a++;\n}\n\nbool good;\nint c;\n\nint dfs(int now, int past){\n    if (!good) return 0;\n    VI a;\n    for (int next : e[now]){\n        if (next == past) continue;\n        a.push_back(dfs(next, now) + 1);\n    }\n    sort(ALL(a));\n    int n = a.size();\n    REP(i,n) if (a[i] > c) good = false;\n    if (n % 2 == 0){\n        int ret = 0;\n        REP(i,n/2){\n            if (a[i] + a[n-1-i] > c){\n                if (ret == 0){\n                    ret = a[i];\n                }else{\n                    good = false;\n                }\n            }\n            // if (a[i] + a[n-1-i] > c) good = false;\n        }\n        // cout << \"e\" << now << good << endl;\n        return ret;\n    }\n    if (a[n-1] > c) good = false;\n    REP(i,n/2){\n        if (a[i] + a[n-2-i] > c) good = false;\n    }\n    int ok = n-1, ng = -1;\n    while (ok - ng > 1){\n        int mi = (ok + ng) / 2;\n        bool f = true;\n        REP(i,n/2){\n            int x = i;\n            if (x >= mi) x++;\n            int y = n - 1 - i;\n            if (y <= mi) y--;\n            if (a[x] + a[y] > c) f = false;\n        }\n        if (f) ok = mi;\n        else ng = mi;\n    }\n    // cout << now << \" \" << a[ok] << endl;\n    return a[ok];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--;b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n\n    dfsa(0, -1);\n\n    int ok = n, ng = 0;\n    while (ok - ng > 1){\n        c = (ok + ng) / 2;\n        // cout << c << endl;\n        good = true;\n        dfs(0, -1);\n        if (good) ok = c;\n        else ng = c;\n    }\n\n\n    cout << a << \" \" << ok << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int)x.size()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n//11:48\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint DP[N][2], n, x;\npii dp[N];\nvi G[N];\n\nvoid DFS(int v, int p = 0){\n\tif (G[v].size() == 1 & v != 1){\n\t\tDP[v][0] = 1;\n\t\tDP[v][1] = 0;\n\t\treturn;\n\t}\n\tint res = 0;\n\tint ted = 0;\n\tfor (auto u:G[v]){\n\t\tif (u == p) continue;\n\t\tted++;\n\t\tDFS(u, v);\n\t\tres += min(DP[u][0], DP[u][1]);\n\t}\n\tDP[v][0] = res + (ted / 2 + (ted % 2));\n\tted--;\n//\tcout << res << ' ' << ted << '\\n';\n\t\n\tDP[v][1] = res + (ted / 2 + (ted % 2));\n//\tcout << v << ' ' << DP[v][0] << ' ' << DP[v][1] << '\\n';\n}\n\nint Best(vi A){\n\tint pnt = A.size() - 1;\n\tint res = 0;\n\tfor (int i = 0; i < A.size() / 2; i++){\n\t\tif (pnt <= i) break;\n\t\twhile (pnt > i && A[pnt] + A[i] > x) pnt--;\n\t\tif (pnt == i) break;\n\t\tres++;\n\t}\n\treturn res;\n}\n\nvoid DFS2(int v, int p = 0){\n\tif (G[v].size() == 1 && v != 1){\n\t\tdp[v] = {0, 0};\n\t\treturn;\n\t}\n\tint sm = 0;\n\tvi num;\n\tfor (auto u:G[v]){\n\t\tif (u == p) continue;\n\t\tDFS2(u, v);\n\t\tsm += dp[u].F;\n\t\tif (dp[u].S + 1 == x)sm++;\n\t\telse num.pb(dp[u].S + 1);\n\t}\n\tif (SZ(num) == 0){\n\t\tdp[v] = {sm, 0};\n\t\treturn;\n\t}\n\tsort(all(num));\n\tint B = Best(num);\n\tdp[v] = {B + SZ(num) - 2 * B + sm, 0};\n//\tcout << v << ' ' << B << endl;\n\tvi GG;\n\tfor (int i = 0; i < (int)num.size() - 1; i++){\n\t\tGG.pb(num[i]);\n\t}\n\tB = Best(GG);\n\tif (dp[v].F == sm + B + SZ(num) - 2 * B - 1){\t\n//\t\tcout << v << ' ' << dp[v].F << ' ' << dp[v].S << '\\n';\n\t\treturn;\n\t}\n\tint l = -1, r = SZ(num) - 1;\n\tdp[v].F = sm + B + SZ(num) - 2 * B - 1;\n\twhile (r - l > 1){\n\t\tint md = (l + r) >> 1;\n\t\tGG.clear();\n\t\tfor (int i = 0; i < SZ(num); i++){\n\t\t\tif (i != md) GG.pb(num[i]);\n\t\t}\n\t\tint xx = Best(GG);\n\t\tif (dp[v].F == xx + sm + SZ(num) - 2 * B - 1) r = md;\n\t\telse l = md;\n\t}\n\tdp[v].S = num[r];\n\tif (dp[v].S == x) dp[v] = {dp[v].F + 1, 0};\t\n//\tcout << v << ' ' << dp[v].F << ' ' << dp[v].S << '\\n';\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tG[v].pb(u), G[u].pb(v);\n\t}\n\tmemset(DP, 31, sizeof DP);\n\tDFS(1);\n\tcout << DP[1][0] << ' ';\n\tint l = 0, r = n;\n\twhile (r - l > 1){\n\t\tx = (l + r) >> 1;\n\t\tDFS2(1);\n\t\tif ((dp[1].F + (dp[1].S != 0) <= DP[1][0])) r = x;\n\t\telse l = x;\n\t}\n//\tx = 3;\n//\tDFS2(1);\n\tcout << r;\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,res,A,B,du[N],dp[N],a[N],pre[N],nex[N];\nbool vis[N];\nvi g[N];\n\ninline void rem(int x){\n\tvis[x]=1;\n\tint l=pre[x],r=nex[x];\n\tif(r) pre[r]=l;nex[l]=r;\n}\ninline int solve(int n){\n\tint tag=0;\n\tfor(int i=0;i<n;i++)\n\t\tnex[i]=i+1,pre[i+1]=i;\n\tnex[n]=pre[0]=0;\n\tfor(int i=0;i<=n;i++) vis[i]=0;\n\tfor(int i=n;i;i--){\n\t\tif(vis[i]) continue;\n\t\twhile(nex[tag]&&a[nex[tag]]+a[i]+1<=B) tag=nex[tag];\n\t\tif(tag==i) tag=pre[tag];\n\t\tif(!tag) return a[i];\n\t\trem(i);rem(tag);\n\t\tassert(tag<i);\n\t\ttag=pre[tag];\n\t}\n}\n\ninline void dfs(int x,int F=0){\n\tint isok=0;\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tdfs(y,x);isok=1;\n\t}\n\tif(!isok){dp[x]=1;return;}\n\tm=0;\n\tfor(int y:g[x])\n\t\tif(y!=F) a[++m]=dp[y];\n\tint ret=0;\n\tfor(int l=1,r=m;l<r;r--)\n\t\tif(a[l]+a[r]+1<=B) l++,ret++;\n\tif(ret*2==m){res+=ret;dp[x]=1;return;}\n\tres+=m-ret-1;\n\tint p=solve(ret*2+1);\n\tif(p+1==B) res++,dp[x]=1; else dp[x]=p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;dfs(1);if(dp[1]!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n \nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N], dem = 1, idem;\nbool kt;\nvector < int > adj[N];\n \nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos > 0) data.erase(data.begin() + pos);\n\tint l = 0, r = data.size() - 1; \n\twhile (l < r) if (data[l++].fi + data[r--].fi > lim) return false; \n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nbool dfs(int u, int pa, int lim){ \n\tvector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if( v == pa) continue; \n\t\tif(! dfs(v, u, lim)) return false;\n\t\tdata.pb(ii(++ h[v], v));\n\t}\n\tif(data.size() == 0) return true;\n\tsort(data.begin(), data.end());\n\t//if(u == 1)\n\t//\tFor(i, 0, (int) data.size() - 1) cout << data[i].fi << ' ' << data[i].se << endl, cout << idem << endl;\n\t\n\twhile(data[data.size() - 1].fi == lim) data.pop_back(),idem ++;\n\tint len = data.size(), Max = 0;  idem += len/2;\n\tif(idem > dem) return false; \n\tif(!len) return true;\n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return false;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) return false;\n\t\th[u] = h[res];\n\t\tif(u == 1 && (h[u] > lim || idem == dem)) return false; \n\t}\n\treturn true;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tFor(i, 1, n)  dem += (adj[i].size() - 1) / 2;\n\t//cout << \"\\n\";\n\t//cout << dfs(1, 1, 3) << endl;\n\t\n\tint l = 1, r = n, ans;\n\twhile(l <= r){\n\t\tmemset(h, 0, sizeof h); idem = 0;\n\t\tint mid = (l + r)/2;\n\t\tif(dfs(1, 1, mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem << ' ' << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans_a, ans_b;\n\t\n\tvoid write () {\n\t\tcout << ans_a << ' ' << ans_b << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint mxl;\n\t\t\n\t\tint rec (int v, int pr) {\n\t\t\tvi q;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint val = rec(to, v);\n\t\t\t\tif (val == -1 || val + 1 > mxl) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tq.pb(val + 1);\n\t\t\t}\n\t\t\tsort(all(q), greater<int>());\n\t\t\t\n\t\t\tif (!sz(q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint val0 = q[0];\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tq[0] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (j < sz(q) && (j <= i || q[j] == -1 || q[i] + q[j] > mxl)) {\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tif (j < sz(q)) {\n\t\t\t\t\tq[i] = q[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvi qq;\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tqq.pb(val0);\n\t\t\t}\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] != -1) {\n\t\t\t\t\tqq.pb(q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sz(qq) == 2 && qq[0] + qq[1] <= mxl) {\n\t\t\t\tqq.clear();\n\t\t\t}\n\t\t\t\n\t\t\tif (sz(qq) == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (sz(qq) == 1) {\n\t\t\t\treturn qq[0];\n\t\t\t} else if (sz(qq) == 2) {\n\t\t\t\tif (sz(e[v]) & 1) {\n\t\t\t\t\treturn qq[1];\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\n\t\tbool check (int val) {\n\t\t\tmxl = val;\n\t\t\treturn rec(0, -1) != -1;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tans_a = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tif (sz(e[i]) & 1) {\n\t\t\t\t\tans_a++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_a /= 2;\n\t\t\t\n\t\t\tint lb = 0, rb = n - 1;\n\t\t\twhile (lb < rb) {\n\t\t\t\tint md = (lb + rb) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\trb = md;\n\t\t\t\t} else {\n\t\t\t\t\tlb = md + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_b = lb;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nmultiset<int>G[N];\nmultiset<int>::iterator gt,gtt;\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tson++;\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=(son+(u==1))/2;\n}\ninline void dfs_ans(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs_ans(v,u);\n\t\tG[u].insert(dis[v]+1);\n\t\tson++;\n\t}\n\tint res=u==1?son&1:son&1?1:2;\n\t//printf(\"%d %d\\n\",u,res);\n\twhile(!G[u].empty())\n\t{\n\t\tgt=G[u].end();--gt;\n\t\tgtt=G[u].upper_bound(len-*gt);\n\t\tif(gtt==G[u].begin()||SZ(G[u])==1)\n\t\t{\n\t\t\tif(!res)flag=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdis[u]=*gt;\n\t\t\t\tres--;\n\t\t\t\tG[u].erase(gt);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t--gtt;\n\t\tif(gt==gtt)gtt--;\n\t\tG[u].erase(gtt);\n\t\tgt=G[u].end();--gt;\n\t\tG[u].erase(gt);\n\t}\n}\ninline bool check(int x)\n{\n\tFor(i,1,n)\n\t{\n\t\tG[i].clear();\n\t\tdis[i]=0;\n\t}\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\treturn dis[1]<=len&&flag;\n}\nint main()\n{\n\tint x,y;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,avx2,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 1e9 + 7;\nint n, _x;\nvector<int> g[maxn];\nint B = 0, A = 0;\nint get(vector<int> &a, int s) {\n\tint l = 0, r = a.size()-1, mx = 0;\n\tif(l == s) l++;\n\tif(r == s) r--;\n\twhile(l < r) {\n\t\tmx = max(mx, a[l] + a[r]);\n\t\tl++, r--;\n\t\tif(l == s) l++;\n\t\tif(r == s) r--;\n\t}\n\treturn mx;\n}\nint dfs(int v, int p, int h = 0) {\n\tvector<int> ch;\n\tif(g[v].size()&1) ch.pb(h);\n\tfor(auto i : g[v]) if(i != p) {\n\t\tint t = dfs(i, v, h+1);\n\t\tif(t == -1) return -1;\n\t\tif(t) ch.pb(t);\n\t}\n\tsort(all(ch));\n\tif(ch.size()%2 == 0) {\n\t\treturn get(ch, -1)-2*h <= _x ? 0 : -1;\n\t}\n\tp = 0;\n\tfor(int i = 1<<17; i>>=1;)\n\t\tif(p+i < ch.size() && get(ch, p+i)-2*h > _x) p += i;\n\tp += (get(ch, p)-2*h > _x);\n\treturn p >= ch.size() ? -1 : ch[p];\n}\nbool can(int x) {\n\t_x = x;\n\treturn dfs(1, 1) != -1;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].pb(t);\n\t\tg[t].pb(f);\n\t}\n\tfor(int i = 1; i <= n; i++) A += g[i].size()&1; A/=2;\n\tfor(int i = 1<<17; i>>=1;) if(!can(B+i)) B += i;\n\tcout << A << \" \" << B+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\n\nint dfsA(int v,int pre,Graph &g){\n    int sum=0;\n    int res=0;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=pre){\n            sum++;\n            res+=dfsA(g[v][i],v,g);\n        }\n    }\n    if(v==0){\n        return (sum+1)/2+res;\n    }\n    else{\n        return sum/2+res;\n    }\n}\n\nint dfsB(int v,int pre,int bound,Graph &g){\n    vector<int> len;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=pre) len.push_back(dfsB(g[v][i],v,bound,g)+1);\n    }\n    if(len.size()==0) return 0;\n    sort(len.begin(),len.end());\n    if(v!=0){\n        if(len.size()%2==0){\n            bool isbad=false;\n            for(int i=0;i<len.size();i++){\n                isbad|=(len[i]+len[len.size()-1-i]>bound);\n            }\n            if(!isbad) return 0;\n            if(len.back()>bound) return bound+1;\n            len.pop_back();\n        }\n        int lb=-1;\n        int ub=len.size();\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            int l=-1,r=len.size();\n            bool isbad=false;\n            while(true){\n                if(l+1!=mid) l++;\n                else l+=2;\n                if(r-1!=mid) r--;\n                else r-=2;\n                assert(l!=r);\n                if(len.size()<=l) break;\n                isbad|=(len[l]+len[r]>bound);\n            }\n            if(isbad) lb=mid;\n            else ub=mid;\n        }\n        if(ub==len.size()) return bound+1;\n        else return len[ub];\n    }\n    else{\n        if(len.size()%2==1){\n            if(len.back()>bound) return bound+1;\n            len.pop_back();\n        }\n        bool isbad=false;\n        for(int i=0;i<len.size();i++){\n            isbad|=(len[i]+len[len.size()-1-i]>bound);\n        }\n        if(isbad) return bound+1;\n        else return 0;\n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int A=dfsA(0,-1,g);\n    cout<<A<<\" \";\n    int lb=0;\n    int ub=n;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        int res=dfsB(0,-1,mid,g);\n        if(res<=mid){\n            ub=mid;\n        }\n        else{\n            lb=mid;\n        }\n    }\n    cout<<ub<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nvector<int> vi;\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tvi.clear();\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=res[G[v][i]];\n\t\t\tvi.push_back(val.second);\n\t\t}\n\t}\n\tif(vi.size()==0)return res[v]=P(1,1);\n\tsort(vi.begin(),vi.end());\n\tint l=0,r=(int)vi.size()-1;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vi[l]+vi[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP rec=dfs(0,-1,len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll long long\n#define db long double\n#define ii pair<int,int>\n#define vi vector<int>\n#define fi first\n#define se second\n#define sz(a) (int)(a).size()\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define FN(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FEN(i,n) for (int i = 1;i <= (int)(n); ++i)\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repv(i,a,b) for(int i=b-1;i>=a;i--)\n#define SET(A, val) memset(A, val, sizeof(A))\ntypedef tree<int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set ;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the kth largest element.(0-based)\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N=100005;\nvi v[N];\nint root=-1,dp[N],n;\nvi tmp;\nvoid dfs(int u,int val,int par=-1)\n{\n  tmp.clear();\n  dp[u]=0;\n  for(int v1:v[u])\n    {\n      if(v1==par) continue;\n      dfs(v1,val,u);\n    }\n  for(int v1:v[u]) if(v1!=par) tmp.pb(dp[v1]);\n  if(sz(tmp)%2==0) tmp.pb(0);\n  sort(all(tmp));\n  int low=0,high=sz(tmp)-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      int i=0,j=sz(tmp)-1;\n      bool ok=true;\n      while(i<j)\n\t{\n\t  if(i==mid) i++;\n\t  else if(j==mid) j--;\n\t  else if(tmp[i]+tmp[j]>val) { ok=false; break; }\n\t  else i++,j--;\n\t}\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  int i=0,j=sz(tmp)-1;\n  bool ok=true;\n  while(i<j)\n    {\n      if(i==low) i++;\n      else if(j==low) j--;\n      else if(tmp[i]+tmp[j]>val) { ok=false; break; }\n      else i++,j--;\n    }\n  if(!ok) dp[u]=val+100;\n  else dp[u]=tmp[low]+1;\n}\nint main()\n{\n  std::ios::sync_with_stdio(false);\n  cin.tie(NULL) ; cout.tie(NULL) ;\n  int x,y;\n  cin>>n;\n  rep(i,1,n) cin>>x>>y,v[x].pb(y),v[y].pb(x);\n  rep(i,1,n+1) if(sz(v[i])==1) root=i;\n  assert(root!=-1);\n  int cnt=0;\n  rep(i,1,n+1) cnt+=(sz(v[i])&1);\n  int low=0,high=n-1;\n  while(low<high)\n    {\n      int mid=(low+high)>>1;\n      dfs(root,mid);\n      bool ok=true;\n      rep(i,1,n+1) ok&=(dp[i]<=mid+1);\n      if(ok) high=mid;\n      else low=mid+1;\n    }\n  cout<<cnt/2<<\" \"<<low<<endl;\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X;\nvector<vector<int> > adj;\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n    }\n\n    if(st.size() % 2) {\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return -1;\n            it2--;\n            st.erase(it2);\n        }\n        return *st.begin();\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int a = 0;\n    for(int i = 0; i < N; i++) {\n        a += (adj[i].size() + 1) / 2 - 1;\n    }\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", 1 + a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        //assert(tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0, resb = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tresb += g[i].size()%2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tresa--; resb /= 2;\n\tif(resa!=resb) return -1;\n\tint lb = -1, ub = n;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resb<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, int node) {\n\tint box = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tbox += Search(edge, dis, i);\n\t}\n\tM += box / 2;\n\tif (!node&&box)M++;\n\treturn 1;\n}\n\nint Search(vector<vector<int>>&edge, vector<int>&dis, vector<multiset<int>>&num, int node, int lim) {\n\t//cout << node << endl;\n\tfor (auto i : edge[node]) {\n\t\tif (dis[i] < dis[node])continue;\n\t\tnum[node].emplace(Search(edge, dis, num, i,lim) + 1);\n\t}\n\t//cout <<\"node \"<< node << endl;\n\t//for (auto i : num[node]) {\n\t//\tcout << i << \" \";\n\t//}\n\t//cout << endl;\n\twhile (num[node].size() > 1) {\n\t\tint b = *prev(num[node].end());\n\t\tnum[node].erase(prev(num[node].end()));\n\t\tauto it = num[node].upper_bound(lim - b);\n\t\tif (it == num[node].begin() && num[node].size() % 2 == 1) {\n\t\t\tif (b > lim)K = 0;\n\t\t}\n\t\telse if (it == num[node].begin()) {\n\t\t\tK = 0;\n\t\t\tnum[node].erase(num[node].begin());\n\t\t}\n\t\telse {\n\t\t\tnum[node].erase(prev(it));\n\t\t}\n\t}\n\tif (!node&&num[node].size() && *num[node].begin() > lim)K = 0;\n\t//cout << node << \" \" << num[node].size() << endl;\n\tif (num[node].empty())return 0;\n\telse return *num[node].begin();\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>dis(N,MOD);\n\tCalculate_Depth(edge, dis, 0);\n\tSearch(edge, dis, 0);\n\tL = 0, R = N;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L) / 2;\n\t//\tcout << L << \" \" << R << \" \" << mid << endl;\n\t\tvector<multiset<int>>num(N);\n\t\tK = 1;\n\t\tSearch(edge, dis, num, 0,mid);\n\t\tif (K)R = mid;\n\t\telse L = mid;\n\t}\n\tcout << M << \" \" << R << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\nconst int INF = TEN(9);\n\nV<int> g[maxn];\nint r;\n\nint dfs(int v, int p, int l) {\n\tV<int> vec;\n\tfor (int to : g[v]) if (to != p) {\n\t\tint res = dfs(to, v, l);\n\t\tif (res == -1 || res > l) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(res);\n\t}\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tif (sz % 2 == 0) {\n\t\t{\n\t\t\t//all\n\t\t\tint nl = 0, nr = sz - 1;\n\t\t\tbool f = 1;\n\t\t\trep(i, sz / 2) {\n\t\t\t\tif (vec[nl] + vec[nr] > l) {\n\t\t\t\t\tf = 0;\n\t\t\t\t}\n\t\t\t\t++nl; --nr;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tvec.pop_back();\n\t\t--sz;\t\t\n\t}\n\n\t//sz : odd\n\n\tauto valid = [&](int p) {\n\t\tint nl = 0, nr = sz - 1;\n\t\tbool f = 1;\n\n\t\trep(i, sz / 2) {\n\t\t\tif (nl == p) ++nl;\n\t\t\tif (nr == p) --nr;\n\t\t\tif (vec[nl] + vec[nr] > l) {\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t\t++nl; --nr;\n\t\t}\n\t\treturn f;\n\t};\n\n\tint lo = 0, hi = sz - 1;\n\tif (valid(lo)) {\n\t\thi = 0;\n\t}\n\tif (!valid(hi)) {\n\t\treturn -1;\n\t}\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (valid(m)) hi = m;\n\t\telse lo = m;\n\t}\n\treturn vec[hi] + 1;\n}\n\nbool ok(int l) {\n\tint res = dfs(r, -1, l);\n\treturn (res != -1);\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\n\trep(i, N) if (g[i].size() == 1) {\n\t\tr = i;\n\t\tbreak;\n\t}\n\n\tint A = 0;\n\trep(i, N) if (g[i].size() % 2 == 1) ++A;\n\n\tint lo = 0, hi = N;\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", A / 2, hi);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> G[100100];\nint N,Y,U,A;\n\nint dfs(int x, int l, int m)\n{\n\tvector<int> u;\n\tfor (auto &y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x,m)+1);\n\t}\n\tsort(u.begin(),u.end());\n\tint ret = 0;\n\tif (u.size() % 2 == 0){\n\t\tint y = 1;\n\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t}\n\t\tif (!y){\n\t\t\tif (u.back() <= m) u.pop_back(), U++;\n\t\t\telse Y = 0;\n\t\t}\n\t\telse U += u.size() / 2;\n\t}\n\tif (u.size() % 2){\n\t\tint l = 0, r = u.size()-1, a = u.size();\n\t\twhile (l <= r){\n\t\t\tint mm = (l + r) / 2;\n\t\t\tint y = 1;\n\t\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\t\tif (i == mm) i++;\n\t\t\t\tif (j == mm) j--;\n\t\t\t\tif (i >= j) break;\n\t\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t\t}\n\t\t\tif (u[mm] > m) y = 0;\n\t\t\tif (y){\n\t\t\t\ta = mm;\n\t\t\t\tr = mm - 1;\n\t\t\t}\n\t\t\telse l = mm + 1;\n\t\t}\n\t\tif (a == u.size()) Y = 0;\n\t\telse ret = u[a], U += u.size() / 2;\n\t}\n\treturn ret;\n}\n\nint chk(int m)\n{\n\tY = 1;\n\tU = 0;\n\tint l = dfs(1,0,m);\n\tif (l > m) Y = 0;\n\tif (l > 0) U++;\n\tif (U != A) Y = 0;\n\treturn Y;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\tint a = 0;\n\tfor (int i=1;i<=N;i++) a += G[i].size() % 2;\n\ta /= 2;\n\tA = a;\n\n\tint l = 2, r = N, b = N;\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (chk(m)){\n\t\t\tb = m;\n\t\t\tr = m - 1;\n\t\t}\n\t\telse l = m + 1;\n\t}\n\n\tprintf (\"%d %d\\n\",a,b);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n       \n\n        }\n\n    dp[n]=X[ind].first+1;\n\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n\n\n    int low=0;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint B, r;\nint a[100001];\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; i >= 0 && j < v.size(); j++) if (v[i] + v[j] <= B) i--;\n\t\tif (i >= 0) return v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\tB = n;\n\tif (f(1, 1)) r++;\n\ttr = r;\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tif (f(1, 1)) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\n// (個数, 最大値, 伸びてるやつ)\ntri dp[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    vp hoge;\n    each(v, G[u]){\n        if(v != p){\n            dfs(v, u);\n            hoge.pb(P(dp[v].th, v));\n        }\n    }\n    sort(all(hoge));\n    int cnt = len(hoge), mx = 0, res = 0;\n    // vector<P> sm1(cnt/2+1), sm2(cnt/2+1), sm3(cnt/2+1);\n    // srep(i,1,cnt/2+1){\n    //     sm1[i] = sm1[i-1];\n    //     sm1[i].fi += dp[hoge[i].se].fi+dp[hoge[cnt-i].se].fi+1;\n    //     cmx(sm1[i].se, max({hoge[i].fi+1+hoge[cnt-i].fi+1, dp[hoge[i].se].se, dp[hoge[cnt-i].se].se}));\n    // }\n    // rep(i,cnt/2){\n    //     sm2[i+1] = sm2[i];\n    //     sm2[i+1].fi += dp[hoge[i].se].fi+dp[hoge[cnt-i-1].se].fi+1;\n    //     cmx(sm2[i+1].se, max({hoge[i].fi+1+hoge[cnt-i-1].fi+1, dp[hoge[i].se].se, dp[hoge[cnt-i-1].se].se}));\n    // }\n    // rep(i,cnt/2){\n    //     sm3[i+1] = sm3[i];\n    //     sm3[i+1].fi += dp[hoge[i].se].fi+dp[hoge[cnt-i-2].se].fi+1;\n    //     cmx(sm3[i+1].se, max({hoge[i].fi+1+hoge[cnt-i-2].fi+1, dp[hoge[i].se].se, dp[hoge[cnt-i-2].se].se}));\n    // }\n    // rep(i,cnt){\n    //\n    // }\n    if(cnt == 1){\n        dp[u] = dp[hoge[0].se];\n        dp[u].th++;\n    }else if(cnt >= 2){\n        if(cnt % 2){\n            // 上げる\n            // rep(i,cnt/2){\n            //     res += dp[hoge[i].se].fi+dp[hoge[cnt-i-1].se].fi+1;\n            //     cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n            //     cmx(mx, dp[hoge[i].se].se);\n            //     cmx(mx, dp[hoge[cnt-i-1].se].se);\n            // }\n            // res += dp[hoge[cnt/2].se].fi;\n            // cmx(mx, dp[hoge[cnt/2].se].se);\n            // dp[u] = (tri){res, mx, hoge[cnt/2].fi+1};\n            srep(i,1,cnt/2+1){\n                res += dp[hoge[i].se].fi+dp[hoge[cnt-i].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n                cmx(mx, dp[hoge[cnt-i].se].se);\n            }\n            res += dp[hoge[0].se].fi;\n            cmx(mx, dp[hoge[0].se].se);\n            dp[u] = (tri){res, mx, hoge[0].fi+1};\n        }else{\n            srep(i,1,cnt/2){\n                res += dp[hoge[i].se].fi+dp[hoge[cnt-i-1].se].fi+1;\n                cmx(mx, hoge[i].fi+1+hoge[cnt-i-1].fi+1);\n                cmx(mx, dp[hoge[i].se].se);\n                cmx(mx, dp[hoge[cnt-i-1].se].se);\n            }\n            // 最初\n            res += dp[hoge[0].se].fi;\n            cmx(mx, dp[hoge[0].se].se);\n            // 最後\n            res += dp[hoge[cnt-1].se].fi+1;\n            cmx(mx, max(dp[hoge[cnt-1].se].se, dp[hoge[cnt-1].se].th+1));\n            dp[u] = (tri){res, mx, hoge[0].fi+1};\n        }\n    }\n    // ashow(u, dp[u]);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        --a, --b;\n        G[a].pb(b), G[b].pb(a);\n    }\n    dfs(0, -1);\n    cout << dp[0].fi+1 << \" \" << max(dp[0].se, dp[0].th) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nint dp[MAXN],A,lim,res;\nint val[MAXN],tot;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {read(a);read(b);add(a,b);add(b,a);}\n    \n}\nvoid dfs(int u,int fa) {\n    int son = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    dfs(v,u);\n\t    ++son;\n\t    dp[u] += dp[v];\n\t}\n    }\n    dp[u] -= son / 2;\n    if(son % 2 == 0 && fa) dp[u]++;\n}\nstruct BIT {\n    int tr[MAXN],s;\n    void clear() {\n\tfor(int i = 1 ; i <= s ; ++i) tr[i] = 0;\n    }\n    int lowbit(int x) {return x & -x;}\n    int query(int x) {\n\tint res = 0;\n\twhile(x > 0) {\n\t    res += tr[x];\n\t    x -= lowbit(x);\n\t}\n\treturn res;\n    }\n    void insert(int x,int v) {\n\twhile(x <= s) {\n\t    tr[x] += v;\n\t    x += lowbit(x);\n\t}\n    }\n    int find_max() {\n\tint L = 1,R = s;\n\tint x = query(s);\n\tif(x == 0) return 0;\n\twhile(L < R) {\n\t    int m = (L + R + 1) >> 1;\n\t    if(query(m - 1) != x) L = m;\n\t    else R = m - 1;\n\t}\n\treturn L;\n    }\n}BST;\nvoid calc(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    calc(v,u);\n\t}\n    }\n    tot = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    val[++tot] = dp[v];\n\t}\n    }\n    if(!tot) {dp[u] = 1;++res;return;}\n    BST.clear();\n    sort(val + 1,val + tot + 1);\n    for(int i = 1 ; i <= tot ; ++i) vis[i] = 1;\n    BST.s = tot;int p = 0;\n    for(int i = tot ; i >= 1 ; --i) {\n\tif(!vis[i]) continue;\n\twhile(p < i && val[p + 1] + val[i] <= lim) {\n\t    ++p;BST.insert(p,1);\n\t}\n\tif(p >= i) BST.insert(i,-1);\n\tint t = BST.find_max();\n\tif(t) {vis[t] = 0;vis[i] = 0;BST.insert(t,-1);--res;}\n    }\n    if(fa) {\n\tdp[u] = 1;++res;\n\tfor(int i = 1 ; i <= tot ; ++i) {\n\t    if(vis[i]) {\n\t\tif(val[i] + 1 > lim) break;\n\t\tdp[u] += val[i];--res;\n\t\tbreak;\n\t    }\n\t}\n    }\n}\nbool check(int m) {\n    lim = m;res = 0;\n    calc(1,0);\n    return res <= A;\n}\nvoid Solve() {\n    dfs(1,0);\n    out(dp[1]);space;\n    A = dp[1];\n    int L = 1,R = N - 1;\n    while(L < R) {\n\tint mid = (L + R) >> 1;\n\tif(check(mid)) R = mid;\n\telse L = mid + 1;\n    }\n    out(R);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\nconst int MAXN=1e5+5;\n\nint N;\n\nint dgr[MAXN];\nstruct E{int next,to;} e[MAXN<<1];int ecnt,G[MAXN];\nvoid addEdge(int u,int v){e[++ecnt]=(E){G[u],v};G[u]=ecnt;dgr[u]++;}\nvoid addEdge2(int u,int v){addEdge(u,v);addEdge(v,u);}\n\nint B;\nint f[MAXN];\nbool dfs(int u,int la)\n{\n\tstd::vector<int> fv;\n\tif(dgr[u]&1) fv.push_back(0);\n\tfor(int i=G[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==la) continue;\n\t\tif(!dfs(v,u)) return false;\n\t\tfv.push_back(f[v]);\n\t}\n\tstd::sort(fv.begin(),fv.end());\n\tint k=fv.size();\n\t\n\tif(!k) {f[u]=1;return true;}\n\tif(!(k&1))\n\t{\n\t\tfor(int i=0;i<fv.size();i++)\n\t\t\tif(fv[i]+fv[fv.size()-1-i]>B)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tint l=1,r=k;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tfor(int p1=1,p2=k;p1<p2;p1++,p2--)\n\t\t{\n\t\t\tif(p1==mid) p1++;if(p2==mid) p2--;\n\t\t\tif(fv[p1-1]+fv[p2-1]>B) {l=mid+1;continue;}\n\t\t}\n\t\tr=mid-1;\n\t}\n\tif(l>k) return false;\n\tf[u]=fv[l-1]+1;\n\treturn true;\n}\n\nbool chk1()\n{\n\tmemset(f,0,sizeof f);\n\tif(!dfs(1,0)) return false;\n\tif(f[1]>B+1) return false;\n\treturn true;\n}\n\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t}\n\tint A=0;for(i=1;i<=N;i++) if(dgr[i]&1) A++;A>>=1;\n\tint l=0,r=N-1;\n\twhile(l<=r)\n\t{\n\t\tB=(l+r)>>1;\n\t\tif(chk1()) r=B-1;\n\t\telse l=B+1;\n\t}\n\tprintf(\"%d %d\",A,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=1e5+10;\nint n,ans,cnt;\nvector<int> g[maxn];\n\nvoid dfs(int pos,int fa,int mid,multiset<int>&root){\n\tmultiset<int> edge;\n\tfor(int i=0;i<g[pos].size();++i)\n\t\tif(g[pos][i]!=fa)\n\t\t\tdfs(g[pos][i],pos,mid,edge);\n\tint rest=0;\n\twhile(!edge.empty()&&*edge.rbegin()==mid){\n\t\tmultiset<int>::iterator p=edge.end();--p;\n\t\tedge.erase(p);\n\t\t++cnt;\n\t}\n\twhile(edge.size()){\n\t\tmultiset<int>::iterator p=edge.end(),q;--p;\n\t\tint maximum=*p;\n\t\tedge.erase(p);\n\t\tq=edge.upper_bound(mid-maximum);\n\t\tif(q==edge.begin()){\n\t\t\tif(rest)\n\t\t\t\t++cnt,rest=maximum;\n\t\t\telse\n\t\t\t\trest=maximum;\n\t\t}\n\t\telse{\n\t\t\t--q;\n\t\t\tedge.erase(q);\n\t\t\t++cnt;\n\t\t}\n\t}\n\troot.insert(rest+1);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;++i){\n\t\tcin>>u>>v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tfor(int i=2;i<=n;++i)\n\t\tans+=(g[i].size()-1)/2;\n\tans+=(g[1].size()+1)/2;\n\tint l=1,r=n-1;\n\twhile(l<r){\n\t\tint mid=l+r>>1;\n\t\tcnt=0;\n\t\tmultiset<int> tmp;\n\t\tdfs(1,0,mid,tmp);\n\t\tif(*tmp.begin()>1)\n\t\t\t++cnt;\n\t\tif(cnt<=ans)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<ans<<' '<<l<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nvector<vector<int> > g;\nvector<int>c;\nint S;\nint dfs(int id,int pre,int len){\n    multiset<int> p;\n    for(auto x:g[id]){\n        if(x!=pre){\n            int k = dfs(x,id,len);\n            if(k==0||k>len){\n                return 0;\n            }\n            p.insert(k);\n        }\n    }\n    if(c[id]==1){\n        return 1;\n    }\n    // cerr << \"id: \" << id << endl;\n    // for(auto x:p){\n    //     cerr << x << \" \";\n    // }\n    // cerr << endl;\n    if((c[id]%2==0&&id!=S)||(c[id]%2==1&&id==S)){\n        multiset<int> q;\n        while(p.size()>=2){\n            auto x = p.end();\n            x--;\n            int k = *x;\n            auto y = p.upper_bound(len-k);\n            if(y==p.begin()){\n                q.insert(k);\n                p.erase(x);\n            }else{\n                y--;\n                if(x==y){\n                    y--;\n                }\n                p.erase(x);\n                p.erase(y);\n            }\n        }\n        for(auto x:p){\n            q.insert(x);\n        }\n        if(q.size()!=1){\n            return 0;\n        }else{\n            int k = (*q.begin());\n            if(id!=S){\n                return k+1;\n            }else{\n                return k;\n            }\n        }\n    }else{\n        multiset<int> q;\n        while(p.size()>=2){\n            auto x = p.end();\n            x--;\n            int k = *x;\n            auto y = p.upper_bound(len-k);\n            if(y==p.begin()){\n                q.insert(k);\n                p.erase(x);\n            }else{\n                y--;\n                if(x==y){\n                    y--;\n                }\n                p.erase(x);\n                p.erase(y);\n            }\n        }\n        for(auto x:p){\n            q.insert(x);\n        }\n        if(q.size()==0){\n            return 1;\n        }else if(q.size()==2){\n            int k = *q.begin();\n            if(id!=S){\n                return k+1;\n            }else{\n                int s = 0;\n                for(auto x:q){\n                    s += x;\n                }\n                return s;\n            }\n        }else{\n            return 0;\n        }\n    }\n}\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);\n    c.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        c[a]++;\n        c[b]++;\n    }\n    int A = 1;\n    int id = 0;\n    rep(i,n){\n        if(c[i]>2){\n            if(c[i]%2==1){\n                A += c[i]/2;\n            }else{\n                A += c[i]/2-1;\n            }\n        }\n        if(c[i]%2==1){\n            id = i;\n\n        }\n    }\n    int S = 0;\n    int ok = n-1;\n    int ng = 1;\n    while(ok-ng>1){\n        int mid = (ok+ng)/2;\n        int k = dfs(0,-1,mid); \n        //cerr << mid << \" \" << k << endl;\n        if(k==0||k>mid){\n            ng = mid;\n        }else{\n            ok = mid;\n        }\n    }\n    cout << A << \" \" << ok << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint to[N << 1],nex[N << 1],beg[N],deg[N],Ans[N],rest[N],A[N];\nint e,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline void dfs(int x,int fa) {\n\tint cur = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tdfs(to[i],x),cur++;\n\t}\n\tans -= cur / 2,cur &= 1;\n\tif(!cur && x > 1) ans++;\n}\n\ninline int check(int Ban,int top,int val) {\n\tint pos = top,tot = 0;\n\tFor(i,1,top) {\n\t\tif(i == Ban) continue;\n\t\twhile(pos && (A[i] + A[pos] > val || pos == Ban)) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\treturn tot;\n}\n\ninline void Dp(int x,int fa,int val) {\n\tint total = 0,top = 0;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tDp(to[i],x,val);\n\t}\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\ttotal += Ans[to[i]];\n\t\tA[++top] = rest[to[i]];\n\t}\n\tsort(A + 1,A + top + 1);\n//\tcout << A[top] << \" \" << val << endl;\n\twhile(top && A[top] >= val) top--;\n\tA[top + 1] = 0;\n\tint pos = top,tot = 0;\n//\tdebug(top);\n\tFor(i,1,top) {\n\t\twhile(A[i] + A[pos] > val) pos--;\n\t\tif(i >= pos) break;\n\t\ttot++,pos--;\n\t}\n//\tdebug(tot);\n\tint l = 1,r = top + 1;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n//\t\tdebug(mid);\n\t\tif(check(mid,top,val) < tot) l = mid + 1;\n\t\telse r = mid;\n\t}\n//\tdebug(l);\n\trest[x] = A[l] + 1;Ans[x] = total - tot;\n\tif(l == top + 1 && x > 1) Ans[x]++;\n//\tcout << x << \" \" << Ans[x] << \" \" << total << \" \" << tot << \" \" << rest[x] << endl;\n}\n\nint main() {\n\tint n = read();\n\tFor(i,1,n - 1) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tint l = 1,r = n;\n\twhile(l < r) {\n\t\tint mid = (l + r) >> 1;\n//\t\tdebug(mid);\n\t\tDp(1,0,mid);\n//\t\tdebug(Ans[1]);\n//\t\tcout << \"------\" << endl;\n\t\tif(Ans[1] > ans) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\tprintf(\"%d %d\\n\",ans,l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100100;\nvi a[N];\nint n;\nint maxlen;\nint res;\n\nbool check(vi& ord, int pos) {\n\tif (ord[pos] + 1 > maxlen) {\n\t \treturn 0;\n\t}\n\tvi c;\n\tc.resize(sz(ord) - 1);\n\tint sz = 0;\n\tforn(i, sz(ord)) {\n\t\tif (i == pos)\n\t\t\tcontinue;\n\t\tc[sz++] = ord[i];\n\t}\t\n\tforn(i, sz(c) / 2) {\n\t\tif (c[i] + c[sz(c) - 1 - i] + 2 > maxlen) {\n\t\t \treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint calc(int v, int pr) {\n\tvi ord;       \n\tforn(i, sz(a[v])) {\n\t \tint to = a[v][i];\n\t \tif (to == pr)\n\t \t\tcontinue;\n\t \tint k = calc(to, v);\n\t\tif (k < 0) {\n\t\t \treturn -1;\n\t\t}\n\t\tord.pb(k);\n\t}\n\tsort(all(ord));\n\tif (!(sz(ord) & 1)) {\n\t\t//debug(sz(ord));\n\t\tforn(i, sz(ord) / 2) {\n\t\t \tif (ord[i] + ord[sz(ord) - 1 - i] + 2 > maxlen) {\n\t\t \t\treturn -1; \t\n\t\t \t}\n\t\t}\n\t\tres += sz(ord) / 2;\n\t\treturn 0;\n\t}\n\tif (!check(ord, sz(ord) - 1)) {\n\t \treturn -1;\n\t}\n\tint l = 0, r = sz(ord) - 1;\n\twhile (l < r) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(ord, m)) {\n\t\t \tr = m;\n\t\t} else {\n\t\t \tl = m + 1;\n\t\t}\n\t}\n\tres += sz(ord) / 2;\n\tif (!v)\n\t\tres++;\n\treturn ord[l] + 1;\n}\n\nint main () {\n\t//std::ios::sync_with_stdio(false);\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tcin >> n;\n\tforn(i, n - 1) {\n\t \tint u, v;\n\t \tcin >> u >> v;\n\t \tu--, v--;\n\t \ta[u].pb(v);\n\t \ta[v].pb(u);\n\t}     \n\tint l = 1, r = n;\n\twhile (l < r) {\n\t    maxlen = (l + r) / 2;\n\t    res = 0;\n\t    if (calc(0, -1) < 0) {\n\t     \tl = maxlen + 1;\n\t    } else {\n\t     \tr = maxlen;\n\t    }\n\t}\n\tmaxlen = l;\n\tres = 0;\n\tdebug(maxlen);\n\tcalc(0, -1);\n\tcout << res << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\twhile((int)sak[u].size()>1){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif(!sak[u].empty()) return *sak[u].begin();\n\treturn 0;\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nint n, m;\nvector<int> edge[100001];\n\nint dfs(int x, int p) {\n    vector<int> child;\n    for (int i : edge[x]) {\n        if (i == p) continue;\n        int ret = dfs(i, x);\n        if (ret > m) return m + 5;\n        child.push_back(ret);\n    }\n    if ((child.size() & 1) == 0) child.push_back(0);\n    sort(child.begin(), child.end());\n    int s = 0, e = child.size();\n    while (s < e) {\n        int md = (s + e) / 2, pos = 1;\n        for (int i = 0, j = child.size() - 1; ; ++i, --j) {\n            if (i == md) ++i;\n            if (j == md) --j;\n            if (j <= i) break;\n            if (child[i] + child[j] > m) {\n                pos = 0;\n                break;\n            }\n        }\n        if (pos) e = md;\n        else s = md + 1;\n    }\n    if (s == child.size()) return m + 5;\n    if (x == 1 && (edge[x].size() & 1) == 0 && s > 0) return m + 5;\n    return child[s] + 1;\n}\n\nint check() {\n    return dfs(1, 0) <= m + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    int A = n - 1;\n    for (int i = 1; i <= n; ++i) A -= edge[i].size() >> 1;\n    int s = 1, e = n - 1;\n    while (s < e) {\n        m = (s + e) / 2;\n        if (check()) e = m;\n        else s = m + 1;\n    }\n    printf(\"%d %d\\n\", A, s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\tint res=sak[u].size()&1?1:2,vl=0;\n\tif(fa==-1) res=sak[u].size()&1?1:0;\n\twhile(!sak[u].empty()){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()||(int)sak[u].size()==1){\n\t\t\tif(!res){\n\t\t\t\tbo=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres--;\n\t\t\tsak[u].erase(itt);\n\t\t\tvl=v;\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\treturn vl;\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n//\tfreopen(\"A.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "10\n1 2\n2 3\n3 4\n2 5\n6 5\n6 7\n7 8\n5 9\n10 5"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\td.insert(dfs(v)+1);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\tcerr<<k<<endl;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0;\n\trep(i, n) resa += (g[i].size()-1)/2;\n\tint lb = 0, ub = n-1;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(0);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resa+1<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1) return -1;\n\t\t\telse if(res == B) ++tot, res = 0;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2 + 1;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) \n\t\t\t{\n\t\t\t\ttot += a.size() / 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\ttot += a.size() / 2;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\ttot += (a.size() - 1) / 2;\n\t\treturn ret;\n\t\t\t\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn tot <= A;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int maxn=100005;\nvector<int>E[maxn];\nint n,deg[maxn],dp[maxn],lim;\nbool dfs(int u,int fa){\n\tbool res=1;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)res&=dfs(v,u);\n\t}\n\tstatic int c[maxn],tot;\n\ttot=0;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)c[++tot]=dp[v];\n\t}\n\tif(deg[u]&1)c[++tot]=0;\n\tsort(c+1,c+1+tot);\n\tint l=1,h=tot;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1,curl=1,curr=tot,Max=0;\n\t\tREP(i,1,tot>>1){\n\t\t\tif(curl==mid)curl++;\n\t\t\tif(curr==mid)curr--;\n\t\t\tchkmax(Max,c[curl]+c[curr]);\n\t\t\tcurl++,curr--;\n\t\t}\n\t\tif(Max<=lim)h=mid-1;\n\t\telse l=mid+1;\n\t}\n\tres&=(l<=tot);\n\tdp[u]=c[l]+1;\n\treturn res;\n}\nbool check(int x){\n\tlim=x;\n\treturn dfs(1,0)&(dp[1]-1<=lim);\n}\nint main(){\n\tint u,v;\n\tn=read();\n\tREP(i,1,n-1){\n\t\tu=read(),v=read();\n\t\tE[u].pb(v),deg[u]++;\n\t\tE[v].pb(u),deg[v]++;\n\t}\n\tint ans=0;\n\tREP(i,1,n)ans+=(deg[i]&1);\n\twrite(ans>>1,' ');\n\tint l=1,h=n-1;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1;\n\t\tif(check(mid))h=mid-1;\n\t\telse l=mid+1;\n\t}write(l,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nint dp[MAXN],A,lim,res;\nint val[MAXN],tot;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {read(a);read(b);add(a,b);add(b,a);}\n    \n}\nvoid dfs(int u,int fa) {\n    int son = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    dfs(v,u);\n\t    ++son;\n\t    dp[u] += dp[v];\n\t}\n    }\n    dp[u] -= son / 2;\n    if(son % 2 == 0 && fa) dp[u]++;\n}\nstruct BIT {\n    int tr[MAXN],s;\n    void clear() {\n\tfor(int i = 1 ; i <= s ; ++i) tr[i] = 0;\n    }\n    int lowbit(int x) {return x & -x;}\n    int query(int x) {\n\tint res = 0;\n\twhile(x > 0) {\n\t    res += tr[x];\n\t    x -= lowbit(x);\n\t}\n\treturn res;\n    }\n    void insert(int x,int v) {\n\twhile(x <= s) {\n\t    tr[x] += v;\n\t    x += lowbit(x);\n\t}\n    }\n    int find_max() {\n\tint L = 1,R = s;\n\tint x = query(s);\n\tif(x == 0) return 0;\n\twhile(L < R) {\n\t    int m = (L + R + 1) >> 1;\n\t    if(query(m - 1) != x) L = m;\n\t    else R = m - 1;\n\t}\n\treturn L;\n    }\n}BST;\nvoid calc(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    calc(v,u);\n\t}\n    }\n    tot = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    val[++tot] = dp[v];\n\t}\n    }\n    if(!tot) {dp[u] = 1;++res;return;}\n    BST.clear();\n    sort(val + 1,val + tot + 1);\n    for(int i = 1 ; i <= tot ; ++i) vis[i] = 1;\n    BST.s = tot;int p = 0;\n    for(int i = tot ; i >= 1 ; --i) {\n\tif(!vis[i]) continue;\n\twhile(p < tot && val[p + 1] + val[i] <= lim) {\n\t    ++p;BST.insert(p,1);\n\t}\n\tif(p >= i) BST.insert(i,-1);\n\tint t = BST.find_max();\n\tif(t) {vis[t] = 0;vis[i] = 0;BST.insert(t,-1);--res;}\n    }\n    if(fa) {\n\tdp[u] = 1;++res;\n\tfor(int i = 1 ; i <= tot ; ++i) {\n\t    if(vis[i]) {\n\t\tif(val[i] + 1 > lim) break;\n\t\tdp[u] += val[i];--res;\n\t\tbreak;\n\t    }\n\t}\n    }\n}\nbool check(int m) {\n    lim = m;res = 0;\n    calc(1,0);\n    return res <= A;\n}\nvoid Solve() {\n    dfs(1,0);\n    out(dp[1]);space;\n    A = dp[1];\n    int L = 1,R = N - 1;\n    while(L < R) {\n\tint mid = (L + R) >> 1;\n\tif(check(mid)) R = mid;\n\telse L = mid + 1;\n    }\n    out(R);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int mid)\n{\n\tvector<int>son;\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, mid))return false;\n\t\t//if(dp[to] != -1)\n\t\tson.push_back(dp[to] + 1);\n\t}\n\tif (son.size() == 0)\n\t{\n\t\tdp[x] = 0;\n\t\treturn true;\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > mid)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = 0;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tint flag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > mid)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (son[le] > mid)return false;\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = cnt / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5;\nvector<int> g[N];\nvector<int> path[N];\n\nvoid dfs(int u, int p, int x) {\n  for (int v : g[u]) if (v != p) {\n    dfs(v, u, x);\n    path[u].push_back(path[v].back() + 1);\n  }\n\n  if (path[u].size() % 2 == 0) {\n    path[u].push_back(0);\n  }\n\n  sort(path[u].begin(), path[u].end());\n\n  int ok = path[u].size();\n  int ng = -1;\n\n  while (ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n\n    int mx = 0;\n    auto tmp = path[u];\n    tmp.erase(tmp.begin() + mid);\n\n    for (int i = 0; i * 2 + 1 < tmp.size(); i++) {\n      mx = max(mx, tmp[i] + tmp[tmp.size() - 1 - i]);\n    }\n\n    if (mx <= x) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n \n  if (ok == path[u].size()) throw -1;\n  swap(path[u][ok], path[u].back());\n  \n  if (p == -1) {\n    if (g[u].size() % 2 == 0 && ok != 0) throw - 1;\n    if (g[u].size() % 2 == 1 && path[u].back() > x) throw -1;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      ans += (g[i].size() + 1) / 2;\n    } else {\n      ans += (g[i].size() - 1) / 2;\n    }\n  }\n\n  int ok = n - 1;\n  int ng = -1;\n  while (ok - ng > 1) {\n    for (int i = 0; i < n; i++) {\n      path[i].clear();\n    }\n    int mid = (ok + ng) / 2;\n    try {\n      dfs(0, -1, mid);\n      ok = mid;\n    } catch (...) {\n      ng = mid;\n    }\n  }\n\n  cout << ans << ' ' << ok << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint nt[N << 1], to[N << 1], head[N], cnt = 0;\n\nvoid add(int x, int y) {\n  to[++cnt] = y;\n  nt[cnt] = head[x];\n  head[x] = cnt;\n}\n\nint f[N], g[N], ans = 0;\nvoid predfs(int u, int fa) {\n  int s = 0, pos = 0, tmp = 0, mx = 0;\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    predfs(to[i], u);\n    ans = max(ans, mx + g[to[i]] + 1);\n    mx = max(mx, g[to[i]] + 1);\n    pos += f[to[i]];\n    tmp++;\n  }\n  g[u] = mx;\n  f[u] = pos + (tmp / 2);\n  if(u == 1) f[u] += tmp & 1;\n  if(!tmp) f[u] = 0;\n}\n\nint lmt, flg, up[N], A, B, num, st[N];\nmultiset<int> S;\nmultiset<int> :: iterator sit;\nvoid dfs(int u, int fa) {\n  if(!flg) return ;\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    dfs(to[i], u);\n  }\n//  printf(\"%d %d\\n\", u, fa);\n  for(int i = head[u]; i; i = nt[i]) {\n    if(to[i] == fa) continue;\n    if(f[to[i]] + 1 > lmt) {\n      flg = 0;\n      return ;\n    }\n//    printf(\"%d %d num = %d\\n\", to[i], f[to[i]] + 1, num);\n    S.insert(f[to[i]] + 1);\n  }\n  int top = 0;\n  while(S.size() > 1) {\n    int pos = *S.rbegin();\n    S.erase(S.find(pos));\n    if(*S.rbegin() + pos <= lmt) {\n      num++;\n      int tmp = *S.rbegin();\n      S.erase(S.find(tmp));\n    } else if(*S.begin() + pos > lmt) {\n      st[++top] = pos;\n    } else {\n      sit = S.upper_bound(lmt - pos);\n      sit--;\n      num++;\n      S.erase(sit);\n    }\n  }\n  if(S.size()) {\n    st[++top] = *S.begin();\n    S.clear();\n  }\n  f[u] = 0;\n  if(top) {\n    sort(st + 1, st + 1 + top);\n    f[u] = st[1];\n    num += top - 1;\n  }\n//  if(u == 2) printf(\"qswl%d\\n\", f[u]);\n  if(!fa && f[u]) num++;\n}\n\nbool check(int x) {\n  flg = 1;\n  lmt = x, num = 0;\n  dfs(1, 0);\n//  printf(\"qwq%d %d %d\\n\", x, num, flg);\n  return flg && num <= A;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for(int i = 2, x, y; i <= n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    add(x, y), add(y, x);\n  }\n  memset(f, 0x3f, sizeof f);\n  predfs(1, 0);\n  A = f[1];\n  int l = 1, r = ans;\n  while(l <= r) {\n    int mid = (l + r) >> 1;\n    if(check(mid)) r = mid - 1, B = mid;\n    else l = mid + 1;\n  }\n//  check(2);\n  printf(\"%d %d\\n\", A, B);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int MAX=200040;\nconst ll MOD=1000000007;\nvector<int> conn[MAX],dir[MAX],tmp[MAX];\nint a,b,com=0,par[MAX],n;\nvoid dfs(int x,int p){\n    par[x]=p;\n    for(int i=0;i<conn[x].size();i++) if(conn[x][i]!=p) dfs(conn[x][i],x);\n}\nint simple(int v,int u){\n    int p1=1,p2=tmp[v].size()-1,pos=1;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n    }\n    return pos;\n}\nint div2(int v,int x,int y,int u){\n    if(y-x==1) return x;\n    int p=(x+y)/2,p1=0,p2=tmp[v].size()-1,pos=1;\n    //for(int i=p1;i<=p2;i++) printf(\"%d \",tmp[v][i]);\n    if(p1==p) p1++;\n    if(p2==p) p2--;\n    while(p1<p2){\n        if(tmp[v][p1]+tmp[v][p2]>u) pos=0;\n        p1++,p2--;\n        if(p1==p) p1++;\n        if(p2==p) p2--;\n    }\n    if(pos) return div2(v,x,p,u);\n    return div2(v,p,y,u);\n}\nint f(int x,int u){\n    tmp[x].clear();\n    if(dir[x].size()==0) return 0;\n    if(dir[x].size()==1){\n        int t=f(dir[x][0],u)+1;\n        if(t==0||t>u) return -1;\n        return t;\n    }\n    for(int i=0;i<dir[x].size();i++){\n        int t=f(dir[x][i],u)+1;\n        if(t==0) return -1;\n        tmp[x].push_back(t);\n    }\n    if(tmp[x].size()%2==0) tmp[x].push_back(0);\n    sort(tmp[x].begin(),tmp[x].end());\n    int t=div2(x,0,tmp[x].size(),u)+1;\n    if(tmp[x].size()==t) return -1;\n    if(tmp[x][t]>u) return -1;\n    if(simple(x,u)) return tmp[x][0];\n    return tmp[x][t];\n}\nint div22(int x,int y){\n    if(y-x==1) return x;\n    int p=(x+y)/2,u=f(com,p);\n    if(u==-1) return div22(p,y);\n    return div22(x,p);\n}\nint main(){\n    scanf(\" %d\",&n);\n    for(int i=0;i<n-1;i++){\n        int t1,t2;\n        scanf(\" %d %d\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(int i=1;i<=n;i++) if(conn[i].size()%2) com=max(i,com), a+=1;\n    a/=2;\n    dfs(com,0);\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<conn[i].size();j++) if(conn[i][j]!=par[i]) dir[i].push_back(conn[i][j]);\n    }\n    b=div22(0,n+1)+1;\n    printf(\"%d %d\\n\",a,b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[110000];\nint n;\n\nbool check2(vector<int>& c, int idx, int k) {\n    vector<int> v = c;\n    v.erase(v.begin() + idx);\n\n    for (int i = 0; i < v.size()/2; i++) {\n        if (v[i] + v[v.size()-i-1] > k) {\n            //cout << \"oops \" << i << \" \" << v[i] << \" \" << n-i-1 << \" \" << v[n-i-1] << endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint dfs(int v, int p, int k) {\n    vector<int> children;\n\n    for (int x : g[v]) if (x != p) {\n        children.push_back( dfs(x, v, k) );\n        if (children.back() > k) return k+2;\n    }\n\n    if (children.size() % 2 != 1 - (p==-1)) children.push_back(0);\n    sort(children.begin(), children.end());\n\n    int cc = children.size();\n    \n    int st = 0, ed = cc-1;\n    while (st < ed) {\n        int md = (st+ed)/2;\n\n        if (check2(children, md, k)) ed = md;\n        else st = md+1;\n    }\n\n    // cout << v+1 << \" \" << st << \" \" << check2(children,st,k) << \" \" << k << endl;\n    // if (children.size() >= 3) cout << children[0] << \" \" << children[1] << \" \" << children[2] << endl;\n\n    if (!check2(children,st,k)) return k+2;\n    return children[st]+1;\n}\n\nint check(int k) {\n    return dfs(0,-1,k) == 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int u,v; cin >> u >> v; u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int ends = 0;\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() % 2 == 1) ends++;\n    }\n\n    int st = 1, ed = n-1;\n    // int st = 5, ed = 6;\n    while (st < ed) {\n        int md = (st+ed)/2;\n        if (check(md)) ed = md;\n        else st = md+1;\n    }\n\n    cout << ends/2 << \" \" << st << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<ll,int> pr;\n\nconst int inf = 2e8;\nconst int maxn = 100020;\nconst ll mod = 1e9 + 7;\nstruct node{\n\tint next,to,w;\n}e[maxn * 2];\n\nint head[maxn],cnt,rt,sz[maxn],n,deg[maxn];\nint len,flag;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\n\nvoid dfs(int x,int fa){\n\tfore(i,x){\n\t\tif ( e[i].to == fa ) continue;\n\t\tdfs(e[i].to,x);\n\t\tdeg[x]++;\t\n\t}\n}\nstruct cmp{\n\tbool operator () (int x,int y){ return x > y; }\n};\nmultiset <int,cmp> vec[maxn];\nint dfs2(int x,int fa){\n\tfore(i,x){\n\t\tif ( e[i].to == fa ) continue;\n\t\tvec[x].insert(dfs2(e[i].to,x));\n\t\tif ( !flag ) return 0;\n\t}\n//\tsort(vec[x].begin(),vec[x].end());\n\tif ( !vec[x].size() ) return 1;\n\tif ( x == 1 ){\n\t\tif ( vec[x].size() & 1 ){\n\t\t   \tflag &= *vec[x].begin() <= len;\n\t\t\tvec[x].erase(vec[x].begin());\n\t\t}\n\t\tif ( vec[x].size() ){\n\t\t\tauto it = vec[x].end();\n\t\t\tfor (auto it2 = vec[x].begin() ; it2 != vec[x].end() ; ++it2){\n\t\t\t\t--it;\n\t\t\t\tflag &= ((*it) + (*it2)) <= len;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint l = 0;\n\tif ( !(vec[x].size() & 1) ){\n\t\tint cnt = 0,tag = 0;\n\t\tfor (auto it = vec[x].begin() ; it != vec[x].end() ; ++it){\n\t\t\tif ( *it > len ){ flag =0 ; return 0; }\n\t\t\tif ( (*it) * 2 <= len ) break;\n\t\t\tauto it2 = vec[x].lower_bound(len - *it);\n\t\t\tif ( it2 == vec[x].end() ){\n\t\t\t\tif ( !tag ) tag = 1;\n\t\t\t\telse if ( !l ) l = (*it) + 1;\n\t\t\t\telse{ flag = 0; return 0; }\n\t\t\t}\n\t\t\telse vec[x].erase(it2);\n\t//\t\tvec[x].erase(it);\n\t\t\t++cnt;\n\t\t\tif ( cnt >= vec[x].size() ) break;\n\t\t}\n\t\tauto it = vec[x].end();\n\t\tif ( !l ){\n\t\t   \tif ( tag ) l = (*(--it)) + 1;\n\t\t\telse l = 1;\n\t\t}\n\t}\n\telse{\n\t\tint cnt = 0;\n\t\tfor (auto it = vec[x].begin() ; it != vec[x].end() ; ++it){\n\t\t\tif ( *it > len ){ flag =0 ; return 0; }\n\t\t\tif ( (*it) * 2 <= len ) break;\n\t\t\tauto it2 = vec[x].lower_bound(len - *it);\n\t\t\tif ( it2 == vec[x].end() ){\n\t\t\t\tif ( !l ) l = (*it) + 1;\n\t\t\t\telse{ flag = 0; return 0; }\n\t\t\t}\n\t\t\telse vec[x].erase(it2);\n\t//\t\tvec[x].erase(it);\n\t\t\t++cnt;\n\t\t\tif ( cnt >= vec[x].size() ) break;\n\t\t}\n\t\tauto it = vec[x].end();\n\t\tif ( !l ) l = (*(--it)) + 1;\n\t}\n\treturn l;\n}\nint check(int mid){\n\trep(i,1,n) vec[i].clear();\n\tflag = 1;\n\tlen = mid;\n\tdfs2(1,0);\n\treturn flag;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n - 1){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y) , adde(y,x);\n\t}\n\tdfs(1,0);\n\tint A = 0,B = 0;\n\trep(i,1,n){\n\t\tif ( i == 1 ) A += (deg[i] + 1) / 2;\n\t\telse A += deg[i] / 2;\n\t}\n\tint l = 1 , r = n;\n\twhile ( l <= r ){\n\t\tint mid = (l + r) >> 1;\n\t\tif ( check(mid) ) B = mid , r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout<<A<<\" \"<<B<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)\n\t\tif(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\twhile(1){\n\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\telse if(pre>0)tt--,pre--;\n\t\telse if(tt-suf==1){\n\t\t\tif(u==1)return false;\n\t\t\tif(pre>0&&pre%2){\n\t\t\t\tif(now[tt]+now[1]+2<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse if(now[suf]+now[1]+2<=mid){f[u]=now[tt]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}else {\n\t\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}else return false;\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;//printf(\"%d\\n\",dp(1,1,2));\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\tint res=1,flag=sak[u].size()&1,vl;\n\twhile((int)sak[u].size()>1){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tif(!res){\n\t\t\t\tbo=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres--;\n\t\t\tsak[u].erase(itt);\n\t\t\tvl=v;\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif(!flag&&fa==-1&&!sak[u].empty()){\n\t\tbo=0;\n\t\treturn 0;\n\t}\n\tif(flag&&sak[u].empty()) return vl;\n\tif(sak[u].empty()) return 0;\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n//\tfreopen(\"A.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nint dp[MAXN],A,lim,res;\nint val[MAXN],tot;\nbool vis[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {read(a);read(b);add(a,b);add(b,a);}\n    \n}\nvoid dfs(int u,int fa) {\n    int son = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    dfs(v,u);\n\t    ++son;\n\t    dp[u] += dp[v];\n\t}\n    }\n    dp[u] -= son / 2;\n    if(son % 2 == 0) dp[u]++;\n}\nstruct BIT {\n    int tr[MAXN],s;\n    void clear() {\n\tfor(int i = 1 ; i <= s ; ++i) tr[i] = 0;\n    }\n    int lowbit(int x) {return x & -x;}\n    int query(int x) {\n\tint res = 0;\n\twhile(x > 0) {\n\t    res += tr[x];\n\t    x -= lowbit(x);\n\t}\n\treturn res;\n    }\n    void insert(int x,int v) {\n\twhile(x <= s) {\n\t    tr[x] += v;\n\t    x += lowbit(x);\n\t}\n    }\n    int find_max() {\n\tint L = 1,R = s;\n\tint x = query(s);\n\tif(x == 0) return 0;\n\twhile(L < R) {\n\t    int m = (L + R + 1) >> 1;\n\t    if(query(m - 1) != x) L = m;\n\t    else R = m - 1;\n\t}\n\treturn L;\n    }\n}BST;\nvoid calc(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    calc(v,u);\n\t}\n    }\n    tot = 0;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(v != fa) {\n\t    val[++tot] = dp[v];\n\t}\n    }\n    if(!tot) {dp[u] = 1;++res;return;}\n    BST.clear();\n    sort(val + 1,val + tot + 1);\n    for(int i = 1 ; i <= tot ; ++i) vis[i] = 1;\n    BST.s = tot;int p = 0;\n    for(int i = tot ; i >= 1 ; --i) {\n\tif(!vis[i]) continue;\n\twhile(p < tot && val[p + 1] + val[i] <= lim) {\n\t    ++p;BST.insert(p,1);\n\t}\n\tif(p >= i) BST.insert(i,-1);\n\tint t = BST.find_max();\n\tif(t) {vis[t] = 0;vis[i] = 0;BST.insert(t,-1);--res;}\n    }\n    if(fa) {\n\tdp[u] = 1;++res;\n\tfor(int i = 1 ; i <= tot ; ++i) {\n\t    if(vis[i]) {\n\t\tif(val[i] + 1 > lim) break;\n\t\tdp[u] += val[i];--res;\n\t\tbreak;\n\t    }\n\t}\n    }\n}\nbool check(int m) {\n    lim = m;res = 0;\n    calc(1,0);\n    return res <= A;\n}\nvoid Solve() {\n    dfs(1,0);\n    out(dp[1]);space;\n    A = dp[1];\n    int L = 1,R = N - 1;\n    while(L < R) {\n\tint mid = (L + R) >> 1;\n\tif(check(mid)) R = mid;\n\telse L = mid + 1;\n    }\n    out(R);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tint lb = 0, ub = n-1;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resa+1<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nvector<int> graph[N];\nint root;\nint A, t;\nint beginning;\n\nint find_value(vector<int> &dp, int M)\n{\n    int L = -1, R = dp.size();\n    while (L + 1 < R)\n    {\n        int mid = (L + R) / 2;\n        int j = dp.size() - 1;\n        int t = 1;\n        for (int i = 0; i < j; )\n        {\n            if (i == mid) i++;\n            if (j == mid) j--;\n            if (dp[i] + dp[j] > M) t = 0;\n            i++, j--;\n        }\n        if (t) R = mid;\n        else L = mid;\n    }\n    return dp[R];\n}\n\nint dfs(int v, int p, int M)\n{\n    vector<int> dp;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dp.push_back(dfs(u, v, M));\n    }\n    if (dp.size() % 2 == 0) dp.push_back(0), beginning++;\n    sort(all(dp));\n    int x = find_value(dp, M) + 1;\n    if (x == M + 1) x = 1, beginning += 2;\n    //cout << \"vertex \" << v << \" \" << x << \"\\n\";\n    return x;\n}\n\nint check(int M)\n{\n    if (M == 1)\n    {\n        return (A == n - 1);\n    }\n    t = 0;\n    beginning = 0;\n    int cat = dfs(root, root, M);\n    if (cat == 1) beginning--;\n    //cout << \"if M = \" << M << \" \" << beginning << \"\\n\";\n    if ((beginning + 1) / 2 <= A) return 1;\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    int cnt_odd = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (graph[i].size() == 1) root = i;\n        cnt_odd += (graph[i].size() % 2);\n    }\n    cout << (cnt_odd + 1) / 2 << \" \";\n    A = (cnt_odd + 1) / 2;\n    int L = 0, R = n;\n    while (L + 1 < R)\n    {\n        int M = (L + R) / 2;\n        if (check(M)) R = M;\n        else L = M;\n    }\n    cout << R;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint n,ed,B,root,g[N],f[N],q[N],deg[N];\nstruct E{int v,nxt;}e[N<<1];\ninline void adde(int x,int y){e[++ed].v=y;e[ed].nxt=g[x];g[x]=ed;}\nint dfs(int x,int y){\n\tint i;f[x]=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y&&!dfs(e[i].v,x))return 0;\n\tint t=0;\n\tfor(i=g[x];i;i=e[i].nxt)if(e[i].v!=y)q[++t]=f[e[i].v]+1;\n\tif(!t)return 1;\n\tif(~t&1)q[++t]=0;\n\tsort(q+1,q+1+t);\n\tif(q[t]>B)return 0;\n\tint l=1,r=t+1;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;\n\t\tint l1=0,r1=t+1;\n\t\tfor(i=1;i<=t/2;++i){\n\t\t\tif(++l1,l1==mid)++l1;\n\t\t\tif(--r1,r1==mid)--r1;\n\t\t\tif(q[l1]+q[r1]>B)break;\n\t\t}\n\t\tif(i<=t/2)l=mid+1;\n\t\telse r=mid;\n\t}\n\tif(l>t)return 0;\n\treturn f[x]=q[l],1; \n}\n\nint main(){\n\t//freopen(\"aa.in\",\"r\",stdin);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);adde(y,x);\n\t\t++deg[x];++deg[y];\n\t}\n\tint tot=0;\n\tfor(i=1;i<=n;++i){\n\t\tif(deg[i]&1)++tot;\n\t\tif(deg[i]==1)root=i;\t\n\t}\n\ttot>>=1;\n\tint l=1,r=n;\n\tfor(;l<r;){\n\t\tint mid=(l+r)>>1;B=mid;\n\t\tif(!dfs(root,root))l=mid+1;\n\t\telse r=mid;\n\t}\n\tprintf(\"%d %d\",tot,l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (300006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=21;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\n\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tvector<int> vi;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvi.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vi.size()==0)return res[v]=P(1,1);\n\tsort(vi.begin(),vi.end());\n\tint l=0,r=(int)vi.size()-1;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vi[l]+vi[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP rec=dfs(0,-1,len);\n\tif(rec.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100100;\n\nint n,A,B,dp[maxn];\nvector<int> g[maxn];\n\nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            if (dp[v]!=-1) temp.push_back(dp[v]);\n        }\n    }\n    sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n  //  cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=-1,rr=temp.size();\n        while (ll+1<rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n           // cout<<x<<endl;\n            while (p1<p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > B) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                rr = x;\n            }\n            else ll = x;\n        }\n       // cout<<rr<<endl;\n        if (rr==temp.size()) return false;\n        dp[u] = temp[rr] + 1;\n        return true;\n    }\n    else {\n        for (int i=0;i<temp.size();i++)\n            if (temp[i] + temp[temp.size()-i-1] + 2 > B) return false;\n        dp[u]=-1;\n        return true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n   // freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=-1,r=n+1;\n    while (l+1<r) {\n        B = (l+r)/2;\n        if (visit(1,-1)) r = B;\n        else l = B;\n    }\n    cout<<r;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nvector<int>G[N];\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=G[u].size()/2;\n}\ninline void dfs_ans(int u,int f)\n{\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs_ans(v,u);\n\t\tG[u].pb(dis[v]+1);\n\t}\n\tsort(G[u].begin(),G[u].end());\n\t/*\n\tprintf(\"%d: \",u);\n\tFor(i,0,G[u].size()-1)printf(\"%d \",G[u][i]);\n\tputs(\"\");\n\t*/\n\tif(G[u].size()&1)\n\t{\n\t\tdis[u]=G[u].back();\n\t\tint last=G[u].size()-2;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<i)break;\n\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t{\n\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\tflag=0;\n\t\t\t}\n\t\t\tlast--;\n\t\t}\n\t}\n\telse\n\t{\n\t\tdis[u]=0;\n\t\tint last=G[u].size()-1,ret=0;\n\t\tFor(i,0,G[u].size()-1)\n\t\t{\n\t\t\tif(last<i)break;\n\t\t\tchkmax(ret,G[u][i]+G[u][last]);\n\t\t\tlast--;\n\t\t}\n\t\tif(ret>len)\n\t\t{\n\t\t\tif(G[u].back()>len)flag=0;\n\t\t\tdis[u]=G[u][G[u].size()-2];\n\t\t\tlast=G[u].size()-3;\n\t\t\tFor(i,0,G[u].size()-1)\n\t\t\t{\n\t\t\t\tif(last<i)break;\n\t\t\t\tif(G[u][i]+G[u][last]>len)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"%d\\n\",u);\n\t\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t\t\tlast--;\n\t\t\t}\n\t\t}\n\t}\n}\ninline bool check(int x)\n{\n\tFor(i,1,n)G[i].clear();\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\tif((G[1].size()&1)&&G[1].back()>len)flag=0;\n\t//printf(\"%d %d\\n\",len,flag);\n\treturn flag;\n}\nint main()\n{\n\tint x,y;\n\tfile();\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tif(G[1].size()&1)dp[1]++;\n\tcheck(2);\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nll N;\nvector<vll> G;\nll degree[100010];\n\nll dp[100010];\nbool dfs(ll v,ll p,const ll &x){\n  bool ret=true;\n  vll V;\n  for(ll u:G[v])if(p!=u){\n    ret &= dfs(u,v,x);\n    V.push_back(dp[u]+1);\n  }\n  if(!V.size())return ret;\n  if(!ret)return false;\n  sort(V.begin(),V.end());\n  if(V.size()&1){\n    ll low=-1,high=V.size();\n    while(high-low>1){\n      ll mid = (low+high)/2;\n      bool isok=V[mid]<=x;\n      ll l=0,r=V.size()-1;\n      for(ll i=0;i<V.size()/2;i++){\n        if(l==mid){\n          l++;\n        }\n        if(r==mid){\n          r--;\n        }\n        isok &= V[l]+V[r]<=x;\n        l++;\n        r--;\n      }\n      if(isok){\n        high = mid;\n      }else{\n        low = mid;\n      }\n    }\n    if(high==V.size()){\n      return false;\n    }\n    dp[v] = V[high];\n  }else{\n    bool isok=true;\n    ll l=0,r=V.size()-1;\n    for(ll i=0;i<V.size()/2;i++){\n      isok &= V[l]+V[r]<=x;\n      l++;\n      r--;\n    }\n    if(!isok){\n      //cerr<<\"!!\"<<endl;\n      ret &= V.back()<=x;\n      V.pop_back();\n      ll low=-1,high=V.size();\n      while(high-low>1){\n        ll mid = (low+high)/2;\n        isok=V[mid]<=x;\n        l=0,r=V.size()-1;\n        for(ll i=0;i<V.size()/2;i++){\n          if(l==mid){\n            l++;\n          }\n          if(r==mid){\n            r--;\n          }\n          isok &= V[l]+V[r]<=x;\n          l++;\n          r--;\n        }\n        if(isok){\n          high = mid;\n        }else{\n          low = mid;\n        }\n      }\n      if(high==V.size()){\n        return false;\n      }\n      dp[v] = V[high];\n    }\n  }\n  ret &= dp[v]<=x;\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll a,b;cin>>a>>b;a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    degree[a]++;\n    degree[b]++;\n  }\n  ll A=0;\n  for(ll i=0;i<N;i++){\n    A += degree[i]&1;\n  }\n  A /= 2;\n  ll low=-1,high=N;\n  while(high-low>1){\n    ll mid=(high+low)/2;\n    //debug(mid);\n    fill(dp,dp+N,0);\n    if(dfs(0,-1,mid)){\n      high = mid;\n    }else{\n      low = mid;\n    }\n    //debugArray(dp,N);\n  }\n  cout<<A<<\" \"<<high<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 100005\nusing namespace std;\nint n,num,cnt,now[MN],f[MN],head[MN];\nstruct edge{int to,next;}g[MN<<1];\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nbool dp(int u,int ff,int mid){\n\tint tt=0,i;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)\n\t\tif(!dp(g[i].to,u,mid))return false;\n\tfor(i=head[u];i;i=g[i].next)if(g[i].to!=ff)now[++tt]=f[g[i].to];\n\tsort(now+1,now+tt+1);\n\tif(!tt){f[u]=0;return true;}\n\tfor(i=1;now[i+1]+now[tt]+2<=mid&&i+1<=tt;i++);int pre=i-1,suf=i;\n\twhile(1){\n\t\tif(suf>tt){if(pre>0&&pre%2)f[u]=now[1]+1;else f[u]=0;return f[u]<=mid;}\n\t\tif(suf==tt){if(pre>0&&pre%2)f[u]=0;else f[u]=pre>0?now[1]+1:now[suf]+1;return f[u]<=mid;}\n\t\tif(now[suf]+now[tt]+2<=mid)tt--,suf++;\n\t\telse if(pre>0)tt--,pre--;\n\t\telse if(tt-suf==1){\n\t\t\tif(u==1)return false;\n\t\t\tif(now[tt]+1<=mid){f[u]=now[suf]+1;return f[u]<=mid;}\n\t\t\telse return false;\n\t\t}else return false;\n\t}\n}\nvoid calc(int u,int ff){\n\tint tt=0;\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff)calc(g[i].to,u),tt++;\n\tcnt+=(u==1?(tt+1)/2:tt/2);\n}\nint main(){\n\tscanf(\"%d\",&n);int x,y;\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&x,&y),ins(x,y),ins(y,x);\n\tint l=1,r=1e5,ans=1e5;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(dp(1,1,mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}calc(1,1);printf(\"%d %d\",cnt,ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nint n, ansA, leftover[MAXN];\nvector<int> adj[MAXN];\n\nint getA(int pos, int prev){\n\tint sum = 0;\n\tfor(int i : adj[pos]) if(i != prev){\n\t\tsum += getA(i, pos);\n\t}\n\tif(prev != 0)\n\t\tsum += (adj[pos].size()-1)/2;\n\telse\n\t\tsum += (adj[pos].size()+1)/2;\n\treturn sum;\n}\n\nbool possible(int pos, int prev, int b){\n\tvector<int> lens = {};\n\t// printf(\"Goto %d\\n\", pos);\n\tfor(int i : adj[pos]) if(i != prev){\n\t\tif(!possible(i, pos, b))\n\t\t\treturn false;\n\t\tlens.push_back(leftover[i]+1);\n\t}\n\tsort(lens.begin(), lens.end());\n\t// printf(\"Working with %d (%d)\\n\", pos, lens.size());\n\tmultiset<int> vacant;\n\tfor(int i = lens.size()-1; i >= 0; --i){\n\t\t// printf(\"(%d)\", lens[i]);\n\t\tint comp = b-lens[i];\n\t\tauto lb = vacant.lower_bound(-comp);\n\t\tif(lb != vacant.end()){\n\t\t\tvacant.erase(lb);\n\t\t}else{\n\t\t\tvacant.insert(-lens[i]);\n\t\t}\n\t}\n\t// printf(\"\\n\");\n\tif(vacant.size() > 2)\n\t\treturn false;\n\telse if(vacant.size() == 2){\n\t\tint u = -(*vacant.begin()); vacant.erase(vacant.begin());\n\t\tint v = -(*vacant.begin());\n\t\tif(pos != 1 && u <= b)\n\t\t\tleftover[pos] = v; // Case 2 : Cut one leftover, extend the other\n\t\telse\n\t\t\treturn false;\n\n\t}else if(vacant.size() == 1){\n\t\tleftover[pos] = -(*vacant.begin());\n\t}else{\n\t\tleftover[pos] = 0;\n\t}\n\treturn true;\n}\n\nbool cekB(int b){\n\tmemset(leftover, 0, sizeof leftover);\n\t// printf(\"Ceking %d\\n\", b);\n\treturn (possible(1, 0, b) && leftover[1] <= b);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n-1; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tansA = getA(1, 0);\n\n\t// TODO: Get B!\n\tint L = 1, R = n;\n\twhile(L < R){\n\t\tint mid = (L+R)/2;\n\t\tif(cekB(mid)){\n\t\t\tR = mid;\n\t\t}else{\n\t\t\tL = mid+1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ansA, L);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, cnt;\nint f[N];\nint sum[N];\nbool flag;\nvector<int> G[N];\n\nvoid dfs(int u, int p, int x) {\n\tvector<int> go;\n\tfor (auto v : G[u]) {\n\t\tif (v == p) continue;\n\t\tdfs(v, u, x), go.push_back(f[v] + 1);\n\t}\n\tint sz = go.size();\n\tbool even = 0;\n\tcnt += sz / 2;\n\tif (sz % 2 == 0) go.push_back(0), sz++, even = 1;\n\telse if (u == 1) cnt++;\n\tsort(go.begin(), go.end());\n\t// bubbletea prevoi 2017\n\tfor (int i = 0; i < sz; ++i) sum[i] = 0;\n\tfor (int i = 0; i <= sz / 2; ++i) {\n        if (i < sz - i - 2 && sz - i - 2 < sz) {\n            if (go[i] + go[sz - i - 2] > x) sum[sz - i - 1]++;\n        }\n        if (i < sz - i - 1 && sz - i - 1 < sz) {\n            if (go[i] + go[sz - i - 1] > x) sum[i + 1]++, sum[sz - i - 1]--;\n        }\n        if (i < sz - i && sz - i < sz) {\n            if (go[i] + go[sz - i] > x) sum[0]++, sum[i]--;\n        }\n\t}\n\tfor (int i = 1; i < sz; ++i) sum[i] += sum[i - 1];\n\tfor (int i = 0; i < sz; ++i) {\n\t\tif (u == 1 && even && go[i]) continue;\n\t\tif (!sum[i] && go[i] <= x) { f[u] = go[i]; return; }\n\t}\n\tflag = 1;\n}\n\nint check(int x) {\n\tflag = cnt = 0, dfs(1, 1, x); \n\treturn (!flag) ? cnt : 0;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tint l = 1, r = n;\n\twhile (l < r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (check(mid)) r = mid; else l = mid + 1;\n\t}\n\tcout << check(l) << ' ' << l;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define rsz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...); }\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...); }\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); }\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\"); }\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n\t#ifdef TQIAN\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n\t#else\n\t#define dbg(x...) 0\n\t#endif\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n\t\treturn *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nint n; vector<vi> par, adj; vi depth;\nvoid init(int _N) {\n    n = _N;\n    int d = 1; while ((1<<d) < n) d ++;\n    par.assign(d,vi(n)); adj.resz(n); depth.resz(n);\n}\nvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\nvoid dfs(int x = 0) {\n    FOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n    trav(y,adj[x]) if (y != par[0][x])\n        depth[y] = depth[par[0][y] = x]+1, dfs(y);\n}\nvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\nint jmp(int x, int d) {\n    F0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n    return x; }\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x,y);\n    x = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n    R0F(i,sz(par)) {\n        int X = par[i][x], Y = par[i][y];\n        if (X != Y) x = X, y = Y;\n    }\n    return par[0][x];\n}\nint dist(int x, int y) { // # edges on path\n    return depth[x]+depth[y]-2*depth[lca(x,y)]; }\n/// edges numbered 1 to n-1 inclusive\nbool vis[MAX];\nvi edges;\nint ans = 1;\nvoid dfs_vert(int src){\n    if(sz(adj[src])%2 == 1) return;\n    for(int nxt: adj[src]){\n        /// src to nxt\n        int val = (depth[src]<depth[nxt] ? nxt:src);\n        if(vis[val]) continue;\n        vis[val] = true;\n        edges.eb(val);\n        dfs_vert(nxt);\n    }\n}\nint dep[MAX];\nbool ok;\nbool check_even(vi& v, int rid, int mx){\n    int l = 0;\n    int r = sz(v) - 1;\n    while(l<=r){\n        if(l == rid) l++;\n        if(r == rid) r--;\n        if(l>r) return true;\n        if(v[l] + v[r]>mx) return false;\n        l++; r--;\n    }\n    return true;\n}\nint solve_even(vi & legs, int mx){\n    int lo = 0;\n    int hi = sz(legs) - 1;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        if(check_even(legs, mid, mx)) hi = mid;\n        else lo = mid+1;\n    }\n    if(check_even(legs, lo, mx)) return legs[lo];\n    else if(check_even(legs, hi, mx)) return legs[hi];\n    else{\n        ok = false;\n        return legs.back();\n    }\n}\nint solve_odd(vi & legs, int mx){\n    int l = 0;\n    int r = sz(legs) - 1;\n    bool good = true;\n    while(l<=r){\n        if(legs[l]+legs[r]>mx) {\n            good = false; break;\n        }\n        l++; r--;\n    }\n    if(good) return 0;\n    int id = -1;\n    f0r(i, sz(legs)) if(legs[i]<=mx) id = i;\n    if(id == -1){\n        ok = false;\n        return legs.back();\n    }\n    legs.erase(legs.begin()+id);\n    return solve_even(legs, mx);\n}\nint root;\nint dfs_solve(int src, int par, int mx){\n    if(sz(adj[src]) == 1 && src != root) return 0;\n    vi legs;\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        legs.eb(dfs_solve(nxt, src, mx)+1);\n    }\n    sort(all(legs));\n    if(legs.back()>mx){\n        ok = false;\n        return legs.back();\n    }\n    if(src == root){\n        if(sz(adj[src])%2 == 0){\n            int l = 0;\n            int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx){\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        else{\n            if(sz(adj[src]) == 1){\n                if(legs.back()>mx) ok = false;\n                return legs.back();\n            }\n            int id = -1;\n            f0r(i, sz(legs)) if(legs[i]<=mx) id = i;\n            if(id == -1){\n                ok = false;\n                return legs.back();\n            }\n            legs.erase(legs.begin()+id);\n            int l = 0; int r = sz(legs)-1;\n            while(l<=r){\n                if(legs[l]+legs[r]>mx) {\n                    ok = false; break;\n                }\n                l++; r--;\n            }\n        }\n        return legs.back();\n\n    }\n    if(sz(adj[src])%2 == 0) return solve_even(legs, mx);\n    else return solve_odd(legs, mx);\n}\nint main(){\n    re(n);\n    init(n);\n    f0r(i, n-1){\n        int u, v; re(u, v); u--; v--;\n        ae(u, v);\n    }\n    gen();\n    int ed = 0;\n    f0r(i, n) if(sz(adj[i])%2 == 1) ed++;\n    int a = ed/2;\n    int lo = 1;\n    int hi = MAX;\n    root = 0;\n    while(hi-lo>1){\n        int mid = (lo+hi)/2;\n        ok = true;\n        dfs_solve(root, -1, mid);\n        if(ok) hi = mid;\n        else lo = mid+1;\n    }\n    ok = true;\n    dfs_solve(root, -1, lo);\n    if(ok) ckmax(ans, lo);\n    else ckmax(ans, hi);\n    ps(a, ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nll f[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        st.insert(sum[v]+1);\n    }\n    while(st.size())\n    {\n        int x=*st.rbegin();\n        st.erase(st.find(x));\n        if(st.size()==0)\n        {\n            if(x+1<=m) sum[u]=x;\n            else f[u]++;\n            break;\n        }\n        it=st.upper_bound(m-x);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;st.erase(st.find(*it));\n        }\n    }\n    if(u==1&&sum[u]) f[u]++;\n}\nint main()\n{\n    freopen(\"15.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=1,r=n,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        bool flag=false;\n        for(int i=1;i<=3;i++)\n        {\n            int x=rand()%n+1;\n            dfs(x,0,m);\n            if(f[x]<=dp[1])\n            {\n                flag=true;break;\n            }\n        }\n        if(flag) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n//#ifdef LOCAL\n//#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n//#else\n//#define NDEBUG\n//#define eprintf(...) do {} while (0)\n//#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t, st;\n\nbool ok(int mid) {\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    if (dp[*e]+1 > mid) return false;\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (v == 0) {\n\t    int m = t.size()/2;\n\t    sort(t.begin(), t.end());\n\t    REP (j, m) if (t[j] + t[m*2-1-j] > mid) return false;\n\t    if (t.size() % 2 && t.back() > mid) return false;\n\t    return true;\n\t} else {\n\t    if (t.size() % 2 == 0) t.push_back(0);\n\t    sort(t.begin(), t.end());\n\t    st.clear();\n\t    int pos = 0;\n\t    dp[v] = -1;\n\t    for (int j=t.size()-1; pos<=j; j--) {\n\t\tint c = t[j];\n\t\twhile (pos < j && t[pos] + c <= mid) {\n\t\t    st.push_back(t[pos]);\n\t\t    pos++;\n\t\t}\n\t\tif (st.empty()) {\n\t\t    if (dp[v] == -1) dp[v] = c;\n\t\t    else return false;\n\t\t} else {\n\t\t    assert(st.size());\n\t\t    assert(st.back() + c <= mid);\n\t\t    st.pop_back();\n\t\t}\n\t    }\n\n\t    if (dp[v] == -1) {\n\t\tassert(st.size() == 1u);\n\t\tdp[v] = st.back();\n\t    } else if (!st.empty()) {\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    assert(false);\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += ((int)G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n        if (dp[u]+1>k){\n            p1=1;\n            return ;\n        }\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n   vector <int> y;\n    while(s.size()>1){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n\n                y.pb(val1);\n                continue;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()){\n        y.pb(*s.begin());\n    }\n    if (y.size()>2){\n        p1=1;\n        return ;\n    }\n    if (y.size()){\n        sort(y.begin(),y.end());\n        for (int i=1;i<y.size();i++) z++;\n        dp[v]=y[0];\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    dfs(1,1,r);\n    ll o=z;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1 && z==o) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 1500000;\nconst int K = 50 ;\nvector < int > g[N];\npair < int, int > dfs1(int v, int p = -1){\n    int c = 0;\n    int res = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto x = dfs1(u, v);\n        c += x.F;\n        res += x.S;\n    }\n    res -= c / 2;\n    c %= 2;\n    if (c == 0 && p != -1){\n        c++;\n        res++;\n    }\n    return {c, res};\n}\npair < int, int > dfs2(int v, int x, int p = -1){\n    multiset < int > t;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        auto y = dfs2(u, x, v);\n        if (y.S == 0) return {0, 0};\n        t.insert(y.F);\n    }\n    if (t.size() == 0){\n        return {1, 1};\n    }\n    if (t.size() == 1){\n        return {*t.begin() + 1, (*t.begin() + 1 <= x)};\n    }\n    while(t.size() > 1){\n        auto y = t.end();\n        y--;\n        if ((*t.begin()) + (*y) > x){\n            return {0, 0};\n        }\n        auto z = t.upper_bound(x - (*y));\n        while(z == t.end() || z == y) z--;\n        if (z == y) z--;\n        int v1 = *z;\n        int v2 = *y;\n        t.erase(t.find(v1));\n        t.erase(t.find(v2));\n    }\n    if (t.size() == 0){;\n        return {1, 1};\n    }\n    return {*t.begin() + 1, (*t.begin() + 1 <= x)};\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    int ans1 = dfs1(1).S;\n    int l = 0;\n    int r = n + 1;\n    while(r - l > 1){\n        int mid = (r + l) / 2;\n        if (dfs2(1, mid).F){\n            r = mid;\n        } else{\n            l = mid;\n        }\n    }\n    cout << ans1 << \" \" << r;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int MAXN = (int) 1e5 + 10;\nint n;\nvector<int> adj[MAXN];\n\nint DFS(int u, int T, int par = -1) {\n    vector<int> a;\n    for (int i = 0; i < (int) adj[u].size(); ++i) {\n        int v = adj[u][i];\n        if (v != par) a.push_back(DFS(v, T, u));\n    }\n    if ((int) a.size() % 2 == 0) a.push_back(0);\n    sort(a.begin(), a.end());\n\n    int l = 0, r = (int) a.size() - 1, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        vector<int> b;\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (i != mid) b.push_back(a[i]);\n        bool check = true;\n        for (int i = 0; i < (int) b.size() / 2; ++i) {\n            if (b[i] + b[(int) b.size() - i - 1] > T) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (f == -1) {\n        return T + 3;\n    }\n    return a[f] + 1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int l = 1, r = n, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (DFS(1, mid) <= mid + 1) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) cnt += (int) adj[i].size() % 2;\n\n    assert(f != -1);\n    printf(\"%d %d\\n\", cnt / 2, f);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt, lo, hi, mi, ta, tb;\nvector< int > v[100005];\nmultiset< int > mm;\nmultiset< int >::iterator it;\n\nint dfs(int a, int b) {\n\tmultiset< int > re = multiset< int >();\n\tfor (int i = 0; i < v[a].size(); i++)\n\t\tif (v[a][i] != b) {\n\t\t\tint tt = dfs(v[a][i], a);\n\t\t\tif (tt == -1 || tt + 1 > mi) {\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tre.insert(tt + 1);\n\t\t}\n\tint ret = 0;\n\t//printf(\"%d:\", a); for (it = re.begin(); it != re.end(); it++) printf(\" %d\", *it); printf(\"\\n\");\n\tmm = re;\n\twhile (!re.empty()) {\n\t\tit = re.end();\n\t\tit--;\n\t\tta = *it;\n\t\tre.erase(ta);\n\t\tit = re.upper_bound(mi - ta);\n\t\tif (it == re.begin()) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = ta;\n\t\t\telse {\n\t\t\t\tif (mm.size() % 2 == 0) {\n\t\t\t\t\tre = mm;\n\t\t\t\t\tit = re.end();\n\t\t\t\t\tit--;\n\t\t\t\t\tre.erase(it);\n\t\t\t\t\tret = 0;\n\t\t\t\t\twhile (!re.empty()) {\n\t\t\t\t\t\tit = re.end();\n\t\t\t\t\t\tit--;\n\t\t\t\t\t\tta = *it;\n\t\t\t\t\t\tre.erase(ta);\n\t\t\t\t\t\tit = re.upper_bound(mi - ta);\n\t\t\t\t\t\tif (it == re.begin()) {\n\t\t\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\t\t\tret = ta;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tre.clear();\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tit--;\n\t\t\t\t\t\t\tre.erase(it);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"ret %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tre.clear();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tit--;\n\t\t\tre.erase(it);\n\t\t}\n\t}\n\t//printf(\"re %d\\n\", ret);\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tv[ta].push_back(tb);\n\t\tv[tb].push_back(ta);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt += v[i].size() % 2;\n\tlo = 1, hi = n + 1;\n\twhile (lo < hi) {\n\t\tmi = (lo + hi) / 2;\n\t\t//printf(\"mi %d\\n\", mi);\n\t\tif (dfs(1, 0) != -1)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\tprintf(\"%d %d\\n\", cnt / 2, lo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int INF = 100005;\nint N;\nvi G[100005];\nvi va[100005];\n\nint bin(vi &a, int r, int lim) {\n    auto g = [&](int mid) {\n        int i = 0, j = r - 1;\n        for (int k = 0; k < r / 2;) {\n            if (i == mid) i++;\n            else if (j == mid)j--;\n            else {\n                k++;\n                if (a[i++] + a[j--] > lim) {\n                    RT 0;\n                }\n            }\n        }\n        RT 1;\n    };\n\n    if (!g(r - 1))RT - 1;\n\n    int ok = r - 1, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        (g(mid) ? ok : ng) = mid;\n    }\n\n    RT ok;\n}\n\nint f(int u, int p, int lim) {\n    int C = sz(G[u]) - 1;\n\n    auto &a = va[u];\n    if (sz(a) < C) {\n        a.reserve(C);\n        a.resize(C);\n    }\n\n    for (int i = 0, j = 0; i < sz(G[u]); ++i) {\n        int v = G[u][i];\n        if (v != p) {\n            a[j++] = f(v, u, lim);\n        }\n    }\n    sort(all(a));\n    if (sz(a) && a.back() > lim)RT INF;\n\n    if (C % 2) {\n        int k = bin(a, C, lim);\n        if (k == -1)RT INF;\n        RT a[k] + 1;\n    } else {\n        int chk = 1;\n        rep(i, C / 2) {\n            if (a[i] + a[C - 1 - i] > lim) {\n                chk = 0;\n                break;\n            }\n        }\n        if (chk)RT 1;\n\n        int k = bin(a, C - 1, lim);\n        if (k == -1 || u == 1)RT INF;\n\n        RT a[k] + 1;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    cin >> N;\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    int A = 0;\n    rep(i, N + 1)A += sz(G[i]) & 1;\n    A /= 2;\n    G[1].push_back(0);\n\n    int ng = 0, ok = N;\n    while (ok - ng > 1) {\n        int mid = (ng + ok) / 2;\n        int re = f(1, 0, mid);\n        (re - 1 <= mid ? ok : ng) = mid;\n    }\n    \n    int B = ok;\n    cout << A << ' ' << B << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint in[MAX_N];\nvi G[MAX_N];\nint dp[MAX_N];\nint M;\n\nvoid dfs(int v, int p) {\n\tvector<int> vec;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(n == p) continue;\n\t\tdfs(n, v);\n\t\tif(dp[n] != -1) vec.pb(dp[n] + 1);\n\t}\n\tif(in[v] % 2) vec.pb(0);\n\tsort(all(vec)); reverse(all(vec));\n\tint rv = 0;\n\trep(i, 0, sz(vec) - 1) {\n\t\tif(vec[i] == inf) continue;\n\t\tif(rv < i) rv = i;\n\t\tint p = i;\n\t\tif(vec[i] + vec[i + 1] <= M) {\n\t\t\tp = i + 1;\n\t\t}\n\t\telse {\n\t\t\twhile(rv < sz(vec) - 1 && vec[i] + vec[rv + 1] > M) {\n\t\t\t\trv++;\n\t\t\t\tif(rv + 1 < sz(vec) && vec[rv + 1] + vec[i] <= M) {\n\t\t\t\t\tp = rv + 1;\n\t\t\t\t}\n\t\t\t\tif(rv == sz(vec) - 1) break;\n\t\t\t}\n\t\t}\n\t\tif(p != i) {\n\t\t\tvec[p] = inf;\n\t\t\tvec[i] = inf;\n\t\t}\n\t}\n\trep(i, 0, sz(vec)) {\n\t\tif(vec[i] != inf) {\n\t\t\tif(dp[v] == -1) dp[v] = vec[i];\n\t\t\telse dp[v] = M + 1;\n\t\t}\n\t}\n}\n\nbool ok(int m) {\n\tM = m;\n\tmemset(dp, -1, sizeof(dp));\n\tdfs(0, -1);\n\tif(dp[0] == -1) return true;\n\telse return false;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tin[a]++; in[b]++;\n\t}\n\tint A = 0;\n\trep(i, 0, N) {\n\t\tA += in[i] % 2;\n\t}\n\tint lv = 0, rv = N;\n\twhile(rv - lv > 1) {\n\t\tint m = (lv + rv) / 2;\n\t\tif(ok(m)) rv = m;\n\t\telse lv = m;\n\t}\n\tcout << A / 2 << \" \" << rv << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=1001000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tint cnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tmit it;\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tint w=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n-1,d=1;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d+1);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n    while(s.size()>2){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n          //  cout << *s.begin() << \" sf \" << val1 << endl;\n            p1=1;\n            break;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()==2){\n        if (*s.begin()+*s.rbegin()>k){\n            if (v==1){\n                p1=1;\n                return ;\n            }\n            else{\n                z++;\n                dp[v]=*s.begin();\n            }\n        }\n        else{\n            z++;\n        }\n    }\n    else if (s.size()){\n        dp[v]=*s.begin();\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=100010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,flag,len;\nint bgn[N],nxt[N<<1],to[N<<1],E;\nint dp[N],f[N],dis[N];\nmultiset<int>G[N];\nmultiset<int>::iterator gt,gtt;\ninline void add_edge(int u,int v){nxt[++E]=bgn[u],bgn[u]=E,to[E]=v;}\ninline void dfs(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tdfs(v,u);\n\t\tson++;\n\t\tdp[u]+=dp[v];\n\t}\n\tdp[u]+=(son+(u==1))/2;\n}\ninline int dfs_ans(int u,int f)\n{\n\tint son=0;\n\tfor(int v,i=bgn[u];i;i=nxt[i])\n\t{\n\t\tif((v=to[i])==f)continue;\n\t\tint x=dfs_ans(v,u)+1;\n\t\tG[u].insert(x);\n\t\tif(!x)flag=0;\n\t\tif(x>len)flag=0;\n\t\tif(!flag)return 0;\n\t\tson++;\n\t}\n\tint res=u==1?son&1:son&1?1:2;\n\t//printf(\"%d %d\\n\",u,res);\n\twhile(!G[u].empty())\n\t{\n\t\tgt=G[u].end();--gt;\n\t\tgtt=G[u].upper_bound(len-*gt);\n\t\tif(gtt==G[u].begin()||SZ(G[u])==1)\n\t\t{\n\t\t\tif(!res){flag=0;return 0;}\n\t\t\tdis[u]=*gt;\n\t\t\tres--;\n\t\t\tG[u].erase(gt);\n\t\t\tcontinue;\n\t\t}\n\t\t--gtt;\n\t\tif(gt==gtt)gtt--;\n\t\tG[u].erase(gtt);\n\t\tgt=G[u].end();--gt;\n\t\tG[u].erase(gt);\n\t}\n\treturn dis[u];\n}\ninline bool check(int x)\n{\n\t//printf(\"%d:\\n\",x);\n\tFor(i,1,n){G[i].clear();dis[i]=0;}\n\tflag=1;\n\tlen=x;\n\tdfs_ans(1,0);\n\treturn flag;\n}\nint main()\n{\n\tint x,y;\n\tread(n);\n\tFor(i,2,n)\n\t{\n\t\tread(x),read(y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs(1,0);\n\tint l=1,r=n;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",dp[1],ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = (2 << 16), LG = 18, INF = 1e9 * 1e6;\nll n, m;\nll grid[LG][LG], inter[SZ], dp[SZ], mx[SZ];\n\nint main() {\n\tfastInp;\n\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < LG; i++) {\n\t\tfor (int j = 0; j < LG; j++) grid[i][j] = INF;\n\t}\n\n\tll sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tll u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tsum += c;\n\t\tu--; v--;\n\t\tgrid[u][v] = c;\n\t\tgrid[v][u] = c;\n\t}\n\n\tll pw = (1ll << n);\n\tfor (int i = 0; i < pw; i++) {\n\t\tll cur = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif (((i >> k) & 1) && ((i >> j) & 1) && grid[k][j] != INF) {\n\t\t\t\t\tcur += grid[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinter[i] = cur;\n\t}\n\n\tfor (int i = 0; i < pw; i++) {\n\t\tfor (int j = 0; j < LG; j++) dp[i] = -INF;\n\t}\n\n\tfor (int i = 0; i < LG; i++) dp[(1ll << i)] = 0;\n\tdp[1] = 0;\n\tfor (int i = 2; i < pw; i++) {\n\t\tfor (int j = 0; j < LG; j++) {\n\t\t\tfor (int k = 0; k < LG; k++) {\n\t\t\t\tif (j != k && (i & (1ll << k)) && (i & (1ll << j)) && grid[j][k] != INF) {\n\t\t\t\t\tll msk = i ^ (1ll << j);\n\t\t\t\t\tdp[i] = max(dp[i], dp[msk] + grid[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = -INF;\n\n\tfor (int i = 0; i < pw; i++) {\n\t\tif (!(i & 1)) continue;\n\t\tif (!((i >> (n - 1)) & 1)) continue;\n\t\tfor (int sub = i; true; sub = ((sub - 1) & i)) {\n\t\t\tfor (int j = 0; j < LG; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\tll msk = (i ^ sub);\n\t\t\t\t\tif ((msk & 1) && ((msk >> (n - 1)) & 1)) dp[i] = max(dp[i], dp[msk] + inter[sub | (1ll << j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sub == 0) break;\n\t\t}\n\t\tans = max(ans, dp[i]);\n\t}\n\n\tcout << sum - ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (100006)\nll n;\npi dp[MAXN];\nvector<int>v[MAXN];\nbool tryy(ll i,bool b){\n\tfunction<void(ll,ll,ll)>dfs=[&](ll x,ll p,ll d){\n\t\tdp[x]=pi(0,0);\n\t\tmultiset<ll,greater<ll>> s;\n\t\tfor(auto i:v[x]) if(i^p) {\n\t\t\tdfs(i,x,d), dp[x].f += dp[i].f;\n\t\t\tif(dp[i].s+1==d){\n\t\t\t\t++ dp[x].f;\n\t\t\t}else{\n\t\t\t\ts.ins(dp[i].s);\n\t\t\t}\n\t\t}\n\t\twhile(s.size()>1){\n\t\t\tll y=*s.begin();\n\t\t\tauto other=s.lower_bound(d-y-1);\n\t\t\tif(other==s.end()) break;\n\t\t\tif(other==s.begin())++other;\n\t\t\tassert(y+*other+1 <= d);\n\t\t\ts.erase(other), s.erase(s.begin());\n\t\t\t++dp[x].f;\n\t\t}\n\t\tif(s.size())dp[x].f+=s.size()-1, dp[x].s=(*--s.end())+1;\n\t\telse dp[x].s = x != 1;\n\t\tif(x==1){\n\t\t\tif(dp[x].s) ++ dp[x].f, dp[x].s=0;\n\t\t}\n\t};\n\tauto bstar=[&](ll x){\n\t\tdfs(1,1,x);\n\t\treturn dp[1].f <= i;\n\t};\n\tll st=1, en=n+1;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(bstar(mid))en=mid;\n\t\telse st=mid;\n\t}\n\tif(en==n+1) return 0;\n\tif(b) cout<<i<<' '<<en-1<<'\\n';\n\treturn 1;\n}\nint main(){\n\tFAST\n\tcin>>n;\n\tFOR(i,0,n-2){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tv[a].eb(b), v[b].eb(a);\n\t}\n\tll st=0, en=100;\n\twhile(en-st>1){\n\t\tll mid=(st+en)>>1;\n\t\tif(tryy(mid,0))en=mid;\n\t\telse st=mid;\n\t}assert(en^100);\n\ttryy(en,1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n  \nvii G(100010);\nint root;\n\n\nint dfs(int now, int par, int& leaf, int max_len) {\n  vi child_len;\n  rep (i, G[now].size()) {\n    int child = G[now][i];\n    if (child == par) continue;\n    int len = dfs(child, now, leaf, max_len);\n    if (len == -1) return -1;\n    child_len.push_back(len);\n  }\n  if (child_len.size() == 0) {\n    leaf++;\n    return 1;\n  }\n  if (child_len.size() % 2 == 0) {\n    leaf++;\n    child_len.push_back(0);\n  }    \n  sort(all(child_len));\n  multiset<int> st;\n  rep (i, child_len.size()) {\n    st.insert(-child_len[i]);\n  }\n  int safe = 1;\n  int temp;\n  rrep (i, child_len.size()) {\n    if (!st.count(-child_len[i])) continue;\n    int len1 = child_len[i];\n    auto itr = st.lower_bound(-len1);\n    st.erase(itr);\n    itr = st.lower_bound(-(max_len - len1));\n    if (itr != st.end()) {\n      int len2 = -*itr;\n      st.erase(itr);\n    }\n    else {\n      safe--;\n      temp = len1;\n      if (safe < 0) return -1;\n    }\n  }\n  if (now != root) {\n    if (temp + 1 <= max_len) {\n      return temp + 1;\n    }\n    else {\n      return -1;\n    }\n  }\n  else {\n    if (temp <= max_len) {\n      return temp;\n    }\n    else {\n      return -1;\n    }\n  }\n}\n\nint check(int root, int max_len) {\n  int leaf = 0;\n  int res = dfs(root, -1, leaf, max_len);\n  if (res < 0) return -1;\n  else return (leaf + 1) / 2;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  rep (i, n - 1) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  rep (i, n) {\n    if (G[i].size() == 1) {\n      root = i;\n      break;\n    }\n  }\n  int ng = 0, ok = 2*n, a = 10;\n  while (ng + 1 < ok) {\n    int mid = (ng + ok) / 2;\n    int res = check(root, mid);\n    if (res == -1) {\n      ng = mid;\n    }\n    else {\n      a = res;\n      ok = mid;\n    }\n  }\n  cout << a << \" \" << ok << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nint n;\nvector<vector<int>>hen;\nvector<int>ki;//is kisu\nint solve(int ter,int oya,int bgen){\n\t//解きます\n\t//cerr<<ter<<endl;\n\tmultiset<int>soi;\n\tif(ki[ter]){soi.ins(0);}\n\tfor(auto it:hen[ter]){\n\t\tif(it==oya){continue;}\n\t\tint kae=solve(it,ter,bgen);\n\t\tif(kae==-1){return -1;}\n\t\tsoi.ins(kae);\n\t}\n\t//bgen未満を作る貪欲法\n\t//soiは1あまる\n\t//setで殴りすぎlogがひどい\n\twhile(soi.size()>1){\n\t\tint mae=*prev(soi.end());\n\t\tauto itr=soi.upper_bound(bgen-mae);\n\t\tif(itr==soi.begin()){return -1;}//ないので\n\t\tsoi.era(prev(soi.end()));\n\t\tsoi.era(prev(itr));\n\t}\n\tif(oya!=-1){return (*soi.begin())+1;}\n\telse{return 0;}\n}\nint main(void){\n\tint i;\n\tcin>>n;hen.res(n);ki.res(n);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\then[a].pub(b);ki[a]=(!ki[a]);\n\t\then[b].pub(a);ki[b]=(!ki[b]);\n\t}\n\tint A=0,ha=-1;\n\tfor(i=0;i<n;i++){if(ki[i]){A++;}if(hen[i].size()==1){ha=i;}}\n\tcout<<A/2<<\" \";\n\tint bmax=n,bmin=0;\n\twhile(bmax-bmin>1){\n\t\tint bgen=(bmax+bmin)/2;\n\t\tif(solve(ha,-1,bgen)!=-1){bmax=bgen;}\n\t\telse{bmin=bgen;}\n\t}\n\tcout<<bmax<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst int INF = 100000000;\nconst ll MOD = 1000000007;\n\nint n;\nvector<int> e[100000];\nint ansa = 1;\n\nbool checker(vector<int> vec, int mid, int x) {\n    int i = 0, j = vec.size()-1;\n    bool ok = true;\n    rep(_,vec.size()/2) {\n        if (i == mid) i++;\n        if (j == mid) j--;\n        if (vec[i]+vec[j] > x) {\n            ok = false;\n            break;\n        }\n        i++; j--;\n    }\n    return ok;\n}\n\nint dfs(int v, int par, int x) {\n    vector<int> vec;\n    rep(i,e[v].size()) {\n        if (e[v][i] == par) continue;\n        int z = dfs(e[v][i], v, x);\n        if (z == INF) {\n            return INF;\n        }\n        vec.push_back(z);\n    }\n    if (vec.size() == 0) {\n        return 1;\n    }\n    if (vec.size() == 1) {\n        return vec[0]+1;\n    }\n    sort(vec.begin(), vec.end());\n    if (vec.size()%2 == 0) {\n        bool ok = true;\n        rep(i,vec.size()/2) {\n            if (vec[i]+vec[vec.size()-1-i] > x) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return 1;\n        }\n        if (vec[vec.size()-1] > x) return INF;\n        vec.pop_back();\n    }\n    int st = -1, en = vec.size(), mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (checker(vec, mid, x)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    if (en == vec.size()) {\n        return INF;\n    }\n    return vec[en]+1;\n}\n\nbool solve(int x) {\n    int z = dfs(0, 0, x);\n    if (z-1 > x) return false;\n    return true;\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n    rep(i,n) {\n        if (e[i].size() > 2) {\n            ansa += (e[i].size()-2+1)/2;\n        }\n    }\n    int st = 1, en = n, mid;\n    while (en-st > 1) {\n        mid = (st+en)/2;\n        if (solve(mid)) {\n            en = mid;\n        } else {\n            st = mid;\n        }\n    }\n    cout << ansa << \" \" << en << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll dp[N];\nll p1=0;\nll z=0;\nvoid dfs(ll v,ll p,ll k){\n    multiset <int> s;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfs(u,v,k);\n        s.insert(dp[u]+1);\n    }\n    if (p1) return ;\n   // if (v==1) cout << s.size() << \" end \" << endl;\n    while(s.size()>2){\n        auto t=s.end();\n        t--;\n        ll val1=*t;\n        s.erase(t);\n        if (*s.begin()+val1>k){\n          //  cout << *s.begin() << \" sf \" << val1 << endl;\n            p1=1;\n            break;\n        }\n        t=s.upper_bound(k-val1);\n        t--;\n        s.erase(t);\n        z++;\n    }\n    if (s.size()==2){\n        if (*s.begin()+*s.rbegin()>k){\n            if (v==1){\n                p1=1;\n                return ;\n            }\n            else{\n                z++;\n                dp[v]=*s.begin();\n            }\n        }\n        else{\n            z++;\n        }\n    }\n    else if (s.size()){\n        dp[v]=*s.begin();\n        if (v==1) z++;\n    }\n    if (dp[1]>k) p1=1;\n}\nint32_t main(){\n    sync;\n    ll n;\n    cin >> n;\n    for (int i=1;i<n;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=0,r=n+10;\n    while(r-l>1){\n        memset(dp,0,sizeof dp);\n        p1=0;\n        ll mid=(r+l)/2;\n        z=0;\n        dfs(1,1,mid);\n        if (!p1) r=mid;\n        else l=mid;\n        //cout << z << \" f \" << mid << endl;\n    }memset(dp,0,sizeof dp);\n    z=0;\n    p1=0;\n    dfs(1,1,r);\n    cout << z << \" \" << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nint a_dfs(const Graph& g, const int s)\n{\n    const int C = g.edge[s].size();\n    int sum = C / 2;\n    for (const int to : g.edge[s]) {\n        sum += a_dfs(g, to);\n    }\n    return sum;\n}\n\nint K;\nbool check(const vector<int>& a, const int ng, const int size)\n{\n    int tail = size - 1;\n    for (int i = 0; i < size; i++, tail--) {\n        if (tail == ng) {\n            tail--;\n        }\n        if (i == ng) {\n            i++;\n        }\n        if (tail <= i) {\n            break;\n        }\n        const int sum = a[i] + a[tail];\n        if (sum + 1 > K) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool b_bfs(const Graph& g, const int s, vector<int>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> l;\n    for (const int to : g.edge[s]) {\n        const bool f = b_bfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        l.push_back(dp[to]);\n    }\n    sort(l.begin(), l.end());\n    if (C % 2 == 1) {\n        int inf = 0;\n        int sup = C;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            if (check(l, mid, C)) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == C or l[sup] + 1 > K) {\n            return false;\n        } else {\n            dp[s] = l[sup] + 1;\n            return true;\n        }\n    } else {\n        if (check(l, C, C)) {\n            dp[s] = 1;\n            return true;\n        } else if (l.back() + 1 > K) {\n            return false;\n        } else {\n            int inf = 0;\n            int sup = C - 1;\n            while (inf < sup) {\n                const int mid = (inf + sup) / 2;\n                if (check(l, mid, C - 1)) {\n                    sup = mid;\n                } else {\n                    if (inf == mid) {\n                        break;\n                    }\n                    inf = mid;\n                }\n            }\n            if (sup == C - 1 or l[sup] + 1 > K) {\n                return false;\n            } else {\n                dp[s] = l[sup] + 1;\n                return true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    vector<int> dim(N, 0);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n        dim[a]++;\n        dim[b]++;\n    }\n    int root = 0;\n    for (; root < N; root++) {\n        if (dim[root] == 1) {\n            break;\n        }\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, root, used);\n    const int A = a_dfs(g, root) + 1;\n\n    vector<int> dp(N, 0);\n    int inf = 0;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        const bool ok = b_bfs(g, root, dp);\n        if (ok) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    b_bfs(g, root, dp);\n    const int B = sup - 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\n\nint dfsA(int v,int pre,Graph &g){\n    int sum=0;\n    int res=0;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=pre){\n            sum++;\n            res+=dfsA(g[v][i],v,g);\n        }\n    }\n    if(v==0){\n        return (sum+1)/2+res;\n    }\n    else{\n        return sum/2+res;\n    }\n}\n\nint dfsB(int v,int pre,int bound,Graph &g){\n    vector<int> len;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=pre) len.push_back(dfsB(g[v][i],v,bound,g)+1);\n    }\n    if(len.size()==0) return 0;\n    sort(len.begin(),len.end());\n    if(v!=0){\n        if(len.size()%2==0){\n            if(len.back()>bound) return bound+1;\n            len.pop_back();\n        }\n        int lb=-1;\n        int ub=len.size();\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            int l=-1,r=len.size();\n            bool isbad=false;\n            while(true){\n                if(l+1!=mid) l++;\n                else l+=2;\n                if(r-1!=mid) r--;\n                else r-=2;\n                if(len.size()<=l) break;\n                isbad|=(len[l]+len[r]>bound);\n            }\n            if(isbad) lb=mid;\n            else ub=mid;\n        }\n        if(ub==len.size()) return bound+1;\n        else return len[ub];\n    }\n    else{\n        if(len.size()%2==1){\n            if(len.back()>bound) return bound+1;\n            len.pop_back();\n        }\n        bool isbad=false;\n        for(int i=0;i<len.size();i++){\n            isbad|=(len[i]+len[len.size()-1-i]>bound);\n        }\n        if(isbad) return bound+1;\n        else return 0;\n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int A=dfsA(0,-1,g);\n    cout<<A<<\" \";\n    int lb=0;\n    int ub=n;\n    while(ub-lb>1){\n        int mid=(ub+lb)/2;\n        int res=dfsB(0,-1,mid,g);\n        if(res<=mid){\n            ub=mid;\n        }\n        else{\n            lb=mid;\n        }\n    }\n    cout<<ub<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n //  cout << n << \" \" << dp[n] << endl;\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\nconst int INF = TEN(9);\n\nV<int> g[maxn];\nint r;\n\nint dfs(int v, int p, int l) {\n\tV<int> vec;\n\tfor (int to : g[v]) if (to != p) {\n\t\tint res = dfs(to, v, l);\n\t\tif (res == -1 || res > l) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(res);\n\t}\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tif (sz % 2 == 1) {\n\t\tfor (int i = 0; i < sz; ++i) {//skip\n\t\t\tV<int> vt;\n\t\t\trep(j, sz) if (j != i) {\n\t\t\t\tvt.pb(vec[j]);\n\t\t\t}\n\n\t\t\tint nl = 0, nr = (int)vt.size() - 1;\n\t\t\tbool f = 1;\n\t\t\trep(i, sz / 2) {\n\t\t\t\tif (vt[nl] + vt[nr] > l) {\n\t\t\t\t\tf = 0;\n\t\t\t\t}\n\t\t\t\t++nl; --nr;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\treturn vec[i] + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t} else {\n\t\t//pair all\n\t\t{\n\t\t\tint nl = 0, nr = (int)vec.size() - 1;\n\t\t\tbool f = 1;\n\t\t\trep(i, sz / 2) {\n\t\t\t\tif (vec[nl] + vec[nr] > l) {\n\t\t\t\t\tf = 0;\n\t\t\t\t}\n\t\t\t\t++nl; --nr;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t//rem 1\n\t\tvec.pop_back();\n\t\t--sz;\n\t\tfor (int i = 0; i < sz; ++i) {//skip\n\t\t\tV<int> vt;\n\t\t\trep(j, sz) if (j != i) {\n\t\t\t\tvt.pb(vec[j]);\n\t\t\t}\n\n\t\t\tint nl = 0, nr = (int)vt.size() - 1;\n\t\t\tbool f = 1;\n\t\t\trep(i, sz / 2) {\n\t\t\t\tif (vt[nl] + vt[nr] > l) {\n\t\t\t\t\tf = 0;\n\t\t\t\t}\n\t\t\t\t++nl; --nr;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\treturn vec[i] + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\t\t\n\t}\n}\n\nbool ok(int l) {\n\tint res = dfs(r, -1, l);\n\t//printf(\"l=%d,res=%d\\n\", l, res);\n\treturn (res != -1);\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\n\trep(i, N) if (g[i].size() == 1) {\n\t\tr = i;\n\t\tbreak;\n\t}\n\n\tint A = 0;\n\trep(i, N) if (g[i].size() % 2 == 1) ++A;\n\n\tint lo = 0, hi = N;\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", A / 2, hi);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,res,A,B,du[N],dp[N],a[N],pre[N],nex[N];\nbool vis[N];\nvi g[N];\n\ninline void rem(int x){\n\tvis[x]=1;\n\tint l=pre[x],r=nex[x];\n\tif(r) pre[r]=l;nex[l]=r;\n}\ninline int solve(int n){\n\tint tag=0;\n\tfor(int i=0;i<n;i++)\n\t\tnex[i]=i+1,pre[i+1]=i;\n\tnex[n]=pre[0]=0;\n\tfor(int i=0;i<=n;i++) vis[i]=0;\n\tfor(int i=n;i;i--){\n\t\tif(vis[i]) continue;\n\t\twhile(nex[tag]&&a[nex[tag]]+a[i]+1<=B) tag=nex[tag];\n\t\tif(tag==i) tag=pre[tag];\n\t\tif(!tag) return a[i];\n\t\trem(i);rem(tag);\n\t\ttag=pre[tag];\n\t}\n}\n\ninline void dfs(int x,int F=0){\n\tbool isok=0;\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tdfs(y,x);isok=1;\n\t}\n\tif(!isok){dp[x]=1;return;}\n\tm=0;\n\tfor(int y:g[x])\n\t\tif(y!=F) a[++m]=dp[y];\n\tsort(a+1,a+m+1);\n\tint ret=0;\n\tfor(int l=1,r=m;l<r;r--)\n\t\tif(a[l]+a[r]+1<=B) l++,ret++;\n\tif(ret*2==m){res+=ret;dp[x]=1;return;}\n\tres+=m-ret-1;\n\tint p=solve(ret*2+1);\n\tif(p+1==B) res++,dp[x]=1; else dp[x]=p+1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"08.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;dfs(1);if(dp[1]!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector< int > g[100000];\nint dp[100000];\n\nbool rec(int idx, int par, int length)\n{\n  vector< int > vs;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(!rec(to, idx, length)) return (false);\n    if(dp[to] + 1 > length) return (false);\n    vs.push_back(dp[to] + 1);\n  }\n  sort(begin(vs), end(vs));\n\n  auto check = [&](int idx)\n  {\n    deque< int > st;\n    for(int i = 0; i < vs.size(); i++) {\n      if(i == idx) continue;\n      st.push_back(vs[i]);\n    }\n    while(!st.empty()) {\n      if(st.back() + st.front() > length) return (false);\n      st.pop_back();\n      st.pop_front();\n    }\n    return (true);\n  };\n\n  if(vs.size() % 2 == 0) {\n    if(check(-1)) {\n      dp[idx] = 0;\n      return (true);\n    }\n    vs.pop_back();\n  }\n\n  int ok = (int) vs.size(), ng = -1;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n  if(ok == vs.size()) return (false);\n  dp[idx] = vs[ok];\n  return (true);\n}\n\nbool check(int v)\n{\n  int root = -1;\n  for(int i = 0; i < N; i++) {\n    if(g[i].size() & 1) root = i;\n  }\n  return (rec(root, -1, v));\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  int A = 1;\n  for(int i = 0; i < N; i++) {\n    A += g[i].size() & 1;\n  }\n\n  int ok = N, ng = 0;\n  while(ok - ng > 1) {\n    int mid = (ok + ng) / 2;\n    if(check(mid)) ok = mid;\n    else ng = mid;\n  }\n\n  cout << A / 2 << \" \" << ok << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nconst int maxn=1e5+10;\nvector<int> g[maxn];\nint n,deg[maxn],pa[maxn];\nvector<int> dfn;\nvoid dfs(int x,int fa)\n{\n\tdfn.push_back(x);\n\tpa[x]=fa;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint to=g[x][i];\n\t\tif(to==fa)continue;\n\t\tdfs(to,x);\n\t}\n}\nint up[maxn];\nvector<int> son;\nbool check2(int pos,int len)\n{\n\tif(pos>=son.size())return 0;\n//\tif(len==2)\n//\t{\n//\t\tcout<<\"check2 \"<<pos<<\" \"<<len<<\" \"<<son[pos]<<endl;\n//\t}\n\tif(son[pos]+1>len)return 0;\n\tint l=0,r=son.size()-1;\n\tfor(int i=0;i<son.size()/2;i++)\n\t{\n\t\tif(l==pos)l++;\n\t\tif(r==pos)r--;\n\t\tif(son[l]+son[r]>len)return 0;\n\t\tl++,r--;\n\t}\n\treturn 1;\n}\nbool check(int len)\n{\n\tfor(int i=0;i<dfn.size();i++)\n\t{\n\t\tint x=dfn[i];\n\t\tson.clear();\n\t\tfor(int j=0;j<g[x].size();j++)\n\t\t\tif(g[x][j]!=pa[x])\n\t\t\t{\n\t\t//\t\tif(len==2)\n\t\t//\t\t{\n\t\t//\t\t\tcout<<\"wtf \"<<x<<\" \"<<g[x][j]<<\" \"<<up[g[x][j]]+1<<endl;\n\t\t//\t\t}\n\t\t\t\tson.push_back(up[g[x][j]]+1);\n\t\t\t}\n\t\tif(!(son.size()&1))son.push_back(0);\n\t\tsort(son.begin(),son.end());\n\t\tif(len==2)\n\t\t{\n\t//\t\tfor(int j=0;j<son.size();j++)cout<<son[j]<<\" \";\n\t//\t\tcout<<\"!! \"<<x<<endl;\n\t\t}\n\t//\tif(!check2(son.size()-1,len))return 0;\n\t\tint l=-1,r=son.size();//(l,r]\n\t//\tcout<<\"safe here?\\n\";\n\t\twhile(l+1<r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check2(mid,len))r=mid;\n\t\t\telse l=mid;\n\t\t}\n\t\tif(r==son.size()||son[r]>=len)return 0;\n\t\tif(len==2)\n\t\t{\n\t//\t\tcout<<x<<\" \"<<r<<\" \"<<son[r]<<endl;\n\t\t}\n\t\tup[x]=son[r];\n\t}\n\tson.clear();\n\tfor(int i=0;i<g[1].size();i++)son.push_back(up[g[1][i]]+1);\n\tsort(son.begin(),son.end());\n\tif(son.back()>len)return 0;\n\tif(son.size()&1)son.pop_back();\n\tfor(int i=0;i<son.size()/2;i++)\n\t\tif(son[i]+son[son.size()-1-i]>len)return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t\tdeg[a]++;\n\t\tdeg[b]++;\n\t}\n\tint A=n-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tA-=deg[i]/2;\n\t}\n\tdfs(1,0);\n\treverse(dfn.begin(),dfn.end());\n\tdfn.pop_back();\n\tint l=0,r=n;//(l,r]\n\twhile(l+1<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n;\nvector<int> graph[N];\nint root;\nint A, t;\nint beginning;\n\nint find_value(vector<int> &dp, int M)\n{\n    int L = -1, R = dp.size();\n    while (L + 1 < R)\n    {\n        int mid = (L + R) / 2;\n        int j = dp.size() - 1;\n        int t = 1;\n        for (int i = 0; i < j; )\n        {\n            if (i == mid) i++;\n            if (j == mid) j--;\n            if (dp[i] + dp[j] > M) t = 0;\n            i++, j--;\n        }\n        if (t) R = mid;\n        else L = mid;\n    }\n    if (R == dp.size()) return -1;\n    return dp[R];\n}\n\nint dfs(int v, int p, int M)\n{\n    vector<int> dp;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dp.push_back(dfs(u, v, M));\n        if (dp.back() == M)\n        {\n            dp.pop_back();\n            beginning++;\n        }\n    }\n    if (dp.size() % 2 == 0) dp.push_back(0), beginning++;\n    sort(all(dp));\n    int x = find_value(dp, M) + 1;\n    if (x == 0)\n    {\n        beginning += dp.size();\n        x = 1;\n    }\n    if (x == M + 1) x = 1, beginning += 2;\n    //cout << \"vertex \" << v << \" \" << x << \"\\n\";\n    return x;\n}\n\nint check(int M)\n{\n    if (M == 1)\n    {\n        return (A == n - 1);\n    }\n    t = 0;\n    beginning = 0;\n    int cat = dfs(root, root, M);\n    if (cat == 1) beginning--;\n    //cout << \"if M = \" << M << \" \" << beginning << \"\\n\";\n    if ((beginning + 1) / 2 <= A) return 1;\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    int cnt_odd = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (graph[i].size() == 1) root = i;\n        cnt_odd += (graph[i].size() % 2);\n    }\n    cout << (cnt_odd + 1) / 2 << \" \";\n    A = (cnt_odd + 1) / 2;\n    int L = 0, R = n;\n    while (L + 1 < R)\n    {\n        int M = (L + R) / 2;\n        if (check(M)) R = M;\n        else L = M;\n    }\n    cout << R;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\t\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nint OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 1;\n\tint hi = 100001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int N = 300010;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n\nint n, u, v, lng, num, md;\nvector<int> g[N];\npii fn;\n\nint dfs(int u, int p) {\n\tmultiset<int> st;\n\tint nt = 0;\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\t++nt;\n\t\tst.insert(1 + dfs(v, u));\n\t}\n\tnum += nt/2;\n\tvector<int> go;\n\twhile (st.size()) {\n\t\tint bk = (*--st.end());\n\t\tst.erase(st.find(bk));\n\t\tauto it = st.upper_bound(md - bk);\n\t\tif (it != st.begin())\n\t\t\tit--;\n\t\tif (st.size() && *it + bk <= md) {\n\t\t\tlng = max(lng, *it + bk);\n\t\t\tst.erase(it);\n\t\t} else {\n\t\t\tgo.pb(bk);\n\t\t\tlng = max(lng, bk);\n\t\t}\n\t}\n\tsort(go.begin(),go.end());\n\tif(p == -1 && nt%2 == 0 && go.size())lng = oo;\n\tif(nt%2 == 0 && go.size() > 2)lng = oo;\n\tif(nt%2 == 1 && go.size() > 1)lng = oo;\n\tif(!go.size())return 0;\n\treturn go[0];\n}\n\nbool check() {\n\tlng = num = 0;\n\tint res = dfs(1, -1);\n\tlng = max(lng, res);\n\tnum += (res>0);\n\treturn lng <= md;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 1 , hi = 300000, best = -1;\n\twhile (lo <= hi) {\n\t\tmd = (lo + hi) / 2;\n\t\tbool ss = check();\n\t\tif (ss) {\n\t\t\tfn = mp(num, lng);\n\t\t\thi = md - 1;\n\t\t} else {\n\t\t\tlo = md + 1;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", fn.x, fn.y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int nmax = 100010;\nint deg[nmax],dp[nmax];\nbool fix[nmax];\nvector < int > graph[nmax];\nint N,u;\nbool check2(int x,int B, vector<int>& kids)\n{\n\tint l = 0, r = kids.size() - 1;\n\tif((kids[x]+1) > B) return false;\n\twhile( l < r)\n\t{\n\t\tif(l == x) l++;\n\t\tif(r == x) r--;\n\t\tif(l >= r  || r < 0) return true;\n\t\tif((kids[l] + kids[r] )> B) return false;\n\t\tl++,r--;\n\t}\n\treturn true;\n}\nbool dfs(int u, int x)\n{\n\tfix[u] = true;\n\tbool ret = true;\n\t//cout << \"in vertex \" << u << \" trying \" << x << endl;\n\tvector< int > kids;\n\tfor(int i = 0; i < graph[u].size(); ++i)\n\t{\n\t\tif(fix[graph[u][i]]) continue;\n\t\tret&=dfs(graph[u][i],x);\n\t\tkids.push_back(dp[graph[u][i]]);\n\t}\n\tif(!ret) return ret;\n\tif((kids.size()&1)==0) kids.push_back(0);\n\tsort(kids.begin(), kids.end());\n\tint l = 0, r = kids.size() - 1;\n\t\n\t//cout << \"out to \" << u;\n\t//cout << \"\\n\\t\";\n\t//for(int i = 0 ; i < kids.size(); ++i)\n\t//\tcout << kids[i] << ' ';\n\t//cout << endl;\n\tbool isGood = check2(r, x, kids);\n\twhile((r - l) > 1)\n\t{\n\t\tint mid = (r+l) >> 1;\n\t\tif(check2(mid, x, kids))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\n\t}\n\tif(check2(l, x, kids)) r = l;\n\tdp[u] = kids[r]+1;\n\treturn true;\n}\nbool check(int x)\n{\n\tfor(int i = 1;i<=N;++i)dp[i]=N,fix[i]=false;\n\treturn dfs(u,x);\n}\nint bs()\n{\n\tint l = 1, r = N-1;\n\twhile((r-l) > 1)\n\t{\n\t\tint mid = (l+r) >> 1;\n\t\tif(check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n\tif(check(l))\n\t\treturn l;\n\treturn r;\n\n}\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0 ;i < N-1;++i)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tint A=0,B=0;\n\tfor(int i = 1;i<=N;++i)\n\t{\n\t\tif(deg[i]&1) A++;\n\t\tif(deg[i] == 1) u = i;\n\t}\n\tA = (A+1)/2;\n\tcout << A << ' ' << bs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define ele int\nusing namespace std;\n#define maxn 200010\nconst ele INF=1e9;\nstruct edge{\n\tele v;\n\tedge *nxt;\n}ep[maxn<<1],*ecnt;\nele n,d[maxn],f[maxn];\nedge *h[maxn];\ninline void addedge(ele u,ele v){\n\tedge *p=ecnt++;\n\tp->v=v; p->nxt=h[u];\n\th[u]=p;\n}\nvoid dfs(ele p,ele i,ele B){\n\tvector<ele> lst;\n\tfor (edge *j=h[i]; j; j=j->nxt)\n\t\tif (j->v!=p){\n\t\t\tdfs(i,j->v,B);\n\t\t\tlst.push_back(f[j->v]);\n\t\t}\n\tif (lst.size()%2==0) lst.push_back(0);\n\tsort(lst.begin(),lst.end());\n\tf[i]=INF;\n\tfor (int r=0; r<lst.size(); ++r){\n\t\tele u=0,v=lst.size()-1;\n\t\tbool flag=true;\n\t\twhile (u<v){\n\t\t\tif (u==r) ++u;\n\t\t\tif (v==r) --v;\n\t\t\tif (u<v && lst[u]+lst[v]>B){ flag=false; break; }\n\t\t\t++u; --v;\n\t\t}\n\t\tif (flag){ f[i]=lst[r]+1; break; }\n\t}\n}\ninline bool test(ele B){\n\tdfs(-1,0,B);\n\treturn f[0]<=B+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tecnt=ep; memset(h,0,sizeof(h)); memset(d,0,sizeof(d));\n\tfor (int i=0; i<n-1; ++i){\n\t\tele x,y;\n\t\tscanf(\"%d%d\",&x,&y); --x,--y;\n\t\taddedge(x,y); addedge(y,x);\n\t\t++d[x]; ++d[y];\n\t}\n\tele cnt=0;\n\tfor (int i=0; i<n; ++i)\n\t\tif (d[i]&1) ++cnt;\n\tele L=0,R=n-1;\n\twhile (R-L>1){\n\t\tele mid=(L+R)>>1;\n\t\tif (test(mid)) R=mid; else L=mid;\n\t}\n\tprintf(\"%d %d\\n\",cnt/2,R);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool check2(int u, vector<int>& vec, int num, int cri, int& sm)\n{\n    vector<int> vec2;\n    if(num == len(vec)-1){\n        rep(i, len(vec)-2){\n            vec2.pb(vec[i]);\n        }\n        if(vec[num] == cri) return false;\n        dp[u] = vec[num] + 1;\n    }else{\n        rep(i, len(vec)-1){\n            if(i == num) continue;\n            vec2.pb(vec[i]);\n        }\n        if(vec[len(vec)-1] == cri) sm++;\n        if(vec[num] == cri) return false;\n        dp[u] = vec[num] + 1;\n    }\n    rep(i, len(vec2)){\n        if(vec2[i] + vec2[len(vec2)-i-1] + 2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri, int& sm)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri, sm)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        sm += len(vec)/2;\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                dp[u] = 1;\n                sm++;\n                return true;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        sm += len(vec)/2;\n        bool flag = true;\n        rep(i, len(vec)){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            dp[u] = 0;\n            return true;\n        }\n        int res = 0;\n        if(check2(u, vec, 0, cri, res)){\n            sm += res;\n            return true;\n        }else if(!check2(u, vec, len(vec)-1, cri, res)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check2(u, vec, mid, cri, res)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            check2(u, vec, r, cri, sm);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool possible(int cri, int a)\n{\n    int sm = 0;\n    if(!dfs2(0, -1, cri, sm)) return false;\n    if(dp[0]) sm++;\n    assert(sm >= a);\n    return (sm == a);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <fstream>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cassert>\n\n//#include <unordered_map>\n//#include <unordered_set>\nusing namespace std;\n\ntypedef long long ll;\n#define eps 1e-8\n#define LL_INF 0x3fffffffffffffff\n#define INF 1LL<<30\n#define mem(a, b) memset(a, b, sizeof(a))\n#define pper(i,n,m) for(int i = n;i >= m; i--)\n#define repp(i, n, m) for (int i = n; i <= m; i++)\n#define rep(i, n, m) for (int i = n; i < m; i++)\n#define sa(n) scanf(\"%d\", &(n))\n#define slla(n) scanf(\"%lld\", &(n))\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define DE(val) cout<<#val<<\": \"<<val<<endl;\n\nconst int dx4[5] = { 0,-1,0,1,0 };\nconst int dy4[5] = { 0,0,1,0,-1 };\n\nconst int dx8[9] = { 0,-1,0,1,0,1,1,-1,-1 };\nconst int dy8[9] = { 0,0,1,0,-1,1,-1,1,-1 };\nconst int maxn = 2e5 + 50;\nconst double PI = acos(-1.0);\nconst ll mod = 1e9 + 7;\nll po(ll a, ll b, ll mod) { ll res = 1; a %= mod; for (; b; b >>= 1) { if (b & 1)res = res*a%mod; a = a*a%mod; }return res; }\nll gcd(ll a, ll b) { if (a == 0) { return b; } else { return gcd(b%a, a); } }\nvoid YES() { puts(\"YES\"); exit(0); }\nvoid Yes() { puts(\"Yes\"); exit(0); }\nvoid NO() { puts(\"NO\"); exit(0); }\nvoid No() { puts(\"No\"); exit(0); }\nvoid one() { puts(\"-1\"); exit(0); }\n\nint n;\nvector<int>edge[maxn];\nint dp[maxn];\n\nbool dfs(int x, int fa, int mid)\n{\n\tvector<int>son;\n\tfor (int i = 0; i<edge[x].size(); i++)\n\t{\n\t\tint to = edge[x][i];\n\t\tif (to == fa)continue;\n\t\tif (!dfs(to, x, mid))return false;\n\t\t//if(dp[to] != -1)\n\t\tson.push_back(dp[to] + 1);\n\t}\n\tif (son.size() == 0)\n\t{\n\t\tdp[x] = 0;\n\t\treturn true;\n\t}\n\n\tsort(son.begin(), son.end());\n\n\tif (son.size() % 2 == 0)\n\t{\n\t\tint st = 0;\n\t\tint en = son.size() - 1;\n\t\twhile (st < en)\n\t\t{\n\t\t\tif (son[st] + son[en] > mid)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tst++;\n\t\t\ten--;\n\t\t}\n\t\tdp[x] = 0;\n\t}\n\telse\n\t{\n\t\tint le = 0;\n\t\tint ri = son.size() - 1;\n\t\twhile (le < ri)\n\t\t{\n\t\t\tint mid = (le + ri) / 2;\n\n\t\t\tint i = 0;\n\t\t\tint j = son.size() - 1;\n\t\t\tint flag = 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tif (i == mid)i++;\n\t\t\t\tif (j == mid)j--;\n\t\t\t\tif (i<j)\n\t\t\t\t{\n\t\t\t\t\tif (son[i] + son[j] > mid)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tle = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (son[le] > mid)return false;\n\t\tdp[x] = son[le];\n\t}\n\treturn true;\n}\n\nvoid solve()\n{\n\tsa(n);\n\trepp(i, 1, n - 1)\n\t{\n\t\tint x, y;\n\t\tsa(x), sa(y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tint cnt = 0;\n\tint p = 1;\n\trepp(i, 1, n)\n\t{\n\t\tif (edge[i].size() & 1)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\tif (edge[i].size() == 1)\n\t\t{\n\t\t\tp = i;\n\t\t}\n\t}\n\tint ans = (cnt + 1) / 2;\n\tint le = 1;\n\tint ri = n;\n\twhile (le < ri)\n\t{\n\t\tint mid = (le + ri) / 2;\n\t\tif (dfs(p, -1, mid))\n\t\t{\n\t\t\tri = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tle = mid + 1;\n\t\t}\n\t}\n\tcout << ans << \" \" << le << endl;\n}\nint main()\n{\n\n\tsolve();\n\t// system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\td.insert(dfs(v)+1);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0;\n\tint r = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tint lb = 0, ub = n-1;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resa+1<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        assert((int) tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        }\n                        return;\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < (int) child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::stack<T> s) {\n    os << \"[\";\n    while (!s.empty()) {\n        os << s.top() << \",\";\n        s.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, Edge<T> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n/* ----- Constants ----- */\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing namespace std;\n\nGraph<> tree;\n\nint A;\n\nint dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n    return ch % 2;\n}\n\nint B;\n\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    if (ch.size() % 2 == 0) ch.push_back(0);\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree.span(u, v);\n        tree.span(v, u);\n    }\n\n    A = 0;\n    int res = dfs1(0, -1);\n    A += res;\n\n    int ok = INF, ng = 0;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(0, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(node == 5 && length == 5){\n\t\t\t//pe(b);\n\t\t}\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0 || de > table.size()){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t\tnum = i;\n\t\t}\n\t}\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\t//num = 5;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <climits>\n#include <bitset>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0;\n    char ch = Advance();\n    while (!isdigit(ch))\n        ch = Advance();\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer;\n}\n\nconst int MAXN = 100000;\n\nvector<int> g[1 + MAXN];\nint limit, splits[1 + MAXN];\n\nint DFS(int node, int father) {\n    multiset<int> sons;\n    for (auto &son : g[node])\n        if (son != father) {\n            sons.insert(DFS(son, node));\n            if (sons.find(-1) != sons.end())\n                return -1;\n        }\n    if (sons.empty())\n        return 1;\n    if (sons.size() == 1)\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    int n = sons.size();\n    if (sons.size() % 2) {\n        for (int i = 1; 2 * i <= n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin())\n                return -1;\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (*sons.begin() < limit)\n            return *sons.begin() + 1;\n        else\n            return -1;\n    }\n    else {\n        bool out = false;\n        for (int i = 1; 2 * i < n; i++) {\n            int need = limit - *sons.rbegin() - 1;\n            auto it = sons.upper_bound(need);\n            if (it == sons.begin()) {\n                if (*sons.rbegin() >= limit)\n                    return -1;\n                if (!out) {\n                    out = true;\n                    sons.erase(sons.find(*sons.rbegin()));\n                    continue;\n                }\n                return -1;\n            }\n            it--;\n            sons.erase(it);\n            sons.erase(sons.find(*sons.rbegin()));\n        }\n        if (!out) {\n            if (*sons.begin() + *sons.rbegin() + 1 <= limit)\n                return 1;\n            if (node == 1)\n                return -1;\n            if (*sons.begin() < limit && *sons.rbegin() < limit)\n                return *sons.begin() + 1;\n            else\n                return -1;\n        }\n        else {\n            if (node == 1)\n                return -1;\n            if (*sons.begin() < limit)\n                return *sons.begin() + 1;\n            else\n                return -1;\n        }\n    }\n}\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int first = 1, left = 2, right = n, second = n;\n    for (int i = 3; i <= n; i++)\n        splits[i] = splits[i / 2] + splits[i - i / 2] + 1;\n    for (int i = 1; i <= n; i++)\n        first += splits[g[i].size()];\n    while (left <= right) {\n        limit = (left + right) / 2;\n        if (DFS(1, 0) != -1) {\n            second = limit;\n            right = limit - 1;\n        }\n        else\n            left = limit + 1;\n    }\n    second--;\n    printf(\"%d %d\\n\", first, second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nll N;\nvector<vll> G;\nll degree[100010];\n\nll dp[100010];\nbool dfs(ll v,ll p,const ll &x){\n  bool ret=true;\n  vll V;\n  for(ll u:G[v])if(p!=u){\n    ret &= dfs(u,v,x);\n    V.push_back(dp[u]+1);\n  }\n  if(!ret)return false;\n  sort(V.begin(),V.end());\n  if(V.size()&1){\n    ll low=-1,high=V.size();\n    while(high-low>1){\n      bool isok=true;\n      ll mid = (low+high)/2;\n      ll l=0,r=V.size()-1;\n      for(ll i=0;i<V.size()/2;i++){\n        if(l==mid){\n          l++;\n        }\n        if(r==mid){\n          r--;\n        }\n        isok &= V[l]+V[r]<=x;\n        l++;\n        r--;\n      }\n      if(isok){\n        high = mid;\n      }else{\n        low = mid;\n      }\n    }\n    if(high==V.size()){\n      return false;\n    }\n    dp[v] = V[high];\n  }else{\n    bool isok=true;\n    ll l=0,r=V.size()-1;\n    for(ll i=0;i<V.size()/2;i++){\n      isok &= V[l]+V[r]<=x;\n      l++;\n      r--;\n    }\n    if(!isok){\n      //cerr<<\"!!\"<<endl;\n      ret &= V.back()<=x;\n      V.pop_back();\n      ll low=-1,high=V.size();\n      while(high-low>1){\n        isok=true;\n        ll mid = (low+high)/2;\n        l=0,r=V.size()-1;\n        for(ll i=0;i<V.size()/2;i++){\n          if(l==mid){\n            l++;\n          }\n          if(r==mid){\n            r--;\n          }\n          isok &= V[l]+V[r]<=x;\n          l++;\n          r--;\n        }\n        if(isok){\n          high = mid;\n        }else{\n          low = mid;\n        }\n      }\n      if(high==V.size()){\n        return false;\n      }\n      dp[v] = V[high];\n    }\n  }\n  ret &= dp[v]<=x;\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll a,b;cin>>a>>b;a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    degree[a]++;\n    degree[b]++;\n  }\n  ll A=0;\n  for(ll i=0;i<N;i++){\n    A += degree[i]&1;\n  }\n  A /= 2;\n  ll low=-1,high=N;\n  while(high-low>1){\n    ll mid=(high+low)/2;\n    //debug(mid);\n    fill(dp,dp+N,0);\n    if(dfs(0,-1,mid)){\n      high = mid;\n    }else{\n      low = mid;\n    }\n    //debugArray(dp,N);\n  }\n  cout<<A<<\" \"<<high<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N;\n   cin >> N;\n   vector<vector<int>> adj(N);\n   for (int i = 0; i < N - 1; ++i) {\n      int v, u;\n      cin >> v >> u;\n      --v, --u;\n      adj[v].emplace_back(u);\n      adj[u].emplace_back(v);\n   }\n   int ans = 0;\n   for (int i = 0; i < N; ++i) {\n      ans += int(adj[i].size()) & 1;\n   }\n   ans >>= 1;\n   int low = 1, high = N;\n   while (low < high) {\n      int mid = (low + high) >> 1;\n      int cans = 0;\n      function<int(int, int)> dfs = [&](int v, int p) {\n         multiset<int> nxts;\n         for (int u : adj[v]) {\n            if (u != p) {\n               nxts.emplace(dfs(u, v) + 1);\n            }\n         }\n         vector<int> bigs;\n         while (nxts.size()) {\n            int x = *(--nxts.end());\n            nxts.erase(nxts.find(x));\n            auto it = nxts.upper_bound(mid - x);\n            if (it == nxts.begin()) {\n               bigs.emplace_back(x);\n            } else {\n               nxts.erase(--it);\n               cans++;\n            }\n         }\n         reverse(bigs.begin(), bigs.end());\n         while (bigs.size() && bigs.back() == mid) {\n            cans++;\n            bigs.pop_back();\n         }\n         if (bigs.empty()) return 0;\n         cans += int(bigs.size()) - (v > 0);\n         return bigs[0];\n      };\n      dfs(0, -1);\n      if (ans == cans) {\n         high = mid;\n      } else {\n         low = mid + 1;\n      }\n   }\n   cout << ans << \" \" << low << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,x,y,ans,l,r,mid,tot,f[N],a[N],g[N],head[N],d[N];\nstruct edge{int v,nxt;}e[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool dp(int u,int fa){\n    f[u]=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) if (!dp(v,u)) return 0;\n    //printf(\"+++++++%d+++++++\\n\",u);\n    //for (int i=head[u],v;i;i=e[i].nxt)\n        //if ((v=e[i].v)!=fa) printf(\"%d\\n\",f[v]);\n    int xb=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) a[++xb]=f[v]+1;\n    sort(a+1,a+xb+1); //for (int i=1;i<=xb;i++) cout<<a[i]<<endl;\n    memset(f,-1,sizeof(int)*(xb+1));\n    int j,k;\n    for (int i=1;i<=xb;i++)\n        for (j=1;j<i && a[j]+a[i]<=mid;j++) g[i]=j;\n    j=0,k=0;\n    if (xb&1){\n        for (int i=xb;i>xb/2+1;i--) if (g[i]<n-i+1){k=i; break;} //cout<<k<<endl;\n        if (k==0){\n            j=1; for (int i=xb;i>xb/2+1;i--) if (f[i]<xb-i+2) j=xb-i+2;\n            f[u]=a[j];\n        }\n        else{\n            j=0; for (int i=xb;i>xb/2+1;i--) if (k!=i){j++; if (a[i]+a[j]>mid) return 0;}\n            f[u]=a[k];\n        }\n    }\n    else{\n        j=0; for (int i=n;i>n/2;i--) if (a[i]+a[n-i+1]>mid) return 0;\n        f[u]=0;\n    }\n    if (u==1 && f[u]>mid) return 0;\n    return 1;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){scanf(\"%d%d\",&x,&y); add(x,y); add(y,x); d[x]++; d[y]++;}\n    for (int i=1;i<=n;i++) if (d[i]&1) ans++;\n    ans/=2; printf(\"%d \",ans);\n    l=1,r=n;\n    while (l<=r){\n        mid=(l+r)>>1; memset(f,0,sizeof f);\n        if (dp(1,0)){ans=mid; r=mid-1;} else l=mid+1;\n    }\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A;\nvector<int> e[N];\n\nint g(vector<int> &v, int z){\n    for(int i = -(v.size() & 1), j = int(v.size()) - 1; i < j; i++, j--){\n        int t = v[j];\n        if(i >= 0) t += v[i];\n        if(t > z) return -1;\n    }\n    return 0;\n}\n\nint h(vector<int> &v, int m, int z){\n    if((m >= 0 ? v[m] : 0) + 1 > z) return -1;\n    vector<int> w;\n    for(int i = 0; i < v.size(); i++) if(i != m) w.push_back(v[i]);\n    return g(w, z);\n}\n\nint f(int x, int y, int z){\n    vector<int> v;\n    for(int i : e[x]){\n        if(i == y) continue;\n        v.push_back(f(i, x, z));\n        if(v.back() < 0) return -1;\n    }\n    if(v.empty()) return 1;\n    sort(v.begin(), v.end());\n    if(!y) return g(v, z);\n    int l = -(~v.size() & 1), r = v.size() - 1;\n    while(l < r){\n        int m = (l + r + 2) / 2 -1;\n        if(h(v, m, z) >= 0) r = m;\n        else l = m + 1;\n    }\n    if(h(v, l, z) < 0) return -1;\n    return (l >= 0 ? v[l] : 0) + 1;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 0, x, y; i < n - 1; i++){\n        scanf(\"%d%d\", &x, &y);\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    A = n - 1;\n    for(int i = 1; i <= n; i++) A -= int(e[i].size()) / 2;\n    printf(\"%d \", A);\n    int l = 1, r = n;\n    while(l < r){\n        int m = (l + r) / 2;\n        if(f(1, 0, m) >= 0) r = m;\n        else l = m + 1;\n    }\n    printf(\"%d\\n\", l);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],sum[N],head[N],nex[N<<1],to[N<<1];\nll f[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nint top,s[N];\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        s[++top]=sum[v]+1;\n        if(s[top]>m) {f[u]+=n;return;}\n    }\n    sort(s+1,s+1+top);\n    for(int i=1;i<=top;i++) st.insert(s[i]);\n    for(int i=top;i>=1;i--)\n    {\n        if(!st.count(s[i])) continue;\n        st.erase(st.find(s[i]));\n        if(st.size()==0)\n        {\n            sum[u]=s[i];break;\n        }\n        it=st.upper_bound(m-s[i]);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;\n            st.erase(st.find(*it));\n        }\n    }\n    top=0;\n    if(u==1&&sum[u]) f[u]++;\n}\nbool judge(int m)\n{\n    dfs(1,0,m);\n    return f[1]<=dp[1];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=(n-1)/dp[1]+((n-1)%dp[1]!=0),r=n-1,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        if(judge(m)) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int maxn=100005;\nvector<int>E[maxn];\nint n,deg[maxn],dp[maxn],lim,rt;\nbool dfs(int u,int fa){\n\tbool res=1;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)res&=dfs(v,u);\n\t}\n\tstatic int c[maxn],tot;\n\ttot=0;\n\tREP(i,0,E[u].size()-1){\n\t\tint v=E[u][i];\n\t\tif(v!=fa)c[++tot]=dp[v];\n\t}\n\tif(deg[u]&1)c[++tot]=0;\n\tsort(c+1,c+1+tot);\n\tint l=1,h=tot;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1,curl=1,curr=tot,Max=0;\n\t\tREP(i,1,tot>>1){\n\t\t\tif(curl==mid)curl++;\n\t\t\tif(curr==mid)curr--;\n\t\t\tchkmax(Max,c[curl]+c[curr]);\n\t\t\tcurl++,curr--;\n\t\t}\n\t\tif(Max<=lim)h=mid-1;\n\t\telse l=mid+1;\n\t}\n\tres&=(l<=tot);\n\tdp[u]=c[l]+1;\n\treturn res;\n}\nbool check(int x){\n\tlim=x;\n\treturn dfs(rt,0)&(dp[rt]-1<=lim);\n}\nint main(){\n\tint u,v;\n\tn=read();\n\tREP(i,1,n-1){\n\t\tu=read(),v=read();\n\t\tE[u].pb(v),deg[u]++;\n\t\tE[v].pb(u),deg[v]++;\n\t}\n\tint ans=0;\n\tREP(i,1,n)\n\t\tif(deg[i]&1)rt=i,ans++;\n\twrite(ans>>1,' ');\n\tint l=1,h=n-1;\n\twhile(l<=h){\n\t\tint mid=(l+h)>>1;\n\t\tif(check(mid))h=mid-1;\n\t\telse l=mid+1;\n\t}write(l,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nvector<int> g[100005];\n\nint dfs(int m, int d, int from){\n  vector<int> ch;\n  for(auto to : g[d]) if(to!=from){\n    int r = dfs(m, to ,d);\n    if(r > m) return INF;\n    ch.pb(r);\n  }\n  // dbg(m,d,ch);\n  int sz = ch.size();\n  if(sz==0) return 1;\n  if(sz==1) return ch[0]+1;\n\n  sort(all(ch));\n  auto check = [&](int mid){\n    int l = 0, r = sz-1;\n    while(l<r){\n      if(l==mid) l++;\n      if(r==mid) r--;\n      if(l>=r) break;\n      if(ch[l]+ch[r] > m) return false;\n      l++;\n      r--;\n    }\n    return true;\n  };\n  if(sz%2==0 && check(-1)) return 1;\n\n  if(check(0)) return ch[0]+1;\n  if(!check(sz-1)) return INF;\n  int l = 0, r = sz-1;\n  while(r-l>1){\n    int mid = (l+r)/2;\n    if(check(mid)) r = mid;\n    else l = mid;\n  }\n  return ch[r]+1;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n\n  // int a = 1;\n  // rep(i,n) a += (g[i].size()-1)/2;\n  int a = 0;\n  rep(i,n) a += g[i].size()%2;\n  a /= 2;\n\n  int d = 0;\n  while(g[d].size()!=1) d++;\n\n  int l = 0, r = n;\n  while(r-l>1){\n    int m = (r+l)/2;\n    if(dfs(m, d, -1) <= m+1) r = m;\n    else l = m;\n  }\n\n  cout << a << \" \" << r << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define MAXN 100010\nint head[MAXN], to[MAXN << 1], next[MAXN << 1], tot = 0;\ninline void addEdge(int u, int v) {\n    next[tot] = head[u], to[tot] = v, head[u] = tot++;\n    next[tot] = head[v], to[tot] = u, head[v] = tot++;\n}\nint n, d[MAXN], f[MAXN], m;\ninline bool check(const std::vector<int> &v, int mid) {\n    int l = 0, r = v.size() - 1;\n    while (l < r) {\n        if (l == mid) l++;\n        if (r == mid) r--;\n        if (v[l] + v[r] > m) return 0;\n        l++;\n        r--;\n    }\n    return 1;\n}\nbool DP(int x, int fa) {\n    std::vector<int> g;\n    for (int i = head[x]; ~i; i = next[i])\n        if (to[i] != fa) {\n            if (!DP(to[i], x)) return false;\n            g.push_back(f[to[i]]);\n        }\n    if (g.empty()) {\n        f[x] = 1;\n        return true;\n    }\n    if (!(g.size() & 1)) g.push_back(0);\n    std::sort(g.begin(), g.end());\n    register int l = 0, r = g.size(), ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(g, mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    if (!~ans) return false;\n    f[x] = g[ans] + 1;\n    return 1;\n}\nint root = 0;\ninline bool judge(int mid) {\n    m = mid;\n    if (!DP(root, 0)) return 0;\n    return f[root] <= m + 1;\n}\nint main() {\n    std::cin >> n;\n    memset(head, -1, sizeof(head));\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        addEdge(u, v);\n        d[u]++;\n        d[v]++;\n    }\n    for (int i = 1; i <= n; i++) m += d[i] & 1;\n    for (int i = 1; i <= n; i++)\n        if (d[i] == 1) {\n            root = i;\n            break;\n        }\n    std::cout << (m >>= 1) << ' ';\n    register int l = 0, r = n, ans = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (judge(mid))\n            ans = mid, r = mid - 1;\n        else\n            l = mid + 1;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = (2 << 16), LG = 18, INF = 1e9 * 1e6;\nll n, m;\nll grid[LG][LG], inter[SZ], dp[SZ], mx[SZ];\n\nint main() {\n\tfastInp;\n\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < LG; i++) {\n\t\tfor (int j = 0; j < LG; j++) grid[i][j] = INF;\n\t}\n\n\tll sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tll u, v, c;\n\t\tcin >> u >> v >> c;\n\t\tsum += c;\n\t\tu--; v--;\n\t\tgrid[u][v] = c;\n\t\tgrid[v][u] = c;\n\t}\n\n\tll pw = (1ll << n);\n\tfor (int i = 0; i < pw; i++) {\n\t\tll cur = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tif (((i >> k) & 1) && ((i >> j) & 1) && grid[k][j] != INF) {\n\t\t\t\t\tcur += grid[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinter[i] = cur;\n\t}\n\n\tfor (int i = 0; i < pw; i++) {\n\t\tfor (int j = 0; j < LG; j++) dp[i] = -INF;\n\t}\n\n\tfor (int i = 0; i < LG; i++) dp[(1ll << i)] = 0;\n\tdp[1] = 0;\n\tfor (int i = 2; i < pw; i++) {\n\t\tfor (int j = 0; j < LG; j++) {\n\t\t\tfor (int k = 0; k < LG; k++) {\n\t\t\t\tif (j != k && (i & (1ll << k)) && (i & (1ll << j)) && grid[j][k] != INF) {\n\t\t\t\t\tll msk = i ^ (1ll << j);\n\t\t\t\t\tdp[i] = max(dp[i], dp[msk] + grid[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = -INF;\n\n\tfor (int i = 0; i < pw; i++) {\n\t\tif (!(i & 1)) continue;\n\t\tif (!((i >> (n - 1)) & 1)) continue;\n\t\tfor (int sub = i; true; sub = ((sub - 1) & i)) {\n\t\t\tfor (int j = 0; j < LG; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\tll msk = (i ^ sub);\n\t\t\t\t\tif ((msk & 1) && ((msk >> (n - 1)) & 1)) dp[i] = max(dp[i], dp[msk] + inter[sub | (1ll << j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sub == 0) break;\n\t\t}\n\t\tans = max(ans, dp[i]);\n\t}\n\n\tcout << sum - ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  {\n    Int A=0;\n    for(Int i=0;i<n;i++)\n      A+=G[i].size()&1;\n    cout<<A/2<<\" \";\n  }\n\n  auto check=\n    [&](Int x)->Int{\n      Int ng=0;\n      function<Int(Int, Int)> dfs=\n        [&](Int v,Int p)->Int{\n          vector<Int> vs;\n          for(Int u:G[v]){\n            if(u==p) continue;            \n            vs.emplace_back(dfs(u,v)+1);\n          }\n          \n          if(G[v].size()&1)\n            vs.emplace_back(0);\n          sort(vs.begin(),vs.end());\n          \n          Int k=vs.size();\n          if(p<0){\n            assert(~k&1);\n            for(Int i=0;i<k/2;i++)\n              if(vs[i]+vs[k-(i+1)]>x) return ng=1;\n            return 0;\n          }\n          \n          assert(k&1);\n          \n          auto check2=\n            [&](Int y)->Int{\n              vector<Int> us;\n              for(Int i=0;i<k;i++)\n                if(i!=y) us.emplace_back(vs[i]);\n              Int l=us.size();\n              assert(~l&1);\n              for(Int i=0;i<l/2;i++)\n                if(us[i]+us[l-(i+1)]>x) return 0;\n              return 1;\n            };\n          \n          Int l=-1,r=k;\n          while(l+1<r){\n            Int m=(l+r)>>1;\n            if(check2(m)) r=m;\n            else l=m;\n          }\n          if(r==k) return ng=1;\n          return vs[r];\n        };\n      \n      dfs(0,-1);\n      return !ng;\n    };\n    \n  Int l=0,r=n;\n  while(l+1<r){\n    Int m=(l+r)>>1;\n    if(check(m)) r=m;\n    else l=m;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector< int > g[100000];\nint dp[100001];\n\nint rec(int idx, int ptr, int limited)\n{\n  dp[idx] = 0;\n\n  deque< int > connect;\n  for(auto &to : g[idx]) {\n    if(to == ptr) continue;\n    connect.emplace_back(rec(to, idx, limited) + 1);\n    dp[idx] += dp[to];\n  }\n\n  sort(begin(connect), end(connect));\n\n  while(connect.size() >= 2) {\n    if(connect.front() + connect.back() > limited) {\n      connect.pop_back();\n      ++dp[idx];\n    } else {\n      connect.pop_back();\n      connect.pop_front();\n      ++dp[idx];\n    }\n  }\n\n  int odd = 0;\n  if(connect.size() % 2 == 1) {\n    if(connect.front() + 1 > limited) {\n      ++dp[idx];\n    } else {\n      odd = connect.front();\n    }\n    connect.pop_front();\n  }\n\n  return (odd);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n\n  if(rec(0, -1, 1145141919) != 0) dp[0]++;\n  int beet = dp[0];\n  auto check = [&](int v)\n  {\n    int result = rec(0, -1, v);\n    if(result != 0) dp[0]++;\n    return (dp[0] == beet);\n  };\n\n  int low = N, high = -1;\n  while(low - high > 1) {\n    int mid = (low + high) / 2;\n    if(check(mid)) low = mid;\n    else high = mid;\n  }\n\n  cout << beet << \" \" << low << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n\n    auto it=S.begin();\n    bool flag=0;\n    while(S.size()>1){\n        it=S.end();--it;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,-1));\n        if(ip==S.begin()){\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n\n   dp[n]=(*S.begin()).first+1;\n   if(dp[n]>mid){\n    dp[n]=2;--ok;\n   }\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    while(high-low>1){\n       ok=ans;\n        int mid=(high+low)/2;\n\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tif(a + table.front() > length){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\t//if(de < 0){\n\t\t//\tdame = true;\n\t\t//\treturn INF;\n\t\t//}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\tassert(node == num);\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = -1;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,res[N],A,B,l,r,mid;\nvector<int> e[N];\nbool ok;\nvoid solve(int x,int fa){\n    vector<int> L;\n    for (int i=0;i<e[x].size();i++){\n        int v=e[x][i];\n        if (v==fa) continue;\n        solve(v,x);\n        L.push_back(res[v]+1);\n    }\n    if (!(L.size()&1)) L.push_back(0);\n    sort(L.begin(),L.end());\n    for (int l=0,r=L.size()-2;l<r;l++,r--)\n    if (L[l]+L[r]>mid) ok=0;\n    int p=L.size()-1,len=p;\n    while (p&&L[p]+L[len-p+(len-p>p)]<=mid) p--;\n    res[x]=L[p];\n}\nbool check(){\n    ok=1;\n    solve(1,0);\n    return ok&&res[1]<=mid;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    A=n-1;\n    for (int i=1;i<=n;i++) A-=e[i].size()/2;\n    for (l=0,r=n-1;l<r;){\n        mid=(l+r)>>1;\n        if (check()) r=mid;else l=mid+1;\n    }\n    printf(\"%d %d\\n\",A,l);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X, a;\nvector<vector<int> > adj;\n\nvoid dfs0(int u, int p) {\n    int cnt = 0;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        cnt++;\n        dfs0(v, u);\n    }\n    a -= cnt / 2;\n    if(p != -1 && cnt % 2 == 0) a++;\n}\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    vector<int> tmp;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n        tmp.push_back(t + 1);\n    }\n\n    sort(tmp.begin(), tmp.end());\n\n    if((p == -1) ^ (st.size() % 2)) {\n        if(p != -1) {\n            for(int i = 0; i < (int)tmp.size() - 1; i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n            }\n        }\n        else {\n            for(int i = 0; i < (int)tmp.size(); i++) {\n                if(tmp[i] + tmp[ (int)tmp.size() - 1 - i ] > X) return -1;\n            }\n        }\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return v;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        for(int i = 0; i < (int)tmp.size() - 1; i++) {\n            if(tmp[i] + tmp[ (int)tmp.size() - 2 - i ] > X) return -1;\n        }\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return v;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    a = 0;\n    dfs0(0, -1);\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  V<> deg(n);\n  for (int _ = 0; _ < n - 1; ++_) {\n    int u, v; cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    ++deg[u], ++deg[v];\n  }\n  cout << count_if(begin(deg), end(deg), [](int x) { return x & 1; }) / 2 << ' ';\n  auto chk = [&](int x) -> bool {\n    V<> dp(n, 1e9);\n    auto dfs = [&](const auto& dfs, int v, int p) -> void {\n      multiset<int> ms;\n      for (int w : g[v]) if (w != p) {\n        dfs(dfs, w, v);\n        ms.insert(dp[w] + 1);\n      }\n      if (~ms.size() & 1) ms.insert(0);\n      while (ms.size() >= 2) {\n        auto itr = ms.upper_bound(x - *prev(end(ms)));\n        if (itr == begin(ms)) return;\n        ms.erase(--itr);\n        ms.erase(prev(end(ms)));\n      }\n      dp[v] = *begin(ms);\n    };\n    dfs(dfs, 0, -1);\n    return dp[0] <= x;\n  };\n  int ng = 0, ok = n - 1;\n  while (ok - ng > 1) {\n    int mid = ng + ok >> 1;\n    (chk(mid) ? ok : ng) = mid;\n  }\n  cout << ok << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::sort;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN],son[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(int son){\n\tfor(int l=1,r=::son[0];l<r;++l,--r){\n\t\tif(::son[l]==son) ++l;\n\t\tif(::son[r]==son) --r;\n\t\tif(dp[::son[l]]+dp[::son[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(){\n\tint l=1,r=son[0],mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tbool ret=true;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa) ret&=treeDP(v,u);\n\t}\n\tif(!ret) return false;\n\tson[0]=0;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa) son[++son[0]]=v;\n\t}\n\tif(son[0]==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) son[++son[0]]=0;\n\tsort(son+1,son+son[0]+1,cmp_dp);\n\tint v=bin_chop_son();\n\tif(v>son[0]) return false;\n\tdp[u]=dp[son[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=1,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]==1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nbool check(vector<int>& vec, int num, int cri)\n{\n    int l = 0, r = len(vec)-1;\n    for(;;++l, --r){\n        if(l == num) ++l;\n        if(r == num) --r;\n        if(l >= r) break;\n        if(vec[l]+vec[r]+2 > cri) return false;\n    }\n    return true;\n}\n\nbool dfs2(int u, int p, int cri)\n{\n    vector<int> vec;\n    for(int v : G[u]){\n        if(v != p){\n            if(!dfs2(v, u, cri)) return false;\n            vec.pb(dp[v]);\n        }\n    }\n    sort(all(vec));\n    if(len(vec) % 2){\n        if(check(vec, 0, cri)){\n            if(vec[0] == cri){\n                return false;\n            }else{\n                dp[u] = vec[0] + 1;\n                return true;\n            }\n        }else if(!check(vec, len(vec)-1, cri)){\n            return false;\n        }else{\n            int l = 0, r = len(vec)-1;\n            while(r-l>1){\n                int mid = (l+r)/2;\n                if(check(vec, mid, cri)){\n                    r = mid;\n                }else{\n                    l = mid;\n                }\n            }\n            if(vec[r] == cri){\n                return false;\n            }else{\n                dp[u] = vec[r] + 1;\n                return true;\n            }\n        }\n    }else{\n        rep(i,len(vec)/2){\n            if(vec[i] + vec[len(vec)-i-1] + 2 > cri) return false;\n        }\n        return true;\n    }\n}\n\nbool possible(int cri, int a)\n{\n    return dfs2(0, -1, cri);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tll b = solve(G[node][i],node,length);\n\t\tif(node == 5 && length == 5){\n\t\t\t//pe(b);\n\t\t}\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0 || de > table.size()){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\ta++;\n\t\t}\n\t}\n\tnum = 1;\n\tassert(a % 2 == 0);\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\t//num = 5;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0, resb = 0\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tresb += g[i].size()%2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tresa--; resb /= 2;\n\tif(resa!=resb) return -1;\n\tint lb = -1, ub = n;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resb<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\n\nint n, lim, ans, dt[N];\n\nvector<int> adj[N], arr;\n\nbool can (int C, int P) {\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(!can(T, C)) return false;\n\t}\n\tarr.clear();\n\tfor(auto &T : adj[C]) {\n\t\tif(T == P) continue;\n\t\tif(dt[T]+1 > lim) return false;\n\t\tarr.push_back(dt[T]+1);\n\t}\n\tsort(arr.begin(), arr.end());\n\tint N = arr.size();\n\tif(N % 2 == 0) {\n\t\tbool F = false;\n\t\tfor(int i=0;i<N/2;i++) {\n\t\t\tif(arr[i] + arr[N-1-i] > lim) F = true;\n\t\t}\n\t\tif(!F) {dt[C] = 0; return true;}\n\t\tarr.pop_back();\n\t}\n\tint S = 0, E = N;\n\twhile(S<E) {\n\t\tint M = (S+E)/2, L = 0, R = N-1;\n\t\tbool F = false;\n\t\twhile(1) {\n\t\t\tif(L == M) L++;\n\t\t\tif(R == M) R--;\n\t\t\tif(L >= R) break;\n\t\t\tif(arr[L] + arr[R] > lim) {F = true; break;}\n\t\t\tL++; R--;\n\t\t}\n\t\tF ? S = M+1 : E = M;\n\t}\n\tif(S == N) return false;\n\tdt[C] = arr[S];\n\treturn true;\n}\n\nbool can () {\n\tif(!can(1, 0)) return false;\n\treturn (adj[1].size() % 2 || dt[1] == 0);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tans = n-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tans -= (int)adj[i].size() / 2;\n\t}\n\tprintf(\"%d \",ans);\n\tint S = 0, E = n;\n\twhile(S<E) {\n\t\tlim = (S+E)/2;\n\t\tcan() ? E = lim : S = lim+1;\n\t}\n\tprintf(\"%d\\n\",S);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nvector<int> G[100000];\nint ar[100000];\nint buffer[100000];\nint N;\nbool check(int B){\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tint p = 0;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tbuffer[p++] = ar[t]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p % 2 == 0){\n\t\t\t\tbuffer[p++] = 0;\n\t\t\t}\n\t\t\tsort(buffer,buffer+p);\n\t\t\tint bf = 0;\n\t\t\tint bl = p;\n\t\t\twhile(bf != bl){\n\t\t\t\tint bc = (bf+bl)/2;\n\t\t\t\tbool OK = true;\n\t\t\t\tif(bc != p){\n\t\t\t\t\tint l = 0;\n\t\t\t\t\tint r = p-1;\n\t\t\t\t\twhile(l < r){\n\t\t\t\t\t\tif(l == bc){\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r == bc){\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(buffer[l] + buffer[r] > B){\n\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tr--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tbl = bc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbf = bc+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bf == p){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tar[v] = buffer[bf];\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ar[0] <= B;\n}\nvoid Calc(){\n\tN = rei();\n\tfor(int i=0;i<N-1;i++){\n\t\tint a = rei()-1;\n\t\tint b = rei()-1;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint A = 0;\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tint b = 0;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint t = G[v][i];\n\t\t\tif(t != f){\n\t\t\t\tb++;\n\t\t\t\tsp.push({t,v});\n\t\t\t}\n\t\t}\n\t\tA -= b / 2;\n\t\tif(b % 2 == 0){\n\t\t\tA++;\n\t\t}\n\t}\n\tint bf = 1;\n\tint bl = N-1;\n\twhile(bf != bl){\n\t\tint bc = (bf+bl)/2;\n\t\tif(check(bc)){\n\t\t\tbl = bc;\n\t\t}\n\t\telse{\n\t\t\tbf = bc+1;\n\t\t}\n\t}\n\tcout << A << \" \" << bf << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = a; i <= b; ++ i)\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N = 1e5 + 5;\ntypedef pair < int, int > ii;\nint t, n, h[N];\nbool kt;\nvector < int > adj[N];\n\nbool check1(vector < ii > data, int pos, int lim){\n\tif(pos >= 0) data.erase(data.begin() + pos);\n\tint Max = 0, len = data.size();\n\tFor(i, 0, len / 2 - 1) Max = max(Max, data[i].fi + data[len - i - 1].fi);\n\tif (Max > lim) return false;\n\treturn true;\n}\nint cal(vector < ii > data, int lim){\n\tint len = data.size();\n\tint l = 0, r = len - 1, res = len;\n\twhile(l <= r){\n\t\tint mid = (l + r) / 2;\n\t\tif(check1(data, mid, lim)) res = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tif(res < len) return data[res].se;\n\treturn -1;\n}\nvoid dfs(int u, int pa, int lim){\n\tif(! kt) return; \n\tint child = 0; vector < ii > data;\n\tFor(i, 0, (int)adj[u].size() - 1){\n\t\tint v = adj[u][i]; if(v == pa) continue;\n\t\tif(! kt) return;\n\t\tchild++; dfs(v, u, lim);\n\t\tif(! kt) return;\n\t\tif(h[v] + 1 > lim) { kt = false; return; }\n\t\tdata.pb(ii(h[v] + 1, v));\n\t}\n\tif(!child) return;\n\tsort(data.begin(), data.end());\n\tint len = data.size(), Max = 0; \n\tif(len % 2 == 0){\n\t\tkt = check1(data, -1, lim);\n\t\tif(!kt) return;\n\t}\n\telse{\n\t\tint res = cal(data, lim);\n\t\tif(res == -1) { kt = false; return; }\n\t\th[u] = h[res] + 1;\n\t}\n}\nbool check(int mid){\n\tmemset(h, 0, sizeof h);\n\tkt = true; dfs(1, 1, mid);\n\treturn kt;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tFor(i, 1, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);  adj[v].pb(u);\n\t}\n\tint dem = 0;\n\tFor(i, 1, n) if((int)adj[i].size() % 2) dem ++; dem /= 2;\n\tint l = 0, r = n, ans;\n\twhile(l <= r){\n\t\tint mid = (l + r)/2;\n\t\tif(check(mid)) ans = mid, r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n\tcout << dem  << ' ' << ans;\n}\n/*\n7\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\nint n,A,B,mid,dp[maxn];\nvector<int> g[maxn];\n\nbool visit(int u,int pa) {\n    vector<int> temp;\n  //  cout<<u<<endl;\n    if (g[u].size()%2) temp.push_back(-1);\n    for (int j=0;j<g[u].size();j++) {\n        int v = g[u][j];\n        if (v!=pa) {\n            if (!visit(v,u)) return false;\n            if (dp[v]!=-1) temp.push_back(dp[v]);\n        }\n    }\n   // sort(temp.begin(),temp.end());\n   // cout<<u<<\" \"<<temp.size()<<endl;\n   // if (temp.size()>0) for (int i=0;i<temp.size();i++) cout<<temp[i]<<\" \";\n   // cout<<endl;\n   // cout<<\"-------------\"<<endl;\n    if (temp.size()%2) {\n        int ll=0,rr=temp.size()-1;\n        int choose=-1;\n        while (ll<=rr) {\n            int x = (ll+rr)/2;\n            bool ok = true;\n            int p1=0,p2=temp.size()-1;\n            while (p1<=p2) {\n                if (p1==x) p1++;\n                if (p2==x) p2--;\n                if (temp[p1] + temp[p2] + 2 > mid) {\n                    ok = false;\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if (ok) {\n                choose = x;\n                rr = x-1;\n            }\n            else ll = x+1;\n        }\n        if (choose==-1) return false;\n        dp[u] = temp[choose] + 1;\n        return true;\n    }\n    else {\n        for (int i=0;i<temp.size();i++)\n            if (temp[i] + temp[temp.size()-i-1] + 2 > mid) return false;\n        dp[u]=-1;\n        return true;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n   // freopen(\"inp.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    A=0;\n    for (int i=1;i<=n;i++) A+=g[i].size()%2;\n    cout<<A/2<<\" \";\n    int l=1,r=n-1;\n    while (l<=r) {\n        mid = (l+r)/2;\n        if (visit(1,-1)) {\n            B = mid;\n            r = mid-1;\n        } else l = mid+1;\n    }\n    cout<<B;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <array>\n#include <map>\n#include <vector>\n#include <utility>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int SIZE = 100009;\nint dp1[SIZE];\nint dp2[SIZE];\nvector<int> adj[SIZE];\nint N;\nint bound;\n\nint buf[SIZE];\nint buf2[SIZE];\nint timestamp;\n\nvoid f(int u, int p)\n{\n    dp1[u] = 0;\n    for(int to: adj[u])\n        if(to != p)\n        {\n            f(to, u);\n            dp1[u] += dp1[to];\n        }\n    int total = 0;\n    for(int to: adj[u])\n        if(to != p)\n        {\n            int l = dp2[to] + 1;\n            dp1[u] += l / bound;\n            l %= bound;\n            if(l)\n                buf[total++] = l;\n        }\n\n    sort(buf, buf + total);\n    ++timestamp;\n    int last = 0;\n    for(int i = total - 1; i >= 0; i--)\n        if(buf2[i] != timestamp)\n        {\n            buf2[i] = timestamp;\n            auto idx = (upper_bound(buf, buf + i, bound - buf[i]) - buf) - 1;\n\n            dp1[u]++;\n            if(idx >= 0 && buf2[idx] != timestamp)\n                buf2[idx] = timestamp;\n            else\n                last = buf[i];\n        }\n    if(last)\n        dp1[u]--;\n\n    dp2[u] = last;\n}\n\nint main()\n{\n    RD(N);\n    for(int i: RG(N - 1))\n    {\n        int a, b;\n        RD(a, b);\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n\n    int l = 0, r = N;\n\n    bound = N;\n    f(1, 0);\n\n    int A = dp1[1] + !!dp2[1];\n\n\n    while(l + 1 < r)\n    {\n        int m = (l + r) / 2;\n        bound = m;\n\n        f(1, 0);\n        if(dp1[1] + !!dp2[1] > A)\n            l = m;\n        else\n            r = m;\n    }\n\n\n    WTL(A, r);\n\n\n\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> II;\n \nconst int MAXN = (int) 1e5 + 10;\nint n;\nvector<int> adj[MAXN];\n \nint DFS(int u, int T, int par = -1) {\n    vector<int> a;\n    for (int i = 0; i < (int) adj[u].size(); ++i) {\n        int v = adj[u][i];\n        if (v != par) a.push_back(DFS(v, T, u));\n    }\n    if ((int) a.size() % 2 == 0 && par != -1) a.push_back(0);\n    sort(a.begin(), a.end());\n \n    if ((int) a.size() % 2 == 0) {\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (a[i] + a[(int) a.size() - i - 1] > T) return T + 3;\n        return 0;\n    }\n \n    int l = 0, r = (int) a.size() - 1, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        vector<int> b;\n        for (int i = 0; i < (int) a.size(); ++i)\n            if (i != mid) b.push_back(a[i]);\n        bool check = true;\n        for (int i = 0; i < (int) b.size() / 2; ++i) {\n            if (b[i] + b[(int) b.size() - i - 1] > T) {\n                check = false;\n                break;\n            }\n        }\n        if (check) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n    if (f == -1) {\n        // printf(\"#%d: %d\\n\", u, T + 3);\n        return T + 3;\n    }\n    // printf(\"#%d: %d\\n\", u, a[f] + 1);\n    return a[f] + 1;\n}\n \nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n - 1; ++i) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n \n    int l = 1, r = n, f = -1;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (DFS(1, mid) <= mid + 1) {\n            f = mid;\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n \n    int cnt = 0;\n    for (int i = 1; i <= n; ++i) cnt += (int) adj[i].size() % 2;\n \n    printf(\"%d %d\\n\", cnt / 2, f);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=101000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tint cnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\tmit it;\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tint w=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif(it->second==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif(it->second==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=1;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\t//if(u.size() && u.back() > B) return inf;\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size() - 1; i < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j == mid) j--;\n\t\t\t\tif(i < j && u[i] + u[j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nint a_dfs(const Graph& g, const int s)\n{\n    const int C = g.edge[s].size();\n    int sum = C / 2;\n    for (const int to : g.edge[s]) {\n        sum += a_dfs(g, to);\n    }\n    return sum;\n}\n\nint K;\nbool check(const vector<int>& a, const int ng, const int size)\n{\n    int tail = size - 1;\n    for (int i = 0; i < size; i++, tail--) {\n        if (tail == ng) {\n            tail--;\n        }\n        if (i == ng) {\n            i++;\n        }\n        if (tail <= i) {\n            break;\n        }\n        const int sum = a[i] + a[tail];\n        if (sum + 1 > K) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool b_bfs(const Graph& g, const int s, vector<int>& dp)\n{\n    const int C = g.edge[s].size();\n    vector<int> l;\n    for (const int to : g.edge[s]) {\n        const bool f = b_bfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        l.push_back(dp[to]);\n    }\n    sort(l.begin(), l.end());\n    if (C % 2 == 1) {\n        int inf = 0;\n        int sup = C;\n        while (inf < sup) {\n            const int mid = (inf + sup) / 2;\n            if (check(l, mid, C)) {\n                sup = mid;\n            } else {\n                if (inf == mid) {\n                    break;\n                }\n                inf = mid;\n            }\n        }\n        if (sup == C or l[sup] + 1 > K) {\n            return false;\n        } else {\n            dp[s] = l[sup] + 1;\n            return true;\n        }\n    } else {\n        if (check(l, C, C)) {\n            dp[s] = 1;\n            return true;\n        } else if (l.back() + 1 > K) {\n            return false;\n        } else {\n            int inf = 0;\n            int sup = C - 1;\n            while (inf < sup) {\n                const int mid = (inf + sup) / 2;\n                if (check(l, mid, C - 1)) {\n                    sup = mid;\n                } else {\n                    if (inf == mid) {\n                        break;\n                    }\n                    inf = mid;\n                }\n            }\n            if (sup == C - 1 or l[sup] + 1 > K) {\n                return false;\n            } else {\n                dp[s] = l[sup] + 1;\n                return true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    vector<int> dim(N, 0);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n        dim[a]++;\n        dim[b]++;\n    }\n    int root = 0;\n    for (; root < N; root++) {\n        if (dim[root] == 1) {\n            break;\n        }\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, root, used);\n    const int A = a_dfs(g, root) + 1;\n\n    vector<int> dp(N, 0);\n    int inf = 0;\n    int sup = N;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        const bool ok = b_bfs(g, root, dp);\n        if (ok) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    b_bfs(g, root, dp);\n    const int B = sup - 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <functional>\nusing namespace std;\n\n//tmpを破壊する\nbool check(vector<int> &tmp, int x) {\n        //assert(tmp.size() % 2 == 0);\n        int bg = 0, ed = tmp.size() - 1;\n        bool res = true;\n        while (bg < ed) {\n                if (tmp[bg] + tmp[ed] > x) {\n                        res = false;\n                }\n                bg ++, ed --;\n        }\n        return res;\n}\n\nbool ok(int x, int n, const vector<vector<int>> &g) {\n        vector<int> dp(n);\n        bool res = true;\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> child;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        if (dp[v] + 1 > x) res = false;\n                        child.push_back(dp[v] + 1);\n                }\n                if (child.empty()) {\n                        dp[u] = 0;\n                        return;\n                }\n                sort(child.begin(), child.end());\n                int deg = g[u].size();\n                for (int i = 0; i < child.size(); i ++) {\n                        if (child[i] > x) {\n                                res = false;\n                        }\n                }\n                if (u == 0) {\n                        if (deg & 1) {\n                                child.pop_back();\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        } else {\n                                if (!check(child, x)) {\n                                        res = false;\n                                }\n                        }\n                }\n                if (deg & 1) {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = -1; i < child.size(); i ++) {\n                                tmp.clear();\n                                if (i == -1) {\n                                        tmp = child;\n                                        if (check(tmp, x)) {\n                                                dp[u] = 0;\n                                                ng = false;\n                                                break;\n                                        }\n                                } else {\n                                        for (int j = 0; j < child.size(); j ++) {\n                                                if (i != j) {\n                                                        tmp.push_back(child[j]);\n                                                }\n                                        }\n                                        tmp.pop_back();\n                                        if (check(tmp, x)) {\n                                                dp[u] = child[i];\n                                                ng = false;\n                                                break;\n                                        }\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                } else {\n                        vector<int> tmp;\n                        bool ng = true;\n                        for (int i = 0; i < child.size(); i ++) {\n                                tmp.clear();\n                                for (int j = 0; j < child.size(); j ++) {\n                                        if (i != j) {\n                                                tmp.push_back(child[j]);\n                                        }\n                                }\n                                if (check(tmp, x)) {\n                                        dp[u] = child[i];\n                                        ng = false;\n                                        break;\n                                }\n                        }\n                        if (ng) { \n                                res = false;\n                        }\n                }\n        };\n        dfs(0, -1);\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int a = 0;\n        for (int i = 0; i < n; i ++) {\n                if ((int) g[i].size() & 1) a ++;\n        }\n        assert(a % 2 == 0);\n        a /= 2;\n        int lb = 0, ub = n;\n        while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ok(mid, n, g)) {\n                        ub = mid;\n                } else {\n                        lb = mid;\n                }\n        }\n        printf(\"%d %d\\n\", a, ub);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::vector<int32_t> edge[100000];\n\nvolatile bool func_ok = false;\nint32_t len_max;\nint32_t func(int32_t v, int32_t parent)\n{\n\tif (edge[v].size() == 1) {\n\t\treturn 0;\n\t}\n\tif (edge[v].size() == 2) {\n\t\tfor (auto& e : edge[v]) {\n\t\t\tif (e != parent) { return 1 + func(e, v); }\n\t\t}\n\t}\n\n\tstd::multiset<int32_t, std::greater<int32_t>> L;\n\tfor (auto& e : edge[v]) {\n\t\tif (e != parent) {\n\t\t\tL.insert(1 + func(e, v));\n\t\t}\n\t}\n\tif (L.size() % 2 == 0) {\n\t\tL.insert(0);\n\t}\n\twhile (L.size()>=2) {\n\t\tauto iter2 = L.begin();\n\t\tauto iter1 = L.lower_bound(len_max - *iter2);\n\t\tif (iter1 == L.end()) {\n\t\t\tfunc_ok = false;\n\t\t\treturn 0;\n\t\t}\n\t\tif (iter1 == iter2) {\n\t\t\t++iter1;\n\t\t}\n\t\tL.erase(iter1);\n\t\tL.erase(iter2);\n\t}\n\treturn *L.begin();\n}\nbool func_2(int32_t v)\n{\n\tfunc_ok = true;\n\tauto res = (func(edge[v][0], v) + 1 <= len_max);\n\treturn func_ok&&res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N-1; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\n\tint32_t A = 1;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tA += (edge[i].size() - 1) / 2;\n\t}\n\tout << A << ' ';\n\n\tint32_t root = 0;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tif (edge[i].size() == 1) {\n\t\t\troot = i; break;\n\t\t}\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = N-1, ng_range = 0;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\t\tlen_max=mid;\n\t\tis_ok = func_2(root);\n\n\t\tif (is_ok) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n\nint n, i, x, y, cnt, limit;\nvector<int> list[maxN];\nint dp[maxN];\nbool bad;\nmultiset<int> aux;\nvector<int> heads;\n\nvoid dfs(int node, int root) {\n    for (auto to : list[node])\n        if (to != root && bad == false)\n            dfs(to, node);\n\n    if (bad) return;\n\n    aux.clear(); heads.clear();\n\n    for (auto to : list[node])\n        if (to != root)\n            aux.insert(dp[to] + 1);\n\n    if (aux.size() % 2 == 0 && node != 1) aux.insert(0), cnt++;\n    while (aux.size() > 1) {\n        auto it = aux.end(); it--;\n        int big = *it;\n        aux.erase(it);\n\n        it = aux.upper_bound(limit - big);\n        if (it == aux.begin()) {\n            heads.pb(big);\n        } else {\n            it--;\n            aux.erase(it);\n            cnt--;\n        }\n    }\n\n    if (aux.size() == 1) heads.pb(*aux.begin());\n    if (heads.size() > 2) {\n        bad = true;\n        return;\n    }\n\n    if (heads.size() == 1) {\n        dp[node] = heads[0];\n    } else {\n        dp[node] = 0;\n    }\n}\n\nbool check(int _limit) {\n    cnt = 0;\n    limit = _limit;\n    bad = false;\n    dfs(1, 0);\n    if (dp[1] > limit) return false;\n    if (bad) return false;\n    return true;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    for (i = 1; i < n; i++) {\n        cin >> x >> y;\n        list[x].pb(y);\n        list[y].pb(x);\n    }\n\n    int ans = 0;\n    for (int step = 1 << 20; step > 0; step >>= 1)\n        if (ans + step < n)\n            if (!check(ans + step))\n                ans += step;\n\n    check(2);\n\n    check(ans + 1);\n    cout << cnt << ' ' << ans + 1;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrt(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-15;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint n;\nvint edge[100010];\n\nint solve(int cur, int parent, int m) {\n\tvint v;\n\trep(i, edge[cur].size()) {\n\t\tif (edge[cur][i] == parent)\tcontinue;\n\t\tint ret = solve(edge[cur][i], cur, m);\n\t\tif (ret == -1)\treturn -1;\n\t\tv.push_back(ret);\n\t}\n\t// add self=0\n\tif (edge[cur].size() & 1)\tv.push_back(0);\n\tsort(all(v));\n\tif (parent == -1) {\n\t\trep(i, v.size() / 2) {\n\t\t\tif (v[i] + v[v.size() - i - 2] > m)\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\trep(i, (v.size() - 1) / 2) {\n\t\t\tif (v[i] + v[v.size() - i - 2] > m)\treturn -1;\n\t\t}\n\t\tfor (int i = v.size(); i > 0; i--) {\n\t\t\tint p = v.size() - i - 1;\n\t\t\tif (p >= i)\tp++;\n\t\t\tif (v[i] + v[p] > m)\treturn v[i] + 1;\n\t\t}\n\t\treturn v[0] + 1;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint a, b;\tcin >> a >> b;\ta--;\tb--;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tint A = 0;\n\trep(i, n)\tA += (edge[i].size() & 1);\n\tA >>= 1;\n\tint left = 0, right = n;\n\trep(i, 100) {\n\t\tint mid = (left + right) >> 1;\n\t\tif (solve(0, -1, mid) == -1)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\tcout << A << \" \" << right << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(l==son) ++l;\n\t\tif(r==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tif(!treeDP(v,u)) return false;\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(rt,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\tcal_A();\n\tfor(int i=1;i<=n;++i){\n\t\tif(deg[i]&1){\n\t\t\trt=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.begin();\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n    for(int i=1;i<=n;++i){\n        if(V[i].size()%2) ++all;\n    }\n    all=all/2;\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    assert(ans==all);\n    ans=all;\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t\t\t\t\t\nusing namespace std;\n\t\t\t\ntypedef long long ll;\n#define mp make_pair\n#define pub push_back\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define db long double\n#define sz(a) (int)a.size()\n\nint n;\nvector<int> g[100007];\n\nint calcCnt(int v, int pred){\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tans += calcCnt(to, v);\n\t\tcnt++;\n\t}\n\tif (v != 0) cnt--;\n\tans += (cnt + 1) / 2;\n\treturn ans;\n}\n\nbool f;\nint ww;\n\nint dfs(int v, int pred){\n\tif (g[v].size() == 1 && g[v][0] == pred) return 0;\n\tvector<int> t;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tt.pub(dfs(to, v) + 1);\n\t}\n\tsort(all(t));\n\tif (t.back() > ww){\n\t\tf = 0;\n\t\treturn 0;\n\t}\n\tif (v == 0){\n\t\tif (t.size() % 2 == 1) t.pop_back();\n\t\tfor (int i = 0; i < t.size() / 2; i++){\n\t\t\tif (t[i] + t[(int)t.size() - i - 1] > ww){\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (t.size() % 2 == 0) t.pop_back();\n\t\tint vl = -1, vr = t.size();\n\t\twhile(vl + 1 < vr){\n\t\t\tint vm = (vl + vr) >> 1;\n\t\t\tbool ok = 1;\n\t\t\tvector<int> tmp;\n\t\t\tfor (int i = 0; i < t.size(); i++) if (i != vm) tmp.pub(t[i]);\n\t\t\tfor (int i = 0; i < tmp.size() / 2; i++) if (tmp[i] + tmp[(int)tmp.size() - i - 1] > ww){\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\tvr = vm;\n\t\t\telse\n\t\t\t\tvl = vm;\n\t\t}\n\t\tif (vr == t.size()){\n\t\t\tf = 0;\n\t\t\treturn 0;\n\t\t} \n\t\treturn t[vr];\n\t}\n}\n\nbool can(int val){ \n\tf = 1; ww = val;\n\tdfs(0, -1);\n\treturn f;\n}\n\nint main(){\n\tsrand(123321);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pub(b);\n\t\tg[b].pub(a);\n\t}\n\n\tint vl = 0, vr = 1e9 + 7;\n\twhile(vl + 1 < vr){\n\t\tint vm = (vl + vr) >> 1;\n\t\tif (can(vm))\n\t\t\tvr = vm;\n\t\telse\n\t\t\tvl = vm;\n\t}\n\tcout << calcCnt(0, -1) << ' ' << vr;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nconst int MAXN = 1e5 + 10;\n\nstruct Edge {\n  int v, next;\n}edge[MAXN << 1];\nint head[MAXN], tail, n, deg[MAXN];\nvoid insert(int u, int v) {\n  edge[++tail] = (Edge) {v, head[u]}; head[u] = tail;\n}\nnamespace solver1 {\n  int f[MAXN];\n  int bound;\n  bool dfs(int u, int fa) {\n    std::vector <int> dps;\n    for (int i = head[u]; i; i = edge[i].next) {\n      int v = edge[i].v;\n      if (v == fa) continue;\n      if (!dfs(v, u)) return 0;\n      dps.push_back(f[v]);\n    }\n    if (deg[u] & 1) dps.push_back(0);\n    std::sort(dps.begin(), dps.end());\n    int l = 0, r = dps.size() - 1;\n    while(l <= r) {\n      int mid = (l + r) >> 1;\n      bool flag = 1;\n      for (int i = (mid == 0 ? 1 : 0), j = ((int) dps.size() - 1 == mid ? dps.size() - 2 : dps.size() - 1); i <= j; i += 1 + (i + 1 == mid), j -= 1 + (j - 1 == mid)) {\n        if (dps[i] + dps[j] > bound) {flag = 0; break;}\n      } \n      if (flag) {\n        f[u] = dps[mid];\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    f[u]++;\n    return f[u];\n  }\n  bool check() {\n    memset(f, -1, sizeof f);\n    return dfs(1, 0) \n      && f[1] <= bound + 1;\n  }\n  void main() {\n    int ans1 = 0;\n    for (int i = 1; i <= n; i++) { \n      if (deg[i] & 1) ans1++; \n    }\n    ans1 /= 2;\n    printf(\"%d \", ans1);\n    int l = 1, r = n, ans2 = 0;\n    deg[1]++;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      bound = mid;\n      if (check()) {\n        ans2 = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    printf(\"%d\\n\", ans2);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    insert(a, b);\n    insert(b, a);\n    deg[a]++; deg[b]++;\n  }\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid make_dfs(const Graph& g_, Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (not used[to]) {\n            g.addEdge(s, to);\n            make_dfs(g_, g, to, used);\n        }\n    }\n}\n\nusing P = pair<int, int>;\nint K;\nbool dp_dfs(const Graph& g, const int s, vector<P>& dp)\n{\n    const int C = g.edge[s].size();\n    multiset<int> st;\n    if (s != 0) {\n        st.insert(0);\n    }\n    int sum = 0;\n    for (const int to : g.edge[s]) {\n        const bool f = dp_dfs(g, to, dp);\n        if (not f) {\n            return false;\n        }\n        st.insert(dp[to].second);\n        sum += dp[to].first;\n    }\n    const int size = st.size();\n    sum += (size - 1) / 2;\n    if (size % 2 == 1) {\n        st.insert(0);\n    }\n\n    int mini = 10000;\n    while (not st.empty()) {\n        auto it = st.end();\n        it--;\n        const int v = *it;\n        st.erase(it);\n        auto upp = st.upper_bound(K - v - 1);\n        if (upp == st.begin()) {\n            return false;\n        }\n        upp--;\n        if (*upp == 0 or v == 0) {\n            mini = min(mini, *upp + v + 1);\n        }\n        st.erase(upp);\n    }\n    dp[s] = {sum, mini};\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    Graph g_(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g_.addEdge(a, b);\n        g_.addEdge(b, a);\n    }\n    Graph g(N);\n    vector<bool> used(N, false);\n    make_dfs(g_, g, 0, used);\n\n    vector<P> dp(N);\n    int inf = 0;\n    int sup = N + 1;\n    while (inf < sup) {\n        K = (inf + sup) / 2;\n        if (dp_dfs(g, 0, dp)) {\n            sup = K;\n        } else {\n            if (inf == K) {\n                break;\n            }\n            inf = K;\n        }\n    }\n    K = sup;\n    dp_dfs(g, 0, dp);\n    show(dp);\n    cout << dp[0].first + 1 << \" \" << sup - 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =1002;\nconst int MOD =1000000007;\nvector<int> hen[100000];\nbool used[100000];\nint ok,ng,mid;\nint dfs(int a,bool a0){\n  used[a]=true;\n  vector<int> v;\n  for(auto&& i:hen[a])if(!used[i]){\n    int b=dfs(i,false);\n    if(b==-1)return -1;\n    v.push_back(b+1);\n  }\n  sort(v.begin(),v.end());\n  if(v.size()%2==0){\n    bool t=true;\n      for(int i=0;i*2<v.size();i++){\n        if(v[i]+v[v.size()-1-i]>mid){\n          t=false;\n          break;\n        }\n      }\n    if(t)return 0;\n    if(v[v.size()-1]>mid||a0)return -1;\n    v.pop_back();\n  }\n  \n    int ok2=v.size(),ng2=-1,mid2;\n    while(abs(ok2-ng2)>1){\n      mid2=(ok2+ng2)/2;\n      bool t=true;\n      for(int i=0;i*2<v.size()-1;i++){\n        if(v[i+(i>=mid2)]+v[v.size()-2-i+(v.size()-2-i>=mid2)]>mid){\n          t=false;\n          break;\n        }\n      }\n      if(t)ok2=mid2;\n      else ng2=mid2;\n    }\n    return v[ok2];\n    \n  \n}\nsigned main(){\n int n,a,b,ansa=1;\n cin>>n;\n for(int i=0;i<n-1;i++){\n   cin>>a>>b;\n   a--;b--;\n   hen[a].push_back(b);\n   hen[b].push_back(a);\n }\n for(int i=0;i<n;i++)ansa+=(hen[i].size()-1)/2;\n  ng=0;ok=n;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    fill(used,used+n,false);\n    int y=dfs(0,true);\n    if(y==-1||y>mid)ng=mid;\n    else ok=mid;\n  }\n  cout<<ansa<<' '<<ok<<endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint N;\nvector<int> G[100000];\n\nint DFS(int i, int prev, int len) {\n\tstd::vector<int> lens;\n\tfor (int to : G[i]) {\n\t\tif (to == prev) continue;\n\t\tlens.push_back(DFS(to, i, len) + 1);\n\t}\n\n\tif (lens.size() == 0) return 0;\n\tif (lens.size() % 2 == 0) lens.push_back(0);\n\tsort(lens.begin(), lens.end());\n\n\tint lo = -1;\n\tint hi = lens.size();\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tint mx = 0;\n\n\t\tint l = 0;\n\t\tint r = lens.size() - 1;\n\t\twhile (l + 1 < r) {\n\t\t\tif (l == mid) ++l;\n\t\t\tif (r == mid) --r;\n\t\t\tmx = max(mx, lens[l] + lens[r]);\n\t\t\t++l;\n\t\t\t--r;\n\t\t}\n\t\tif (mx <= len) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\treturn hi == lens.size() ? INF : lens[hi];\n}\n\nbool OK(int len) {\n\tint i = 0;\n\twhile (G[i].size() != 1) {\n\t\t++i;\n\t}\n\tint a = DFS(i, -1, len);\n\treturn a <= len;\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tint ans = 1;\n\tREP(i, 0, N) {\n\t\tans += (G[i].size() - 1) / 2;\n\t}\n\n\tint lo = 0;\n\tint hi = 150001;\n\twhile (lo + 1 < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (OK(mid)) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << ans << ' ' << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<set>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,ans,ans2=n+n,l,r,mid,x,y,dis[100005];\nvector<int> bi[100005];\nbool dfs(int x,int fa)\n{\n\tint i;\n\tvector<int> len;\n\tfor (i=0;i<bi[x].size();i++)\n\t{\n\t\tif (bi[x][i]==fa) continue;\n\t\tif (!dfs(bi[x][i],x)) return 0;\n\t\tlen.push_back(dis[bi[x][i]]+1);\n\t}\n\tif (x==1&&len.size()%2==1) len.push_back(0);\n\tsort(len.begin(),len.end());\n\tset<int> s;\n\tfor (i=0;i<len.size();i++) s.insert(i);\n\tint j=len.size()-1;i=0;\n\tint t=len.size()/2;\n\twhile (i<j&&t)\n\t{\n\t\twhile (t&&i<=j&&len[i]+len[j]>mid)\n\t\t{\n\t\t\tif (len[j]<=mid)\n\t\t\t{\n\t\t\t\ts.erase(j);\n\t\t\t\tt--;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t\tif (i>=j||!t) break;\n\t\ts.erase(i);\n\t\ts.erase(j);\n\t\ti++;\n\t\tj--;\n\t\tt--;\n\t}\n\tif (s.size()>1) return 0;\n\tif (s.size()==1) dis[x]=len[*s.begin()];\n\treturn 1;\n}\nbool check(int x)\n{\n\tint i;\n\tmemset(dis,0,sizeof(dis));\n\tif (!dfs(1,0)) return 0;\n\tif (dis[1]>x) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tbi[x].push_back(y);\n\t\tbi[y].push_back(x);\n\t}\n\tans=n-1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tans-=bi[i].size()/2;\n\t}\n\tl=0;r=n+n;\n\twhile (l<r)\n\t{\n\t\tmid=(l+r+1)/2;\n\t\tif (check(mid))\n\t\t{\n\t\t\tr=mid-1;\n\t\t\tans2=mid;\n\t\t}\n\t\telse l=mid;\n\t}\n\tcout<<ans<<' '<<ans2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tvector<int> vec;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tvec.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tif(vec.size()==0)return P(1,1);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=vec.size()-1;\n\tfor(int i=0;i<vec.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vec[l]+vec[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vec[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && p!=-1){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(0,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,h;\nvvi G;\n\nint f(vi a,int b){\n\tint l=0,r=a.size()-1;\n\twhile(l<r){\n\t\tif(l==b)l++;\n\t\tif(r==b)r--;\n\t\tif(a[l]+a[r]>h)return false;\n\t\tl++;r--;\n\t}\n\treturn true;\n}\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tt.pb(1+dfs(to,a));\n\t}\n\tif(t.size()==0)return 0;\n\tif(t.size()==1)return t[0];\n\tsort(all(t));\n\tif(t.back()>h)return inf;\n\tint out=inf;\n\tif(t.size()%2==0&&f(t,-1))out=0;\n\tif(!a)return out;\n\tif(t.size()%2==0){\n\t\tauto it=t.end();\n\t\tit--;\n\t\tt.erase(it);\n\t}\n\tint l=-1,r=t.size()-1;\n\twhile(r-l>1){\n\t\tint hh=(l+r)/2;\n\t\tif(f(t,hh))r=hh;\n\t\telse l=hh;\n\t}\n\tif(f(t,r))cmin(out,t[r]);\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint A=1;\n\trep(i,n)A+=(G[i].size()-1)/2;\n\tcout<<A<<\" \";\n\tint l=-1,r=n-1;\n\twhile(r-l>1){\n\t\th=(l+r)/2;\n\t\tif(dfs(0,-1)>h)l=h;\n\t\telse r=h;\n\t}\n\tcout<<r<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=100005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tmultiset<int> s;\n\tsort(all(v));\n\tfor(auto i:v) s.insert(i);\n\tfor(int i=SZ(v)-1;~i&&SZ(s)>1;i--){\n\t\tif(s.find(v[i])==s.end()) continue;\n\t\ts.erase(s.find(v[i]));\n\t\tauto it=s.upper_bound(B-v[i]-1);\n\t\tif(it!=s.begin())s.erase(--it);\n\t\tres++;\n\t}\n\tif(SZ(s)==1){\n\t\tint p=*s.begin();\n\t\tif(p+1==B){res++;return 1;}\n\t\treturn p+1;\n\t}\n\treturn 1;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"08.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tA++;\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;if(dfs(1)!=1) res++;\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, x;\nbool ok;\nint r = 0;\nbool used[N];\n\nint dfs(int u){\n\tused[u] = true;\n\tmultiset<int> d;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tint t = dfs(v)+1;\n\t\td.insert(t);\n\t\tif(!ok) return INF;\n\t}\n\tif(d.size()%2==0) d.insert(0);\n\twhile(d.size()>1){\n\t\tauto it = d.end(); --it;\n\t\tint k = *it;\n\t\td.erase(it);\n\t\tauto it2 = d.upper_bound(x-k);\n\t\tif(it2==d.begin()){\n\t\t\tok = false;\n\t\t\treturn INF;\n\t\t}\n\t\t--it2;\n\t\td.erase(it2);\n\t}\n\tif(*d.begin()>x) ok = false;\n\tused[u] = false;\n\treturn *d.begin();\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint resa = 0, resb = 0;\n\trep(i, n){\n\t\tresa += (g[i].size()-1)/2;\n\t\tresb += g[i].size()%2;\n\t\tif(g[i].size()==1) r = i;\n\t}\n\tresa++; resb /= 2;\n\tif(resa!=resb) return -1;\n\tint lb = -1, ub = n;\n\twhile(ub-lb>1){\n\t\tx = (lb+ub+1)/2;\n\t\tok = true;\n\t\tmset(used, 0);\n\t\tdfs(r);\n\t\t(ok?ub:lb)=x;\n\t}\n\tcout<<resb<<\" \"<<ub<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint B, r;\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\tassert(i >= 0);\n\t\treturn v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, t, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\ttr = 1;\n\tfor (i = 1; i <= n; i++) tr += (g[i].size() - 1) / 2;\n\tB = n;\n\tt = f(1, 1);\n\tif (t) r++;\n\tassert(r == tr);\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tt = f(1, 1);\n\t\tif (t) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int to = -1, int from = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconst int INF = std::numeric_limits<int>::max() / 3;\n\nusing namespace std;\n\n\nGraph<> tree;\nint A, B;\n\n// Aを求める\nvoid dfs1(int v, int r) {\n    int ch = 0;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ++ch;\n        dfs1(e.to, v);\n    }\n    A += ch / 2;\n}\n\n// パスの最大長がB以下になるようにしたとき、\n// 親に送られるパスの最小値(無理ならINF)を返す\nint dfs2(int v, int r) {\n    vector<int> ch;\n    for (auto e : tree[v]) {\n        if (e.to == r) continue;\n        ch.push_back(dfs2(e.to, v) + 1);\n        if (ch.back() > B) return INF;\n    }\n\n    // ダミーを仕込んで奇数の場合に帰着させる\n    if (ch.size() % 2 == 0) ch.push_back(0);\n\n    sort(ch.begin(), ch.end());\n\n    int ok = ch.size(), ng = -1;\n    // ok番目抜きで、和の最大値がB以下になるようマッチングできる\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n\n        bool judge = true;\n        for (int l = 0, r = ch.size() - 1; l < r; ++l, --r) {\n            if (l == mid) ++l;\n            if (r == mid) --r;\n            if (ch[l] + ch[r] > B) judge = false;\n        }\n\n        (judge ? ok : ng) = mid;\n    }\n\n    return (ok == ch.size() ? INF : ch[ok]);\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    tree = Graph<>(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree[u].emplace_back(v);\n        tree[v].emplace_back(u);\n    }\n\n    int r;\n    for (r = 0; tree[r].size() > 1; ++r) {}\n\n    A = 0;\n    dfs1(r, -1);\n    ++A;  // 根から出てくるパスを受け取る\n\n    // Bを二分探索\n    int ok = N, ng = -1;\n    while (ok - ng > 1) {\n        int mid = (ok + ng) / 2;\n        B = mid;\n        (dfs2(r, -1) <= mid ? ok : ng) = mid;\n    }\n\n    cout << A << \" \" << ok << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n; cin>>n;\n  vvi G(n);\n  FOR(i,n-1) {\n    int a,b; cin>>a>>b;\n    --a; --b;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  { int a = 0;\n    FOR(i,n) if(G[i].size()&1) a += 1;\n    cout << a/2 << ' ';\n  }\n\n  auto ok = [&](int b) -> bool {\n    function<int(int, int)> dfs = [&](int i, int p) -> int {\n      deque<int> rs;\n      for(int j : G[i]) if(j != p) {\n          int r = dfs(j,i);\n          if(r>b) throw 0;\n          rs.pb(r);\n      }\n      sort(all(rs));\n      if(p == -1) {\n        if(rs.size()&1) {\n          if(rs.back() > b) throw 0;\n          rs.pop_back();\n        }\n        FOR(i,rs.size()) if(rs[i]+rs[rs.size()-1-i] > b) throw 0;\n        return 0;\n      }else{\n        if((rs.size()&1) == 0) rs.pb(0);\n        int r0 = rs.front(); rs.pop_front();\n        while(!rs.empty()) {\n          if(rs.front()+rs.back() > b) {\n            if(r0+rs.back() > b) throw 0;\n            r0 = rs.front(); rs.pop_front(); rs.pop_back();\n          }else{\n            rs.pop_front();\n            rs.pop_back();\n          }\n        }\n        return r0+1;\n      }\n    };\n    try {\n      dfs(0,-1);\n      return 1;\n    } catch(int){\n      return 0;\n    }\n  };\n\n  int lo = 1, hi = n;\n  while(lo != hi) {\n    int mi = (lo+hi)/2;\n    if(ok(mi)) { hi = mi; }\n    else { lo = mi+1; }\n  }\n  cout << lo << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<stdlib.h>\n#include<ctime>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define LL long long\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef long double ld;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nbool ok;\nint nxt[500010],f[500010],d[500010],l,r,o,ans,L,R,O,n,x,y,hed[500010],too[500010],nedge,stk[500010],top;\nvoid ae(int x,int y){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n}\nbool check(int o){\n\tint p=0,q=top+1;\n\tFOR(i,1,top/2){\n\t\t++p,--q;\n\t\tif (p==o) ++p;\n\t\tif (q==o) --q;\n\t\tif (stk[p]+stk[q]>O) return 0;\n\t}\n\treturn 1;\n}\nvoid dfs(int x,int l){\n\tif (!ok) return;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tdfs(y,x);\n\t}\n\ttop=0;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (y==l) continue;\n\t\tstk[++top]=f[y];\n\t\tif (f[y]==-1){ok=0;return;}\n\t}\n\tif (d[x]%2==0){\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n\telse{\n\t\tstk[++top]=0;\n\t\tsort(stk+1,stk+top+1);\n\t\tif (!check(top)){f[x]=-1;return;}\n\t\tl=1,r=top;\n\t\twhile (l<r){\n\t\t\to=l+r>>1;\n\t\t\tif (check(o)) r=o;\n\t\t\telse l=o+1;\n\t\t}\n\t\tf[x]=stk[r]+1;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tgetint(x),getint(y);\n\t\tae(x,y),ae(y,x);\n\t\t++d[x],++d[y];\n\t}\n\tFOR(i,1,n) ans+=d[i]&1;\n\tcout<<ans/2<<' ';\n\t++d[1];\n\tL=0,R=n;\n\twhile (L<R){\n\t\tO=L+R>>1;\n\t\tok=1;\n\t\tdfs(1,0);\n\t\tif (f[1]>O+1 || f[1]==-1) ok=0;\n\t\tif (ok) R=O;\n\t\telse L=O+1;\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nll N;\nvector<vll> G;\nll degree[100010];\n\nll dp[100010];\nbool dfs(ll v,ll p,const ll &x){\n  bool ret=true;\n  vll V;\n  for(ll u:G[v])if(p!=u){\n    ret &= dfs(u,v,x);\n    V.push_back(dp[u]+1);\n  }\n  if(!ret)return false;\n  sort(V.begin(),V.end());\n  if(V.size()&1){\n    ll low=-1,high=V.size();\n    while(high-low>1){\n      bool isok=true;\n      ll mid = (low+high)/2;\n      ll l=0,r=V.size()-1;\n      for(ll i=0;i<V.size()/2;i++){\n        if(l==mid){\n          l++;\n        }\n        if(r==mid){\n          r--;\n        }\n        isok &= V[l]+V[r]<=x;\n        l++;\n        r--;\n      }\n      if(isok){\n        high = mid;\n      }else{\n        low = mid;\n      }\n    }\n    if(high==V.size()){\n      return false;\n    }\n    dp[v] = V[high];\n  }else{\n    bool isok=true;\n    ll l=0,r=V.size()-1;\n    for(ll i=0;i<V.size()/2;i++){\n      isok &= V[l]+V[r]<=x;\n      l++;\n      r--;\n    }\n    if(!isok){\n      //cerr<<\"!!\"<<endl;\n      ret &= V.back()<=x;\n      V.pop_back();\n      ll low=-1,high=V.size();\n      while(high-low>1){\n        isok=true;\n        ll mid = (low+high)/2;\n        l=0,r=V.size()-1;\n        for(ll i=0;i<V.size()/2;i++){\n          if(l==mid){\n            l++;\n          }\n          if(r==mid){\n            r--;\n          }\n          isok &= V[l]+V[r]<=x;\n          l++;\n          r--;\n        }\n        if(isok){\n          high = mid;\n        }else{\n          low = mid;\n        }\n      }\n      if(high==V.size()){\n        return false;\n      }\n      dp[v] = V[high];\n    }\n  }\n  ret &= dp[v]<=x;\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll a,b;cin>>a>>b;a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    degree[a]++;\n    degree[b]++;\n  }\n  ll A=1;\n  for(ll i=0;i<N;i++){\n    A += (degree[i]-1)/2;\n  }\n  ll low=-1,high=N;\n  while(high-low>1){\n    ll mid=(high+low)/2;\n    //debug(mid);\n    fill(dp,dp+N,0);\n    if(dfs(0,-1,mid)){\n      high = mid;\n    }else{\n      low = mid;\n    }\n    //debugArray(dp,N);\n  }\n  cout<<A<<\" \"<<high<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tvi e[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n - 1) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\te[x].pb(y);\n\t\t\te[y].pb(x);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tint ans_a, ans_b;\n\t\n\tvoid write () {\n\t\tcout << ans_a << ' ' << ans_b << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint root;\n\t\tint mxl;\n\t\t\n\t\tint rec (int v, int pr) {\n\t\t\tvi q;\n\t\t\tfor (int to : e[v]) {\n\t\t\t\tif (to == pr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint val = rec(to, v);\n\t\t\t\tif (val == -1 || val + 1 > mxl) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tq.pb(val + 1);\n\t\t\t}\n\t\t\tsort(all(q), greater<int>());\n\t\t\t\n\t\t\tif (!sz(q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tint val0 = q[0];\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tq[0] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tint j = 0;\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (j < sz(q) && (j <= i || q[j] == -1 || q[i] + q[j] > mxl)) {\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tif (j < sz(q)) {\n\t\t\t\t\tassert(q[i] != -1);\n\t\t\t\t\tassert(q[j] != -1);\n\t\t\t\t\tq[i] = q[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvi qq;\n\t\t\tif (sz(q) % 2 == 0) {\n\t\t\t\tqq.pb(val0);\n\t\t\t}\n\t\t\tforn (i, sz(q)) {\n\t\t\t\tif (q[i] != -1) {\n\t\t\t\t\tqq.pb(q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sz(qq) == 2 && qq[0] + qq[1] <= mxl) {\n\t\t\t\tqq.clear();\n\t\t\t}\n\t\t\t\n\t\t\tif (sz(qq) == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (sz(qq) == 1) {\n\t\t\t\treturn qq[0];\n\t\t\t} else if (sz(qq) == 2) {\n\t\t\t\treturn qq[1];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\n\t\tbool check (int val) {\n\t\t\tmxl = val;\n\t\t\treturn rec(root, -1) != -1;\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\troot = 0;\n\t\t\twhile (sz(e[root]) > 1) {\n\t\t\t\troot++;\n\t\t\t}\n\t\t\t\n\t\t\tans_a = 0;\n\t\t\tforn (i, n) {\n\t\t\t\tif (sz(e[i]) & 1) {\n\t\t\t\t\tans_a++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_a /= 2;\n\t\t\t\n\t\t\tint lb = 0, rb = 1000000000;\n\t\t\twhile (lb < rb) {\n\t\t\t\tint md = (lb + rb) / 2;\n\t\t\t\tif (check(md)) {\n\t\t\t\t\trb = md;\n\t\t\t\t} else {\n\t\t\t\t\tlb = md + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_b = lb;\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N, mid;\nvi adj[MX];\nbool ok;\n\nbool OK(int cur, vi v, int ind) {\n    if (cur != 1 && v[ind]+1 > mid) return 0;\n    v.erase(v.begin()+ind);\n    for (int i = 0; i < sz(v)-1-i; ++i) if (v[i]+v[sz(v)-1-i] > mid) return 0;\n    return 1;\n}\n\nint test(int cur, int pre) {\n    if (!ok) return 0;\n    vi v; for (int i: adj[cur]) if (i != pre) v.pb(test(i,cur));\n    if (!ok) return 0;\n    \n    if (sz(v) % 2 == 0) v.pb(0);\n    sort(all(v));\n    int lo = 0, hi = sz(v);\n    while (lo < hi) {\n        int mid = (lo+hi)/2;\n        if (OK(cur,v,mid)) hi = mid;\n        else lo = mid+1;\n    }\n    // cout << \"ZZ \" << cur << \" \" << lo << \" \" << sz(v) << \" \" << v[0] << \"\\n\";\n    if (lo == sz(v)) {\n        ok = 0;\n        return 0;\n    }\n    // cout << \"HAHA \" << ok << \" \" << cur << \" \" << v[lo] << \"\\n\";\n    return v[lo]+1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N;\n    F0R(i,N-1) {\n        int a,b; cin >> a >> b;\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    // cout << ok << \"\\n\";\n    int A = 0; FOR(i,1,N+1) if (sz(adj[i])&1) A++;\n    int lo = 1, hi = N-1; \n    while (lo < hi) {\n        mid = (lo+hi)/2;\n        ok = 1; test(1,0);\n        if (ok) hi = mid;\n        else lo = mid+1;\n    }\n    cout << A/2 << \" \" << lo;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint B, r;\nvector<int> g[100001];\n\nint f(int x, int y) {\n\tvector<int> v;\n\tfor (auto t : g[x]) if (t != y) {\n\t\tint z = f(t, x) + 1;\n\t\tif (!z) return -1;\n\t\tif (z == B) r++;\n\t\telse v.push_back(z);\n\t}\n\tint i, j;\n\tsort(v.begin(), v.end());\n\tfor (i = 0, j = (int)v.size() - 1; i < j; j--, r++) if (v[i] + v[j] <= B) i++;\n\tif (i == j) {\n\t\tfor (j++; j < v.size() && v[i] + v[j] <= B; i--, j++);\n\t\treturn v[i];\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint L, R;\n\tint i, j, k, n, tr;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &j, &k);\n\t\tg[j].push_back(k);\n\t\tg[k].push_back(j);\n\t}\n\ttr = 0;\n\tfor (i = 1; i <= n; i++) tr += g[i].size() % 2;\n\ttr >>= 1;\n\tB = n;\n\tif (f(1, 1)) r++;\n\tassert(r == tr);\n\tL = 1;\n\tR = n;\n\twhile (L < R) {\n\t\tB = (L + R) / 2;\n\t\tr = 0;\n\t\tif (f(1, 1)) r++;\n\t\tif (r == tr) R = B;\n\t\telse L = B + 1;\n\t}\n\tprintf(\"%d %d\\n\", tr, L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n#include<cassert>\n#include<set>\nstruct kk\n{\n\tint v;\n};\nbool operator <(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nbool cmp(const kk &x,const kk &y)\n{\n\treturn x.v>y.v;\n}\nstd::multiset<kk> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int k)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,k)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to]+1;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tassert(pv%2==0);\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>k)return 0;\n\t}\n\telse\n\t{\n\t\tpv=0;\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)v[++pv]=f[e[p].to]+1;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tint ans=pv;\n\t\tfor(register int l=1,r=pv,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\t{\n\t\t\tfor(register int x=mid==1?2:1,y=mid==pv?pv-1:pv;x<y;)\n\t\t\t{\n\t\t\t\tif(v[x]+v[y]>k)goto skip;\n\t\t\t\t++x,--y;\n\t\t\t\tif(x==mid)++x;\n\t\t\t\tif(y==mid)--y;\n\t\t\t}\n\t\t\tans=mid;\n\t\t\tr=mid-1;\n\t\t\tcontinue;\n\t\t\tskip:;\n\t\t\tl=mid+1;\n\t\t}\n\t\tf[o]=v[ans];\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,1,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(3);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\n\nint dfs(int cur,int pre,int T) {\n\tmultiset<int> V;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tint ret=dfs(e,cur,T);\n\t\tif(ret==-2) return -2;\n\t\tif(ret>=0) V.insert(ret+1);\n\t}\n\tif(E[cur].size()%2) V.insert(0);\n\t\n\tint cand=-1;\n\twhile(V.size()) {\n\t\tint x=*V.rbegin();\n\t\tV.erase(V.find(x));\n\t\t\n\t\tauto it=V.lower_bound(T-x+1);\n\t\tif(it==V.begin()) {\n\t\t\tif(cand!=-1) return -2;\n\t\t\tcand=x;\n\t\t}\n\t\telse {\n\t\t\tit--;\n\t\t\tV.erase(it);\n\t\t}\n\t}\n\treturn cand;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tint A=0;\n\tFOR(i,N) if(E[i].size()%2==1) A++;\n\t\n\tint B=1<<20;\n\tfor(i=19;i>=0;i--) {\n\t\tif(dfs(0,-1,B-(1<<i))!=-2) B-=1<<i;\n\t}\n\t\n\tcout<<A/2<<\" \"<<B<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n    set<pair<int,int> > S;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        S.insert(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(S.empty()){\n        dp[n]=1;return;\n    }\n\n  //  cout << n << \" \" << S.size() << \" size\" <<   endl;\n    auto it=S.begin();\n    bool flag=0;\n    dp[n]=1000000000;\n    while(!S.empty()){\n        it=S.end();--it;\n       // cout << (*it).first << \" \" << (*it).second << \" pair\" << endl;\n        auto ip=S.upper_bound(make_pair(mid-1-(*it).first,1000000000));\n        if(ip==S.begin()){\n            dp[n]=min(dp[n],(*it).first+1);\n\n            //cout << \"A\" << endl;\n            S.erase(it);--ok;continue;\n        }\n        --ip;\n        if(ip==it){\n            if(ip==S.begin()){\n                 dp[n]=min(dp[n],(*it).first+1);\n               // cout << \"B\" << endl;\n               --ok;S.erase(ip);\n               continue;\n            }\n            --ip;\n\n        }\n\n        S.erase(it);S.erase(ip);--ok;\n\n    }\n\n    ++ok;\n\n   if(dp[n]>=mid && dp[n]<1000000000 && n!=1){\n    dp[n]=2;--ok;\n   }\n   else if(dp[n]==1000000000){\n    dp[n]=1;\n   }\n   else if(dp[n]>mid && dp[n]<1000000000 && n==1){\n    dp[n]=2;--ok;\n   }\n//cout << n << \" \" << dp[n] << \" \" << ok << \" \" << mid << endl;\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n    //++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(ok>0){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(ok>0){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nint a;\n\nbool good;\nint c;\n\nint dfs(int now, int past){\n    if (!good) return 0;\n    VI a;\n    for (int next : e[now]){\n        if (next == past) continue;\n        a.push_back(dfs(next, now) + 1);\n    }\n    sort(ALL(a));\n    int n = a.size();\n    REP(i,n) if (a[i] > c) good = false;\n    if (n % 2 == 0){\n        int ret = 0;\n        if (past == -1) ret = 1e9;\n        REP(i,n/2){\n            if (a[i] + a[n-1-i] > c){\n                if (ret == 0){\n                    ret = a[i];\n                }else{\n                    good = false;\n                }\n            }\n            // if (a[i] + a[n-1-i] > c) good = false;\n        }\n        // cout << \"e\" << now << good << endl;\n        return ret;\n    }\n    if (a[n-1] > c) good = false;\n    REP(i,n/2){\n        if (a[i] + a[n-2-i] > c) good = false;\n    }\n    int ok = n-1, ng = -1;\n    while (ok - ng > 1){\n        int mi = (ok + ng) / 2;\n        bool f = true;\n        REP(i,n/2){\n            int x = i;\n            if (x >= mi) x++;\n            int y = n - 1 - i;\n            if (y <= mi) y--;\n            if (a[x] + a[y] > c) f = false;\n        }\n        if (f) ok = mi;\n        else ng = mi;\n    }\n    // cout << now << \" \" << a[ok] << endl;\n    return a[ok];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--;b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n\n    REP(i,n) a += (e[i].size() % 2);\n    a = (a + 1) / 2;\n\n    int root;\n    REP(i,n) if (e[i].size() == 1) root = i;\n\n    int ok = n, ng = 0;\n    while (ok - ng > 1){\n        c = (ok + ng) / 2;\n        // cout << c << endl;\n        good = true;\n        dfs(root, -1);\n        if (good) ok = c;\n        else ng = c;\n    }\n\n\n    cout << a << \" \" << ok << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, A, B, tot;\nvector<int> E[maxn];\nint dfs(int x, int fa)\n{\n\tint ret = 0;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t\tret += dfs(v, x);\n\tif(fa) ret += (E[x].size() - 1) / 2;\n\telse ret += (E[x].size() + 1) / 2;\n\treturn ret;\n}\nint color(int x, int fa)\n{\n\tvector<int> a;\n\tfor(auto v : E[x])\n\t\tif(v != fa)\n\t\t{\n\t\t\tint res = color(v, x);\n\t\t\tif(res == -1) return -1;\n\t\t\telse if(res == B) ++tot, res = 0;\n\t\t\ta.push_back(res + 1);\n\t\t}\n\tsort(a.begin(), a.end());\n\tif(!fa)\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0, j = a.size() - 2; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t\treturn -1;\n\t\t\ttot += a.size() / 2;\n\t\t\treturn a.back();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(a.size() % 2 == 0)\n\t\t{\n\t\t\tbool flag = 1;\n\t\t\tfor(int i = 0, j = a.size() - 1; i < j; ++i, --j)\n\t\t\t\tif(a[i] + a[j] > B)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(flag) \n\t\t\t{\n\t\t\t\ttot += a.size() / 2;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tint ret = a[0];\n\t\tfor(int i = 1, j = a.size() - 1; i < j; ++i, --j)\n\t\t\tif(a[i] + a[j] > B)\n\t\t\t{\n\t\t\t\tif(ret + a[j] <= B) ret = a[i];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tret = a[j];\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tfor(int ii = 0, jj = a.size() - 1; ii < jj; ++ii, --jj)\n\t\t\t\t\t\tif(a[ii] + a[jj] > B)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\ttot += a.size() / 2;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\ttot += a.size() / 2;\n\t\treturn ret;\n\t\t\t\n\t}\n}\nbool check()\n{\n\ttot = 0;\n\tif(color(1, 0) == -1) return 0;\n\treturn tot <= A;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tA = dfs(1, 0);\n\tint l = 1, r = n - 1;\n\twhile(l <= r)\n\t{\n\t\tB = l + r >> 1;\n\t\tif(check()) r = B - 1;\n\t\telse l = B + 1;\n\t}\n\tcout << A << ' ' << l << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\n\nint n;\nvector<int> gph[MAXN];\nvector<int> dfn;\n\nint dp[MAXN];\n\nint query(int k){\n\tfor(auto &i : dfn){\n\t\tif(i == 1) break;\n\t\tvector<int> v;\n\t\tfor(auto &j : gph[i]) v.push_back(dp[j] + 1);\n\t\tsort(v.begin(), v.end());\n\t\tauto trial_pos = [&](int x){\n\t\t\tint l = 0, r = v.size() - 1;\n\t\t\tfor(int i=0; i<v.size()/2; i++){\n\t\t\t\tif(l == x) l++;\n\t\t\t\tif(r == x) r--;\n\t\t\t\tif(v[l] + v[r] > k) return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t};\n\t\tif(v.size() % 2 == 0){\n\t\t\tv.insert(v.begin(), 0);\n\t\t\tint s = 0, e = v.size();\n\t\t\twhile(s != e){\n\t\t\t\tint m = (s+e)/2;\n\t\t\t\tif(trial_pos(m)) e = m;\n\t\t\t\telse s = m + 1;\n\t\t\t}\n\t\t\tif(s == v.size()) return 0;\n\t\t\tdp[i] = v[s];\n\t\t}\n\t\telse{\n\t\t\tint s = 0, e = v.size();\n\t\t\twhile(s != e){\n\t\t\t\tint m = (s+e)/2;\n\t\t\t\tif(trial_pos(m)) e = m;\n\t\t\t\telse s = m + 1;\n\t\t\t}\n\t\t\tif(s == v.size()) return 0;\n\t\t\tdp[i] = v[s];\n\t\t}\n\t}\n\tvector<int> v;\n\tfor(auto &i : gph[1]) v.push_back(dp[i] + 1);\n\tsort(v.begin(), v.end());\n\tif(v.back() > k) return 0;\n\tif(v.size() % 2 == 1) v.pop_back();\n\tfor(int i=0; i<v.size()/2; i++){\n\t\tif(v[i] + v[v.size()-i-1] > k) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int x){\n\tdfn.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tgph[i].erase(find(gph[i].begin(), gph[i].end(), x));\n\t\tdfs(i);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1);\n\tint ans = n - 1;\n\tfor(int i=1; i<=n; i++){\n\t\tans -= ((i != 1) + gph[i].size()) / 2;\n\t}\n\tint s = 1, e = n;\n\treverse(dfn.begin(), dfn.end());\n\twhile(s != e){\n\t\tint m = (s+e)/2;\n\t\tif(!query(m)) s = m+1;\n\t\telse e = m;\n\t}\n\tprintf(\"%d %d\\n\", ans, s);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(100010);\nint visited[100010] = {0},dp[100010] = {0};\n\nbool ok(int n,int m){\n\tvisited[n] = 1;\n\tbool judge = true;\n\tvector<int> children;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(visited[s]==0){\n\t\t\tjudge = (judge & ok(s,m));\n\t\t\tchildren.push_back(dp[s]);\n\t\t}\n\t}\n\tint len = children.size();\n\tsort(children.begin(),children.end());\n\tif(len%2==0){\n\t\tbool j = true;\n\t\tfor(int i=0;i<len/2;i++){\n\t\t\tif(children[i]+children[len-i-1]>m) j = false;\n\t\t}\n\t\tif(j) return judge;\n\t\tchildren.pop_back(); len--;\n\t}\n\tint l = -1,r = len;\n\twhile(l+1<r){\n\t\tint mid = (l+r)/2;\n\t\tint a = 0,b = len-1;\n\t\tbool j = true;\n\t\twhile(a<b){\n\t\t\tif(a==mid) a++;\n\t\t\tif(b==mid) b--;\n\t\t\tif(children[a]+children[b]>m) j = false;\n\t\t\ta++; b--;\n\t\t}\n\t\tif(j && children[mid]+dp[n]<=m) r = mid;\n\t\telse l = mid;\n\t}\n\tif(r==len) judge = false;\n\telse dp[n] += children[r];\n\tif(dp[n]>m) judge = false;\n\treturn judge;\n}\n\nint main(){\n\tcin >> N;\n\tint a,b;\n\tfor(int i=0;i<N-1;i++){\n\t\tcin >> a >> b;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tint A = 0,cnt = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tif(v[i].size()%2==1) cnt++;\n\t}\n\tA = cnt/2;\n\tint l = 0,r = N;\n\twhile(l+1<r){\n\t\tdp[1] = 0;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tvisited[i] = 0; dp[i] = 1;\n\t\t}\n\t\tint m = (l+r)/2;\n\t\tif(ok(1,m)) r = m;\n\t\telse l = m;\n\t}\n\tcout << A << \" \" << r << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[100111];\nint l[100101];\nint j[1];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[1];\n\nP u[1];\nqueue<int> q;\nstack<int> s;\n\nvector<int> v[100101];\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\nvoid f(int n,int m)\n{\n  vector<int> s;\n  for(int h=0;h<v[n].size();h++)\n  if(v[n][h]!=m)\n  {\n    f(v[n][h],n);\n    s.push_back(l[v[n][h]]+1);\n  }\n  if((s.size()%2==0&&m>0)||(s.size()%2&&m==0)) s.push_back(0);\n  sort(s.begin(),s.end());\n  \n  if(m==0)\n  {\n    int c=0,d=s.size()-1;\n    o[n]=0;\n    for(;c<d;c++,d--)\n    o[n]=max(o[n],s[c]+s[d]);\n    return;\n  }\n  int a=0,b=s.size()-1;\n  for(;a<b;)\n  {\n    int h=(a+b)/2;\n    int x=0,c=0,d=s.size()-1;\n    for(;c<d;)\n    if(c==h) c++;\n    else if(d==h) d--;\n    else\n    {\n      x=max(x,s[c]+s[d]);\n      c++,d--;\n    }\n    if(x<=k) b=h;\n    else a=h+1;\n  }\n  l[n]=s[a];\n  int x=0,c=0,d=s.size()-1;\n  for(;c<d;)\n  if(c==a) c++;\n  else if(d==a) d--;\n  else\n  {\n    x=max(x,s[c]+s[d]);\n    c++,d--;\n  }\n  o[n]=x;\n}\n\nint main()\n{\n  scanf(\"%d\",&a);\n  for(int t=1;t<a;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    v[n].push_back(m);\n    v[m].push_back(n);\n  }\n  for(int t=1;t<=a;t++)\n    e+=v[t].size()%2;\n  printf(\"%d \",e/2);\n  n=1,m=a-1;\n  for(;n<m;)\n  {\n    k=(n+m)/2;\n    f(1,0);\n    //for(int t=1;t<=a;t++)\n    //  printf(\"%d \",o[t]);\n    //puts(\"\");\n    for(int t=1;t<=a;t++)\n      if(o[t]>k)\n      {\n        n=k+1;\n        goto qwe;\n      }\n    m=k;\n    qwe:;\n  }\n  printf(\"%d\",n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,tot,ans,dp[N],f[N],sum[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvoid dfs(int u,int p)\n{\n    int tot=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dp[u]+=dp[v];\n        tot++;\n    }\n    dp[u]+=tot/2;\n    if(u==1) dp[u]+=tot%2;\n}\nint top,s[N];\nmultiset<int>st;\nmultiset<int>::iterator it;\nvoid dfs(int u,int p,int m)\n{\n    f[u]=sum[u]=0;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u,m);\n        f[u]+=f[v];\n    }\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        s[++top]=sum[v]+1;\n        if(s[top]>m) {f[u]=n;return;}\n    }\n    sort(s+1,s+1+top);\n    for(int i=1;i<=top;i++) st.insert(s[i]);\n    for(int i=top;i>=1;i--)\n    {\n        if(!st.count(s[i])) continue;\n        st.erase(st.find(s[i]));\n        if(st.size()==0)\n        {\n            sum[u]=s[i];break;\n        }\n        it=st.upper_bound(m-s[i]);\n        f[u]++;\n        if(it!=st.begin())\n        {\n            it--;\n            st.erase(st.find(*it));\n        }\n    }\n    top=0;\n    if(u==1&&sum[u]) f[u]++;\n}\nbool judge(int m)\n{\n    dfs(1,0,m);\n    return f[1]<=dp[1];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    dfs(1,0);\n    int l=(n-1)/dp[1]+((n-1)%dp[1]!=0),r=n-1,ans;\n    while(l<=r)\n    {\n        int m=l+r>>1;\n        if(judge(m)) ans=m,r=m-1;\n        else l=m+1;\n    }\n    printf(\"%d %d\\n\",dp[1],ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n//#ifdef LOCAL\n//#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n//#else\n//#define NDEBUG\n//#define eprintf(...) do {} while (0)\n//#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI ord;\nint par[100011];\nint dp[100011];\nVI t, st;\n\nbool ok(int mid) {\n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tt.clear();\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    if (dp[*e]+1 > mid) return false;\n\t    t.push_back(dp[*e]+1);\n\t}\n\n\tif (v == 0) {\n\t    int m = t.size()/2;\n\t    sort(t.begin(), t.end());\n\t    REP (j, m) if (t[j] + t[m*2-1-j] > mid) return false;\n\t    return true;\n\t} else {\n\t    if (t.size() % 2 == 0) t.push_back(0);\n\t    sort(t.begin(), t.end());\n\t    st.clear();\n\t    int pos = 0;\n\t    dp[v] = -1;\n\t    for (int j=t.size()-1; j>=0; j--) {\n\t\tint c = t[j];\n\t\tif (c == -1) continue;\n\t\twhile (pos < j && t[pos] + c <= mid) {\n\t\t    st.push_back(t[pos]);\n\t\t    t[pos] = -1;\n\t\t    pos++;\n\t\t}\n\t\tif (st.empty()) {\n\t\t    if (dp[v] == -1) dp[v] = c;\n\t\t    else return false;\n\t\t} else {\n\t\t    st.pop_back();\n\t\t}\n\t    }\n\n\t    if (dp[v] == -1) {\n\t\tdp[v] = st[0];\n\t    } else if (!st.empty()) {\n\t\treturn false;\n\t    }\n\t}\n    }\n\n    assert(false);\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    int A = 1;\n    REP (i, N) {\n\tA += ((int)G[i].size() - 1) / 2;\n    }\n\n    int lo = 0, hi = N-1;\n    while (hi - lo > 1) {\n\tint mid = (lo + hi) / 2;\n\t(ok(mid)? hi: lo) = mid;\n    }\n    printf(\"%d %d\\n\", A, hi);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nvector<int> G[100000];\nint ar[100000];\nint buffer[100000];\nint N;\nbool check(int B){\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tint p = 0;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tbuffer[p++] = ar[t]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p % 2 == 0){\n\t\t\t\tbuffer[p++] = 0;\n\t\t\t}\n\t\t\tsort(buffer,buffer+p);\n\t\t\tint bf = 0;\n\t\t\tint bl = p;\n\t\t\twhile(bf != bl){\n\t\t\t\tint bc = (bf+bl)/2;\n\t\t\t\tbool OK = true;\n\t\t\t\tif(bc != p){\n\t\t\t\t\tint l = 0;\n\t\t\t\t\tint r = p-1;\n\t\t\t\t\twhile(l < r){\n\t\t\t\t\t\tif(l == bc){\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(r == bc){\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(buffer[l] + buffer[r] > B){\n\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl++;\n\t\t\t\t\t\tr--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tbl = bc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbf = bc+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bf == p){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tar[v] = buffer[bf];\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = G[v][i];\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ar[0] <= B;\n}\nvoid Calc(){\n\tN = rei();\n\tfor(int i=0;i<N-1;i++){\n\t\tint a = rei()-1;\n\t\tint b = rei()-1;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint A = 0;\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tint b = 0;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint t = G[v][i];\n\t\t\tif(t != f){\n\t\t\t\tb++;\n\t\t\t\tsp.push({t,v});\n\t\t\t}\n\t\t}\n\t\tA -= b / 2;\n\t\tif(b % 2 == 0 && f != -1){\n\t\t\tA++;\n\t\t}\n\t}\n\tint bf = 1;\n\tint bl = N-1;\n\twhile(bf != bl){\n\t\tint bc = (bf+bl)/2;\n\t\tif(check(bc)){\n\t\t\tbl = bc;\n\t\t}\n\t\telse{\n\t\t\tbf = bc+1;\n\t\t}\n\t}\n\tcout << A << \" \" << bf << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int nmax = 100010;\nint deg[nmax],dp[nmax];\nbool fix[nmax];\nvector < int > graph[nmax];\nint N,u;\nbool check2(int x,int B, vector<int>& kids)\n{\n\tint l = 0, r = kids.size() - 1;\n\tif((kids[x]+1) > B) return false;\n\twhile( l < r)\n\t{\n\t\tif(l == x) l++;\n\t\tif(r == x) r--;\n\t\tif(l >= r  || r < 0) return true;\n\t\tif((kids[l] + kids[r]+2 )> B) return false;\n\t\tl++,r--;\n\t}\n\treturn true;\n}\nbool dfs(int u, int x)\n{\n\tfix[u] = true;\n\tbool ret = true;\n\t//cout << \"in vertex \" << u << \" trying \" << x << endl;\n\tvector< int > kids;\n\tfor(int i = 0; i < graph[u].size(); ++i)\n\t{\n\t\tif(fix[graph[u][i]]) continue;\n\t\tret&=dfs(graph[u][i],x);\n\t\tkids.push_back(dp[graph[u][i]]);\n\t}\n\tif(!ret) return ret;\n\tbool isfake = false;\n\tif((kids.size()&1)==0){ isfake = true; kids.push_back(0);}\n\tsort(kids.begin(), kids.end());\n\tint l = 0, r = kids.size() - 1;\n\t\n\t//cout << \"out to \" << u;\n\t//cout << \"\\n\\t\";\n\t//for(int i = 0 ; i < kids.size(); ++i)\n\t//\tcout << kids[i] << ' ';\n\t//cout << endl;\n\tbool isGood = check2(r, x, kids);\n\twhile((r - l) > 1)\n\t{\n\t\tint mid = (r+l) >> 1;\n\t\tif(check2(mid, x, kids))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\n\t}\n\tif(check2(l, x, kids)) r = l;\n\tif(!isGood) return false;\n\t//cout << \"\\tchose\" << kids[r] << endl;\n\tdp[u] = kids[r]+1;\n\tif(kids[r] == 0 && isfake) dp[u] = 0;\n\treturn true;\n}\nbool check(int x)\n{\n\tfor(int i = 1;i<=N;++i)dp[i]=N,fix[i]=false;\n\treturn dfs(u,x);\n}\nint bs()\n{\n\tint l = 1, r = N-1;\n\twhile((r-l) > 1)\n\t{\n\t\tint mid = (l+r) >> 1;\n\t\tif(check(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t\t//cout << l << ' ' << r << ' ' << mid << endl;\n\t}\n\tif(check(l))\n\t\treturn l;\n\treturn r;\n\n}\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0 ;i < N-1;++i)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tint A=0,B=0;\n\tfor(int i = 1;i<=N;++i)\n\t{\n\t\tif(deg[i]&1) A++;\n\t\tif(deg[i] == 1) u = i;\n\t}\n\tA = (A+1)/2;\n\tcout << A << ' ' << bs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[100010];\nint ans;\n\nint DFS1(int v,int p)\n{\n    int cnt = 0,sum = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        sum += DFS1(ne,v);\n        cnt++;\n    }\n    if(cnt == 0)return 1;\n    return sum - (cnt - 1) / 2;\n}\n\nint DFS2(int v,int p,int x)\n{\n    vector<int> V;\n    int cnt = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        V.push_back(DFS2(ne,v,x));\n        cnt++;\n    }\n    if(cnt == 0)\n    {\n        return 1;\n    }\n    sort(V.begin(),V.end());\n    if(V.back() > x)\n    {\n        return 0;\n    }\n    if(V[0] == 0)\n    {\n        return 0;\n    }\n    if(cnt % 2 == 0)\n    {\n        for(int i = 0; i < V.size() / 2 + 1; i++)\n        {\n            if(i == V.size() / 2)\n            {\n                return 1;\n            }\n            if(V[i] + V[V.size() - 1 - i] > x)\n            {\n                if(V.back() > x)\n                {\n                    return 0;\n                }\n                V.pop_back();\n                break;\n            }\n        }\n    }\n    int l = -1,r = V.size() - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        int L = 0,R = V.size() - 1;\n        for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n        {\n            if(i == V.size() / 2)\n            {\n                r = mid;\n                break;\n            }\n            if(L == mid)L++;\n            if(R == mid)R--;\n            if(V[L] + V[R] > x)\n            {\n                l = mid;\n                break;\n            }\n        }\n    }\n\n    int L = 0,R = V.size() - 2;\n    for(int i = 0; i <= V.size() / 2; i++,L++,R--)\n    {\n        if(i == V.size() / 2)\n        {\n            return V[r] + 1;\n        }\n        if(L == r)L++;\n        if(R == r)R--;\n        if(V[L] + V[R] > x)\n        {\n            return 0;\n            break;\n        }\n    }\n}\n\nbool judge(int mid)\n{\n    int res;\n    for(int i = 1; i <= N; i++)if(G[i].size() == 1)\n    {\n        res = DFS2(1,0,mid);\n        break;\n    }\n    return (res != 0 && mid >= res - 1);\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    ans = DFS1(1,0);\n\n    int l = 0,r = N - 1;\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(judge(mid))r = mid;\n        else l = mid;\n    }\n\n    printf(\"%d %d\\n\",ans,r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 100005\n#define mid (l+r>>1)\nstruct edge{int to,nex;}e[MN*2];int cnt,hr[MN],d[MN];\ninline void INS(int f,int t){e[++cnt]=(edge){t,hr[f]};hr[f]=cnt;d[t]++;}\ninline void ins(int f,int t){INS(f,t);INS(t,f);}\nint n,rt,ans,flag,l,r;\nmultiset<int> s[MN+5];multiset<int>::iterator it;\nint f[MN];\nvoid dfs(int x,int fa){\n\ts[x].clear();f[x]=0;register int i;\n\tfor(i=hr[x];i;i=e[i].nex) if(e[i].to!=fa) dfs(e[i].to,x),s[x].insert(f[e[i].to]+1);\n\tint has=0,has2=0,siz=s[x].size();if(!siz) ans++;ans-=(siz-1)/2;\n\tif(s[x].size()&&(*(--(it=s[x].end())))>mid) return (void)(flag=0);\n\twhile(!s[x].empty()){\n\t\tit=s[x].end();--it;int v=*it;s[x].erase(it);\n\t\tit=s[x].upper_bound(mid-v);\n\t\tif(it==s[x].begin()){\n\t\t\tif(!has) has=v,f[x]=has;\n\t\t\telse if(~siz&1){\n\t\t\t\tif(!has2) has2=v,f[x]=has2;\n\t\t\t\telse return(void)(flag=0);\n\t\t\t}\n\t\t\telse return (void)(flag=0);\n\t\t}\n\t\telse s[x].erase(--it);\n\t}\n}\nint main(){\n\tn=read();register int i;\n\tfor(i=1;i<n;i++) ins(read(),read());\n\tl=1,r=n;int res,anss;\n\tfor(rt=1;~d[rt]&1;rt++);\n\twhile(l<=r){\n\t\tans=0;flag=1;dfs(rt,0);\n\t\tif(flag) res=mid,r=mid-1,anss=ans;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d %d\",anss,res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5;\n\nvi g[MAXN];\n\nint dp[MAXN];\nint prv[MAXN];\nint vv[MAXN], top_vv;\nint sorted[MAXN], top_sorted;\n\nvoid dfs(int s) {\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]) {\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\tsorted[top_sorted++] = s;\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\tint cnt = 0;\n\tREPN(i, 1, n) {\n\t\tcnt += SZ(g[i]) % 2;\n\t}\n\tcnt /= 2;\n\t\n\tint ind = 0;\n\tREPN(i, 1, n) {\n\t\tif (SZ(g[i]) == 1) {\n\t\t\tind = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(ind);\n\t\n\tint l = 0, r = n - 1;\n\tfor(; l + 1 < r; ) {\n\t\tint lim = (l + r) >> 1;\n\t\tbool good = true;\n\t\tREP(i, 0, n) {\n\t\t\tint s = sorted[i];\n\t\t\tdp[s] = 0;\n\t\t\ttop_vv = 0;\n\t\t\tREP(j, 0, SZ(g[s])) {\n\t\t\t\tint to = g[s][j];\n\t\t\t\tif (to != prv[s]) {\n\t\t\t\t\tvv[top_vv++] = dp[to] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (top_vv % 2 == 0) {\n\t\t\t\tvv[top_vv++] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tsort(vv, vv + top_vv);\n\t\t\t\n\t\t\tif (vv[top_vv - 1] > lim) {\n\t\t\t\tgood = false;\n\t\t\t} else {\n\t\t\t\tfor(int ind_r = top_vv / 2, ind_l = top_vv / 2 - 1; ind_l >= 0; ind_l--, ind_r++) {\n\t\t\t\t\tif (vv[ind_r] + vv[ind_l] > lim) {\n\t\t\t\t\t\tgood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (good) {\n\t\t\t\tint ind = top_vv - 1;\n\t\t\t\tfor(ind--; ind >= 0; ind--) {\n\t\t\t\t\tif (ind >= top_vv / 2) {\n\t\t\t\t\t\tif (vv[ind + 1] + vv[top_vv - 2 - ind] > lim) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (vv[ind + 1] + vv[top_vv - 1 - ind] > lim) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tind++;\n\t\t\t\tdp[s] = vv[ind];\n\t\t\t}\n\t\t\t\n\t\t\tif (!good) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (good) {\n\t\t\tr = lim;\n\t\t} else {\n\t\t\tl = lim;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\", cnt, r);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nvector<int> vi;\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tvi.clear();\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=res[G[v][i]];\n\t\t\tvi.push_back(val.second);\n\t\t}\n\t}\n\tif(vi.size()==0)return res[v]=P(1,1);\n\tsort(vi.begin(),vi.end());\n\tint l=0,r=(int)vi.size()-1;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vi[l]+vi[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tP res=dfs(1,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint mx;\nint num;\n\nvoid pre(int v, int p)\n{\n\tint cnt = 0;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tpre(to, v);\n\t\t++cnt;\n\t}\n\n\tnum += (cnt / 2);\n\tif (p == -1) {\n\t\tif (cnt & 1) ++num;\n\t}\n}\n\nint dfs(int v, int p, int x)\n{\n\tvi vec;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tint u = dfs(to, v, x);\n\t//\tcout << \"DEBUG \" << to << \" \" << u << endl;\n\t\tif (u == -1 || u >= x) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(u + 1);\n\t}\n\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tmultiset<int> ss;\n\tfor (int x : vec) {\n\t\tss.insert(x);\n\t}\n\n\tint ng_cnt = 0;\n\tint val = -1;\n\n\twhile (ss.size() >= 2) {\n\t\tint a = *ss.rbegin();\n\t\tss.erase(ss.lower_bound(a));\n\t\tauto it = ss.upper_bound(x - a);\n\n\t\tif (v == 3) {\n\t\t//\tputs(\"wo\");\n\t\t}\n\n\t\tif (it == ss.begin()) {\n\t\t//\tif (v == 3) puts(\"f1\");\n\t\t\tif (ng_cnt > 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tng_cnt++;\n\t\t\tval = a;\n\t\t} else {\n\t\t\t//if (v == 3) puts(\"f2\");\t\t\t\n\t\t\t--it;\n\t\t\tss.erase(it);\n\t\t}\n\t}\n\n\t//ng_cnt <= 1, ss.size() <= 1\n\n\tif (p == -1) {\n\t\tif (sz & 1) {\n\t\t//\tcout << ng_cnt << \" \" << ss.size() << endl;\n\t\t\tif (ng_cnt + ss.size() > 1) {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tif (ng_cnt || ss.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ss.size() && ng_cnt) {\n\t\treturn min(*ss.begin(), val);\n\t} else if (ng_cnt) {\n\t\treturn val;\n\t} else if (ss.size()) {\n\t\treturn *ss.begin();\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nbool ok(int x)\n{\n\tint t = dfs(0, -1, x);\n\tcout << t << endl;\n\treturn (t != -1);\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tpre(0, -1);\n\n\tint lo = 0, hi = N;\n\t//ok(2);\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tcout << num << \" \" << hi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint sign(int x) { return (x > 0) - (x < 0); }\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint cdiv(int a, int b) { return (a - 1 + b) / b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const map<T, U> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<typename F> long long discrete_binary_search(long long ok, long long ng, F is_ok) {\n    while (abs(ok - ng) > 1) {\n        long long mid = (ok + ng) / 2;\n        (is_ok(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nsigned main() {\n    int N;\n    cin >> N;\n    vvint G(N);\n    vint deg(N);\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b, a--, b--;\n        G[a].emplace_back(b), G[b].emplace_back(a);\n        deg[a]++, deg[b]++;\n    }\n    int A = 0;\n    rep(i, N) { A += deg[i] & 1; }\n    A /= 2;\n    cout << A << \" \" << discrete_binary_search(N, 0, [&](int B) {\n        bool flag = true;\n        auto dfs = [&](auto &&self, int cur, int par) -> int {\n            vint dep;\n            if (par == -1) { dep.emplace_back(N); }\n            if (deg[cur] & 1) { dep.emplace_back(0); }\n            for (int to:G[cur]) {\n                if (to != par) { dep.emplace_back(self(self, to, cur)); }\n            }\n            sort(all(dep));\n            int idx = discrete_binary_search(dep.size(), -1, [&](int x) {\n                vint cpy = dep;\n                cpy.erase(cpy.begin() + x);\n                rep(i, cpy.size() / 2) {\n                    if (B < cpy[i] + cpy[cpy.size() - i - 1]) { return false; }\n                }\n                return true;\n            });\n            flag &= idx < dep.size();\n            return dep[idx] + 1;\n        };\n        dfs(dfs, 0, -1);\n        return flag;\n    }) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing std::sort;\nusing std::vector;\n\nconst int MAXN=1e5+5;\nint rt,n,A,B;\nint he[MAXN],deg[MAXN];\nint dp[MAXN];\n\nstruct line{int to,nex;}ed[MAXN<<1];\n\ninline void addE(int u,int v){\n\tstatic int cnt;\n\ted[++cnt]=(line){v,he[u]};\n\the[u]=cnt;\n}\n\ninline bool cmp_dp(int a,int b){return dp[a]<dp[b];}\n\ninline bool check(vector<int> &vec,int son){\n\tfor(int l=0,r=vec.size()-1;l<r;++l,--r){\n\t\tif(l==son) ++l;\n\t\tif(r==son) --r;\n\t\tif(dp[vec[l]]+dp[vec[r]]>B)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\ninline int bin_chop_son(vector<int> &vec){\n\tint l=0,r=vec.size()-1,mid;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tif(check(vec,mid)) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nbool treeDP(int u,int fa){\n\tvector<int> vec;\n\tfor(int i=he[u],v;i;i=ed[i].nex){\n\t\tv=ed[i].to;\n\t\tif(v!=fa){\n\t\t\tif(!treeDP(v,u)) return false;\n\t\t\tvec.push_back(v);\n\t\t}\n\t}\n\tif(vec.size()==0){\n\t\tdp[u]=1;\n\t\treturn true;\n\t}\n\t//度数为奇数，则儿子为偶数个\n\tif(deg[u]&1) vec.push_back(0);\n\tsort(vec.begin(),vec.end(),cmp_dp);\n\tint v=bin_chop_son(vec);\n\tif(v==vec.size()) return false;\n\tdp[u]=dp[vec[v]]+1;\n\treturn dp[u]<=B+1;\n}\n\ninline void bin_chop_B(){\n\tint l=0,r=n;\n\twhile(l<=r){\n\t\tB=l+r>>1;\n\t\tif(treeDP(n+1,0)) r=B-1;\n\t\telse l=B+1;\n\t}\n\tB=l;\n}\n\ninline void cal_A(){\n\tint cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tcnt+=deg[i]&1;\n\tA=cnt>>1;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;++i){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++deg[u],++deg[v];\n\t\taddE(u,v),addE(v,u);\n\t}\n\taddE(n+1,1);\n\tcal_A();\n\tbin_chop_B();\n\tprintf(\"%d %d\",A,B);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\n\nint cnt = 0;\nbool calcnum(int root,int from) {\n\tint tmp = 0;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tif (calcnum(to,root))tmp++;\n\t}\n\tcnt += tmp / 2;\n\tif (root == 0 && tmp % 2 == 0)cnt--;\n\treturn 1;\n}\nint c; bool f;\nint dfs(int root, int from) {\n\tvector<int> v;\n\trep(j, G[root].size()) {\n\t\tint to = G[root][j];\n\t\tif (to == from)continue;\n\t\tint cto = dfs(to, root);\n\t\tif (cto == c) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(cto);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint len = v.size(); cnt += len / 2;\n\tif (len % 2==0) {\n\t\tbool g = true;\n\t\trep(i, len / 2) {\n\t\t\tif (v[i] + v[len - i - 1] > c)g = false;\n\t\t}\n\t\tif (g)return 1;\n\t\telse {\n\t\t\tv.pop_back();\n\t\t}\n\t}\n\t\tmultiset<int> mt;\n\t\trep(i, len)mt.insert(v[i]);\n\t\trep(i, len / 2) {\n\t\t\tauto itr = mt.end(); itr--;\n\t\t\tint z = *itr; mt.erase(mt.find(z));\n\t\t\tint r = c - z;\n\t\t\tif (mt.count(r)) {\n\t\t\t\tmt.erase(mt.find(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt.insert(r);\n\t\t\t\tauto itr2 = mt.find(r);\n\t\t\t\tif (itr2 == mt.begin()) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\titr2--; mt.erase(r);\n\t\t\t\tint zz = *itr2;\n\t\t\t\tif (zz + z > c) {\n\t\t\t\t\tf = false; return 1;\n\t\t\t\t}\n\t\t\t\tmt.erase(itr2);\n\t\t\t}\n\t\t}\n\t\tint z = *mt.begin();\n\t\tif (z == c) {\n\t\t\tcnt++; z = 0;\n\t\t}\n\t\treturn z + 1;\n}\nint ansa;\nbool test(int x) {\n\tc = x; f = true; cnt = 0;\n\tint u = dfs(0, -1) - 1; if (u > x)f = false; if (u > 0)cnt++;\n\tif (cnt > ansa)f = false;\n\treturn f;\n}\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tif (calcnum(0, -1))cnt++;\n\tansa = cnt;\n\tint le = 0, ri = n;\n\twhile (ri - le > 1) {\n\t\tint mid = (ri + le) / 2;\n\t\tif (test(mid)) {\n\t\t\tri = mid;\n\t\t}\n\t\telse {\n\t\t\tle = mid;\n\t\t}\n\t}\n\tcout << ansa<<\" \"<<ri << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector <int> G[100005];\npair <long long, long long> DP[2][100005];\nlong long DP2[100005];\nint aux;\nbool ok;\nint a = 0;\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    for(int i = 1; i <= N; i++)\n        if(G[i].size() % 2 == 1)\n            a++;\n}\ninline bool cmp(int a, int b)\n{\n    return DP2[a] < DP2[b];\n}\nbool check2(int pos, int node)\n{\n    int left = 0, right=  G[node].size() - 1;\n    while(left < right)\n    {\n        if(left == pos)\n        {\n            left++;\n            continue;\n        }\n        if(right == pos)\n        {\n            right--;\n            continue;\n        }\n        if(DP2[G[node][left]] + DP2[G[node][right]] > aux)\n            return 0;\n        left++;\n        right--;\n    }\n    int add = 0;\n    if(node == 1)\n        add = 1;\n    if(DP2[G[node][pos]] + 1 > aux + add)\n        return 0;\n    return 1;\n}\nint binS(int node)\n{\n    int mid, left = 0, right = G[node].size() - 1, sol = -1;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check2(mid, node))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    return sol;\n}\nvoid DFS(int node, int father)\n{\n    if(ok == 0)\n        return;\n    int cnt = 0;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father || neighb == 0)\n            continue;\n        DFS(neighb, node);\n        ++cnt;\n    }\n\n    for(auto it = G[node].begin(); it != G[node].end(); it = next(it))\n    {\n        if(*it == father)\n        {\n            G[node].erase(it);\n            break;\n        }\n\n    }\n\n    if(G[node].size() % 2 == 0)\n        G[node].push_back(0);\n    if(cnt == 0)\n    {\n        DP2[node] = 1;\n        return;\n    }\n    sort(G[node].begin(), G[node].end(), cmp);\n    int p = binS(node);\n    if(p == -1)\n    {\n        ok = 0;\n        return;\n    }\n    DP2[node] = DP2[G[node][p]] + 1;\n}\nbool check(int B)\n{\n    aux = B;ok = 1;\n    DFS(1, 0);\n    return ok;\n}\nvoid binS2()\n{\n    int left = 1, right = N, mid, sol = N;\n    while(left <= right)\n    {\n        mid = (left+ right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << a / 2 << \" \" << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    binS2();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing pi = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n\n//number//\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nstruct modint {\n\tll n;\npublic:\n\tmodint(const ll n = 0) : n((n % mod + mod) % mod) {}\n\tstatic modint pow(modint a, ll m) {\n\t\tmodint r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; }\n\t\t\ta = (a * a); m /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tmodint &operator++() { *this += 1; return *this; }\n\tmodint &operator--() { *this -= 1; return *this; }\n\tmodint operator++(int) { modint ret = *this; *this += 1; return ret; }\n\tmodint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n\tmodint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n\tfriend bool operator==(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend modint &operator+=(modint& lhs, const modint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator-=(modint& lhs, const modint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator*=(modint& lhs, const modint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator/=(modint& lhs, const modint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend modint operator+(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n + rhs.n);\n\t}\n\tfriend modint operator-(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n - rhs.n);\n\t}\n\tfriend modint operator*(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n * rhs.n);\n\t}\n\tfriend modint operator/(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\nstruct binomial_coefficient {\nprivate:\n\tint m;\n\tvector<modint> fact;\npublic:\n\tbinomial_coefficient(int m) : m(m) {\n\t\tfact.resize(m);\n\t\tfact[0] = 1;\n\t\tfor(int i = 1; i < m; i++) fact[i] = fact[i - 1] * i;\n\t}\n\tmodint combination(int n, int k) {\n\t\tif(n < 0 || k < 0 || n < k) return 0;\n\t\treturn fact[n] / fact[n - k] / fact[k];\n\t}\n};\n\n\n// graph //\nusing weight = long long;\nstruct edge { int to; weight w; };\ntemplate <typename T> struct vedge : edge { T v; };\nstruct graph {\nprivate:\n\tint n;\n\tbool weighted;\n\tbool tree;\n\tvector<vector<edge>> g;\npublic:\n\tgraph(int n, bool tree = false) : n(n), weighted(false), tree(tree), g(vector<vector<edge>>(n)) { }\n\tvector<edge>& operator[] (int i) { return g[i]; }\n\tint size() { return n; }\n\tbool isweighted() { return weighted; }\n\tbool istree() { return tree; }\n\tvoid add_edge(int s, int t, weight w = 1) {\n\t\tg[s].push_back({t, w});\n\t\tg[t].push_back({s, w});\n\t\tif(w != 1) weighted = true;\n\t}\n\tvoid add_dedge(int s, int t, weight w = 1) {\n\t\tg[s].push_back({t, w});\n\t\tif(w != 1) weighted = true;\n\t}\n};\ntemplate <typename T> struct vgraph {\npublic:\nprivate:\n\tint n;\n\tbool weighted;\n\tbool tree;\n\tvector<vector<vedge<T>>> g;\n\tvgraph(int n, bool tree = false) : n(n), weighted(false), tree(tree), g(vector<vector<vedge<T>>>(n)) { }\n\tvector<edge>& operator[] (int i) { return g[i]; }\n\tint size() { return n; }\n\tbool isweighted() { return weighted; }\n\tbool istree() { return tree; }\n\tvoid add_edge(int s, int t, T v, weight w = 1) {\n\t\tg[s].push_back({t, w, v});\n\t\tg[t].push_back({s, w, v});\n\t\tif(w != 1) weighted = true;\n\t}\n\tvoid add_dedge(int s, int t, T v, weight w = 1) {\n\t\tg[s].push_back({t, w, v});\n\t\tif(w != 1) weighted = true;\n\t}\n\tgraph build_graph() {\n\t\tgraph ret(n);\n\t\tfor(auto v: g) for(auto e: g[v]) {\n\t\t\tret.add_dedge(v, e.to, e.w);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nvector<weight> shortest_path(graph& g, int s) {\n\tint n = g.size();\n\tvector<weight> path(n, -1);\n\tif(g.isweighted() && !g.istree()) { // dijkstra\n\t\tpriority_queue<pair<weight, int>, vector<pair<weight, int>>, greater<pair<weight, int>>> q;\n\t\tpath[s] = 0;\n\t\tq.push({0, s});\n\t\twhile(!q.empty()) {\n\t\t\tweight cost = q.top().first;\n\t\t\tint p = q.top().second;\n\t\t\tq.pop();\n\t\t\tif(path[p] != cost) continue;\n\t\t\tfor(auto e: g[p]) {\n\t\t\t\tif(path[e.to] == -1 || path[e.to] > cost + e.w) {\n\t\t\t\t\tpath[e.to] = cost + e.w;\n\t\t\t\t\tq.push({path[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { // bfs\n\t\tqueue<int> q;\n\t\tpath[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tint p = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e: g[p]) {\n\t\t\t\tif(path[e.to] == -1) {\n\t\t\t\t\tpath[e.to] = path[p] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn path;\n}\n\n\nusing mi = modint;\n\nint g(vector<int>& vec, int m) {\n\tint n = (int)vec.size();\n\tif((int)vec.size() % 2 == 0) {\n\t\tvector<int> rvec = vec;\n\t\treverse(all(rvec));\n\t\tbool ok = true;\n\t\tREP(i, n) {\n\t\t\tif(vec[i] + rvec[i] > m) ok = false;\n\t\t}\n\t\tif(ok) return -1;\n\t\telse return n;\n\t} else {\n\t\tint ng = -1, ok = n;\n\t\twhile(abs(ok - ng) > 1) {\n\t\t\tint mm = (ok + ng) / 2;\n\t\t\tvector<int> nvec;\n\t\t\tREP(i, n) if(i != mm) nvec.pb(vec[i]);\n\t\t\tvector<int> rnvec = nvec;\n\t\t\treverse(all(rnvec));\n\t\t\tbool b = true;\n\t\t\tREP(i, nvec.size()) {\n\t\t\t\tif(nvec[i] + rnvec[i] > m) b = false;\n\t\t\t}\n\t\t\tif(b) ok = mm;\n\t\t\telse ng = mm;\n\t\t}\n\t\treturn ok;\n\t}\n}\n\nint dfs(graph& t, int v, int p, int m) {\n\tvector<int> vec;\n\tif(t[v].size() % 2) vec.pb(0);\n\tfor(auto e: t[v]) {\n\t\tif(e.to == p) continue;\n\t\tint tmp = dfs(t, e.to, v, m);\n\t\tif(tmp == inf) return inf;\n\t\tif(tmp != -1) vec.pb(tmp + 1);\n\t}\n\tsort(all(vec));\n\tint tmp = g(vec, m);\n\tif(tmp == (int)vec.size()) return inf;\n\telse if(tmp == -1) return -1;\n\telse return vec[tmp];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tgraph t(n);\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tt.add_edge(--a, --b);\n\t}\n\tint a = 0;\n\tREP(i, n) if((int)t[i].size() % 2) a++;\n\ta /= 2;\n\tint ng = 0, ok = n - 1;\n\twhile(abs(ok - ng) > 1) {\n\t\tint m = (ok + ng) / 2;\n\t\tif(dfs(t, 0, -1, m) == -1) ok = m;\n\t\telse ng = m;\n\t}\n\tcout << a << \" \" << ok << endl;\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100005];\nbool used[100005];\nP res[100005];\nbool poo[100005];\nvector<int> vi;\n\nP dfs(int v,int p,int len){\n\tint sum=0;\n\tpoo[v]=true;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!poo[G[v][i]]){\n\t\t\tP val=dfs(G[v][i],v,len);\n\t\t\t//vi.push_back(val.second);\n\t\t\tsum+=val.first;\n\t\t}\n\t}\n\tvi.clear();\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tP val=res[G[v][i]];\n\t\t\tvi.push_back(val.second);\n\t\t}\n\t}\n\tif(vi.size()==0)return res[v]=P(1,1);\n\tsort(vi.begin(),vi.end());\n\tint l=0,r=(int)vi.size()-1;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tused[i]=false;\n\t}\n\twhile(l<r){\n\t\tif(vi[l]+vi[r]>len){\n\t\t\tr--;\n\t\t\tcontinue;\n\t\t}\n\t\tused[l]=true;\n\t\tused[r]=true;\n\t\tsum--;\n\t\tl++;\n\t\tr--;\n\t}\n\tbool flag=false;\n\tint len_min=n+5;\n\tfor(int i=0;i<(int)vi.size();i++){\n\t\tif(!used[i]){\n\t\t\tlen_min=min(len_min,vi[i]);\n\t\t\tflag=true;\n\t\t}\n\t}\n\tif(!flag && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}else if(len_min==len && v!=0){\n\t\tsum++;\n\t\tlen_min=0;\n\t}\n\treturn res[v]=P(sum,len_min+1);\n}\n\n\nbool C(int num,int len){\n\tmemset(poo,false,sizeof(poo));\n\tP res=dfs(0,-1,len);\n\tif(res.first>num)return false;\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint l1=0,r1=n;\n\twhile(l1+1<r1){\n\t\tint mid=(l1+r1)/2;\n\t\tif(C(mid,n))r1=mid;\n\t\telse l1=mid;\n\t}\n\tint l2=0,r2=n;\n\twhile(l2+1<r2){\n\t\tint mid=(l2+r2)/2;\n\t\tif(C(r1,mid))r2=mid;\n\t\telse l2=mid;\n\t}\n\tprintf(\"%d %d\\n\",r1,r2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t\t\t\t\t\nusing namespace std;\n\t\t\t\ntypedef long long ll;\n#define mp make_pair\n#define pub push_back\n#define x first\n#define y second\n#define all(a) a.begin(), a.end()\n#define db long double\n#define sz(a) (int)a.size()\n\nint n;\nvector<int> g[100007];\n\nint calcCnt(int v, int pred){\n\tint ans = 0;\n\tint cnt = 0;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tans += calcCnt(to, v);\n\t\tcnt++;\n\t}\n\tif (v != 0) cnt--;\n\tans += (cnt + 1) / 2;\n\treturn ans;\n}\n\nbool f;\nint ww;\n\nint dfs(int v, int pred){\n\tif (g[v].size() == 1 && g[v][0] == pred) return 0;\n\tmultiset<int> se;\n\tfor (auto to : g[v]) if (to != pred){\n\t\tse.insert(dfs(to, v) + 1);\n\t}\n\tif (v == 0){\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\tif ((*se.begin()) > ww) f = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t} else {\n\t\twhile(se.size()){\n\t\t\tif (se.size() == 1){\n\t\t\t\treturn (*se.begin());\n\t\t\t}\n\t\t\tif (se.size() == 2){\n\t\t\t\tif ((*(--se.end())) > ww) f = 0;\n\t\t\t\treturn *se.begin();\n\t\t\t}\n\t\t\tint x = (*(--se.end()));\n\t\t\tse.erase(--se.end());\n\t\t\tint ost = ww - x;\n\t\t\tauto it = se.upper_bound(ost);\n\t\t\tif (it == se.begin()){\n\t\t\t\tf = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tit--;\n\t\t\tse.erase(it);\n\t\t}\n\t}\n}\n\nbool can(int val){ \n\tf = 1; ww = val;\n\tdfs(0, -1);\n\treturn f;\n}\n\nint main(){\n\tsrand(123321);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pub(b);\n\t\tg[b].pub(a);\n\t}\n\n\tint vl = 0, vr = 1e9 + 7;\n\twhile(vl + 1 < vr){\n\t\tint vm = (vl + vr) >> 1;\n\t\tif (can(vm))\n\t\t\tvr = vm;\n\t\telse\n\t\t\tvl = vm;\n\t}\n\tcout << calcCnt(0, -1) << ' ' << vr;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\twhile((int)sak[u].size()>2){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif((int)sak[u].size()==2){\n\t\tit=sak[u].begin(),itt=it;\n\t\titt++;\n\t\tif(*it+*itt<=B) return 0;\n\t\treturn *it;\n\t}\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\n\nint solve(int curr, int prev, int limit)\n{\n    vector<int> v;\n    for(int next : edges[curr]){\n        if(next == prev)\n            continue;\n        v.push_back(solve(next, curr, limit));\n        if(v.back() == -1)\n            return -1;\n    }\n    sort(v.begin(), v.end());\n\n    int n = v.size();\n    int i = 0;\n    int j = v.size() - 1;\n    vector<int> w;\n    while(i < j){\n        if(limit < v[i] + v[j] + 1){\n            w.push_back(v[j]);\n            -- j;\n        }\n        else{\n            ++ i;\n            -- j;\n        }\n    }\n    if(i == j)\n        w.push_back(v[j]);\n\n    if(w.empty())\n        return 1;\n    else if(w.size() <= 2 && w[0] + 1 <= limit)\n        return w.back() + 1;\n    else\n        return -1;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int a, b;\n        cin >> a >> b;\n        -- a;\n        -- b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    int ans = 1;\n    for(int i=0; i<n; ++i)\n        ans += (edges[i].size() - 1) / 2;\n\n    int left = 1;\n    int right = n;\n    while(left < right){\n        int mid = (left + right) / 2;\n        if(solve(0, -1, mid) != -1)\n            right = mid;\n        else\n            left = mid + 1;\n    }\n    cout << ans << ' ' << (left - 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint N;\nvi g[100010];\nint mx;\nint num;\n\nvoid pre(int v, int p)\n{\n\tint cnt = 0;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tpre(to, v);\n\t\t++cnt;\n\t}\n\n\tnum += (cnt / 2);\n\tif (p == -1) {\n\t\tif (cnt & 1) ++num;\n\t}\n}\n\nint dfs(int v, int p, int x)\n{\n\tvi vec;\n\n\tfor (int to : g[v]) if (to != p) {\n\t\tint u = dfs(to, v, x);\n\t\tif (u == -1 || u >= x) {\n\t\t\treturn -1;\n\t\t}\n\t\tvec.pb(u + 1);\n\t}\n\n\tsort(ALL(vec));\n\tint sz = vec.size();\n\n\tmultiset<int> ss;\n\tfor (int x : vec) {\n\t\tss.insert(x);\n\t}\n\n\tint ng_cnt = 0;\n\tint val = -1;\n\n\twhile (ss.size() >= 2) {\n\t\tint a = *ss.rbegin();\n\t\tss.erase(ss.lower_bound(a));\n\t\tauto it = ss.upper_bound(x - a);\n\n\t\tif (it == ss.begin()) {\n\t\t\tif (ng_cnt > 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tng_cnt++;\n\t\t\tval = a;\n\t\t} else {\t\t\n\t\t\t--it;\n\t\t\tss.erase(it);\n\t\t}\n\t}\n\n\t//ng_cnt <= 1, ss.size() <= 1\n\n\tif (p == -1) {\n\t\tif (sz & 1) {\n\t\t\tif (ng_cnt + ss.size() > 1) {\n\t\t\t\treturn -1;\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\tif (ng_cnt || ss.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (ss.size() && ng_cnt) {\n\t\tassert(sz%2==0);\n\t\treturn min(*ss.begin(), val);\n\t} else if (ng_cnt) {\n\t\treturn val;\n\t} else if (ss.size()) {\n\t\treturn *ss.begin();\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nbool ok(int x)\n{\n\tint t = dfs(0, -1, x);\n\t//cout << t << endl;\n\treturn (t != -1);\n}\n\nint main() {\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\tpre(0, -1);\n\n\tint lo = 0, hi = N;\n\t//ok(2);\n\n\twhile (hi - lo > 1) {\n\t\tint m = (lo + hi) / 2;\n\t\tif (ok(m)) {\n\t\t\thi = m;\n\t\t} else {\n\t\t\tlo = m;\n\t\t}\n\t}\n\n\tcout << num << \" \" << hi << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nint dp[MAX_N];\n\nint dfs(int u, int p)\n{\n    int cnt = 0, num = 0;\n    for(int v : G[u]){\n        if(v != p){\n            dfs(v, u);\n            num += dp[v];\n            cnt++;\n        }\n    }\n    dp[u] = cnt/2 + num;\n    return (cnt+1)/2 + num;\n}\n\nvoid dfs2(int u, int p, int cri, int& sm)\n{\n    multiset<int> ng;\n    for(int v : G[u]){\n        if(v != p){\n            dfs2(v, u, cri, sm);\n            ng.insert(dp[v]);\n        }\n    }\n    while(!ng.empty()){\n        if(len(ng) == 1){\n            int val = *ng.begin();\n            if(cri >= val+1){\n                dp[u] = val + 1;\n                return;\n            }else{\n                dp[u] = 1;\n                sm++;\n                return;\n            }\n        }else{\n            int val = *(--ng.end());\n            ng.erase(--ng.end());\n            if(val == cri){\n                sm++;\n                ng.insert(0);\n            }else{\n                auto it = ng.upper_bound(cri-val-2);\n                if(it == ng.begin()){\n                    sm++;\n                }else{\n                    --it;\n                    ng.erase(it);\n                    sm++;\n                }\n            }\n        }\n    }\n    dp[u] = 0;\n}\n\nbool possible(int cri, int a)\n{\n    int sm = 0;\n    dfs2(0, -1, cri, sm);\n    if(dp[0]) sm++;\n    return (sm == a);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        cin >> a >> b;\n        G[a-1].pb(b-1), G[b-1].pb(a-1);\n    }\n    int a = dfs(0, -1);\n    int l = 0, r = n;\n    while(r-l>1){\n        int mid = (l+r)/2;\n        if(possible(mid, a)){\n            r = mid;\n        }else{\n            l = mid;\n        }\n    }\n    cout << a << \" \" << r << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=1e3+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=1e5+10;\n\t//------------------FIXED------------------\n\tint cnt;int up[N];vc<int> to[N];\n\tvoid solve(int x,int fa,int mx)\n\t{\n\t\tmultiset<int> now;for(auto y:to[x]) if(y!=fa) solve(y,x,mx),now.insert(up[y]+1);\n\t\tif(x==5)\n\t\t\tdeb;\n\t\tint mi=INF;\n\t\twhile(sz(now))\n\t\t{\n\t\t\tint len=*(--now.end());now.erase(--now.end());\n\t\t\tmultiset<int>::iterator IT=now.upper_bound(mx-len);\n\t\t\tif(IT==now.begin()) cnt++,chmin(mi,len);\n\t\t\telse IT--,now.erase(IT),cnt++;\n\t\t}\n\t\tif(fa==0) ;\n\t\telse if(mi+1>mx) up[x]=0; else cnt--,up[x]=mi;\n\t\tdebug(\"mx=%d up(%d)=%d cnt=%d\\n\",mx,x,up[x],cnt);\n\t}\n\tvoid main()\n\t{\n\t\tint n=qread();fo(i,2,n){ int x=qread(),y=qread();to[x].PB(y),to[y].PB(x); }\n\t\tsolve(1,0,n);int A=cnt,B=-1;\n\t\tfor(int fl=1,fr=n;fl<=fr;){\n\t\t\tint T=(fl+fr)/2;cnt=0;solve(1,0,T);\n\t\t\tdebug(\"T=%d cnt=%d\\n\",T,cnt);\n\t\t\tassert(cnt>=A);\n\t\t\tif(cnt==A) B=T,fr=T-1; else fl=T+1;\n\t\t}\n\t\twrite1(A),write(B);\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  V<> deg(n);\n  for (int _ = 0; _ < n - 1; ++_) {\n    int u, v; cin >> u >> v, --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n    ++deg[u], ++deg[v];\n  }\n  cout << count_if(begin(deg), end(deg), [](int x) { return x & 1; }) / 2 << ' ';\n  auto chk = [&](int x) -> bool {\n    V<> dp(n, 1e9);\n    auto dfs = [&](const auto& dfs, int v, int p) -> void {\n      V<> a;\n      for (int w : g[v]) if (w != p) {\n        dfs(dfs, w, v);\n        a.push_back(dp[w] + 1);\n      }\n      if (~a.size() & 1) a.push_back(0);\n      sort(begin(a), end(a));\n      int m = a.size(), ng = -1, ok = m;\n      while (ok - ng > 1) {\n        int mid = ng + ok >> 1;\n        V<> b;\n        for (int i = 0; i < m; ++i) if (i != mid) {\n          b.push_back(a[i]);\n        }\n        int mx = 0;\n        for (int i = 0; i < m / 2; ++i) {\n          mx = max(mx, b[i] + b[b.size() + ~i]);\n        }\n        (mx <= x ? ok : ng) = mid;\n      }\n      if (ok == m) return;\n      dp[v] = a[ok];\n    };\n    int r = -1;\n    for (int v = 0; v < n; ++v) if (deg[v] == 1) {\n      r = v;\n      break;\n    }\n    dfs(dfs, r, -1);\n    return dp[r] <= x;\n  };\n  int ng = 0, ok = n - 1;\n  while (ok - ng > 1) {\n    int mid = ng + ok >> 1;\n    (chk(mid) ? ok : ng) = mid;\n  }\n  cout << ok << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int Nmax=114514;\nvi tr[Nmax];\npi dfs(int v,int p,int b){\n\tmultiset<int> lens;\n\tint cnt=0;\n\tfor(auto ch:tr[v])if(ch!=p){\n\t\tpi w=dfs(ch,v,b);\n\t\tcnt+=w.first;\n\t\tlens.insert(w.second);\n\t}\n\tint rems=0,mn=inf;\n\twhile(!lens.empty()){\n\t\tauto itr=lens.end();itr--;\n\t\tint x=*itr;lens.erase(itr);\n\t\titr=lens.upper_bound(b-x);\n\t\tif(itr==lens.begin()){\n\t\t\trems++;\n\t\t\tchmin(mn,x);\n\t\t}else{\n\t\t\titr--;\n\t\t\tlens.erase(itr);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(mn==b){\n\t\trems++;\n\t\tmn=0;\n\t}\n\tif(rems)\n\t\tcnt+=rems-1;\n\telse\n\t\tmn=0;\n\treturn pi(cnt,mn+1);\n}\n\nsigned main(){\n\tint n=read();\n\tREP(i,n-1){\n\t\tint a=read()-1,b=read()-1;\n\t\ttr[a].PB(b);\n\t\ttr[b].PB(a);\n\t}\n\tint par;\n\tREP(i,n)if(tr[i].size()==1)par=i;\n\tint root=tr[par][0];\n\tint a=dfs(root,par,inf).first+1;\n\tint bot=0,up=n;\n\twhile(up-bot>1){\n\t\tint mid=(up+bot)/2;\n\t\tpi w=dfs(root,par,mid);\n\t\tif(w.first==a-1)\n\t\t\tup=mid;\n\t\telse\n\t\t\tbot=mid;\n\t}\n\tcout<<a<<\" \"<<up<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<set>\n#include<map>\n\nnamespace fuck\n{\n\tconst int N=1001000,M=N*2;\n\tint begin[N],next[M],to[M];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\ttypedef std::map<int,int>::iterator mit;\n\tint f[N],g[N],lim;\n\tstd::map<int,int> S;\n\n\tmit it;\n\tint w,dw,cnt;\n\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tf[p]=g[p]=0;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)dfs(q,p);\n\t\tS.clear();\n\n\t\tcnt=0;\n\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tf[p]+=f[q];\n\t\t\t\tS[g[q]+1]++;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tit=S.end();it--;\n\t\t\tw=it->first,dw=lim-w;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\n\t\t\tf[p]++;\n\t\t\tit=S.upper_bound(dw);\n\t\t\tif(it==S.begin())continue;\n\t\t\telse it--;\n\n\t\t\tit->second--;\n\t\t\tif((it->second)==0)S.erase(it);\n\t\t\tcnt--;\n\t\t}\n\n\t\tif(!cnt)g[p]=0;\n\t\telse g[p]=S.begin()->first;\n\n\t\tif(g[p]==lim)f[p]++,g[p]=0;\n\t\tif(p==1 && g[p]!=0)f[p]++,g[p]=0;\n\t}\n\tint c[N];\n\tvoid solve()\n\t{\n\t\tinitialize();\n\n\t\tif(n>98000)exit(1);\n\n\t\tlim=n+10,dfs();\n\t\tint A=f[1],u=n,d=0;\n\n\t\twhile(u>d)\n\t\t{\n\t\t\tlim=(u+d)>>1;\n\t\t\tdfs();\n\t\t\tif(f[1]==A)u=lim;\n\t\t\telse d=lim+1;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",A,d);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n\n\tfuck::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,res,du[N];\nvi g[N];\nint A,B;\n\ninline int dfs(int x,int F=0){\n\tint ret=1,isok=0;\n\tvi v(0);\n\tfor(int y:g[x]){\n\t\tif(y==F) continue;\n\t\tv.pb(dfs(y,x));isok=1;\n\t}\n\tif(!isok) return 1;\n\tsort(v.begin(),v.end());\n\tint l=0,r=SZ(v)-1;\n\tfor(int l=0,r=SZ(v)-1;l<r;)\n\t\tif(v[l]+v[r]+1<=B) l++,r--,res++; else r--,res++;\n\tif(l==r){\n\t\tif(v[l]+1>=B){res++;return 1;}\n\t\treturn v[l]+1;\n\t}\n\treturn 1;\n}\t\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t\tdu[x]++;du[y]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tA+=(du[i]-1)/2;\n\tint l=2,r=n;\n\twhile(l<r){\n\t\tint mid=l+r>>1;B=mid;\n\t\tres=0;dfs(1);\n\t\tif(res<=A) r=mid; else l=mid+1;\n\t}\n\tprintf(\"%d %d\\n\",A+1,r-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\n\nint dfs(int cur,int pre,int T) {\n\tmultiset<int> V;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tint ret=dfs(e,cur,T);\n\t\tif(ret==-2) return -2;\n\t\tif(ret>=0) V.insert(ret+1);\n\t}\n\tif(E[cur].size()%2) V.insert(0);\n\t\n\tint cand=-1;\n\twhile(V.size()) {\n\t\tint x=*V.rbegin();\n\t\tV.erase(V.find(x));\n\t\t\n\t\tauto it=V.lower_bound(T-x+1);\n\t\tif(it==V.begin()) {\n\t\t\tif(V.size()) return -2;\n\t\t\tif(cand!=-1) return -2;\n\t\t\tcand=x;\n\t\t}\n\t\telse {\n\t\t\tit--;\n\t\t\tV.erase(it);\n\t\t}\n\t}\n\treturn cand;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tint A=0;\n\tFOR(i,N) if(E[i].size()%2==1) A++;\n\t\n\tint B=1<<20;\n\tfor(i=19;i>=0;i--) {\n\t\tif(dfs(0,-1,B-(1<<i))!=-2) B-=1<<i;\n\t}\n\t\n\tcout<<A/2<<\" \"<<B<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint n; \nconst int INF = int(1e9);\nconst int N = 123456;\nii dp[N];\nvi adj[N];\n\nint threshold;\n\nvoid dfs(int u, int p=-1)\n{\n\tint sum = 0; dp[u]=mp(INF,INF);\n\tdeque<int> V;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t\tsum+=dp[v].fi;\n\t\tV.pb(dp[v].se);\n\t}\n\tsort(V.begin(),V.end());\n\twhile(!V.empty()&&V.back()>=threshold)\n\t{\n\t\tV.pop_back(); V.push_front(0); sum++;\n\t}\n\tdeque<int> tmp = V;\n\tint sumtmp=sum;\n\t{\n\t\tint mnup=INF;\n\t\twhile(!V.empty())\n\t\t{\n\t\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t\t{\n\t\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t\t}\n\t\t\tif(V.back()+1<=threshold)\n\t\t\t{\n\t\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t\t}\n\t\t}\n\t\tdp[u]=min(dp[u],mp(sum,mnup));\n\t}\n\tint mnsum=sum;\n\tV=tmp;sum=sumtmp;\n\tint lo = 0; int hi = int(V.size())-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tsum=sumtmp; V=tmp;\n\t\tint mnup=V[mid]+1;\n\t\t//cerr<<u<<' '<<sum<<' '<<mnsum<<' '<<mnup<<'\\n';\n\t\tV.erase(V.begin()+mid);\n\t\twhile(!V.empty())\n\t\t{\n\t\t\tif(V.size()>=2&&V[0]+V.back()+2<=threshold)\n\t\t\t{\n\t\t\t\tsum--; V.pop_front(); V.pop_back(); continue;\n\t\t\t}\n\t\t\tif(V.back()+1<=threshold)\n\t\t\t{\n\t\t\t\tmnup=min(mnup,V.back()+1); V.pop_back(); continue;\n\t\t\t}\n\t\t}\n\t\tdp[u]=min(dp[u],mp(sum,mnup));\n\t\tif(sum<=mnsum)\n\t\t{\n\t\t\thi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\t//cerr<<threshold<<\" | \"<<u<<' '<<dp[u].fi<<' '<<dp[u].se<<'\\n';\n}\n\nint calc(int C)\n{\n\tthreshold=C;\n\tdfs(0,-1); \n\treturn dp[0].fi;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tint bestres = calc(n+1);\n\tint lo=1; int hi=n;\n\tint ans=-1;\n\twhile(lo<=hi)\n\t{\n\t\tint mid=(lo+hi)>>1;\n\t\tint v=calc(mid);\n\t\tif(v<=bestres)\n\t\t{\n\t\t\tans=mid; hi=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tcout<<bestres<<' '<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tls.insert(tmp);\n\t}\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()) return -1;\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(ls.size() == 0) return 1;\n\telse return *ls.begin() + 1;\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=0;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += deg%2;\n\t}\n\tA/=2;\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> G[100100];\nint N,Y;\n\nint dfs(int x, int l, int m)\n{\n\tvector<int> u;\n\tfor (auto &y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x,m)+1);\n\t}\n\tsort(u.begin(),u.end());\n\tint ret = 0;\n\tif (u.size() % 2 == 0){\n\t\tint y = 1;\n\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t}\n\t\tif (!y){\n\t\t\tif (u.back() <= m) u.pop_back();\n\t\t\telse Y = 0;\n\t\t}\n\t}\n\tif (u.size() % 2){\n\t\tint l = 0, r = u.size()-1, a = u.size();\n\t\twhile (l <= r){\n\t\t\tint mm = (l + r) / 2;\n\t\t\tint y = 1;\n\t\t\tfor (int i=0,j=(int)u.size()-1;i<j;i++,j--){\n\t\t\t\tif (i == mm) i++;\n\t\t\t\tif (j == mm) j--;\n\t\t\t\tif (i >= j) break;\n\t\t\t\tif (u[i] + u[j] > m) y = 0;\n\t\t\t}\n\t\t\tif (u[mm] > m) y = 0;\n\t\t\tif (y){\n\t\t\t\ta = mm;\n\t\t\t\tr = mm - 1;\n\t\t\t}\n\t\t\telse l = mm + 1;\n\t\t}\n\t\tif (a == u.size()) Y = 0;\n\t\telse ret = u[a];\n\t}\n\treturn ret;\n}\n\nint chk(int m)\n{\n\tY = 1;\n\tif (dfs(1,0,m) > m) Y = 0;\n\treturn Y;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\n\tint a = 0;\n\tfor (int i=1;i<=N;i++) a += G[i].size() % 2;\n\ta /= 2;\n\n\tint l = 2, r = N, b = N;\n\twhile (l <= r){\n\t\tint m = (l + r) / 2;\n\t\tif (chk(m)){\n\t\t\tb = m;\n\t\t\tr = m - 1;\n\t\t}\n\t\telse l = m + 1;\n\t}\n\n\tprintf (\"%d %d\\n\",a,b);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\n#define pb push_back\n#define sz(a) int(a.size())\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,A,lim,f[N],rt;\nvector<int> E[N];\nbool fl;\n\nbool check2(vector<int> &v,int mid) {\n\tint l=0,r=sz(v)-1;\n\twhile(l<r) {\n\t\tif(l==mid) { ++l;continue; }\n\t\tif(r==mid) { --r;continue; }\n\t\tif(v[l]+v[r]>lim) return 0;\n\t\t++l,--r;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int u,int fa) {\n\tvector<int> vec;\n\tfor(auto v:E[u]) if(v^fa) dfs(v,u),vec.pb(f[v]);\n\tif(sz(vec)&1^1) vec.pb(0);\n\tsort(vec.begin(),vec.end());\n\tint l=0,r=sz(vec);\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check2(vec,mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tif(l==sz(vec)) { fl=0;return; }\n\tf[u]=vec[l]+1;\n}\n\nbool check(int mid) {\n\tlim=mid;fl=1;dfs(rt,0);\n\treturn fl&&f[rt]<=lim+1;\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tfor(int i=1;i<=n;i++)\n\t\tif(sz(E[i])&1) ++A,rt=i;\n\tint l=0,r=n;\n\twhile(l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcout<<A/2<<' '<<l;\n\tcheck(2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =1002;\nconst int MOD =1000000007;\nvector<int> hen[100000];\nbool used[100000];\nint ok,ng,mid;\nint dfs(int a,bool a0){\n  used[a]=true;\n  vector<int> v;\n  for(auto&& i:hen[a])if(!used[i]){\n    int b=dfs(i,false);\n    if(b==-1)return -1;\n    v.push_back(b+1);\n  }\n  sort(v.begin(),v.end());\n  if(v.size()%2==0){\n    bool t=true;\n      for(int i=0;i*2<v.size();i++){\n        if(v[i]+v[v.size()-1-i]>mid){\n          t=false;\n          break;\n        }\n      }\n    if(t)return 0;\n    if(v[v.size()-1]>mid||a0)return -1;\n    v.pop_back();\n  }\n  \n    int ok2=v.size(),ng2=-1,mid2;\n    while(abs(ok2-ng2)>1){\n      mid2=(ok2+ng2)/2;\n      bool t=true;\n      for(int i=0;i*2<v.size()-1;i++){\n        if(v[i+(i>=mid2)]+v[v.size()-2-i+(v.size()-2-i>=mid2)]>mid){\n          t=false;\n          break;\n        }\n      }\n      if(t)ok2=mid2;\n      else ng2=mid2;\n    }\n    if(ok2==v.size())return -1;\n    return v[ok2];\n    \n  \n}\nsigned main(){\n int n,a,b,ansa=1;\n cin>>n;\n for(int i=0;i<n-1;i++){\n   cin>>a>>b;\n   a--;b--;\n   hen[a].push_back(b);\n   hen[b].push_back(a);\n }\n for(int i=0;i<n;i++)ansa+=(hen[i].size()-1)/2;\n  ng=0;ok=n;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    fill(used,used+n,false);\n    int y=dfs(0,true);\n    if(y==-1||y>mid)ng=mid;\n    else ok=mid;\n  }\n  cout<<ansa<<' '<<ok<<endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "//created by missever\n\n#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\n\nint add(int x, int y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n}\n\nint mul(int x, int y) {\n    LL z = 1LL * x * y;\n    return z - z / mod * mod;\n}\n\nvector<int> g[maxn];\nmap<int, int> q[maxn];\nint m;\nint c[maxn];\n\nbool dfs(int u, int fa) {\n    q[u].clear();\n    for(auto v : g[u]) {\n        if(v == fa) continue;\n        if(!dfs(v, u)) return false;\n        q[u][c[v]]++;\n    }\n    int n = g[u].size() - (fa != 0);\n    if(!(n & 1)) q[u][0]++;\n    for(int i = 0; i < n / 2; i++) {\n        auto e = q[u].end();\n        e--;\n        int x = (*e).first;\n        if(--q[u][x] == 0) q[u].erase(x);\n        e = q[u].upper_bound(m - x);\n        if(e == q[u].begin()) return false;\n        e--;\n        int y = (*e).first;\n        if(--q[u][y] == 0) q[u].erase(y);\n    }\n    c[u] = (*q[u].begin()).first + (u != 1);\n    //cout<<u<<\" \"<<c[u]<<endl;\n    return c[u] <= m;\n\n}\n\nint pdfs(int u, int fa) {\n    int t = 0;\n    for(auto v : g[u]) {\n        if(v == fa) continue;\n        t += pdfs(v, u);\n    }\n    int n = g[u].size() - (fa != 0);\n    t += n / 2;\n    if(u == 1 && n & 1) t++;\n    return t;\n}\n\n\nint main() {\n#ifdef CX_TEST\n    freopen(\"E:\\\\program--GG\\\\test_in.txt\", \"r\", stdin);\n#endif\n    int n, i, u, v;\n    scanf(\"%d\", &n);\n    for(i = 1; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int l = 1, r = n;\n    while(l < r) {\n        int mid = (l + r) >> 1;\n        m = mid;\n        //cout<<mid<<endl;\n        if(dfs(1, 0)) r = mid;\n        else l = mid + 1;\n    }\n    printf(\"%d %d\\n\", pdfs(1, 0), r);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,x,y,ans,l,r,mid,tot,f[N],a[N],g[N],head[N],d[N];\nstruct edge{int v,nxt;}e[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool dp(int u,int fa){\n    f[u]=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) if (!dp(v,u)) return 0;\n    //printf(\"+++++++%d+++++++\\n\",u);\n    //for (int i=head[u],v;i;i=e[i].nxt)\n        //if ((v=e[i].v)!=fa) printf(\"%d\\n\",f[v]);\n    int xb=0;\n    for (int i=head[u],v;i;i=e[i].nxt)\n        if ((v=e[i].v)!=fa) a[++xb]=f[v]+1;\n    sort(a+1,a+xb+1);// for (int i=1;i<=xb;i++) cout<<a[i]<<endl;\n    memset(g,-1,sizeof(int)*(xb+1));\n    int j,k; j=1;\n    for (int i=1;i<=xb;i++)\n        for (;j<i && a[j]+a[i]<=mid;j++) g[i]=j;\n    j=0,k=0;\n    if (xb&1){\n        for (int i=xb;i>xb/2+1;i--) if (g[i]<n-i+1){k=i; break;} //cout<<k<<endl;\n        if (k==0){\n            j=1; for (int i=xb;i>xb/2+1;i--) if (f[i]<xb-i+2) j=xb-i+2;\n            f[u]=a[j];\n        }\n        else{\n            j=0; for (int i=xb;i>xb/2;i--) if (k!=i){j++; if (a[i]+a[j]>mid) return 0;}\n            f[u]=a[k];\n        }\n    }\n    else{\n        j=0; for (int i=xb;i>xb/2;i--) if (a[i]+a[xb-i+1]>mid) return 0;\n        f[u]=0;\n    }\n    if (u==1 && f[u]>mid) return 0;\n    return 1;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){scanf(\"%d%d\",&x,&y); add(x,y); add(y,x); d[x]++; d[y]++;}\n    for (int i=1;i<=n;i++) if (d[i]&1) ans++;\n    ans/=2; printf(\"%d \",ans);\n    l=1,r=n;\n    while (l<=r){\n        mid=(l+r)>>1; memset(f,0,sizeof f);\n        if (dp(1,0)){ans=mid; r=mid-1;} else l=mid+1;\n    } //mid=1; if (dp(1,0)) puts(\"orz\");\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nint n, m;\nvector<int> edge[100001];\n\nint dfs(int x, int p) {\n    vector<int> child;\n    for (int i : edge[x]) {\n        if (i == p) continue;\n        int ret = dfs(i, x);\n        if (ret > m) return m + 5;\n        child.push_back(ret);\n    }\n    if ((child.size() & 1) == 0) child.push_back(0);\n    sort(child.begin(), child.end());\n    int s = 0, e = child.size();\n    while (s < e) {\n        int md = (s + e) / 2, pos = 1;\n        for (int i = 0, j = child.size() - 1; ; ++i, --j) {\n            if (i == md) ++i;\n            if (j == md) --j;\n            if (j <= i) break;\n            if (child[i] + child[j] > m) {\n                pos = 0;\n                break;\n            }\n        }\n        if (pos) e = md;\n        else s = md + 1;\n    }\n    if (s == child.size()) return m + 5;\n    return child[s] + 1;\n}\n\nint check() {\n    return dfs(1, 0) <= m + 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    int A = n - 1;\n    for (int i = 1; i <= n; ++i) A -= edge[i].size() >> 1;\n    int s = 1, e = n - 1;\n    while (s < e) {\n        m = (s + e) / 2;\n        if (check()) e = m;\n        else s = m + 1;\n    }\n    printf(\"%d %d\\n\", A, s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n\n        }\n\n    dp[n]=X[ind].first+1;\n\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n\n\n    int low=1;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define fo(a,b) for(int o=a;o<b;++o)\n#define fdi(a,b) for(int i=a-1;i>=b;--i)\n#define fdj(a,b) for(int j=a-1;j>=b;--j)\n#define fdo(a,b) for(int o=a-1;o>=b;--o)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n////////////////////\n\nint const N = 1e5 + 41;\nint const INF = 1e9 + 41;\n\nvector<int> e[N];\nint n, d[N], q[N], m;\nint a, b;\n\nint getmatch(multiset<int> &t, int x){\n\tif(sz(t) == 0) return INF;\n\tmultiset<int> :: iterator it = t.upper_bound(x);\n\tif(it == t.begin()) return INF;\n\t--it;\n\treturn (*it);\n}\n\nvoid dfs(int x, int p = -1){\n\td[x] = 0;\n\tq[x] = 0;\n\tvector<int> h;\n\tfi(0, sz(e[x])){\n\t\tint y = e[x][i];\n\t\tif(y == p) continue;\n\t\tdfs(y, x);\n\t\th.pb(d[y] + 1);\n\t\tq[x] += q[y];\n\t}\n\tsort(h.begin(), h.end());\n\tmultiset<int> t;\n\tfdi(sz(h), 0){\n\t\tint v0 = h[i];\n\t\tint v1 = m - x;\n\t\tint k = getmatch(t, v1);\n\t\tif(k + v0 <= m){\n\t\t\tt.erase(t.find(k));\n\t\t\tq[x] += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tt.insert(v0);\n\t}\n\tq[x] += sz(t);\n\tif(sz(t) > 0){\n\t\tint v0 = (*t.begin());\n\t\tif(v0 < m){\n\t\t\t--q[x];\n\t\t\td[x] = v0;\n\t\t}\n\t}\n}\n\nint calc(int m){\n\t::m = m;\n\tdfs(0);\n\tint res = q[0];\n\tif(d[0] > 0) res += 1;\n\treturn res;\n}\n\nvoid solve(){\n\tif(n == 2){\n\t\ta = 1;\n\t\tb = 1;\n\t\treturn;\n\t}\n\tint l = 0;\n\tint r = N;\n\ta = calc(n);\n\twhile(r-l>1){\n\t\tint m = (l+r)/2;\n\t\tif(calc(m) == a) r = m;\n\t\telse l = m;\n\t}\n\tb = r;\n\t/*fi(0, n+1){\n\t\tif(calc(i) == a){\n\t\t\tb = i;\n\t\t\tbreak;\n\t\t}\n\t}*/\n\t\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d\",&n);\n\tfi(0, n-1){\n\t\tint x, y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\t--x;--y;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d %d\\n\",a,b);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> edge;\n\nbool isok(const vector<int>& v, int rem, int k) {\n    int j = (int)v.size() - 1;\n    for (int i = 0; ; i++) {\n        if (i == rem) ++i;\n        if (j == rem) --j;\n        if (i >= j) return true;\n        if (v[i] + v[j] > k) return false;\n        --j;\n    }\n}\n\nint dfs(int p, int par, int k) {\n    vector<int> v;\n    for (int i : edge[p]) {\n        if (i == par) continue;\n        v.push_back(dfs(i, p, k) + 1);\n    }\n    if (v.size() % 2 == 0) v.push_back(0);\n    sort(v.begin(), v.end());\n    if (isok(v, 0, k))\n        return v[0];\n    if (!isok(v, (int)v.size() - 1, k))\n        return k + 1;\n\n    int ok = (int)v.size() - 1, ng = 0;\n    while (ng < ok - 1) {\n        int m = (ok + ng) / 2;\n        if (isok(v, m, k))\n            ok = m;\n        else ng = m;\n    }\n    return v[ok];\n}\n\nint main() {\n    cin >> n;\n    edge.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n    int a = 1;\n    for (int i = 0; i < n; i++)\n        a += (edge[i].size() + 1) / 2 - 1;\n\n    int ok = n - 1, ng = 0;\n    while (ng < ok - 1) {\n        int m = (ok + ng) / 2;\n        if (dfs(0, -1, m) <= m)\n            ok = m;\n        else ng = m;\n    }\n    cout << a << \" \" << ok << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100;\nint beg[maxn],tto[maxn<<1],nex[maxn<<1],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint dfsA(int u,int fa){\n\tint res=0,cnt=0;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tres+=dfsA(tto[i],u);\n\t\tcnt++;\n\t}\n\tif(fa==-1) res+=(cnt+1)/2;\n\telse res+=cnt/2;\n\treturn res;\n}\nint B,bo;\nmultiset<int> sak[maxn];\nmultiset<int>::iterator it,itt;\nint n;\nint dfsB(int u,int fa){\n\tint v;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tv=dfsB(tto[i],u)+1;\n\t\tif(v>B){\n\t\t\tbo=0;\n\t\t\treturn 0;\n\t\t}\n\t\tsak[u].insert(v);\n\t\tif(!bo) return 0;\n\t}\n\tint res=1;\n\twhile((int)sak[u].size()>1){\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tv=*itt;\n\t\tit=sak[u].upper_bound(B-v);\n\t\tif(it==sak[u].begin()){\n\t\t\tif(!res){\n\t\t\t\tbo=0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tres--;\n\t\t\tsak[u].erase(itt);\n\t\t\tcontinue;\n\t\t}\n\t\tit--;\n\t\tif(it==itt) it--;\n\t\tsak[u].erase(it);\n\t\titt=sak[u].end();\n\t\titt--;\n\t\tsak[u].erase(itt);\n\t}\n\tif(sak[u].empty()) return 0;\n\treturn *sak[u].begin();\n}\nbool solve(int x){\n\tB=x,bo=1;\n\tfor(int i=1;i<=n;i++)\n\t\tsak[i].clear();\n\tdfsB(1,-1);\n\treturn bo;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tint s,t;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tputin(s,t);\n\t\tputin(t,s);\n\t}\n\tint A=dfsA(1,-1);\n\tint l=0,r=n,mid;\n\twhile(r-l>1){\n\t\tmid=(l+r)>>1;\n\t\tif(solve(mid)) r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%d %d\\n\",A,r);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif (ch=='-')f=-1,ch=getchar();\n\twhile (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n\n//---------------------------------------------------head---------------------------------------------------\n\nint n;\n#define maxn 100005\nstruct Edge{\n\tint son[maxn<<1],nxt[maxn<<1],lnk[maxn],tot;\n\tvoid add(int x,int y){\n\t\ttot++;son[tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;\n\t\ttot++;son[tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;\n\t}\n}edge;\nint cnt[maxn];\nint middle;\nint f[maxn],g[maxn];\nint father[maxn];\nbool vis[maxn];\nvoid setfather(int now){\n\tvis[now]=true;\n\tfor (int j=edge.lnk[now];j;j=edge.nxt[j])\n\t\tif (!vis[edge.son[j]]){\n\t\t\tfather[edge.son[j]]=now;setfather(edge.son[j]);\n\t\t}\n}\nbool used;\nint cwy[maxn];\nint d[maxn];\nbool check_que(int mid){\n\td[0]=0;\n\trep(i,1,cwy[0])if (i!=mid)d[++d[0]]=cwy[i];\n\trep(i,1,d[0])if (d[i]+d[d[0]-i+1]>middle)return false;\n\treturn true;\n}\nvoid dfs(int now){\n\tfor (int j=edge.lnk[now];j;j=edge.nxt[j])if (edge.son[j]!=father[now])\n\t\tdfs(edge.son[j]);\n\t// vector<int>cwy;cwy.clear();\n\tcwy[0]=0;\n\tfor (int j=edge.lnk[now];j;j=edge.nxt[j])if (edge.son[j]!=father[now]){\n\t\tcwy[++cwy[0]]=f[edge.son[j]]+1;\n\t}\n\tif (cnt[now])cwy[++cwy[0]]=0;\n\tsort(cwy+1,cwy+cwy[0]+1);\n\tif (now==1){\n\t\trep(i,1,cwy[0]/2)if (cwy[i]+cwy[cwy[0]-i+1]>middle)used=false;\n\t}\n\telse{\n\t\tif (cnt[now]){\n\t\t\tint l=1,r=cwy[0];\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif (check_que(mid))r=mid-1;\n\t\t\t\telse l=mid+1;\n\t\t\t}\n\t\t\tif (l>cwy[0])used=false;\n\t\t\telse f[now]=cwy[l];\n\t\t}\n\t\telse{\n\t\t\tint l=1,r=cwy[0];\n\t\t\twhile (l<=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif (check_que(mid))r=mid-1;\n\t\t\t\telse l=mid+1;\n\t\t\t}\n\t\t\tif (l>cwy[0])used=false;\n\t\t\telse f[now]=cwy[l];\n\t\t}\n\t}\n\t// printf(\"%d %d %d\\n\",now,f[now],used);\n}\nbool check(int mid){\n\tmiddle=mid;\n\tmemset(f,0,sizeof(f));\n\tmemset(g,0,sizeof(g));\n\tmemset(vis,0,sizeof(vis));\n\tused=true;dfs(1);return used;\n}\nint main(){\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tedge.add(x,y);\n\t\tcnt[x]^=1;cnt[y]^=1;\n\t}\n\tint ans=0;\n\trep(i,1,n)if (cnt[i])ans++;\n\tprintf(\"%d \",ans/2);\n\tint l=1,r=n;setfather(1);\n\t// printf(\"%d\\n\",check(4));\n\t// printf(\"%d\\n\",check(2));\n\twhile (l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif (check(mid))r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%d\\n\",l);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\nvector<int> V[100005];\nint dp[100005];\nint ans;int ok;\nvoid dfs(int n,int mid,int p=-1){\n   vector<pair<int,int> > X;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs(V[n][i],mid,n);\n        X.push_back(make_pair(dp[V[n][i]],V[n][i]));\n    }\n    if(X.size()==0){\n        dp[n]=1;return;\n    }\n    if(X.size()%2==0){\n        X.push_back(make_pair(0,0));\n    }\n    sort(X.begin(),X.end());\n    int low=0;int high=X.size()-1;\n    while(high-low>1){\n        int m=(low+high)/2;\n        vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==m) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                ok=1;break;\n            }\n        }\n        if(!ok){\n            high=m;\n        }\n        else\n            low=m+1;\n    }\n    int ind=low;\n     vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=low;\n        }\n        else{\n            vector<int> A,B;\n        int sz=X.size()/2;\n        int coun=0;\n        ind=high;\n        for(int i=0;i<X.size();++i){\n            if(i==ind) continue;\n            if(coun==sz){\n                B.push_back(X[i].first);\n            }\n            else{\n                ++coun;A.push_back(X[i].first);\n            }\n        }\n        reverse(B.begin(),B.end());\n        bool Ok=0;\n        for(int i=0;i<A.size();++i){\n            if(A[i]+B[i]+1>mid){\n                Ok=1;break;\n            }\n        }\n        if(!Ok){\n            ind=high;\n        }\n        else{\n            dp[n]=1000000000;return;\n        }\n\n        }\n\n    dp[n]=X[ind].first+1;\n\n\n\n\n\n\n}\nvoid dfs2(int n,int p=-1){\n    int sz=0;\n    for(int i=0;i<V[n].size();++i){\n        if(V[n][i]==p) continue;\n        dfs2(V[n][i],n);\n        ++sz;\n    }\n    ans+=sz/2;\n\n}\nint main(){\n    int n;cin >> n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        V[a].push_back(b);V[b].push_back(a);\n    }\n    int all=0;\n\n\n    int low=0;\n    int high=n;\n    dfs2(1);\n    if(V[1].size()%2) ++ans;\n\n   // ++ans;\n    while(high-low>1){\n\n       ok=ans;\n        int mid=(high+low)/2;\n       // cout << mid << endl;\n        dfs(1,mid);\n        if(dp[1]<=mid){\n            high=mid;\n        }\n        else{\n            low=mid+1;\n        }\n    }\n    ok=ans;\n    dfs(1,low);\n    if(dp[1]<=low){\n        cout << ans << \" \" << low-1 << endl;\n    }\n    else\n        cout << ans << \" \" << high-1 << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, X;\nvector<vector<int> > adj;\n\nint dfs(int u, int p) {\n    multiset<int> st;\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        int t = dfs(v, u);\n        if(t == -1) return -1;\n        if(t + 1 > X) return -1;\n        st.insert(t + 1);\n    }\n\n    if((p == -1) ^ (st.size() % 2)) {\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) return -1;\n            it2--;\n            st.erase(it2);\n        }\n        return st.size()? *st.begin() : 0;\n    }\n    else {\n        int chk = 0;\n        while(st.size() >= 2) {\n            multiset<int>::iterator it1 = st.end();\n            it1--;\n            int v = *it1;\n            st.erase(it1);\n\n            multiset<int>::iterator it2 = st.upper_bound(X - v);\n            if(it2 == st.begin()) {\n                if(chk) return -1;\n                chk = 1;\n                continue;\n            }\n            it2--;\n            st.erase(it2);\n        }\n\n        return st.size()? *st.begin() : 0;\n    }\n}\n\nbool f(int x) {\n    X = x;\n    return dfs(0, -1) != -1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    int a = 0;\n    for(int i = 0; i < N; i++) {\n        a += (adj[i].size() + 1) / 2 - 1;\n    }\n\n    int s = 1, e = N, b;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(f(m)) {\n            b = m;\n            e = m - 1;\n        }\n        else s = m + 1;\n    }\n    printf(\"%d %d\", 1 + a, b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nvector<vi> e;\nint rec(int c, int p, int B){\n\tvi u;\n\tfor(int i : e[c]) if(i != p) u.pb(rec(i, c, B));\n\tsort(all(u));\n\t\n\tauto calc = [&](){\n\t\tassert(u.size() % 2);\n\t\tint lo = -1, hi = u.size(), mid;\n\t\twhile(lo + 1 < hi){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = 0, j = u.size(); i + 1 < j; ){\n\t\t\t\tif(i == mid) i++;\n\t\t\t\tif(j - 1 == mid) j--;\n\t\t\t\tif(i + 1 < j && u[i++] + u[--j] > B){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\treturn hi < u.size() ? u[hi] + 1 : inf;\n\t};\n\t\n\tif(u.size() % 2) return calc();\n\t\n\tbool ok = 1;\n\trep(i, u.size() / 2) if(u[i] + u[u.size() - 1 - i] > B) ok = 0;\n\tif(ok) return 1;\n\t\n\tif(u.back() > B) return inf;\n\tu.pop_back();\n\treturn calc();\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tint A = 0;\n\trep(i, n) if(e[i].size() % 2) A++;\n\tassert(A % 2 == 0);\n\tA /= 2;\n\t\n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(rec(0, 0, mid) <= mid + 1) hi = mid;\n\t\telse lo = mid;\n\t}\n\tcout << A << \" \" << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nint dfs(Graph<int> &g, int v, int p, const int &mid) {\n  multiset<int, greater<int>> s;\n\n  for (int &nv : g[v]) {\n    if (nv != p) {\n      int val = dfs(g, nv, v, mid);\n\n      if (val == -1 || val == mid) return -1;\n\n      s.insert(val + 1);\n    }\n  }\n\n  bool odd = g[v].size() & 1;\n  int ret = 0;\n\n  while (s.size() > 1) {\n    int w = *begin(s); s.erase(s.begin());\n    auto itr = s.lower_bound(mid - w);\n\n    if (itr == s.end()) {\n      if (!odd) {\n        if (ret != 0) return -1;\n        ret = w;\n      }\n      else odd = false;\n      continue;\n    }\n\n    s.erase(itr);\n  }\n\n  if (s.empty()) return ret;\n\n  return *begin(s);\n}\n\nvoid solve() {\n  int n; cin >> n;\n  Graph<int> g(n);\n  rep1(i,n) {\n    int a, b; cin >> a >> b; --a, --b;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  int odd = 1;\n  rep(i,n) {\n    if (g[i].size() & 1) ++odd;\n  }\n\n  const int cnt = odd / 2;\n  bool even = !(g[0].size() & 1);\n\n  int l = 0, r = n;\n\n  while (r - l > 1) {\n    int mid = (l + r) / 2;\n    int ret = dfs(g, 0, -1, mid);\n    if (ret == -1 || (even && ret != 0)) l = mid;\n    else r = mid;\n  }\n\n  cout << pii(cnt, r) << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N; vector<int> G[100009];\nint solve(int pos, int pre, int lim) {\n\tvector<int> v;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tint res = solve(i, pos, lim);\n\t\tif (res == -1) return -1;\n\t\tv.push_back(res);\n\t}\n\tif (G[pos].size() % 2 == 1) v.push_back(0);\n\tsort(v.begin(), v.end());\n\tif (pre == -1) {\n\t\tfor (int i = 0; 2 * i < v.size(); i++) {\n\t\t\tif (v[i] + v[v.size() - i - 1] > lim) return -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tfor (int i = 0; 2 * i < v.size() - 1; i++) {\n\t\tif (v[i] + v[v.size() - i - 2] > lim) return -1;\n\t}\n\tfor (int i = v.size() - 1; i >= 1; i--) {\n\t\tint lp = v.size() - i - 1;\n\t\tif (lp >= i) lp++;\n\t\tif (v[i] + v[lp] > lim) return v[i] + 1;\n\t}\n\treturn v[0] + 1;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) c += G[i].size() % 2;\n\tint l = 0, r = N;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) >> 1;\n\t\tint res = solve(0, -1, m);\n\t\tif (res == -1) l = m;\n\t\telse r = m;\n\t}\n\tcout << c / 2 << ' ' << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define NFOR(i,a,b) for(int i = (int)(a); i >= (int)(b); --i)\n#define endl \"\\n\"\n#define mp make_pair\n#define X first\n#define Y second\n#define inf 1e9\n#define mod 1000000007\n#define pb push_back\n#define Case cout<<\"Case #\"<<++cas<<\": \";\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define all(v) v.begin(),v.end()\n#define sz(x) int(x.size())\n// #define lli int\ntypedef long long int lli;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vii;\ntypedef pair<lli,lli> pll;\ntypedef vector<lli> vl;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef complex <long double> complex_t;\nconst long double PI = acos((long double)-1.0);\n\n#define pr(...) dbs(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T> void dbs(string str, T t) {cerr << str << \" : \" << t << \"\\n\";}\ntemplate <class T, class... S> void dbs(string str, T t, S... s) {int idx = str.find(','); cerr << str.substr(0, idx) << \" : \" << t << \",\"; dbs(str.substr(idx + 1), s...);}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const pair<S, T>& p) {return os << \"(\" << p.first << \", \" << p.second << \")\";}\ntemplate <class T>ostream& operator <<(ostream& os, const vector<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T>ostream& operator <<(ostream& os, const set<T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class S, class T>ostream& operator <<(ostream& os, const map<S, T>& p) {os << \"[ \"; for (auto& it : p) os << it << \" \"; return os << \"]\";}\ntemplate <class T> void prc(T a, T b) {cerr << \"[\"; for (T i = a; i != b; ++i) {if (i != a) cerr << \", \"; cerr << *i;} cerr << \"]\\n\";}\n\nll dp[100010];\nbool visited[100010];\nvi Adj[100010];\nint n; \nint limitDist;\nbool flag;\n\nbool verify(int posToAvoid, vi &listOfdP) {\n    vi res;\n    FOR(i, 0, sz(listOfdP)-1) {\n        if (posToAvoid != i) {\n            res.pb(listOfdP[i]);\n        }\n    }\n    FOR(i, 0, sz(res)-1) {\n        if (res[i] + res[sz(res)-1-i] > limitDist) return false; \n    }\n    return true;\n}\n\nvoid DFS(int u, int p) {\n    dp[u] = 1e8;\n    for (auto v : Adj[u]) {\n        if (v != p) {\n            DFS(v, u);\n        }\n    }\n    vi listOfdP;\n    for (auto v : Adj[u]) {\n        if (v != p) {\n            listOfdP.pb(dp[v]);\n        }\n    }\n    if ((sz(Adj[u])-1)%2==0) {\n        listOfdP.pb(0);\n    }\n    int l1 = 0, h1 = sz(listOfdP)-1;\n    sort(all(listOfdP));\n    while ( l1 < h1) {\n        int mid = (l1 + h1)/2;\n        if (l1 + 1 == h1) {\n            if (verify(l1, listOfdP)) h1 = l1;\n            else l1 = h1;\n            break;\n        }\n        if (verify(mid, listOfdP)) {\n            h1 = mid;\n        } else {\n            l1 = mid;\n        }\n    }\n    // pr(l1, h1);\n    assert(l1 == h1);\n    if (verify(l1, listOfdP)) {\n        dp[u] = listOfdP[l1] + 1;\n    }\n    // pr(u, dp[u]);\n}\n\nbool isValid(int root, int p, int dist) {\n    FOR(i, 0, n) {\n        dp[i] = 0, visited[i] = false;\n    }\n    limitDist = dist;\n    // pr(dist);\n    DFS(root, p);\n    if (dp[root] <= dist+1) return true;\n    else return false;\n}\n\nint main() {\n    cin >> n;\n    FOR(i, 1, n-1) {\n        int a1, b1;\n        cin >> a1 >> b1;\n        Adj[a1].pb(b1), Adj[b1].pb(a1);\n    }\n    int root = -1;\n    int countOdd = 0;\n    FOR(i, 1, n) {\n        if (sz(Adj[i]) == 1) root = i;\n    }\n    FOR(i, 1, n) {\n        if (sz(Adj[i])%2 == 1) countOdd++;\n    }\n    int l = 1;\n    int h = n;\n    while (l < h) {\n        int mid = (l+h)/2;\n        if (l+1==h) {\n            if (isValid(root, 0, l)) h = l;\n            else l = h;\n            break;\n        }\n        if (isValid(root, 0, mid)) {\n            h = mid;\n        } else {\n            l = mid+1;\n        }\n    }\n    cout << countOdd/2 << \" \" << l << endl;\nreturn 0;}"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#  include <intrin.h>\n#  define __builtin_popcount __popcnt\n#endif\n\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <list>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <functional>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) os << *i << (i == end(v) - 1 ? \"\" : \" \"); return os;\n}\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v) {\n\tfor (auto i = begin(v); i != end(v); i++) is >> *i; return is;\n}\n\nvector<int> edg[101000];\n\nint dfs(int i, int max_sz, int parent = -1)\n{\n\tvector<int> arr;\n\tfor (int u : edg[i])\n\t{\n\t\tif (u == parent)\n\t\t\tcontinue;\n\t\tint add = dfs(u, max_sz, i) + 1;\n\t\tarr.push_back(add);\n\t\tif (add > max_sz)\n\t\t\tthrow 1;\n\t}\n\n\tsort(arr.begin(), arr.end());\n\tif (arr.size() % 2 == 0)\n\t{\n\t\tbool ok = true;\n\t\tfor (int i = 0, j = arr.size() - 1; i < j; i++, j--)\n\t\t{\n\t\t\tif ((arr[i] + arr[j]) > max_sz)\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok)\n\t\t\treturn 0;\n\t\tarr.pop_back();\n\t}\n\n\t{\n\t\tint left = 0, right = arr.size();\n\t\twhile (left < right)\n\t\t{\n\t\t\tint m = (left + right) / 2;\n\n\t\t\tint i = 0, j = arr.size() - 1;\n\t\t\tbool ok = true;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (i == m)\n\t\t\t\t\ti++;\n\t\t\t\tif (j == m)\n\t\t\t\t\tj--;\n\t\t\t\tif (i >= j)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (arr[i] + arr[j] > max_sz)\n\t\t\t\t\tok = false;\n\t\t\t\ti++; j--;\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tright = m;\n\t\t\telse\n\t\t\t\tleft = m + 1;\n\t\t}\n\n\t\tif (left == arr.size())\n\t\t\tthrow 1;\n\t\treturn arr[left];\n\t}\n}\n\nint main()\n{\n#if defined(_DEBUG) \n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\tcout.tie(NULL);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedg[a].push_back(b);\n\t\tedg[b].push_back(a);\n\t}\n\n\tint A = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (edg[i].size() % 2 == 1)\n\t\t\tA++;\n\t}\n\n\tA /= 2;\n\n\tint left = 0, right = n + 1;\n\twhile (left < right)\n\t{\n\t\tint m = (left + right) / 2;\n\t\ttry\n\t\t{\n\t\t\tdfs(0, m, -1);\n\t\t}\n\t\tcatch (int)\n\t\t{\n\t\t\tleft = m + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tright = m;\n\t}\n\n\tcout << A << \" \" << left;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint deg[111111];\nstruct edge\n{\n\tint to;\n\tint next;\n}e[333333];\nint pe=111111;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n\tdeg[a]++;\n}\n\n#include<set>\nstd::multiset<int> s;\nint f[111111];\nint v[111111],pv;\nbool dfs(int o,int fa,int mid)\n{\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)if(dfs(e[p].to,o,mid)==0)return 0;\n\tif(o==1)\n\t{\n\t\tpv=0;\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tv[++pv]=f[e[p].to];\n\t\tif(deg[o]&1)v[++pv]=0;\n\t\tstd::sort(v+1,v+pv+1);\n\t\tfor(register int i=1,j=pv;i<j;++i,--j)\n\t\t\tif(v[i]+v[j]>mid)return 0;\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\ts.clear();\n\t\tif(deg[o]&1)++cnt,s.insert(0);\n\t\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\t\tif(e[p].to!=fa)++cnt,s.insert(f[e[p].to]+1);\n\t\twhile(cnt>1)\n\t\t{\n\t\t\tint val=*s.rbegin();\n\t\t\ts.erase(s.find(val));\n\t\t\tstd::multiset<int>::iterator pl=s.upper_bound(mid-val);\n\t\t\tif(pl==s.begin())return 0;\n\t\t\t--pl;\n\t\t\ts.erase(pl);\n\t\t\tcnt-=2;\n\t\t}\n\t\tf[o]=*s.begin();\n\t}\n\treturn 1;\n}\nbool chk(int mid)\n{\n\treturn dfs(1,0,mid);\n}\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint x=io::F(),y=io::F();\n\t\tinsert(x,y);\n\t\tinsert(y,x);\n\t}\n\tint cc=0;\n\tfor(register int i=1;i<=n;++i)if(deg[i]&1)++cc;\n\tprintf(\"%d \",cc/2);\n\tchk(1);\n\tint ans=0;\n\tfor(register int l=1,r=n-1,mid=l+r>>1;l<=r;mid=l+r>>1)\n\t\tif(chk(mid))ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 100010;\nVI e[N];\nint a;\n\nbool good;\nint c;\n\nint dfs(int now, int past){\n    if (!good) return 0;\n    VI a;\n    for (int next : e[now]){\n        if (next == past) continue;\n        a.push_back(dfs(next, now) + 1);\n    }\n    sort(ALL(a));\n    int n = a.size();\n    REP(i,n) if (a[i] > c) good = false;\n    if (n % 2 == 0){\n        int ret = 0;\n        if (now == 0) ret = 1e9;\n        REP(i,n/2){\n            if (a[i] + a[n-1-i] > c){\n                if (ret == 0){\n                    ret = a[i];\n                }else{\n                    good = false;\n                }\n            }\n            // if (a[i] + a[n-1-i] > c) good = false;\n        }\n        // cout << \"e\" << now << good << endl;\n        return ret;\n    }\n    if (a[n-1] > c) good = false;\n    REP(i,n/2){\n        if (a[i] + a[n-2-i] > c) good = false;\n    }\n    int ok = n-1, ng = -1;\n    while (ok - ng > 1){\n        int mi = (ok + ng) / 2;\n        bool f = true;\n        REP(i,n/2){\n            int x = i;\n            if (x >= mi) x++;\n            int y = n - 1 - i;\n            if (y <= mi) y--;\n            if (a[x] + a[y] > c) f = false;\n        }\n        if (f) ok = mi;\n        else ng = mi;\n    }\n    // cout << now << \" \" << a[ok] << endl;\n    return a[ok];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--;b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n    }\n\n    REP(i,n) a += (e[i].size() % 2);\n    a = (a + 1) / 2;\n\n    int ok = n, ng = 0;\n    while (ok - ng > 1){\n        c = (ok + ng) / 2;\n        // cout << c << endl;\n        good = true;\n        dfs(0, -1);\n        if (good) ok = c;\n        else ng = c;\n    }\n\n\n    cout << a << \" \" << ok << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME \"a\"\n\nconst int MAXN = 1e5 + 10;\n\nint n;\nvi g[MAXN];\n\nbool read() {\n\tif  (scanf(\"%d\", &n) < 1) {\n\t\treturn 0;\n\t}\n\tforn(i, n) {\n\t\tg[i].clear();\n\t}\n\tforn(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn 1;\n}\n\nconst int INF = 1e9;\n\npii dp[MAXN];\n\nbool can_part(const vi& lens, int B) {\n\tassert(is_sorted(all(lens)));\n\tassert(sz(lens) % 2 == 0);\n\n\tvi left;\n\tvi right;\n\tforn(i, sz(lens)) {\n\t\tif  (i < sz(lens) / 2) {\n\t\t\tleft.pb(lens[i]);\n\t\t} else {\n\t\t\tright.pb(lens[i]);\n\t\t}\n\t}\n\n\tassert(sz(left) == sz(right));\n\n\tint l1 = 0;\n\tint r1 = sz(left) - 1;\n\tint l2 = 0;\n\tint r2 = sz(right) - 1;\n\twhile (l1 <= r1) {\n\t\tassert(r1 - l1 == r2 - l2);\n\n\t\tint ptr = l1;\n\t\twhile (ptr + 1 <= r1 && left[ptr + 1] + right[r2] <= B) {\n\t\t\t++ptr;\n\t\t}\n\n\t\tif  (left[ptr] + right[r2] > B) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tl1 = ptr + 1;\n\t\tr2 = l2 + (r1 - l1 + 1) - 1;\n\t}\n\n\treturn 1;\n}\n\nvoid dfs(int v, int p, int B) {\n\tint paths = 0;\n\tvi lens;\n\tfor (int to : g[v]) {\n\t\tif  (to == p) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(to, v, B);\n\t\t\n\t\t// eprintf(\"to=%d, dp=(%d, %d)\\n\", to, dp[to].fst, dp[to].snd);\n\n\t\tint cur_paths, cur_len;\n\t\ttie(cur_paths, cur_len) = dp[to];\n\t\tif  (cur_len > B) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\t\n\n\t\tpaths += cur_paths;\n\t\tlens.pb(cur_len);\n\t}\n\n\tpaths -= sz(lens);\n\tsort(all(lens));\n\n\t// eprintf(\"v=%d, lens:\\n\", v);\n\t// for (int len : lens) {\n\t// \teprintf(\"%d \", len);\n\t// }\n\t// eprintf(\"\\n\");\n\n\tif  (sz(lens) % 2 == 0) {\n\t\tif  (p == -1) {\n\t\t\tif  (!can_part(lens, B)) {\n\t\t\t\tdp[v] = mp(INF, INF);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdp[v] = mp(paths + sz(lens) / 2, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tif  (can_part(lens, B)) {\n\t\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, 1);\n\t\t\treturn;\t\t\t\n\t\t}\n\n\t\tvi nlens;\n\t\tfor (int i = 1; i + 1 < sz(lens); ++i) {\n\t\t\tnlens.pb(lens[i]);\n\t\t}\n\t\tif  (!can_part(nlens, B)) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\n\t\tdp[v] = mp(paths + sz(nlens) / 2 + 2, lens[0] + 1);\n\t\treturn;\n\t}\n\n\t{\n\t\tint L = -1;\n\t\tint R = sz(lens);\n\t\tint best_pos = -1;\n\t\twhile (L != R - 1) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tvi nlens;\n\t\t\tforn(i, sz(lens)) {\n\t\t\t\tif  (i != M) {\n\t\t\t\t\tnlens.pb(lens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif  (can_part(nlens, B)) {\n\t\t\t\tbest_pos = M;\n\t\t\t\tR = M;\n\t\t\t} else {\n\t\t\t\tL = M;\n\t\t\t}\n\t\t}\n\t\t// eprintf(\"v=%d, best_pos=%d\\n\", v, best_pos);\n\t\tif  (best_pos == -1) {\n\t\t\tdp[v] = mp(INF, INF);\n\t\t\treturn;\n\t\t}\n\n\t\tif  (p == -1) {\n\t\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tdp[v] = mp(paths + sz(lens) / 2 + 1, lens[best_pos] + 1);\n\t\treturn;\n\t}\n\n\tassert(0);\n}\n\nbool can(int B, int& A) {\n\tdfs(0, -1, B);\n\tif  (dp[0].snd > B) {\n\t\treturn 0;\n\t}\n\tA = dp[0].fst;\n\treturn 1;\n}\n\npii solve() {\n\t// {\n\t// \tint A;\n\t// \tcan(2, A);\n\t// \treturn mp(0, 0);\n\t// }\n\n\tint L = 0;\n\tint R = n + 1;\n\twhile (L != R - 1) {\n\t\tint M = (L + R) / 2;\n\t\tint A;\n\t\tif  (can(M, A)) {\n\t\t\tR = M;\n\t\t} else {\n\t\t\tL = M;\n\t\t}\n\t}\n\tint A;\n\tassert(can(R, A));\n\treturn mp(A, R);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME \".in\", \"r\", stdin);\n\t// freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n\twhile (read()) {\n\t\tint A, B;\n\t\ttie(A, B) = solve();\n\t\tprintf(\"%d %d\\n\", A, B);\n\t}\n\n#ifdef LOCAL\n\teprintf(\"Time: %.10f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nll N;\nvector<vll> G;\nll degree[100010];\n\nll dp[100010];\nbool dfs(ll v,ll p,const ll &x){\n  bool ret=true;\n  vll V;\n  for(ll u:G[v])if(p!=u){\n    ret &= dfs(u,v,x);\n    V.push_back(dp[u]+1);\n  }\n  if(!V.size())return ret;\n  if(!ret)return false;\n  sort(V.begin(),V.end());\n  if(V.size()&1){\n    ll low=-1,high=V.size();\n    while(high-low>1){\n      ll mid = (low+high)/2;\n      bool isok=V[mid]<=x;\n      ll l=0,r=V.size()-1;\n      for(ll i=0;i<V.size()/2;i++){\n        if(l==mid){\n          l++;\n        }\n        if(r==mid){\n          r--;\n        }\n        isok &= V[l]+V[r]<=x;\n        l++;\n        r--;\n      }\n      if(isok){\n        high = mid;\n      }else{\n        low = mid;\n      }\n    }\n    if(high==V.size()){\n      return false;\n    }\n    dp[v] = V[high];\n  }else{\n    bool isok=true;\n    ll l=0,r=V.size()-1;\n    for(ll i=0;i<V.size()/2;i++){\n      isok &= V[l]+V[r]<=x;\n      l++;\n      r--;\n    }\n    if(!isok){\n      //cerr<<\"!!\"<<endl;\n      ret &= V.back()<=x;\n      V.pop_back();\n      ll low=-1,high=V.size();\n      while(high-low>1){\n        ll mid = (low+high)/2;\n        isok=V[mid]<=x;\n        l=0,r=V.size()-1;\n        for(ll i=0;i<V.size()/2;i++){\n          if(l==mid){\n            l++;\n          }\n          if(r==mid){\n            r--;\n          }\n          isok &= V[l]+V[r]<=x;\n          l++;\n          r--;\n        }\n        if(isok){\n          high = mid;\n        }else{\n          low = mid;\n        }\n      }\n      if(high==V.size()){\n        return false;\n      }\n      dp[v] = V[high];\n    }\n  }\n  ret &= dp[v]<=x;\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll a,b;cin>>a>>b;a--;b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    degree[a]++;\n    degree[b]++;\n  }\n  int root=0;\n  ll A=0;\n  for(ll i=0;i<N;i++){\n    if(degree[i]&1){\n      A++;\n      root=i;\n    }\n  }\n  A /= 2;\n  ll low=-1,high=N;\n  while(high-low>1){\n    ll mid=(high+low)/2;\n    //debug(mid);\n    fill(dp,dp+N,0);\n    if(dfs(root,-1,mid)){\n      high = mid;\n    }else{\n      low = mid;\n    }\n    //debugArray(dp,N);\n  }\n  cout<<A<<\" \"<<high<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint N;\nvector<vector<int>> G;\nint dfs(int v,int p,int L){\n\tmultiset<int> ls,cls;\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp = dfs(u,v,L);\n\t\tif(tmp==-1) return -1;\n\t\tif(tmp>L) return -1;\n\t\tls.insert(tmp);\n\t}\n\tcls = ls;\n\tint K = ls.size();\n\tbool can = 1;\n\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\tcan = 0;\n\t\t\tbreak;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\tif(can){\n\t\tif(ls.size()==0) return 1;\n\t\telse return *ls.begin() + 1;\n\t}\n\tif(K%2==1) return -1;\n\t\n\tls = cls;\n\tls.erase(*ls.rbegin());\n\twhile(ls.size()>1){\n\t\tauto it = ls.end();\n\t\tit--;\n\t\tint a = *it;\n\t\tls.erase(it);\n\t\tit = ls.upper_bound(L-a);\n\t\tif(it==ls.begin()){\n\t\t\treturn -1;\n\t\t}\n\t\tit--;\n\t\tls.erase(it);\n\t}\n\treturn *ls.begin() + 1;\n}\nbool can(int L){\n\tint r = -1;\n\trep(i,N) if(G[i].size()==1) r = i;\n\tint tmp = dfs(r,-1,L);\n\tif(tmp==-1) return 0;\n\tif(tmp-1>L) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>N;\n\tG.resize(N);\n\trep(i,N-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tint A=0;\n\trep(v,N){\n\t\tint deg = G[v].size();\n\t\tA += deg%2;\n\t}\n\tA/=2;\n\tint ub = N-1, lb = 0;\n\twhile(ub-lb>1){\n\t\tint m = (ub+lb)/2;\n\t\tif(can(m)) ub = m;\n\t\telse lb = m;\n\t}\n\tint B = ub;\n\tcout<<A<<\" \"<<B<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n#define MN 200\n#define mod 998244353\nint n,x[MN+5],y[MN+5];\nint b[MN+5][MN+5],ans,pw[MN+5],q[MN+5],top;\nint main(){\n\tn=read();pw[0]=1;register int i,j,l,r,k;\n    for(j=1;j<=n;++j) pw[j]=2*pw[j-1]%mod;ans=(pw[n]-n-1+mod)%mod;\n    for(i=1;i<=n;++i) x[i]=read(),y[i]=read();\n    for(i=1;i<=n;++i) for(j=i+1;j<=n;++j) if(!b[i][j]){\n        q[top=1]=i;q[top=2]=j;\n        for(k=j+1;k<=n;++k) if((x[j]-x[i])*(y[k]-y[i])==(x[k]-x[i])*(y[j]-y[i])) q[++top]=k;\n        for(l=1;l<top;++l) for(r=l+1;r<=top;++r) b[q[l]][q[r]]=1;\n        ans=((ans-pw[top]+top+1)%mod+mod)%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>edge[100005];\nint n;\nint dp[2][100005];\nint lim;\nP solve2(vector<int>&v){\n\t//v is sorted\n\tint sz = v.size();\n\t//check if perfect-matching exists\n\tif(sz%2 == 0){\n\t\trep(i,sz/2){\n\t\t\tif(v[i]+v[sz-1-i] > lim) goto nxt;\n\t\t}\n\t\treturn mp(sz/2,0);\n\t}\n\tnxt:;\n\t\n\tint lb = 0, ub = sz/2+1;\n\twhile(ub-lb > 1){\n\t\tint mid = (lb+ub)/2;\n\t\trep(i,mid){\n\t\t\tif(v[i]+v[2*mid-1-i] > lim){\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tlb = mid; continue;\n\t\tfail:; ub = mid;\n\t}\n\tint max_match = lb;\n\t\n\tlb = -1, ub = v.size()-1;\n\twhile(ub-lb > 1){\n\t\tint mid = (lb+ub)/2;\n\t\tif(0 <= mid && mid <= 2*max_match-1){\n\t\t\tint L = 0, R = 2*max_match;\n\t\t\trep(a,max_match){\n\t\t\t\tif(L == mid) L++;\n\t\t\t\tif(R == mid) R--;\n\t\t\t\tassert(L < R);\n\t\t\t\tif(v[L]+v[R] > lim) goto bad;\n\t\t\t\tL++; R--;\n\t\t\t}\n\t\t\tub = mid; continue;\n\t\t\tbad:; lb = mid;\n\t\t}\n\t\telse{\n\t\t\tub = mid; continue;\n\t\t}\n\t}\n\treturn mp(sz-max_match-1, v[ub]);\n}\nvoid dfs(int v,int u){\n\tbool ex = 0;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\tex = 1; dfs(to,v);\n\t}\n\tif(!ex){\n\t\tdp[0][v] = 0;\n\t\tdp[1][v] = 0;\n\t\treturn;\n\t}\n\tint ans = 0;\n\tvector<int>path;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(to == u) continue;\n\t\tif(dp[1][to]+1 > lim){\n\t\t\t//must cut\n\t\t\tans += dp[0][to]+1;\n\t\t\tpath.pb(1);\n\t\t}\n\t\telse{\n\t\t\tans += dp[0][to];\n\t\t\tpath.pb(dp[1][to]+1);\n\t\t}\n\t}\n\tsort(path.begin(),path.end());\n\tP mn = solve2(path);\n\tans += mn.fi;\n\tdp[0][v] = ans;\n\tdp[1][v] = mn.sc;\n}\nint solve(int M){\n\tlim = M;\n\tdfs(1,-1);\n\tint ret = dp[0][1];\n\tif(dp[1][1] > 0) ret++;\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\tint ans = solve(INF);\n\tint lb = 0, ub = n;\n\twhile(ub-lb > 1){\n\t\tint mid = (lb+ub)/2;\n\t\tif(solve(mid) == ans) ub = mid;\n\t\telse lb = mid;\n\t}\n\tcout << ans << \" \" << ub << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,ans,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng;\nll t[500005],l[500005],r[500005];\nll dp[5005][5005][3];\nbool flag,dame;\n\nll solve(ll node,ll parent,ll length){\n\t//nodeを見ている\n\t//親がparent\n\t//length以下にする\n\tvector <ll> table;\n\tfor(int i=0;i<G[node].size();i++){\n\t\tif(G[node][i] == parent)continue;\n\t\tb = solve(G[node][i],node,length);\n\t\tif(b != -1){\n\t\t\ttable.pb(b);\n\t\t}\n\t}\n\tif(G[node].size() % 2 == 1)table.pb(0ll);\n\tsort(table.begin(),table.end());\n\twhile(table.size() >= 2){\n\t\ta = table.back();\n\t\ttable.pop_back();\n\t\tll de = lb(table.begin(),table.end(),length - a + 1) - table.begin();\n\t\tde--;\n\t\tif(de < 0){\n\t\t\tdame = true;\n\t\t\treturn INF;\n\t\t}\n\t\ttable.erase(table.begin() + de);\n\t}\n\tif(table.size() == 1){\n\t\treturn table[0] + 1;\n\t}else{\n\t\treturn -1;\n\t}\n}\n\n\nint main(){\n    cin >> n;\n\tfor(i=0;i<n-1;i++){\n\t\tcin >> a >> b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\ta = 0;\n\tfor(i=1;i<=n;i++){\n\t\tif(G[i].size() % 2 == 1){\n\t\t\tnum = i;\n\t\t\ta++;\n\t\t}\n\t}\n\ta /= 2;\n\tpe(a);\n\tng = 0;\n\tok = n + 10;\n\twhile(ok - ng > 1){\n\t\tll mid = (ok + ng) / 2;\n\t\t//pe(mid);\n\t\tdame = false;\n\t\tll ans = solve(num,-1,mid);\n\t\t//assert(ans == 0 || ans == INF);\n\t\t//p(ans);\n\t\tif(dame){\n\t\t\tng = mid;\n\t\t}else{\n\t\t\tok = mid;\n\t\t}\n\t}\n\tp(ok);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nmt19937 rnd(13372823);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nconst int Mod = 1e9 + 7;\n\nint bpow(int x, int y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    int ret = bpow(x, y >> 1);\n    ret = (ret * (ll)ret) % Mod;\n    if (y & 1)\n        ret = (ret * (ll)x) % Mod;\n    return ret;\n}\n\nint bdiv(int x, int y){\n    return (x * (ll)bpow(y, Mod - 2)) % Mod;\n}\n\nconst ll llinf = 1e18 + 100;\n\nconst int maxn = 1e5 + 100, inf = 2e9 + 100, sq = 300, mod = 1e9 + 7;\n\nint n;\n\nvector<int> e[maxn];\n\nint A;\n\nvoid calcA(int v, int par){\n    for (auto i : e[v])\n    if (i != par)\n        calcA(i, v);\n    int deg = e[v].size() - (par != -1);\n    if (par == -1)\n        A += (deg + 1) / 2;\n    else\n        A += deg / 2;\n}\n\nint dfs(int v, int par, int B){\n    vector<int> q;\n    q.reserve(e[v].size());\n    for (auto i : e[v])\n    if (i != par)\n        q.push_back(dfs(i, v, B) + 1);\n    sort(q.begin(), q.end());\n    if (q.empty())\n        return 0;\n    if (q[0] == 0 || q.back() > B)\n        return -1;\n    int deg = q.size();\n    if (par == -1){\n        if (deg & 1)\n            q.pop_back(), deg--;\n        for (int i = 0; i < deg / 2; i++)\n        if (q[i] + q[deg - i - 1] > B)\n            return -1;\n        return 0;\n    }\n    if (deg % 2 == 0){\n        bool is = 1;\n        for (int i = 0; i < deg / 2; i++)\n        if (q[i] + q[deg - i - 1] > B)\n            is = 0;\n        if (is)\n            return 0;\n        q.pop_back();\n        deg--;\n    }\n    vector<int> g(deg - 1);\n    int s;\n    int l = -1, r = deg;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        s = 0;\n        for (int i = 0; i < deg; i++)\n        if (i != m)\n            g[s++] = q[i];\n        bool is = 1;\n        for (int i = 0; i < deg / 2; i++)\n        if (g[i] + g[s - 1 - i] > B)\n            is = 0;\n        if (is)\n            r = m;\n        else\n            l = m;\n    }\n    if (r == deg)\n        return -1;\n    return q[r];\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    //freopen(\"trap.in\", \"r\", stdin);\n    //freopen(\"trap.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int v, u;\n        cin >> v >> u;\n        v--;\n        u--;\n        e[v].push_back(u);\n        e[u].push_back(v);\n    }\n    calcA(0, -1);\n    cout << A << ' ';\n    int l = 0, r = n;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (dfs(0, -1, m) != -1)\n            r = m;\n        else\n            l = m;\n    }\n    cout << r << '\\n';\n}\n"
  },
  {
    "language": "Text",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nint N;\nvector<int> V[MC];\nvector<int> S[MC];\nint r;\n\nbool dfs(int p , int q , int z){\n\tS[q].clear();\n\tfor(auto u : V[q]){\n\t\tif(u==p) continue;\n\t\tif(!dfs(q,u,z)) return 0;\n\t}\n\tif(S[q].size()%2==0) S[q].PB(0);\n\tsort(S[q].begin(),S[q].end());\n\tint f = 0 , g = -1;\n\tdeque<int> Q;\n\trepm(i,S[q].size()-1,-1){\n\t\twhile(f<i && S[q][f]+S[q][i]<=z){\n\t\t\tQ.push_back(S[q][f]);\n\t\t\t++f;\n\t\t}\n\t\tif(f == i){\n\t\t\tQ.push_back(S[q][f]);\n\t\t\tbreak;\n\t\t}\n\t\tif(Q.empty()){\n\t\t\tif(~g) return 0;\n\t\t\tg = S[q][i];\n\t\t} else {\n\t\t\tQ.pop_back();\n\t\t}\n\t}\n\tint w = max(Q.empty()?0:Q.front(),g);\n\tif(p>0) S[p].PB(w+1);\n\telse if(w>z) return 0;\n\treturn 1;\n}\n\nint BS(int x , int y){\n\tif(x-y<2) return x;\n\tint z = (x+y) / 2;\n\treturn dfs(-1,r,z) ? BS(z,y) : BS(x,z);\n}\n\nint main(){\n\tcin >> N;\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tint A = 1;\n\trepp(i,1,N+1){\n\t\tA += (V[i].size()-1)/2;\n\t\tif(V[i].size()==1) r = i;\n\t}\n\tcout << A << ' ' << (A==1?N-1:BS(N-1,0)) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(while (and (not (null? stack))\n\t\t\t    (<= (car stack) lp))\n\t\t       (set! stack (cdr stack)))\t\n\t\t(cond\n\t\t [(not (null? stack))\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)]\n\t\t [sp\n\t\t  (if (even? len)\n\t\t      (let-paired (cdr (vector->list vec)) lim)\n\t\t      (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t   (vector-ref vec lp)))]\n\t\t [else N])])))]\n    (pairpos 0 (- len 1) '() #t)))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired son-ret lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n(define (let-paired lst lim)\n  (letrec [(vec (sort (list->vector lst) >))\n\t   (len (length lst))\n\t   (paired (make-vector len #f))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(= lp len) -1]\n\t       [(vector-ref paired lp)\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (<= lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(and\n\t\t   (not (null? stack))\n\t\t   (= lp (car stack))\n\t\t   (null? (cdr stack)))\n\t\t  (vector-ref vec lp)]\n\t\t [(null? stack)\n\t\t  (if (and sp\n\t\t\t   (<= (vector-ref vec lp) lim))\n\t\t      (let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t(cond\n\t\t\t [(not con-ret) #f]\n\t\t\t [(odd? len) (vector-ref vec lp)]\n\t\t\t [else con-ret]))\n\t\t      #f)]\n\t\t [else\n\t\t  (when (= lp (car stack))\n\t\t\t(set! stack (cdr stack)))\n\t\t  (set! (vector-ref paired lp) #t)\n\t\t  (set! (vector-ref paired (car stack)) #t)\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)])])))\n\t   (res (pairpos 0 (- len 1) '() #t))]\n    res))\n(define (find* ele lst)\n  (cond\n   [(null? lst) #f]\n   [(eq? ele (car lst)) #t]\n   [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (remove* pa (vector-ref alledges u)))\n\t (son-ret (map (lambda (v) (check-OK? v u lim))\n\t\t       edges))]\n    (if (find* #f son-ret)\n\t#f\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  ;; (print \"u = \" u \" son-ret = \" son-ret \"pair-ret = \" pair-ret)\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      #f)))))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [(and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t(pairpos lp (- rp 1) (cons rp stack) sp)]\n\t       [(and (not (null? stack))\n\t\t     (< (car stack) lp))\n\t\t(pairpos lp lp (cdr stack) sp)]\n\t       [(not (null? stack))\n\t\t(pairpos (+ lp 1) rp (cdr stack) sp)]\n\t       [sp\n\t\t(if (even? len)\n\t\t    (let-paired (cdr (vector->list vec)) lim)\n\t\t    (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t (vector-ref vec lp)))]\n\t\t [else N])))]\n    (pairpos 0 (- len 1) '() #t)))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired son-ret lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [(and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t(pairpos lp (- rp 1) (cons rp stack) sp)]\n\t       [(and (not (null? stack))\n\t\t     (= (car stack) lp))\n\t\t(pairpos lp rp (cdr stack) sp)]\n\t       [(not (null? stack))\n\t\t(pairpos (+ lp 1) rp (cdr stack) sp)]\n\t       [sp\n\t\t(if (even? len)\n\t\t    (let-paired (cdr (vector->list vec)) lim)\n\t\t    (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t (vector-ref vec lp)))]\n\t\t [else N]])))]\n    (pairpos 0 (- len 1) '() #t)))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired son-ret lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t  (cond\n\t\t\t   [(odd? len) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       ;; [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(when (and (not (null? stack))\n\t\t\t    (= (car stack) lp))\n\t\t      (set! stack (cdr stack)))\t\n\t\t(cond\n\t\t [(not (null? stack))\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)]\n\t\t [sp\n\t\t  (if (even? len)\n\t\t      (let-paired (cdr (vector->list vec)) lim)\n\t\t      (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t   (vector-ref vec lp)))]\n\t\t [else N])])))]\n    (pairpos 0 (- len 1) '() #t)))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired son-ret lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp rest)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp rest)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (+ (vector-ref vec lp) 1) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack (even? rest) (- rest 1)))]\n\t\t\t  (cond\n\t\t\t   [(= con-ret N) N]\n\t\t\t   [(odd? rest) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp (- rest 2))\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp (- rest 2)))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t len))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t  (cond\n\t\t\t   [(odd? len) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  (<= (+ maxl 1) lim))\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(<= (* (vector-ref vec lp) 2) lim) -1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (<= lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(null? stack)\n\t\t  (if (and sp\n\t\t\t   (<= (vector-ref vec lp) lim))\n\t\t      (let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t(cond\n\t\t\t [(not con-ret) #f]\n\t\t\t [(odd? len) (vector-ref vec lp)]\n\t\t\t [else con-ret]))\n\t\t      #f)]\n\t\t [(and\n\t\t   (null? (cdr stack)))\n\t\t  (vector-ref vec lp)]\n\t\t [else\n\t\t  (if (= lp (car stack))\n\t\t      (pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t      (pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t   (res\n\t    (pairpos 0 (- len 1) '() #t))]\n    res))\n(define (find* ele lst)\n  (cond\n   [(null? lst) #f]\n   [(eq? ele (car lst)) #t]\n   [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t ;; (son-ret (map (lambda (v) (check-OK? v u lim))\n\t ;; \t       edges))\n\t (son-ret '())]\n    (while (and (not (null? edges))\n    \t\t(or (null? son-ret)\n    \t\t    (car son-ret)))\n    \t   (set! son-ret\n    \t\t (cons (check-OK? (car edges) u lim)\n    \t\t       son-ret))\n    \t   (set! edges (cdr edges)))\n    (if (find* #f son-ret)\n    \t#f\n    \t(let [(pair-ret (let-paired son-ret lim))]\n    \t  (if pair-ret\n    \t      (+ pair-ret 1)\n    \t      #f)))))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (while (and (not (null? stack))\n\t\t\t  (<= (car stack) lp))\n\t\t     (set! stack (cdr stack)))\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(not (null? stack))\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)]\n\t\t [sp\n\t\t  (if (even? len)\n\t\t      (let-paired (cdr (vector->list vec)) lim)\n\t\t      (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t   (vector-ref vec lp)))]\n\t\t [else N])])))]\n    (pairpos 0 (- len 1) '() #t)))\n;; (define (find* ele lst)\n;;   (cond\n;;    [(null? lst) #f]\n;;    [(eq? ele (car lst)) #t]\n;;    [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t ;; (son-ret (map (lambda (v)\n\t ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t ;; \t\t\t   (set! maxl (max maxl ret))\n\t ;; \t\t\t   (set! minl (min minl ret))\n\t ;; \t\t     ret))\n\t ;; \t\t edges))\n\t (son-ret '())\n\t ]\n    (while (and (not (null? edges))\n\t\t;; (<= (+ maxl 1) lim)\n\t\t)\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else\n      (let [(pair-ret (let-paired son-ret lim))]\n\t(if pair-ret\n\t    (+ pair-ret 1)\n\t    N))])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  \n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  \n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (< lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (+ (vector-ref vec lp) 1) lim))\n\t\t\t(if (even? len)\n\t\t\t    (let-paired (cdr (vector->list vec)) lim)\n\t\t\t    (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t\t (vector-ref vec lp)))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (= lp (car stack))\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl -1)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t  (cond\n\t\t\t   [(= con-ret N) N]\n\t\t\t   [(odd? len) (vector-ref vec lp)]\n\t\t\t   [else N]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack)]\n\t       [(and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t(pairpos lp (- rp 1) (cons rp stack))]\n\t       [(and (not (null? stack))\n\t\t     (= (car stack) lp))\n\t\t(if (null? (cdr stack))\n\t\t    (vector-ref vec lp)\n\t\t    (pairpos lp lp (cdr stack)))]\n\t       [(not (null? stack))\n\t\t(if (= (car stack) (- len 1))\n\t\t    (max (vector-ref vec lp) (pairpos (+ lp 1) rp (cdr stack)))\n\t\t    (pairpos (+ lp 1) rp (cdr stack)))]\n\t       [else N])))]\n    (pairpos 0 (- len 1) '())))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired (cons -1 son-ret) lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (while (and (not (null? stack))\n\t\t\t  (<= (car stack) lp))\n\t\t     (set! stack (cdr stack)))\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(not (null? stack) (pairpos (+ lp 1) rp (cdr stack) sp))]\n\t\t [sp\n\t\t  (if (even? len)\n\t\t      (let-paired (cdr (vector->list vec)) lim)\n\t\t      (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t   (vector-ref vec lp)))]\n\t\t [else N])])))])\n  (pairpos 0 (- len 1) '() #t))\n;; (define (find* ele lst)\n;;   (cond\n;;    [(null? lst) #f]\n;;    [(eq? ele (car lst)) #t]\n;;    [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t ;; (son-ret (map (lambda (v)\n\t ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t ;; \t\t\t   (set! maxl (max maxl ret))\n\t ;; \t\t\t   (set! minl (min minl ret))\n\t ;; \t\t     ret))\n\t ;; \t\t edges))\n\t (son-ret '())\n\t ]\n    (while (and (not (null? edges))\n\t\t;; (<= (+ maxl 1) lim)\n\t\t)\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else\n      (let [(pair-ret (let-paired son-ret lim))]\n\t(if pair-ret\n\t    (+ pair-ret 1)\n\t    N))])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "    (begin\n      (define N (read))\n      (define alledges (make-vector N '()))\n      (map (lambda (NO-USE)\n    \t (let [(u (- (read) 1))\n    \t       (v (- (read) 1))]\n    \t   (set! (vector-ref alledges u)\n    \t\t (cons v (vector-ref alledges u)))\n    \t   (set! (vector-ref alledges v)\n    \t\t (cons u (vector-ref alledges v)))))\n           (make-list (- N 1)))\n      (define (remove* ele lst)\n        (cond [(null? lst) lst]\n    \t  [(= ele (car lst))\n    \t   (remove* ele (cdr lst))]\n    \t  [else\n    \t   (cons (car lst)\n    \t\t (remove* ele (cdr lst)))]))\n      (define (get-fewest-paths-sons sons pa)\n        (if (null? sons)\n    \t0\n    \t(+ (get-fewest-paths (car sons) pa)\n    \t   (get-fewest-paths-sons (cdr sons) pa))))\n      \n      (define (get-fewest-paths u pa)\n        (let [(edges (remove* pa (vector-ref alledges u)))\n    \t  (deg (length (vector-ref alledges u)))]\n          (set! (vector-ref alledges u) edges)\n          (+ (if (odd? deg) 1/2 0)\n    \t (get-fewest-paths-sons edges u))))\n      \n      (define (let-paired lst lim)\n        (letrec [(vec\n    \t      (list->vector (sort lst >)))\n    \t     (len (vector-length vec))\n    \t     (pairpos\n    \t      (lambda (lp rp stack sp)\n    \t\t(cond\n    \t\t [(and (< rp lp)\n    \t\t       (null? stack))\n    \t\t  -1]\n    \t\t [(and (< rp lp)\n    \t\t       (> (car stack) lp))\n    \t\t  (pairpos (+ lp 1) rp stack sp)]\n    \t\t [else\n    \t\t  (while (and (< lp rp)\n    \t\t\t      (<= (+ (vector-ref vec lp)\n    \t\t\t\t     (vector-ref vec rp)\n    \t\t\t\t     2)\n    \t\t\t\t  lim))\n    \t\t\t (set! stack (cons rp stack))\n    \t\t\t (set! rp (- rp 1)))\n    \t\t  (cond\n    \t\t   [(null? stack)\n    \t\t    (if (and sp\n    \t\t\t     (<= (+ (vector-ref vec lp) 1) lim))\n    \t\t\t(if (even? len)\n    \t\t\t    (let-paired (cdr (vector->list vec)) lim)\n    \t\t\t    (max (pairpos (+ lp 1) rp stack #f)\n    \t\t\t\t (vector-ref vec lp)))\n    \t\t\tN)]\n    \t\t    (vector-ref vec lp)]\n    \t\t   [else\n    \t\t    (if (= lp (car stack))\n    \t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n    \t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n    \t     (res\n    \t      (pairpos 0 (- len 1) '() #t))]\n          res))\n      ;; (define (find* ele lst)\n      ;;   (cond\n      ;;    [(null? lst) #f]\n      ;;    [(eq? ele (car lst)) #t]\n      ;;    [else (find* ele (cdr lst))]))\n      (define (check-OK? u pa lim)\n        (let* [(edges (vector-ref alledges u))\n    \t   (maxl -1)\n    \t   (minl N)\n    \t   ;; (son-ret (map (lambda (v)\n    \t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n    \t   ;; \t\t\t   (set! maxl (max maxl ret))\n    \t   ;; \t\t\t   (set! minl (min minl ret))\n    \t   ;; \t\t     ret))\n    \t   ;; \t\t edges))\n    \t   (son-ret '())\n    \t   ]\n          (while (and (not (null? edges))\n          \t\t  ;; (<= (+ maxl 1) lim)\n    \t\t  )\n          \t     (set! son-ret\n          \t\t   (cons (check-OK? (car edges) u lim)\n          \t\t\t son-ret))\n          \t     (set! maxl (max maxl (car son-ret)))\n          \t     (set! minl (min minl (car son-ret)))\n          \t     (set! edges (cdr edges)))\n          (cond\n           [(> (+ maxl 1) lim) N]\n           [(< (* (+ maxl 1) 2) lim)\n           \t(if (even? (length son-ret))\n           \t    0\n           \t    (+ minl 1))]\n           [else\n    \t(let [(pair-ret (let-paired son-ret lim))]\n    \t  (if pair-ret\n    \t      (+ pair-ret 1)\n    \t      N))])))\n     \n      (define (check-OK?-lr lv rv)\n        (if (= (+ lv 1) rv)\n    \tlv\n    \t(let* [(mid (quotient (+ lv rv) 2))\n    \t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n    \t       (check-res (check-OK? 0 -1 (- mid 1)))]\n    \t  (if (and check-res\n    \t\t   (<= check-res (- mid 1)))\n    \t      (check-OK?-lr lv mid)\n    \t      (check-OK?-lr mid rv)))))\n      (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n    \t (let [(u (- (read) 1))\n    \t       (v (- (read) 1))]\n    \t   (set! (vector-ref alledges u)\n    \t\t (cons v (vector-ref alledges u)))\n    \t   (set! (vector-ref alledges v)\n    \t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n    \t  [(= ele (car lst))\n    \t   (remove* ele (cdr lst))]\n    \t  [else\n    \t   (cons (car lst)\n    \t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n    \t0\n    \t(+ (get-fewest-paths (car sons) pa)\n    \t   (get-fewest-paths-sons (cdr sons) pa))))\n  \n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n    \t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n    \t (get-fewest-paths-sons edges u))))\n  \n  (define (let-paired lst lim)\n    (letrec [(vec\n    \t      (list->vector (sort lst >)))\n    \t     (len (vector-length vec))\n    \t     (pairpos\n    \t      (lambda (lp rp stack sp)\n    \t\t(cond\n    \t\t [(and (< rp lp)\n    \t\t       (null? stack))\n    \t\t  -1]\n    \t\t [(and (< rp lp)\n    \t\t       (> (car stack) lp))\n    \t\t  (pairpos (+ lp 1) rp stack sp)]\n    \t\t [else\n    \t\t  (while (and (< lp rp)\n    \t\t\t      (<= (+ (vector-ref vec lp)\n    \t\t\t\t     (vector-ref vec rp)\n    \t\t\t\t     2)\n    \t\t\t\t  lim))\n    \t\t\t (set! stack (cons rp stack))\n    \t\t\t (set! rp (- rp 1)))\n    \t\t  (cond\n    \t\t   [(null? stack)\n    \t\t    (if (and sp\n    \t\t\t     (<= (+ (vector-ref vec lp) 1) lim))\n    \t\t\t(if (even? len)\n    \t\t\t    (let-paired (cdr (vector->list vec)) lim)\n    \t\t\t    (max (pairpos (+ lp 1) rp stack #f)\n    \t\t\t\t (vector-ref vec lp)))\n    \t\t\tN)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl -1)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n\t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n\t     (set! son-ret\n\t\t   (cons (check-OK? (car edges) u lim)\n\t\t\t son-ret))\n\t     (set! maxl (max maxl (car son-ret)))\n\t     (set! minl (min minl (car son-ret)))\n\t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n\t(if (even? (length son-ret))\n\t    0\n\t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t  (cond\n\t\t\t   [(not con-ret) #f]\n\t\t\t   [(odd? len) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\t#f)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  (define (find* ele lst)\n    (cond\n     [(null? lst) #f]\n     [(eq? ele (car lst)) #t]\n     [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   (son-ret (map (lambda (v)\n\t\t\t   (let [(ret (check-OK? v u lim))]\n\t\t\t     (when ret\n\t\t\t\t   (set! maxl (max maxl ret))\n\t\t\t\t   (set! minl (min minl ret)))\n\t\t\t     ret))\n\t\t\t edges))\n\t   ;; (son-ret '())\n\t   ]\n      ;; (while (and (not (null? edges))\n      ;; \t\t  (or (null? son-ret)\n      ;; \t\t      (car son-ret)))\n      ;; \t     (set! son-ret\n      ;; \t\t   (cons (check-OK? (car edges) u lim)\n      ;; \t\t\t son-ret))\n      ;; \t     (set! edges (cdr edges)))\n      (cond\n       [(find* #f son-ret) #f]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      #f))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [(and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t(pairpos lp (- rp 1) (cons rp stack) sp)]\n\t       [(and (not (null? stack))\n\t\t     (= (car stack) lp))\n\t\t(pairpos lp lp (cdr stack) sp)]\n\t       [(not (null? stack))\n\t\t(pairpos (+ lp 1) rp (cdr stack) sp)]\n\t       [sp\n\t\t(if (even? len)\n\t\t    (let-paired (cdr (vector->list vec)) lim)\n\t\t    (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t (vector-ref vec lp)))]\n\t       [else N])))]\n    (pairpos 0 (- len 1) '() #t)))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired son-ret lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t  (cond\n\t\t\t   [(= con-ret N) N]\n\t\t\t   [(odd? len) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp rest)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp rest)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (vector-ref vec lp) lim))\n\t\t\t(let [(con-ret (pairpos (+ lp 1) rp stack (even? rest) (- rest 1)))]\n\t\t\t  (cond\n\t\t\t   [(= con-ret N) N]\n\t\t\t   [(odd? rest) (vector-ref vec lp)]\n\t\t\t   [else con-ret]))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp (- rest 2))\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp (- rest 2)))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t len))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack)]\n\t       [(and (< lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t(pairpos lp (- rp 1) (cons rp stack))]\n\t       [(and (not (null? stack))\n\t\t     (= (car stack) lp))\n\t\t(pairpos lp lp (cdr stack))]\n\t       [(not (null? stack))\n\t\t(pairpos (+ lp 1) rp (cdr stack))]\n\t       [else N])))]\n    (pairpos 0 (- len 1) '())))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t (maxl -1)\n\t (minl N)\n\t (son-ret '())]\n    (while (and (not (null? edges))\n\t\t(<= (+ maxl 1) lim))\n\t   (set! son-ret\n\t\t (cons (check-OK? (car edges) u lim)\n\t\t       son-ret))\n\t   (set! maxl (max maxl (car son-ret)))\n\t   (set! minl (min minl (car son-ret)))\n\t   (set! edges (cdr edges)))\n    (cond\n     [(> (+ maxl 1) lim) N]\n     [(<= (* (+ maxl 1) 2) lim)\n      (if (even? (length son-ret))\n\t  0\n\t  (+ minl 1))]\n     [else (+ (let-paired (cons -1 son-ret) lim) 1)])))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(begin\n  (define N (read))\n  (define alledges (make-vector N '()))\n  (map (lambda (NO-USE)\n\t (let [(u (- (read) 1))\n\t       (v (- (read) 1))]\n\t   (set! (vector-ref alledges u)\n\t\t (cons v (vector-ref alledges u)))\n\t   (set! (vector-ref alledges v)\n\t\t (cons u (vector-ref alledges v)))))\n       (make-list (- N 1)))\n  (define (remove* ele lst)\n    (cond [(null? lst) lst]\n\t  [(= ele (car lst))\n\t   (remove* ele (cdr lst))]\n\t  [else\n\t   (cons (car lst)\n\t\t (remove* ele (cdr lst)))]))\n  (define (get-fewest-paths-sons sons pa)\n    (if (null? sons)\n\t0\n\t(+ (get-fewest-paths (car sons) pa)\n\t   (get-fewest-paths-sons (cdr sons) pa))))\n  (define (get-fewest-paths u pa)\n    (let [(edges (remove* pa (vector-ref alledges u)))\n\t  (deg (length (vector-ref alledges u)))]\n      (set! (vector-ref alledges u) edges)\n      (+ (if (odd? deg) 1/2 0)\n\t (get-fewest-paths-sons edges u))))\n  (define (let-paired lst lim)\n    (letrec [(vec\n\t      (list->vector (sort lst >)))\n\t     (len (vector-length vec))\n\t     (pairpos\n\t      (lambda (lp rp stack sp)\n\t\t(cond\n\t\t [(and (< rp lp)\n\t\t       (null? stack))\n\t\t  -1]\n\t\t [(and (< rp lp)\n\t\t       (> (car stack) lp))\n\t\t  (pairpos (+ lp 1) rp stack sp)]\n\t\t [else\n\t\t  (while (and (<= lp rp)\n\t\t\t      (<= (+ (vector-ref vec lp)\n\t\t\t\t     (vector-ref vec rp)\n\t\t\t\t     2)\n\t\t\t\t  lim))\n\t\t\t (set! stack (cons rp stack))\n\t\t\t (set! rp (- rp 1)))\n\t\t  (cond\n\t\t   [(null? stack)\n\t\t    (if (and sp\n\t\t\t     (<= (+ (vector-ref vec lp) 1) lim))\n\t\t\t(if (even? len)\n\t\t\t    (let-paired (cdr (vector->list vec)) lim)\n\t\t\t    (max (pairpos (+ lp 1) rp stack #f)\n\t\t\t\t (vector-ref vec lp)))\n\t\t\tN)]\n\t\t   [(and\n\t\t     (null? (cdr stack)))\n\t\t    (vector-ref vec lp)]\n\t\t   [else\n\t\t    (if (= lp (car stack))\n\t\t\t(pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t\t(pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t     (res\n\t      (pairpos 0 (- len 1) '() #t))]\n      res))\n  ;; (define (find* ele lst)\n  ;;   (cond\n  ;;    [(null? lst) #f]\n  ;;    [(eq? ele (car lst)) #t]\n  ;;    [else (find* ele (cdr lst))]))\n  (define (check-OK? u pa lim)\n    (let* [(edges (vector-ref alledges u))\n\t   (maxl 0)\n\t   (minl N)\n\t   ;; (son-ret (map (lambda (v)\n\t   ;; \t\t   (let [(ret (check-OK? v u lim))]\n\t   ;; \t\t\t   (set! maxl (max maxl ret))\n\t   ;; \t\t\t   (set! minl (min minl ret))\n\t   ;; \t\t     ret))\n\t   ;; \t\t edges))\n\t   (son-ret '())\n\t   ]\n      (while (and (not (null? edges))\n      \t\t  ;; (<= (+ maxl 1) lim)\n\t\t  )\n      \t     (set! son-ret\n      \t\t   (cons (check-OK? (car edges) u lim)\n      \t\t\t son-ret))\n      \t     (set! maxl (max maxl (car son-ret)))\n      \t     (set! minl (min minl (car son-ret)))\n      \t     (set! edges (cdr edges)))\n      (cond\n       [(> (+ maxl 1) lim) N]\n       [(< (* (+ maxl 1) 2) lim)\n       \t(if (even? (length son-ret))\n       \t    0\n       \t    (+ minl 1))]\n       [else\n\t(let [(pair-ret (let-paired son-ret lim))]\n\t  (if pair-ret\n\t      (+ pair-ret 1)\n\t      N))])))\n\n  (define (check-OK?-lr lv rv)\n    (if (= (+ lv 1) rv)\n\tlv\n\t(let* [(mid (quotient (+ lv rv) 2))\n\t       ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t       (check-res (check-OK? 0 -1 (- mid 1)))]\n\t  (if (and check-res\n\t\t   (<= check-res (- mid 1)))\n\t      (check-OK?-lr lv mid)\n\t      (check-OK?-lr mid rv)))))\n  (print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1))))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >)))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(and (< rp lp)\n\t\t     (null? stack))\n\t\t-1]\n\t       [(and (< rp lp)\n\t\t     (> (car stack) lp))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (<= lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(null? stack)\n\t\t  (if (and sp\n\t\t\t   (<= (vector-ref vec lp) lim))\n\t\t      (let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t(cond\n\t\t\t [(not con-ret) #f]\n\t\t\t [(odd? len) (vector-ref vec lp)]\n\t\t\t [else con-ret]))\n\t\t      #f)]\n\t\t [(and\n\t\t   (null? (cdr stack)))\n\t\t  (vector-ref vec lp)]\n\t\t [else\n\t\t  (if (= lp (car stack))\n\t\t      (pairpos (+ lp 1) rp (cddr stack) sp)\n\t\t      (pairpos (+ lp 1) rp (cdr stack) sp))])])))\n\t   (res\n\t    (pairpos 0 (- len 1) '() #t))]\n    res))\n(define (find* ele lst)\n  (cond\n   [(null? lst) #f]\n   [(eq? ele (car lst)) #t]\n   [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t ;; (son-ret (map (lambda (v) (check-OK? v u lim))\n\t ;; \t       edges))\n\t (son-ret '())]\n    (while (and (not (null? edges))\n    \t\t(or (null? son-ret)\n    \t\t    (car son-ret)))\n    \t   (set! son-ret\n    \t\t (cons (check-OK? (car edges) u lim)\n    \t\t       son-ret))\n    \t   (set! edges (cdr edges)))\n    (if (find* #f son-ret)\n    \t#f\n    \t(let [(pair-ret (let-paired son-ret lim))]\n    \t  (if pair-ret\n    \t      (+ pair-ret 1)\n    \t      #f)))))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n(define (let-paired lst lim)\n  (letrec [(vec (sort (list->vector lst) >))\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(= lp len) -1]\n\t       [(and (< rp lp)\n\t\t     (or (null? stack)\n\t\t\t (> (car stack) lp)))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (<= lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(and\n\t\t   (not (null? stack))\n\t\t   (= lp (car stack))\n\t\t   (null? (cdr stack)))\n\t\t  (vector-ref vec lp)]\n\t\t [(null? stack)\n\t\t  (if (and sp\n\t\t\t   (<= (vector-ref vec lp) lim))\n\t\t      (let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t(cond\n\t\t\t [(not con-ret) #f]\n\t\t\t [(odd? len) (vector-ref vec lp)]\n\t\t\t [else con-ret]))\n\t\t      #f)]\n\t\t [else\n\t\t  (when (= lp (car stack))\n\t\t\t(set! stack (cdr stack)))\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)])])))\n\t   (res\n\t    (pairpos 0 (- len 1) '() #t))]\n    res))\n(define (find* ele lst)\n  (cond\n   [(null? lst) #f]\n   [(eq? ele (car lst)) #t]\n   [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t ;; (son-ret (map (lambda (v) (check-OK? v u lim))\n\t ;; \t       edges))\n\t (son-ret '())]\n    (while (and (not (null? edges))\n    \t\t(or (null? son-ret)\n    \t\t    (car son-ret)))\n    \t   (set! son-ret\n    \t\t (cons (check-OK? (car edges) u lim)\n    \t\t       son-ret))\n    \t   (set! edges (cdr edges)))\n    (if (find* #f son-ret)\n    \t#f\n    \t(let [(pair-ret (let-paired son-ret lim))]\n    \t  (if pair-ret\n    \t      (+ pair-ret 1)\n    \t      #f)))))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "Scheme",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (dfs u pa)\n  (let* [(edges (remove* pa (vector-ref alledges u)))\n\t (sumc 0)\n\t (minl N)\n\t (min2 N)\n\t (maxl 0)\n\t (son-rets (map (lambda (v)\n\t\t\t  (dfs v u))\n\t\t\tedges))]\n    (map (lambda (cc)\n\t   (let [(l (cdr cc))\n\t\t (c (car cc))]\n\t     (set! sumc (+ sumc c))\n\t     (cond\n\t      [(<= (cdr cc) minl)\n\t       (set! min2 minl)\n\t       (set! minl l)]\n\t      [(<= (cdr cc) min2)\n\t       (set! min2 l)])\n\t     (set! maxl (max maxl l))))\n\t son-rets)\n    (cond [(= (length son-rets) 0)\n\t   (cons 1 0)]\n\t  [(and (= pa -1)\n\t\t(> (length son-rets) 1))\n\t   (cons (- sumc 1) (max maxl (+ minl min2 2)))]\n\t  [else\n\t   (cons sumc (max maxl (+ minl 1)))])))\n((lambda (cc) (print (car cc) \" \" (cdr cc))) (dfs 0 -1))\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n#define N\t100000\n\nunsigned int X;\n\nvoid srand_() {\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\tX = tv.tv_sec ^ tv.tv_usec;\n\tif (X % 2 == 0)\n\t\tX++;\n}\n\nint rand_() {\n\treturn (X *= 3) >> 1;\n}\n\nint *oj[N], oo[N];\n\nvoid link(int i, int j) {\n\tint o = oo[i]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\toj[i] = (int *) realloc(oj[i], o * 2 * sizeof *oj[i]);\n\toj[i][o] = j;\n}\n\nvoid sort(int *aa, int l, int r) {\n\twhile (l < r) {\n\t\tint i = l, j = l, k = r, a = aa[l + rand_() % (r - l)], tmp;\n\n\t\twhile (j < k)\n\t\t\tif (aa[j] == a)\n\t\t\t\tj++;\n\t\t\telse if (aa[j] < a) {\n\t\t\t\ttmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n\t\t\t\ti++, j++;\n\t\t\t} else {\n\t\t\t\tk--;\n\t\t\t\ttmp = aa[j], aa[j] = aa[k], aa[k] = tmp;\n\t\t\t}\n\t\tsort(aa, l, i);\n\t\tl = k;\n\t}\n}\n\nint solve(int *aa, int n, int i_, int l) {\n\tint i = 0, j = n - 1;\n\n\twhile (i < j)\n\t\tif (i == i_)\n\t\t\ti++;\n\t\telse if (j == i_)\n\t\t\tj--;\n\t\telse {\n\t\t\tif (aa[i] + aa[j] > l)\n\t\t\t\treturn 0;\n\t\t\ti++, j--;\n\t\t}\n\treturn 1;\n}\n\nint dp[N];\n\nint dfs(int p, int i, int l) {\n\tstatic int aa[N];\n\tint o, n, lower, upper;\n\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p && !dfs(i, j, l))\n\t\t\treturn 0;\n\t}\n\tn = 0;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p)\n\t\t\taa[n++] = dp[j] + 1;\n\t}\n\tsort(aa, 0, n);\n\tif (p == -1)\n\t\treturn solve(aa, n % 2 == 0 ? n : n - 1, -1, l);\n\tif (n % 2 == 0) {\n\t\tif (solve(aa, n, -1, l)) {\n\t\t\tdp[i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tn--;\n\t}\n\tlower = -1, upper = n;\n\twhile (upper - lower > 1) {\n\t\tint h = (lower + upper) / 2;\n\n\t\tif (solve(aa, n, h, l))\n\t\t\tupper = h;\n\t\telse\n\t\t\tlower = h;\n\t}\n\treturn upper < n && (dp[i] = aa[upper]) < l;\n}\n\nint main() {\n\tint n, h, i, j, k, lower, upper;\n\n\tsrand_();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\toj[i] = (int *) malloc(2 * sizeof *oj[i]);\n\tfor (h = 0; h < n - 1; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tlink(i, j), link(j, i);\n\t}\n\tk = n - 1;\n\tfor (i = 0; i < n; i++)\n\t\tk -= oo[i] / 2;\n\tlower = 0, upper = n - 1;\n\twhile (upper - lower > 1) {\n\t\tint l = (lower + upper) / 2;\n\n\t\tif (dfs(-1, 0, l))\n\t\t\tupper = l;\n\t\telse\n\t\t\tlower = l;\n\t}\n\tprintf(\"%d %d\\n\", k, upper);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n#define N\t100000\n\nunsigned int X;\n\nvoid srand_() {\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\tX = tv.tv_sec ^ tv.tv_usec;\n}\n\nint rand_() {\n\treturn (X *= 3) >> 1;\n}\n\nint *oj[N], oo[N];\n\nvoid link(int i, int j) {\n\tint o = oo[i]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\toj[i] = (int *) realloc(oj[i], o * 2 * sizeof *oj[i]);\n\toj[i][o] = j;\n}\n\nvoid sort(int *aa, int l, int r) {\n\twhile (l < r) {\n\t\tint i = l, j = l, k = r, a = aa[l + rand_() % (r - l)], tmp;\n\n\t\twhile (j < k)\n\t\t\tif (aa[j] == a)\n\t\t\t\tj++;\n\t\t\telse if (aa[j] < a) {\n\t\t\t\ttmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n\t\t\t\ti++, j++;\n\t\t\t} else {\n\t\t\t\tk--;\n\t\t\t\ttmp = aa[j], aa[j] = aa[k], aa[k] = tmp;\n\t\t\t}\n\t\tsort(aa, l, i);\n\t\tl = k;\n\t}\n}\n\nint solve(int *aa, int n, int i_, int l) {\n\tint i = 0, j = n - 1;\n\n\twhile (i < j)\n\t\tif (i == i_)\n\t\t\ti++;\n\t\telse if (j == i_)\n\t\t\tj--;\n\t\telse {\n\t\t\tif (aa[i] + aa[j] > l)\n\t\t\t\treturn 0;\n\t\t\ti++, j--;\n\t\t}\n\treturn 1;\n}\n\nint dp[N];\n\nint dfs(int p, int i, int l) {\n\tstatic int aa[N];\n\tint o, n, lower, upper;\n\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p && !dfs(i, j, l))\n\t\t\treturn 0;\n\t}\n\tn = 0;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p)\n\t\t\taa[n++] = dp[j] + 1;\n\t}\n\tsort(aa, 0, n);\n\tif (p == -1)\n\t\treturn solve(aa, n % 2 == 0 ? n : n - 1, -1, l);\n\tlower = n % 2 == 0 ? -2 : -1, upper = n;\n\twhile (upper - lower > 1) {\n\t\tint h = (lower + upper) / 2;\n\n\t\tif (solve(aa, n, h, l))\n\t\t\tupper = h;\n\t\telse\n\t\t\tlower = h;\n\t}\n\treturn upper < n && (dp[i] = upper == -1 ? 0 : aa[upper]) < l;\n}\n\nint main() {\n\tint n, h, i, j, k, lower, upper;\n\n\tsrand_();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\toj[i] = (int *) malloc(2 * sizeof *oj[i]);\n\tfor (h = 0; h < n - 1; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tlink(i, j), link(j, i);\n\t}\n\tk = n - 1;\n\tfor (i = 0; i < n; i++)\n\t\tk -= oo[i] / 2;\n\tlower = 0, upper = n - 1;\n\twhile (upper - lower > 1) {\n\t\tint l = (lower + upper) / 2;\n\n\t\tif (dfs(-1, 0, l))\n\t\t\tupper = l;\n\t\telse\n\t\t\tlower = l;\n\t}\n\tprintf(\"%d %d\\n\", k, upper);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n#define N\t100000\n\nunsigned int X;\n\nvoid srand_() {\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\tX = tv.tv_sec ^ tv.tv_usec;\n}\n\nint rand_() {\n\treturn (X *= 3) >> 1;\n}\n\nint *oj[N], oo[N];\n\nvoid link(int i, int j) {\n\tint o = oo[i]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\toj[i] = (int *) realloc(oj[i], o * 2 * sizeof *oj[i]);\n\toj[i][o] = j;\n}\n\nvoid sort(int *aa, int l, int r) {\n\twhile (l < r) {\n\t\tint i = l, j = l, k = r, a = aa[l + rand_() % (r - l)], tmp;\n\n\t\twhile (j < k)\n\t\t\tif (aa[j] == a)\n\t\t\t\tj++;\n\t\t\telse if (aa[j] < a) {\n\t\t\t\ttmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n\t\t\t\ti++, j++;\n\t\t\t} else {\n\t\t\t\tk--;\n\t\t\t\ttmp = aa[j], aa[j] = aa[k], aa[k] = tmp;\n\t\t\t}\n\t\tsort(aa, l, i);\n\t\tl = k;\n\t}\n}\n\nint solve(int *aa, int n, int i_, int l) {\n\tint i = 0, j = n - 1;\n\n\twhile (i < j)\n\t\tif (i == i_)\n\t\t\ti++;\n\t\telse if (j == i_)\n\t\t\tj--;\n\t\telse {\n\t\t\tif (aa[i] + aa[j] > l)\n\t\t\t\treturn 0;\n\t\t\ti++, j--;\n\t\t}\n\treturn 1;\n}\n\nint dp[N];\n\nint dfs(int p, int i, int l) {\n\tstatic int aa[N];\n\tint o, n, lower, upper;\n\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p && !dfs(i, j, l))\n\t\t\treturn 0;\n\t}\n\tn = 0;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p)\n\t\t\taa[n++] = dp[j] + 1;\n\t}\n\tsort(aa, 0, n);\n\tif (p == -1)\n\t\treturn solve(aa, n % 2 == 0 ? n : n - 1, -1, l);\n\tif (n % 2 == 0) {\n\t\tif (solve(aa, n, -1, l)) {\n\t\t\tdp[i] = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tn--;\n\t}\n\tlower = -1, upper = n;\n\twhile (upper - lower > 1) {\n\t\tint h = (lower + upper) / 2;\n\n\t\tif (solve(aa, n, h, l))\n\t\t\tupper = h;\n\t\telse\n\t\t\tlower = h;\n\t}\n\treturn upper < n && (dp[i] = aa[upper]) < l;\n}\n\nint main() {\n\tint n, h, i, j, k, lower, upper;\n\n\tsrand_();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++)\n\t\toj[i] = (int *) malloc(2 * sizeof *oj[i]);\n\tfor (h = 0; h < n - 1; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tlink(i, j), link(j, i);\n\t}\n\tk = n - 1;\n\tfor (i = 0; i < n; i++)\n\t\tk -= oo[i] / 2;\n\tlower = 0, upper = n - 1;\n\twhile (upper - lower > 1) {\n\t\tint l = (lower + upper) / 2;\n\n\t\tif (dfs(-1, 0, l))\n\t\t\tupper = l;\n\t\telse\n\t\t\tlower = l;\n\t}\n\tprintf(\"%d %d\\n\", k, upper);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//tree DP\n//ABC036-D\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val > ((sd*)b)->val){return -1;}\nif(((sd*)a)->val < ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    int st;\n    int fi;\n    int kr;\n}rs;\n\ntypedef struct{\n    int st;\n    int kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st == ((rs*)b)->st){return 0;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nreturn 1;\n}\n\nvoid makemkj(rs g[],mkj x[],int n){\n    int i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\nint dist[524288],par[524288];\nvoid dfs(int t,int l,int bp,rs g[],mkj x[]){\n  int i;\n  if(dist[t]<=l){return;}\n  dist[t]=l;\n  par[t]=bp;\n  for(i=x[t].st;i<x[t].st+x[t].kz;i++){\n    dfs(g[i].fi,l+1,t,g,x);\n  }\n}\n\nint judge(int arr[],int n,int border){\n  int st,fi,te,p,q;\n  st=0;fi=n-1;\n  while(st<=fi){\n    p=0;q=n-1;\n    te=(st+fi)/2;\n    if(p==te){p++;}\n    if(q==te){q--;}\n    while(p<=q){\n      if(arr[p]+arr[q]>border){\n        st=te+1;\n        break;\n      }\n      p++;q--;\n      if(p==te){p++;}\n      if(q==te){q--;}\n    }\n    if(p>q){fi=te-1;}\n  }\n  return st;\n}\n\nint main(void){\n    int i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n    int res=0;\n    int st,fi,te;\n    int cnt[524288]={0};\n    int dp[524288];\n    int arr[524288],ac;\n    rs g[524288];\n    mkj x[524288];\n    sd dat[524288];\n    scanf(\"%d\",&n);\n    for(i=0;i<(n-1);i++){\n      scanf(\"%d%d\",&a,&b);\n      cnt[a]++;cnt[b]++;\n      g[2*i].st=a;\n      g[2*i].fi=b;\n      g[2*i].kr=1;\n      g[2*i+1].st=b;\n      g[2*i+1].fi=a;\n      g[2*i+1].kr=1;\n    }\n    qsort(g,2*(n-1),sizeof(g[0]),sortfnc);\n    makemkj(g,x,2*(n-1));\n    for(i=0;i<=n;i++){\n      dp[i]=inf;\n      dist[i]=inf;\n      if(cnt[i]%2==1){r++;}\n    }\n    dfs(1,0,-1,g,x);\n    for(i=0;i<n;i++){\n      dat[i].node=i+1;\n      dat[i].val=dist[i+1];\n    }\n    qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n    st=1;fi=n-1;\n    while(st<=fi){\n      te=(st+fi)/2;\n      for(i=0;i<n;i++){\n        w=dat[i].node;\n        ac=0;\n        for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n          if(par[w]==g[j].fi){continue;}\n          arr[ac]=dp[g[j].fi]+1;\n          //printf(\"[%d]\",arr[ac]);\n          ac++;\n        }\n        if(cnt[w]%2==1){\n          arr[ac]=0;\n          //printf(\"[%d]\",arr[ac]);\n          ac++;\n        }\n        if(i==n-1){\n          arr[ac]=-inf;\n          //printf(\"[%d]\",arr[ac]);\n          ac++;\n        }\n        qsort(arr,ac,sizeof(int),sortfncsj);\n        t=judge(arr,ac,te);\n        //printf(\"\\n<%d %d %d %d>\\n\",te,w,ac,t);\n        if(i==n-1){\n          if(t==0){fi=te-1;}\n          else{st=te+1;}\n          break;\n        }\n        if(t==ac){st=te+1;break;}\n        dp[w]=arr[t];\n      }\n    }\n    printf(\"%d %d\\n\",r/2,st);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//tree DP\n//ABC036-D\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val > ((sd*)b)->val){return -1;}\nif(((sd*)a)->val < ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    int st;\n    int fi;\n    int kr;\n}rs;\n\ntypedef struct{\n    int st;\n    int kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st == ((rs*)b)->st){return 0;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nreturn 1;\n}\n\nvoid makemkj(rs g[],mkj x[],int n){\n    int i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\nint dist[524288],par[524288];\nvoid dfs(int t,int l,int bp,rs g[],mkj x[]){\n  int i;\n  if(dist[t]<=l){return;}\n  dist[t]=l;\n  par[t]=bp;\n  for(i=x[t].st;i<x[t].st+x[t].kz;i++){\n    dfs(g[i].fi,l+1,t,g,x);\n  }\n}\n\nint main(void){\n    int i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n    int res=0;\n    int cnt[524288]={0};\n    int dp[524288];\n    rs g[524288];\n    mkj x[524288];\n    sd dat[524288];\n    scanf(\"%d\",&n);\n    for(i=0;i<(n-1);i++){\n      scanf(\"%d%d\",&a,&b);\n      cnt[a]++;cnt[b]++;\n      g[2*i].st=a;\n      g[2*i].fi=b;\n      g[2*i].kr=1;\n      g[2*i+1].st=b;\n      g[2*i+1].fi=a;\n      g[2*i+1].kr=1;\n    }\n    qsort(g,2*(n-1),sizeof(g[0]),sortfnc);\n    makemkj(g,x,2*(n-1));\n    for(i=0;i<=n;i++){\n      dp[i]=inf;\n      dist[i]=inf;\n      if(cnt[i]%2==1){r++;}\n    }\n    dfs(1,0,-1,g,x);\n    for(i=0;i<n;i++){\n      dat[i].node=i+1;\n      dat[i].val=dist[i+1];\n    }\n    qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n    for(i=0;i<n;i++){\n      w=dat[i].node;\n      a=-1;b=-1;\n      for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n        if(par[w]==g[j].fi){continue;}\n        if(a<=dp[g[j].fi]){\n          b=a;a=dp[g[j].fi];\n        }\n        else if(b<=dp[g[j].fi]){b=dp[g[j].fi];}\n      }\n      if(cnt[w]%2==0){\n        if(b!=-1){\n          res=max(a+2+b,res);\n        }\n        dp[w]=a+1;\n      }\n      else{\n        if(a!=-1){\n          res=max(a+1,res);\n        }\n        dp[w]=0;\n      }\n    }\n    printf(\"%d %d\\n\",r/2,res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null st[N_MAX];\null r = 0;\nbool isok;\nsll dfs (ull v, ull p, ull start, ull var) {\n\tull len = 0;\n\tsll i;\n\tif (d[v] % 2) {\n\t\tst[start + len++] = 0;\n\t}\n\tfor (i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tif (u == p) continue;\n\n\t\tsll x = dfs(u, v, start + len, var);\n\t\tif (x == -1) return -1;\n\n\t\tx++;\n\t\tst[start + len++] = x;\n\t\t// printf(\"has %lld\\n\", x);\n\t}\n\tqsort(st + start, len, sizeof(sll), psllcomp);\n\n\t// printf(\"%llu; \", v);\n\t// for (i = 0; i < len; i++) {\n\t// \tprintf(\"%lld \", st[start + i]);\n\t// }\n\t// puts(\"\");\n\n\t// for (sll i = len - 1; i > 0; i -= 2) {\n\t// \tull cand = st[start + i] + st[start + i - 1];\n\t// \tr = umax(r, cand);\n\t// }\n\tull l = (len & ~1LL);\n\tfor (i = 0; i < l / 2; i++) {\n\t\tif (st[start + i] + st[start + (l - 1 - i)] > var) {\n\t\t\tisok = false;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsll ok = len - 1, ng = -1;\n\tif (v) {\n\t\twhile (ng + 1 < ok) {\n\t\t\tsll med = (ok + ng) / 2;\n\t\t\tfor (i = 0; i < l / 2; i++) {\n\t\t\t\tsll left = i, right = (l - 1 - i);\n\t\t\t\tif (left >= med) left++;\n\t\t\t\tif (right >= med) right++;\n\n\t\t\t\tif (st[start + left] + st[start + right] > var) break;\n\t\t\t}\n\n\t\t\tif (i == l / 2) {\n\t\t\t\tok = med;\n\t\t\t} else {\n\t\t\t\tng = med;\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"ok: %lld -> %lld\\n\", ok, st[start + ok]);\n\n\treturn st[start + ok];\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\txy[i] = (hwll){a[i], b[i]};\n\t\txy[i + (n - 1)] = (hwll){b[i], a[i]};\n\t}\n\tqsort(xy, (n - 1) * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < (n - 1) * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull odds = 0;\n\tfor (i = 0; i < n - 1; i++) {\n\t\td[a[i]]++;\n\t\td[b[i]]++;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif (d[i] % 2) odds++;\n\t}\n\n\tsll ok = n, ng = 0;\n\twhile (ng + 1 < ok) {\n\t\tsll med = (ok + ng) / 2;\n\t\tr = 0;\n\t\tisok = true;\n\t\tsll ret = dfs(0, n, 0, med);\n\t\tif (isok) {\n\t\t\tok = med;\n\t\t} else {\n\t\t\tng = med;\n\t\t}\n\t}\n\tresult = ok;\n\n\tprintf(\"%llu %llu\\n\", odds / 2, result);\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n - 1; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tint insert = dfs(dst, cur, B);\n\t\t\tif (insert > B_)\n\t\t\t\treturn insert;\n\t\t\tpnd.add(insert);\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(0);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == -1) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic class Tree {\n\t\tpublic class Edge {\n\t\t\tint to, rev;\n\n\t\t\tpublic Edge(int to, int rev) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint V;\n\t\tArrayList<ArrayList<Edge>> G;\n\t\tint root;\n\t\tint[] p;\n\t\t\n\t\tpublic Tree(int[] a, int[] b) {\n\t\t\tthis.V = a.length+1;\n\t\t\tp = new int[V];\n\t\t\t\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0; i<V; i++) {\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<V-1; i++) {\n\t\t\t\tG.get(a[i]).add(new Edge(b[i], G.get(b[i]).size()));\n\t\t\t\tG.get(b[i]).add(new Edge(a[i], G.get(a[i]).size()-1));\n\t\t\t}\n\t\t\tsetRoot(0);\n\t\t}\n\t\t\n\t\tpublic void setRoot(int root) {\n\t\t\tthis.root = root;\n\t\t\tsetRoot(root, -1);\n\t\t}\n\t\tpublic void setRoot(int cur, int parent) {\n\t\t\tp[cur] = parent;\n\t\t\tfor(int i=0; i<G.get(cur).size(); i++) {\n\t\t\t\tint next = G.get(cur).get(i).to;\n\t\t\t\tif(next!=parent) {\n\t\t\t\t\tsetRoot(next, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic int countPath() {\n\t\t\tint ans = 0;\n\t\t\tfor(ArrayList<Edge> node : G) {\n\t\t\t\tans += node.size()%2;\n\t\t\t}\n\t\t\treturn ans/2;\n\t\t}\n\t\t\n\t\tpublic boolean check(int B) {\n\t\t\tif(G.get(root).size()%2==0)\n\t\t\t\treturn dp(root, B)==0;\n\t\t\telse\n\t\t\t\treturn dp(root, B)<=B;\n\t\t}\n\t\t\n\t\tint dp(int cur, int B) {\n\t\t\tArrayList<Integer> dp = new ArrayList<>();\n\t\t\tfor(int i=0; i<G.get(cur).size(); i++) {\n\t\t\t\tint next = G.get(cur).get(i).to;\n\t\t\t\tif(next!=p[cur]) {\n\t\t\t\t\tdp.add(dp(next, B)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(dp);\n\t\t\tif(dp.size()>0 && dp.get(dp.size()-1)>B)\n\t\t\t\treturn B+1;\n\n\t\t\tif(dp.size()%2==0) {\n\t\t\t\tif(validatePairing(dp, B, -1)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tdp.remove(dp.size()-1);\n\t\t\t\t\treturn leaveShortestPath(dp, B);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn leaveShortestPath(dp, B);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaveShortestPath(ArrayList<Integer> v, int B) {\n\t\t\tint N = v.size();\n\t\t\tint min = -1;\n\t\t\tint max = N;\n\t\t\twhile(min+1<max) {\n\t\t\t\tint skip = (min+max)/2;\n\t\t\t\tif(validatePairing(v, B, skip))\n\t\t\t\t\tmax = skip;\n\t\t\t\telse\n\t\t\t\t\tmin = skip;\n\t\t\t}\n\t\t\tif(max<N)\n\t\t\t\treturn v.get(max);\n\t\t\telse\n\t\t\t\treturn B+1;\n\t\t}\n\t\t\n\t\tboolean validatePairing(ArrayList<Integer> v, int B, int skip) {\n\t\t\tfor(int i=0,j=v.size()-1; i<j; i++,j--) {\n\t\t\t\tif(i==skip)\n\t\t\t\t\ti++;\n\t\t\t\tif(j==skip)\n\t\t\t\t\tj--;\n\t\t\t\tif(v.get(i) + v.get(j) > B)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N-1];\n\t\tint[] b = new int[N-1];\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\ta[i] = sc.nextInt()-1;\n\t\t\tb[i] = sc.nextInt()-1;\n\t\t}\n\t\tTree tree = new Tree(a, b);\n\t\t\n\t\tint A = tree.countPath();\n\t\tint min = 0;\n\t\tint max = N-1;\n\t\twhile(min+1 < max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tif(tree.check(mid))\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid;\n\t\t}\n\t\t\n\t\tSystem.out.println(A + \" \" + max);\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tint insert = dfs(dst, cur, B_);\n\t\t\tif (insert > B_)\n\t\t\t\treturn insert;\n\t\t\tpnd.add(insert);\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(B_ - 1);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == pnd.size()) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc088;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        graph = buildGraph(in, n, n-1);\n\n        gto = new int[n][];\n        tmpto = new int[n][];\n        dfs0(0, -1);\n\n        int A = dfsA(0, -1, 0);\n\n        int min = 0;   // NG\n        int max = n+1; // OK\n        while (max - min > 1) {\n            int med = (max + min) / 2;\n            if (isOK(med)) {\n                max = med;\n            } else {\n                min = med;\n            }\n        }\n        out.println(String.format(\"%d %d\", A, max));\n        out.flush();\n    }\n\n    static int[][] graph;\n    static int[][] gto;\n    static int maxB;\n\n    static void dfs0(int now, int par) {\n        int ci = 0;\n        gto[now] = new int[graph[now].length - (par == -1 ? 0 : 1)];\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            gto[now][ci++] = to;\n            dfs0(to, now);\n        }\n        tmpto[now] = new int[gto[now].length];\n    }\n\n    static int[][] tmpto;\n    static boolean ng;\n\n    static boolean isOK(int length) {\n        ng = false;\n        maxB = length;\n        int a = dfsB(0);\n        return !ng && a <= maxB;\n    }\n\n    static int dfsB(int now) {\n        int cn = gto[now].length;\n        if (cn == 0) {\n            return 1;\n        }\n\n        int ci = 0;\n        int[] tmp = tmpto[now];\n        for (int to : gto[now]) {\n            tmp[ci++] = dfsB(to);\n        }\n        Arrays.sort(tmp);\n\n        if (cn % 2 == 0) {\n            boolean ok = true;\n            for (int i = 0 ; i < cn / 2 ; i++) {\n                ok &= tmp[i] + tmp[cn-1-i] <= maxB;\n            }\n            if (ok) {\n                return 1;\n            }\n            if (now == 0) {\n                ng = true;\n                return maxB+10;\n            }\n            cn--;\n        }\n\n        int d = now == 0 ? 0 : 1;\n        if (tmp[cn-1]+d > maxB) {\n            ng = true;\n            return maxB+10;\n        }\n\n        int ok = cn;\n        int ng = -1;\n        int[] tmp2 = new int[cn-1];\n        while (ok - ng > 1) {\n            int med = (ok + ng) / 2;\n            int ti = 0;\n            for (int i = 0; i < cn ; i++) {\n                if (i == med) {\n                    continue;\n                }\n                tmp2[ti++] = tmp[i];\n            }\n            boolean isng = false;\n            for (int i = 0 ; i < ti / 2 ; i++) {\n                if (tmp2[i] + tmp2[ti-1-i] > maxB) {\n                    isng = true;\n                    break;\n                }\n            }\n            if (isng) {\n                ng = med;\n            } else {\n                ok = med;\n            }\n        }\n        if (ok == cn) {\n            return maxB+10;\n        }\n        return tmp[ok] + (now == 0 ? 0 : 1);\n    }\n\n    static int dfsA(int now, int par, int flg) {\n        int cn = 0;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            cn++;\n        }\n        int A = (cn+(flg^1))/2;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            A += dfsA(to, now, 1);\n        }\n        return A;\n    }\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic class Tree {\n\t\tpublic class Edge {\n\t\t\tint to, rev;\n\n\t\t\tpublic Edge(int to, int rev) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint V;\n\t\tArrayList<ArrayList<Edge>> G;\n\t\tint root;\n\t\tint[] p;\n\t\t\n\t\tpublic Tree(int[] a, int[] b) {\n\t\t\tthis.V = a.length+1;\n\t\t\tp = new int[V];\n\t\t\t\n\t\t\tG = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0; i<V; i++) {\n\t\t\t\tG.add(new ArrayList<Edge>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<V-1; i++) {\n\t\t\t\tG.get(a[i]).add(new Edge(b[i], G.get(b[i]).size()));\n\t\t\t\tG.get(b[i]).add(new Edge(a[i], G.get(a[i]).size()-1));\n\t\t\t}\n\t\t\tsetRoot(0);\n\t\t}\n\t\t\n\t\tpublic void setRoot(int root) {\n\t\t\tthis.root = root;\n\t\t\tsetRoot(root, -1);\n\t\t}\n\t\tpublic void setRoot(int cur, int parent) {\n\t\t\tp[cur] = parent;\n\t\t\tfor(int i=0; i<G.get(cur).size(); i++) {\n\t\t\t\tint next = G.get(cur).get(i).to;\n\t\t\t\tif(next!=parent) {\n\t\t\t\t\tsetRoot(next, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic int countPath() {\n\t\t\tint ans = 0;\n\t\t\tfor(ArrayList<Edge> node : G) {\n\t\t\t\tans += node.size()%2;\n\t\t\t}\n\t\t\treturn ans/2;\n\t\t}\n\t\t\n\t\tpublic boolean check(int B) {\n\t\t\treturn dp(root, B)<=B;\n\t\t}\n\t\t\n\t\tint dp(int cur, int B) {\n\t\t\tArrayList<Integer> dp = new ArrayList<>();\n\t\t\tfor(int i=0; i<G.get(cur).size(); i++) {\n\t\t\t\tint next = G.get(cur).get(i).to;\n\t\t\t\tif(next!=p[cur]) {\n\t\t\t\t\tdp.add(dp(next, B)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(dp);\n\t\t\tif(dp.size()>0 && dp.get(dp.size()-1)>B)\n\t\t\t\treturn B+1;\n\n\t\t\tif(dp.size()%2==0) {\n\t\t\t\tif(validatePairing(dp, B, -1)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tdp.remove(dp.size()-1);\n\t\t\t\t\treturn leaveShortestPath(dp, B);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn leaveShortestPath(dp, B);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaveShortestPath(ArrayList<Integer> v, int B) {\n\t\t\tint N = v.size();\n\t\t\tint min = -1;\n\t\t\tint max = N;\n\t\t\twhile(min+1<max) {\n\t\t\t\tint skip = (min+max)/2;\n\t\t\t\tif(validatePairing(v, B, skip))\n\t\t\t\t\tmax = skip;\n\t\t\t\telse\n\t\t\t\t\tmin = skip;\n\t\t\t}\n\t\t\tif(max<N)\n\t\t\t\treturn v.get(max);\n\t\t\telse\n\t\t\t\treturn B+1;\n\t\t}\n\t\t\n\t\tboolean validatePairing(ArrayList<Integer> v, int B, int skip) {\n\t\t\tfor(int i=0,j=v.size()-1; i<j; i++,j--) {\n\t\t\t\tif(i==skip)\n\t\t\t\t\ti++;\n\t\t\t\tif(j==skip)\n\t\t\t\t\tj--;\n\t\t\t\tif(v.get(i) + v.get(j) > B)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N-1];\n\t\tint[] b = new int[N-1];\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\ta[i] = sc.nextInt()-1;\n\t\t\tb[i] = sc.nextInt()-1;\n\t\t}\n\t\tTree tree = new Tree(a, b);\n\t\t\n\t\tint A = tree.countPath();\n\t\tint min = 0;\n\t\tint max = N-1;\n\t\twhile(min+1 < max) {\n\t\t\tint mid = (min+max)/2;\n\t\t\tif(tree.check(mid))\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\tmin = mid;\n\t\t}\n\t\t\n\t\tSystem.out.println(A + \" \" + max);\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tint insert = dfs(dst, cur, B_);\n\t\t\tif (insert > B_)\n\t\t\t\treturn insert;\n\t\t\tpnd.add(insert);\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(0);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == -1) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = Integer.parseInt(sc.next());\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tint insert = dfs(dst, cur, B_);\n\t\t\tif (insert > B_)\n\t\t\t\treturn insert;\n\t\t\tpnd.add(insert);\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(B_ - 1);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == pnd.size()) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[][] graph = buildGraph(in, n, n-1);\n\n        out.println(solve(graph));\n        out.flush();\n    }\n\n    private static String solve(int[][] _graph) {\n        graph = _graph;\n        n = graph.length;\n\n        int a = 1;\n        for (int i = 0; i < n ; i++) {\n            a += (graph[i].length - 1) / 2;\n        }\n\n        for (int i = 0; i < n ; i++) {\n            if (graph[i].length == 1) {\n                root = i;\n            }\n        }\n\n        int minB = 0;\n        int maxB = n+10;\n        while (maxB - minB > 1) {\n            int med = (minB + maxB) / 2;\n            if (isOK(med)) {\n                maxB = med;\n            } else {\n                minB = med;\n            }\n        }\n        return String.format(\"%d %d\", a, maxB);\n    }\n\n    private static boolean isOK(int med) {\n        limit = med;\n        // debug(root, med, dfs(root, -1));\n        return dfs(root, -1) <= limit;\n    }\n\n    static int dfs(int now, int par) {\n        List<Integer> ln = new ArrayList<>();\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            ln.add(dfs(to, now));\n        }\n        Collections.sort(ln);\n        if (ln.size() == 0) {\n            return 1;\n        } else if (ln.size() == 1) {\n            if (now == root) {\n                return ln.get(0);\n            }\n            return ln.get(0) + 1;\n        } else if (ln.get(ln.size()-1) > limit) {\n            return limit+100;\n        }\n\n        if (ln.size() % 2 == 0) {\n            if (canMakePair(ln, -1, limit)) {\n                return 1;\n            } else {\n                ln.remove(ln.size()-1);\n            }\n        }\n\n        if (!canMakePair(ln, ln.size()-1, limit)) {\n            return limit+100;\n        }\n\n        int ok = ln.size()-1;\n        int ng = -1;\n        while (ok - ng > 1) {\n            int med = (ok + ng) / 2;\n            if (canMakePair(ln, med, limit)) {\n                ok = med;\n            } else {\n                ng = med;\n            }\n        }\n        return ln.get(ok)+1;\n    }\n\n    static boolean canMakePair(List<Integer> list, int ignoreIndex, int limit) {\n        int n = list.size();\n        int l = 0;\n        int r = n-1;\n        while (l <= r) {\n            if (l == ignoreIndex) {\n                l++;\n                continue;\n            }\n            if (r == ignoreIndex) {\n                r--;\n                continue;\n            }\n            int ls = list.get(l);\n            int rs = list.get(r);\n            if (l == r) {\n                if (ls > limit) {\n                    return false;\n                }\n            } else if (ls + rs > limit) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n\n    static int n;\n    static int[][] graph;\n    static int limit;\n    static int root;\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FChristmasTree solver = new FChristmasTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FChristmasTree {\n        boolean valid;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            for (int i = 0; i < n - 1; i++) {\n                Node a = nodes[in.readInt() - 1];\n                Node b = nodes[in.readInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n\n            for (int i = 0; i < n; i++) {\n                nodes[i].children = new IntegerList(nodes[i].adj.size());\n            }\n\n            int A = blockNeed(nodes[0], null);\n\n            IntBinarySearch ibs = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    valid = true;\n                    dfs(nodes[0], null, mid);\n                    return valid;\n                }\n            };\n\n            int B = ibs.binarySearch(0, n);\n\n            out.append(A).append(' ').append(B);\n        }\n\n        public int blockNeed(Node root, Node p) {\n            int child = 0;\n            int ans = 0;\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                child++;\n                ans += blockNeed(node, root);\n            }\n            ans += child / 2;\n            if (child % 2 == 1 && p == null) {\n                ans++;\n            }\n            root.odd = p == null && child % 2 == 1 || p != null && child % 2 == 0;\n            return ans;\n        }\n\n        public int dfs(Node root, Node p, int limit) {\n            root.children.clear();\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                root.children.add(dfs(node, root, limit) + 1);\n            }\n            root.children.sort();\n            int[] data = root.children.getData();\n            int n = root.children.size();\n            if (root.odd && n > 0) {\n                if (data[n - 1] > limit) {\n                    valid = false;\n                }\n                n--;\n            }\n\n            int l = n;\n            for (int i = n - 1; i >= 1; i--) {\n                if (data[i] == -1) {\n                    continue;\n                }\n                l = Math.min(l, i - 1);\n                while (l >= 0 && (data[l] == -1 || data[l] + data[i] > limit)) {\n                    l--;\n                }\n                if (l < 0) {\n                    break;\n                }\n                data[l] = -1;\n                data[i] = -1;\n            }\n\n            int ret = 0;\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (data[i] != -1) {\n                    cnt++;\n                    ret = data[i];\n                }\n            }\n\n            if (cnt > 1) {\n                valid = false;\n            }\n\n            if (ret > limit) {\n                valid = false;\n            }\n            return ret;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int average(int a, int b) {\n            int ans = (a / 2) + (b / 2);\n            switch (a % 2 + b % 2) {\n                case 2:\n                    ans++;\n                    break;\n                case -1:\n                case -2:\n                    ans--;\n                    break;\n            }\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static abstract class IntBinarySearch {\n        public abstract boolean check(int mid);\n\n        public int binarySearch(int l, int r) {\n            if (l > r) {\n                throw new IllegalArgumentException();\n            }\n            while (l < r) {\n                int mid = DigitUtils.average(l, r);\n                if (check(mid)) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return l;\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        IntegerList children;\n        int id;\n        boolean odd;\n\n        public String toString() {\n            return \"\" + (id + 1);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int[][] graph = buildGraph(in, n, n-1);\n\n        out.println(solve(graph));\n        out.flush();\n    }\n\n    private static String solve(int[][] _graph) {\n        graph = _graph;\n        n = graph.length;\n\n        int a = 1;\n        for (int i = 0; i < n ; i++) {\n            a += (graph[i].length - 1) / 2;\n        }\n\n        for (int i = 0; i < n ; i++) {\n            if (graph[i].length == 1) {\n                root = i;\n            }\n        }\n\n        int minB = 0;\n        int maxB = n+10;\n        while (maxB - minB > 1) {\n            int med = (minB + maxB) / 2;\n            if (isOK(med)) {\n                maxB = med;\n            } else {\n                minB = med;\n            }\n        }\n        return String.format(\"%d %d\", a, maxB);\n    }\n\n    private static boolean isOK(int med) {\n        limit = med;\n        // debug(root, med, dfs(root, -1));\n        return dfs(root, -1) <= limit;\n    }\n\n    static int dfs(int now, int par) {\n        List<Integer> ln = new ArrayList<>();\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            ln.add(dfs(to, now));\n        }\n        Collections.sort(ln);\n        if (ln.size() == 0) {\n            return 1;\n        } else if (ln.size() == 1) {\n            if (now == root) {\n                return ln.get(0);\n            }\n            return ln.get(0) + 1;\n        } else if (ln.get(ln.size()-1) > limit) {\n            return limit+100;\n        }\n\n        if (ln.size() % 2 == 0) {\n            if (canMakePair(ln, -1, limit)) {\n                return 1;\n            } else {\n                ln.remove(ln.size()-1);\n            }\n        }\n\n        if (!canMakePair(ln, ln.size()-1, limit)) {\n            return limit+100;\n        }\n\n        int ok = ln.size()-1;\n        int ng = 0;\n        while (ok - ng > 1) {\n            int med = (ok + ng) / 2;\n            if (canMakePair(ln, med, limit)) {\n                ok = med;\n            } else {\n                ng = med;\n            }\n        }\n        return ln.get(ok)+1;\n    }\n\n    static boolean canMakePair(List<Integer> list, int ignoreIndex, int limit) {\n        int n = list.size();\n        int l = 0;\n        int r = n-1;\n        while (l <= r) {\n            if (l == ignoreIndex) {\n                l++;\n                continue;\n            }\n            if (r == ignoreIndex) {\n                r--;\n                continue;\n            }\n            int ls = list.get(l);\n            int rs = list.get(r);\n            if (l == r) {\n                if (ls > limit) {\n                    return false;\n                }\n            } else if (ls + rs > limit) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n\n    static int n;\n    static int[][] graph;\n    static int limit;\n    static int root;\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tpnd.add(dfs(dst, cur, B_));\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(0);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == -1) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.AbstractMap;\nimport java.util.TreeMap;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FChristmasTree solver = new FChristmasTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FChristmasTree {\n        Debug debug = new Debug(false);\n        boolean valid;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            for (int i = 0; i < n - 1; i++) {\n                Node a = nodes[in.readInt() - 1];\n                Node b = nodes[in.readInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n\n            for (int i = 0; i < n; i++) {\n                nodes[i].children = new IntegerList(nodes[i].adj.size());\n            }\n\n            int A = blockNeed(nodes[0], null);\n\n            IntBinarySearch ibs = new IntBinarySearch() {\n\n                public boolean check(int mid) {\n                    valid = true;\n                    dfs(nodes[0], null, mid);\n                    return valid;\n                }\n            };\n\n            int B = ibs.binarySearch(0, n);\n\n            out.append(A).append(' ').append(B);\n        }\n\n        public int blockNeed(Node root, Node p) {\n            int child = 0;\n            int ans = 0;\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                child++;\n                ans += blockNeed(node, root);\n            }\n            ans += child / 2;\n            if (child % 2 == 1 && p == null) {\n                ans++;\n            }\n            root.odd = p == null && child % 2 == 1 || p != null && child % 2 == 0;\n            return ans;\n        }\n\n        private void add(TreeMap<Integer, Integer> map, Integer key) {\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n\n        private void remove(TreeMap<Integer, Integer> map, Integer key) {\n            int cnt = map.get(key);\n            cnt--;\n            if (cnt > 0) {\n                map.put(key, cnt);\n            } else {\n                map.remove(key);\n            }\n        }\n\n        public int dfs(Node root, Node p, int limit) {\n            if (!valid) {\n                return 0;\n            }\n\n            root.children.clear();\n            for (Node node : root.adj) {\n                if (node == p) {\n                    continue;\n                }\n                root.children.add(dfs(node, root, limit) + 1);\n            }\n\n            if (!valid) {\n                return 0;\n            }\n            root.children.sort();\n            int[] data = root.children.getData();\n            int n = root.children.size();\n\n            debug.debug(\"root\", root);\n            //special\n            if (root.odd && p != null) {\n                int l = 0;\n                int r = n - 1;\n                boolean skip = true;\n                while (l < r && skip) {\n                    if (data[l] + data[r] > limit) {\n                        skip = false;\n                    }\n                    l++;\n                    r--;\n                }\n\n                if (skip) {\n                    return 0;\n                }\n            }\n\n            if (root.odd && n > 0) {\n                if (data[n - 1] > limit) {\n                    valid = false;\n                    return 0;\n                }\n                n--;\n            }\n\n            TreeMap<Integer, Integer> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                add(map, data[i]);\n            }\n\n            Integer ret = null;\n            while (!map.isEmpty()) {\n                Integer max = map.lastKey();\n                remove(map, max);\n                Integer floor = map.floorKey(limit - max);\n                if (floor == null) {\n                    if (ret == null) {\n                        ret = max;\n                        continue;\n                    }\n                    valid = false;\n                    return 0;\n                }\n                remove(map, floor);\n            }\n            return ret == null ? 0 : ret;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int average(int a, int b) {\n            int ans = (a / 2) + (b / 2);\n            switch (a % 2 + b % 2) {\n                case 2:\n                    ans++;\n                    break;\n                case -1:\n                case -2:\n                    ans--;\n                    break;\n            }\n            return ans;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        IntegerList children;\n        int id;\n        boolean odd;\n\n        public String toString() {\n            return \"\" + (id + 1);\n        }\n\n    }\n\n    static abstract class IntBinarySearch {\n        public abstract boolean check(int mid);\n\n        public int binarySearch(int l, int r) {\n            if (l > r) {\n                throw new IllegalArgumentException();\n            }\n            while (l < r) {\n                int mid = DigitUtils.average(l, r);\n                if (check(mid)) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return l;\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tint pr = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpr += g[i].length&1;\n\t\t}\n\t\tout.print(pr/2 + \" \");\n\t\tint low = 0, high = n+10;\n\t\tint[] temp = new int[n];\n\t\tinner:\n\t\twhile(high - low > 1){\n\t\t\tint h = high+low>>1;\n\t\t\tint[] dp = new int[n];\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tint cur = ord[i];\n\t\t\t\tint p = 0;\n\t\t\t\tif(g[cur].length % 2 == 1){\n\t\t\t\t\ttemp[p++] = 0;\n\t\t\t\t}\n\t\t\t\tfor(int e : g[cur]){\n\t\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\t\tif(dp[e] != -1)temp[p++] = dp[e] - dep[cur];\n\t\t\t\t}\n\t\t\t\tint res = go(Arrays.copyOf(temp, p), h);\n\t\t\t\t\n\t\t\t\tif(res == -1){\n\t\t\t\t\tlow = h;\n\t\t\t\t\tcontinue inner;\n\t\t\t\t}\n\t\t\t\tdp[cur] = p % 2 == 0 ? -1 : res + dep[cur];\n\t\t\t}\n\t\t\thigh = h;\n\t\t}\n\t\tout.println(high);\n\t}\n\t\n\tstatic int go(int[] a, int h)\n\t{\n\t\tint n = a.length;\n\t\tArrays.sort(a);\n\t\tif(n % 2 == 0){\n\t\t\tfor(int i = 0, j = n-1;i < j;i++,j--){\n\t\t\t\tif(a[i] + a[j] > h)return -1;\n\t\t\t}\n\t\t\treturn -2;\n\t\t}else{\n\t\t\tfor(int i = 0, j = n-2;i < j;i++,j--){\n\t\t\t\tif(a[i] + a[j] > h)return -1;\n\t\t\t}\n\t\t\tint ok = n-1;\n\t\t\tfor(int j = n-2;j >= 0;j--){\n\t\t\t\tif(j >= n/2){\n\t\t\t\t\tif(a[n-2-j] + a[j+1] > h)return a[ok];\n\t\t\t\t}else{\n\t\t\t\t\tif(a[j+1] + a[n-j-1] > h)return a[ok];\n\t\t\t\t}\n\t\t\t\tok--;\n\t\t\t}\n\t\t\treturn a[0];\n\t\t}\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tint insert = dfs(dst, cur, B_);\n\t\t\tif (insert > B_)\n\t\t\t\treturn insert;\n\t\t\tpnd.add(insert);\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(0);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == pnd.size()) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main {\n\n\tArrayList<Integer>[] g;\n\tint[] deg;\n\tint n;\n\tint[] a, b;\n\tint A, B;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ta = new int[n - 1];\n\t\tb = new int[n - 1];\n\t\tdeg = new int[n];\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\t++deg[a[i]];\n\t\t\t++deg[b[i]];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tg[b[i]].add(a[i]);\n\t\t}\n\t\tA = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] % 2 == 1)\n\t\t\t\t++A;\n\t\t}\n\t\tA /= 2;\n\t\tint ok = n - 1;\n\t\tint ng = 0;\n\t\twhile (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tif (check(middle)) {\n\t\t\t\tok = middle;\n\t\t\t} else {\n\t\t\t\tng = middle;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(A + \" \" + ok);\n\t\tsc.close();\n\t}\n\n\tboolean check(int B_) {\n\t\tint p = dfs(0, -1, B_);\n\t\tif (p <= B_)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tint dfs(int cur, int par, int B_) {\n\t\tArrayList<Integer> pnd = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par)\n\t\t\t\tcontinue;\n\t\t\tpnd.add(dfs(dst, cur, B_));\n\t\t}\n\t\tif (deg[cur] % 2 == 1)\n\t\t\tpnd.add(0);\n\t\tif (cur == 0)\n\t\t\tpnd.add(0);\n\t\tCollections.sort(pnd);\n\t\tint ng = -1;\n\t\tint ok = pnd.size();\n\t\tloop1: while (ok - ng > 1) {\n\t\t\tint middle = (ok + ng) / 2;\n\t\t\tint s = 0;\n\t\t\tint t = pnd.size() - 1;\n\t\t\tif (s == middle)\n\t\t\t\t++s;\n\t\t\tif (t == middle)\n\t\t\t\t--t;\n\t\t\twhile (t - s > 0) {\n\t\t\t\tif (pnd.get(s) + pnd.get(t) > B_) {\n\t\t\t\t\tng = middle;\n\t\t\t\t\tcontinue loop1;\n\t\t\t\t}\n\t\t\t\t++s;\n\t\t\t\t--t;\n\t\t\t\tif (s == middle)\n\t\t\t\t\t++s;\n\t\t\t\tif (t == middle)\n\t\t\t\t\t--t;\n\t\t\t}\n\t\t\tok = middle;\n\t\t}\n\t\tif (ok == -1) {\n\t\t\treturn B_ + 1;\n\t\t}\n\t\treturn pnd.get(ok) + 1;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc088;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        graph = buildGraph(in, n, n-1);\n\n        gto = new int[n][];\n        tmpto = new int[n][];\n        dfs0(0, -1);\n\n        int A = dfsA(0, -1, 0);\n\n        int min = 0;   // NG\n        int max = n+1; // OK\n        while (max - min > 1) {\n            int med = (max + min) / 2;\n            if (isOK(med)) {\n                max = med;\n            } else {\n                min = med;\n            }\n        }\n        out.println(String.format(\"%d %d\", A, max));\n        out.flush();\n    }\n\n    static int[][] graph;\n    static int[][] gto;\n    static int maxB;\n\n    static void dfs0(int now, int par) {\n        int ci = 0;\n        gto[now] = new int[graph[now].length - (par == -1 ? 0 : 1)];\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            gto[now][ci++] = to;\n            dfs0(to, now);\n        }\n        tmpto[now] = new int[gto[now].length];\n    }\n\n    static int[][] tmpto;\n    static boolean ng;\n\n    static boolean isOK(int length) {\n        ng = false;\n        maxB = length;\n        int a = dfsB(0);\n        return !ng && a <= maxB;\n    }\n\n    static int dfsB(int now) {\n        int cn = gto[now].length;\n        if (cn == 0) {\n            return 1;\n        }\n\n        int ci = 0;\n        int[] tmp = tmpto[now];\n        for (int to : gto[now]) {\n            tmp[ci++] = dfsB(to);\n        }\n        Arrays.sort(tmp);\n\n        if (cn % 2 == 0) {\n            boolean ok = true;\n            for (int i = 0 ; i < cn / 2 ; i++) {\n                ok &= tmp[i] + tmp[cn-1-i] <= maxB;\n            }\n            if (ok) {\n                return 1;\n            }\n            if (now == 0) {\n                ng = true;\n                return maxB+10;\n            }\n            cn--;\n        }\n\n        int d = now == 0 ? 0 : 1;\n        if (tmp[cn-1]+d > maxB) {\n            ng = true;\n            return maxB+10;\n        }\n\n        int ok = cn-1;\n        int ng = -1;\n        int[] tmp2 = new int[cn-1];\n        while (ok - ng > 1) {\n            int med = (ok + ng) / 2;\n            int ti = 0;\n            for (int i = 0; i < cn ; i++) {\n                if (i == med) {\n                    continue;\n                }\n                tmp2[ti++] = tmp[i];\n            }\n            boolean isng = false;\n            for (int i = 0 ; i < ti / 2 ; i++) {\n                if (tmp2[i] + tmp2[ti-1-i] > maxB) {\n                    isng = true;\n                    break;\n                }\n            }\n            if (isng) {\n                ng = med;\n            } else {\n                ok = med;\n            }\n        }\n        return tmp[ok] + (now == 0 ? 0 : 1);\n    }\n\n    static int dfsA(int now, int par, int flg) {\n        int cn = 0;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            cn++;\n        }\n        int A = (cn+(flg^1))/2;\n        for (int to : graph[now]) {\n            if (to == par) {\n                continue;\n            }\n            A += dfsA(to, now, 1);\n        }\n        return A;\n    }\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        int n;\n        List<int>[] G;\n        int need;\n        void solve() {\n            var l = 0; var r = n;\n            while (r - l > 1) {\n                var m = (l + r) / 2;\n                Debug.WriteLine($\"try {m}\");\n                if (f(m)) r = m;\n                else l = m;\n            }\n            Console.WriteLine($\"{need} {r}\");\n        }\n        bool g(List<int> a, int k, int x) {\n            var cnt = a.Count / 2;\n            for (int i = 0, j = a.Count - 1; cnt > 0; i++, j--, cnt--) {\n                if (i == k) i++;\n                if (j == k) j--;\n                if (a[i] + a[j] > x) return false;\n            }\n            return true;\n        }\n        Func<int, bool> f;\n        public void Solve() {\n            n = ri;\n            G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(n - 1)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            var root = Enumerable.Range(0, n).First(x => G[x].Count == 1);\n            need = 1;\n            foreach (var i in Rep(n))\n                need += (Math.Max(0, G[i].Count - 2) + 1) / 2;\n            var ord = new List<int>();\n            var par = new int[n];\n            {\n                var vis = new bool[n];\n                var q = new Queue<int>();\n                q.Enqueue(root);\n                while (q.Any()) {\n                    var p = q.Dequeue();\n                    vis[p] = true;\n                    ord.Add(p);\n                    foreach (var t in G[p]) {\n                        if (vis[t]) continue;\n                        q.Enqueue(t);\n                        par[t] = p;\n                    }\n                }\n            }\n            Debug.WriteLine($\"root: {root}\");\n            var V = Enumerate(n, x => new List<int>(G[x].Count));\n            var dp = new int[n];\n\n            f = x => {\n                var ok = true;\n                foreach (var c in RRep(n)) {\n                    var cur = ord[c];\n                    var v = V[cur];\n                    v.Clear();\n                    foreach (var t in G[cur]) {\n                        if (t != par[cur]) v.Add(dp[t] + 1);\n                    }\n                    v.Sort();\n                    if (v.Count % 2 == 0) {\n                        var flag = true;\n                        for (int i = 0, j = v.Count - 1; i < j; i++, j--)\n                            flag &= v[i] + v[j] <= x;\n                        if (flag) { dp[cur] = 0; continue; } else {\n                            ok &= v[v.Count - 1] <= x;\n                            v.RemoveAt(v.Count - 1);\n                        }\n                    }\n                    if (!g(v, v.Count - 1, x)) { ok = false; return false; }\n                    var l = -1; var r = v.Count - 1;\n                    while (r - l > 1) {\n                        var m = (l + r) / 2;\n                        if (g(v, m, x)) r = m;\n                        else l = m;\n\n                    }\n                    dp[cur] = v[r];\n                }\n                return dp[0] <= x && ok;\n            };\n\n            solve();\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        // int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            // s = i + 2;\n            // t = r.Next(i + 1) + 1;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        int ok = n - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) < M) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a >= M) return M;\n            lis.Add(a + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 0;\n            }\n            else return M;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        // int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            // s = i + 2;\n            // t = r.Next(i + 1) + 1;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        if (a == 1) {\n            DBG(a, n - 1);\n            return;\n        }\n        int dis;\n        int p = calclongest(0, out dis);\n        p = calclongest(p, out dis);\n        int ok = Math.Min(dis, n - 1 - a + 1), ng = (n - 2) / a;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) <= m) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int calclongest(int p, out int d) {\n        int n = edge.Length;\n        var dis = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            dis[i] = M;\n        }\n        dis[p] = 0;\n        var q = new Queue<int>();\n        q.Enqueue(p);\n        while (q.Any())\n        {\n            int pp = q.Dequeue();\n            foreach (var item in edge[pp])\n            {\n                if (dis[item] == M) {\n                    dis[item] = dis[pp] + 1;\n                    q.Enqueue(item);\n                }\n            }\n        }\n        int max = 0, maxid = p;\n        for (int i = 0; i < n; i++)\n        {\n            if (max < dis[i]) {\n                max = dis[i];\n                maxid = i;\n            }\n        }\n         d = max;\n        return maxid;\n    }\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a > k) return k + 1;\n            lis.Add(a + 1);\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return k + 1;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        int n;\n        List<int>[] G;\n        int need;\n        void solve() {\n            var l = 0; var r = n;\n            while (r - l > 1) {\n                var m = (l + r) / 2;\n                Debug.WriteLine($\"try {m}\");\n                if (f(m)) r = m;\n                else l = m;\n            }\n            Console.WriteLine($\"{need} {r}\");\n        }\n        bool g(List<int> a, int k, int x) {\n            var cnt = a.Count / 2;\n            for (int i = 0, j = a.Count - 1; cnt > 0; i++, j--, cnt--) {\n                if (i == k) i++;\n                if (j == k) j--;\n                if (a[i] + a[j] > x) return false;\n            }\n            return true;\n        }\n        Func<int, bool> f;\n        public void Solve() {\n            n = ri;\n            G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(n - 1)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            var root = Enumerable.Range(0, n).First(x => G[x].Count == 1);\n            need = 1;\n            foreach (var i in Rep(n))\n                need += (Math.Max(0, G[i].Count - 2) + 1) / 2;\n            var ord = new List<int>();\n            var par = Enumerate(n, x => -1);\n            {\n                var vis = new bool[n];\n                var q = new Queue<int>();\n                q.Enqueue(root);\n                while (q.Any()) {\n                    var p = q.Dequeue();\n                    vis[p] = true;\n                    ord.Add(p);\n                    foreach (var t in G[p]) {\n                        if (vis[t]) continue;\n                        q.Enqueue(t);\n                        par[t] = p;\n                    }\n                }\n            }\n            Debug.WriteLine($\"root: {root}\");\n            var V = Enumerate(n, x => new List<int>(G[x].Count));\n            var dp = new int[n];\n\n            f = x => {\n                var ok = true;\n                foreach (var c in RRep(n)) {\n                    var cur = ord[c];\n                    var v = V[cur];\n                    v.Clear();\n                    foreach (var t in G[cur]) {\n                        if (t != par[cur]) v.Add(dp[t] + 1);\n                    }\n                    v.Sort();\n                    if (v.Count % 2 == 0) {\n                        var flag = true;\n                        for (int i = 0, j = v.Count - 1; i < j; i++, j--)\n                            flag &= v[i] + v[j] <= x;\n                        if (flag) { dp[cur] = 0; continue; } else {\n                            ok &= v[v.Count - 1] <= x;\n                            v.RemoveAt(v.Count - 1);\n                        }\n                    }\n                    if (!g(v, v.Count - 1, x)) { ok = false; return false; }\n                    var l = -1; var r = v.Count - 1;\n                    while (r - l > 1) {\n                        var m = (l + r) / 2;\n                        if (g(v, m, x)) r = m;\n                        else l = m;\n\n                    }\n                    dp[cur] = v[r];\n                }\n                return dp[root] <= x && ok;\n            };\n\n            solve();\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        int ok = n - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) == 1) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            lis.Add(dfs(item, p, k) + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 1;\n            }\n            else return 0;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        // int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            // s = i + 2;\n            // t = r.Next(i + 1) + 1;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        if (a == 1) {\n            DBG(a, n - 1);\n            return;\n        }\n        int dis;\n        int p = calclongest(0, out dis);\n        p = calclongest(p, out dis);\n        int ok = Math.Min(dis, n - 1 - a + 1), ng = (n - 2) / a;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) < M) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int calclongest(int p, out int d) {\n        int n = edge.Length;\n        var dis = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            dis[i] = M;\n        }\n        dis[p] = 0;\n        var q = new Queue<int>();\n        q.Enqueue(p);\n        while (q.Any())\n        {\n            int pp = q.Dequeue();\n            foreach (var item in edge[pp])\n            {\n                if (dis[item] == M) {\n                    dis[item] = dis[pp] + 1;\n                    q.Enqueue(item);\n                }\n            }\n        }\n        int max = 0, maxid = p;\n        for (int i = 0; i < n; i++)\n        {\n            if (max < dis[i]) {\n                max = dis[i];\n                maxid = i;\n            }\n        }\n         d = max;\n        return maxid;\n    }\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a >= M) return M;\n            lis.Add(a + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 0;\n            }\n            else return M;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        // int n = sc.Int;\n        int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            s = i + 2;\n            t = r.Next(i + 1) + 1;\n            // sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        int ok = n - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) < M) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a >= M) return M;\n            lis.Add(a + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 0;\n            }\n            else return M;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        // int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            // s = i + 2;\n            // t = r.Next(i + 1) + 1;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        if (a == 1) {\n            DBG(a, n - 1);\n            return;\n        }\n        int dis;\n        int p = calclongest(0, out dis);\n        p = calclongest(p, out dis);\n        int ok = Math.Min(dis, n - 1 - a + 1), ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) < M) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int calclongest(int p, out int d) {\n        int n = edge.Length;\n        var dis = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            dis[i] = M;\n        }\n        dis[p] = 0;\n        var q = new Queue<int>();\n        q.Enqueue(p);\n        while (q.Any())\n        {\n            int pp = q.Dequeue();\n            foreach (var item in edge[pp])\n            {\n                if (dis[item] == M) {\n                    dis[item] = dis[pp] + 1;\n                    q.Enqueue(item);\n                }\n            }\n        }\n        int max = 0, maxid = p;\n        for (int i = 0; i < n; i++)\n        {\n            if (max < dis[i]) {\n                max = dis[i];\n                maxid = i;\n            }\n        }\n         d = max;\n        return maxid;\n    }\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a >= M) return M;\n            lis.Add(a + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 0;\n            }\n            else return M;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        int n;\n        List<int>[] G;\n        int need;\n        void solve() {\n            var l = 0; var r = n;\n            while (r - l > 1) {\n                var m = (l + r) / 2;\n                Debug.WriteLine($\"try {m}\");\n                if (f(m)) r = m;\n                else l = m;\n            }\n            Console.WriteLine($\"{need} {r}\");\n        }\n        bool g(List<int> a, int k, int x) {\n            var cnt = a.Count / 2;\n            for (int i = 0, j = a.Count - 1; cnt > 0; i++, j--, cnt--) {\n                if (i == k) i++;\n                if (j == k) j--;\n                if (a[i] + a[j] > x) return false;\n            }\n            return true;\n        }\n        Func<int, bool> f;\n        public void Solve() {\n            n = ri;\n            G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(n - 1)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            var root = Enumerable.Range(0, n).First(x => G[x].Count == 1);\n            need = 1;\n            foreach (var i in Rep(n))\n                need += (Math.Max(0, G[i].Count - 2) + 1) / 2;\n            var ord = new List<int>();\n            var par = new int[n];\n            {\n                var vis = new bool[n];\n                var q = new Queue<int>();\n                q.Enqueue(root);\n                while (q.Any()) {\n                    var p = q.Dequeue();\n                    vis[p] = true;\n                    ord.Add(p);\n                    foreach (var t in G[p]) {\n                        if (vis[t]) continue;\n                        q.Enqueue(t);\n                        par[t] = p;\n                    }\n                }\n            }\n            Debug.WriteLine($\"root: {root}\");\n            var V = Enumerate(n, x => new List<int>(G[x].Count));\n            var dp = new int[n];\n\n            f = x => {\n                var ok = true;\n                foreach (var cur in RRep(n)) {\n                    var v = V[cur];\n                    v.Clear();\n                    foreach (var t in G[cur]) {\n                        if (t != par[cur]) v.Add(dp[t] + 1);\n                    }\n                    v.Sort();\n                    if (v.Count % 2 == 0) {\n                        var flag = true;\n                        for (int i = 0, j = v.Count - 1; i < j; i++, j--)\n                            flag &= v[i] + v[j] <= x;\n                        if (flag) { dp[cur] = 0; continue; } else {\n                            ok &= v[v.Count - 1] <= x;\n                            v.RemoveAt(v.Count - 1);\n                        }\n                    }\n                    if (!g(v, v.Count - 1, x)) { ok = false; return false; }\n                    var l = -1; var r = v.Count - 1;\n                    while (r - l > 1) {\n                        var m = (l + r) / 2;\n                        if (g(v, m, x)) r = m;\n                        else l = m;\n\n                    }\n                    dp[cur] = v[r];\n                }\n                return dp[root] <= x && ok;\n            };\n\n            solve();\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n = sc.Int;\n        // int n = 100000;\n        edge = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<int>();\n        }\n        var r = new Random();\n        for (int i = 0; i < n - 1; i++)\n        {\n            int s, t;\n            // s = i + 2;\n            // t = r.Next(i + 1) + 1;\n            sc.Multi(out s, out t);\n            --s;\n            --t;\n            edge[s].Add(t);\n            edge[t].Add(s);\n        }\n        int a = 1;\n        for (int i = 0; i < n; i++)\n        {\n            a += (edge[i].Count + 1) / 2 - 1;\n        }\n        int dis;\n        int p = calclongest(0, out dis);\n        p = calclongest(p, out dis);\n        int ok = dis, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (dfs(0, -1, m) < M) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        Prt(a, ok);\n        sw.Flush();\n    }\n    static List<int>[] edge;\n    static int calclongest(int p, out int d) {\n        int n = edge.Length;\n        var dis = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            dis[i] = M;\n        }\n        dis[p] = 0;\n        var q = new Queue<int>();\n        q.Enqueue(p);\n        while (q.Any())\n        {\n            int pp = q.Dequeue();\n            foreach (var item in edge[pp])\n            {\n                if (dis[item] == M) {\n                    dis[item] = dis[pp] + 1;\n                    q.Enqueue(item);\n                }\n            }\n        }\n        int max = 0, maxid = p;\n        for (int i = 0; i < n; i++)\n        {\n            if (max < dis[i]) {\n                max = dis[i];\n                maxid = i;\n            }\n        }\n         d = max;\n        return maxid;\n    }\n    static int dfs(int p, int par, int k) {\n        var lis = new List<int>();\n        foreach (var item in edge[p])\n        {\n            if (item == par) continue;\n            int a = dfs(item, p, k);\n            if (a >= M) return M;\n            lis.Add(a + 1);\n        }\n        if (p == 0) {\n            if (lis.Count % 2 == 1) lis.Add(0);\n            if (isok(lis, -1, k)) {\n                return 0;\n            }\n            else return M;\n        }\n        if (lis.Count % 2 == 0) lis.Add(0);\n        lis.Sort();\n        if (isok(lis, 0, k)) {\n            return lis[0];\n        }\n        if (!isok(lis, lis.Count - 1, k)) {\n            return M;\n        }\n        int ok = lis.Count - 1, ng = 0;\n        while (ng < ok - 1)\n        {\n            int m = (ok + ng) / 2;\n            if (isok(lis, m, k)) {\n                ok = m;\n            }\n            else ng = m;\n        }\n        return lis[ok];\n    }\n    static bool isok(List<int> l, int rem, int k) {\n        int j = l.Count - 1;\n        for (int i = 0; i < l.Count; i++)\n        {\n            if (i == rem) ++i;\n            if (j == rem) --j;\n            if (i >= j) return true;\n            if (l[i] + l[j] > k) return false;\n            --j;\n        }\n        throw new Exception();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        int n;\n        List<int>[] G;\n        int need;\n        void solve() {\n            var l = 0; var r = n;\n            while (r - l > 1) {\n                var m = (l + r) / 2;\n                Debug.WriteLine($\"try {m}\");\n                if (f(m)) r = m;\n                else l = m;\n            }\n            Console.WriteLine($\"{need} {r}\");\n        }\n        bool g(List<int> a, int k, int x) {\n            var cnt = a.Count / 2;\n            for (int i = 0, j = a.Count - 1; cnt > 0; i++, j--, cnt--) {\n                if (i == k) i++;\n                if (j == k) j--;\n                if (a[i] + a[j] > x) return false;\n            }\n            return true;\n        }\n        Func<int, bool> f;\n        public void Solve() {\n            n = ri;\n            G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(n - 1)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            var root = Enumerable.Range(0, n).First(x => G[x].Count == 1);\n            need = 1;\n            foreach (var i in Rep(n))\n                need += (Math.Max(0, G[i].Count - 2) + 1) / 2;\n\n            Debug.WriteLine($\"root: {root}\");\n            f = x => {\n                Func<int, int, int> dfs = null;\n                var ok = true;\n                dfs = (prev, cur) => {\n                    var v = new List<int>();\n                    foreach (var t in G[cur]) {\n                        if (t != prev) v.Add(dfs(cur, t) + 1);\n                    }\n                    v.Sort();\n                    Debug.WriteLine($\"{cur}: {v.AsJoinedString()}\");\n                    if (v.Count % 2 == 0) {\n                        var flag = true;\n                        for (int i = 0, j = v.Count - 1; i < j; i++, j--)\n                            flag &= v[i] + v[j] <= x;\n                        if (flag) return 0;\n                        else {\n                            ok &= v[v.Count - 1] <= x;\n                            v.RemoveAt(v.Count - 1);\n                        }\n                    }\n                    if (!g(v, v.Count - 1, x)) { ok = false; return 0; }\n                    var l = -1; var r = v.Count - 1;\n                    while (r - l > 1) {\n                        var m = (l + r) / 2;\n                        if (g(v, m, x)) r = m;\n                        else l = m;\n\n                    }\n                    return v[r];\n                };\n                return dfs(-1, root) <= x && ok;\n            };\n\n            solve();\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        int n;\n        List<int>[] G;\n        int need;\n        void solve() {\n            var l = 0; var r = n;\n            while (r - l > 1) {\n                var m = (l + r) / 2;\n                Debug.WriteLine($\"try {m}\");\n                if (f(m)) r = m;\n                else l = m;\n            }\n            Console.WriteLine($\"{need} {r}\");\n        }\n        bool g(List<int> a, int k, int x) {\n            var cnt = a.Count / 2;\n            for (int i = 0, j = a.Count - 1; cnt > 0; i++, j--, cnt--) {\n                if (i == k) i++;\n                if (j == k) j--;\n                if (a[i] + a[j] > x) return false;\n            }\n            return true;\n        }\n        Func<int, bool> f;\n        public void Solve() {\n            n = ri;\n            G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(n - 1)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n            }\n            var root = Enumerable.Range(0, n).First(x => G[x].Count == 1);\n            need = 1;\n            foreach (var i in Rep(n))\n                need += (Math.Max(0, G[i].Count - 2) + 1) / 2;\n            var ord = new List<int>();\n            var par = Enumerate(n, x => -1);\n            {\n                var vis = new bool[n];\n                var q = new Queue<int>();\n                q.Enqueue(root);\n                while (q.Any()) {\n                    var p = q.Dequeue();\n                    vis[p] = true;\n                    ord.Add(p);\n                    foreach (var t in G[p]) {\n                        if (vis[t]) continue;\n                        q.Enqueue(t);\n                        par[t] = p;\n                    }\n                }\n            }\n            Debug.WriteLine($\"root: {root}\");\n            var V = Enumerate(n, x => new List<int>(G[x].Count));\n            var dp = new int[n];\n\n            f = x => {\n                var ok = true;\n                foreach (var c in RRep(n)) {\n                    var cur = ord[c];\n                    var v = V[cur];\n                    v.Clear();\n                    foreach (var t in G[cur]) {\n                        if (t != par[cur]) v.Add(dp[t] + 1);\n                    }\n                    v.Sort();\n                    if (v.Count % 2 == 0) {\n                        var flag = true;\n                        for (int i = 0, j = v.Count - 1; i < j; i++, j--)\n                            flag &= v[i] + v[j] <= x;\n                        if (flag) { dp[cur] = 0; continue; } else {\n                            ok &= v[v.Count - 1] <= x;\n                            v.RemoveAt(v.Count - 1);\n                        }\n                    }\n                    if (!g(v, v.Count - 1, x)) { ok = false; return false; }\n                    var l = -1; var r = v.Count - 1;\n                    while (r - l > 1) {\n                        var m = (l + r) / 2;\n                        if (g(v, m, x)) r = m;\n                        else l = m;\n\n                    }\n                    dp[cur] = v[r];\n                }\n                return dp[0] <= x && ok;\n            };\n\n            solve();\n\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Lisp",
    "code": "(define N (read))\n(define alledges (make-vector N '()))\n(map (lambda (NO-USE)\n       (let [(u (- (read) 1))\n\t     (v (- (read) 1))]\n\t (set! (vector-ref alledges u)\n\t       (cons v (vector-ref alledges u)))\n\t (set! (vector-ref alledges v)\n\t       (cons u (vector-ref alledges v)))))\n     (make-list (- N 1)))\n(define (remove* ele lst)\n  (cond [(null? lst) lst]\n\t[(= ele (car lst))\n\t (remove* ele (cdr lst))]\n\t[else\n\t (cons (car lst)\n\t       (remove* ele (cdr lst)))]))\n(define (get-fewest-paths-sons sons pa)\n  (if (null? sons)\n      0\n      (+ (get-fewest-paths (car sons) pa)\n\t (get-fewest-paths-sons (cdr sons) pa))))\n(define (get-fewest-paths u pa)\n  (let [(edges (remove* pa (vector-ref alledges u)))\n\t(deg (length (vector-ref alledges u)))]\n    (set! (vector-ref alledges u) edges)\n    (+ (if (odd? deg) 1/2 0)\n       (get-fewest-paths-sons edges u))))\n(define (let-paired lst lim)\n  (letrec [(vec\n\t    (list->vector (sort lst >))\n\t    ;; (list->vector lst)\n\t    )\n\t   (len (vector-length vec))\n\t   (pairpos\n\t    (lambda (lp rp stack sp)\n\t      (cond\n\t       [(= lp len) -1]\n\t       [(and (< rp lp)\n\t\t     (or (null? stack)\n\t\t\t (> (car stack) lp)))\n\t\t(pairpos (+ lp 1) rp stack sp)]\n\t       [else\n\t\t(while (and (<= lp rp)\n\t\t\t    (<= (+ (vector-ref vec lp)\n\t\t\t\t   (vector-ref vec rp)\n\t\t\t\t   2)\n\t\t\t\tlim))\n\t\t       (set! stack (cons rp stack))\n\t\t       (set! rp (- rp 1)))\n\t\t(cond\n\t\t [(and\n\t\t   (not (null? stack))\n\t\t   (= lp (car stack))\n\t\t   (null? (cdr stack)))\n\t\t  (vector-ref vec lp)]\n\t\t [(null? stack)\n\t\t  (if (and sp\n\t\t\t   (<= (vector-ref vec lp) lim))\n\t\t      (let [(con-ret (pairpos (+ lp 1) rp stack #f))]\n\t\t\t(cond\n\t\t\t [(not con-ret) #f]\n\t\t\t [(odd? len) (vector-ref vec lp)]\n\t\t\t [else con-ret]))\n\t\t      #f)]\n\t\t [else\n\t\t  (when (= lp (car stack))\n\t\t\t(set! stack (cdr stack)))\n\t\t  (pairpos (+ lp 1) rp (cdr stack) sp)])])))\n\t   (res\n\t    (pairpos 0 (- len 1) '() #t))]\n    res))\n(define (find* ele lst)\n  (cond\n   [(null? lst) #f]\n   [(eq? ele (car lst)) #t]\n   [else (find* ele (cdr lst))]))\n(define (check-OK? u pa lim)\n  (let* [(edges (vector-ref alledges u))\n\t ;; (son-ret (map (lambda (v) (check-OK? v u lim))\n\t ;; \t       edges))\n\t (son-ret '())]\n    (while (and (not (null? edges))\n    \t\t(or (null? son-ret)\n    \t\t    (car son-ret)))\n    \t   (set! son-ret\n    \t\t (cons (check-OK? (car edges) u lim)\n    \t\t       son-ret))\n    \t   (set! edges (cdr edges)))\n    (if (find* #f son-ret)\n    \t#f\n    \t(let [(pair-ret (let-paired son-ret lim))]\n    \t  (if pair-ret\n    \t      (+ pair-ret 1)\n    \t      #f)))))\n\n(define (check-OK?-lr lv rv)\n  (if (= (+ lv 1) rv)\n      lv\n      (let* [(mid (quotient (+ lv rv) 2))\n\t     ;; (NO-USE (print \"check-OK?-lr \" (- mid 1)))\n\t     (check-res (check-OK? 0 -1 (- mid 1)))]\n\t(if (and check-res\n\t\t (<= check-res (- mid 1)))\n\t    (check-OK?-lr lv mid)\n\t    (check-OK?-lr mid rv)))))\n(print (get-fewest-paths 0 -1) \" \" (check-OK?-lr 0 (+ N 1)))\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.algorithm;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int X = n-1;\n    foreach (i; 0..n-1) {\n        X -= g[i].length.to!int / 2;\n    }\n\n    bool calc(int md) {\n        //md以下可能？\n//        writeln(\"START \", md);\n        bool ok = true;\n        int dfs(int p, int b) {\n            int m = g[p].length.to!int;\n            if (b != -1) m--;\n            int[] vs = new int[m];\n            int vsCnt = 0;\n            foreach (d; g[p]) {\n                if (d == b) continue;\n                vs[vsCnt++] = dfs(d, p) + 1;\n            }\n            vs.sort!\"a<b\";\n//            writeln(p+1, \" \", b+1, \" \", vs);\n            if (m % 2 == 0) {\n                //even\n                bool f = true;\n                foreach (i; 0..m/2) {\n                    if (vs[i] + vs[m-1-i] > md) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return 0;\n                if (vs[$-1] > md) {\n                    ok = false;\n                    return 0;\n                }\n                vs = vs[0..$-1];\n                m--;\n            }\n            //odd\n            int dw = -1, up = m;\n            while (up-dw > 1) {\n                int md2 = (dw+up)/2;\n                bool f = true;\n                int l = 0, r = m-1;\n                foreach (i; 0..m/2) {\n                    if (l == md2) l++;\n                    if (r == md2) r--;\n                    if (vs[l] + vs[r] > md) {\n                        f = false;\n                        break;\n                    }\n                    l++; r--;\n                }\n                if (!f) {\n                    dw = md2;\n                } else {\n                    up = md2;\n                }\n            }\n            if (up == m) {\n                ok = false;\n                return 0;\n            }\n            return vs[up];       \n        }\n        if (dfs(0, -1) > md) {\n            ok = false;\n        }\n        return ok;\n    }\n\n    int Y = binSearch!(md => calc(md))(0, n-1);\n    writeln(X, \" \", Y);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.algorithm;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int X = n-1;\n    foreach (i; 0..n) {\n        X -= g[i].length.to!int / 2;\n    }\n\n    int r = -1;\n    foreach (i; 0..n) {\n        if (g[i].length == 1) {\n            r = i;\n            break;\n        }\n    }\n\n    bool calc(int md) {\n        //md以下可能？\n//        writeln(\"START \", md);\n        bool ok = true;\n        int dfs(int p, int b) {\n            int m = g[p].length.to!int;\n            if (b != -1) m--;\n            int[] vs = new int[m];\n            int vsCnt = 0;\n            foreach (d; g[p]) {\n                if (d == b) continue;\n                vs[vsCnt++] = dfs(d, p) + 1;\n            }\n            vs.sort!\"a<b\";\n            if (vs.length && vs[$-1] > md) {\n                ok = false;\n                return 0;\n            }\n//            writeln(p+1, \" \", b+1, \" \", vs);\n            if (m % 2 == 0) {\n                //even\n                bool f = true;\n                foreach (i; 0..m/2) {\n                    if (vs[i] + vs[m-1-i] > md) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return 0;\n                vs = vs[0..$-1];\n                m--;\n            }\n            //odd\n            int dw = -1, up = m;\n            while (up-dw > 1) {\n                int md2 = (dw+up)/2;\n                bool f = true;\n                int l = 0, r = m-1;\n                foreach (i; 0..m/2) {\n                    if (l == md2) l++;\n                    if (r == md2) r--;\n                    if (vs[l] + vs[r] > md) {\n                        f = false;\n                        break;\n                    }\n                    l++; r--;\n                }\n                if (!f) {\n                    dw = md2;\n                } else {\n                    up = md2;\n                }\n            }\n            if (up == m) {\n                ok = false;\n                return 0;\n            }\n            return vs[up];       \n        }\n        if (dfs(0, -1) > md) {\n            ok = false;\n        }\n        return ok;\n    }\n\n\n    int Y = binSearch!(md => calc(md))(0, n-1);\n    writeln(X, \" \", Y);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.algorithm;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int X = n-1;\n    foreach (i; 0..n-1) {\n        X -= g[i].length.to!int / 2;\n    }\n\n    bool calc(int md) {\n        //md以下可能？\n//        writeln(\"START \", md);\n        bool ok = true;\n        int dfs(int p, int b) {\n            int m = g[p].length.to!int;\n            if (b != -1) m--;\n            int[] vs = new int[m];\n            int vsCnt = 0;\n            foreach (d; g[p]) {\n                if (d == b) continue;\n                vs[vsCnt++] = dfs(d, p) + 1;\n            }\n            vs.sort!\"a<b\";\n            if (vs.length && vs[$-1] > md) {\n                ok = false;\n                return 0;\n            }\n//            writeln(p+1, \" \", b+1, \" \", vs);\n            if (m % 2 == 0) {\n                //even\n                bool f = true;\n                foreach (i; 0..m/2) {\n                    if (vs[i] + vs[m-1-i] > md) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return 0;\n                vs = vs[0..$-1];\n                m--;\n            }\n            //odd\n            int dw = -1, up = m;\n            while (up-dw > 1) {\n                int md2 = (dw+up)/2;\n                bool f = true;\n                int l = 0, r = m-1;\n                foreach (i; 0..m/2) {\n                    if (l == md2) l++;\n                    if (r == md2) r--;\n                    if (vs[l] + vs[r] > md) {\n                        f = false;\n                        break;\n                    }\n                    l++; r--;\n                }\n                if (!f) {\n                    dw = md2;\n                } else {\n                    up = md2;\n                }\n            }\n            if (up == m) {\n                ok = false;\n                return 0;\n            }\n            return vs[up];       \n        }\n        if (dfs(0, -1) > md) {\n            ok = false;\n        }\n        return ok;\n    }\n\n    int Y = binSearch!(md => calc(md))(0, n-1);\n    writeln(X, \" \", Y);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.algorithm;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int X = n-1;\n    foreach (i; 0..n-1) {\n        X -= g[i].length.to!int / 2;\n    }\n\n    int r = -1;\n    foreach (i; 0..n) {\n        if (g[i].length == 1) {\n            r = i;\n            break;\n        }\n    }\n    bool calc(int md) {\n        //md以下可能？\n//        writeln(\"START \", md);\n        bool ok = true;\n        int dfs(int p, int b) {\n            int m = g[p].length.to!int;\n            if (b != -1) m--;\n            int[] vs = new int[m];\n            int vsCnt = 0;\n            foreach (d; g[p]) {\n                if (d == b) continue;\n                vs[vsCnt++] = dfs(d, p) + 1;\n            }\n            vs.sort!\"a<b\";\n            if (vs.length && vs[$-1] > md) {\n                ok = false;\n                return 0;\n            }\n//            writeln(p+1, \" \", b+1, \" \", vs);\n            if (m % 2 == 0) {\n                //even\n                bool f = true;\n                foreach (i; 0..m/2) {\n                    if (vs[i] + vs[m-1-i] > md) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return 0;\n                vs = vs[0..$-1];\n                m--;\n            }\n            //odd\n            int dw = -1, up = m;\n            while (up-dw > 1) {\n                int md2 = (dw+up)/2;\n                bool f = true;\n                int l = 0, r = m-1;\n                foreach (i; 0..m/2) {\n                    if (l == md2) l++;\n                    if (r == md2) r--;\n                    if (vs[l] + vs[r] > md) {\n                        f = false;\n                        break;\n                    }\n                    l++; r--;\n                }\n                if (!f) {\n                    dw = md2;\n                } else {\n                    up = md2;\n                }\n            }\n            if (up == m) {\n                ok = false;\n                return 0;\n            }\n            return vs[up];       \n        }\n        if (dfs(r, -1) > md) {\n            ok = false;\n        }\n        return ok;\n    }\n\n\n    int Y = binSearch!(md => calc(md))(0, n-1);\n    writeln(X, \" \", Y);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.algorithm;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][n];\n    foreach (i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    int X = n-1;\n    foreach (i; 0..n) {\n        X -= g[i].length.to!int / 2;\n    }\n\n    int r = -1;\n    foreach (i; 0..n) {\n        if (g[i].length == 1) {\n            r = i;\n            break;\n        }\n    }\n\n    bool calc(int md) {\n        //md以下可能？\n//        writeln(\"START \", md);\n        bool ok = true;\n        int dfs(int p, int b) {\n            int m = g[p].length.to!int;\n            if (b != -1) m--;\n            int[] vs = new int[m];\n            int vsCnt = 0;\n            foreach (d; g[p]) {\n                if (d == b) continue;\n                vs[vsCnt++] = dfs(d, p) + 1;\n            }\n            vs.sort!\"a<b\";\n            if (vs.length && vs[$-1] > md) {\n                ok = false;\n                return 0;\n            }\n//            writeln(p+1, \" \", b+1, \" \", vs);\n            if (m % 2 == 0) {\n                //even\n                bool f = true;\n                foreach (i; 0..m/2) {\n                    if (vs[i] + vs[m-1-i] > md) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) return 0;\n                vs = vs[0..$-1];\n                m--;\n            }\n            //odd\n            int dw = -1, up = m;\n            while (up-dw > 1) {\n                int md2 = (dw+up)/2;\n                bool f = true;\n                int l = 0, r = m-1;\n                foreach (i; 0..m/2) {\n                    if (l == md2) l++;\n                    if (r == md2) r--;\n                    if (vs[l] + vs[r] > md) {\n                        f = false;\n                        break;\n                    }\n                    l++; r--;\n                }\n                if (!f) {\n                    dw = md2;\n                } else {\n                    up = md2;\n                }\n            }\n            if (up == m) {\n                ok = false;\n                return 0;\n            }\n            return vs[up];       \n        }\n        if (dfs(r, -1) > md) {\n            ok = false;\n        }\n        return ok;\n    }\n\n\n    int Y = binSearch!(md => calc(md))(0, n-1);\n    writeln(X, \" \", Y);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1,id2) in ban:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i]+1\n            heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n            ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1,id2) in ban:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while (id1,id2) in ban:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left, bisect_right\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef make_pairs(S,x):\n    # a + b <= x となるペアをなるべくたくさん作る\n    # nペア（なるべくたくさん）作ったあと、1つ短い長さが残る\n    i = bisect_right(S,x//2)\n    lower = S[:i][::-1]; upper = S[i:]\n    cand = []\n    rest = []\n    seg = 0\n    for b in upper[::-1]:\n        while lower and lower[-1] + b <= x:\n            cand.append(lower.pop())\n        if cand:\n            cand.pop()\n            seg += 1\n        else:\n            rest.append(b)\n    lower += cand\n    L = len(lower)\n    q,r = divmod(L,2)\n    if r:\n        return seg + len(rest) + q, lower[0]\n    else:\n        seg += q\n        if rest:\n            y = rest[-1]\n            if x == y:\n                return seg + len(rest), 0\n            else:\n                return seg + len(rest) - 1, y\n        else:\n            # 全部ペアになった\n            return seg, 0\n\ndef solve(x):\n    # 長さ x までの線分を許容した場合に、必要となる本数を返す\n    dp = [0] * (N+1)\n    temp = [[] for _ in range(N+1)] # 下から出てくる長さ\n    for v in order[::-1]:\n        p = parent[v]\n        S = temp[v]\n        S.sort()\n        s, l = make_pairs(S,x)\n        dp[v] += s        \n        dp[p] += dp[v]\n        temp[p].append(l + 1)\n        if v == 1:\n            return dp[1] if not l else dp[1] + 1\n\nseg = solve(N + 10)\nleft = 0 # むり\nright = N # できる\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if solve(x) == seg:\n        right = x\n    else:\n        left = x\nprint(seg, right)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef make_pairs(A,S):\n    half = S//2\n    U = sorted(x for x in A if x > half)\n    D = sorted([x for x in A if x <= half], reverse=True)\n    cand = []\n    rest_U = []\n    complete = 0\n    while U and U[-1] == S:\n        U.pop()\n        complete += 1\n    for y in U[::-1]:\n        while D and D[0] + y <= S:\n            cand.append(D.pop())\n        if cand:\n            cand.pop()\n            complete += 1\n        else:\n            rest_U.append(y)\n    cand += D[::-1]\n    L = len(cand)\n    if L & 1:\n        # 一番小さいものを余らせる\n        complete += L // 2 + len(rest_U)\n        return complete, cand[0]\n    else:\n        complete += L // 2\n        if rest_U:\n            return complete + len(rest_U) - 1, rest_U[-1]\n        else:\n            return complete, 0\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef num_of_seg(B):\n    # 長さBまで許容したとき、いくつの線分が必要になるか\n    dp = [0] * (N+1)\n    seg_lens = [[] for _ in range(N+1)]\n    for v in order[::-1]:\n        p = parent[v]\n        A = seg_lens[v]\n        pair, r = make_pairs(A,B)\n        dp[v] += pair\n        if v == root:\n            if r:\n                return dp[v] + 1\n            else:\n                return dp[v]\n        dp[p] += dp[v]\n        seg_lens[p].append(r + 1)\n\nopt_A = num_of_seg(N+10)\nleft = 0 # むり\nright = N + 10 # 可能\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if num_of_seg(x) == opt_A:\n        right = x\n    else:\n        left = x\nB = right\nA = opt_A\nprint(A,B)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef make_pairs(A,S):\n    half = S//2\n    U = sorted(x for x in A if x > half)\n    D = sorted([x for x in A if x <= half], reverse=True)\n    cand = []\n    rest_U = []\n    complete = 0\n    while U and U[-1] == S:\n        U.pop()\n        complete += 1\n    for y in U[::-1]:\n        while D and D[-1] + y <= S:\n            cand.append(D.pop())\n        if cand:\n            cand.pop()\n            complete += 1\n        else:\n            rest_U.append(y)\n    cand += D[::-1]\n    L = len(cand)\n    if L & 1:\n        # 一番小さいものを余らせる\n        complete += L // 2 + len(rest_U)\n        return complete, cand[0]\n    else:\n        complete += L // 2\n        if rest_U:\n            return complete + len(rest_U) - 1, rest_U[-1]\n        else:\n            return complete, 0\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef num_of_seg(B):\n    # 長さBまで許容したとき、いくつの線分が必要になるか\n    dp = [0] * (N+1)\n    seg_lens = [[] for _ in range(N+1)]\n    for v in order[::-1]:\n        p = parent[v]\n        A = seg_lens[v]\n        pair, r = make_pairs(A,B)\n        dp[v] += pair\n        if v == root:\n            if r:\n                return dp[v] + 1\n            else:\n                return dp[v]\n        dp[p] += dp[v]\n        seg_lens[p].append(r + 1)\n\nopt_A = num_of_seg(N+10)\nleft = 0 # むり\nright = N + 10 # 可能\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if num_of_seg(x) == opt_A:\n        right = x\n    else:\n        left = x\nB = right\nA = opt_A\nprint(A,B)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom collections import deque\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef make_pairs(A,S):\n    half = S//2\n    U = sorted(x for x in A if x > half)\n    D = deque(sorted(x for x in A if x <= half))\n    cand = []\n    rest_U = []\n    complete = 0\n    while U and U[-1] == S:\n        U.pop()\n        complete += 1\n    for y in U[::-1]:\n        while D and D[0] + y <= S:\n            cand.append(D.popleft())\n        if cand:\n            cand.pop()\n            complete += 1\n        else:\n            rest_U.append(y)\n    cand += D\n    L = len(cand)\n    if L & 1:\n        # 一番小さいものを余らせる\n        complete += L // 2 + len(rest_U)\n        return complete, cand[0]\n    else:\n        complete += L // 2\n        if rest_U:\n            return complete + len(rest_U) - 1, rest_U[-1]\n        else:\n            return complete, 0\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef num_of_seg(B):\n    # 長さBまで許容したとき、いくつの線分が必要になるか\n    dp = [0] * (N+1)\n    seg_lens = [[] for _ in range(N+1)]\n    for v in order[::-1]:\n        p = parent[v]\n        A = seg_lens[v]\n        pair, r = make_pairs(A,B)\n        dp[v] += pair\n        if v == root:\n            if r:\n                return dp[v] + 1\n            else:\n                return dp[v]\n        dp[p] += dp[v]\n        seg_lens[p].append(r + 1)\n\nopt_A = num_of_seg(N+10)\nleft = 0 # むり\nright = N + 10 # 可能\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if num_of_seg(x) == opt_A:\n        right = x\n    else:\n        left = x\nB = right\nA = opt_A\nprint(A,B)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        #ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while id1+id2==N and id1<=i:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i]+1\n            heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n            #ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1+id2==N) or (id1+id2==N-1 and id2<i+k):\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            #ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while id1+id2!=2*k-1:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)\n\n\n#ans=dfs(0,-1)\n#print(\"YES\" if ans else \"NO\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def dfs(u=0, ou=-1):\n        dist_leaf = 0\n        for ku in to[u]:\n            if ku == ou: continue\n            dist_leaf += dfs(ku, u) + 1\n        if dist_leaf >= 0:\n            if len(to[ou]) == 2 and ou != 0:\n                return dist_leaf\n            else:\n                dp_original[u] = dist_leaf\n                return -10\n        odr_dp.append(u)\n        parent[u] = ou\n        return -10\n\n    def check(m):\n        dp = dp_original[:]\n        for u in odr_dp:\n            dists = []\n            for v in to[u]:\n                if v == parent[u]: continue\n                dists.append(dp[v] + 1)\n            dists.sort()\n            if dists[-1] > m:\n                return False\n            n_dists = len(dists)\n\n            # 子が偶数のとき、子だけでマッチングできるか確認\n            if n_dists % 2 == 0:\n                for i in range(n_dists // 2):\n                    if dists[i] + dists[n_dists - 1 - i] > m:\n                        n_dists -= 1\n                        break\n                else:\n                    dp[u] = 0\n                    continue\n\n            # 外す子を二分探索\n            l, r = -1, n_dists\n            while l + 1 < r:\n                c = (l + r) // 2\n                i, j = 0, n_dists - 1\n                for _ in range(n_dists // 2):\n                    if i == c: i += 1\n                    if j == c: j -= 1\n                    if dists[i] + dists[j] > m:\n                        if c == n_dists - 1:\n                            return False\n                        l = c\n                        break\n                    i, j = i + 1, j - 1\n                else:\n                    r = c\n            dp[u] = dists[r]\n        #print(dp)\n        if len(to[0]) % 2 == 0 and dp[0] > 0:\n            return False\n        else:\n            return True\n\n    inf = 10 ** 6\n    n = int(input())\n    to = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int1, input().split())\n        to[a].append(b)\n        to[b].append(a)\n    odd_degree_nodes = []\n    for u in range(n):\n        if len(to[u]) % 2:\n            odd_degree_nodes.append(u)\n    # print(odd_degree_nodes)\n    ans_a = len(odd_degree_nodes) // 2\n\n    # DPの順番決め\n    odr_dp = []\n    dp_original = [inf] * n\n    parent = [-1] * n\n    dfs()\n    #print(odr_dp)\n    #print(dp_original)\n\n    # ans_b決め\n    l = 0\n    r = n\n    while l + 1 < r:\n        m = (l + r) // 2\n        if check(m):\n            r = m\n        else:\n            l = m\n    ans_b = r\n    print(ans_a, ans_b)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\nparent=[-1]*N\nparent[0]=0\nque=deque([0])\nans=[0]\nwhile que:\n    v=que.popleft()\n    for nv in edge[v]:\n        if parent[nv]==-1:\n            parent[nv]=v\n            que.append(nv)\n            ans.append(nv)\n\nans=ans[::-1]\n\ndef cond(n):\n    dp=[-1]*N\n    for v in ans:\n        if v!=0:\n            temp=[]\n            if len(edge[v])==1:\n                dp[v]=1\n            else:\n                for nv in edge[v]:\n                    if nv!=parent[v]:\n                        r=dp[nv]\n                        if r==-1:\n                            return False\n                        temp.append(r)\n                temp.sort()\n                if len(temp)%2==0:\n                    temp.append(0)\n                start=0\n                end=len(temp)-1\n                while end-start>1:\n                    test=(end+start)//2\n                    check=True\n                    s=0;t=len(temp)-1\n                    while t>s:\n                        if s==test:\n                            s+=1\n                        elif t==test:\n                            t-=1\n                        else:\n                            if temp[s]+temp[t]>n:\n                                check=False\n                            s+=1\n                            t-=1\n                    if check:\n                        end=test\n                    else:\n                        start=test\n                check=True\n                s=0;t=len(temp)-1\n                while t>s:\n                    if s==start:\n                        s+=1\n                    elif t==start:\n                        t-=1\n                    else:\n                        if temp[s]+temp[t]>n:\n                            check=False\n                        s+=1\n                        t-=1\n                if check:\n                    dp[v]=temp[start]+1\n                else:\n                    check=True\n                    s=0;t=len(temp)-1\n                    while t>s:\n                        if s==end:\n                            s+=1\n                        elif t==end:\n                            t-=1\n                        else:\n                            if temp[s]+temp[t]>n:\n                                check=False\n                            s+=1\n                            t-=1\n                    if check:\n                        dp[v]=temp[end]+1\n                    else:\n                        return False\n        else:\n            temp=[]\n            for nv in edge[v]:\n                temp.append(dp[nv])\n            if len(temp)%2==1:\n                temp.append(0)\n            temp.sort()\n            k=len(temp)//2\n            for i in range(k):\n                test=temp[i]+temp[-i-1]\n                if test>n:\n                    return False\n            return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    test=(end+start)//2\n    if cond(test):\n        end=test\n    else:\n        start=test\n\nprint(A,end)\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        temp.sort()\n        start=0\n        end=len(temp)-1\n        k=len(temp)//2\n        while end-start>1:\n            test=(end+start)//2\n            check=True\n            s=0\n            t=len(temp)-1\n            while t>s:\n                if s==test:\n                    s+=1\n                elif t==test:\n                    t-=1\n                else:\n                    if temp[s]+temp[t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                end=test\n            else:\n                start=test\n        check=True\n        s=0\n        t=len(temp)-1\n        while t>s:\n            if s==start:\n                s+=1\n            elif t==start:\n                t-=1\n            else:\n                if temp[s]+temp[t]>n:\n                    check=False\n                s+=1\n                t-=1\n        if check:\n            return temp[start]+1\n        else:\n            check=True\n            s=0\n            t=len(temp)-1\n            while t>s:\n                if s==end:\n                    s+=1\n                elif t==end:\n                    t-=1\n                else:\n                    if temp[s]+temp[t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                return temp[end]+1\n            else:\n                return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nfrom math import log2\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def init(i, oi=-1, dpt=0):\n        depth[i] = dpt\n        parent_2k[0][i] = oi\n        for ki in to[i]:\n            if ki == oi: continue\n            init(ki, i, dpt + 1)\n        return\n\n    def make_parent(level):\n        parent_2kk1 = parent_2k[0]\n        for k in range(1, level):\n            parent_2kk = parent_2k[k]\n            for i in range(n):\n                parent1 = parent_2kk1[i]\n                if parent1 != -1:\n                    parent_2kk[i] = parent_2kk1[parent1]\n            parent_2kk1 = parent_2kk\n        return\n\n    def lca(u, v):\n        dist_uv = depth[u] - depth[v]\n        if dist_uv < 0:\n            u, v = v, u\n            dist_uv *= -1\n\n        k = 0\n        while dist_uv:\n            if dist_uv & 1:\n                u = parent_2k[k][u]\n            dist_uv >>= 1\n            k += 1\n\n        if u == v:\n            return u\n\n        for k in range(int(log2(depth[u])) + 1, -1, -1):\n            pu = parent_2k[k][u]\n            pv = parent_2k[k][v]\n            if pu != pv:\n                u = pu\n                v = pv\n        return parent_2k[0][u]\n\n    def dfs(i, mx, len_odd):\n        if i == len_odd:\n            return mx\n        if fin[i]:\n            return dfs(i + 1, mx, len_odd)\n        res = inf\n        fin[i] = True\n        for j in range(i + 1, len_odd):\n            if fin[j]: continue\n            fin[j] = True\n            res = min(res, dfs(i + 1, max(mx, dist[i][j]), len_odd))\n            fin[j] = False\n        fin[i] = False\n        return res\n\n    inf = 10 ** 6\n    n = int(input())\n    to = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int1, input().split())\n        to[a].append(b)\n        to[b].append(a)\n    depth = [0] * n\n    level = int(log2(n)) + 1\n    parent_2k = [[-1] * n for _ in range(level)]\n    init(0)\n    make_parent(level)\n\n    odd_degree_nodes = []\n    for u in range(n):\n        if len(to[u]) % 2:\n            odd_degree_nodes.append(u)\n    # print(odd_degree_nodes)\n    len_odd = len(odd_degree_nodes)\n    ans_a = len_odd // 2\n\n    dist = [[-1] * len_odd for _ in range(len_odd)]\n    for j in range(len_odd):\n        v = odd_degree_nodes[j]\n        for i in range(j):\n            u = odd_degree_nodes[i]\n            lca_uv = lca(u, v)\n            dist[i][j] = dist[j][i] = depth[u] + depth[v] - 2 * depth[lca_uv]\n    # p2D(dist)\n\n    fin = [False] * len_odd\n    ans_b = dfs(0, 0, len_odd)\n    print(ans_a, ans_b)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ntemp=[[0 for j in range(len(edge[i])-1)] for i in range(N)]\ntemp[0].append(0)\nfor i in range(1,N):\n    if len(temp[i])%2==0:\n        temp[i].append(0)\nif len(temp[0])%2==1:\n    temp[0].append(0)\n\ndef clear():\n    for i in range(N):\n        for j in range(len(temp[i])):\n            temp[i][j]=0\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        id=0\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp[v][id]=r\n                id+=1\n        temp[v].sort()\n        start=0\n        end=len(temp[v])-1\n        k=len(temp[v])//2\n        while end-start>1:\n            test=(end+start)//2\n            check=True\n            s=0\n            t=len(temp[v])-1\n            while t>s:\n                if s==test:\n                    s+=1\n                elif t==test:\n                    t-=1\n                else:\n                    if temp[v][s]+temp[v][t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                end=test\n            else:\n                start=test\n        check=True\n        s=0\n        t=len(temp[v])-1\n        while t>s:\n            if s==start:\n                s+=1\n            elif t==start:\n                t-=1\n            else:\n                if temp[v][s]+temp[v][t]>n:\n                    check=False\n                s+=1\n                t-=1\n        if check:\n            return temp[v][start]+1\n        else:\n            check=True\n            s=0\n            t=len(temp[v])-1\n            while t>s:\n                if s==end:\n                    s+=1\n                elif t==end:\n                    t-=1\n                else:\n                    if temp[v][s]+temp[v][t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                return temp[v][end]+1\n            else:\n                return -1\n    else:\n        id=0\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp[v][id]=r\n                id+=1\n        temp[v].sort()\n        k=len(temp[v])//2\n        for i in range(k):\n            test=temp[v][i]+temp[v][-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    clear()\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ntemp=[[0 for j in range(len(edge[i])-1)] for i in range(N)]\ntemp[0].append(0)\nfor i in range(1,N):\n    if len(temp[i])%2==0:\n        temp[i].append(0)\nif len(temp[0])%2==1:\n    temp[0].append(0)\n\ndef clear():\n    for i in range(N):\n        temp[i].sort()\n        for j in range(len(temp[i])):\n            temp[i][j]=0\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    clear()\n    end=t\n\nprint(end)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\nparent=[-1]*N\nparent[0]=0\nque=deque([0])\nans=[0]\nwhile que:\n    v=que.popleft()\n    for nv in edge[v]:\n        if parent[nv]==-1:\n            parent[nv]=v\n            que.append(nv)\n            ans.append(nv)\n\nans=ans[::-1]\n\ndef cond(n):\n    dp=[-1]*N\n    for v in ans:\n        if v!=0:\n            temp=[]\n            if len(edge[v])==1:\n                dp[v]=1\n            else:\n                for nv in edge[v]:\n                    if nv!=parent[v]:\n                        r=dp[nv]\n                        if r==-1:\n                            return False\n                        temp.append(r)\n                if len(temp)%2==0:\n                    temp.append(0)\n                temp.sort()\n                start=0\n                end=len(temp)-1\n                while end-start>1:\n                    test=(end+start)//2\n                    check=True\n                    s=0;t=len(temp)-1\n                    while t>s:\n                        if s==test:\n                            s+=1\n                        elif t==test:\n                            t-=1\n                        else:\n                            if temp[s]+temp[t]>n:\n                                check=False\n                            s+=1\n                            t-=1\n                    if check:\n                        end=test\n                    else:\n                        start=test\n                check=True\n                s=0;t=len(temp)-1\n                while t>s:\n                    if s==start:\n                        s+=1\n                    elif t==start:\n                        t-=1\n                    else:\n                        if temp[s]+temp[t]>n:\n                            check=False\n                        s+=1\n                        t-=1\n                if check:\n                    dp[v]=temp[start]+1\n                else:\n                    check=True\n                    s=0;t=len(temp)-1\n                    while t>s:\n                        if s==end:\n                            s+=1\n                        elif t==end:\n                            t-=1\n                        else:\n                            if temp[s]+temp[t]>n:\n                                check=False\n                            s+=1\n                            t-=1\n                    if check:\n                        dp[v]=temp[end]+1\n                    else:\n                        return False\n        else:\n            temp=[]\n            for nv in edge[v]:\n                temp.append(dp[nv])\n            if len(temp)%2==1:\n                temp.append(0)\n            temp.sort()\n            k=len(temp)//2\n            for i in range(k):\n                test=temp[i]+temp[-i-1]\n                if test>n:\n                    return False\n            return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    test=(end+start)//2\n    if cond(test):\n        end=test\n    else:\n        start=test\n\nprint(A,end)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_right\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef make_pairs(A,S):\n    half = S//2\n    A.sort()\n    complete = 0\n    while A and A[-1] == S:\n        A.pop()\n        complete += 1\n    i = bisect_right(A,half)\n    U = A[i:][::-1]\n    D = A[:i][::-1]\n    cand = []\n    rest_U = []\n    for y in U:\n        while D and D[-1] + y <= S:\n            cand.append(D.pop())\n        if cand:\n            cand.pop()\n            complete += 1\n        else:\n            rest_U.append(y)\n    cand += D[::-1]\n    L = len(cand)\n    if L & 1:\n        # 一番小さいものを余らせる\n        complete += L // 2 + len(rest_U)\n        return complete, cand[0]\n    else:\n        complete += L // 2\n        if rest_U:\n            return complete + len(rest_U) - 1, rest_U[-1]\n        else:\n            return complete, 0\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef num_of_seg(B):\n    # 長さBまで許容したとき、いくつの線分が必要になるか\n    dp = [0] * (N+1)\n    seg_lens = [[] for _ in range(N+1)]\n    for v in order[::-1]:\n        p = parent[v]\n        A = seg_lens[v]\n        pair, r = make_pairs(A,B)\n        dp[v] += pair\n        if v == root:\n            if r:\n                return dp[v] + 1\n            else:\n                return dp[v]\n        dp[p] += dp[v]\n        seg_lens[p].append(r + 1)\n\nopt_A = num_of_seg(N+10)\nleft = 0 # むり\nright = N + 10 # 可能\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if num_of_seg(x) == opt_A:\n        right = x\n    else:\n        left = x\nB = right\nA = opt_A\nprint(A,B)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ntemp=[[0 for j in range(len(edge[i])-1)] for i in range(N)]\ntemp[0].append(0)\nfor i in range(1,N):\n    if len(temp[i])%2==0:\n        temp[i].append(0)\nif len(temp[0])%2==1:\n    temp[0].append(0)\n\ndef clear():\n    for i in range(N):\n        for j in range(len(temp[i])):\n            temp[i][j]=0\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        id=0\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp[v][id]=r\n                id+=1\n        temp[v].sort()\n        start=0\n        end=len(temp[v])-1\n        k=len(temp[v])//2\n        while end-start>1:\n            test=(end+start)//2\n            check=True\n            s=0\n            t=len(temp[v])-1\n            while t>s:\n                if s==test:\n                    s+=1\n                elif t==test:\n                    t-=1\n                else:\n                    if temp[v][s]+temp[v][t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                end=test\n            else:\n                start=test\n        check=True\n        s=0\n        t=len(temp[v])-1\n        while t>s:\n            if s==start:\n                s+=1\n            elif t==start:\n                t-=1\n            else:\n                if temp[v][s]+temp[v][t]>n:\n                    check=False\n                s+=1\n                t-=1\n        if check:\n            return temp[v][start]+1\n        else:\n            check=True\n            s=0\n            t=len(temp[v])-1\n            while t>s:\n                if s==end:\n                    s+=1\n                elif t==end:\n                    t-=1\n                else:\n                    if temp[v][s]+temp[v][t]>n:\n                        check=False\n                    s+=1\n                    t-=1\n            if check:\n                return temp[v][end]+1\n            else:\n                return -1\n    else:\n        id=0\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp[v][id]=r\n                id+=1\n        temp[v].sort()\n        k=len(temp[v])//2\n        for i in range(k):\n            test=temp[v][i]+temp[v][-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    clear()\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\nn = int(input())\nedge = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    edge[a].append(b)\n    edge[b].append(a)\n\ncnt = [1] *(n+1)\n\na = 0\nfor i in range(1, n+1):\n    if len(edge[i]) % 2 == 1:\n        a += 1\n\na //= 2\n\ndef init_dfs(x, last = -1):\n    for to in edge[x]:\n        if to == last:continue\n        init_dfs(to, x)\n        cnt[x] += cnt[to]\n\ninit_dfs(1)\n\ndef check(tmp, b):\n    k = len(tmp)\n    if k == 1:\n        return True, tmp[0]\n    for i in range(k//2):\n        if tmp[i] + tmp[k-2-i] > b:\n            return False, 0\n    for i in range(k // 2):\n        if tmp[i] + tmp[k-1-i] > b:\n            return True, tmp[k-1-i]\n    for i in range(k // 2 + 1, 0, -1):\n        if tmp[i] + tmp[k-i] > b:\n            return True, tmp[i]\n    return True, tmp[0]\n                            \n        \n\ndef dfs(x, b, last = -1):\n    tmp = []\n    for to in edge[x]:\n        if to == last:continue\n        ok, length = dfs(to, b, x)\n        if not ok:return False, 0\n        if length == b:return False, 0\n        tmp.append(length + 1)\n    tmp.sort()\n    k = len(tmp)\n    if k % 2 == 0:\n        ok = True\n        for i in range(k//2):\n            if tmp[i] + tmp[k-1-i] > b:\n                ok = False\n        if ok:\n            return True, 0\n\n        tmp.pop()\n    return check(tmp, b)\n\nbottom = 0\ntop = n\n\nwhile top - bottom > 1:\n    mid = (top + bottom) // 2\n    if dfs(1, mid)[0]:\n        top = mid\n    else:\n        bottom = mid\nprint(a, top)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ntemp=[[0 for j in range(len(edge[i])-1)] for i in range(N)]\ntemp[0].append(0)\nfor i in range(1,N):\n    if len(temp[i])%2==0:\n        temp[i].append(0)\nif len(temp[0])%2==1:\n    temp[0].append(0)\n\ndef clear():\n    for i in range(N):\n        for j in range(len(temp[i])):\n            temp[i][j]=0\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    clear()\n    end=t\n\nprint(end)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1,id2) in ban:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i]+1\n            heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n            ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1,id2) in ban:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while (id1,id2) in ban:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def dfs(i, mx, len_odd):\n        if i == len_odd:\n            return mx\n        if fin[i]:\n            return dfs(i + 1, mx, len_odd)\n        res = inf\n        fin[i] = True\n        u = odd_degree_nodes[i]\n        for j in range(i + 1, len_odd):\n            if fin[j]: continue\n            fin[j] = True\n            v = odd_degree_nodes[j]\n            res = min(res, dfs(i + 1, max(mx, dist[u][v]), len_odd))\n            fin[j] = False\n        fin[i] = False\n        return res\n\n    inf = 10 ** 6\n    n = int(input())\n    to = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int1, input().split())\n        to[a].append(b)\n        to[b].append(a)\n    odd_degree_nodes = []\n    for u in range(n):\n        if len(to[u]) % 2:\n            odd_degree_nodes.append(u)\n    # print(odd_degree_nodes)\n    ans_a = len(odd_degree_nodes) // 2\n\n    dist = [[inf] * n for _ in range(n)]\n    for u in range(n):\n        dist[u][u] = 0\n        for v in to[u]:\n            dist[u][v] = dist[v][u] = 1\n    for w in range(n):\n        for u in range(n):\n            for v in range(n):\n                new_dist = dist[w][u] + dist[w][v]\n                if new_dist < dist[u][v]:\n                    dist[u][v] = dist[v][u] = new_dist\n    # p2D(dist)\n\n    fin = [False] * len(odd_degree_nodes)\n    ans_b = dfs(0, 0, len(odd_degree_nodes))\n    print(ans_a, ans_b)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        temp.sort()\n        start=0\n        end=len(temp)\n        k=len(temp)//2\n        while end-start>1:\n            test=(end+start)//2\n            check=True\n            ttt=temp[:test]+temp[test+1:]\n            for i in range(k):\n                if ttt[i]+ttt[-i-1]>n:\n                    check=False\n            if check:\n                end=test\n            else:\n                start=test\n        check=True\n        ttt=temp[:start]+temp[start+1:]\n        for i in range(k):\n            if ttt[i]+ttt[-i-1]>n:\n                check=False\n        if check:\n            return temp[start]+1\n        else:\n            check=True\n            ttt=temp[:end]+temp[end+1:]\n            for i in range(k):\n                if ttt[i]+ttt[-i-1]>n:\n                    check=False\n            if check:\n                return temp[end]+1\n            else:\n                return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        #ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while id1+id2==N and id1<i:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i]+1\n            heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n            #ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1+id2==N) or (id1+id2==N-1 and id2<i+k):\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            #ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while id1+id2!=2*k-1:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nedge = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    edge[a].append(b)\n    edge[b].append(a)\n\ncnt = [1] *(n+1)\n\na = 0\nfor i in range(1, n+1):\n    if len(edge[i]) % 2 == 1:\n        a += 1\n\na //= 2\n\ndef init_dfs(x, last = -1):\n    for to in edge[x]:\n        if to == last:continue\n        init_dfs(to, x)\n        cnt[x] += cnt[to]\n\ninit_dfs(1)\n\ndef check(tmp, b):\n    k = len(tmp)\n    if k == 1:\n        return True, tmp[0]\n    for i in range(k//2):\n        if tmp[i] + tmp[k-2-i] > b:\n            return False, 0\n    for i in range(k // 2):\n        if tmp[i] + tmp[k-1-i] > b:\n            return True, tmp[k-1-i]\n    for i in range(k // 2 + 1, 0, -1):\n        if tmp[i] + tmp[k-i] > b:\n            return True, tmp[i]\n    return True, tmp[0]\n                            \n        \n\ndef dfs(x, b, last = -1):\n    tmp = []\n    for to in edge[x]:\n        if to == last:continue\n        ok, length = dfs(to, b, x)\n        if not ok:return False, 0\n        if length == b:return False, 0\n        tmp.append(length + 1)\n    tmp.sort()\n    k = len(tmp)\n    if k % 2 == 0:\n        ok = True\n        for i in range(k//2):\n            if tmp[i] + tmp[k-1-i] > b:\n                ok = False\n        if ok:\n            return True, 0\n\n        tmp.pop()\n    return check(tmp, b)\n\nbottom = 0\ntop = n\n\nwhile top - bottom > 1:\n    mid = (top + bottom) // 2\n    if dfs(1, mid)[0]:\n        top = mid\n    else:\n        bottom = mid\nprint(a, top)"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        check=True\n        if len(temp)%2==0:\n            temp.append(0)\n            check=False\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            if i==0:\n                if check:\n                    val,id1,id2=heapq.heappop(que)\n                    while (id1,id2) in ban:\n                        val,id1,id2=heapq.heappop(que)\n                    if val>=-n:\n                        return temp[i]+1\n                heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-i-1))\n                ban.add((i+1,N-1-i))\n            else:\n                val,id1,id2=heapq.heappop(que)\n                while (id1,id2) in ban:\n                    val,id1,id2=heapq.heappop(que)\n                if val>=-n:\n                    return temp[i]+1\n                heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n                ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1,id2) in ban:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while (id1,id2) in ban:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport bisect\n\nn = 0\nedges = None\nvisited = None\n\ndef dfs(v, b, r = False):\n    global visited\n\n    if not r:\n        visited = [False] * n\n\n    visited[v] = True\n    lengths = []\n    for c in edges[v]:\n        if not visited[c]:\n            k = dfs(c, b, True)\n            if k < 0 or b < k:\n                return -1\n            lengths.append(k)\n\n    odd = (len(lengths) % 2 == 1) ^ r\n    lengths.sort()\n    while 1 < len(lengths):\n        k = lengths.pop()\n        i = bisect.bisect_right(lengths, b - k)\n        if i == 0:\n            if odd:\n                odd = False\n            else:\n                return -1\n        else:\n            lengths.pop(i - 1)\n\n    if len(lengths) == 0:\n        return 1\n    else:\n        return lengths[0] + 1\n\n\ndef solve():\n\n    root = None\n    a = 1\n\n    for i in range(n):\n        c = len(edges[i])\n        if 3 <= c:\n            a += (c - 1) // 2\n            root = i\n\n    if root is None:\n        return 1, n - 1\n\n    ok = n - 1\n    ng = 1\n\n    while ng + 1 < ok:\n        mid = (ok + ng) // 2\n        if 0 <= dfs(root, mid):\n            ok = mid\n        else:\n            ng = mid\n\n    return a, ok\n\n\ndef main():\n    global n\n    global edges\n\n    n = int(input())\n    edges = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = input().split()\n        a = int(a) - 1\n        b = int(b) - 1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    a, b = solve()\n    print('{} {}'.format(a, b))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom bisect import bisect_left, bisect_right\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndef make_pairs(S,x):\n    # a + b <= x となるペアをなるべくたくさん作る\n    # nペア（なるべくたくさん）作ったあと、1つ短い長さが残る\n    seg = 0\n    while S and S[-1] == x:\n        S.pop()\n        seg += 1\n    i = bisect_right(S,x//2)\n    lower = S[:i][::-1]; upper = S[i:]\n    cand = []\n    rest = []\n    for b in upper[::-1]:\n        while lower and lower[-1] + b <= x:\n            cand.append(lower.pop())\n        if cand:\n            cand.pop()\n            seg += 1\n        else:\n            rest.append(b)\n    cand += lower[::-1]\n    L = len(cand)\n    q,r = divmod(L,2)\n    if r:\n        return seg + len(rest) + q, cand[0]\n    else:\n        seg += q\n        if rest:\n            return seg + len(rest) - 1, rest[-1]\n        else:\n            # 全部ペアになった\n            return seg, 0\n\ndef solve(x):\n    # 長さ x までの線分を許容した場合に、必要となる本数を返す\n    dp = [0] * (N+1)\n    temp = [[] for _ in range(N+1)] # 下から出てくる長さ\n    for v in order[::-1]:\n        p = parent[v]\n        S = temp[v]\n        S.sort()\n        s, l = make_pairs(S,x)\n        dp[v] += s        \n        dp[p] += dp[v]\n        temp[p].append(l + 1)\n        if v == 1:\n            return dp[1] if not l else dp[1] + 1\n\nseg = solve(N + 10)\nleft = 0 # むり\nright = N # できる\nwhile left + 1 < right:\n    x = (left + right) // 2\n    if solve(x) == seg:\n        right = x\n    else:\n        left = x\nprint(seg, right)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def dfs(u=0, ou=-1):\n        dist_leaf = 0\n        for ku in to[u]:\n            if ku == ou: continue\n            dist_leaf += dfs(ku, u) + 1\n        if dist_leaf >= 0:\n            if len(to[ou]) == 2 and ou != 0:\n                return dist_leaf\n            else:\n                dp_original[u] = dist_leaf\n                return -10\n        odr_dp.append(u)\n        parent[u] = ou\n        return -10\n\n    def check(m):\n        dp = dp_original[:]\n        for u in odr_dp:\n            dists = []\n            for v in to[u]:\n                if v == parent[u]: continue\n                dists.append(dp[v] + 1)\n            dists.sort()\n            if dists[-1] > m:\n                return False\n            n_dists = len(dists)\n\n            # 子が偶数のとき、子だけでマッチングできるか確認\n            if n_dists % 2 == 0:\n                for i in range(n_dists // 2):\n                    if dists[i] + dists[n_dists - 1 - i] > m:\n                        n_dists -= 1\n                        break\n                else:\n                    dp[u] = 0\n                    continue\n\n            # 外す子を二分探索\n            l, r = -1, n_dists\n            while l + 1 < r:\n                c = (l + r) // 2\n                i, j = 0, n_dists - 1\n                for _ in range(n_dists // 2):\n                    if i == c: i += 1\n                    if j == c: j -= 1\n                    if dists[i] + dists[j] > m:\n                        if c == n_dists - 1:\n                            return False\n                        l = c\n                        break\n                    i, j = i + 1, j - 1\n                else:\n                    r = c\n            dp[u] = dists[r]\n        #print(dp)\n        if len(to[0]) % 2 == 0 and dp[0] > 0:\n            return False\n        else:\n            return True\n\n    inf = 10 ** 6\n    n = int(input())\n    to = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int1, input().split())\n        to[a].append(b)\n        to[b].append(a)\n    odd_degree_nodes = []\n    for u in range(n):\n        if len(to[u]) % 2:\n            odd_degree_nodes.append(u)\n    # print(odd_degree_nodes)\n    ans_a = len(odd_degree_nodes) // 2\n\n    # DPの順番決め\n    odr_dp = []\n    dp_original = [inf] * n\n    parent = [-1] * n\n    dfs()\n    #print(odr_dp)\n    #print(dp_original)\n\n    # ans_b決め\n    l = 0\n    r = n\n    while l + 1 < r:\n        m = (l + r) // 2\n        if check(m):\n            r = m\n        else:\n            l = m\n    ans_b = r\n    print(ans_a, ans_b)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys,heapq\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nN=int(input())\nedge=[[] for i in range(N)]\nfor _ in range(N-1):\n    a,b=map(int,input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\n\ndef dfs(v,pv,n):\n    #print(v,pv,len(edge[v]))\n    if v!=0:\n        if len(edge[v])==1:\n            return 1\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return -1\n                temp.append(r)\n        if len(temp)%2==0:\n            temp.append(0)\n        elif len(temp)==1:\n            return temp[0]+1\n        temp.sort()\n        que=[]\n        #ban=set([])\n        k=len(temp)//2\n        for i in range(k):\n            heapq.heappush(que,(-temp[i+1]-temp[-i-1],i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while id1+id2==N and id1=<i:\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i]+1\n            heapq.heappush(que,(-temp[i]-temp[-i-1],i,N-1-i))\n            #ban.add((i+1,N-1-i))\n        for i in range(k):\n            val,id1,id2=heapq.heappop(que)\n            while (id1+id2==N) or (id1+id2==N-1 and id2<i+k):\n                val,id1,id2=heapq.heappop(que)\n            if val>=-n:\n                return temp[i+k]+1\n            heapq.heappush(que,(-temp[k-1-i]-temp[i+k],k-1-i,i+k))\n            #ban.add((N-1-i-k,i+k))\n        val,id1,id2=heapq.heappop(que)\n        while id1+id2!=2*k-1:\n            val,id1,id2=heapq.heappop(que)\n        if val>=-n:\n            return temp[-1]+1\n\n        return -1\n    else:\n        temp=[]\n        for nv in edge[v]:\n            if nv!=pv:\n                r=dfs(nv,v,n)\n                if r==-1:\n                    return False\n                temp.append(r)\n        if len(temp)%2==1:\n            temp.append(0)\n        temp.sort()\n        k=len(temp)//2\n        for i in range(k):\n            test=temp[i]+temp[-i-1]\n            if test>n:\n                return False\n        return True\n\nA=(len(edge[0])+1)//2\nfor i in range(1,N):\n    A+=(len(edge[i])-1)//2\n\nstart=0\nend=N-1\nwhile end-start>1:\n    t=(end+start)//2\n    if dfs(0,-1,t):\n        end=t\n    else:\n        start=t\n\nprint(A,end)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport bisect\n\nn = 0\nedges = None\nvisited = None\n\ndef dfs(v, b, r = False):\n    global visited\n\n    if not r:\n        visited = [False] * n\n        count = [0] * n\n\n    visited[v] = True\n    lengths = []\n    for c in edges[v]:\n        if not visited[c]:\n            k = dfs(c, b, True)\n            if k < 0:\n                return -1\n            lengths.append(k)\n\n    odd = (len(lengths) % 2 == 1) ^ r\n    lengths.sort()\n    while 1 < len(lengths):\n        k = lengths.pop()\n        if b < k:\n            return -1\n        elif k == b and odd:\n            odd = False\n        else:\n            i = bisect.bisect_right(lengths, b - k)\n            if i == 0:\n                return -1\n            lengths.pop(i - 1)\n    if len(lengths) == 0:\n        return 1\n    else:\n        return lengths[0] + 1\n\n\ndef solve():\n\n    root = None\n    a = 1\n\n    for i in range(n):\n        c = len(edges[i])\n        if 3 <= c:\n            a += (c - 1) // 2\n            root = i\n\n    if root is None:\n        return 1, n - 1\n\n    ok = n - 1\n    ng = 1\n\n    while ng + 1 < ok:\n        mid = (ok + ng) // 2\n        if 0 <= dfs(root, mid):\n            ok = mid\n        else:\n            ng = mid\n\n    return a, ok\n\n\ndef main():\n    global n\n    global edges\n\n    n = int(input())\n    edges = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = input().split()\n        a = int(a) - 1\n        b = int(b) - 1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    a, b = solve()\n    print('{} {}'.format(a, b))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct FenwickTree {\n    seq: Vec<i64>,\n}\n#[allow(dead_code)]\nimpl FenwickTree {\n    fn new(n: usize) -> FenwickTree {\n        FenwickTree { seq: vec![0; n + 2] }\n    }\n    fn add(&mut self, index: usize, value: i64) {\n        let mut index = (index + 1) as i32;\n        while (index as usize) < self.seq.len() {\n            self.seq[index as usize] += value;\n            index += index & -index;\n        }\n    }\n    // inclusive\n    fn sum(&self, index: usize) -> i64 {\n        let mut ret = 0;\n        let mut index = (index + 1) as i32;\n        while index > 0 {\n            ret += self.seq[index as usize];\n            index -= index & -index;\n        }\n        ret\n    }\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\n\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n    edge_cnt: Vec<usize>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        Solver {\n            n: 0,\n            g: vec![],\n            edge_cnt: vec![],\n        }\n    }\n    fn init(&mut self) {\n        let n: usize = read();\n        self.n = n;\n        self.g = graph_new(n);\n        self.edge_cnt = vec![usize::max_value(); n - 1];\n        let mut e = 0;\n        for _ in 0..n-1 {\n            let mut a: usize = read();\n            let mut b: usize = read();\n            a -= 1; b -= 1;\n            add_bi_edge(&mut self.g, &mut e, a, b, 0);\n        }\n    }\n    fn bfs(&self, len: usize) -> i32 {\n        let n = self.n;\n        let mut childs = vec![vec![]; n];\n        let mut used = vec![false; n - 1];\n        let mut ret = 0;\n        let mut que = VecDeque::new();\n        for i in 0..n {\n            if self.g[i].len() == 1 { que.push_back(i); }\n        }\n        while que.front().is_some() {\n            let from = *que.front().unwrap();\n            que.pop_front();\n            let mut rest = 0;\n            {\n                childs[from].sort();\n                childs[from].reverse();\n                let childs = childs[from].clone();\n                let mut used = vec![false; childs.len()];\n                let mut front = 0;\n                let mut other = vec![];\n                for back in (0..childs.len()).rev() {\n                    if used[back] { continue; }\n                    while front < back && childs[back] + childs[front] >= len {\n                        other.push(front);\n                        front += 1;\n                    }\n                    while !other.is_empty() && *other.last().unwrap() >= back { other.pop(); }\n                    if !other.is_empty() {\n                        let index = *other.last().unwrap();\n                        assert!(childs[index] + childs[back] >= len);\n                        assert!(index != back);\n                        other.pop();\n                        used[back] = true;\n                        used[index] = true;\n                        ret -= 1;\n                    }\n                }\n                for i in 0..childs.len() {\n                    if !used[i] {\n                        rest = childs[i];\n                        break;\n                    }\n                }\n            }\n            for edge in self.g[from].clone().iter() {\n                if used[edge.index] { continue; }\n                used[edge.index] = true;\n                if rest == 0 {\n                    rest = len;\n                    ret += 1;\n                }\n                rest -= 1;\n                childs[edge.dest].push(rest);\n                // println!(\"{} {:?}\", edge.dest, self.g[edge.dest]);\n                if childs[edge.dest].len() == self.g[edge.dest].len() - 1 {\n                    que.push_back(edge.dest);\n                }\n            }\n        }\n        return ret;\n    }\n    fn solve(&mut self) {\n        let n = self.n;\n        let e = n - 1;\n        let cnt = self.bfs(e);\n        let mut left = 0;\n        let mut right = e;\n        while right - left > 1 {\n            let mid = (left + right) / 2;\n            if self.bfs(mid) == cnt {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        println!(\"{} {}\", cnt, right);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.init();\n    solver.solve();\n}"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc088/tasks/arc088_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\ntype Graph = Vec<Vec<usize>>;\n\nconst INF: usize = 100000000;\n\nfn combine(c: &Vec<usize>, limit: usize) -> usize {\n    let n = c.len();\n    let mut count = 0;\n    let mut fr = 0;\n    let mut to = n-1;\n    while fr <= to {\n        if c[fr] == INF {\n            fr += 1;\n            continue;\n        }\n        if c[to] == INF {\n            to -= 1;\n            continue;\n        }\n        if fr == to {\n            count += 1;\n            break;\n        } else {\n            count += 1;\n            if c[fr] + c[to] > limit {\n                to -= 1;\n            } else {\n                fr += 1;\n                to -= 1;\n            }\n        }\n    }\n    count\n}\n\nfn dfs(now: usize, par: Option<usize>, limit: usize, g: &Graph) -> (usize, usize) {\n    let mut children = vec![];\n\n    let mut total_count = 0;\n    for &to in &g[now] {\n        if Some(to) == par {\n            continue;\n        }\n        let (len, count) = dfs(to, Some(now), limit, g);\n        assert!(len <= limit);\n        if len == limit {\n            total_count += count + 1;\n        } else {\n            total_count += count;\n            children.push(len);\n        }\n    }\n    if children.len() == 0 {\n        return (1, total_count);\n    }\n\n    children.sort();\n\n    let cn = children.len();\n    let mut best = (combine(&children, limit), 0);\n    for i in 0..cn {\n        let tmp = children[i];\n        children[i] = INF;\n        let r = combine(&children, limit);\n        best = min(best, (r, tmp));\n        children[i] = tmp;\n    }\n    total_count += best.0;\n    (best.1 + 1, total_count)\n}\n\nfn isok(a: usize, b: usize, g: &Graph) -> bool {\n    let (tail, count) = dfs(0, None, b, g);\n    count + ifv!(tail >= 2, 1, 0) <= a\n}\n\nfn solve(a: usize, g: Graph) -> usize {\n    let mut ok = g.len();\n    let mut ng = 0;\n    while ok - ng > 1 {\n        let med = (ok + ng) / 2;\n        if isok(a, med, &g) {\n            ok = med;\n        } else {\n            ng = med;\n        }\n    }\n    ok\n}\n\nfn main() {\n    input! {\n        n: usize,\n        edges: [(usize1, usize1); n-1]\n    };\n\n    let mut g = vec![vec![]; n];\n    for (u, v) in edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut odddeg = 0;\n    for i in 0..n {\n        if g[i].len() % 2 == 1 {\n            odddeg += 1;\n        }\n    }\n    assert!(odddeg % 2 == 0);\n    let a = odddeg / 2;\n    let b = solve(a, g);\n    println!(\"{} {}\", a, b);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc088/tasks/arc088_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\ntype Graph = Vec<Vec<usize>>;\n\nconst INF: usize = 100000000;\n\nfn combine(c: &Vec<usize>, limit: usize) -> usize {\n    let n = c.len();\n    let mut count = 0;\n    let mut fr = 0;\n    let mut to = n-1;\n    while fr <= to {\n        if c[fr] == INF {\n            fr += 1;\n            continue;\n        }\n        if c[to] == INF {\n            to -= 1;\n            continue;\n        }\n        if fr == to {\n            count += 1;\n            break;\n        } else {\n            count += 1;\n            if c[fr] + c[to] > limit {\n                to -= 1;\n            } else {\n                fr += 1;\n                to -= 1;\n            }\n        }\n    }\n    count\n}\n\nfn combine_except(c: &mut Vec<usize>, i: usize, limit: usize) -> usize {\n    let tmp = c[i];\n    c[i] = INF;\n    let r = combine(&c, limit);\n    c[i] = tmp;\n    r\n}\n\nfn dfs(now: usize, par: Option<usize>, limit: usize, g: &Graph) -> (usize, usize) {\n    let mut children = vec![];\n\n    let mut total_count = 0;\n    for &to in &g[now] {\n        if Some(to) == par {\n            continue;\n        }\n        let (len, count) = dfs(to, Some(now), limit, g);\n        assert!(len <= limit);\n        if len == limit {\n            total_count += count + 1;\n        } else {\n            total_count += count;\n            children.push(len);\n        }\n    }\n    if children.len() == 0 {\n        return (1, total_count);\n    }\n\n    children.sort();\n\n    let cn = children.len();\n    let best0 = combine(&children, limit);\n    let mut wbest = combine_except(&mut children, cn-1, limit);\n    let mut ok = (cn-1) as i32;\n    let mut ng = -1;\n\n    while ok - ng > 1 {\n        let med = (ok + ng) / 2;\n        assert!(med >= 0);\n        if wbest == combine_except(&mut children, med as usize, limit) {\n            ok = med;\n        } else {\n            ng = med;\n        }\n    }\n    if best0 == wbest {\n        (1, total_count + best0)\n    } else {\n        (children[ok as usize] + 1, total_count + wbest)\n    }\n}\n\nfn isok(a: usize, b: usize, g: &Graph) -> bool {\n    let (tail, count) = dfs(0, None, b, g);\n    count + ifv!(tail >= 2, 1, 0) <= a\n}\n\nfn solve(a: usize, g: Graph) -> usize {\n    let mut ok = g.len();\n    let mut ng = 0;\n    while ok - ng > 1 {\n        let med = (ok + ng) / 2;\n        if isok(a, med, &g) {\n            ok = med;\n        } else {\n            ng = med;\n        }\n    }\n    ok\n}\n\nfn main() {\n    input! {\n        n: usize,\n        edges: [(usize1, usize1); n-1]\n    };\n\n    let mut g = vec![vec![]; n];\n    for (u, v) in edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut odddeg = 0;\n    for i in 0..n {\n        if g[i].len() % 2 == 1 {\n            odddeg += 1;\n        }\n    }\n    assert!(odddeg % 2 == 0);\n    let a = odddeg / 2;\n    let b = solve(a, g);\n    println!(\"{} {}\", a, b);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Usize1};\n\nfn shallowest(b: usize, d: &[usize]) -> Option<usize> {\n    let n = d.len();\n    assert!(n % 2 == 1);\n    let is_ok = |skip| {\n        let d: Vec<usize> = d[0..skip]\n            .iter()\n            .chain(d[skip + 1..n].iter())\n            .copied()\n            .collect();\n        (0..n / 2).all(|i| d[i] + d[n - 2 - i] <= b)\n    };\n    if is_ok(0) {\n        Some(d[0])\n    } else {\n        let mut l = 0;\n        let mut r = n;\n        while 1 < r - l {\n            let c = (l + r) / 2;\n            if is_ok(c) {\n                r = c;\n            } else {\n                l = c;\n            }\n        }\n        if r < n {\n            Some(d[r])\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    input!(n: usize, uv: [(Usize1, Usize1); n - 1]);\n    let mut g = vec![vec![]; n];\n    for (u, v) in uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n\n    let is_ok = |b| {\n        let mut dp = vec![Some(0); n];\n        fn dfs(b: usize, x: usize, p: usize, dp: &mut [Option<usize>], g: &[Vec<usize>]) {\n            for &y in &g[x] {\n                if y == p {\n                    continue;\n                }\n                dfs(b, y, x, dp, g)\n            }\n            dp[x] = g[x]\n                .iter()\n                .copied()\n                .filter(|&y| y != p)\n                .map(|y| dp[y].and_then(|x| if x < b { Some(x + 1) } else { None }))\n                .collect::<Option<Vec<usize>>>()\n                .and_then(|mut d| {\n                    if g[x].len() % 2 == 1 {\n                        d.push(0);\n                    }\n                    if d.len() % 2 == 0 {\n                        d.push(0);\n                    }\n                    d.sort();\n                    shallowest(b, &d)\n                });\n        }\n        dfs(b, 0, 0, &mut dp, &g);\n        dp[0] == Some(0)\n    };\n    let a = g.iter().filter(|v| v.len() % 2 == 1).count() / 2;\n    let b = {\n        let mut l = 0;\n        let mut r = n;\n        while 1 < r - l {\n            let c = l + (r - l) / 2;\n            if is_ok(c) {\n                r = c;\n            } else {\n                l = c;\n            }\n        }\n        r\n    };\n    println!(\"{} {}\", a, b);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_shallowest() {\n        assert_eq!(shallowest(0, &[0, 1, 2]), None);\n        assert_eq!(shallowest(1, &[0, 1, 2]), Some(2));\n        assert_eq!(shallowest(2, &[0, 1, 2]), Some(1));\n        assert_eq!(shallowest(3, &[0, 1, 2]), Some(0));\n        assert_eq!(shallowest(4, &[0, 1, 2]), Some(0));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct FenwickTree {\n    seq: Vec<i64>,\n}\n#[allow(dead_code)]\nimpl FenwickTree {\n    fn new(n: usize) -> FenwickTree {\n        FenwickTree { seq: vec![0; n + 2] }\n    }\n    fn add(&mut self, index: usize, value: i64) {\n        let mut index = (index + 1) as i32;\n        while (index as usize) < self.seq.len() {\n            self.seq[index as usize] += value;\n            index += index & -index;\n        }\n    }\n    // inclusive\n    fn sum(&self, index: usize) -> i64 {\n        let mut ret = 0;\n        let mut index = (index + 1) as i32;\n        while index > 0 {\n            ret += self.seq[index as usize];\n            index -= index & -index;\n        }\n        ret\n    }\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\n\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n    edge_cnt: Vec<usize>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        Solver {\n            n: 0,\n            g: vec![],\n            edge_cnt: vec![],\n        }\n    }\n    fn init(&mut self) {\n        let n: usize = read();\n        self.n = n;\n        self.g = graph_new(n);\n        self.edge_cnt = vec![usize::max_value(); n - 1];\n        let mut e = 0;\n        for _ in 0..n-1 {\n            let mut a: usize = read();\n            let mut b: usize = read();\n            a -= 1; b -= 1;\n            add_bi_edge(&mut self.g, &mut e, a, b, 0);\n        }\n    }\n    fn merge1(&self, len: usize, childs: &mut Vec<usize>) -> (usize, usize) {\n        let mut rest = 0;\n        let mut minus = 0;\n        childs.sort();\n        childs.reverse();\n        let mut used = vec![false; childs.len()];\n        let mut front = 0;\n        let mut other = vec![];\n        for back in (0..childs.len()).rev() {\n           if used[back] { continue; }\n           while front < back && childs[back] + childs[front] >= len {\n               other.push(front);\n               front += 1;\n            }\n            while !other.is_empty() && *other.last().unwrap() >= back { other.pop(); }\n            if !other.is_empty() {\n               let index = *other.last().unwrap();\n               assert!(childs[index] + childs[back] >= len);\n               assert!(index != back);\n               other.pop();\n               used[back] = true;\n               used[index] = true;\n               minus += 1;\n            }\n        }\n        for i in 0..childs.len() {\n            if !used[i] {\n               rest = childs[i];\n               break;\n            }\n        }\n        (rest, minus)\n    }\n    fn merge2(&self, len: usize, childs: &mut Vec<usize>) -> (usize, usize) {\n        let mut rest = 0;\n        let mut minus = 0;\n        childs.sort();\n        childs.reverse();\n        let mut front = 0;\n        let mut back = childs.len();\n        while front < back && childs[back - 1] == 0 { back -= 1; }\n        while back - front > 1 {\n            if back - front > 2 && childs[front + 1] + childs[back - 1] >= len {\n                childs.swap(front, front + 1);\n                front += 1;\n                back -= 1;\n                minus += 1;\n            } else if childs[front] + childs[back - 1] >= len {\n                front += 1;\n                back -= 1;\n                minus += 1;\n            } else {\n                rest = childs[back - 1];\n                back -= 1;\n            }\n        }\n        if front != back {\n            rest = childs[front];\n        }\n        (rest, minus)\n    }\n    fn bfs(&self, len: usize) -> usize {\n        let n = self.n;\n        let mut childs = vec![vec![]; n];\n        let mut used = vec![false; n - 1];\n        let mut ret = 0;\n        let mut que = VecDeque::new();\n        for i in 0..n {\n            if self.g[i].len() == 1 { que.push_back(i); }\n        }\n        while que.front().is_some() {\n            let from = *que.front().unwrap();\n            que.pop_front();\n            let (rest, minus) = self.merge2(len, &mut childs[from].clone());\n            // let (rest2, minus2) = self.merge2(len, &mut childs[from].clone());\n            // if rest != rest2 || minus != minus2 {\n            //     println!(\"{} {} {} {} {} {:?}\", rest, rest2, minus, minus2, len, childs[from]);\n            //     assert!(false);\n            // }\n            ret -= minus;\n            let mut rest = rest;\n            for edge in self.g[from].clone().iter() {\n                if used[edge.index] { continue; }\n                used[edge.index] = true;\n                if rest == 0 {\n                    rest = len;\n                    ret += 1;\n                }\n                rest -= 1;\n                childs[edge.dest].push(rest);\n                // println!(\"{} {:?}\", edge.dest, self.g[edge.dest]);\n                if childs[edge.dest].len() == self.g[edge.dest].len() - 1 {\n                    que.push_back(edge.dest);\n                }\n            }\n        }\n        return ret;\n    }\n    fn solve(&mut self) {\n        let n = self.n;\n        let e = n - 1;\n        let cnt = self.bfs(e);\n        let mut left = 0;\n        let mut right = e;\n        while right - left > 1 {\n            let mid = (left + right) / 2;\n            if self.bfs(mid) == cnt {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        println!(\"{} {}\", cnt, right);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.init();\n    solver.solve();\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct FenwickTree {\n    seq: Vec<i64>,\n}\n#[allow(dead_code)]\nimpl FenwickTree {\n    fn new(n: usize) -> FenwickTree {\n        FenwickTree { seq: vec![0; n + 2] }\n    }\n    fn add(&mut self, index: usize, value: i64) {\n        let mut index = (index + 1) as i32;\n        while (index as usize) < self.seq.len() {\n            self.seq[index as usize] += value;\n            index += index & -index;\n        }\n    }\n    // inclusive\n    fn sum(&self, index: usize) -> i64 {\n        let mut ret = 0;\n        let mut index = (index + 1) as i32;\n        while index > 0 {\n            ret += self.seq[index as usize];\n            index -= index & -index;\n        }\n        ret\n    }\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\n\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n    edge_cnt: Vec<usize>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        Solver {\n            n: 0,\n            g: vec![],\n            edge_cnt: vec![],\n        }\n    }\n    fn init(&mut self) {\n        let n: usize = read();\n        self.n = n;\n        self.g = graph_new(n);\n        self.edge_cnt = vec![usize::max_value(); n - 1];\n        let mut e = 0;\n        for _ in 0..n-1 {\n            let mut a: usize = read();\n            let mut b: usize = read();\n            a -= 1; b -= 1;\n            add_bi_edge(&mut self.g, &mut e, a, b, 0);\n        }\n    }\n    fn bfs(&self, len: usize) -> i32 {\n        let n = self.n;\n        let mut childs = vec![vec![]; n];\n        let mut used = vec![false; n - 1];\n        let mut ret = 0;\n        let mut que = VecDeque::new();\n        for i in 0..n {\n            if self.g[i].len() == 1 { que.push_back(i); }\n        }\n        while que.front().is_some() {\n            let from = *que.front().unwrap();\n            que.pop_front();\n            let mut rest = 0;\n            {\n                childs[from].sort();\n                childs[from].reverse();\n                let mut childs = childs[from].clone();\n                let mut used = vec![false; childs.len()];\n                for back in (1..childs.len()+1).rev() {\n                    if used[back - 1] { continue; }\n                    for i in (0..back - 1).rev() {\n                        if used[i] { continue; }\n                        if childs[back - 1] + childs[i] >= len {\n                            assert!(back - 1 != i);\n                            used[back - 1] = true;\n                            used[i] = true;\n                            ret -= 1;\n                            // println!(\"{} {} {} {} {}\", len, ret, from, len - childs[back - 1], len - childs[i]);\n                            break;\n                        }\n                    }\n                }\n                for i in 0..childs.len() {\n                    if !used[i] {\n                        // println!(\"{} {} {} {}\", len, ret, i, childs[i]);\n                        rest = childs[i];\n                        break;\n                    }\n                }\n                // let mut front = 0;\n                // let mut back = childs.len();\n                // while front < back && childs[back - 1] == 0 { back -= 1; }\n                // while back - front > 1 {\n                //     if back - front > 2 && childs[front] + childs[back - 2] >= len {\n                //         childs.swap(back - 1, back - 2);\n                //         front += 1;\n                //         back -= 1;\n                //         ret -= 1;\n                //     } else if childs[front] + childs[back - 1] >= len {\n                //         front += 1;\n                //         back -= 1;\n                //         ret -= 1;\n                //     } else {\n                //         rest = childs[back - 1];\n                //         back -= 1;\n                //     }\n                // }\n                // if front != back {\n                //     rest = childs[front];\n                // }\n            }\n            for edge in self.g[from].clone().iter() {\n                if used[edge.index] { continue; }\n                used[edge.index] = true;\n                if rest == 0 {\n                    rest = len;\n                    ret += 1;\n                }\n                rest -= 1;\n                childs[edge.dest].push(rest);\n                // println!(\"{} {:?}\", edge.dest, self.g[edge.dest]);\n                if childs[edge.dest].len() == self.g[edge.dest].len() - 1 {\n                    que.push_back(edge.dest);\n                }\n            }\n        }\n        return ret;\n    }\n    fn solve(&mut self) {\n        let n = self.n;\n        let e = n - 1;\n        let cnt = self.bfs(e);\n        let mut left = 0;\n        let mut right = e;\n        while right - left > 1 {\n            let mid = (left + right) / 2;\n            if self.bfs(mid) == cnt {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        println!(\"{} {}\", cnt, right);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.init();\n    solver.solve();\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nconst INF: usize = 1 << 30;\n\nfn fold(pool: &[usize], x: usize) -> usize {\n    assert_eq!(pool.len() % 2, 0);\n    let n = pool.len();\n    for i in 0..n / 2 {\n        if pool[n - i - 1] + pool[i] > x {\n            return INF;\n        }\n    }\n    0\n}\n\nfn opt(pool: &[usize], x: usize) -> usize {\n    let n = pool.len();\n    assert_eq!(n % 2, 1);\n    let mut pass = n as i32;\n    let mut fail = -1;\n    while pass - fail > 1 {\n        let mid = (pass + fail) / 2;\n        let idx = mid as usize;\n        let mut ok = true;\n        for i in 0..n / 2 {\n            let a = if idx <= i { i + 1 } else { i };\n            let b = if idx <= n - i - 2 { n - i - 1 } else { n - i - 2 };\n            if pool[a] + pool[b] > x {\n                ok = false;\n                break;\n            }\n        }\n        if ok {\n            pass = mid;\n        } else {\n            fail = mid;\n        }\n    }\n    if pass < n as i32 {\n        pool[pass as usize]\n    } else {\n        INF\n    }\n}\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>], x: usize) -> usize {\n    let n = g.len();\n    let mut pool = vec![];\n    if n == par {\n        // Only one child\n        let ch = g[v][0];\n        let dep = dfs(ch, v, g, x);\n        return dep + 1;\n    }\n    for &w in &g[v] {\n        if w == par { continue; }\n        let sub = dfs(w, v, g, x);\n        pool.push(sub + 1);\n    }\n    if pool.len() == 0 {\n        return 0;\n    }\n    pool.sort();\n    let mut mi = INF;\n    if pool.len() % 2 == 0 {\n        if pool[pool.len() - 1] > x {\n            return x + 1;\n        }\n        mi = opt(&pool[..pool.len() - 1], x);\n        mi = min(mi, fold(&pool, x));\n    } else {\n        mi = min(mi, opt(&pool, x));\n    }\n    mi\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        uv: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &uv {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let mut a = 1;\n    for i in 0..n {\n        let d = g[i].len();\n        if d >= 3 {\n            a += (d - 1) / 2;\n        }\n    }\n    let mut r = 0;\n    for i in 0..n {\n        if g[i].len() == 1 {\n            r = i;\n            break;\n        }\n    }\n    // Find the smallest b by binsect.\n    let mut pass = n - 1;\n    let mut fail = 0;\n    while pass - fail > 1 {\n        let mid = (pass + fail) / 2;\n        let res = dfs(r, n, &g, mid);\n        if res <= mid {\n            pass = mid;\n        } else {\n            fail = mid;\n        }\n    }\n    puts!(\"{} {}\\n\", a, pass);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct FenwickTree {\n    seq: Vec<i64>,\n}\n#[allow(dead_code)]\nimpl FenwickTree {\n    fn new(n: usize) -> FenwickTree {\n        FenwickTree { seq: vec![0; n + 2] }\n    }\n    fn add(&mut self, index: usize, value: i64) {\n        let mut index = (index + 1) as i32;\n        while (index as usize) < self.seq.len() {\n            self.seq[index as usize] += value;\n            index += index & -index;\n        }\n    }\n    // inclusive\n    fn sum(&self, index: usize) -> i64 {\n        let mut ret = 0;\n        let mut index = (index + 1) as i32;\n        while index > 0 {\n            ret += self.seq[index as usize];\n            index -= index & -index;\n        }\n        ret\n    }\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\n\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n    edge_cnt: Vec<usize>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        Solver {\n            n: 0,\n            g: vec![],\n            edge_cnt: vec![],\n        }\n    }\n    fn init(&mut self) {\n        let n: usize = read();\n        self.n = n;\n        self.g = graph_new(n);\n        self.edge_cnt = vec![usize::max_value(); n - 1];\n        let mut e = 0;\n        for _ in 0..n-1 {\n            let mut a: usize = read();\n            let mut b: usize = read();\n            a -= 1; b -= 1;\n            add_bi_edge(&mut self.g, &mut e, a, b, 0);\n        }\n    }\n    fn merge(&self, len: usize, childs: &mut Vec<usize>) -> (usize, usize) {\n        let mut rest = 0;\n        let mut minus = 0;\n        childs.sort();\n        childs.reverse();\n        let mut front = 0;\n        let mut back = childs.len();\n        while front < back && childs[back - 1] == 0 { back -= 1; }\n        while back - front > 1 {\n            if back - front > 2 && childs[front + 1] + childs[back - 1] >= len {\n                childs.swap(front, front + 1);\n                front += 1;\n                back -= 1;\n                minus += 1;\n            } else if childs[front] + childs[back - 1] >= len {\n                front += 1;\n                back -= 1;\n                minus += 1;\n            } else {\n                rest = childs[back - 1];\n                back -= 1;\n            }\n        }\n        if front != back {\n            rest = childs[front];\n        }\n        (rest, minus)\n    }\n    fn bfs(&self, len: usize) -> usize {\n        let n = self.n;\n        let mut childs = vec![vec![]; n];\n        let mut used = vec![false; n - 1];\n        let mut ret = 0;\n        let mut que = VecDeque::new();\n        for i in 0..n {\n            if self.g[i].len() == 1 { que.push_back(i); }\n        }\n        while let Some(from) = que.pop_front() {\n            let (mut rest, minus) = self.merge(len, &mut childs[from]);\n            ret -= minus;\n            for edge in self.g[from].iter() {\n                if used[edge.index] { continue; }\n                used[edge.index] = true;\n                if rest == 0 {\n                    rest = len;\n                    ret += 1;\n                }\n                rest -= 1;\n                childs[edge.dest].push(rest);\n                if childs[edge.dest].len() == self.g[edge.dest].len() - 1 {\n                    que.push_back(edge.dest);\n                }\n            }\n        }\n        return ret;\n    }\n    fn solve(&mut self) {\n        let n = self.n;\n        let e = n - 1;\n        let cnt = self.bfs(e);\n        let mut left = 0;\n        let mut right = e;\n        while right - left > 1 {\n            let mid = (left + right) / 2;\n            if self.bfs(mid) == cnt {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        println!(\"{} {}\", cnt, right);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.init();\n    solver.solve();\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct FenwickTree {\n    seq: Vec<i64>,\n}\n#[allow(dead_code)]\nimpl FenwickTree {\n    fn new(n: usize) -> FenwickTree {\n        FenwickTree { seq: vec![0; n + 2] }\n    }\n    fn add(&mut self, index: usize, value: i64) {\n        let mut index = (index + 1) as i32;\n        while (index as usize) < self.seq.len() {\n            self.seq[index as usize] += value;\n            index += index & -index;\n        }\n    }\n    // inclusive\n    fn sum(&self, index: usize) -> i64 {\n        let mut ret = 0;\n        let mut index = (index + 1) as i32;\n        while index > 0 {\n            ret += self.seq[index as usize];\n            index -= index & -index;\n        }\n        ret\n    }\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\n\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n    edge_cnt: Vec<usize>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        Solver {\n            n: 0,\n            g: vec![],\n            edge_cnt: vec![],\n        }\n    }\n    fn init(&mut self) {\n        let n: usize = read();\n        self.n = n;\n        self.g = graph_new(n);\n        self.edge_cnt = vec![usize::max_value(); n - 1];\n        let mut e = 0;\n        for _ in 0..n-1 {\n            let mut a: usize = read();\n            let mut b: usize = read();\n            a -= 1; b -= 1;\n            add_bi_edge(&mut self.g, &mut e, a, b, 0);\n        }\n    }\n    fn bfs(&self, len: usize) -> i32 {\n        let n = self.n;\n        let mut childs = vec![vec![]; n];\n        let mut used = vec![false; n - 1];\n        let mut ret = 0;\n        let mut que = VecDeque::new();\n        for i in 0..n {\n            if self.g[i].len() == 1 { que.push_back(i); }\n        }\n        while que.front().is_some() {\n            let from = *que.front().unwrap();\n            que.pop_front();\n            let mut rest = 0;\n            {\n                childs[from].sort();\n                childs[from].reverse();\n                let mut childs = childs[from].clone();\n                let mut front = 0;\n                let mut back = childs.len();\n                while front < back && childs[back - 1] == 0 { back -= 1; }\n                while back - front > 1 {\n                    if back - front > 2 && childs[front] + childs[back - 2] >= len {\n                        childs.swap(back - 1, back - 2);\n                        front += 1;\n                        back -= 1;\n                        ret -= 1;\n                    } else if childs[front] + childs[back - 1] >= len {\n                        front += 1;\n                        back -= 1;\n                        ret -= 1;\n                    } else {\n                        rest = childs[back - 1];\n                        back -= 1;\n                    }\n                }\n                if front != back {\n                    rest = childs[front];\n                }\n            }\n            for edge in self.g[from].clone().iter() {\n                if used[edge.index] { continue; }\n                used[edge.index] = true;\n                if rest == 0 {\n                    rest = len;\n                    ret += 1;\n                }\n                rest -= 1;\n                childs[edge.dest].push(rest);\n                // println!(\"{} {:?}\", edge.dest, self.g[edge.dest]);\n                if childs[edge.dest].len() == self.g[edge.dest].len() - 1 {\n                    que.push_back(edge.dest);\n                }\n            }\n        }\n        return ret;\n    }\n    fn solve(&mut self) {\n        let n = self.n;\n        let e = n - 1;\n        let cnt = self.bfs(e);\n        let mut left = 0;\n        let mut right = e;\n        while right - left > 1 {\n            let mid = (left + right) / 2;\n            if self.bfs(mid) == cnt {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        println!(\"{} {}\", cnt, right);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.init();\n    solver.solve();\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nconst INF: usize = 1 << 30;\n\nfn fold(pool: &[usize], x: usize) -> usize {\n    assert_eq!(pool.len() % 2, 0);\n    let n = pool.len();\n    for i in 0..n / 2 {\n        if pool[n - i - 1] + pool[i] > x {\n            return INF;\n        }\n    }\n    0\n}\n\nfn opt(pool: &[usize], x: usize) -> usize {\n    let n = pool.len();\n    assert_eq!(n % 2, 1);\n    let mut pass = n as i32;\n    let mut fail = -1;\n    while pass - fail > 1 {\n        let mid = (pass + fail) / 2;\n        let idx = mid as usize;\n        let mut ok = true;\n        for i in 0..n / 2 {\n            let a = if idx <= i { i + 1 } else { i };\n            let b = if idx <= n - i - 2 { n - i - 1 } else { n - i - 1 };\n            if pool[a] + pool[b] > x {\n                ok = false;\n                break;\n            }\n        }\n        if ok {\n            pass = mid;\n        } else {\n            fail = mid;\n        }\n    }\n    if pass < n as i32 {\n        pool[pass as usize]\n    } else {\n        INF\n    }\n}\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>], x: usize) -> usize {\n    let n = g.len();\n    let mut pool = vec![];\n    if n == par {\n        // Only one child\n        let ch = g[v][0];\n        let dep = dfs(ch, v, g, x);\n        return dep + 1;\n    }\n    for &w in &g[v] {\n        if w == par { continue; }\n        let sub = dfs(w, v, g, x);\n        pool.push(sub + 1);\n    }\n    if pool.len() == 0 {\n        return 0;\n    }\n    pool.sort();\n    let mut mi = INF;\n    if pool.len() % 2 == 0 {\n        if pool[pool.len() - 1] > x {\n            return x + 1;\n        }\n        mi = opt(&pool[..pool.len() - 1], x);\n        mi = min(mi, fold(&pool, x));\n    } else {\n        mi = min(mi, opt(&pool, x));\n    }\n    mi\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        uv: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &uv {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let mut a = 1;\n    for i in 0..n {\n        let d = g[i].len();\n        if d >= 3 {\n            a += (d - 1) / 2;\n        }\n    }\n    let mut r = 0;\n    for i in 0..n {\n        if g[i].len() == 1 {\n            r = i;\n            break;\n        }\n    }\n    // Find the smallest b by binsect.\n    let mut pass = n - 1;\n    let mut fail = 0;\n    while pass - fail > 1 {\n        let mid = (pass + fail) / 2;\n        let res = dfs(r, n, &g, mid);\n        if res <= mid {\n            pass = mid;\n        } else {\n            fail = mid;\n        }\n    }\n    puts!(\"{} {}\\n\", a, pass);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]