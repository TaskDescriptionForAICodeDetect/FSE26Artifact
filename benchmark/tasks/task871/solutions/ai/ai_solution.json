[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 200005\n\nint parent[MAX_N];\nint rank[MAX_N];\nint n;\n\nvoid init_dsu() {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else {\n        parent[py] = px;\n        if (rank[px] == rank[py]) {\n            rank[px]++;\n        }\n    }\n}\n\nbool is_connected() {\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        if (find(i) != root) return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int a = 0; a <= n; a++) {\n        for (int b = 0; b <= n; b++) {\n            init_dsu();\n            int paths_count = 0;\n            \n            // Try to make Christmas Tree\n            for (int x = 1; x <= n; x++) {\n                for (int y = x + 1; y <= n; y++) {\n                    if (paths_count >= a) break;\n                    \n                    // Check path length\n                    int path_length = y - x;\n                    if (path_length > b) continue;\n                    \n                    // Connect vertices in path\n                    for (int k = x; k < y; k++) {\n                        unite(k, k + 1);\n                    }\n                    \n                    paths_count++;\n                }\n                if (paths_count >= a) break;\n            }\n            \n            // Check if tree is connected\n            if (is_connected() && paths_count == a) {\n                printf(\"%d %d\\n\", a, b);\n                return 0;\n            }\n        }\n    }\n    \n    printf(\"-1\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N + 5];\nint head[MAX_N + 5];\nint edge_count = 0;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nint degree[MAX_N + 5];\nint queue[MAX_N + 5];\nint front, rear;\n\nvoid init() {\n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n    front = rear = 0;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    init();\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n        degree[a]++;\n        degree[b]++;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (degree[i] == 1) {\n            queue[rear++] = i;\n        }\n    }\n\n    int A = 0, B = 0;\n    int remaining = N;\n\n    while (remaining > 2) {\n        int current_size = rear - front;\n        int pairs = current_size / 2;\n        A += pairs;\n        B += 1;\n        remaining -= pairs * 2;\n        for (int i = 0; i < pairs * 2; i++) {\n            int u = queue[front++];\n            for (int j = head[u]; j != -1; j = edges[j].next) {\n                int v = edges[j].to;\n                if (degree[v] > 0) {\n                    degree[v]--;\n                    if (degree[v] == 1) {\n                        queue[rear++] = v;\n                    }\n                }\n            }\n        }\n    }\n\n    if (remaining == 2) {\n        A += 1;\n        B += 1;\n    } else if (remaining == 1) {\n        A += 1;\n    }\n\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<int> degrees(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        degrees[i] = adj[i].size();\n    }\n\n    priority_queue<int, vector<int>, greater<int>> leaves;\n    for (int i = 1; i <= N; ++i) {\n        if (degrees[i] == 1) {\n            leaves.push(i);\n        }\n    }\n\n    vector<int> paths;\n    while (leaves.size() > 2) {\n        int u = leaves.top();\n        leaves.pop();\n        int v = leaves.top();\n        leaves.pop();\n        paths.push_back(u);\n        paths.push_back(v);\n        for (int neighbor : adj[u]) {\n            if (--degrees[neighbor] == 1) {\n                leaves.push(neighbor);\n            }\n        }\n        for (int neighbor : adj[v]) {\n            if (--degrees[neighbor] == 1) {\n                leaves.push(neighbor);\n            }\n        }\n    }\n\n    if (leaves.size() == 2) {\n        int u = leaves.top();\n        leaves.pop();\n        int v = leaves.top();\n        paths.push_back(u);\n        paths.push_back(v);\n    } else if (leaves.size() == 1) {\n        int u = leaves.top();\n        paths.push_back(u);\n    }\n\n    int A = (paths.size() + 1) / 2;\n    int B = 1;\n    cout << A << \" \" << B << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:12:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        UnionFind(int n) {\n            parent = new int[n + 1];\n            rank = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int xRoot = find(x);\n            int yRoot = find(y);\n            if (xRoot == yRoot) {\n                return false;\n            }\n            if (rank[xRoot] < rank[yRoot]) {\n                parent[xRoot] = yRoot;\n            } else if (rank[yRoot] < rank[xRoot]) {\n                parent[yRoot] = xRoot;\n            } else {\n                parent[yRoot] = xRoot;\n                rank[xRoot]++;\n            }\n            return true;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        List<int[]> edges = new ArrayList<>();\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            edges.add(new int[]{a, b});\n        }\n\n        int low = 1, high = N - 1;\n        int bestA = N - 1, bestB = 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (isPossible(N, edges, mid)) {\n                bestA = mid;\n                bestB = (N - 1 + mid - 1) / mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        System.out.println(bestA + \" \" + bestB);\n    }\n\n    static boolean isPossible(int N, List<int[]> edges, int A) {\n        UnionFind uf = new UnionFind(N);\n        int components = N;\n        for (int[] edge : edges) {\n            if (uf.union(edge[0], edge[1])) {\n                components--;\n                if (components == 1) {\n                    break;\n                }\n            }\n        }\n        if (components != 1) {\n            return false;\n        }\n\n        int maxDegree = 0;\n        int[] degree = new int[N + 1];\n        for (int[] edge : edges) {\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n            maxDegree = Math.max(maxDegree, Math.max(degree[edge[0]], degree[edge[1]]));\n        }\n        return maxDegree <= A;\n    }\n}",
    "timestamp": "2025-08-05 23:12:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ChristmasTree {\n    static int N;\n    static List<List<Integer>> graph;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        \n        for (int A = 0; A <= N * (N - 1) / 2; A++) {\n            for (int B = 1; B <= N - 1; B++) {\n                if (canConstructTree(A, B)) {\n                    System.out.println(A + \" \" + B);\n                    return;\n                }\n            }\n        }\n    }\n    \n    static boolean canConstructTree(int A, int B) {\n        graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        int pathCount = 0;\n        \n        for (int start = 0; start < N; start++) {\n            for (int end = start + 1; end < N; end++) {\n                int pathLength = bfs(start, end);\n                if (pathLength <= B) {\n                    pathCount++;\n                }\n            }\n        }\n        \n        return pathCount >= A && isConnected();\n    }\n    \n    static int bfs(int start, int end) {\n        boolean[] visited = new boolean[N];\n        int[] dist = new int[N];\n        Queue<Integer> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited[start] = true;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            if (current == end) {\n                return dist[end];\n            }\n            \n            for (int neighbor : graph.get(current)) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                    dist[neighbor] = dist[current] + 1;\n                }\n            }\n        }\n        \n        return Integer.MAX_VALUE;\n    }\n    \n    static boolean isConnected() {\n        boolean[] visited = new boolean[N];\n        dfs(0, visited);\n        \n        for (boolean v : visited) {\n            if (!v) return false;\n        }\n        \n        return true;\n    }\n    \n    static void dfs(int node, boolean[] visited) {\n        visited[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, visited);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:12:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> graph(N+1);\n    vector<int> edges(N+1);\n    \n    for (int i = 1; i < N; i++) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        edges[a]++;\n        edges[b]++;\n    }\n    \n    int A = 0, B = 0;\n    \n    for (B = 0; B < N; B++) {\n        A = 0;\n        vector<bool> visited(N+1, false);\n        \n        for (int start = 1; start <= N; start++) {\n            if (!visited[start]) {\n                vector<int> path;\n                int current = start;\n                path.push_back(current);\n                visited[current] = true;\n                \n                while (path.size() <= B + 1) {\n                    bool found = false;\n                    for (int neighbor : graph[current]) {\n                        if (!visited[neighbor]) {\n                            current = neighbor;\n                            path.push_back(current);\n                            visited[current] = true;\n                            found = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!found) break;\n                }\n                \n                if (path.size() == B + 1) {\n                    A++;\n                }\n            }\n        }\n        \n        bool allVisited = true;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                allVisited = false;\n                break;\n            }\n        }\n        \n        if (allVisited) {\n            break;\n        }\n    }\n    \n    cout << A << \" \" << B << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_christmas_tree(N):\n    if N == 2:\n        return (1, 1)\n    for B in range(1, N):\n        A = (N - 1 + B - 1) // B\n        if A * B >= N - 1:\n            return (A, B)\n    return (N - 1, 1)\n\nN = int(input().strip())\nA, B = find_christmas_tree(N)\nprint(A, B)",
    "timestamp": "2025-08-13 14:02:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ChristmasTree {\n\n    public static int[] findSmallestPair(int N) {\n        int[] result = new int[2]; // A and B\n\n        // Initialize the tree with N nodes and no edges\n        List<Integer>[] tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n\n        // Attempt to find the smallest pair (A, B)\n        int A = 0, B = N - 1;\n        while (true) {\n            // Clear the tree edges\n            for (int i = 1; i <= N; i++) {\n                tree[i].clear();\n            }\n\n            // Attempt to construct the tree using the current A and B values\n            boolean possible = constructTree(tree, A, B, N);\n            if (possible) {\n                result[0] = A;\n                result[1] = B;\n                break;\n            }\n            A++;\n            B++;\n        }\n\n        return result;\n    }\n\n    private static boolean constructTree(List<Integer>[] tree, int A, int B, int N) {\n        int[] degrees = new int[N + 1];\n        List<Integer> leaves = new ArrayList<>();\n        \n        // Initialize leaves as all nodes except for 1\n        for (int i = 2; i <= N; i++) {\n            leaves.add(i);\n        }\n\n        // Construct paths of length at most B\n        for (int i = 0; i < A; i++) {\n            if (leaves.isEmpty()) return false; // No more leave nodes available\n\n            int pathStart = leaves.remove(0); // Start of the path\n            int pathLength = Math.min(N - 1, B); // Determine max length for the current path\n\n            for (int j = 0; j < pathLength; j++) {\n                if (leaves.isEmpty()) return false; // Not enough nodes to complete path\n\n                int nextNode = leaves.remove(0);\n                tree[pathStart].add(nextNode);\n                tree[nextNode].add(pathStart);\n\n                pathStart = nextNode;\n            }\n        }\n\n        // Final check for connectivity\n        return checkConnectivity(tree, 1, N);\n    }\n\n    private static boolean checkConnectivity(List<Integer>[] tree, int start, int N) {\n        boolean[] visited = new boolean[N + 1];\n        dfs(tree, start, visited);\n\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) return false;\n        }\n        return true;\n    }\n\n    private static void dfs(List<Integer>[] tree, int node, boolean[] visited) {\n        visited[node] = true;\n        for (int neighbor : tree[node]) {\n            if (!visited[neighbor]) {\n                dfs(tree, neighbor, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int N = 7; // Example Input: Number of vertices\n        int[] result = findSmallestPair(N);\n        \n        // Print the result\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-13 14:03:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Handle the trivial case\n    if (N == 1) {\n        printf(\"0 0\\n\");\n        return 0;\n    }\n\n    int A = N - 1; // Start with maximum possible A (i.e., N-1 paths)\n    int B;\n    int max_possible_B = N - 1; // Maximum possible B (all vertices in a single path)\n    int *degree = (int *)calloc(N + 1, sizeof(int)); // Track degrees of vertices\n    \n    for (B = 1; B <= max_possible_B; B++) {\n        // Reset degree array for each B\n        for (int i = 0; i <= N; i++) degree[i] = 0;\n\n        // Start constructing paths with length <= B\n        int current_vertex = 1;\n        for (int path = 0; path < A; path++) {\n            int length = 0;\n            for (int i = 0; i < N && length < B; ) {\n                if (degree[current_vertex] < 2) { // Max 2 degree for central path vertices\n                    degree[current_vertex]++;\n                    i++;\n                    length++;\n                    if (i < N) current_vertex = i + 1;\n                } else {\n                    break;\n                }\n            }\n            if (length < B) break; // Path is shorter than allowed\n        }\n\n        // Check if all vertices are covered\n        int vertices_covered = 0;\n        for (int i = 1; i <= N; i++) {\n            if (degree[i] > 0) vertices_covered++;\n        }\n\n        if (vertices_covered == N) {\n            break;\n        }\n    }\n    \n    free(degree);\n    printf(\"%d %d\\n\", A, B);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:03:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> edges(N-1);\n    for (int i = 0; i < N-1; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    pair<int, int> best = {INT_MAX, INT_MAX};\n\n    for (int A = 1; A <= N; ++A) {\n        for (int B = 1; B <= N; ++B) {\n            vector<vector<int>> paths(A);\n            int curr = 1;\n\n            for (int i = 0; i < A; ++i) {\n                for (int j = 0; j < min(B, N-curr+1); ++j) {\n                    paths[i].push_back(curr++);\n                }\n            }\n\n            if (curr <= N && paths.size() == A) {\n                bool valid = true;\n                vector<bool> visited(N+1, false);\n                for (auto& path : paths) {\n                    for (int node : path) visited[node] = true;\n                }\n                for (bool v : visited) {\n                    if (!v) valid = false;\n                }\n\n                if (valid) {\n                    best = min(best, {A, B});\n                }\n            }\n        }\n    }\n\n    cout << best.first << \" \" << best.second << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:03:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N):\n    # Try all possible combinations of A and B\n    for B in range(N):\n        for A in range(N + 1):\n            # Create a graph that can satisfy the conditions\n            graph = [[] for _ in range(N)]\n            \n            # Connect vertices in a star topology\n            for i in range(1, N):\n                graph[0].append(i)\n                graph[i].append(0)\n            \n            # Count paths of length at most B\n            paths = 0\n            for start in range(N):\n                for end in range(N):\n                    if start != end:\n                        # DFS to find paths\n                        visited = [False] * N\n                        path_length = dfs(graph, start, end, visited, 0, B)\n                        if path_length <= B:\n                            paths += 1\n            \n            # Check if the conditions are met\n            if paths >= A:\n                return A, B\n    \n    return -1, -1\n\ndef dfs(graph, current, target, visited, length, max_length):\n    if length > max_length:\n        return float('inf')\n    \n    if current == target:\n        return length\n    \n    visited[current] = True\n    min_path = float('inf')\n    \n    for neighbor in graph[current]:\n        if not visited[neighbor]:\n            path = dfs(graph, neighbor, target, visited, length + 1, max_length)\n            min_path = min(min_path, path)\n    \n    visited[current] = False\n    return min_path\n\n# Read input\nN = int(input())\n\n# Find solution\nA, B = solve(N)\n\n# Print result\nprint(A, B)",
    "timestamp": "2025-08-13 14:03:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Find the diameter of the tree using BFS twice\n    def bfs(start):\n        dist = [-1] * (N+1)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        farthest_node = start\n        max_dist = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n                    if dist[v] > max_dist:\n                        max_dist = dist[v]\n                        farthest_node = v\n        return farthest_node, max_dist\n    \n    u, _ = bfs(1)\n    v, diameter = bfs(u)\n    \n    A = 1\n    B = diameter\n    print(A, B)\n\nsolve()",
    "timestamp": "2025-08-13 14:03:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findSmallestChristmasTree(n, edges) {\n    const adjacencyList = Array.from({ length: n + 1 }, () => []);\n    for (const [a, b] of edges) {\n        adjacencyList[a].push(b);\n        adjacencyList[b].push(a);\n    }\n\n    function bfs(start) {\n        const queue = [start];\n        const distances = Array(n + 1).fill(-1);\n        distances[start] = 0;\n\n        let furthestVertex = start;\n        while (queue.length > 0) {\n            const vertex = queue.shift();\n            for (const neighbor of adjacencyList[vertex]) {\n                if (distances[neighbor] === -1) {\n                    distances[neighbor] = distances[vertex] + 1;\n                    queue.push(neighbor);\n                    if (distances[neighbor] > distances[furthestVertex]) {\n                        furthestVertex = neighbor;\n                    }\n                }\n            }\n        }\n        return [furthestVertex, distances[furthestVertex]];\n    }\n\n    const [end1, _] = bfs(1);\n    const [end2, maxLength] = bfs(end1);\n\n    return [2, maxLength];\n}\n\n// Example usage:\n// const n = 5;\n// const edges = [\n//     [1, 2],\n//     [2, 3],\n//     [3, 4],\n//     [4, 5]\n// ];\n// console.log(findSmallestChristmasTree(n, edges)); // Outputs [2, 4]",
    "timestamp": "2025-08-13 14:03:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N) {\n    for (let A = 0; A <= N * (N - 1) / 2; A++) {\n        for (let B = 1; B <= N - 1; B++) {\n            if (canConstructTree(N, A, B)) {\n                return [A, B];\n            }\n        }\n    }\n    return [-1, -1];\n}\n\nfunction canConstructTree(N, A, B) {\n    if (A > N * (N - 1) / 2) return false;\n    \n    const graph = Array.from({ length: N }, () => []);\n    const used = new Array(N).fill(false);\n    let paths = 0;\n    \n    function dfs(node, pathLength) {\n        used[node] = true;\n        if (pathLength > B) return false;\n        \n        for (let neighbor of graph[node]) {\n            if (!used[neighbor]) {\n                if (dfs(neighbor, pathLength + 1)) return true;\n            }\n        }\n        return true;\n    }\n    \n    function addEdge(u, v) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    for (let i = 1; i < N; i++) {\n        addEdge(0, i);\n        paths++;\n    }\n    \n    if (paths > A) return false;\n    \n    used.fill(false);\n    return dfs(0, 0);\n}\n\nlet [N] = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n').map(Number);\nconst result = solve(N);\nconsole.log(result[0], result[1]);",
    "timestamp": "2025-08-13 14:03:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nfunction solve() {\n    const N = parseInt(input[0], 10);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 1; i < N; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n\n    const degrees = adj.map(edges => edges.length);\n    const leaves = [];\n    for (let i = 1; i <= N; i++) {\n        if (degrees[i] === 1) {\n            leaves.push(i);\n        }\n    }\n\n    if (leaves.length === 2) {\n        console.log(1, N - 1);\n        return;\n    }\n\n    const visited = new Array(N + 1).fill(false);\n    const queue = [];\n    queue.push(leaves[0]);\n    visited[leaves[0]] = true;\n    let lastNode = leaves[0];\n\n    while (queue.length > 0) {\n        const u = queue.shift();\n        lastNode = u;\n        for (const v of adj[u]) {\n            if (!visited[v] && degrees[v] <= 2) {\n                visited[v] = true;\n                queue.push(v);\n            }\n        }\n    }\n\n    const visited2 = new Array(N + 1).fill(false);\n    const distance = new Array(N + 1).fill(0);\n    queue.length = 0;\n    queue.push(lastNode);\n    visited2[lastNode] = true;\n    let maxDist = 0;\n    let farthestNode = lastNode;\n\n    while (queue.length > 0) {\n        const u = queue.shift();\n        for (const v of adj[u]) {\n            if (!visited2[v] && degrees[v] <= 2) {\n                visited2[v] = true;\n                distance[v] = distance[u] + 1;\n                if (distance[v] > maxDist) {\n                    maxDist = distance[v];\n                    farthestNode = v;\n                }\n                queue.push(v);\n            }\n        }\n    }\n\n    const A = leaves.length;\n    const B = maxDist;\n    console.log(A, B);\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:03:56"
  }
]