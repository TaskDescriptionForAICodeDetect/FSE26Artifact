[
  {
    "language": "Fortran",
    "code": "program neither_AB_nor_BA\n  implicit none\n  integer(8), parameter :: md = 998244353_8\n  integer(8) :: n, i, p = 1_8, c = 1_8, x = 0_8\n  read(*,*) n\n  do i = 0_8, (n-1_8)/2_8\n    x = mod(x+p*c,md)\n    p = mod(2_8*p,md)\n    c = mod(c*(n-i),md)\n    c = mod(c*inv(i+1_8),md)\n  end do\n  write(*,'(i0)') modulo(pow(3_8,int(n,4))-2_8*x,md)\ncontains\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = modulo(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = modulo(y,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: k\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    k = b\n    do while (k > 0)\n      if (btest(k,0)) r = mod(r*p,md)\n      p = mod(p*p,md)\n      k = rshift(k,1)\n    end do\n  end\nend program neither_AB_nor_BA"
  },
  {
    "language": "Fortran",
    "code": "module mod_modint\n  implicit none\n  integer(8) :: modulus = 998244353\n  type modint\n    private\n    integer(8) :: num\n  contains\n    procedure :: get => getnum\n  end type\n\n  interface assignment(=)\n    module procedure :: setm, seti64, seti32\n  end interface assignment(=)\n\n  interface operator(+)\n    module procedure :: posm, addmm, addmi64, addmi32, addi64m, addi32m\n  end interface operator(+)\n\n  interface operator(-)\n    module procedure :: negm, submm, submi64, submi32, subi64m, subi32m\n  end interface operator(-)\n\n  interface operator(*)\n    module procedure :: mulmm, mulmi64, mulmi32, muli64m, muli32m\n  end interface operator(*)\n\n  interface operator(/)\n    module procedure :: divmm, divmi64, divmi32, divi64m, divi32m\n  end interface operator(/)\n\n  interface operator(**)\n    module procedure :: powmi64, powmi32\n  end interface operator(**)\n\n  interface inv\n    module procedure :: invm\n  end interface inv\n\ncontains\n\n  integer(8) function getnum(this)\n    class(modint), intent(in) :: this\n    getnum = this%num\n  end\n\n  pure elemental type(modint) function newm()\n    newm%num = 0_8\n  end\n\n  pure elemental subroutine setm(x,y)\n    type(modint), intent(inout) :: x\n    type(modint), intent(in) :: y\n    x%num = y%num\n  end\n\n  pure elemental function posm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = x%num\n  end\n\n  pure elemental function negm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = modulus-x%num\n  end\n\n  pure elemental function addmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num+y%num\n    if (n%num >= modulus) n%num = n%num-modulus\n  end\n\n  pure elemental function submm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num-y%num\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  pure elemental function mulmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = mod(x%num*y%num,modulus)\n  end\n\n  impure elemental function invm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    integer(8) :: a, b, c, q, r, v\n    a = x%num\n    if (a == 0_8) then\n      write(*,'(a)') \"Error: Division by zero (x == 0). (modint, invm)\"\n      stop\n    end if\n    b = modulus\n    c = 0_8\n    v = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      r = mod(a,b)\n      a = b\n      b = r\n      r = c\n      c = v-c*q\n      v = r\n    end do\n    n%num = mod(v,modulus)\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  impure elemental function divmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n = mulmm(x,invm(y))\n  end\n\n  impure elemental type(modint) function newi(i)\n    class(*), intent(in) :: i\n    select type(i)\n    type is (integer(8))\n      newi%num = i\n    type is (integer)\n      newi%num = int(i,8)\n    type is (integer(2))\n      newi%num = int(i,8)\n    type is (integer(1))\n      newi%num = int(i,8)\n    class default\n      write(*,'(a)') \"Error: Invalid value (i is not integer). (modint, newi)\"\n      stop\n    end select\n    newi%num = mod(newi%num,modulus)\n    if (newi%num < 0_8) newi%num = newi%num+modulus\n  end\n\n  impure elemental subroutine seti64(x,i)\n    type(modint), intent(inout) :: x\n    integer(8), intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental subroutine seti32(x,i)\n    type(modint), intent(inout) :: x\n    integer, intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental function addmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function addi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function submi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function submi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function subi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function subi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function mulmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function mulmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function muli64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function muli32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function divmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function divi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function powmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n, p\n    integer(8) :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0_8) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0_8)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\n  impure elemental function powmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n, p\n    integer :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\nend module mod_modint\nmodule mod_modint_comb\nuse mod_modint\ntype(modint),allocatable,dimension(:)::Fact,i_Fact\ncontains\nsubroutine init_comb(maxN)\n    integer::maxN\n    integer::i\n    allocate(Fact(0:maxN),i_Fact(0:maxN))\n    Fact(0)=1\n    do i=1,maxN\n        Fact(i)=Fact(i-1)*i\n    end do\n    i_Fact(maxN)=1/Fact(maxN)\n    do i=maxN-1,0,-1\n        i_Fact(i)=i_Fact(i+1)*(i+1)\n    end do\nend subroutine\ntype(modint) function Comb(N,K)\n  integer::N,K\n  Comb=Fact(N)*i_Fact(K)*i_Fact(N-K)\nend function\nend module mod_modint_comb\nprogram A\n  use mod_modint\n  use mod_modint_comb\n  implicit none\n  integer::N,i\n  type(modint)::ans,sum\n  type(modint),allocatable,dimension(:)::pow2\n  read*,N\n  N=N/2\n  call init_comb(N)\n  allocate(pow2(0:N))\n  pow2(0)=1\n  do i=1,N\n    pow2(i)=pow2(i-1)*2\n  end do\n\n  ans=0;sum=pow2(N)\n  do i=0,N\n    ans=ans+2*Comb(N,i)*pow2(N-i)*sum-Comb(N,i)*pow2(N-i)*Comb(N,i)*pow2(N-i)\n    if(i/=N)sum=sum+comb(N,i+1)*pow2(N-i-1)-comb(N,i)*pow2(i)\n  end do\n  print\"(I0)\",getnum(ans)\ncontains\nend program A"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static const int MOD = 998244353;\n\n    int v;\n    modint(const int _v = 0): v(_v % MOD) {\n        if (v < 0) v += MOD;\n    }\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = 1LL * v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint(v) += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint(v) -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint(v) *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint(v) /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res = 1;\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nconstexpr int MAXN = 1e5;\nmodint fact[MAXN], tcaf[MAXN];\n\nvoid gen_fact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    tcaf[MAXN - 1] = modint(1) / fact[MAXN - 1];\n    for (int i = MAXN - 2; i >= 0; --i) {\n        tcaf[i] = tcaf[i + 1] * (i + 1);\n    }\n}\n\nmodint choose(int n, int k) {\n    assert(n >= 0);\n    if (k < 0 or n < k)\n        return 0;\n\n    return fact[n] * tcaf[k] * tcaf[n - k];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(3, n);\n    modint cur = 0;\n    modint term = 1;\n    modint p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= (n - k + 1);\n        term *= k;\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass combination{\nprivate:\n    vector<mint> fact,inv,finv;\npublic:\n    combination(int N){\n        fact = inv = finv = vector<mint>(N+1);\n        fact[0] = fact[1] = 1;\n        inv[0] = inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(ll i=2;i<=N;i++){\n            fact[i] = fact[i-1]*i;\n//            inv[i] = (mint) mod - inv[mod%i]*(mod/i);\n            finv[i] = fact[i].inv();\n        }\n    }\n    mint f(int i){\n        return fact[i];\n    }\n    mint comb(int n,int k){\n        if(n<k) return 0;\n        if(n<0 || k<0) return 0;\n        return fact[n]*finv[k]*finv[n-k];\n    }\n    mint hcomb(int n,int k){\n        if(n==0 && k==0) return 1;\n        return comb(n+k-1,k);\n    }\n};\n\n\nint main(){\n    int N;\n    cin >> N;\n    mint ans = 1;\n    combination c(N);\n    vector<mint> beki2(N+1,1);\n    for(int i=1;i<=N;i++) beki2[i] = beki2[i-1]*2;\n    for(int i=0;i<N;i++) ans *= 3;\n    for(int i=N/2+1;i<=N;i++) ans -= c.comb(N,i)*beki2[N-i]*2;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define MP make_pair\n#define MT make_tuple\n#define EPS (1e-7)\n#define INF (1e18)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\n \nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n \nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n \nll KAI(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI(m-1)%MOD;\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n \nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)%MOD*modinv(KAI(n)%MOD*KAI(m-n)%MOD)%MOD;\n}\n \nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)//xのm進数でのx^nの位の値\n{\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)//xのn進数での桁数\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)//x!のnで割り切れる回数\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)//xのnで割り切れる回数\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n \nll SUP(ll x,ll n)//xのnで割れなくなるまで割ったときの余り\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll SGS(ll x,ll y, ll m)//1+x+…+x^(y-1)をmで割った余り\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)//Σ[k=1→y](1+x+…+x^(k-1))をmで割った余り\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n\nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n\nstruct edge{ll to, cost;};\nstruct graph{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n\n  graph(ll n){\n    init(n);\n  }\n\n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n\n  void add_edge(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n\n  void dijkstra(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nll d[300][300];\n\nvoid warshall_floyd(ll n){  \n  rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){ \n      s+=b[i];\n      i-=i&-i;\n    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\nint main(){ \n  ll n,c[11000000],b[11000000],ans;\n  cin >> n;\n  c[0]=1;\n  rep(i,1e7+10){\n    c[i+1]=c[i]*(n-i)%MOD*modinv(i+1)%MOD;\n  }\n  b[0]=1;\n  rep(i,1e7+10){\n    b[i+1]=b[i]*2%MOD;\n  }\n  ans=POW(3,n);\n  FOR(i,n/2+1,n+1){\n    ans-=c[i]*b[n-i]*2;\n    ans%=MOD;\n  }\n  ans=mod(ans,MOD);\n  printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INCANT cin.tie(0), cout.tie(0), ios::sync_with_stdio(false), cout << fixed << setprecision(20);\n#define int long long\n#define gcd __gcd\n#define all(x) (x).begin(), (x).end()\ntemplate<class T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<class T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(...) _overload(__VA_ARGS__, repi, _rep)(__VA_ARGS__)\n#define _rev(i, n) revi(i, n, 0)\n#define revi(i, a, b) for(int i = (int)(a - 1); i >= (int)(b); i--)\n#define rev(...) _overload(__VA_ARGS__, revi, _rev)(__VA_ARGS__)\n#define each(i, n) for(auto&& i: n)\nconst int INF = 1e18, MOD = 1e9 + 7;\nint extgcd(int a, int b, int &x, int &y) {\n    int g = a;\n    x = 1, y = 0;\n    if(b) {\n        g = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n    }\n    return g;\n}\nint invmod(int a, int m = MOD){\n    int x = 0, y = 0;\n    extgcd(a, m, x, y);\n    return (x + m) % m;\n}\nstruct modint{\n    int _num;\n    modint(int x = 0) : _num(){\n        _num = x % MOD;\n        if(_num < 0) _num += MOD;\n    }\n    modint operator =  (int x) {\n        _num = x % MOD;\n        if(_num < 0) _num += MOD;\n        return *this;\n    }\n    modint operator =  (modint x) {\n        _num = x._num;\n        return *this;\n    }\n    modint operator +  (int x) {return modint(_num + x);}\n    modint operator +  (modint x) {\n        int a = _num + x._num;\n        if(a >= MOD) a -= MOD;\n        return modint{a};\n    }\n    modint operator += (int x) {\n        _num += x, _num %= MOD;\n        if(_num < 0) _num += MOD;\n        return *this;\n    }\n    modint operator += (modint x) {\n        _num += x._num;\n        if(_num >= MOD) _num -= MOD;\n        return *this;\n    }\n    modint operator ++ () {\n        _num++;\n        if(_num == MOD) _num = 0;\n        return *this;\n    }\n    modint operator -  (int x) {return modint(_num - x);}\n    modint operator -  (modint x) {\n        int a = _num - x._num;\n        if(a < 0) a += MOD;\n        return modint{a};\n    }\n    modint operator -= (int x) {\n        _num -= x, _num %= MOD;\n        if(_num < 0) _num += MOD;\n        return *this;\n    }\n    modint operator -= (modint x) {\n        _num -= x._num;\n        if(_num < 0) _num += MOD;\n        return *this;\n    }\n    modint operator -- () {\n        _num--;\n        if(_num == -1) _num = MOD - 1;\n        return *this;\n    }\n    modint operator *  (int x) {return modint(_num * (x % MOD));}\n    modint operator *  (modint x) {return modint{_num * x._num % MOD};}\n    modint operator *= (int x) {\n        _num *= modint(x), _num %= MOD;\n        return *this;\n    }\n    modint operator *= (modint x) {\n        _num *= x._num, _num %= MOD;\n        return *this;\n    }\n    modint operator /  (int x) {return modint(_num * invmod(modint(x), MOD));}\n    modint operator /  (modint x) {return modint{_num * invmod(x._num, MOD) % MOD};}\n    modint operator /= (int x) {\n        _num *= invmod(modint(x), MOD), _num %= MOD;\n        return *this;\n    }\n    modint operator /= (modint x) {\n        _num *= invmod(x._num, MOD), _num %= MOD;\n        return *this;\n    }\n    modint pow(int x) {\n        modint ans = 1, cnt = *this;\n        for(int i = 1; i < x + 1; i *= 2) {\n            if(x & i) ans *= cnt; x ^= i;\n            cnt *= cnt;\n        }\n        return ans;\n    }\n    operator int() {return _num;}\n};\nvector<modint> fac(1, 1), inv(1, 1);\nvoid reserve(int a) {\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= MOD) a = MOD;\n    while(fac.size() < a) fac.push_back(fac.back() * (int)(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = modint(1) / fac.back();\n    for(int i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\nmodint comb(int n, int r){\n    if(r < 0 || n < r) return 0;\n    reserve(n + 1);\n    return fac[n] * inv[r] * inv[n - r];\n}\nsigned main() {\n    INCANT;\n    int n, v[11111111] = {1};\n    cin>>n;\n    modint res = modint(3).pow(n);\n    rep(i, n){\n        v[i + 1] = v[i];\n        v[i + 1] *= 2;\n    }\n    rep(i, n / 2 + 1, n + 1){\n        res -= 2 * comb(n, i) * v[n - i];\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=b-1LL;i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define endl \"\\n\"\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nll f(string s){\n  if(s.sz==0){\n    return 1;\n  }\n  ll ret = 0;\n  rep(i,0,s.sz-1){\n    if(s[i]=='A'&&s[i+1]=='B')continue;\n    if(s[i]=='B'&&s[i+1]=='A')continue;\n    string s1;\n    rep(j,0,i){\n      s1 += s[j];\n    }\n    rep(j,i+2,s.sz){\n      s1 += s[j];\n    }\n    ret |= f(s1);\n  }\n  return ret;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  if(n>10)return 0;\n  string s;\n  rep(i,0,n){\n    s += \"a\";\n  }\n  ll c = 0;\n  rep(i,0,pow(3,n)){\n    ll a = i;\n    rep(j,0,n){\n      s[j] = 'A'+a%3;\n      a/=3;\n    }\n    c += f(s);\n  }\n  cout << c << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long fac[2000000];\nlong long finv[2000000];\nlong long inv[2000000];\nlong long comb(long long a, long long b) {\n\tlong long ans = fac[a];\n\tans *= finv[a-b];\n\tans %= MOD;\n\tans *= finv[b];\n\tans %= MOD;\n\treturn ans;\n}\nint main() {\n#define int long long\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 1100000; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n\tlong long n;\n\tcin >> n;\n\tlong long ans = 1;\n\tlong long hoge = 1;\n\tREP(i, n) {\n\t\tans *= 3LL;\n\t\tans %= MOD;\n\t\thoge *= 2LL;\n\t\thoge %= MOD;\n\t}\n\tfor (long long i = 1; i <= n / 2 + 1; ++i) {\n\t\thoge *= inv[2];\n\t\thoge %= MOD;\n\t}\n\tfor (long long i = n / 2 + 1; i <= n; ++i) {\n\t\tlong long tmp = comb(n, i) * 2LL;\n\t\ttmp *= hoge;\n\t\ttmp %= MOD;\n\t\thoge *= inv[2];\n\t\thoge %= MOD;\n\t\tans += (MOD - tmp);\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 998244353\n\nint inv(LLI n) {\n    LLI r = 1;\n    int e = MOD-2;\n    while (e > 0) {\n        if (e & 1) r *= n,r %= MOD;\n        e >>= 1;\n        n *= n,n %= MOD;\n    }\n    return r;\n}\nint fact[10000001],invfact[10000001];\nint main() {\n    int N;\n    cin >> N;\n\n    int i;\n    fact[0] = 1;\n    for (i = 1; i <= N; i++) fact[i] = ((LLI) fact[i-1]*i) % MOD;\n    invfact[N] = inv(fact[N]);\n    for (i = N-1; i >= 0; i--) invfact[i] = ((LLI) invfact[i+1]*(i+1)) % MOD;\n    LLI ans = 0,p = 1;\n    for (i = 0; i < N/2; i++) p *= 2,p %= MOD;\n    for (i = N/2; i >= 0; i--) {\n        LLI x = fact[N];\n        x *= invfact[i],x %= MOD;\n        x *= invfact[N-i],x %= MOD;\n        ans += x*p,ans %= MOD;\n        p *= 2,p %= MOD;\n        LLI y = fact[N-i];\n        y *= invfact[N/2],y %= MOD;\n        y *= invfact[N/2-i],y %= MOD;\n        p += MOD-y,p %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n\nconst int N=1e7+1;\nconst int M=998244353;\nint bp(int a,int pw){ \n    int r=1;\n    for(;pw;(a*=a)%=M,pw/=2)if(pw&1)(r*=a)%=M;\n    return r;\n}\nint inverse(int a){return bp(a%M,M-2);} \nint fc[N],ifc[N];\nstruct pcfc{pcfc(){\n        fc[0]=1;\n        for(int i=1;i<N;++i)fc[i]=(fc[i-1]*i)%M;\n        ifc[N-1]=inverse(fc[N-1]);\n        for(int i=N-2;i>=0;--i)ifc[i]=(ifc[i+1]*(i+1))%M;\n}}pcfc;\nint C(int n,int k){\n    if(k<0||k>n)return 0;\n    return(((fc[n]*ifc[k])%M)*ifc[n-k])%M;\n}\nint p[N];\n\n\nint32_t main(){\n    int n;\n    cin>>n;\n    p[0]=1;\n    for(int i=1;i<=n;++i)p[i]=(p[i-1]*2)%M;\n    int bad=0;\n    for(int a=n/2+1;a<=n;++a){\n        bad+=C(n,a)*p[n-a]%M;\n    }\n    bad%=M;\n    int p3=1;\n    for(int i=1;i<=n;++i)(p3*=3)%=M;\n    int ans=p3-bad*2;\n    ans%=M;\n    ans+=M;\n    ans%=M;\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<FiniteField> factorials(n + 1);\n  vector<FiniteField> inverse_factorials(n + 1);\n\n  factorials[0] = inverse_factorials[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    factorials[i] = factorials[i - 1] * i;\n  }\n  inverse_factorials[n] = FiniteField(1) / factorials[n];\n  for (int i = n; i >= 1; i--) {\n    inverse_factorials[i - 1] = inverse_factorials[i] * i;\n  }\n\n  vector<FiniteField> two_powers(n + 1);\n  two_powers[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two_powers[i] = two_powers[i - 1] * 2;\n  }\n\n  FiniteField z = 0;\n  for (int k = n / 2 + 1; k <= n; k++) {\n    z += factorials[n] * inverse_factorials[k] * inverse_factorials[n - k]\n        * two_powers[n - k];\n  }\n  \n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans *= 3;\n  }\n  ans -= z * 2;\n  cout << ans.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint modpow(int a, int b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 30; i++) {\n\t\tif ((b & (1 << i)) != 0) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nint Div(int a, int b, long long m) {\n\treturn (1LL * a * modpow(b, m - 2, m)) % m;\n}\n\nlong long mod = 998244353;\nlong long dp1[10000007];\nlong long dp2[10000007];\n\nint main() {\n\tlong long N; cin >> N;\n\n\t// dp1 の計算\n\tdp1[0] = 1; dp1[1] = -2; dp1[2] = 0; dp1[3] = 16;\n\tlong long val1 = 20, val2 = 2, p1 = 14, p2 = 2;\n\tfor (int i = 4; i <= (N >> 1); i++) {\n\t\tdp1[i] = dp1[i - 1] * Div(val1 % mod, val2 % mod, mod);\n\t\tdp1[i] %= mod;\n\t\tp1 += 8; p2++;\n\t\tval1 += p1; val2 += p2;\n\t}\n\n\t// dp2 の計算\n\tdp2[0] = 1;\n\tfor (int i = 1; i <= (N >> 1); i++) {\n\t\tdp2[i] = 9LL * dp2[i - 1] + dp1[i];\n\t\tdp2[i] = (dp2[i] + mod) % mod;\n\t}\n\n\tcout << dp2[N / 2] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n#include <stack>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n// ll MOD = 1000000007;\nll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\nint N,K;\nll gcd(ll a, ll b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\n\n\n\nll powMod(ll x, ll k, ll m) {//x^k (mod n)\n\tif (k == 0)     return 1;\n\tif (k % 2 == 0) return powMod(x*x % m, k/2, m);\n\telse            return x*powMod(x, k-1, m) % m;\n}\nint main(){\n\tll N;\n\tcin>>N;\n\tN/=2;\n\tll ans=powMod(3,2*N,MOD);\n\tll fu=0;\n\tll kumi=1;\n\tll po2=1;\n\tfor(int i=0;i<=N-1;i++){\n\t\tll hoge=(kumi*po2)%MOD;\n\t\thoge*=2;\n\t\thoge%=MOD;\n\t\tans-=hoge;\n\t\tans+=MOD;\n\t\tans%=MOD;\n\t\tkumi*=(2*N-i);\n\t\tkumi%=MOD;\n\t\tkumi*=invMod(i+1,MOD);\n\t\tkumi%=MOD;\n\t\tpo2*=2;\n\t\tpo2%=MOD;\n\t}\n\tcout<<ans<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=10000004,mod=998244353;\nll fac[N],pw[N/2],ni[N];\nll c(int a,int b){\n\treturn fac[a]*ni[b]%mod*ni[a-b]%mod;\n}\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint n=read(),ans=0;\n\tFor(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;\n\tni[n]=ksm(fac[n],mod-2);\n\tRep(i,n,1)ni[i-1]=ni[i]*i%mod;\n\tFor(i,pw[0]=1,n/2)pw[i]=pw[i-1]*2%mod;\n\tFor(i,n/2+1,n)ans=(ans+c(n,i)*pw[n-i+1])%mod;\n\tcout<<(ksm(3,n)-ans+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>     \n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define ll long long\n#define forn(i, a, b) for(int i = (a); i <= (b); ++i)\n#define forev(i, b, a) for(int i = (b); i >= (a); --i)\n#define VAR(v, i) __typeof( i) v=(i)\n#define forit(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)(x).size())\n#define file(s) freopen(s\".in\",\"r\",stdin); freopen(s\".out\",\"w\",stdout);\n \nusing namespace std;\n \nconst int maxn = (int)1e7 + 100;\nconst int mod = (int)998244353;\n \n#define inf mod\n \ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;   \ntypedef vector<ll> Vll;               \ntypedef vector<pair<int, int> > vpii;\ntypedef vector<pair<ll, ll> > vpll;\n\nint f[maxn], inv[maxn], pw[maxn], ans;\nint n, s;\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\tres = (res * 1ll * a) % mod;\n\t\tb >>= 1;\n\t\ta = (a * 1ll * a) % mod;\n\t}\n\treturn res;\n}\nint C(int n, int k) {\n  if (k > n || k < 0) return 0;\n  int res = f[n];\n  res = res * 1ll * inv[k] % mod;\n  res = res * 1ll * inv[n - k] % mod;\n  return res;\n}\nmain () {\n\tf[0] = pw[0] = 1;\n  forn(i, 1, maxn - 1)\n\tf[i] = f[i - 1] * 1ll * i % mod, pw[i] = pw[i - 1] * 2ll % mod;\n    inv[maxn - 1] = binpow(f[maxn - 1], mod - 2);\n\tforev(i, maxn - 1, 1)\n  \tinv[i - 1] = inv[i] * 1ll * i % mod;\n\tcin >> n;\n\tforn(a, n / 2 + 1, n){\n\t\tans = (ans + C(n, a) * 1ll * pw[n - a] % mod) % mod;\n\t}\t\n\tans = (ans + ans) % mod;\n\tcout << (binpow(3, n) - ans + mod) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e7 + 5;\nconst int mod = 998244353;\nint n;\nint r[maxn] , fac[maxn] , rfac[maxn];\nint P[maxn];\n\nint nCk(int n , int k){\n    return (ll)fac[n] * rfac[n - k] % mod * rfac[k] % mod;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n;\n    r[1] = 1;\n    for(int i = 2; i <= n ; ++i){\n        r[i] = (mod - (ll)(mod / i) * r[mod % i] % mod);\n    }\n    P[0] = fac[0] = rfac[0] = 1;\n    int res = 1;\n    for(int i = 1 ; i <= n ; ++i){\n        P[i] = P[i - 1] * 2 % mod;\n        fac[i] = (ll)fac[i - 1] * i % mod;\n        rfac[i] = (ll)rfac[i - 1] * r[i] % mod;\n        res = (ll)res * 3 % mod;\n    }\n    for(int i = n / 2 + 1 ; i <= n ; ++i){\n        res -= 2ll * nCk(n , i) * P[n - i] % mod;\n        if(res < 0)res += mod;\n    }\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 998244353; // = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nvl invs, fac, ifac;\nmi two[10000005];\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ);\n\tinvs[1] = 1; FOR(i,2,SZ) invs[i] = MOD-MOD/i*invs[MOD%i]%MOD;\n\tfac[0] = ifac[0] = 1;\n\tFOR(i,1,SZ) {\n\t\tfac[i] = fac[i-1]*i%MOD;\n\t\tifac[i] = ifac[i-1]*invs[i]%MOD;\n\t}\n}\n\nint main() {\n\tsetIO(); genFac(5000005);\n\ttwo[0] = 1; FOR(i,1,10000005) two[i] = 2*two[i-1];\n\tint N; re(N); N /= 2;\n\tmi ans = 0, sum = 0;\n\tFOR(b,1,N+1) {\n\t\t// mi tmp = 0;\n\t\t// F0R(c,b) F0R(d,N-b+1) tmp += ifac[d]*ifac[c]*ifac[N-c-d];\n\t\tsum -= ifac[N-b+1]*(two[b-1]-1)*ifac[b-1];\n\t\tsum += ifac[b-1]*(two[N-b+1]-1)*ifac[N-b+1];\n\t\t// assert(sum == tmp);\n\t\tans += ifac[b]*two[N-b]*ifac[N-b]*sum;\n\t}\n\tans *= 2;\n\tF0R(b,N+1) {\n\t\tans += mi(ifac[b])*ifac[b]*two[2*(N-b)]*ifac[N-b]*ifac[N-b];\n\t}\n\tans *= mi(fac[N])*fac[N];\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long LL;\nconst int SIZEN = 10000010;\nconst LL mod = 998244353;\nLL pw[SIZEN];\nLL fac[SIZEN];\nLL inv[SIZEN];\nint N;\nLL qpow(LL x,LL len){\n    LL ret = 1;\n    for(;len;len>>=1){\n        if(len & 1)ret = ret * x % mod;\n        x = x * x % mod;\n    }\n    return ret;\n}\nLL C(int n,int m){\n    if(n < m)return 0;\n    return fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\nint main(){\n    scanf(\"%d\",&N);\n    for(int i = 0;i <= N;i++)pw[i] = (i == 0?1:pw[i-1] * 2 % mod);\n    for(int i = 0;i <= N;i++)fac[i] = (i == 0?1:fac[i-1] * i % mod);\n    for(int i = N;i >= 0;i--)inv[i] = (i == N?qpow(fac[N],mod-2):inv[i+1] * (i+1) % mod);\n    LL ans = qpow(3,N);\n    for(int i = N/2+1;i <= N;i++){\n        // printf(\"C(%d,%d) = %lld\\n\",N,i,C(N,i));\n        ans = (ans - 2*C(N,i) * pw[N-i] % mod) % mod;\n    }\n    printf(\"%lld\",(ans+mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nvll factorial; \n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return factorial[n] * inverse(factorial[k]) % MOD * inverse(factorial[n-k]) % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    factorial.resize(N+1);\n    factorial[0] = 1;\n    FOR(i, 1, N+1) factorial[i] = factorial[i-1] * i % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * binpow(2, N-i);\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include<bits/extc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vector<ll>>;\nconst ll mod = 998244353;\nusing oset = tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nll fact[10001001], inv[10001001], p3[10001001];\nll bp(ll a, ll p) {\n\tll res = 1;\n\twhile(p) {\n\t\tif(p&1) res = (res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\nll nck(ll n, ll k) {\n\tll res = (fact[n]*inv[k])%mod;\n\treturn (res*inv[n-k])%mod;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tll n;\n\tcin >> n;\n\tfact[0]= p3[0] = 1;\n\tfor(int i = 1; i <= 10000000; i++)\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\tinv[10000000]=bp(fact[10000000], mod-2);\n\tfor(int i = 10000000; i--;)\n\t\tinv[i] = (inv[i+1]*(i+1))%mod;\n\tfor(int i = 1; i <= 10000000; i++)\n\t\tp3[i] = (p3[i-1]*2)%mod;\n\tll ans = bp(3, n);\n\tfor(ll x = (n/2)+1; x <= n; x++) {\n\t\tans = (mod+ans - (2ll*p3[n-x]*nck(n, x))%mod)%mod;\n\t}\n\tcout << ans;\n}\n\\"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<998244353>;\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nconst int MAXN = 1.01e7;\nnum fact[MAXN];\nnum ifact[MAXN];\nnum p2[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfact[i] = fact[i-1] * num(i);\n\t}\n\tifact[N] = fact[N].inv();\n\tfor (int i = N; i >= 1; i--) {\n\t\tifact[i-1] = ifact[i] * num(i);\n\t}\n\tp2[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tp2[i] = p2[i-1] + p2[i-1];\n\t}\n\n\tnum res = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tres = res + res + res;\n\t}\n\n\tfor (int i = N/2+1; i <= N; i++) {\n\t\tres -= 2 * fact[N] * ifact[i] * ifact[N-i] * p2[N-i];\n\t}\n\tcout << res << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 10000000\n#define X 998244353\n#define C(x,y) (1LL*Fac[x]*IFac[y]%X*IFac[(x)-(y)]%X)\nusing namespace std;\nint n,Fac[N+5],IFac[N+5];\nI int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,t=0;for(scanf(\"%d\",&n),Fac[0]=i=1;i<=n;++i) Fac[i]=1LL*Fac[i-1]*i%X;\n\tfor(IFac[n]=Qpow(Fac[n],X-2),i=n-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;\n\tfor(i=n/2+1;i<=n;++i) t=(1LL*C(n,i)*Qpow(2,n-i)+t)%X;\n\treturn printf(\"%d\",(Qpow(3,n)-2*t%X+X)%X),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 998244353\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\n\n//aのb乗\nint beki(int a,int b){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=mod(x*a);\n\t\t}\n\t\ta=mod(a*a);\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\n//aの逆元\nint gyakugen(int a){\n\treturn beki(a,modulo-2);\n}\n\nstruct combi{\n\tdeque<int> kaijou;\n\tdeque<int> kaijou_;\n\t\n\tvoid kaijou_set(int n){\n\t\tkaijou.push_back(1);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tkaijou.push_back(mod(kaijou[i-1]*i));\n\t\t}\n\t\t\n\t\tint b=gyakugen(kaijou[n]);\n\t\t\n\t\tkaijou_.push_front(b);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint k=n+1-i;\n\t\t\tkaijou_.push_front(mod(kaijou_[0]*k));\n\t\t}\n\t}\n\t\n\tint combination(int n,int r){\n\t\tif(r>n)return 0;\n\t\tint a = mod(kaijou[n]*kaijou_[r]);\n\t\ta=mod(a*kaijou_[n-r]);\n\t\treturn a;\n\t}\n\t\n\tint junretsu(int a,int b){\n\t\tint x = mod(kaijou_[a]*kaijou_[b]);\n\t\tx=mod(x*kaijou[a+b]);\n\t\treturn x;\n\t}\n\t\n};\n\nint main(){\n\t\n\tcombi C;\n\tC.kaijou_set(10000001);\n\t\n\tint N;\n\tcin>>N;\n\t\n\tint k = N/2 + 1;\n\t\n\tint bb = beki(2,N-k);\n\tint sum = 0;\n\tint gya = gyakugen(2);\n\tfor(int i=k;i<=N;i++){\n\t\tint a = C.combination(N,i);\n\t\tint b = mod(a * bb);\n\t\t\n\t\tsum = mod(sum + b);\n\t\t\n\t\tbb = mod(bb * gya);\n\t}\n\t\n\tsum = mod(sum * 2);\n\t\n\tint ans = beki(3,N);\n\tans = mod(ans - sum);\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll mod=998244353;\n\nvector<ll> fac(100000000);\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(int n){\n    fac[0]=1;\n    for(ll i=1;i<n;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  ll n;\n  cin >> n;\n  modfac(10000010);\n  ll ans=modpow(3,n);\n  ll cnt=modpow(2,n-n/2-1);\n  ll inv2=modinv(2);\n  for(ll i=n/2+1;i<=n;i++){\n    ans-=cnt*modcomb(n,i)*2%mod;\n    ans+=mod; ans%=mod;\n    cnt*=inv2; cnt%=mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(v) ((int)(v).size())\nconst int MAXN = 10000005;\nconst int mod = 998244353;\nusing lint = long long;\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nlint fact[MAXN], invf[MAXN];\n\nlint binom(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x-y] % mod) % mod;\n}\n\nint main() { \n\tint n; cin >> n;\n\tfact[0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t}\n\tinvf[n] = ipow(fact[n], mod - 2);\n\tfor(int i=n-1; i>=0; i--){\n\t\tinvf[i] = invf[i + 1] * (i + 1) % mod;\n\t}\n\tlint ans = 0;\n\tfor(int i=0; i<n/2; i++){\n\t\tans += ipow(2, i + 1) * binom(n, i) % mod;\n\t}\n\tans %= mod;\n\tans = ipow(3, n) - ans;\n\tcout << ans % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define int long long\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e7 + 12;\n\nlong long ans;\nlong long deg2[N], fact[N], ufact[N], r[N];\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    deg2[0] = 1, fact[0] = 1, ufact[0] = 1, r[1] = 1;\n    for (int i = 2; i < N; i++) r[i] = MOD - (MOD / i) * r[MOD % i] % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * 2 % MOD, fact[i] = fact[i - 1] * i % MOD, ufact[i] = ufact[i - 1] * r[i] % MOD;\n    ans = 1;\n    for (int i = 0; i < n; i++) ans = ans * 3 % MOD;\n    for (int c = n / 2 + 1; c <= n; c++)\n    {\n        ans = (ans - cnk(n, c) * deg2[n - c + 1] + MOD * MOD) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision;\n\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define X first\n#define Y second\n#define ALL(x) x.begin(), x.end()\n#define RALL(x) x.rbegin(), x.rend()\n#define Push push_back\n\nconst int64_t mod = 998244353;\n\n/// 7, 63, 583, 5407, 50007, 460815, 4231815, ...\n\n/*\nvoid boom() {\n\tint cnt = 0, len = 14;\n\t\n\tstring s(len, 'A');\n\t--s[len - 1];\n\t\n\tint pows = 1;\n\tfor (int i = 0; i < len; ++i) pows *= 3;\n\t\n\tfor (int i = 0; i < pows; ++i) {\n\t\tint tok = len - 1;\n\t\twhile (++s[tok] == 'D') {\n\t\t\ts[tok] = 'A';\n\t\t\t--tok;\n\t\t}\n\t\t// cout << s << \"\\n\";\n\t\t\n\t\tbool flag = false;\n\t\t\n\t\tfor (int x = 0; x < len-1 and !flag; ++x) {\n\t\t\tif (s[x] == 'A' and s[x + 1] == 'B') continue;\n\t\t\tif (s[x] == 'B' and s[x + 1] == 'A') continue;\n\t\t\t\n\t\t\tstring t1;\n\t\t\tfor (int a = 0; a < len; ++a) {\n\t\t\t\tif (a == x or a == x + 1) continue;\n\t\t\t\tt1 += s[a];\n\t\t\t}\n\t\t\t\n\t\t\tfor (int y = 0; y < len-3 and !flag; ++y) {\n\t\t\t\tif (t1[y] == 'A' and t1[y + 1] == 'B') continue;\n\t\t\t\tif (t1[y] == 'B' and t1[y + 1] == 'A') continue;\n\t\t\t\t\n\t\t\t\tstring t2;\n\t\t\t\tfor (int a = 0; a < len-2; ++a) {\n\t\t\t\t\tif (a == y or a == y + 1) continue;\n\t\t\t\t\tt2 += t1[a];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int z = 0; z < len-5 and !flag; ++z) {\n\t\t\t\t\tif (t2[z] == 'A' and t2[z + 1] == 'B') continue;\n\t\t\t\t\tif (t2[z] == 'B' and t2[z + 1] == 'A') continue;\n\t\t\t\t\t\n\t\t\t\t\tstring t3;\n\t\t\t\t\tfor (int a = 0; a < len-4; ++a) {\n\t\t\t\t\t\tif (a == z or a == z + 1) continue;\n\t\t\t\t\t\tt3 += t2[a];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (int w = 0; w < len-7 and !flag; ++w) {\n\t\t\t\t\t\tif (t3[w] == 'A' and t3[w + 1] == 'B') continue;\n\t\t\t\t\t\tif (t3[w] == 'B' and t3[w + 1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tstring t4;\n\t\t\t\t\t\tfor (int a = 0; a < len-6; ++a) {\n\t\t\t\t\t\t\tif (a == w or a == w + 1) continue;\n\t\t\t\t\t\t\tt4 += t3[a];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int v = 0; v < len-9 and !flag; ++v) {\n\t\t\t\t\t\t\tif (t4[v] == 'A' and t4[v + 1] == 'B') continue;\n\t\t\t\t\t\t\tif (t4[v] == 'B' and t4[v + 1] == 'A') continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstring t5;\n\t\t\t\t\t\t\tfor (int a = 0; a < len-8; ++a) {\n\t\t\t\t\t\t\t\tif (a == v or a == v + 1) continue;\n\t\t\t\t\t\t\t\tt5 += t4[a];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (int u = 0; u < len-11 and !flag; ++u) {\n\t\t\t\t\t\t\t\tif (t5[u] == 'A' and t5[u + 1] == 'B') continue;\n\t\t\t\t\t\t\t\tif (t5[u] == 'B' and t5[u + 1] == 'A') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tstring t6;\n\t\t\t\t\t\t\t\tfor (int a = 0; a < len-10; ++a) {\n\t\t\t\t\t\t\t\t\tif (a == u or a == u + 1) continue;\n\t\t\t\t\t\t\t\t\tt6 += t5[a];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (t6[0] == 'A' and t6[1] == 'B') continue;\n\t\t\t\t\t\t\t\tif (t6[0] == 'B' and t6[1] == 'A') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if (t5[0] == 'A' and t5[1] == 'B') continue;\n\t\t\t\t\t\t\t// if (t5[0] == 'B' and t5[1] == 'A') continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if (t4[0] == 'A' and t4[1] == 'B') continue;\n\t\t\t\t\t\t// if (t4[0] == 'B' and t4[1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if (t1[0] == 'A' and t1[1] == 'B') continue;\n\t\t\t// if (t1[0] == 'B' and t1[1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t// flag = true;\n\t\t}\n\t\t\n\t\tcnt += flag;\n\t}\n\t\n\tcout << cnt << \"\\n\";\n}\n*/\n\nvoid solve() {\n\tint64_t n;\n\tcin >> n;\n\t\n\tassert(n < 8);\n\tint arr[8] = {0, 7, 63, 583, 5407, 50007, 460815, 4231815};\n\tcout << arr[n] << \"\\n\";\n}\n\nint main() {\n\tint t = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e7+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,pw2[N],pw3[N],fac[N],inv[N],ifac[N];\n\nint C(int n,int m) {\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() {\n\tn=gi();\n\tpw2[0]=pw3[0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tpw2[i]=2ll*pw2[i-1]%mod;\n\t\tpw3[i]=3ll*pw3[i-1]%mod;\n\t}\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n\tfor(int i=2;i<=n;i++) {\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\t}\n\tint ans=pw3[n],sum=0;\n\tfor(int i=n/2+1;i<=n;i++)\n\t\tsum=(sum+1ll*C(n,i)*pw2[n-i])%mod;\n\tcout<<(ans-2ll*sum%mod+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define mod 998244353\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 10000005;\nint n;\nll fac[MAXN],inv[MAXN],fin[MAXN],pw[MAXN];\ninline ll c(int a, int b)\n    { return a<b?0:fac[a]*fin[b]%mod*fin[a-b]%mod; }\ninline ll qpow(ll a, int b)\n{\n\tll res = 1;\n\tfor(; b; a = a*a%mod, b >>= 1)\n\t    if(b&1)\n\t    \tres = res*a%mod;\n\treturn res;\n}\n\nint main()\n{\n\tcin >> n;\n\tinv[1] = 1;\n\tfor(int i = 2; i<=n; i++)\n\t\tinv[i] = inv[mod%i]*(mod-mod/i)%mod;\n\tfac[0] = fin[0] = 1;\n\tfor(int i = 1; i<=n; i++)\n\t\tfac[i] = fac[i-1]*i%mod, fin[i] = fin[i-1]*inv[i]%mod;\n\tpw[0] = 1;\n\tfor(int i = 1; i<=n; i++)\n\t\tpw[i] = pw[i-1]*2%mod;\n\tll ans = qpow(3,n);\n\tfor(int i = n/2+1; i<=n; i++)\n\t\tans = (ans-2*c(n,i)*pw[n-i]%mod+mod)%mod;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst long long mod=998244353ll;\nconst int MSIZE=10000009;\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nvoid mn(long long &a,long long b){a+=mod-b;a%=mod;}\nvoid ml(long long &a,long long b){a*=b;a%=mod;}\nlong long sq(long long a){return a*a%mod;}\nlong long pw(long long a,long long n)\n{\n  return n==0?1ll:sq(pw(a,n/2))*(n%2==1?a:1ll)%mod;\n}\nlong long iv(long long a){return pw(a,mod-2);}\nlong long inv[MSIZE],F[MSIZE],iF[MSIZE];\n\nvoid prev(int N)\n{\n  inv[0]=0;\n  inv[1]=1;\n  for(int i=2;i<N;i++){\n    inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n  }\n  F[0]=iF[0]=1;\n  for(int i=1;i<N;i++){\n    F[i]=F[i-1]*i%mod;\n    iF[i]=iF[i-1]*inv[i]%mod;\n  }\n}\n\nlong long Ch(int i,int j)\n{\n  return F[i]*iF[j]%mod*iF[i-j]%mod;\n}\n\nlong long p2[MSIZE];\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  prev(n/2+1);\n  p2[0]=1ll;\n  for(int i=1;i<=n/2;i++){\n    p2[i]=2ll*p2[i-1]%mod;\n  }\n  std::vector<long long> S(n/2+2);\n  S[n/2+1]=0ll;\n  for(int i=n/2;i>=0;i--){\n    S[i]=(S[i+1]+Ch(n/2,i)*p2[n/2-i]%mod)%mod;\n  }\n  long long bad=0ll;\n  for(int i=0;i<=n/2;i++){\n    ad(bad,Ch(n/2,i)*p2[n/2-i]%mod*S[n/2-i+1]%mod);\n  }\n  printf(\"%lld\\n\",(pw(3,n)+2*mod-2*bad)%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nconst int maxn=1e7+5;\nint n;\nint f[maxn];\nint invf[maxn];\nint power[maxn];\ninline int ksm(int x,int y){\n\tif(!y) return 1;\n\tif(y==1) return x;\n\tint tmp=ksm(x,y/2);\n\ttmp=(1ll*tmp*tmp)%MOD;\n\tif(y&1) return (1ll*tmp*x)%MOD;\n\telse return tmp;\n}\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn 1ll*f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tf[0]=invf[0]=1;\n\tfor(int i=1;i<maxn;i++) f[i]=(1ll*f[i-1]*i)%MOD;\n\tinvf[maxn-1]=ksm(f[maxn-1],MOD-2);\n\tfor(int i=maxn-2;i>=1;i--) invf[i]=(1ll*invf[i+1]*(i+1))%MOD;\n\tpower[0]=1;\n\tfor(int i=1;i<maxn;i++) power[i]=(1ll*power[i-1]*2)%MOD;\n\tint ans=ksm(3,n);\n\tint res=0;\n\tfor(int i=n/2+1;i<=n;i++) res=(res+2ll*power[n-i]%MOD*C(n,i))%MOD;\n\tans=((ans-res)%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define all(a) a.begin(),a.end()\n#define println printf(\"\\n\");\n#define readln(x) getline(cin,x);\n#define pb push_back\n#define endl \"\\n\"\n#define INT_INF 0x3f3f3f3f\n#define LL_INF 0x3f3f3f3f3f3f3f3f\n#define MOD 998244353\n#define MOD2 1494318097\n#define SEED 131\n#define mp make_pair\n#define fastio cin.tie(0); cin.sync_with_stdio(0);\n\n#define MAXN 10000005\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unordered_map<int,int> umii;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,pii> triple;\ntypedef int8_t byte;\n\nmt19937 g1(time(0));\n\nint randint(int a, int b){return uniform_int_distribution<int>(a, b)(g1);}\nll randlong(ll a,ll b){return uniform_int_distribution<long long>(a, b)(g1);}\n\nll gcd(ll a, ll b){return b == 0 ? a : gcd(b, a % b);}\nll lcm(ll a, ll b){return a*b/gcd(a,b);}\nll fpow(ll  b, ll exp, ll mod){if(exp == 0) return 1;ll t = fpow(b,exp/2,mod);if(exp&1) return t*t%mod*b%mod;return t*t%mod;}\nll divmod(ll i, ll j, ll mod){i%=mod,j%=mod;return i*fpow(j,mod-2,mod)%mod;}\n\nint len;\nll res,f[MAXN],power[MAXN];\n\nll inv(ll a){\n\tll x1 = 1, b1 = a, x2 = 0, b2 = MOD;\n\twhile (b2) {\n\t\tll q = b1/b2;\n\t\tb1-=q*b2, x1-=q*x2;\n\t\tswap(x1,x2);\n\t\tswap(b1,b2);\n\t}\n\treturn ((x1%MOD)+MOD)%MOD;\n}\n\nll cnk(ll n, ll k){\n\tif(k > n) return 0;\n\tll q = (inv(f[k])*inv(f[n - k]))%MOD;\n\treturn (f[n]*q)%MOD;\n}\n\nint main(){\n\tscanf(\"%d\",&len);\n\tf[0] = power[0] = 1;\n\tfor(int i=1; i<=len; i++){\n\t\tf[i] = (f[i-1]*i)%MOD;\n\t\tpower[i] = (power[i-1]*2)%MOD;\n\t}\n\tres = fpow(3,len,MOD);\n\tfor(int i=len/2+1; i<=len; i++){\n\t\tll add = (cnk(len,i)*2)%MOD;\n\t\tadd = (add*power[len-i])%MOD;\n\t\tres = (res-add+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 10000005, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline int fpow(int x, int k)\n{\n\tint res = 1;\n\twhile (k) {\n\t\tif (k & 1) res = (ll)res * x % mod;\n\t\tk >>= 1; x = (ll)x * x % mod;\n\t}\n\treturn res;\n}\n\nint n, fac[maxn], ifac[maxn], Pow[maxn];\n\ninline int C(int m, int n)\n{\n\treturn (ll)fac[m] * ifac[n] % mod * ifac[m - n] % mod;\n}\n\nint main()\n{\n\tn = gi();\n\tfac[0] = 1; Pow[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fac[i] = (ll)fac[i - 1] * i % mod;\n\tifac[n] = fpow(fac[n], mod - 2);\n\tfor (int i = n - 1; ~i; --i) ifac[i] = (ll)ifac[i + 1] * (i + 1) % mod;\n\tfor (int i = 1; i <= n / 2 + 1; ++i) Pow[i] = Pow[i - 1] + Pow[i - 1], Pow[i] = Pow[i] >= mod ? Pow[i] - mod : Pow[i];\n\t\n\tint ans = fpow(3, n);\n\tfor (int i = n / 2 + 1; i <= n; ++i)\n\t\tans = (ans + (ll)(mod - C(n, i)) * Pow[n - i + 1]) % mod;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n\n\nint a[5000020];\nsigned main(){\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nmod= 998244353;\n\tgya(6000005);\n\t\n\tint n;\n\tcin>>n;\n\tint z=1;\n\tfor(int i=0;i<=n/2;i++){\n\t\ta[i]=z*comb(n/2,i)%mod;\n\t\tz*=2;\n\t\tif(z>=mod) z-=mod;\n\t}\n\tint dame=0;\n\tint wa=0;\n\tfor(int i=0;i<n/2;i++){\n\t\twa+=a[i];\n\t\twa%=mod;\n\t\tdame+=wa*a[n/2-i-1]%mod;\n\t}\n\tdame%=mod;\n\tdame*=2;\n\tdame%=mod;\n\tint zen=beki(3,n,mod);\n\t\n\tcout<<(zen+mod-dame)%mod<<endl;\n\t\n\nreturn 0;\n \t\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n/* debug macros */\n#ifdef WAFDAYO\n#define DBG_PRINT(s, t, u) { std::cerr << s << \" \\e[2m=\\e[m \\e[1m\" << t << \"\\e[m\" << u; }\n#else\n#define DBG_PRINT(s, t, u) {}\n#endif\n#define dbg(x) DBG_PRINT(#x, x, std::endl)\n#define dbgn(x) DBG_PRINT(#x, x, \", \")\n#define idbg(x, i) DBG_PRINT(#x \"[\" << i << \"]\", x[i], std::endl)\n#define idbgn(x, i) DBG_PRINT(#x \"[\" << i << \"]\", x[i], \", \")\n\n/* IO utilities */\nstruct read_input { read_input() {}; template<class T> operator T() { T t; std::cin >> t; return t; } };\n\n/* types and constants */\ntypedef long long i64;\nconst i64 inf = (i64)1.05e18;\n// const int inf = (int)1.05e9;\nconst i64 mod = 998244353;\n\ni64 modpow(i64 x, i64 a) {\n\ti64 y = 1;\n\tfor(int i = 0; i < 63; i++) {\n\t\tif((a >> i) & 1LL) {\n\t\t\ty = y * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t}\n\treturn y;\n}\n\nint main() {\n\n\tint n = read_input();\n\n\tint inv_lim = max(n, 10);\n\tvector<i64> inv(inv_lim + 1);\n\n\tinv[1] = 1;\n\tfor(int i = 2; i <= inv_lim; i++) {\n\t\tinv[i] = inv[mod % i] * (mod - mod / i) % mod;\n\t}\n\n\tvector<i64> fact(n + 1);\n\tvector<i64> fact_inv(n + 1);\n\n\tfact[0] = fact_inv[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tfact_inv[i] = fact_inv[i - 1] * inv[i] % mod;\n\t}\n\n\ti64 ans = modpow(3, n);\n\ti64 r = modpow(2, n / 2);\n\n\tfor(int k = n / 2 + 1; k <= n; k++) {\n\t\tr = r * inv[2] % mod;\n\t\ti64 nck = fact[n] * (fact_inv[n - k] * fact_inv[k] % mod) % mod;\n\t\ti64 s = nck * r * 2 % mod;\n\t\tans = ans - s;\n\t\tif(ans < 0) {\n\t\t\tans += mod;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MOD = 998244353;\nconst int MAXN = 10000000;\nint sub(int x, int y) { return x - y < 0 ? x - y + MOD : x - y; }\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile (p) {\n\t\tif (p & 1) ret = 1LL * ret * b % MOD;\n\t\tb = 1LL * b * b % MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint pw2[MAXN + 5], fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tpw2[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++)\n\t\tpw2[i] = 2LL * pw2[i - 1] % MOD;\n\tfct[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++)\n\t\tfct[i] = 1LL * fct[i - 1] * i % MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD - 2);\n\tfor (int i = MAXN - 1; i >= 0; i--)\n\t\tifct[i] = 1LL * ifct[i + 1] * (i + 1) % MOD;\n}\nint comb(int n, int m) {\n\treturn 1LL * fct[n] * ifct[m] % MOD * ifct[n - m] % MOD;\n}\nint main() {\n\tinit(); int N;\n\tscanf(\"%d\", &N);\n\tint ans = pow_mod(3, N);\n\tfor (int i = N / 2 + 1; i <= N; i++)\n\t\tans = sub(ans, 2LL * comb(N, i) * pw2[N - i] % MOD);\n\tprintf(\"%d\\n\", ans);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n\n#include<cmath>\n#include<functional>\n#include<algorithm>\n\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<unordered_set>\n#include<map>\n#include<unordered_map>\n#include<bitset>\n#include<tuple>\n\n#define TEST {IS_TEST=true;}\n\nusing namespace std;\nusing ll = int_fast64_t;\nusing v_bool = vector <bool>;\nusing v_ll = vector <ll>;\nusing v_std = vector <string>;\nusing p_ll = pair <ll,ll>;\nusing vv_ll = vector <vector <ll> >;\nusing vp_ll = vector < p_ll >;\n\nusing ld = long double;\nusing v_ld = vector <ld>;\nusing vv_ld = vector<v_ld>;\n\nbool IS_TEST=false;\nll ll_min=1LL<<63;\nll ll_max=~ll_min;\nll int_min=1LL<<31;\nll int_max=~ll_max;\nll MOD = 1000000007;\n\ntemplate<class T>\nvoid show(const T &x){\n  if (!IS_TEST) return;\n  cout << x << endl;\n}\ntemplate<class T1,class T2>\nvoid show(const pair<T1,T2> &x){\n  if (!IS_TEST) return;\n  cout << \"{\" << x.first << \",\" << x.second << \"}\" << endl;\n}\n\ntemplate<class T>\nvoid show_sub(const T &x){if (!IS_TEST) return; cout << x;}\nvoid show_sub(const string &x){if (!IS_TEST) return; cout << x << endl;}\ntemplate<class T1,class T2>\nvoid show_sub(const pair<T1,T2> &x){\n  if (!IS_TEST) return;\n  cout << \"{\" << show_sub(x.first) << \",\" << show_sub(x.second) << \"}\";\n}\ntemplate<class T>\nvoid v_show(const T &v){\n  if (!IS_TEST) return;\n  auto itr=v.begin();\n  while(itr!=v.end()){ show_sub(*itr); itr++;}\n  cout << endl;\n}\n\ntemplate<class T>\nvoid vv_show(const T &v){\n  if (!IS_TEST) return;\n  cout << \"--------------------------------\\n\";\n  auto itr=v.begin();\n  while(itr!=v.end()){ v_show(*itr); itr++;}\n  cout << \"--------------------------------\" << endl;\n}\n\n\n\nll max(ll x,ll y){return x>y?x:y;}\nll max(ll x,ll y, ll z){return max(max(x,y),z);}\nll max(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=max(ans,*b);b++;}\n    return ans;\n}\nll min(ll x,ll y){return x<y?x:y;}\nll min(ll x,ll y, ll z){return min(min(x,y),z);}\nll min(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=min(ans,*b);b++;}\n    return ans;\n}\nll mid(ll x,ll y,ll z){\n    if (y>=x && x>=z) return x;\n    if (z>=x && x>=y) return x;\n    if (x>=y && y>=z) return y;\n    if (z>=y && y>=x) return y;\n    if (x>=z && z>=y) return z;\n    if (y>=z && z>=x) return z;\n    return x;\n}\nll gcd(ll x,ll y){\n    if(x<0)x=-x; if(y<0)y=-y;\n    while(y>0){ x%=y; swap(x,y); }\n    return y;\n}\nll gcd(ll x,ll y, ll z){return gcd(gcd(x,y),z);}\nll gcd(v_ll::iterator b,v_ll::iterator e){\n    ll ans=0;\n    while (b<e) ans=gcd(ans,*b);\n    return ans;\n}\nll lcm(ll x,ll y){\n    ll z=x*y; if(x<0)x=-x; if(y<0)y=-y;\n    while(y>0){ x%=y; swap(x,y); }\n    return z/y;\n}\nll lcm(ll x,ll y, ll z){return lcm(lcm(x,y),z);}\nll lcm(v_ll::iterator b,v_ll::iterator e){\n    ll ans=1;\n    while (b<e) ans=lcm(ans,*b);\n    return ans;\n}\n\nv_ll arange(ll n){\n    v_ll v(n+1,0);\n    for(ll i=0;i<=n;i++)v[i]=i;\n    return v;\n}\n\nll vec_sum(const v_ll& v,ll b,ll e){\n    ll ans=0;\n    for(ll i=b;i<e;i++)ans+=v[i];\n    return ans;\n}\nll v_sum(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans+=*b; b++;}\n    return ans;\n}\nll v_xor(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans^=*b; b++;}\n    return ans;\n}\nll v_eq(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans^=~*b; b++;}\n    return ans;\n}\n\n\ntemplate<class T> void refl_max(T& x,const T& y){ if (x>=y) return; x=y; }\ntemplate<class T> void refl_min(T& x,const T& y){ if (x<=y) return; x=y; }\n\ntemplate<class T,class S> void refl_max(T& x,S& xx,const T& y,const S& yy){\n  if (x>=y) return; x=y; xx=yy;\n}\ntemplate<class T,class S> void refl_min(T& x,S& xx,const T& y,const S& yy){\n  if (x<=y) return; x=y; xx=yy;\n}\n\ntemplate<class T> void quit(T x){cout << x << endl; exit(0);}\n\n/*O(logN)*/\nll sqrt_ll(ll n){\n  assert(n>=0);\n  ll ok = 0,ng = n+1;\n  while(ok-ng>1||ng-ok>1){ ll m=(ok+ng)/2; if (m*m<=n) ok=m; else ng=m;}\n  return ok;\n}\n\nclass ModInt{\n  public:\n  static ll modulus;\n  ll val;\n  ModInt(ll n=0){ val=n%modulus; if (val<0) val+=modulus;}\n  ModInt operator +(const ModInt& rhs)const{ return val+rhs.val;}\n  ModInt operator -(const ModInt& rhs)const{ return val-rhs.val;}\n  ModInt operator *(const ModInt& rhs)const{ return val*rhs.val;}\n  ModInt& operator +=(const ModInt& rhs){val+=rhs.val; if (val>=modulus)val-=modulus; return *this;}\n  ModInt& operator -=(const ModInt& rhs){val-=rhs.val; if (val<modulus)val+=modulus; return *this;}\n  ModInt& operator *=(const ModInt& rhs){val*=rhs.val; val%=modulus; return *this;}\n  ModInt pow(ll a)const{\n    a%=(modulus-1); if (a<0)a+=(modulus-1);\n    ModInt ret(1); ModInt vv(val);\n    while (a!=0){ if (a&1) ret*=vv; a>>=1; vv*=vv;}\n    return ret;\n  }\n  ModInt inv()const{return pow(-1);}\n  ModInt operator /(const ModInt& rhs)const{ return *this*rhs.pow(-1);}\n  ModInt& operator /=(const ModInt& rhs){ *this*=rhs.pow(-1); return *this;}\n};\nistream& operator >> (istream& istr, ModInt &rhs){istr >> (rhs.val); return istr;};\nostream& operator << (ostream& ostr, const ModInt &rhs){ostr << (rhs.val); return ostr;};\nvector<ModInt> mod_nck(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*(n+1-i)/i;\n  return v;\n}\nvector<ModInt> mod_npk(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*(n+1-i);\n  return v;\n}\nvector<ModInt> mod_fact(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*i;\n  return v;\n}\nvector<ModInt> mod_nck_2(ll n,ll k){\n  vector<ModInt> v(n+1,1);\n  for (ll i=k+1;i<=n;i++) v[i]=v[i-1]*i/(i-k);\n  return v;\n}\nll ModInt::modulus=998244353;\n\nll N;\n\nint main(){\n  cin >> N;\n  vector<ModInt> nck=mod_nck(N);\n  ModInt ans=0;\n  ModInt ans2=ModInt(3).pow(N);\n  for(ll a=N/2+1;a<=N;a++){\n    ans+=nck[a]*ModInt(2).pow(N-a);\n  }\n  ans*=ModInt(2);\n\n  cout << ans2-ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author tatsumack\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n\n#define int long long\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REPS(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)\n#define REV(i, a, b) for (int i = (a); i >= (b); --i)\n#define CLR(a, b) memset((a), (b), sizeof(a))\n#define DUMP(x) cout << #x << \" = \" << (x) << endl;\n#define INF 1001001001001001001ll\n#define fcout cout << fixed << setprecision(12)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint mod = 998244353;\n\nstruct mint {\n    unsigned x;\n\n    mint() : x(0) {}\n\n    mint(signed sig) { x = sig < 0 ? sig % mod + mod : sig % mod; }\n\n    mint(signed long long sig) { x = sig < 0 ? sig % mod + mod : sig % mod; }\n\n    int get() const { return (int) x; }\n\n    mint& operator+=(mint that) {\n        if ((x += that.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint& operator-=(mint that) {\n        if ((x += mod - that.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint& operator*=(mint that) {\n        x = (unsigned long long) x * that.x % mod;\n        return *this;\n    }\n\n    mint& operator/=(mint that) { return *this *= that.inverse(); }\n\n    mint operator+(mint that) const { return mint(*this) += that; }\n\n    mint operator-(mint that) const { return mint(*this) -= that; }\n\n    mint operator*(mint that) const { return mint(*this) *= that; }\n\n    mint operator/(mint that) const { return mint(*this) /= that; }\n\n    mint inverse() const {\n        long long a = x, b = mod, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            std::swap(a, b);\n            u -= t * v;\n            std::swap(u, v);\n        }\n        return mint(u);\n    }\n\n    bool operator==(mint that) const { return x == that.x; }\n\n    bool operator!=(mint that) const { return x != that.x; }\n\n    mint operator-() const {\n        mint t;\n        t.x = x == 0 ? 0 : mod - x;\n        return t;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inverse();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\n\nclass CNeitherABNorBA {\npublic:\n    static constexpr int kStressIterations = 0;\n\n    static void generateTest(std::ostream& test) {\n    }\n\n    void solve(std::istream& cin, std::ostream& cout) {\n        int N;\n        cin >> N;\n\n        mint res = 1;\n        REP(i, N) {\n            res *= 3;\n        }\n\n        vector<mint> two(N + 1);\n        two[0] = 1;\n        REP(i, N) two[i + 1] = two[i] * 2;\n\n        combination cb(N);\n        FOR(i, N / 2 + 1, N) {\n            res -= cb(N, i) * two[N - i] * 2;\n        }\n        cout << res.get() << endl;\n    }\n};\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n\n    CNeitherABNorBA solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\nstruct PrettyOS {\n    ostream& os;\n    bool first;\n    template <class T> auto operator<<(T&& x) {\n        if (!first) os << \", \";\n        first = false;\n        os << x;\n        return *this;\n    }\n};\ntemplate <class... T> void dbg0(T&&... t) {\n    (PrettyOS{cerr, true} << ... << t);\n}\n#define dbg(...)                                            \\\n    do {                                                    \\\n        cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \"; \\\n        dbg0(__VA_ARGS__);                                  \\\n        cerr << endl;                                       \\\n    } while (false);\n#else\n#define dbg(...)\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\nconst int MN = TEN(7) + TEN(3);\nV<Mint> fact(MN), iFac(MN);\n\nMint C(int n, int k) {\n    if (n < k || k < 0) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i - 1] * Mint(i);\n    }\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    V<Mint> p2(MN);\n    p2[0] = Mint(1);\n    for (int i = 1; i < MN; i++) {\n        p2[i] = p2[i - 1] * Mint(2);\n    }\n\n    assert((fact[25] * iFac[25]).v == 1);\n    int n;\n    cin >> n;\n    int m = n / 2;\n    Mint ans = Mint(3).pow(n);\n    for (int a = m + 1; a <= n; a++) {\n        ans -= Mint(2) * C(n, a) * p2[n - a];\n    }\n/*    for (int a = 0; a <= m; a++) {\n        for (int b = 0; b <= m; b++) {\n            ans += C(n, a) * C(n - a, b);\n        }\n    }*/\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define mod 998244353\n\nusing namespace std;\n\nint C[10000050];\nint n;\n\nint qexp(int b, int e){\n\tif(e == 0) return 1;\n\tint half = qexp(b,e/2) % mod;\n\thalf *= half;\n\thalf %= mod;\n\tif(e % 2 == 0) return half;\n\telse return (half*b)%mod;\n}\nint inv(int x){\n\treturn qexp(x, mod-2);\n}\nint32_t main(){\n\tcin >> n;\n\tC[0] = 1;\n\tfor(int i=1; i<=n; ++i){\n\t\tC[i] = (C[i-1]*(n-i+1)) % mod;\n\t\tC[i] *= inv(i); C[i] %= mod;\n\t}\n\tint ans = qexp(3,n);\n\tfor(int i=n/2+1; i<=n; ++i){\n\t\tint sub = 2*C[i]; sub %= mod;\n\t\tsub *= qexp(2,n-i); sub %= mod;\n\t\tans -= sub;\n\t\tans += mod; ans %= mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n/* debug macros */\n#ifdef WAFDAYO\n#define DBG_PRINT(s, t, u) { std::cerr << s << \" \\e[2m=\\e[m \\e[1m\" << t << \"\\e[m\" << u; }\n#else\n#define DBG_PRINT(s, t, u) {}\n#endif\n#define dbg(x) DBG_PRINT(#x, x, std::endl)\n#define dbgn(x) DBG_PRINT(#x, x, \", \")\n#define idbg(x, i) DBG_PRINT(#x \"[\" << i << \"]\", x[i], std::endl)\n#define idbgn(x, i) DBG_PRINT(#x \"[\" << i << \"]\", x[i], \", \")\n\n/* IO utilities */\nstruct read_input { read_input() {}; template<class T> operator T() { T t; std::cin >> t; return t; } };\n\n/* types and constants */\ntypedef long long i64;\nconst i64 inf = (i64)1.05e18;\n// const int inf = (int)1.05e9;\nconst i64 mod = 998244353;\n\ni64 modpow(i64 x, i64 a) {\n\ti64 y = 1;\n\tfor(int i = 0; i < 63; i++) {\n\t\tif((a >> i) & 1LL) {\n\t\t\ty = y * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t}\n\treturn y;\n}\n\nint main() {\n\n\tint n = read_input();\n\n\tvector<i64> fact(n + 1);\n\tvector<i64> fact_inv(n + 1);\n\n\tfact[0] = fact_inv[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tfact_inv[i] = modpow(fact[i], mod - 2);\n\t}\n\n\ti64 ans = modpow(3, n);\n\n\tfor(int k = n / 2 + 1; k <= n; k++) {\n\t\ti64 nck = (fact[n] * fact_inv[k] % mod) * fact_inv[n - k] % mod;\n\t\ti64 r = modpow(2, n - k);\n\t\ti64 s = nck * r * 2 % mod;\n\t\tans = ans - s;\n\t\tif(ans < 0) {\n\t\t\tans += mod;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (10000010)\n#define P (998244353)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,jc[N],inv[N],pw[N],ans;\nint ksm(int a,int p){\n\tint res=1;\n\twhile(p){\n\t\tif(p&1)res=1ll*res*a%P;\n\t\ta=1ll*a*a%P,p>>=1;\n\t}\n\treturn res;\n}\nint C(int n,int m){\n\treturn 1ll*jc[n]*inv[m]%P*inv[n-m]%P;\n}\nint main(){\n\tread(n); inv[0]=jc[0]=pw[0]=1;\n\tfor(int i=1;i<=n;i++)jc[i]=1ll*jc[i-1]*i%P,pw[i]=2ll*pw[i-1]%P;\n\tinv[n]=ksm(jc[n],P-2);for(int i=n-1;i;i--)inv[i]=1ll*inv[i+1]*(i+1)%P;\n\tfor(int i=n/2+1;i<=n;i++)(ans+=1ll*C(n,i)*pw[n-i]%P)%=P;\n\tprintf(\"%lld\\n\",(0ll+ksm(3,n)-ans+P-ans+P)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, x, y) for (ll i = x; i <= y; i++)\n#define BIT(t) (1ll << t)\n#define PER(i, y, x) for (ll i = y; i >= x; i--)\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define pll pair<ll, ll>\n#define SIZE(v) ll(v.size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\nusing namespace std;\ntypedef long long ll;\n//        ios::sync_with_stdio(false);\n//        cin.tie(nullptr);\n\nll const MOD = 998244353;\nll mod_p(ll x, ll y) {\n       x %= MOD;\n       y %= MOD;\n       return (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n       x %= MOD;\n       y %= MOD;\n       return x * y%MOD;\n}\n\nll mod_pow(ll x, ll t) {\n       x %= MOD;\n       if (t == 0) {\n               return 1;\n       }\n       else {\n               ll v = mod_pow(x, t / 2);\n               if (t % 2 == 0) {\n                       return v * v % MOD;\n               }\n               else {\n                       return v * v%MOD * x %MOD;\n               }\n       }\n}\n\nll mod_inv(ll x) {\n       return mod_pow(x, MOD - 2);\n}\n\nvll fct(1e7 + 5), invfct(1e7 + 5), pow2(1e7 + 5);\nvoid init(){\n        fct[0] = invfct[0] = pow2[0] = 1;\n        REP(i,1,1e7 + 2){\n                fct[i] = mod_m(fct[i-1], i);\n                invfct[i] = mod_inv(fct[i]);\n                pow2[i] = mod_m(pow2[i-1], 2);\n        }\n}\n\nll ncr(ll x,ll y){\n        return mod_m(fct[x], mod_m(invfct[y], invfct[x-y]));\n}\n\nint main(){\n        init();\n        ll n;\n        cin >> n;\n        ll m = n / 2;\n        ll tmp = 0;\n        REP(i,m+1, n){\n                tmp = mod_p(tmp, mod_m(ncr(n,i), pow2[n-i]));\n        }\n        cout << mod_p(mod_pow(3,n), mod_m(-2, tmp)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define itn int\n#define For(i, a, b) for (int i = (a); i <= static_cast<int>(b); i++)\n#define Forr(i, a, b) for (int i = (a); i >= static_cast<int>(b); i--)\n#define rep(i, n) For(i, 0, n - 1)\n#define repall(i, arr) for (auto& i : (arr))\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << '\\n'\n#define dump2(x, y) \\\n    cerr << #x << \" = \" << (x) << \" \" << #y << \" = \" << (y) << '\\n'\n#define SZ(x) ((int)(x).size())\n#define bit(n) (1LL << (n))\nconstexpr int MOD = 998244353;\n\ntemplate <typename T>\nusing pq = priority_queue<T>;\ntemplate <typename T>\nusing pqr = priority_queue<T, vector<T>, greater<T>>;\nconst int INF = LLONG_MAX / 2;\nusing P = pair<int, int>;\nusing vec = vector<int>;\ntemplate <typename T>\nusing mat = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& stream, const pair<T1, T2>& p) { return stream << p.first << \",\" << p.second; }\ntemplate <typename T>\nvoid print(const vector<T> vec) { rep (i, vec.size() - 1) cout << vec[i] << ' '; cout << vec[vec.size() - 1] << '\\n'; }\ntemplate <typename Arg>\nvoid print(const Arg arg) { cout << arg << '\\n'; }\ntemplate <typename Head, typename... Args>\nvoid print(const Head head, const Args... args) { cout << head << \" \"; print(args...); }\ntemplate <typename T, typename U>\nvoid init(vector<T>& v, vector<U>& w) { rep (i, v.size()) cin >> v[i] >> w[i]; }\ntemplate <typename T>\nvoid init(vector<T>& v) { rep (i, v.size()) cin >> v[i]; }\ntemplate <typename T>\nT sum_(vector<T> vec, T init = 0) { return std::accumulate(all(vec), T(init)); }\ntemplate<typename T>\nbool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T>\nbool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T>\nint index(const T& vec, const typename T::iterator it) { return distance(vec.begin(), it); }\ntemplate <typename T = int>\nmat<T> mmat(int n, int m=0) { return mat<T>(n, vector<T>(m)); }\ntemplate <typename T = int>\nvector<T> ivec(int n) { vector<T> v(n); init(v); return v; }\n// clang-format on\n\nvoid yn(bool tf) { print(tf ? \"Yes\" : \"No\"); }\nvoid YN(bool tf) { print(tf ? \"YES\" : \"NO\"); }\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n// -------------------------------------------------------------------\n// sort 1 2 3 4\n// pqr 1 2 3 must impl >\n// need to define MOD\nclass mint {\n    using ll = long long;\n    ll num;\n\npublic:\n    mint(ll x = 0) : num(x % MOD) {}\n    mint operator+=(const mint& x) noexcept {\n        this->num += x.num;\n        if (this->num >= MOD) this->num %= MOD;\n        return *this;\n    }\n    mint operator-=(const mint& x) noexcept {\n        if (this->num < x.num) this->num += MOD;\n        this->num -= x.num;\n        return *this;\n    }\n    mint operator*=(const mint& x) noexcept {\n        this->num = (this->num * x.num) % MOD;\n        return *this;\n    }\n    mint operator/=(mint x) noexcept {\n        ll exp = MOD - 2;\n        while (exp) {\n            if (exp % 2) *this *= x;\n            x *= x;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint operator%=(const mint& x) noexcept {\n        this->num %= x.num;\n        return *this;\n    }\n    mint operator+(const mint& x) const noexcept { return mint(*this) += x; }\n    mint operator-(const mint& x) const noexcept { return mint(*this) -= x; }\n    mint operator*(const mint& x) const noexcept { return mint(*this) *= x; }\n    mint operator/(const mint& x) const noexcept { return mint(*this) /= x; }\n    mint operator%(const mint& x) const noexcept { return mint(*this) %= x; }\n    mint operator&(const mint& x) const noexcept { return this->num & x.num; }\n    bool operator==(const mint& x) const noexcept { return this->num == x.num; }\n    bool operator!=(const mint& x) const noexcept { return not((*this) == x); }\n    explicit operator bool() const noexcept { return this->num != 0; }\n    explicit operator int() const noexcept { return this->num; }\n\n    mint pow(mint _n) {\n        mint r = mint(*this);\n        mint re = 1;\n        int n = (int)_n;\n        for (; n; n /= 2) {\n            if (n & 1) re *= r;\n            r *= r;\n        }\n        return re;\n    }\n\n    mint inv() { return this->pow(MOD - 2); }\n\n    friend ostream& operator<<(ostream&, const mint&);\n};\n\nostream& operator<<(ostream& stream, const mint& x) { return stream << x.num; }\n\nclass ModuloCombination {\n    using ll = long long;\n    ll len;\n    std::vector<mint> f, rf;\n\npublic:\n    ModuloCombination(ll max_len = 10000010)\n        : len(max_len + 1),\n          f(std::vector<mint>(len)),\n          rf(std::vector<mint>(len)) {\n        f[0] = 1;\n        for (int i = 0; i < len - 1; i++) f[i + 1] = f[i] * (i + 1);\n        rf[len - 1] = f[len - 1].inv();\n        for (int i = len - 2; i >= 0; i--) rf[i] = rf[i + 1] * (i + 1);\n    }\n    mint c(ll n, ll k) {\n        if (n < 0 or k < 0 or n - k < 0) {\n            std::cerr << \"(n,k) = \" << n << \" \" << k << std::endl;\n            exit(0);\n        }\n        return f[n] * rf[n - k] * rf[k];\n    }\n};\n\nsigned main() {\n    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<mint> po(n + 1);\n    po[0] = 1;\n    For(i, 1, n) po[i] = po[i - 1] * 2;\n\n    ModuloCombination comb;\n\n    mint kahan = 0;\n    int over = n / 2 + 1;\n    For(i, over, n) kahan += po[n - i] * comb.c(n, i);\n\n    print(mint(3).pow(n) - kahan * 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//＊最初に、入力のNを1/2倍しておく。以降では1≦N≦5*10^6として考える。\n//AB, BA -> AA, BBと置き換えて良い. （偶数番目のAをBに, BをAにした文字列Tを考えると分かる）\n//置き換え後、A,BだけならAB,BAを消せるので、AとBが同数が必要条件。\n//逆にAとBが同数(1個以上)なら, AB, BAがどこかに存在するので、帰納的に十分性が成立。\n//Cは(AまたはB)として使えるので、長さ2NのABC列であって「A,BがN個以下」を数えれば良い。\n//否定を取ると「AがN+1個以上」または「BがN+1個以上」となりこれは排反かつ対称な条件なので嬉しい。\n//「AがN+1個以上」はAの個数を全探索すれば容易に計算可能。\n//1～Nのmod P (P=998244353)での逆元の計算にO(NlogP)かけると厳しいが、これはO(N)にできるので大丈夫。\n\n#include <iostream>\n#define int long long\nusing namespace std;\n\nconst int MAX = 10000010;\nconst int mod = 998244353;\nint fact[MAX], finv[MAX], inv[MAX];\nint pow2[MAX];\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\nint n;\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tn /= 2;\n\t\n\t//参考：http://drken1215.hatenablog.com/entry/2018/06/08/210000\n\tfact[0] = fact[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (i = 2; i < MAX; i++) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n\t\n\tpow2[0] = 1;\n\tfor (i = 1; i < MAX; i++) {\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\t}\n\t\n\tint ngCnt = 0;\n\tfor (i = n + 1; i <= 2 * n; i++) {\n\t\tngCnt += comb(2 * n, i) * pow2[2 * n - i] % mod;\n\t\tngCnt %= mod;\n\t}\n\t\n\tint all = 1;\n\tfor (i = 0; i < 2 * n; i++) (all *= 3) %= mod;\n\t\n\tint ans = (all - 2 * ngCnt + 2 * mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=998244353,N=1e7+5;\nint fac[N],inv[N],pw2[N];\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tpw2[i]=pw2[i-1]*2%mod;\n} \nint C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y)%mod;\n}\nsigned main(){\n\tint n,ans=0;\n\tcin>>n;\n\tinit(n);\n\tfor(int i=n/2+1;i<=n;++i)\n\t\tadd(ans,2*C(n,i)*pw2[n-i]%mod);\n\tint res=1;\n\tfor(int i=1;i<=n;++i)\n\t\tres=res*3%mod;\n\tadd(res,(mod-ans)%mod);\n\tcout<<res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nconst int N=1e7+5;\ntypedef long long ll;\nconst ll mod=998244353;\nll qpow(ll x,ll y) {\n    ll res=1;\n    for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n    return res;\n}\nll p[N],inv[N];\nll C(int n,int m) {\n    if(n<m) return 0;\n    return p[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main() {\n    int n;\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*i%mod;\n    inv[N-1]=qpow(p[N-1],mod-2);\n    for(int i=N-2;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    scanf(\"%d\",&n);\n    ll ans=qpow(3,n);\n    for(int i=n/2+1;i<=n;i++) {\n        ll c=qpow(2,n-i+1);\n        ans=(ans-c*C(n,i)%mod+mod)%mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " //#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\nconst ll nmax = 1e9 + 7;\nconst ll Mod = 998244353;\nconst double PI = 2 * asin(1);\n\nll Pow(ll A, ll N){\n  if (N == 0) return 1;\n  else{\n    if (N % 2 == 0){\n      return Pow(A * A % Mod, N / 2) % Mod;\n    }else{\n      return A * Pow(A * A % Mod, N / 2) % Mod;\n    }\n  }\n}\n\n\nint main(){\n\n  int N; cin >> N;\n  ll ans = Pow(3, N);\n  \n  ll Pow2 = 1, nCr = 1;\n  ll sum = 1;\n  for (ll i = 1; i < N / 2; i++){\n    Pow2 *= 2; Pow2 %= Mod;\n\n    nCr *= N + 1 - i; nCr %= Mod;\n    nCr *= Pow(i, Mod - 2); nCr %= Mod;\n\n    sum += Pow2 * nCr % Mod;\n    sum %= Mod;\n  }\n  ans -= sum * 2; ans %= Mod;\n\n  if (ans < 0) ans += Mod;\n  \n  cout << ans << endl;\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nconst int MOD = 998244353;\nconst int MX = 5000005;\nint n;\nll ans = 1, k;\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nll fact[MX] = {1}, invf[MX];\nvoid setcomb(int n){\n\tfor(int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % MOD;\n\tinvf[n] =  exp(fact[n] ,MOD-2);\n\tfor(int i = n; i > 0; i--) invf[i-1] = (invf[i] * i) % MOD;\n}\ninline ll comb(int a, int b){return fact[a] * invf[a-b] % MOD * invf[b] % MOD;}\nint main(){\n\tscanf(\"%d\", &n);\n\tsetcomb(n);\n\tans = exp(3,n);\n\trep(i,n/2) ans -= comb(n,i) * exp(2,i) * 2 % MOD;\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f1r(i,a,b) for (int i = (a); i < (b); ++i)\n#define f0r(i,a) f1r(i,0,a)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n    #ifdef TQIAN\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n    #else\n    #define dbg(x...) 0\n    #endif\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        // cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll)val*m.val%MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a,MOD-2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e7+5;\nmi ifact[MAX];\nmi fact[MAX];\nmi choose(int n, int k){\n    if(n < k) return 0;\n    return fact[n] * ifact[n-k] * ifact[k];\n}\nint main(){\n    fact[0] = ifact[0] = 1;\n    f1r(i, 1, MAX) fact[i] = fact[i-1] * i, ifact[i] = ifact[i-1] / i;\n    setIO(\"\");\n    int n; re(n);\n    mi ans = 1;\n    f0r(i, n) ans *= 3;\n    mi sub = 0;\n    f1r(k, n/2+1, n+1){\n        sub += choose(n, k)*pow(mi(2), n-k);\n    }\n    ans -= sub * 2;\n    ps(ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAXN = 1e7 + 10;\nconst long long MOD = 998244353;\n\nvector<long long> fact(MAXN);\n\nlong long gcde(long long a, long long b, long long *x, long long *y)\n{\n  if(a == 0)\n  {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = gcde(b % a, a, &x1, &y1);\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n  return gcd;\n}\n\nlong long inv(long long a)\n{\n  long long x, y;\n  long long g = gcde(a, MOD, &x, &y);\n  assert(g == 1);\n  long long res = (x % MOD + MOD) % MOD;\n  return res;\n}\n\nvoid evalf()\n{\n  fact[0] = 1;\n  for(int i = 1; i < MAXN; i++)\n  {\n    fact[i] = (fact[i - 1] * i) % MOD;\n  }\n}\n\nlong long binary_expo(long long a, long long n)\n{\n  if(n == 0) return 1;\n  if(n == 1) return a;\n  long long p = binary_expo(a, n / 2);\n  (p *= p) %= MOD;\n  if(n & 1) (p *= a) %= MOD;\n  return p;\n}\n\nlong long ncr(long long n, long long r)\n{\n  long long ans = (fact[n] * inv(fact[n - r])) % MOD;\n  (ans *= inv(fact[r])) %= MOD;\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  evalf();\n  long long n;\n  cin >> n;\n  long long ans = 1, nans = 0;\n  for(int i = (n / 2) + 1; i <= n; i++)\n  {\n    long long ts = binary_expo(2, n - i);\n    (ts *= ncr(n, i)) %= MOD;\n    (nans += ts) %= MOD;\n  }\n  for(int i = 0; i < n; i++)\n  {\n    (ans *= 3) %= MOD;\n  }\n  (nans *= 2) %= MOD;\n  ans = (((ans - nans) % MOD) + MOD) % MOD;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e7 + 10;\nconst int M = 998244353;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[N], rfact[N];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (ll) i * fact[i - 1] % M;\n    }\n    rfact[N - 1] = pw(fact[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        rfact[i] = (ll) (i + 1) * rfact[i + 1] % M;\n    }\n}\n\nvoid smain() {\n    init();\n    int n;\n    cin >> n;\n    n >>= 1;\n\n    int ans = 0;\n    fori (a0, n + 1) {\n        fori (b0, n - a0 + 1) {\n            int c0 = n - a0 - b0;\n                fori (a1, n + 1) {\n                    fori (b1, n + 1 - a1) {\n                        int c1 = n - a1 - b1;\n                            if (a0 <= b1 + c1 &&\n                                    a1 <= b0 + c0 &&\n                                    b0 <= a1 + c1 &&\n                                    b1 <= a0 + c0) {\n                                int cur = (ll) fact[n] * rfact[a0] % M * rfact[b0] % M * rfact[c0] % M;\n                                cur = (ll) cur * fact[n] % M * rfact[a1] % M * rfact[b1] % M * rfact[c1] % M;\n                                ans = (ans + cur) % M;\n                            }\n                        }\n                    }\n                }\n            }\n\n\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = 1;\n\trep1(i, N) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll ima = ifac[N2];\n\tll k = modpow(2, N2 - 1);\n\trep(i, N2) {\n\t\tima = ima * (N2 - i) % mod;\n\t\thiku += ima * ifac[N2 - i - 1] % mod * k % mod;\n\t\tk = k * inv2 % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n#define incID(i, l, r) for(LL i = (l)    ; i <  (r); ++i)\n#define incII(i, l, r) for(LL i = (l)    ; i <= (r); ++i)\n#define decID(i, l, r) for(LL i = (r) - 1; i >= (l); --i)\n#define decII(i, l, r) for(LL i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec(i, n)  decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\ntemplate<typename T> bool setmin  (T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmax  (T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\nLL mo(LL a, LL b) { assert(b > 0); a %= b; if(a < 0) { a += b; } return a; }\nLL fl(LL a, LL b) { assert(b > 0); return (a > 0 ? a / b : (a - b + 1) / b); }\nLL ce(LL a, LL b) { assert(b > 0); return (a < 0 ? a / b : (a + b - 1) / b); }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n#define bit(b, i) (((b) >> (i)) & 1)\n#define BC __builtin_popcountll\n#define SC static_cast\n#define SI(v) SC<int>(v.size())\n#define SL(v) SC<LL >(v.size())\n#define RF(e, v) for(auto & e: v)\n#define ef else if\n#define UR assert(false)\n\n// ---- ----\n\ntemplate<LL M> class ModInt {\nprivate:\n\tLL v = 0;\npublic:\n\tModInt() { }\n\tModInt(LL vv) { setval(vv); }\n\tModInt & setval(LL vv) { v = vv % M; if(v < 0) { v += M; } return (*this); }\n\tLL getval() const { return v; }\n\tModInt & operator+=(const ModInt & b)       { return setval(v + b.v); }\n\tModInt & operator-=(const ModInt & b)       { return setval(v - b.v); }\n\tModInt & operator*=(const ModInt & b)       { return setval(v * b.v); }\n\tModInt & operator/=(const ModInt & b)       { return setval(v * b.inv()); }\n\tModInt & operator^=(            LU b)       { return setval(ex(v, b)); }\n\tModInt   operator+ (                ) const { return ModInt(+v); }\n\tModInt   operator- (                ) const { return ModInt(-v); }\n\tModInt   operator+ (const ModInt & b) const { return ModInt(v + b.v); }\n\tModInt   operator- (const ModInt & b) const { return ModInt(v - b.v); }\n\tModInt   operator* (const ModInt & b) const { return ModInt(v * b.v); }\n\tModInt   operator/ (const ModInt & b) const { return ModInt(v * b.inv()); }\n\tModInt   operator^ (            LU b) const { return ModInt(ex(v, b)); }\n\tLL inv() const {\n\t\tLL x = (ex_gcd(v, M).FI + M) % M;\n\t\tassert(v * x % M == 1);\n\t\treturn x;\n\t}\n\tLL ex(LL a, LU b) const {\n\t\tLL D = 64, x[64], y = 1;\n\t\tinc(i, D) { if((b >> i) == 0) { D = i; break; } }\n\t\tinc(i, D) { x[i] = (i == 0 ? a : x[i - 1] * x[i - 1]) % M; }\n\t\tinc(i, D) { if((b >> i) & 1) { (y *= x[i]) %= M; } }\n\t\treturn y;\n\t}\n\tpair<LL, LL> ex_gcd(LL a, LL b) const {\n\t\tif(b == 0) { return MP(1, 0); }\n\t\tauto p = ex_gcd(b, a % b);\n\t\treturn MP(p.SE, p.FI - (a / b) * p.SE);\n\t}\n};\ntemplate<LL M> ModInt<M> operator+(LL a, const ModInt<M> & b) { return  b + a; }\ntemplate<LL M> ModInt<M> operator-(LL a, const ModInt<M> & b) { return -b + a; }\ntemplate<LL M> ModInt<M> operator*(LL a, const ModInt<M> & b) { return  b * a; }\ntemplate<LL M> ModInt<M> operator/(LL a, const ModInt<M> & b) { return  a * b.inv(); }\ntemplate<LL M> istream & operator>>(istream & is, ModInt<M> & b) { LL v; is >> v; b.setval(v); return is; }\ntemplate<LL M> ostream & operator<<(ostream & os, const ModInt<M> & b) { return (os << b.getval()); }\n\n// ---- ----\n\ntypedef ModInt<998244353> MI;\n\nint main() {\n\tLL n;\n\tcin >> n;\n\t\n\tMI fn = 1;\n\tinc1(i, n) { fn *= i; }\n\t\n\tvector<MI> r(n + 1);\n\tr[n] = 1 / fn;\n\tdec(i, n) { r[i] = r[i + 1] * (i + 1); }\n\t\n\tMI sum = 0, bi = 1;\n\tinc(i, n / 2) { sum += bi * r[i] * r[n - i]; bi *= 2; }\n\t\n\tcout << (MI(3) ^ n) - 2 * fn * sum << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=998244353;\nint n;\n#define Maxn 10000010\nint two[Maxn];\nint fact[Maxn],inv[Maxn];\n\ninline int Fast_Pow(int a,int b){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1)res=1ll*res*a%Mod;\n\t\ta=1ll*a*a%Mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n \ninline int C(int i,int j){return 1ll*fact[i]*inv[i-j]%Mod*inv[j]%Mod;}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;++i)fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1;\n\tfor(int i=2;i<=n;++i)inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(int i=2;i<=n;++i)inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n\tint res=Fast_Pow(3,n);\n\ttwo[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\ttwo[i]=two[i-1]+two[i-1];\n\t\tif(two[i]>=Mod)two[i]-=Mod;\n\t}\n\tfor(int i=n/2+1;i<=n;++i)\n\t\tres=(res-1ll*C(n,i)*two[n-i+1]%Mod+Mod)%Mod;\n\tprintf(\"%d\\n\",res);\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<char,char> PCC;\ntypedef pair<ll,ll> PLL;\ntypedef pair<char,int> PCI;\ntypedef pair<int,char> PIC;\ntypedef pair<ll,int> PLI;\ntypedef pair<int,ll> PIL; \ntypedef pair<ll,char> PLC; \ntypedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\ntemplate<int MOD> struct Fp {\n    ll val;\n    constexpr Fp(ll v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\n//const int MOD = 1e6 + 3;\n//const int MOD = 1e9 + 7;\nconst int N_MAX = 2e5+5;\n//mint:mod演算のための型\nusing mint = Fp<MOD>;\n//型変換\n#define MINT (mint)\n\n//mod MOD上での階乗\nmint fact[N_MAX];\nmint finv[N_MAX];\nvoid init(){\n  fact[0] = fact[1] = MINT 1;\n  for(int i = 2; i < N_MAX; i++){\n    fact[i] = fact[i-1] * i;\n  }\n  finv[N_MAX-1] = MINT 1/fact[N_MAX-1];\n  for(int i = N_MAX-1; i>0; --i){\n    finv[i-1] = finv[i] * i;\n  }\n}\n\n//mod MOD上での逆元\ninline mint inv(mint n){\n  return MINT 1/n;\n}\n\n//二項係数の計算(mod MOD上)\ninline mint COM(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[k]*finv[n-k];\n}\n\n//順列計算\ninline mint PER(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[n-k];\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  init();\n  int N;cin >> N;\n  mint ans = modpow(MINT 3, N);\n  repp(k,N/2+1,N+1){\n    ans -= MINT 2 * COM(N,k)*modpow(MINT 2,N-k);\n  }\n  cout << ans << endl;\n  return 0;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n//#define HOME\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define F first\n#define S second\n\ntemplate<class T> void _R(T &_x) { cin >> _x; }\nvoid _R(int &_x) { scanf(\"%d\", &_x); }\nvoid _R(int64_t &_x) { scanf(\"%\" SCNd64, &_x); }\nvoid _R(double &_x) { scanf(\"%lf\", &_x); }\nvoid _R(char &_x) { scanf(\" %c\", &_x); }\nvoid _R(char *_x) { scanf(\"%s\", _x); }\ntemplate<class T, class U> void _R(pair<T, U> &_x) {_R(_x.F); _R(_x.S);}\nvoid R() {}\ntemplate<class T, class... U> void R(T &_head, U &... _tail) { _R(_head); R(_tail...); }\n\ntemplate<class T> void _W(const T &_x) { cout << _x; }\nvoid _W(const int &_x) { printf(\"%d\", _x); }\nvoid _W(const int64_t &_x) { printf(\"%\" PRId64, _x); }\nvoid _W(const double &_x) { printf(\"%.16f\", _x); }\nvoid _W(const char &_x) { putchar(_x); }\nvoid _W(const char *_x) { printf(\"%s\", _x); }\ntemplate<class T, class U> void _W(const pair<T, U> &_x) {_W(_x.F); putchar(' '); _W(_x.S);}\ntemplate<class T> void _W(const vector<T> &_x) { for (auto i = _x.begin(); i != _x.end(); _W(*i++)) if (i != _x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &_head, const U &... _tail) { _W(_head); putchar(sizeof...(_tail) ? ' ' : '\\n'); W(_tail...); }\ntemplate<class T, class... U> void DB(const T &_head, const U &... _tail) {\n#ifdef HOME\n    W('#', _head, _tail...);\n#endif\n}\n\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define RAN(x,n) (x).begin(), (x).begin()+(n)\n#define UNIQUE(x) {sort(ALL(x)); (x).erase(unique(ALL(x)), (x).end());}\n\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n//#define ITER(i,t) for (auto i = t.begin(); i != t.end(); ++i)\n#define IT3(i,st,ed) for (auto i = st; i != ed; ++i)\n#define IT2(i,range) IT3(i,range)\n\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define MS(X, v) memset((X), (v), sizeof((X)))\n\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\ntypedef int64_t ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\ninline int LG (const unsigned int &_x) { return 31-__builtin_clz(_x); }  // floor: LG(x), ceil: LG(x-1)+1\n/*}}}*/\n\nconst int MOD = 998244353;\n\nint n;\n\n/*\n2 * C(n, k) * 2^(n-k), k = ceil(n/2) ... n\n*/\n\nint ADD(int a, int b){ return (a + b) % MOD; }\nint MUL(int a, int b){ return (ll)a * b % MOD; }\nint POW(int a, int p){\n    int r = 1, t = a;\n    for(; p; p >>= 1, t = MUL(t, t))\n        if(p & 1) r = MUL(r, t);\n    return r;\n}\nint INV(int a){ return POW(a, MOD-2); }\n\nint main(){\n    R(n);\n\n    int ans = POW(3, n);\n    int p2 = 1, c = 1;\n    REPD(k, n, n/2+1){\n        ans = ADD(ans, MOD - MUL(2 * p2, c));\n        p2 = MUL(p2, 2);\n        c = MUL(MUL(c, k), INV(n-k+1));\n    }\n\n    W(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\n\nvector<int64_t> factors;\nvector<int64_t> finvs;\nvoid precalc_nCr(int n, int64_t rem) {\n\tfactors = vector<int64_t>(n + 1);\n\tfinvs = vector<int64_t>(n + 1);\n\n\t{\n\t\tint64_t f = 1;\n\t\tfactors[0] = 1;\n\t\tFOR_LE(i, 1, n) {\n\t\t\tf *= i;\n\t\t\tf %= rem;\n\t\t\tfactors[i] = f;\n\t\t}\n\t}\n\t{\n\t\tint64_t inv = divide_rem(1, factors[n], rem);\n\t\tfinvs[n] = inv;\n\t\tFOR_DW(i, n - 1, 0) {\n\t\t\tinv *= i + 1;\n\t\t\tinv %= rem;\n\t\t\tfinvs[i] = inv;\n\t\t}\n\t}\n}\n\nint64_t nCr(int n, int k) {\n\tint64_t val = factors[n];\n\tval *= finvs[n - k];\n\tval %= kRem;\n\tval *= finvs[k];\n\tval %= kRem;\n\treturn val;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tprecalc_nCr(n, kRem);\n\tvector<int64_t> pow2(n / 2);\n\tpow2[0] = 1;\n\tFOR_LT(i, 1, n / 2) {\n\t\tpow2[i] = pow2[i - 1] * 2;\n\t\tpow2[i] %= kRem;\n\t}\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = nCr(n, k);\n\t\tval *= pow2[n - k];\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 10000000 + 10;\nconst ll MOD = 998244353;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint fac[N], inv[N], tav[N], mx[N];\n\nint POW(int x, int y){\n\tint res = 1;\n\twhile (y){\n\t\tif (y & 1) res = res * 1ll * x % MOD;\n\t\ty >>= 1;\n\t\tx = x * 1ll * x % MOD;\n\t}\n\treturn res;\n}\n\nint nCr(int a, int b){\n\tif (b < 0 || a < 0 || b > a) return 0;\n\tint res = fac[a];\n\tres = res * 1ll *inv[b] % MOD;\n\tres = res * 1ll * inv[a - b] % MOD;\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint n;\n\tcin >> n;\n\tfac[0] = tav[0] = 1;\n\tfor (int i = 1; i < N; i++) tav[i] = tav[i - 1] * 2ll % MOD;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * 1ll * i % MOD;\n\tinv[N - 1] = POW(fac[N - 1], MOD - 2);\n\tfor (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * 1ll * (i + 1) % MOD;\n\tint ans = POW(3, n);\n\tfor (int i = n / 2 + 1; i <= n; i++){\n\t\tint res = nCr(n, i) * 1ll * tav[n - i] % MOD;\n\t\tans -= res * 2ll % MOD;\n\t\tans %= MOD;\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans;\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define _overload3(_1,_2,_3,name,...)name\n#define _rep(i,n)repi(i,0,n)\n#define repi(i,a,b)for(int i=int(a),i##_len=(b);i<i##_len;++i)\n#define MSVC_UNKO(x)x\n#define rep(...)MSVC_UNKO(_overload3(__VA_ARGS__,repi,_rep,_rep)(__VA_ARGS__))\n#define all(c)c.begin(),c.end()\n#define write(x)cout<<(x)<<'\\n'\nusing namespace std; typedef long long ll; template<class T>using vv = vector<vector<T>>;\ntemplate<class T>auto vvec(int n, int m, T v) { return vv<T>(n, vector<T>(m, v)); }\ntemplate<class T, class U>bool chmax(T& a, U&& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T, class U>bool chmin(T& a, U&& b) { return b < a ? a = b, 1 : 0; }\nconstexpr int INF = 1 << 29, MOD = 998244353; constexpr ll LINF = 1LL << 60;\nstruct aaa { aaa() { cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }; }aaaa;\n\nstruct Combination {\n    static ll mpow(ll x, ll n) { ll y = 1; for (; n > 0; n /= 2) { y = n % 2 ? y * x % MOD : y; x = x * x % MOD; } return y; }\n    vector<ll> fact, ifact;\n    Combination(int n) : fact(n + 1), ifact(n + 1) {\n        fact[0] = 1; for (int i = 0; i < n; ++i) fact[i + 1] = fact[i] * (i + 1) % MOD;\n        ifact[n] = mpow(fact[n], MOD - 2); for (int i = n; i > 0; --i) ifact[i - 1] = ifact[i] * i % MOD;\n    }\n    ll operator ()(int n, int k) { return k < 0 || k > n ? 0 : fact[n] * ifact[n - k] % MOD * ifact[k] % MOD; }\n} C(1e7);\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<ll> pow2(N + 1);\n    pow2[0] = 1;\n    rep(i, N) pow2[i + 1] = pow2[i] * 2 % MOD;\n\n    ll ans = 1;\n    rep(i, N) ans = ans * 3 % MOD;\n\n    rep(i, N / 2 + 1, N + 1) {\n        ans = (ans - 2 * C(N, i) * pow2[N - i]) % MOD;\n    }\n    if (ans < 0) ans += MOD;\n\n    write(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 10000005;\n\nlong long modpow(long long a, long long p){\n\tif(p == 0)return 1;\n\tif(p % 2 == 1)return a * modpow(a, p - 1) % MOD;\n\t\n\tlong long r = modpow(a, p / 2);\n\treturn r * r % MOD;\n}\nlong long modinv(long long a){\n\treturn modpow(a, MOD - 2);\n}\n\nint N;\nlong long fact[MAXN], invfact[MAXN];\n\nlong long C(int n, int r){\n\treturn fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;\n}\n\nint main(){\t\n\tscanf(\"%d\", &N);\n\t\n\tfor(int i = 0; i <= N; i++){\n\t\tif(i == 0)fact[i] = 1;\n\t\telse fact[i] = i * fact[i - 1] % MOD;\n\t}\n\t\n\tfor(int i = N; i >= 0; i--){\n\t\tif(i == N)invfact[i] = modinv(fact[i]);\n\t\telse invfact[i] = (i + 1) * invfact[i + 1] % MOD;\n\t}\n\t\n\tlong long res = 0, cur = 1;\n\tfor(int c = 0; c <= N; c++){\n\t\tres = (res + cur * C(N, c)) % MOD;\n\t\t\n\t\tif(c < N){\n\t\t\tcur = cur * 2 % MOD;\n\t\t\tif(c >= N / 2)cur = (cur - 2 * C(c, N / 2) + 2LL * MOD) % MOD;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\nusing lint = long long;\nconstexpr int MOD = 998244353, INF = 1010101010;\nconstexpr lint LINF = 1LL << 60;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\\n\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\ntemplate<int Modulo = MOD> struct Mint {\n\n\tlint val;\n\tconstexpr Mint(lint v = 0) noexcept : val(v % Modulo) { if (val < 0) v += Modulo; }\n\n\tconstexpr Mint& operator += (const Mint &r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= Modulo) val -= Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -= (const Mint &r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *= (const Mint &r) noexcept {\n\t\tval = val * r.val % Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator /= (const Mint &r) noexcept {\n\t\tlint a = r.val, b = Modulo, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlint t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % Modulo;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint operator + (const Mint &r) const noexcept { return Mint(*this) += r; }\n\tconstexpr Mint operator - (const Mint &r) const noexcept { return Mint(*this) -= r; }\n\tconstexpr Mint operator * (const Mint &r) const noexcept { return Mint(*this) *= r; }\n\tconstexpr Mint operator / (const Mint &r) const noexcept { return Mint(*this) /= r; }\n\n\tconstexpr int getmod() { return Modulo; }\n\tconstexpr Mint operator - () const noexcept { return val ? Modulo - val : 0; }\n\n\tconstexpr bool operator == (const Mint &r) const noexcept { return val == r.val; }\n\tconstexpr bool operator != (const Mint &r) const noexcept { return val != r.val; }\n\n\tfriend ostream &operator << (ostream &os, const Mint<Modulo> &x) noexcept { return os << x.val; }\n\tfriend istream &operator >> (istream &is, Mint<Modulo> &x) noexcept {\n\t\tlint tmp; is >> tmp;\n\t\tx = Mint<Modulo>(tmp);\n\t\treturn is;\n\t}\n\tfriend constexpr Mint<Modulo> modpow(const Mint<Modulo> &a, lint n) noexcept {\n\t\tMint res(1), tmp = a;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nusing mint = Mint<>;\n\ntemplate<class T>\nvector<T> make_vec(size_t s, T val) { return vector<T>(s, val); }\ntemplate<class... Size>\nauto make_vec(size_t s, Size... tail) {\n\treturn vector<decltype(make_vec(tail...))>(s, make_vec(tail...));\n}\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tauto dp = make_vec(N / 2 + 1, 9, mint(0));\n\tdp[1] = { 1,0,1,0,1,1,1,1,1 }; // AA AB AC BA BB BC CA CB CC\n\n\tfor (int i = 1; i < N / 2; i++) {\n\n\t\tmint sum = 0;\n\t\tfor (int j = 0; j < 9; j++) sum += dp[i][j]; // AB BA 以外を後ろにつける\n\t\tfor (int j = 0; j < 9; j++) dp[i + 1][j] += sum;\n\n\t\t// 間に入れてAB BA ができる場合、それはそこまでで後ろにつける操作では実現不可能な並び\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tfor (int k = 0; k < 9; k++) {\n\n\t\t\t\tif (k == 1 || k == 3) continue;\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 || j / 3 * 3 + k / 3 == 3) && (j % 3 + k % 3 * 3 == 1 || j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 && j % 3 * 3 + k % 3 == 1) || (j / 3 + k / 3 * 3 == 3 && j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] -= dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//DMP(dp);\n\n\tmint ans = 0;\n\tfor (int i = 0; i < 9; i++) ans += dp[N / 2][i];\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b) do { cout << \"[\"; for (int count = (a);count < (b);++count) cout << ary[count] << ((b)-1 == count ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\n// const ll mod = 1000000007;\nconst ll mod = 998244353;\n\nconst int MAX_N = 10000010;\nll fact[MAX_N],fact_inv[MAX_N],inv[MAX_N];\n\nll pow_mod(ll a,ll b) {\n    ll ret;\n    if (b < 0) ret = pow_mod(a,mod+b-1);\n    else if (b == 0) ret = 1;\n    else if (b == 1) ret = a;\n    else {\n        ll c = pow_mod(a,b/2);\n        if (b%2) ret = (c*c)%mod*a%mod;\n        else ret = c*c%mod;\n    }\n    return ret;\n}\n\nvoid generate_table(int x) {\n    fact[0] = 1;fact[1] = 1;\n    for (int i = 2;i <= x;++i) fact[i] = fact[i-1]*i%mod;\n    fact_inv[x] = pow_mod(fact[x],-1);\n    for (int i = x;i > 0;--i) fact_inv[i-1] = fact_inv[i]*i%mod;\n    for (int i = 1;i <= x;++i) inv[i] = fact_inv[i]*fact[i-1]%mod;\n}\n\nll combi(ll a, ll b) {\n    return fact[a]*fact_inv[b]%mod*fact_inv[a-b]%mod;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    generate_table(n);\n    vector<ll> pow2(n+1,1);\n    for (int i = 0;i < n;++i) pow2[i+1] = pow2[i]*2%mod;\n    ll ans = pow_mod(3,n);\n    for (int i = 0;i < n/2;++i) {\n        (ans -= combi(n,i)*pow2[i]*2%mod) %= mod;\n    }\n    cout << (ans+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD  998244353\nconst long long nmax = 1e7+1;\n\nusing namespace std;\n\nint n;\nlong long thr[nmax], tw[nmax], fr[nmax];\n\nlong long mul(long long a, long long b)\n{\n    return (a * b) % MOD;\n}\n\nlong long add(long long a, long long b)\n{\n    return (a + b) % MOD;\n}\n\nlong long sub(long long a, long long b)\n{\n    long long o = a - b;\n\n    while (o < 0) o += MOD;\n    return o;\n}\n\nlong long Pow(long long a, long long b)\n{\n    if (b == 1) return a;\n    long long o = Pow(a, b/2);\n\n    if (b % 2 == 1) return mul(mul(o, o), a);\n    return mul(o, o);\n}\n\nlong long Ckn(long long a, long long b)\n{\n    return mul(fr[b], Pow(mul(fr[a], fr[b-a]), MOD - 2));\n}\n\nvoid Input()\n{\n    ios_base::sync_with_stdio(0);       cin.tie(0);\n\n//    freopen(\"abc.txt\", \"r\", stdin);\n\n    cin >> n;   thr[0] = tw[0] = fr[0] = 1;\n    for (int i=1; i<=n; i++)\n    {\n        thr[i] = mul(thr[i-1], 3);\n        tw[i] = mul(tw[i-1], 2);\n        fr[i] = mul(fr[i-1], i);\n    }\n}\n\nvoid Process()\n{\n    long long ans = 0;\n    for (int i=n/2+1; i<=n; i++)\n        ans = add(ans, mul(Ckn(i, n), tw[n-i+1]));\n\n//    cout << Ckn(2, n) << endl;\n//    cout << ans << endl;\n\n    cout << sub(thr[n], ans);\n}\n\nint main()\n{\n    Input();\n    Process();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int MOD=998244353;\nconst int N=1e7+10;\nlong long int f[N],inf[N];\nlong long int POW(long long int a,long long int b){\n\tlong long int ans=1;\n\twhile(b){\n\t\tif(b&1)ans=(ans*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nlong long int Inv(long long int n){return POW(n,MOD-2);}\nlong long int C(long long int n,long long int m){return (f[n]*((inf[m]*inf[n-m])%MOD))%MOD;}\nvoid pre(){\n\tinf[0]=inf[1]=f[0]=f[1]=1;\n\tfor(int i=2;i<N;i++)f[i]=(f[i-1]*i)%MOD;\n\tinf[N-1]=Inv(f[N-1]);\n\tfor(int i=N-2;i>=2;i--)inf[i]=(inf[i+1]*(i+1))%MOD;\n\treturn ;\n}\nint main(){\n\tpre();\n\tint n;\n\tlong long int ans=0,temp;\n\tscanf(\"%d\",&n);\n\tans=POW(3,n);\n\tfor(int i=n/2+1;i<=n;i++){\n\t\ttemp=POW(2,n-i+1);\n\t\ttemp=(temp*C(n,i))%MOD;\n\t\tans=(ans-temp+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nvll factorial; \nvll inv;\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\n\nll choose(ll n, ll k) {\n    return factorial[n] * inv[factorial[k]] % MOD * inv[factorial[n-k]] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    factorial.resize(N+1);\n    factorial[0] = 1;\n    FOR(i, 1, N+1) factorial[i] = factorial[i-1] * i % MOD;\n\n    inv.resize(MOD);\n    inv[1] = 1;\n    for(int i = 2; i < MOD; ++i) inv[i] = (MOD - (MOD/i) * inv[MOD%i] % MOD) % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * binpow(2, N-i);\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n\n\n\n#if 1\nconst int MOD = 998244353;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) ans = (1LL * ans * a) % MOD;\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\ninline void add(int &x, int y) {\n    x += y;\n    mod(x);\n}\n\ninline void sub(int &x, int y) {\n    x += MOD - y;\n    mod(x);\n}\n\ninline void mul(int &x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int inv(int x) {\n    return lgput(x, MOD - 2);\n}\n#endif\n\n#if 0\nint fact[], invfact[];\n\ninline void prec(int n) {\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    invfact[n] = lgput(fact[n], MOD - 2);\n    for(int i = n - 1; i >= 0; i--) {\n        invfact[i] = (1LL * invfact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\ninline int comb(int n, int k) {\n    if(n < k) return 0;\n    return (1LL * fact[n] * (1LL * invfact[k] * invfact[n - k] % MOD)) % MOD;\n}\n#endif\n\nusing namespace std;\n\n\n\nint main() {\n#if HOME\n    ifstream cin(\"B.in\");\n    ofstream cout(\"B.out\");\n#endif\n    int i, n;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    int ans = lgput(3, n);\n    int bad = 0, cmb = 1;\n    for(i = 1; i <= n / 2; i++) {\n        mul(cmb, n - i + 1);\n        mul(cmb, inv(i));\n    }\n    for(i = n / 2 + 1; i <= n; i++) {\n        int cur = lgput(2, n - i);\n        // comb(n, i) = n! / i! * (n - i)!\n        // comb(n, i - 1) = n! / (i - 1)! * (n - i + 1)!\n        mul(cmb, n - i + 1);\n        mul(cmb, inv(i));\n        mul(cur, cmb);\n        add(bad, cur);\n    }\n\n    mul(bad, 2);\n    sub(ans, bad);\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n \nusing ll = long long;\nusing P = std::pair<ll, ll>;\n \n#define rep(i, a, b) for (ll(i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" << i << std::endl\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nll pow_mod(ll a, ll b, ll mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  ll x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \nconst ll MOD = 998244353;\n// const ll MOD = 1e9 + 7;\n \nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<ll> pow(n/2,1),conv(n/2,1),inv(n/2,1);\n\n  rep(i,2,n/2){\n    inv[i]=(inv[MOD%i]*(MOD-MOD/i))%MOD;\n  }\n\n  rep(i,1,n/2){\n    pow[i]=(pow[i-1]*2)%MOD;\n    conv[i]=(((conv[i-1]*(n+1-i))%MOD)*inv[i])%MOD;\n  }\n\n  ll sum=0;\n\n  rep(i,0,n/2){\n    sum=(sum+(conv[i]*pow[i])%MOD)%MOD;\n  }\n\n  sum=(sum*2)%MOD;\n\n  std::cout<<(pow_mod(3,n,MOD)-sum+MOD)%MOD;\n\n  \n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 998244353;\n\nvector<ll> fact{1};\nll fast_pow(ll x, ll p) {\n\tll r = 1;\n\twhile (p) {\n\t\tif (p & 1) r = (r * x) % MOD;\n\t\tx = (x * x) % MOD;\n\t\tp /= 2;\n\t}\n\treturn r;\n}\nll inv(ll x) {\n\treturn fast_pow(x, MOD - 2);\n}\nll mul(ll a, ll b) {\n\treturn (a * b) % MOD;\n}\nll binom(ll n, ll k) {\n\treturn (fact[n] * inv((fact[n - k] * fact[k]) % MOD)) % MOD;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tint n;\n\tscan n;\n\tfor (int i = 1; i < n + 10; i++) {\n\t\tfact.pb((i * fact.back()) % MOD);\n\t}\n\t// for (int i = 2; i < 100; i += 2) {\n\t\t// n = i;\n\t\tll rez = fast_pow(3, n);\n\t\tfor (int x = n / 2 + 1; x <= n; x++) {\t\n\t\t\trez -= 2 * ((binom(n, x) * fast_pow(2, n - x)) % MOD);\n\t\t\trez %= MOD;\n\t\t}\n\t\tif (rez < 0) rez += MOD;\n\t\t// for (int y = 0; y <= n / 2; y++) {\n\t\t// }\n\t\tprint rez;\n\t\t// print \"f(\", n / 2, \")=\", rez,\",\";\n\t\t// fflush(stdout);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD  (ll)998244353\n\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\nll Fa[10101010], iFa[10101010];\nll p2[10101010];\nll C(ll a,ll b){\n    return Fa[a] * iFa[b] % MOD * iFa[a - b] % MOD;\n}\n\nll N;\nll i, j, k,ans;\n\n\nint main(){\n    scanf(\"%lld\",&N);\n    Fa[0] = 1;\n    p2[0] = 1;\n    fornum(i,0,N){\n        Fa[i + 1] = Fa[i] * (i + 1) % MOD;\n        p2[i + 1] = p2[i] * 2 % MOD;\n    }\n    iFa[N] = moddiv(1, Fa[N]);\n    for (i = N; i > 0;i--)\n    {\n        iFa[i - 1] = iFa[i] * i % MOD;\n    }\n\n    ans = 1;\n    fornum(i,0,N){\n        ans = ans * 3 % MOD;\n    }\n    fornum(i,N/2+1,N+1){\n        ans = ans + (MOD - C(N, i) * p2[N - i]) * 2 % MOD;\n        ans %= MOD;\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AGC040C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e7 + 200, mod = 998244353;\n\nint fac[MAX_N], inv[MAX_N], fac_inv[MAX_N], n, pow2[MAX_N];\n\nint quick_pow(int bas, int tim)\n{\n    int ret = 1;\n    while (tim)\n    {\n        if (tim & 1)\n            ret = 1LL * ret * bas % mod;\n        bas = 1LL * bas * bas % mod;\n        tim >>= 1;\n    }\n    return ret;\n}\n\nint comb(int n_, int k_) { return 1LL * fac[n_] * fac_inv[n_ - k_] % mod * fac_inv[k_] % mod; }\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = fac[0] = pow2[0] = 1; i <= n; i++)\n        fac[i] = 1LL * fac[i - 1] * i % mod, pow2[i] = 1LL * pow2[i - 1] * 2 % mod;\n    fac_inv[n] = quick_pow(fac[n], mod - 2);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        inv[i] = 1LL * fac_inv[i + 1] * fac[i] % mod;\n        fac_inv[i] = 1LL * fac_inv[i + 1] * (i + 1) % mod;\n    }\n    int ans = quick_pow(3, n);\n    for (int i = (n >> 1) + 1; i <= n; i++)\n        ans = (1LL * ans - 2LL * comb(n, i) * pow2[n - i] % mod + mod) % mod;\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,ans,jc[10000010],jcv[10000010];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tjc[0]=1;\n\tfor(int i=1;i<=n;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[n]=kpow(jc[n],mod-2);\n\tfor(int i=n;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n\tint po=1;\n\tfor(int i=n;i>n/2;--i)\n\t{\n\t\tans=(ans+1ll*jcv[i]*jcv[n-i]%mod*po)%mod;\n\t\t(po+=po)>=mod?po-=mod:0;\n\t}\n\tans=(kpow(3,n)+2ll*(mod-ans)*jc[n]%mod)%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 10555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mod_pow(2, n - i) % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define fr first\n# define sc second\n# define pb push_back\n# define int long long\n# define mk make_pair\n# define sz(s) (int)s.size()\n# define all(s) s.begin(), s.end()\nusing namespace std;\nconst int N = 1e6+12,INF = 1000000007;\nint a[N];\nmap <string,bool> m;\n\nmain(){\n    int n;\n    cin>>n;\n    cout <<62;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, int> i_i;\nll INF = 1e9+10;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\nvector<pair<ll, ll> > pairs;\n\nll n, mod = 998244353;\nconst ll MAX = 1e7 + 1;\nvector<ll> v(MAX);\n\nll inv[MAX];\n\nvoid init() {\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    }\n}\n\nint main()\n{\n    ll N;\n    cin >> N;\n    init();\n    \n    ll sub = 0;\n    ll beki = 1, nCk = 1;\n    for (int i = N; i >= N/2+1; i--){\n        (sub += beki * nCk)%=mod; \n        \n        (nCk *= i) %= mod;\n        (nCk *= inv[N + 1 - i]) %= mod;\n        (beki *= 2) %= mod;\n    }\n    \n    ll ans = 1;\n    rep(i, N){\n        (ans *= 3) %= mod;\n    }\n    (ans += mod - 2 * sub) %= mod;\n    cout << ans << endl;\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MOD 998244353\n#define int long long \nusing namespace std;\nconst int maxn=1e7+5;\nint n;\nint f[maxn];\nint invf[maxn];\nint power[maxn];\ninline int ksm(int x,int y){\n\tif(!y) return 1;\n\tif(y==1) return x;\n\tint tmp=ksm(x,y/2);\n\ttmp=(1ll*tmp*tmp)%MOD;\n\tif(y&1) return (1ll*tmp*x)%MOD;\n\telse return tmp;\n}\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn 1ll*f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tf[0]=invf[0]=1;\n\tfor(int i=1;i<maxn;i++) f[i]=(1ll*f[i-1]*i)%MOD;\n\tinvf[maxn-1]=ksm(f[maxn-1],MOD-2);\n\tfor(int i=maxn-2;i>=1;i--) invf[i]=(1ll*invf[i+1]*(i+1))%MOD;\n\tpower[0]=1;\n\tfor(int i=1;i<maxn;i++) power[i]=(1ll*power[i-1]*2)%MOD;\n\tint ans=ksm(3,n);\n\tint res=0;\n\tfor(int i=n/2+1;i<=n;i++) res=(res+2ll*power[n-i]%MOD*C(n,i))%MOD;\n\tans=(ans-res)%MOD+MOD%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vvi;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vvl;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nint mod=998244353;\nint sum(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vvi &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 10000007;\nint fact[maxn], ofact[maxn];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nint dp3[maxn], dp2[maxn];\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tdp3[0] = 1;\n\tdp2[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tdp2[i] = mlt(dp2[i - 1], 2);\n\t\tdp3[i] = mlt(dp3[i - 1], 3);\n\t}\n\tint n;\n\tcin >> n;\n\tint sum = dp3[n];\n\tfor (int i = (n)/2+1; i <= n; i++)\n\t{\n\t\tint val = c(i, n);\n\t\tval = mlt(val, dp2[n - i]);\n\t\tval = mlt(val, 2);\n\t\tsum = dif(sum, val);\n\t}\n\tcout << sum << endl;\n}\nint main()\n{\n\tprec();\n\tcerr << \"Here\" << endl;\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000005,P=998244353;\nint n,inv[N];\nint main()\n{\n\tscanf(\"%d\",&n);inv[1]=1;\n\tfor(int i=2;i<=n;i++)inv[i]=1ll*(P-P/i)*inv[P%i]%P;\n\tint s=0;for(int i=0,c=1,p=1;i<n/2;i++){s=(s+1ll*c*p)%P;p=p*2%P;c=1ll*c*(n-i)%P*inv[i+1]%P;}\n\tint t=1;for(int i=1;i<=n;i++)t=3ll*t%P;t=(t-2ll*s%P+P)%P;printf(\"%d\\n\",t);return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc040/submissions/10482076\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n    if(N == 2) return 0;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\nvoid read(int &x){\n    char ch;bool ok;\n    for(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n    for(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=1e7+10,mod=998244353;\nint n,fac[maxn],inv[maxn],g[maxn],ans;\nint mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint del(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mi(int a,int b){int ans=1;while(b){if(b&1)ans=mul(ans,a);b>>=1,a=mul(a,a);}return ans;}\nint C(int n,int m){return mul(fac[n],mul(inv[m],inv[n-m]));}\nint main(){\n    read(n);fac[0]=inv[0]=g[0]=1;\n    for(rg int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i),g[i]=mul(g[i-1],2);\n    inv[n]=mi(fac[n],mod-2);\n    for(rg int i=n-1;i;i--)inv[i]=mul(inv[i+1],i+1);\n    for(rg int i=n/2+1;i<=n;i++)\n\tans=add(ans,mul(C(n,i),g[n-i]));\n    printf(\"%d\\n\",del(mi(3,n),mul(ans,2)));\n}\n"
  },
  {
    "language": "C++",
    "code": "// by newbiechd\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n// DELETE the debugging information!\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\n\nconst int N_MAX = 10000003, mod = 998244353;\nint fac[N_MAX], iFac[N_MAX], bin[N_MAX];\nint power(int x, int y) {\n  int ret = 1;\n  while (y) {\n    if (y & 1)\n      ret = 1ll * x * ret % mod;\n    x = 1ll * x * x % mod, y >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  fac[0] = 1, bin[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    fac[i] = 1ll * i * fac[i - 1] % mod, bin[i] = 2 * bin[i - 1] % mod;\n  iFac[n] = power(fac[n], mod - 2);\n  for (int i = n; i > 0; --i)\n    iFac[i - 1] = 1ll * i * iFac[i] % mod;\n  int ans = 0;\n  for (int i = 0; i < n / 2; ++i)\n    ans = (1ll * iFac[i] * iFac[n - i] % mod * bin[i] + ans) % mod;\n  ans = (power(3, n) - 2ll * fac[n] * ans % mod) % mod;\n  printf(\"%d\\n\", (ans + mod) % mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nostream& operator<<(ostream &out, string str) {\n\tfor(char c : str) out << c;\n\treturn out;\n}\n \ntemplate<class L, class R> ostream& operator<<(ostream &out, pair<L, R> p) {\n\treturn out << \"(\" << p.first << \", \" << p.second << \")\";\n}\n \ntemplate<class T> auto operator<<(ostream &out, T a) -> decltype(a.begin(), out) {\n\tout << \"{\";\n\tfor(auto it = a.begin(); it != a.end(); it = next(it))\n\t\tout << (it != a.begin() ? \", \" : \"\") << *it;\n\treturn out << \"}\";\n}\n \nvoid dump() { cerr << \"\\n\"; }\ntemplate<class T, class... Ts> void dump(T a, Ts... x) {\n\tcerr << a << \", \";\n\tdump(x...);\n}\n \n#ifdef DEBUG\n#  define debug(...) cerr << \"[\" #__VA_ARGS__ \"]: \", dump(__VA_ARGS__)\n#else\n#  define debug(...) false\n#endif\n \n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define ST first\n#define ND second\n \ntemplate<class T> int size(T && a) { return a.size(); }\n\nusing LL = long long;\nusing PII = pair<int, int>;\n\nint mod = 998244353;\nint mul(int a, int b) { return (LL) a * b % mod; }\nint add(int a, int b) { return a + b < mod ? a + b : a + b - mod; }\nint qpow(int a, int n) {\n\tif(n == 0) return 1;\n\tif(n % 2 == 1) return mul(qpow(a, n - 1), a);\n\treturn qpow(mul(a, a), n / 2);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> rev(n + 1, 1);\n\tint fac = 1;\n\tFOR(i, 1, n) fac = mul(fac, i);\n\trev[n] = qpow(fac, mod - 2);\n\tfor(int i = n; i >= 2; i--)\n\t\trev[i - 1] = mul(rev[i], i);\n\tauto choose_k = [&](int k) {\n\t\tint res = fac;\n\t\tres = mul(res, rev[k]);\n\t\tres = mul(res, rev[n - k]);\n\t\treturn res;\n\t};\n\n\tint ans = qpow(3, n);\n\tint bad = 0, p = 1;\n\tfor(int i = n; i * 2 > n; i--) {\n\t\tint res = mul(choose_k(i), p);\n\t\tbad = add(bad, res);\n\t\tp = mul(p, 2);\n\t}\n\n\tbad = mul(2, bad);\n\tbad = add(mod, -bad);\n\tans = add(ans, bad);\n\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\nconst int pre[10001] = { 1,777990065,766786010,512513096,705983787,734256002,244148993,533292028,210582481,688517539,215582594,14820617,129246395,150625187,86672976,764239242,21874704,57288446,850657009,774583782,638474417,128284758,786368753,472986042,103549395,495451255,264078536,433635135,625262204,766766525,185226044,35932350,902168850,455715166,218641259,972559028,640480499,206662314,683003246,923831102,876712294,724261094,408525348,763874992,547233394,109140246,300634900,256419515,371584155,276107980,832944090,540250216,893651744,936348937,326512726,516396135,843656716,776879789,359802705,356307409,949283602,121678346,755038370,144825638,398849114,243664371,157125107,752722108,971617941,787502726,951610819,720346213,481304016,361949821,680950950,387120559,575366956,411040690,816984038,668571204,187142323,552289458,722805387,993149209,318238233,904486800,968982693,875054001,578248523,925025550,271818664,509541523,500499768,929802162,849466163,523746388,268604730,311862148,211074478,804711044,373341033,683607517,262864254,899397125,903574757,408123903,570163026,387548298,136310560,757193515,492373922,16092666,218256882,33612616,184219001,645249935,348551228,835533217,302307407,641587141,70007868,840714962,797190974,744571430,180557608,554082240,483244331,924205037,933027896,760946120,890154909,803775227,605185517,868712494,835769462,401208474,689354486,226621123,96687561,38631563,501927483,483249587,593944616,998231222,23528366,842172435,357335185,725982025,398516968,269658881,797725335,59352911,184061655,193546739,303152497,61883255,98078622,195866691,996728981,446353446,796024455,885097692,915829452,732760877,97457057,251606742,829937743,367147609,907175897,989448554,748640136,168580487,42590154,482935433,768160042,31342156,39326209,654029131,72020724,47519485,542991096,876162665,577428803,188685455,233510797,422423143,544780457,613635275,137823240,55715373,97062836,437207675,578565389,794462456,122688768,964014598,148890003,428128959,278232786,996120899,45596018,7163323,387102481,258039391,515773886,830696837,604845763,539553101,384403210,949063076,849317807,630752268,210722610,773591150,869634880,109500248,32144134,224896996,642008315,169507794,283287674,219473392,422410040,174823408,288798151,140807520,497583578,863575707,355648573,272221122,561110485,253470028,580834681,587770974,112220015,850532094,33475427,498807687,317772333,409146882,596316874,331449290,335429501,670238024,900627351,14996190,733198052,307321953,844834750,829096729,400767242,769588955,98032360,560788564,292816061,468314755,983912094,328059458,549942096,45373125,417528165,901294757,895122295,151159745,297548894,203255878,752797429,911093840,496689395,629769991,78939987,459538825,406390137,6879134,257680118,396950159,129807060,715875807,553661506,390811345,191166323,810576750,213045873,942790458,758339094,899444486,309004018,633895784,128589948,937478027,212513874,174345296,62004037,591751261,649329767,366843154,926280101,432150075,354244239,659276328,834980587,136620485,948751335,633318822,299685362,867019421,267600853,697694392,173796099,133939251,167633838,168664055,455355228,509401446,914452079,440577645,29283142,556198383,482874240,923005927,914550501,892014883,550966054,375146890,259320783,391769529,226806694,768163357,300654217,694655521,844638237,661303928,422327106,355635742,489451003,137628974,980318491,361853327,645638169,336599956,688948565,638514939,153383062,889194597,536430068,893849901,923432110,315839722,49382817,516474656,248173708,403609024,833306540,338847731,986694950,790821219,197628535,285108045,285934271,811084650,104964765,243988035,674229619,993956736,147476083,824048109,791673374,111127164,710735456,308066837,815197913,520396119,92412037,174723780,843863210,222304311,70227310,745928328,40367869,201974250,393032085,247592312,302180761,495381981,900779821,42751968,130815209,110950082,445232011,650497384,752109934,369950087,309849396,190399500,497647689,353358328,459852401,546099291,671454973,367352978,623627864,100401244,892602210,941551774,871438080,513287280,28185349,21030930,44275710,449827510,712246343,36889166,383078382,912763782,209588582,66987695,640672435,956971829,371907015,714047850,982424362,437882276,454748600,468777415,226512910,761686008,418711160,679266400,372627958,797779775,242570019,602303606,983737359,585763482,940263818,910024593,182269085,662738675,615426027,638525692,446366139,68263779,710197880,222814184,532876159,24120062,707881939,705340838,809441202,482114351,45768177,722815024,897943079,728188648,339739889,364745005,808452545,151610888,987511783,394592072,407729297,52967962,680043468,502198643,938707127,20993746,222949807,531872391,810935357,892377075,154762272,84787052,486805848,317085134,992754474,195236749,21949307,780187478,413553058,879449557,330880448,81415435,108607930,341779439,784896483,620491631,153641122,534228690,846914883,610414719,232588079,436762323,984600471,75405628,263308959,639543590,265889797,133955315,209305986,554795787,428937595,941877363,184451191,923795936,49525425,312442269,437151206,78919908,325973945,579844487,398204190,422683275,595487166,194914147,918795881,69211505,380683932,530612228,634697067,709623540,897706118,22942978,281839888,735681848,25120123,882619476,174552294,668106640,641839971,777450530,655937896,29612691,76069349,832769992,277055316,877454260,115365802,87835316,262466036,79664056,536236563,425951836,278768863,475769894,90522759,307362605,63204044,648964820,931888706,954449142,938010479,325282066,209053425,396563384,761781696,408508738,591582400,829340326,348639450,905026623,860856448,437296068,435334482,291412970,343673774,828901226,901613695,992541178,920381845,302843711,566172771,736189313,783990843,184030082,33617073,439331499,611136185,574497345,90817591,306143980,945501487,362805859,74284790,641726342,522692857,775884194,549727729,444956677,545075287,892463752,90265520,916637957,178236658,980812214,59569691,932392802,488131279,861287555,954672905,419328334,442819817,357758244,887478702,984290034,939144003,70714661,485961375,177417145,162118962,168070756,174913840,982318186,650727215,846359719,984640166,823933073,243009290,152990121,535790194,842333964,57092875,671223531,933222015,271959156,288003384,421390300,835225795,394537809,243155841,856810726,671154973,919875491,265924126,79436106,994247829,183378915,532312977,641156343,576069340,704676636,14554181,6523850,393621207,962151282,554820476,606567566,540585991,269714976,420527242,902506476,79339328,938346178,906937168,714916297,950663746,924948492,93383124,742471102,96868329,289622464,511596111,892814818,404369049,409642870,925142075,388844266,695178051,924307790,769870823,258352801,37319493,656535362,942160874,643592487,159647979,459668470,339174706,60288630,749230429,137386012,142128101,741523026,932249458,133685955,848166191,971938720,690816329,693509216,256408885,839738215,939641949,589638571,25469448,932714644,275884954,440367728,901736665,872587068,897787042,837977995,499710224,189498332,636546695,512005440,220288536,368285012,522130486,112567128,173590818,787664831,463296900,963431830,585289222,414700630,530772554,520800955,27834666,632926830,108265239,130127802,406984354,885533900,267599206,846568716,925571632,361045177,455835455,631901425,582383970,397418490,902263780,279768062,684207567,555876879,213169731,993545710,281195933,354016936,417452790,325049825,372247494,913454812,229684453,11625560,557539657,158714984,396403031,362573159,559048195,305476857,280520923,172808824,618589023,957745517,507362338,183892698,536827111,136820615,161184916,581288683,788080221,379731237,970234708,512908572,911557655,693532380,75693974,743612959,293425406,460742607,841929891,478466605,131340979,941426392,96506146,734531144,954715348,258071636,267285258,157361051,634098066,847501174,291172701,823316612,287824262,290717927,321615349,597704882,407060168,100064711,40000658,640920375,910618969,5182489,548235654,969546889,238062370,516021134,147732413,370659533,833655840,649202504,283787677,544385077,533215075,245880234,995321109,504089062,527440767,806954080,237670639,972424792,544700093,154025540,542342152,523089929,946800898,320483244,401371823,78384996,62174429,258433535,553295948,127143445,564154450,413488441,991069498,392441240,824132912,514921452,123644879,692841184,618623956,565158616,58529238,150117976,71490068,699156339,333263606,921371650,217507999,741546202,724472787,964898806,817920986,582096713,559153778,903819609,215291535,534168349,488985182,844145821,935050600,371603787,757869745,268970995,792449869,803557966,235112752,659275014,826634010,351488455,176734098,263260251,785552216,299003958,208080760,569058617,360532390,386399723,398762201,33272509,497218769,522181848,976622995,260131094,982778284,77371871,395349740,390214653,531854347,493975992,678229473,574409531,95826270,992726917,458437396,619632461,205161868,549830743,223515902,178482990,310282069,219230309,602291763,929072996,593463923,527802328,636498474,823705589,83857087,778669244,941456377,73301964,898657754,509912480,938900018,435397704,519619493,735044665,265835960,559201172,239826028,312119351,739353209,103208090,135132726,784824707,232832650,736566311,391931702,394509768,469195547,590383266,897215155,458515558,373585170,158729077,952125022,711761227,868405413,226589812,677030475,648757054,454752913,592350159,754968001,137896269,14566430,858673333,60435539,930609495,947940003,321611846,402349796,352034025,951901408,484084529,740021117,952069554,541638394,357815063,74405887,350552020,776016487,155552075,881994814,90947222,26360681,846511130,346814021,447948726,11819857,378653079,716353332,696316282,56457542,302941700,371036503,124047029,390868579,84411314,33882493,204021054,580753084,652653069,601390003,135041016,492401516,817288138,201876905,449498406,264348632,965482620,138310,207110730,107364155,669232095,139014676,180671118,556369147,199407219,671144270,58468077,73314446,890418474,428534311,925456411,262608571,349636135,295201906 };\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = pre[N / 10000];\n\tint n = N / 10000 * 10000;\n\tfor (int i = n + 1; i <= n + N % 10000; i++) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll k = modpow(2, N2) * ifac[N2] % mod;\n\tll k2 = (ll)N2 * inv2 % mod;\n\trep(i, N2) {\n\t\tk = k * k2 % mod;\n\t\thiku += k * ifac[N2 - i - 1] % mod;\n\t\tk2 -= inv2;\n\t\tif (k2 < 0) k2 += mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 998244353;\n\nlong long power(int x, int y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y / 2);\n  res = res * res % BASE;\n  if (y % 2)\n    res = res * x % BASE;\n  return res;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  vector<long long> fact(n + 1), invFact(n + 1), p2(n + 1);\n  fact[0] = p2[0] = 1;\n  for (int i = 1; i <= n; i++)\n  {\n    fact[i] = fact[i - 1] * i % BASE;\n    p2[i] = p2[i - 1] * 2 % BASE;\n  }\n  invFact[n] = power(fact[n], BASE - 2);\n  for (int i = n; i; i--)\n    invFact[i - 1] = invFact[i] * i % BASE;\n\n  long long ans = power(3, n);\n  for (int i = n / 2 + 1; i <= n; i++)\n  {\n    long long ways = fact[n] * invFact[i] % BASE * invFact[n - i] % BASE;\n    ans = (ans + BASE - ways * p2[n - i + 1] % BASE) % BASE;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\nconst int N = 1e7+5;\nint n;\nint fac[N],ifac[N],pw[N];\ninline void init(int n = 1e7){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;i--)ifac[i]=mul(ifac[i+1],i+1);\n\tpw[0] = 1;for(int i=1;i<=n;i++)pw[i] = mul(pw[i-1],2);\n}\ninline int binom(int a,int b){\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\n\nint main()\n{\n\tinit();\n\tcin >> n;\n\tint ans = qpow(3,n);\n\tfor(int i=(n>>1)+1;i<=n;i++){\n\t\tans = sub(ans, mul(2, mul(binom(n,i),pw[n-i])));\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar_unlocked()\n#define pc(x) putchar_unlocked(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\nusing ll = long long;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 1;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        bi = divmod(bi, i, mod);\n        ans -= 2*bi; //A or B\n        if(ans < 0)\n            ans += mod;\n    }\n    \n    print(ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nusing ll =  long long;\n\nconstexpr ll MOD = 998244353;\n\nll modpow(ll a, ll t) {\n    ll ret = 1LL;\n    while(t){\n        if(t & 1LL){\n            ret *= a;\n            ret %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        t >>= 1;\n    }\n    return ret;\n}\n\ninline ll comb(const ll fact, const ll rfact1, const ll rfact2) {\n    return (fact * ((rfact1 * rfact2) % MOD)) % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll n;\n    cin >> n;\n\n    ll ans = modpow(3LL, n);\n\n    ll fact = 1LL, rfact1 = 1LL, rfact2 = 1LL;\n    for(ll i=2;i<=n;++i) {\n        fact *= i;\n        fact %= MOD;\n    }\n    for(ll i=2;i<=n/2;++i) {\n        rfact1 *= modpow(i, MOD-2);\n        rfact1 %= MOD;\n    }\n    rfact2 = rfact1;\n\n    ll pow_2 = modpow(2LL, n/2);\n    ll r2 = modpow(2LL, MOD-2);\n\n    for(ll i=n/2+1;i<=n;++i) {\n        pow_2 *= r2;\n        pow_2 %= MOD;\n        rfact1 *= ll(n-i+1);\n        rfact1 %= MOD;\n        rfact2 *= modpow(i, MOD-2);\n        rfact2 %= MOD;\n        ans += MOD - (((2 * comb(fact, rfact1, rfact2)) % MOD) * pow_2) % MOD;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll mod = 998244353LL;\n\n// aのb乗を求める.\nll modpow(ll a, ll b) {\n\tif (a > mod) a %= mod;\n\tif (b == 0LL) return 1LL;\n\tll tmp = modpow(a, b / 2);\n\tif (b & 1LL)\n\t\treturn tmp * tmp % mod * a % mod;\n\treturn tmp * tmp % mod;\n}\n\n// aの逆元を求める.\nll inverse(ll a) {\n\treturn modpow(a, mod - 2);\n}\n\n// kの階乗を計算する.(sgnを0以外に設定すると逆元を返す)\nll fact(ll k, int sgn = 0) {\n\tstatic vector<ll> fac(2, 1LL);\n\tstatic vector<ll> inv(2, 1LL);\n\tstatic vector<ll> finv(2, 1LL);\n\tstatic ll nx = 2LL;\n\twhile (nx <= k) {\n\t\tfac.push_back(fac[nx - 1] * nx % mod);\n\t\tinv.push_back(mod - inv[mod % nx] * (mod / nx) % mod);\n\t\tfinv.push_back(finv[nx - 1] * inv[nx] % mod);\n\t\t++nx;\n\t}\n\tif (sgn == 0)\n\t\treturn fac[k];\n\treturn finv[k];\n}\n\n// aCbを計算する.\nll comb(ll a, ll b) {\n\tif (b < 0 || b > a) return 0;\n\treturn fact(a) * fact(b, 1) % mod * fact(a - b, 1) % mod;\n}\n\nsigned main() {\n\tll n; cin >> n;\n\tll ans = modpow(3, n);\n\tfor (ll i = (n / 2) + 1; i <= n; ++i) {\n\t\tans -= modpow(2, n - i) * comb(n, i) % mod * 2 % mod;\n\t\tans += mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = (int)1e6 * 5 + 10;\nint fact[maxN], invfact[maxN], inv[maxN];\nint n;\nint pref[maxN];\nint pw2[maxN];\nint cnk(int a, int b) {\n    if (a < b || b < 0) return 0;\n    return mult(fact[a], mult(invfact[a - b], invfact[b]));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    n /= 2;\n    fact[0] = invfact[0] = inv[1] = fact[1] = invfact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        inv[i] = mult(mod - mod / i, inv[mod % i]);\n        fact[i] = mult(fact[i - 1], i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    pw2[0] = 1;\n    for (int i = 1; i < maxN; i++) pw2[i] = mult(2, pw2[i - 1]);\n    for (int i = 0; i <= n; i++) {\n        pref[i] = mult(pw2[i], cnk(n, i));\n        if (i > 0) pref[i] = sum(pref[i], pref[i - 1]);\n    }\n    int coef = 1;\n    for (int i = 0; i < 2 * n; i++) coef = mult(coef, 3);\n    int tot = 0;\n    for (int i = 1; i <= n; i++) {\n        tot = sum(tot, mult(pref[i - 1], mult(cnk(n, i), pw2[n - i])));\n    }\n    coef = sub(coef, mult(2, tot));\n    cout << coef;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n//#include <chrono>\n//#include <random>\n\n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define long int64_t\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ std::cerr << name << \" : \" << arg1 << std::endl; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); std::cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//uniform_int_distribution<> dis(0, INF<<1);\n\nconst int N = 10000001;\nconst int mod = 998244353;\n\nint modexp(int a, int b = mod - 2)\n{\n\tint r = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1)\n\t\t\tr = (r * 1ll * a) % mod;\n\t\ta = (a * 1ll * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn r;\n}\n\nint f[N];\n\nint main()\n{\n\tfio;\n\tf[0] = 1;\n\tfor(int i=1; i<N; i++)\n\t\tf[i] = (f[i-1] * 1ll * i) % mod;\n\tint n, t = 1, a = 0;\n\tcin >> n;\n\tfor(int i=(n >> 1) + 1; i<=n; i++)\n\t{\n\t\tt = (3ll * t) % mod;\n\t\tint x = (modexp(f[i]) * 1ll * modexp(f[n-i])) % mod;\n\t\tx = (x * 1ll * f[n]) % mod;\n\t\tx = (x * 1ll * modexp(2, n-i)) % mod;\n\t\ta += x;\n\t\ta %= mod;\n\t}\n\ta = (a + a) % mod;\n\tt = (t * 1ll * t) % mod;\n\tcout << (t - a + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vp;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst db eps = 1e-10;\n\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define ep emplace\n#define mem(a) memset(a, 0, sizeof(a))\n#define copy(a, b) memcpy(a, b, sizeof(b))\n#define PA cout << \"pass\\n\"\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define TM cout << db(clock()) / CLOCKS_PER_SEC << '\\n'\n\nconst int mod = 998244353;\nconst int maxn = 1e7 + 233;\nint fac[maxn], inv[maxn];\n\nint pow_mod(int q, int w){\n    int ret = 1;\n    while(w){\n        if(w & 1) ret = 1ll * ret * q % mod;\n        q = 1ll * q * q % mod;\n        w >>= 1;\n    }\n    return ret % mod;\n}\n\nint n;\nint po[maxn];\n\nint C(int x, int y){\n    if(x < y) return 0;\n    return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    po[0] = fac[0] = inv[0] = 1;\n    for(int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[i] = (po[i - 1] + po[i - 1]) % mod;\n    inv[n] = pow_mod(fac[n], mod - 2);\n    for(int i = n - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n    int res = 0;\n    for(int i = n / 2 + 1; i <= n; i++) res = (res + 2ll * C(n, i) * po[n - i]) % mod;\n    cout << (pow_mod(3, n) + mod - res) % mod << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(v) ((int)(v).size())\nconst int MAXN = 10000005;\nconst int mod = 998244353;\nusing lint = long long;\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nlint fact[MAXN], invf[MAXN];\n\nlint binom(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x-y] % mod) % mod;\n}\n\nint main() { \n\tint n; cin >> n;\n\tfact[0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t}\n\tinvf[n] = ipow(fact[n], mod - 2);\n\tfor(int i=n-1; i>=0; i--){\n\t\tinvf[i] = invf[i + 1] * (i + 1) % mod;\n\t}\n\tlint ans = 0;\n\tfor(int i=0; i<n/2; i++){\n\t\tans += ipow(2, i + 1) * binom(n, i) % mod;\n\t}\n\tans %= mod;\n\tans = ipow(3, n) - ans + mod;\n\tcout << ans % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nconst i64 mod = 998244353;\ni64 fact_memo[10000001];\ni64 fact(i64 x) {\n  if (x == 0) return 1;\n  if (fact_memo[x]) return fact_memo[x];\n  return fact_memo[x] = x * fact(x - 1) % mod;\n}\ni64 ipow(i64 a, i64 b) {\n  return (b & 1 ? a : 1) * (b > 1 ? ipow(a * a % mod, b >> 1) : 1) % mod;\n}\ni64 inv(i64 x) {\n  return ipow(x, mod - 2);\n}\ni64 fact_inv(i64 x) {\n  return inv(fact(x));\n}\ni64 perm(i64 a, i64 b) {\n  return fact(a) * fact_inv(a - b) % mod;\n}\ni64 conb(i64 a, i64 b) {\n  return perm(a, b) * fact_inv(b) % mod;\n}\ni64 n;\nint main() {\n  cin >> n;\n  fact_memo[0] = 1;\n  for (i64 i = 1; i <= n; ++i) {\n    fact_memo[i] = fact_memo[i - 1] * i % mod;\n  }\n  i64 sum = ipow(3, n), sub = 0;\n  for (i64 i = n / 2 + 1; i <= n; ++i) {\n    (sub += conb(n, i) * ipow(2, n - i) % mod) %= mod;\n  }\n  i64 ans = (sum - 2 * sub + 2 * mod) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL_EXEC\n#include \"include.h\"\n#else\n#include <bits/stdc++.h>\nusing namespace std;\n#define trace(...)\n#endif\n\nusing LL = long long;\n\nconst LL MOD = 998244353;\n\nLL modpow(LL a, LL n) {\n\tLL res = 1;\n\tfor (; n > 0; n >>= 1) {\n\t\tif (n & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t}\n\treturn res;\n}\n\nconst int N = 1e7 + 1;\nLL fact[N], inv[N];\nLL choose(int n, int r) {\n\treturn (fact[n] * ((inv[r] * inv[n - r]) % MOD)) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = modpow(fact[i], MOD - 2);\n\t}\n\n\tint n; cin >> n;\n\tLL rem = 0;\n\tfor (int i = n / 2 + 1; i <= n; i++) {\n\t\trem += (choose(n, i) * modpow(2, n - i + 1)) % MOD;\n\t}\n\tLL ans = (modpow(3, n) + MOD - (rem % MOD)) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long double ld;\ntypedef long long ll;\n\nusing namespace std;\n\nconst int inf = 1e9 + 1;\nconst ld pi = acos(-1);\nconst ll p = 998244353;\n\nconst int maxsz = 1e7 + 2;\n\nll factorial[maxsz];\nll invfact[maxsz];\n\nll POWER(ll x, ll y) {\n    if (y == 0) return 1;\n    ll f = POWER(x, y / 2);\n    f *= f;\n    f %= p;\n    if (y % 2 == 1) {\n        f *= x;\n        f %= p;\n    }\n    return f;\n}\n\nll Pow(ll x, ll y) {\n    ll x1 = x % p;\n    x1 += p;\n    x1 %= p;\n    ll y1 = y % (p - 1);\n    y1 += (p - 1);\n    y1 %= (p - 1);\n    return POWER(x1, y1);\n}\n\nll inverse(ll x) {\n    return Pow(x, p - 2);\n}\n\nvoid podfact() {\n    factorial[0] = 1;\n    for (int i = 1; i < maxsz; i++) {\n        ll k = i;\n        factorial[i] = factorial[i - 1] * k;\n        factorial[i] %= p;\n    }\n    invfact[maxsz - 1] = inverse(factorial[maxsz - 1]);\n    for (int i = maxsz - 2; i >= 0; i--) {\n        ll k = i;\n        invfact[i] = (k + 1) * invfact[i + 1];\n        invfact[i] %= p;\n    }\n}\n\nll C(int n, int k) {\n    ll x = factorial[n] * invfact[k];\n    x %= p;\n    x *= invfact[n - k];\n    return x % p;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    // freopen(\"input.txt\", \"r\", stdin);\n    cout << setprecision(20);\n\n    podfact();\n    int n;\n    cin >> n;\n    int k = n / 2;\n    ll x = 1;\n    for (int i = 0; i < k; i++) {\n        x *= 2;\n        x %= p;\n    }\n    ll ans = (x * C(n, k)) % p;\n    // cout << ans;\n    for (int i = 0; i < k; i++) {\n        ll y = x * 2;\n        y -= C(k + i, i);\n        x = y % p;\n        ans += (x * C(n, k - i - 1)) % p;\n        ans %= p;\n    }\n    cout << (ans + p) % p;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 1000007\n#define MOD 998244353\n#define N 1048576\nll n, x, k, z, m, pos, q, ans_v;\nll x1, p1, x2;\nvector<ll> g[300500], f;\n\nll fac[MAXN], invfac[MAXN];\n\nll binpow(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    }\n    ll tmp = binpow(x, y / 2);\n    tmp = tmp * tmp % MOD;\n    if (y % 2) {\n        return x * tmp % MOD;\n    }\n    return tmp;\n}\n\nll inv(ll x) {\n    return binpow(x, MOD-2);\n}\n\nll C(ll n, ll m) {\n    if (n < m) {\n        return 0;\n    }\n    return fac[n] * invfac[m] % MOD * invfac[n-m] % MOD;\n}\n\nvoid precalc_facs() {\n    fac[0] = invfac[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fac[i] = fac[i-1] * i % MOD;\n        invfac[i] = inv(fac[i]);\n    }\n}\n\nll a[MAXN], pa[MAXN], p3[2 * MAXN], p2[2 * MAXN], sp[MAXN], spp[MAXN];\n\nint main() {\n    precalc_facs();\n    cin >> n;\n    n /= 2;\n    p3[0] = 1;\n    p2[0] = 1;\n    for (int i = 0; i <= 2 * n; i++) {\n\n        p3[i+1] = p3[i] * 3 % MOD;\n        p2[i+1] = p2[i] * 2 % MOD;\n    }\n\n    for (int i = 0; i <= n; i++) {\n        sp[i] = p2[n-i] * C(n, i) % MOD;\n        spp[i+1] = (spp[i] + sp[i]) % MOD;\n    }\n\n    for (int i = 0; i <= n; i++) {\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ll sum = sp[i] * (p3[n] - (spp[n - i + 1] - spp[0])) % MOD;\n        ans = (ans + sum) % MOD;\n        //cout << ans << endl;\n    }\n    cout << (p3[n*2] - ans * 2 + MOD * 2) % MOD << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto DUMMY: x) cerr << DUMMY << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) true\n#define dump(x) true\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\n\nvector<mint> extended(int n, const vector< vector<mint> >& coeffs, const vector<mint>& terms) {\n\n\tvector<mint> ret(max<int>(n + 1, terms.size()));\n\tcopy(terms.begin(), terms.end(), ret.begin());\n\tconst int order = coeffs.size() - 1;\n\tconst int deg = coeffs[0].size() - 1;\n\tassert((int) terms.size() >= order);\n\tfor (int m = terms.size(); m <= n; ++m) {\n\t\tmint s = 0;\n\t\tfor (int i = 1; i <= order; ++i) {\n\t\t\tint k = m - i;\n\t\t\tmint t = ret[k];\n\t\t\tfor (int d = 0; d <= deg; ++d) {\n\t\t\t\ts += t * coeffs[i][d];\n\t\t\t\tt *= k;\n\t\t\t}\n\t\t}\n\t\tmint denom = 0, mpow = 1;\n\t\tfor (int d = 0; d <= deg; ++d) {\n\t\t\tdenom += mpow * coeffs[0][d];\n\t\t\tmpow *= m;\n\t\t}\n\t\tret[m] = -s/denom;\n\t}\n\treturn ret;\n}\n\nvector< vector<mint> > find_recurrence_relation(vector<mint> terms, int deg, int ord = -1, bool verify=true) {\n\n\tif(ord != -1){\t\t//given order\n\t\tint n = (deg+1)*(ord+1)+ord-1;\n\t\twhile((int)terms.size()>n) terms.pop_back();\n\t}\n\n\tconst int n = terms.size();\n\tconst int B = (n + 2) / (deg + 2); // number of blocks\n\tconst int C = B * (deg + 1); // number of columns\n\tconst int R = n - (B - 1); // number of rows\n\tassert(B >= 2); assert(R >= C - 1);\n\n\tauto error = [] (int order, int deg) {\n\t\tfprintf(stderr, \n\t\t\t\"Error: Could not find a recurrence relation \"\n\t\t\t\"of order <= %d and degree <= %d.\\n\\n\", \n\t\t\torder, deg);\n\t\tassert(0);\n\t};\n\n\tvector< vector<mint> > mat(R, vector<mint>(C));\n\tfor (int y = 0; y < R; ++y) {\n\t\tfor (int b = 0; b < B; ++b) {\n\t\t\tmint v = terms[y+b];\n\t\t\tfor (int d = 0; d <= deg; ++d) {\n\t\t\t\tmat[y][b * (deg + 1) + d] = v;\n\t\t\t\tv *= y+b;\n\t\t\t}\n\t\t}\n\t}\n\n\tint rank = 0;\n\tfor (int x = 0; x < C; ++x) {\n\t\tint pivot = -1;\n\t\tfor (int y = rank; y < R; ++y) if (mat[y][x] != 0) {\n\t\t\tpivot = y; break;\n\t\t}\n\t\tif (pivot < 0) break;\n\t\tif (pivot != rank) swap(mat[rank], mat[pivot]);\n\t\tmint inv = mat[rank][x].inv();\n\t\tfor (int x2 = x; x2 < C; ++x2) mat[rank][x2] *= inv;\n\t\tfor (int y = rank + 1; y < R; ++y) if (mat[y][x]) {\n\t\t\tmint c = -mat[y][x];\n\t\t\tfor (int x2 = x; x2 < C; ++x2) {\n\t\t\t\tmat[y][x2] += c * mat[rank][x2];\n\t\t\t}\n\t\t}\n\t\t++rank;\n\t}\n\n\tif (rank == C) error(B - 1, deg);\n\n\tfor (int y = rank - 1; y >= 0; --y) if (mat[y][rank]) {\n\t\tassert(mat[y][y] == 1);\n\t\tmint c = -mat[y][rank];\n\t\tfor (int y2 = 0; y2 < y; ++y2) {\n\t\t\tmat[y2][rank] += c * mat[y2][y];\n\t\t}\n\t}\n\n\tint order = rank / (deg + 1);\n\n\tvector< vector<mint> > ret(order + 1, vector<mint>(deg + 1));\n\tret[0][rank % (deg + 1)] = 1;\n\tfor (int y = rank - 1; y >= 0; --y) {\n\t\tint k = order - y / (deg + 1), d = y % (deg + 1);\n\t\tret[k][d] = -mat[y][rank];\n\t}\n\n\tif (verify) {\n\t\tauto extended_terms = extended(n - 1, ret, \n\t\t\t\tvector<mint>(terms.begin(), terms.begin() + order));\n\t\tfor (int i = 0; i < (int) terms.size(); ++i) {\n\t\t\tif (terms[i] != extended_terms[i]) error(B - 1, deg);\n\t\t}\n\t}\n\n\tauto verbose = [&] {\n\t\tint last = verify ? n - 1 : order + R - 1;\n\t\tfprintf(stderr, \n\t\t\t\"[ Found a recurrence relation ]\\n\"\n\t\t\t\"- order %d\\n\"\n\t\t\t\"- degree %d\\n\"\n\t\t\t\"- verified up to a(%d) (number of non-trivial terms: %d)\\n\",\n\t\t\torder, deg, last, (last + 1) - ((deg + 2) * (order + 1) - 2)\n\t\t);\n\t\tfprintf(stderr, \"{\\n\");\n\t\tfor (int k = 0; k <= order; ++k) {\n\t\t\tfprintf(stderr, \"  {\");\n\t\t\tfor (int d = 0; d <= deg; ++d) {\n\t\t\t\tif (d) fprintf(stderr, \", \");\n\t\t\t\tfprintf(stderr, \"%d\", ret[k][d].v);\n\t\t\t}\n\t\t\tfprintf(stderr, \"}%s\\n\", k == order ? \"\" : \",\");\n\t\t}\n\t\tfprintf(stderr, \"}\\n\\n\");\n\t};\n\tverbose();\n\n\treturn ret;\n}\n\nvoid show_extended_sequence(int n, const vector<mint>& terms, int degree, int order = -1) {\n\tauto coeffs = find_recurrence_relation(terms, degree, order);\n\tauto extended_terms = extended(n, coeffs, terms);\n\tfor (int i = 0; i < (int) extended_terms.size(); ++i) {\n\t\tprintf(\"%d %d\\n\", i, extended_terms[i].v);\n\t}\n\tputs(\"\");\n}\nV<mint> get_extended_sequence(int n, const vector<mint>& terms, int degree, int order = -1) {\n\tauto coeffs = find_recurrence_relation(terms, degree, order);\n\treturn extended(n, coeffs, terms);\n}\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(1000000);\n\t\n\tV<mint> v;\n\trep1(N,30){\n\t\tmint res = 0;\n\t\trep(a,N+1) rep(b,N+1-a){\n\t\t\tint c = N-a-b;\n\t\t\trep(x,N+1) rep(y,N+1-x){\n\t\t\t\tint z = N-x-y;\n\t\t\t\tif(-c <= a-x && a-x <= z){\n\t\t\t\t\tres += fact[N] * ifact[a] * ifact[b] * ifact[c] * fact[N] * ifact[x] * ifact[y] * ifact[z];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.pb(res);\n\t}\n\tdump(v);\n\tint N; cin >> N;\n\tshow(get_extended_sequence(100,v,1));\n\tcout << get_extended_sequence(N/2-1,v,1)[N/2-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 998244353\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll n,k[10000005],kinv[10000005],inv[10000005],ans,sum;\nll cm(ll x,ll y){\n\tif(y<0||x<y)return 0;\n\treturn k[x]*kinv[y]%M*kinv[x-y]%M;\n}\nint main(void){\n\tcin>>n;\n    k[0]=1LL,inv[0]=1LL,inv[1]=1LL,kinv[0]=1LL;\n    for(ll i=2;i<=n;i++)inv[i]=M-(M/i)*inv[M%i]%M;\n    for(ll i=1;i<=n;i++)k[i]=k[i-1]*i%M,kinv[i]=kinv[i-1]*inv[i]%M;\n    ans=1LL,sum=1LL;\n    for(ll i=1;i<=n;i++){\n\t\tsum=sum*2LL%M;\n\t\tsum=(M+sum-cm(i-1LL,n/2LL)*2LL%M)%M;\n\t\tans=(ans+sum*cm(n,i)%M)%M;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(std::chrono::system_clock::now().time_since_epoch().count());\nconst int N = 1e7 + 1,M = 998244353;\nint fact[N] = {1},inv[N];\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nvoid add(int &a,int b){\n\ta+=b;\n\tif(a >= M)a-=M;\n\tif(a < 0)a+=M;\n}\nint choose(int n,int k){return (fact[n]*1LL*inv[k]%M)*inv[n - k]%M;}\nint main(){\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tint n;\n\tcin >> n;\n\tfor(int i = 1;i < N;i++)fact[i] = fact[i - 1]*1LL*i%M;\n\tinv[N - 1] = power(fact[N - 1],M - 2);\n\tfor(int i = N - 1;i;i--)inv[i - 1] = inv[i]*1LL*i%M;\n\tint ans = power(3,n);\n\tfor(int i = n/2 + 1;i <= n;i++)\n\t\tadd(ans,-choose(n,i)*2LL*power(2,n - i)%M);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define Rep(i,a,b) for (int i=a;i<b;i++)\n#define maxn 10000005\nint n;\n#define mod 998244353\nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint pw2[maxn],fac[maxn],inv[maxn];\nint power(int a,int b,int p){\n\tint s=1,w=a;while (b){\n\t\tif (b&1)s=1ll*s*w%p;\n\t\tw=1ll*w*w%p;b>>=1;\n\t}\n\treturn s;\n}\nint C(int a,int b){\n\treturn 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main(){\n\tscanf(\"%d\",&n);int res=0;\n\tpw2[0]=1;rep(i,1,n)pw2[i]=2*pw2[i-1]%mod;\n\tfac[0]=1;rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=power(fac[n],mod-2,mod);\n\tper(i,n,1)inv[i-1]=1ll*inv[i]*i%mod;\n\trep(i,n/2+1,n)\n\t\tadd(res,2ll*C(n,i)*pw2[n-i]%mod);\n\tres = (power(3,n,mod)-res+mod)%mod;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph & g, Matrix & scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tinv[n] = mod_inv(fact[n]);\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\ntemplate<typename T>\ninline void bit_reverse(vector<T> & a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n & -n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod - 2, mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long> & input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long> & input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto& x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long> & a, const vector<long long> & b) {\nint result_size = a.size() + b.size() - 1;\nint n = 1; while (n < result_size) n <<= 1;\n\nvector<long long> _a = a, _b = b;\n_a.resize(n, 0);\n_b.resize(n, 0);\n\nntt(_a);\nntt(_b);\nfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\nintt(_a);\n\n_a.resize(result_size);\nreturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\n\t\tret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nint popcount3(int x) {\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0F0F0F0F) + (x >> 4 & 0x0F0F0F0F);\n\tx = (x & 0x00FF00FF) + (x >> 8 & 0x00FF00FF);\n\tx = (x & 0x0000FFFF) + (x >> 16 & 0x0000FFFF);\n\n\treturn x;\n}\n\nll const mod = 998244353;\nll two[10000010];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\n\tll n;\n\tcin >> n;\n\tCombination comb(n+1, mod);\n\ttwo[0] = 1;\n\tREP(i, n) {\n\t\ttwo[i + 1] = (two[i] * 2) % mod;\n\t}\n\tll ans = mod_pow(3, n, mod);\n\tll temp = 0;\n\trep(i,n/2+1,n+1) {\n\t\t(temp += comb.nCr(n, i) * two[n - i] % mod) %= mod;\n\t}\n\t(temp *= 2) %= mod;\n\t(ans += mod - temp) %= mod;\n\n\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nll res, f[10000001], t;\nint N;\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\ta = a*x%mod998;\n\t\t}\n\t\tx = x*x%mod998;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nll modinv(ll x) {\n\treturn pw(x, mod998 - 2);\n}\n\nll comb(int n, int r) {\n\treturn f[n] * modinv(f[r] * f[n - r] % mod998) % mod998;\n}\n\nint main() {\n\tcin >> N;\n\tf[0] = 1;\n\tfor (int i = 1; i <= 10000000; i++) {\n\t\tf[i] = f[i - 1] * i%mod998;\n\t}\n\tres = pw(3, N);\n\tfor (int i = N / 2 + 1; i <= N; i++) {\n\t\tt += comb(N, i)*pw(2, N - i) % mod998;\n\t\tt %= mod998;\n\t}\n\tt *= 2;\n\tt %= mod998;\n\tres += mod998 - t;\n\tres %= mod998;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 1e7 + 9, mod = 998244353;\nint fac[maxn], tw[maxn], ifac[maxn], n;\n\nint pw(int base, int power)\n{\n    int res = 1;\n    while (power) {\n        if (power & 1)\n            (res *= base) %= mod;\n        (base *= base) %= mod;\n        power >>= 1;\n    }\n    return res;\n}\n\nint C(int n, int k) { return fac[n] * ifac[k] % mod * ifac[n - k] % mod; }\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n;\n\n    fac[0] = 1;\n    for (int i = 1; i < maxn; i++)\n        fac[i] = fac[i - 1] * i % mod;\n    ifac[maxn - 1] = pw(fac[maxn - 1], mod - 2);\n    for (int i = maxn - 2; ~i; i--)\n        ifac[i] = ifac[i + 1] * (i + 1) % mod;\n    tw[0] = 1;\n    for (int i = 1; i < maxn; i++)\n        tw[i] = tw[i - 1] * 2 % mod;\n\n    int ans = pw(3, n);\n    for (int i = n / 2 + 1; i <= n; i++) {\n        (ans += mod - C(n, i) * tw[n - i + 1] % mod) %= mod;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nlong long inv(long long a, long long m)\n{\n    return powmod(a, m-2, m);\n}\n\nint main()\n{\n    long long N;\n    cin>>N;\n\n    long long M = 998244353LL;\n\n    vector<long long> F(N+1);\n    F[0] = 1;\n    for (int i=1; i<=N; i++)\n        F[i] = F[i-1]*i%M;\n\n    long long t = 0;\n    for (long long i=N/2+1; i<=N; i++)\n    {\n        t += 2*powmod(2, N-i, M)*F[N]%M*inv(F[i], M)%M*inv(F[N-i], M)%M;\n        t %= M;\n    }\n    cout<<((powmod(3, N, M)-t)%M+M)%M<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=998244353;\nconst int maxn=1e7+10;\nlong long fac[maxn],inv[maxn];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%md*inv[x-y]%md;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[n]=powd(fac[n],md-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tlong long ans=powd(3,n);\n\tfor(int i=n/2+1;i<=n;i++)\n\t\tans=(ans-C(n,i)*powd(2,n-i)*2%md+md)%md;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2019/11/6 13:22:59\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\nusing ll = long long;\nconstexpr ll MOD{998244353LL};\nconstexpr ll MAX_SIZE{20000010LL};\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x(0) {}\n  Mint(ll x) : x(x % MOD) {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nint main()\n{\n  ll N;\n  cin >> N;\n  mint ans{mint{3}.power(N)};\n  mint X{0};\n  combination C;\n  for (auto k = N / 2 + 1; k <= N; k++)\n  {\n    X += C(N, k) * mint{2}.power(N - k);\n  }\n  ans -= X * 2;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define rrep(i,n) RREP(i,n-1,0)\n#define REPL(i,m,n) for(ll i=(ll)(m); i<(ll)(n); i++)\n#define repl(i,n) REPL(i,0,n)\n#define all(v) v.begin(), v.end()\nconst int inf = 1e9+7;\nconst ll longinf = 1LL<<60;\nconst ll mod = 998244353;\n\n#define MAX_N 10000005\nll inv[MAX_N], fac[MAX_N], finv[MAX_N];\nvoid make() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for(int i=2; i<MAX_N; i++) {\n    inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n    fac[i] = fac[i-1] * (ll)i % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\nll perm(ll n, ll r) {\n  if(n < 0)       return 0;\n  else if(n < r)  return 0;\n  else            return (fac[n] * finv[n-r]) % mod;\n}\nll comb(ll n, ll r) {\n  ll ans = 1;\n  ans = perm(n, r);\n  ans = (ans * finv[r]) % mod;\n  return ans;\n}\nll binary_pow(ll a, ll N) {\n  ll ans = 1;\n  ll tmp = a;\n  while(N > 0) {\n    if(N % 2 == 1) {\n      ans *= tmp;\n      ans %= mod;\n    }\n    N /= 2;\n    tmp *= tmp;\n    tmp %= mod;\n  }\n  return ans;\n}\n\nint main() {\n  ll N;\n  cin >> N;\n  make();\n  ll cnt = 0;\n  REP(i, N/2+1, N+1) {\n    cnt += comb(N, i) * binary_pow(2, N-i);\n    cnt %= mod;\n  }\n  cout << binary_pow(3, N) - cnt * 2 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nLL mod = 998244353;\n\nLL modpow(LL a, LL n, LL mod) {\n    LL res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst LL MAX = 10010000;\nconst LL MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long pow2[MAX];\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  COMinit();\n\n  pow2[0] = 1;\n\n  FOR(i,1,MAX){\n    pow2[i] = (pow2[i - 1] * 2) % mod;\n  }\n\n  LL N;\n  cin >> N;\n\n  LL sum = 0;\n  \n  FOR(i,N/2+1,N+1){\n    sum += (COM(N, i) * pow2[N - i + 1])%mod;\n    sum %= mod;\n  }\n\n  LL ans = modpow(3, N, mod) - sum;\n  ans = ((ans % mod) + mod) % mod;\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (10000006)\nll n, f[MAXN], inv[MAXN], p2[MAXN], mod=1e9+7;\nint main(){\n\tFAST\n\tcin>>n;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\tfor(;e;e>>=1,x*=x,x%=mod)if(e&1)sum*=x,sum%=mod;\n\t\treturn sum;\n\t};\n\tp2[0]=1; FOR(i,1,MAXN-1)p2[i]=p2[i-1]*2%mod;\n\tf[0]=1; FOR(i,1,MAXN-1)f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1]=qexp(f[MAXN-1],mod-2);\n\tDEC(i,MAXN-2,0)inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){\n\t\treturn n < k ? 0 : f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=qexp(3,n);\n\tFOR(i,n/2+1,n){\n\t\tans -= 2 * C(n, n-i) % mod * p2[n-i] % mod, ans += mod, ans %= mod;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n#include <stack>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n// ll MOD = 1000000007;\nll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\nint N,K;\nll bik[10000005];\nll bikinv[10000005];\nll gcd(ll a, ll b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\nvoid bikcal(int NN){\n\tll hoge=(ll)1;\n\tbik[0]=(ll)1;\n\tbikinv[0]=(ll)1;\n\tfor(int i=1;i<=NN;i++){\n\t\thoge=(hoge*i)%MOD;\n\t\tbik[i]=hoge;\n\t\tbikinv[i]=invMod(bik[i],MOD);\n\t}\n}\n\n\nll Comb(int a,int b){\n\tll ret;\n\tret=(((bik[a]*bikinv[b])%MOD)*bikinv[a-b])%MOD;\n\treturn ret;\n}\n\n\nll powMod(ll x, ll k, ll m) {//x^k (mod n)\n\tif (k == 0)     return 1;\n\tif (k % 2 == 0) return powMod(x*x % m, k/2, m);\n\telse            return x*powMod(x, k-1, m) % m;\n}\nint main(){\n\tll N;\n\tcin>>N;\n\tN/=2;\n\tbikcal(2*N+1);\n\tll ans=powMod(3,2*N,MOD);\n\tfor(int i=0;i<=N-1;i++){\n\t\tll hoge=(Comb(2*N,i)*powMod(2,i,MOD))%MOD;\n\t\thoge*=2;\n\t\thoge%=MOD;\n\t\tans-=hoge;\n\t\tans+=MOD;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e7 + 5;\nconst int mod = 998244353;\ninline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }\ninline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }\ninline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }\ninline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }\ninline int fpow( int b , int k ) {\n  int res = 1;\n  while( k ) {\n    if( k & 1 ) res = 1LL * res * b % mod;\n    b = 1LL * b * b % mod; k >>= 1;\n  }\n  return res;\n} int _w;\n\nint n , fac[N] , ifac[N] , Pow[N] , inv[N] , ans;\n\nint binom( int n , int m ) { return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\nint main( void ) {\n  _w = scanf(\"%d\",&n);\n  fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1 , Pow[1] = 2;\n  for( int i = 2 ; i <= n ; ++i ) {\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n    inv[i] = 1LL * ( mod - mod / i ) * inv[mod % i] % mod;\n    ifac[i] = 1LL * ifac[i - 1] * inv[i] % mod;\n    Pow[i] = pls( Pow[i - 1] , Pow[i - 1] );\n  }\n  ans = fpow( 3 , n );\n  for( int i = n / 2 + 1 ; i <= n ; ++i )\n    dec( ans , 1LL * binom( n , i ) * Pow[n - i + 1] % mod );\n  cout << ans;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int md = 998244353;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\nvoid sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\nint mul(int a, int b) {\n  return ((ll)a * b) % md;\n}\n\nint power(int a, ll b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector <int> f(n + 1), rf(n + 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; ++i) f[i] = mul(f[i - 1], i);\n  rf[n] = power(f[n], md - 2);\n  for (int i = n - 1; i >= 0; --i) {\n    rf[i] = mul(rf[i + 1], i + 1);\n  }\n  auto C = [&] (int n, int k) {\n    return mul(f[n], mul(rf[n - k], rf[k]));\n  };\n  vector <int> p2(n + 1);\n  p2[0] = 1;\n  for (int i = 1; i <= n; ++i) p2[i] = mul(p2[i - 1], 2);\n  int ans = 1;\n  for (int i = 0; i < n; ++i) ans = mul(ans, 3);\n  for (int cnt = n / 2 + 1; cnt <= n; ++cnt) {\n    int cur = mul(C(n, cnt), p2[n - cnt]);\n    sub(ans, mul(cur, 2));\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse2,avx,avx2,fma\")\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\n//long long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    //fact[0] = 1;\n    //long long factN = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        //factN = (factN*i)%MOD;\n        //fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += (((tempPow2*invFact[N-i])%MOD) * invFact[i])%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n\n    long long factN = powmod(invFact[N], MOD-2);\n\n    ans = (ans+ans)%MOD;\n    ans = ans*factN%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 998244353;\n\nll todeg(ll k, ll deg) {\n    ll deg0 = deg;\n    if (deg == 0) {\n        return 0;\n    }\n    if (deg == -1) {\n        deg = mod - 2;\n    }\n    ll ans = 1;\n    for (int i = 30; i >= 0; --i) {\n        ans *= ans;\n        if (ans > 100000000000LL) {\n            ans %= mod;\n        }\n        if ((deg >> i) & 1) {\n            ans *= k;\n        }\n        if (ans > mod) {\n            ans %= mod;\n        }\n    }\n    /*while (deg > 1) {\n        ans *= ans;\n        ans %= mod;\n        if (deg % 2 == 1) {\n            ans *= k;\n            ans %= mod;\n        }\n        deg /= 2;\n    }*/\n    //cout << k << \"^\" << deg0 << \"=\" << ans << '\\n';\n    return ans;\n}\n\n\n\nint main()\n{\n    /*for (int i = 32; i >= 0; --i) {\n        if (((mod - 2) >> i) & 1) {\n            cout << '1';\n        } else {\n            cout << '0';\n        }\n    }*/\n    ll n;\n    cin >> n;\n    ll f = 1;\n    ll cur2 = 1, curc = 1;\n    for (int k = 1; k * 2 < n; ++k) {\n        /*cur2 *= 2;\n        while (cur2 > mod) {\n            cur2 -= mod;\n        }*/\n        curc = curc * 2 * (n - k + 1);\n        if (curc % k == 0) {\n            curc /= k;\n        } else {\n            curc = (curc % mod) * todeg(k, -1);\n        }\n        curc %= mod;\n        //cout << k << \": \" << cur2 << \", \" << curc << '\\n';\n        f += /*cur2 * */curc;\n        //f %= mod;\n        if (f > mod) {\n            f -= mod;\n        }\n    }\n    ll ans = todeg(3, n);\n    ans -= 2 * f;\n    while(ans < 0) {\n        ans += mod;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int mod=998244353,N=1e7+5;\nint fac[N],inv[N],pw[N],n,tot;\n\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n\treturn res;\n}\n\nint C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nsigned main(){\n\tread(n);\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tpw[0]=1;for(int i=1;i<=n;i++) pw[i]=(pw[i-1]+pw[i-1])%mod;\n\tinv[n]=fpow(fac[n],mod-2);for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tfor(int i=n/2+1;i<=n;i++) tot=(tot+pw[n-i]*C(n,i)%mod)%mod;\n\twrite((fpow(3,n)-tot-tot+mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// use gp_hash_table<int,int,custom_hash> m;\n// in place of map\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define repa(i,a,n) for(int i=a;i<n;++i)\n#define repr(i,n) for(int i=n-1;i>=0;--i)\n#define repba(i,b,a) for(int i=b;i>=a;--i)\n#define repab(i,a,b) for(int i=a;i<b;++i)\n#define ll long long\n// #define ull unsigned long long\n#define vi vector<int>\n#define msi map<string,int>\n#define mii map<int,int>\n#define viip vector<pair<int,pair<int,int> > > \n#define mp make_pair\n#define vip vector<pair<int,int> >\n#define pb push_back \n#define po pop_back\n#define fi first\n#define sec second\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\n// #define s(v) v.size()\nll mod = 998244353;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());//use rng()%n for numbers in range [0,n-1]\n// This custom_hash is for unordered_map \n// use map<int, int, custom_hash> mp;\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nusing uint=unsigned;\nusing ull=unsigned long long;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\nconst int maxn = 1e7+2;\nmint inv[maxn],fac[maxn],pow1[maxn];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//#ifndef ONLINE_JUDGE\n   // \tfreopen(\"input.txt\", \"r\", stdin);\n    \t//freopen(\"output.txt\", \"w\", stdout);\n\t//#endif\n\tint n;\n\tcin>>n;\n\tfac[0]=1;\n\trepa(i,1,n+1){\n\t\tfac[i]=fac[i-1]*i;\n\t}\n\tinv[n] = fac[n].inv();\n\trepr(i,n){\n\t\tinv[i] = inv[i+1]*(i+1);\n\t}\n\tmint x = 3;\n\tmint ans = x.pow(n);\n\tpow1[0]=1;\n\trepa(i,1,n+1){\n\t\tpow1[i] = pow1[i-1]*2;\n\t}\n\trepa(i,n/2+1,n+1){\n\t\tans -= pow1[n-i]*inv[i]*inv[n-i]*fac[n]*2;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n#define PI  (3.1415926535)\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n\n\n\n// #define MOD   (1000000007LL)\n#define MOD   (998244353LL)\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    perm_invs[size-1] = mod_inv(perms[size-1], mod);\n    rrep (i, size-1) {\n        perm_invs[i] = perm_invs[i+1LL] * (i+1LL);\n        perm_invs[i] %= mod;\n    }\n}\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n\n    S ll perms[10000007];\n    S ll perm_invs[10000007];\n    make_perms(perms, perm_invs, 10000007, MOD);\n\n    ll total = 0;\n\n    rep (i, n/2LL) {\n        ll incr = 1LL;\n\n        incr *= perms[n];\n        incr %= MOD;\n        incr *= perm_invs[i];\n        incr %= MOD;\n        incr *= perm_invs[n-i];\n        incr %= MOD;\n\n        incr *= mod_pow(2LL, i, MOD);\n        incr %= MOD;\n\n        total += incr;\n        total %= MOD;\n    }\n\n    total *= 2LL;\n    total %= MOD;\n\n    ll ans = mod_pow(3LL, n, MOD);\n    ans -= total;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<assert.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\n#define MRE assert(0);\nconst int inf = 1e11;\nconst int mod = 998244353;\nconst int maxN = 10000003;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint kj[maxN], kji[maxN];\nint rwa[maxN];\nint modpow(int a, int x, int mod) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\tx >>= 1;\n\t\ta = a*a%mod;\n\t}\n\treturn res;\n}\nvoid setkj(int n) {\n\tkj[0] = 1;\n\trep(i, n)kj[i + 1] = kj[i] * (i + 1) % mod;\n\trep(i, n + 1)kji[i] = modpow(kj[i], mod - 2, mod);\n}\nint comb(int r,int c) {\n\tif (c<0 || r<c)return 0;\n\treturn kj[r] * kji[c] % mod*kji[r - c] % mod;\n}\nvoid expr(int n) {\n\tint sum = 0;\n\trep(a1, n + 1) {\n\t\trep(b1, n + 1) {\n\t\t\trep(a2, n + 1) {\n\t\t\t\trep(b2, n + 1) {\n\t\t\t\t\tif (a1 + b1 <= n&&a2 + b2 <= n&&a1 + b2 <= n&&a2 + b1 <= n) {\n\t\t\t\t\t\tint c1 = n - a1 - b1, c2 = n - a2 - b2;\n\t\t\t\t\t\tsum += kj[n] * kj[n] % mod*kji[a1] % mod*kji[a2] % mod*kji[b1] % mod*kji[b2] % mod*kji[c1] % mod*kji[c2] % mod;\n\t\t\t\t\t\tcout << a1 << b1 << a2 << b2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n}\nsigned main() {\n\tint n; cin >> n;\n\tsetkj(n);\n\tn /= 2;\n\tint sum = 0;\n\tfor (int j = 1; j <= n; j++)rwa[j] = comb(n, j)*modpow(2, mod - 1 - j, mod) % mod;\n\tfor (int j = 0; j <= n; j++)rwa[j + 1] += rwa[j];\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint lj = n + 1 - i, rj = n;\n\t\tint res1 = rwa[rj] - rwa[lj - 1] + mod;\n\t\tres1 %= mod;\n\t\tsum += comb(n, i)*modpow(2, n + n - i, mod) % mod*res1%mod;\n\t\tsum %= mod;\n\t}\n\t/*\n\trep(i, n + 1) {\n\t\trep(j, n + 1) {\n\t\t\tif (i + j > n) {\n\t\t\t\tsum += comb(n, i)*comb(n, j) % mod*modpow(2, n*2 - i-j, mod);\n\t\t\t}\n\t\t}\n\t}*/\n\tsum = modpow(3, 2 * n, mod) - sum * 2 % mod;\n\tsum = (sum + mod) % mod;\n\tcout << sum << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\n//繰り返し二乗法\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=power(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(5000010*2);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tll ans=mod_pow(3,n);\n\tll res=0;\n\tfor(int i=0;i<n/2;i++){\n\t\tll k=p.comb(n,i);\n\t\t(k*=mod_pow(2,i))%=mod;\n\t\t(res+=k)%=mod;\n\t}\n\tcout << (ans-2*res+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=998244353;\nll modpow(ll x,ll y){\nif(y==0)\n  return 1;\n  else if(y%2==0){\n  ll z=modpow(x,y/2);\n    return (z*z)%mod;\n  }else{\n   ll z=modpow(x,y/2);\n    return (x*((z*z)%mod))%mod;\n  }\n}\nll N;\nll fac[10000005];\nll rev[10000005];\nll inf[10000005];\nint main(){\n  cin>>N;N/=2;\n  fac[0]=1;rev[0]=1;\n  for(ll i=1;i<=N;i++){\n  fac[i]=(i*fac[i-1])%mod;\n    rev[i]=modpow(fac[i],mod-2);\n  }ll a=1;\n  inf[0]=1;\n  for(ll i=1;i<=N;i++){\n  a=(a*2)%mod;\n    inf[i]=(a*((fac[N]*((rev[N-i]*rev[i])%mod))%mod))%mod;\n  }ll ans=0;ll sum=0;\n  for(ll i=0;i<N;i++){\n  sum=(sum+inf[i])%mod;\n    ans=(ans+((inf[N-1-i]*sum)%mod))%mod;\n  }\n  ll all=modpow(9,N);\n  ans=(all-2*ans+2*mod)%mod;\n  cout<<ans<<endl;\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1e7;\nconst int mod=998244353;\nlong long ans=0;\nint n;\nint fir[maxn+5],inv[maxn+5],mu[maxn+5];\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nlong long C(int n,int m)\n{\n\treturn 1ll*fir[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfir[0]=1;\n\tfor(int i=1;i<=n;i++) fir[i]=1ll*fir[i-1]*i%mod;\n\tinv[n]=ksm(fir[n],mod-2);\n\tfor(int i=n-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tmu[0]=1;\n\tfor(int i=1;i<=n;i++) mu[i]=mu[i-1]*2%mod;\n\tfor(int i=n/2+1;i<=n;i++) ans=(ans+C(n,i)*mu[n-i]%mod)%mod;\n\tans=(ksm(3,n)-ans*2%mod)%mod;\n\tans=(ans%mod+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// C - Neither AB nor BA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD\t998244353\n\nvector<long long> fact, finv;\n\nvoid init_fact(int n = 1000000)\n{\n\tfact.resize(n); finv.resize(n);\n\tfact[0] = finv[n - 1] = 1;\n\tfor (int i = 1; i < n; i++) fact[i] = fact[i - 1] * i % MOD;\n\tfor (long long x = MOD - 2, a = fact[n - 1]; x > 0; a = a * a % MOD, x >>= 1)\n\t\tif (x & 1) finv[n - 1] = finv[n - 1] * a % MOD;\n\tfor (int i = n - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % MOD;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact[n] * finv[r] % MOD * finv[n - r] % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tlong long n;\n\tcin >> n;\n\n\tinit_fact(n + 1);\n\n\tlong long ans = 1;\n\tfor (int i = 0; i < n; i++) ans = ans * 3 % MOD;\n\n\tvector<long long> p2(n + 1, 1);\n\tfor (int i = 0; i < n; i++) p2[i + 1] = (p2[i] * 2) % MOD;\n\tfor (long long i = n / 2 + 1; i <= n; i++)\n\t\tans = (ans - cnr(n, i) * p2[n - i] * 2 % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define LD long double\n#define ST string\n#define BS bitset\n#define PA pair<LL,LL>\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define BPL __builtin_popcountll\n#define FOR(i,a,n) for(i=a;i<n;++i)\n#define FORR(i,a,n) for(i=n-1;i>=a;--i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) FORR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define INF 1145141919810364364\n#define PI 3.14159265358979\n//#define MOD 1000000007\n#define MOD 998244353\n#define ERR 0.00000001\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL dig(LL n){LL ret=0;while(n)n/=10,ret++;return ret;}\nLL LBn(VL &v,LL a){LL mx=v.size(),mn=-1,md;while(mx-mn>1){md=(mx+mn)/2;if(v[md]<a)mn=md;else mx=md;}return mx;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nint lcmp(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return 1;if(*(LL*)a<*(LL*)b)return -1;return 0;}\nint lcmpr(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return -1;if(*(LL*)a<*(LL*)b)return 1;return 0;}\nint ccmp(const void* a,const void* b){return *(char*)a-*(char*)b;}\nint ccmpr(const void* a,const void* b){return *(char*)b-*(char*)a;}\nint scmp(const void* a,const void* b){return strcmp((char*)a,(char*)b);}\nint scmpr(const void* a,const void* b){return strcmp((char*)b,(char*)a);}\nLL cmod(LL a,LL m){if(a%m<0)return a%m+abs(m);else return a%m;}\nLL DIV(LL a,LL d,LL m){LL l=m,x=1,y=0,k;while(l){k=d/l;d-=k*l;swap(l,d);x-=k*y;swap(x,y);}return cmod(a*cmod(x,m),m);}\nLL POW(LL a,LL n,LL m){LL ans=1;while(n>0){if(n&1)ans=ans*a%m;a=a*a%m;n>>=1;}return ans;}\nVL fact,finv,inv;\nvoid comi(LL n){LL i;fact.resize(max(2LL,n+1));finv.resize(max(2LL,n+1));inv.resize(max(2LL,n+1));fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,n+1){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\ntemplate<typename T>bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\n#define MI modint<MOD>\ntemplate<int mod>struct modint{\n\tint x;\n\tmodint():x(0){}\n\tmodint(LL n):x(n>=0?n%mod:(mod-(-n)%mod)%mod){}\n\tmodint &operator+=(const modint &n){if((x+=n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator-=(const modint &n){if((x+=mod-n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator++(){*this+=1;return *this;}\n  modint &operator--(){*this-=1;return *this;}\n\tmodint &operator*=(const modint &n){x=(int)((LL)x*n.x%mod);return *this;}\n\tmodint &operator/=(const modint &n){*this*=n.inv();return *this;}\n\tmodint operator-()const{return modint(-x);}\n\tmodint operator+(const modint &n)const{return modint(*this)+=n;}\n\tmodint operator-(const modint &n)const{return modint(*this)-=n;}\n\tmodint operator++(int){modint ret(*this);*this+=1;return ret;}\n  modint operator--(int){modint ret(*this);*this-=1;return ret;}\n\tmodint operator*(const modint &n)const{return modint(*this)*=n;}\n\tmodint operator/(const modint &n)const{return modint(*this)/=n;}\n\tbool operator<(const modint &n)const{return x<n.x;}\n\tbool operator>(const modint &n)const{return x>n.x;}\n\tbool operator<=(const modint &n)const{return x<=n.x;}\n\tbool operator>=(const modint &n)const{return x>=n.x;}\n\tbool operator!=(const modint &n)const{return x!=n.x;}\n\tbool operator==(const modint &n)const{return x==n.x;}\n\tfriend istream &operator>>(istream &is,modint &n){LL l;is>>l;n=modint<mod>(l);return is;}\n\tfriend ostream &operator<<(ostream &os,const modint &n){return os<<n.x;}\n\tint getmod(){return mod;}\n\tmodint inv()const{int a=x,b=mod,c=1,d=0,n;while(b){n=a/b;swap(a-=n*b,b);swap(c-=n*d,d);}return modint(c);}\n\tmodint pow(LL n)const{modint ret(1),m(x);while(n){if(n&1)ret*=m;m*=m;n>>=1;}return ret;}\n};\n\nint main(){\n\tFAST;\n\tLL i,N;\n\tcin>>N;\n\tcomi(N);\n\tMI ans=MI(3).pow(N),k=1,m;\n\tFORR(i,N/2+1,N+1)m+=k*com(N,i),k*=2;\n\tcout<<ans-m*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\n//mod-int構造体\n//計算量 加減乗算:O(1)、除算:O(log(MOD))、K乗:O(log(K))\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int operator -() const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const{\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e7;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*mint(i);\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N-1, 0){\n        ifac[i] = ifac[i+1]*(i+1);\n    }\n}\n\nmint comb(mint n, mint k){\n    return fac[n.x]*ifac[n.x-k.x]*ifac[k.x];\n}\n\nmint perm(mint n, mint k){\n    return fac[n.x]*ifac[n.x-k.x];\n}\n\nint main(){\n    int N;\n    cin >> N;\n    init();\n    mint tw = 2, th = 3, ans = th.pow(N);\n    rep(i, N/2){\n        ans -= comb(N, i)*tw.pow(i+1);\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cin, cout, cerr\n#include <algorithm> // minmax, sort, swap\n#include <numeric> // iota\n#include <cstdio> // printf, scanf\n#include <string> // string, stoi, to_string\n#include <vector> // vector\n#include <queue> // queue, priority_queue\n#include <deque> // deque\n#include <map> // key-value pairs sorted by keys\n#include <set> // set\n#include <iomanip> // cout<<setprecision(n)\n#include <functional> // function<void(int)>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ENDL '\\n'\n#define print(i) std::cout << (i) << '\\n'\n\n#define int long long // at least int64 > 9*10^18\n#define all(v) (v).begin(), (v).end()\n/* libraries */\n\nconstexpr int MOD = 998244353;\nstruct mint\n{\n\tint v;\n\tmint():v(0){}\n\tmint(int v):v((v+MOD)%MOD){}\n\tmint operator-()const{ return mint(0) - *this; }\n\tmint& operator+=(const mint& a){ if((v+=a.v)>=MOD) v-=MOD; return *this; }\n\tmint& operator-=(const mint& a){ if((v+=MOD-a.v)>=MOD) v-=MOD; return *this; }\n\tmint& operator*=(const mint& a){ (v*=a.v)%=MOD; return *this; }\n\tmint& operator/=(const mint& a){ (*this) *= a.inv(); return *this; }\n\tmint operator+(const mint& a)const{ return mint(*this) += a; }\n\tmint operator-(const mint& a)const{ return mint(*this) -= a; }\n\tmint operator*(const mint& a)const{ return mint(*this) *= a; }\n\tmint operator/(const mint& a)const{ return mint(*this) /= a; }\n\tbool operator<(const mint& a)const{ return v < a.v; }\n\tbool operator==(const mint& a)const{ return v == a.v; }\n\tmint pow(int k)const{ mint r(1),t(v); while(k){ if(k&1) r*=t; t*=t; k>>=1; } return r; }\n\tmint inv()const{ return pow(MOD-2); }\n\tstatic mint comb(int n, int k) {\n\t\tif(n-k<k) k=n-k;\n\t\tmint num(1), dom(1);\n\t\tfor(int i=0;i<k;i++) { num*=n-i; dom*=i+1; }\n\t\treturn num/dom;\n\t}\n};\nstd::istream& operator>>(std::istream&i,mint&a){ int t; i>>t; a=mint(t); return i; }\nstd::ostream& operator<<(std::ostream&o,const mint&a){ o<<a.v; return o; }\n\n\nsigned main() {\n\tint n;\n\tstd::cin >> n;\n\tmint ans = mint(3).pow(n);\n\tmint com = 1;\n\tfor(int i=0;i<n/2;i++) {\n\t\tmint x = com;\n\t\tcom*=n-i;\n\t\tcom/=i+1;\n\t\tx*=mint(2).pow(i);\n\t\tans-=mint(2)*x;\n\t}\n\tprint(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nRathin Bhargava\nIIIT Bangalore\n\n*/\n#include<bits/stdc++.h>\n#define mt make_tuple\n#define mp make_pair\n#define pu push_back\n#define INF 1000000001\n#define MOD 998244353\n#define EPS 1e-6\n#define ll long long int\n#define ld long double\n#define fi first\n#define se second\n#define all(v) v.begin(),v.end()\n#define pr(v) { for(int i=0;i<v.size();i++) { v[i]==INF? cout<<\"INF \" : cout<<v[i]<<\" \"; } cout<<endl;}\n#define t1(x)                cerr<<#x<<\" : \"<<x<<endl\n#define t2(x, y)             cerr<<#x<<\" : \"<<x<<\" \"<<#y<<\" : \"<<y<<endl\n#define t3(x, y, z)          cerr<<#x<<\" : \" <<x<<\" \"<<#y<<\" : \"<<y<<\" \"<<#z<<\" : \"<<z<<endl\n#define t4(a,b,c,d)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<endl\n#define t5(a,b,c,d,e)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<\" \"<<#e<<\" : \"<<e<<endl\n#define t6(a,b,c,d,e,f)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<\" \"<<#e<<\" : \"<<e<<\" \"<<#f<<\" : \"<<f<<endl\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define t(...) GET_MACRO(__VA_ARGS__,t6,t5, t4, t3, t2, t1)(__VA_ARGS__)\n#define _ cerr<<\"here\"<<endl;\n#define __ {ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);}\n\nusing namespace std;\ntemplate<class A, class B> ostream& operator<<(ostream& out, const pair<A, B> &a){ return out<<\"(\"<<a.first<<\", \"<<a.second<<\")\";}\ntemplate <int> ostream& operator<<(ostream& os, const vector<int>& v) { os << \"[\"; for (int i = 0; i < v.size(); ++i) { if(v[i]!=INF) os << v[i]; else os << \"INF\";if (i != v.size() - 1) os << \", \"; } os << \"]\\n\"; return os; } \ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) { os << \"[\"; for (int i = 0; i < v.size(); ++i) { os << v[i]; ;if (i != v.size() - 1) os << \", \"; } os << \"]\\n\"; return os; } \n\nconst int N = 1e7+10;\nint fact[N] = {0};\nint inv[N] = {0};\n\nll power(ll x, ll y, ll p)\n{\n        ll res = 1;      // Initialize result\n        x = x % p;  // Update x if it is more than or\n        while (y > 0)\n        {\n                        if (y & 1)\n                                        res = (res*x) % p;\n                        y = y>>1; // y = y/2\n                        x = (x*x) % p;\n        }\n        return res;\n}\n\nvoid compute()\n{\n  fact[0] = 1;\n  inv[0] = 1;\n  for(int i=1;i<=1e7;i++) \n  {\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n    inv[i] = power(fact[i],MOD-2,MOD);\n  }\n}\n\nint C(int n,int i)\n{\n  int a = fact[n], b = inv[i], c = inv[n-i];\n  return ((1LL*a*b) % MOD * 1LL * c) % MOD;\n}\n\nint main()\n{\n  __;\n  compute();\n  int n;\n  cin >> n;\n  int a = power(3,n,MOD);\n  for(int i=n/2+1;i<=n;i++)\n  {\n    int temp = C(n,i);\n    int b = power(2,n-i,MOD);\n    // t(b,temp);\n    a -= ((2LL*temp) % MOD * b) % MOD;\n    a += MOD;\n    a %= MOD;\n  }\n\n  cout << a << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 10555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = 1;\n  for (ll i = 1; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n  }\n  rfact[n] = mod_inverse(fact[n], M);\n  for (ll i = n - 1; i >= 0; i--) {\n      rfact[i] = (i + 1) * rfact[i + 1] % M;\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    ll mul = 1;\n    for (int i = n; i > n / 2; i--) {\n    // for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mul % MOD;\n        mul = mul * 2 % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define End exit(0)\n#define LL long long\n#define mp make_pair\n#define SZ(x) ((int) x.size())\n#define GO cerr << \"GO\" << endl\n#define DE(x) cout << #x << \" = \" << x << endl\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n\nvoid proc_status()\n{\n\tfreopen(\"/proc/self/status\",\"r\",stdin);\n\tstring s; while(getline(cin, s)) if (s[2] == 'P') { cerr << s << endl; return; }\n}\n\ntemplate<typename T> inline T read() \n{\n\tregister T x = 0;\n\tregister char c; register int f(1);\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c ^ 48), isdigit(c = getchar()));\n\treturn x * f;\n}\n\ntemplate<typename T> inline bool chkmin(T &a,T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a,T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = 1e7 + 2;\nconst int mod = 998244353;\n\nint qpow(int a, int b)\n{\n    int ans = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n        if (b & 1) ans = 1ll * ans * a % mod;\n    return ans;\n}\n\ninline void Inc(int &x) { x < 0 ? x += mod : 0; }\n\nint fac[maxN + 2], ifac[maxN + 2], pw2[maxN + 2];\n\nvoid init(int N = 1e7)\n{\n    fac[0] = 1;\n    for (int i = 1; i <= N; ++i) fac[i] = (LL) fac[i - 1] * i % mod;\n    ifac[N] = qpow(fac[N], mod - 2);\n    for (int i = N - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % mod;\n    pw2[0] = 1;\n    for (int i = 1; i <= N; ++i) pw2[i] = pw2[i - 1] * 2ll % mod;\n}\n\nint C(int n, int m)\n{\n    if (n < m) return 0;\n    return (LL) fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint n;\n\nvoid input() { n = read<int>(); }\n\nvoid solve()\n{\n    int ans = qpow(3, n);\n    for (int i = n / 2 + 1; i <= n; ++i)\n        Inc(ans -= 2ll * C(n, i) * pw2[n - i] % mod);\n    printf(\"%d\\n\", ans);\n}\n\nint main() \n{ \n    input(), init(), solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nconstexpr int MOD = 998244353;\n\nint modpow(int b, int e) {\n    int res = 1;\n    for (int p = 1; p <= e; p <<= 1) {\n        if (p & e) {\n            res = 1LL * res * b % MOD;\n        }\n        b = 1LL * b * b % MOD;\n    }\n\n    return res;\n}\n\ninline int inv(int x) {\n    return modpow(x, MOD - 2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    int ans = modpow(3, n);\n    int cur = 0;\n    int term = 1;\n    int p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += 1LL * term * p % MOD;\n        if (cur >= MOD)\n            cur -= MOD;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term = 1LL * term * inv(n - k + 1) % MOD;\n        term = 1LL * term * k % MOD;\n        p += p;\n        if (p >= MOD)\n            p -= MOD;\n    }\n\n    int res = ans - cur;\n    if (res < 0) res += MOD;\n    cout << res << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#include<cstring>\n\n#include<cmath>\n\n#include<ctime>\n\n#include<cstdlib>\n\n#include<string>\n#include<assert.h>\n\n#include<queue>\n\n#include<stack>\n\n#include<bitset>\n\n#include<algorithm>\n\n#define pr pair<int,int>\n\n#define FR first\n\n#define SE second\n\n#define MP make_pair\n\n#define PB push_back\n#define fo(i,l,r) for(register int i=(l),I=(r);i<=I;i++)\n#define fd(i,l,r) for(register int i=(l),I=(r);i>=I;i--)\n\nnamespace mine\n\n{\n\n\ttypedef long long ll;\n\n\tll qread()\n\n\t{\n\n\t\tll ret=0,f=1;char c=getchar();\n\n\t\twhile(c<'0' or c>'9'){if(c=='-')f=-1;c=getchar();}\n\n\t\twhile('0'<=c and c<='9') ret=ret*10+c-'0',c=getchar();return ret*f;\n\n\t}\n\n\tvoid write(ll num){if(num<0)putchar('-'),num=-num;if(num>=10)write(num/10);putchar('0'+num%10);}\n\n\tvoid write1(ll num){write(num);putchar(' ');}\n\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\n\t\n\n\tconst int MOD=998244353;\n\n\tll qpower(ll x,ll e,const ll mod=MOD)\t{assert(e>=0);ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\n\tll invm(ll x,const ll mod=MOD){return qpower(x,mod-2,mod);}\n\n\ttemplate<typename T> void add(T &x,const int y){x=(x+y<MOD?x+y:x+y-MOD);}\n\n\n\tconst int N=1e7+10;\n\n\tll fac[N],facinv[N],inv[N];ll C(int n,int m){return n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\n    void main()\n\n\t{\n\t\tinv[1]=1;fo(i,2,N-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\n        fac[0]=1;fo(i,1,N-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[N-1]=invm(fac[N-1]);fd(i,N-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\n        int n=qread(),ans=0;\n\t\tll down=1;fo(i,n-n/2+1,n) down=down*i%MOD;\n\t\tll now=0;fo(y,0,n/2) add(now, C(n-n/2,y) );\n\n        for(int x=n/2;x>=0;x--)\n\t\t{\n\t\t\tadd(ans, down*now%MOD*facinv[x]%MOD );\n\t\t\tdown=down*inv[n-x+1]%MOD;now=(now*2+MOD-C(n-x,n/2))%MOD;\n\t\t}write(ans);\n\n\t}\n\n};\n\nint main()\n\n{\n\t//freopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\n\tsrand(time(0));\n\n\tmine::main();\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=2e7,p=998244353;\nint n,v[N],o[N],c[N],z[N],bi[N];\n#define C(x,y) (o[x]*c[y]%p*c[x-y]%p)\nmain()\n{v[1]=o[1]=c[1]=1;z[0]=bi[0]=c[0]=1;\nfor(int i=2;i<=1e7;i++)v[i]=p-v[p%i]*(p/i)%p,o[i]=o[i-1]*i%p,c[i]=c[i-1]*v[i]%p;\nfor(int i=1;i<=1e7;i++)bi[i]=bi[i-1]*3%p,z[i]=z[i-1]*2%p;\n\tcin>>n;int ans=bi[n];\n\tfor(int i=n/2+1;i<=n;i++)ans=(ans-C(n,i)*z[n-i+1]%p)%p;cout<<(ans+p)%p;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n\n\tfriend modnum pow() {}\n};\n\nusing num = modnum<998244353>;\n\nnum pow(num a, ll b){\n\tassert(b >= 0);\n\tif(b & 1) return a * pow(a, b-1);\n\tif(!b) return 1;\n\treturn pow(a * a, b / 2);\n}\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 11000000; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(fact.size());\n\tifact.back() = 1 / fact.back();\n\tfor(int i = (int)ifact.size() - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tp2[i] = 2 * p2[i-1];\n\t}\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * p2[i] * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc040/submissions/10482076\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n    if(N == 2) return 0;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t}\n    RF[N] = Calc(F[N], MOD - 2);\n    for (int i = N; i > 0; i--) {\n        RF[i - 1] = RF[i] * i % MOD;\n    }\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep(i,s,t)\n#define re register\n#define int long long\nint gi(){\n\tfor(register int i=s;i<=t;++i )\n    char cc=getchar();\n\tint cn=0,flus=1 ;\n    while(cc<'0'||cc>'9' ){ \n\tif( cc == '-' ) \n\tflus=-flus; \n\tcc=getchar(); \n}\n    while(cc>='0'&&cc<='9') \n\tcn=cn*10+cc-'0',cc=getchar() ;\n    return cn*flus;\n}\nconst int P=998244353; \nconst int N=1e7+5;\nint n,inv[N],fac[N],fp[N],Ans;\nint fpow(int x,int k){\n    int ans=1,base=x;\n    while(k) {\n        if(k&1) \n\t\tans=ans*base%P; \n        base=base*base%P,k>>=1;\n    } \n\treturn ans; \n}\nvoid inc(int&x,int y ){\n    ((x+=y)>=P)&&(x-=P);\n}\nint C(int x,int y){\n    if(y>x) \n\treturn 0 ;\n    return fac[x]*inv[y]%P*inv[x-y]%P;\n}\nsigned main()\n{\n    n=gi(),fp[0]=inv[0]=fac[0]=1;\n    rep(i,1,n)fac[i]=fac[i-1]*i%P,fp[i]=fp[i-1]*2%P; \n    inv[n]=fpow(fac[n],P-2);\n    for(re int i=n;i>=1;--i) \n\tinv[i-1]=inv[i]*i%P;\n    int m=(n/2)+1,num=0 ;\n    Ans=fpow(3,n) ;\n    for(re int i=m;i<=n;++i) {\n        int dec=C(n,i) ;\n        dec=dec*fp[n-i]%P;\n        inc(num,dec);\n    }\n    Ans=(Ans-num*2ll%P+P)%P;\n    printf(\"%lld\\n\",Ans);\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n/*int l[100001];\nint r[100001];\nint templ[100001];\nint tempr[100001];\nvoid margesort(int a[], int a_len, int left, int right);\n*/\nlong long modpow(long long a, long long n, long long mod);\nlong long modinv(long long a, long long mod);\n\n\nint main(){\n\t//C\n\tlong long int n;\n\tlong long int p = 998244353;\n\tcin >> n;\n\tn = n / 2;\n\tlong long int counter = 0;\n\tlong long int comb = 1;\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tcounter = (counter + 2 * comb) % p;\n\t\tcomb = (comb * 2 * (2 * n - i)) % p;\n\t\tcomb = (comb * modinv(i + 1, p)) % p;\n\t}\n\tlong long int absum = 1;\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tabsum = (absum * 3) % p;\n\t}\n\tabsum = (absum - counter + p) % p;\n\tcout << absum;\n\treturn 0;\n\t/*int n;\n\n\tint i;\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> l[i];\n\t\tcin >> r[i];\n\t}\n\tmargesort(l, n, 0, n - 1);\n\tint minR, min2R, maxL, max2L;\n\tminR = 1000000001;\n\tmin2R = 1000000001;\n\tmaxL = 0;\n\tmax2L = 0;\n\tint maxwidth = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (r[i] <= minR) {\n\t\t\tmin2R = minR;\n\t\t\tminR = r[i];\n\t\t}\n\t\telse if (r[i] < min2R) {\n\t\t\tmin2R = r[i];\n\t\t}\n\t\tif (l[i] >= maxL) {\n\t\t\tmax2L = maxL;\n\t\t\tmaxL = l[i];\n\t\t}\n\t\telse if (l[i] > max2L) {\n\t\t\tmax2L = l[i];\n\t\t}\n\t}\n\n\tint ll, rr;\n\tfor (i = 0; i < n; i++) {\n\t\tif (r[i] == minR) {\n\t\t\trr = min2R;\n\t\t}\n\t\telse {\n\t\t\trr = minR;\n\t\t}\n\t\tif (l[i] == maxL) {\n\t\t\tll = max2L;\n\t\t}\n\t\telse {\n\t\t\tll = maxL;\n\t\t}\n\t\tif (rr - ll >= 0) {\n\t\t\tif (rr - ll + r[i] - l[i] + 2 > maxwidth) {\n\t\t\t\tmaxwidth = rr - ll + r[i] - l[i] + 2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r[i] - l[i] + 1 > maxwidth) {\n\t\t\t\tmaxwidth = r[i] - l[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmin2R = r[n - 1];\n\tmax2L = l[n - 1];\n\tint j,w1,w2;\n\tfor (i = n-2; i > 0; i--) {\n\t\tif (r[i] < min2R) {\n\t\t\tmin2R = r[i];\n\t\t}\n\t\tif (l[i] > max2L) {\n\t\t\tmax2L = l[i];\n\t\t}\n\t\tmaxL = l[i - 1];\n\t\tif (r[i] == minR) {\n\t\t\tminR = 1000000001;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (r[j] < minR) {\n\t\t\t\t\tminR = r[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (min2R - max2L >= 0) {\n\t\t\tw2 = min2R - max2L + 1;\n\t\t}\n\t\telse {\n\t\t\tw2 = 0;\n\t\t}\n\t\tif (minR - maxL >= 0) {\n\t\t\tw1 = minR - maxL + 1;\n\t\t}\n\t\telse {\n\t\t\tw1 = 0;\n\t\t}\n\t\tif (w1 + w2 > maxwidth) {\n\t\t\tmaxwidth = w1 + w2;\n\t\t}\n\t}\n\tcout << maxwidth;\n\treturn 0;\n\t*/\n}\n/*\nvoid margesort(int a[], int a_len, int left, int right){\n\tint i, j, mid, L, R;\n\n\tif (right <= left)\n\t\treturn;\n\n\tmid = (left + right) / 2;\n\tmargesort(a, mid, left, mid);\n\tmargesort(a, a_len - mid, mid + 1, right);\n\n\tfor (i = left; i <= mid; i++) {\n\t\ttempl[i] = a[i];\n\t\ttempr[i] = r[i];\n\t}\n\tfor (i = mid + 1, j = right; i <= right; i++, j--) {\n\t\ttempl[i] = a[j];\n\t\ttempr[i] = r[j];\n\t}\n\tL = left;\n\tR = right;\n\n\tfor (i = left; i <= right; i++)\n\t{\n\t\tif (templ[L] <= templ[R])\n\t\t{\n\t\t\ta[i] = templ[L];\n\t\t\tr[i] = tempr[L];\n\t\t\tL++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[i] = templ[R];\n\t\t\tr[i] = tempr[R];\n\t\t\tR--;\n\t\t}\n\t}*/\n\t// a^n mod を計算する\n\nlong long modpow(long long a, long long n, long long mod) {\n\tlong long res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// a^{-1} mod を計算する\nlong long modinv(long long a, long long mod) {\n\treturn modpow(a, mod - 2, mod);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e7+7, M = 998244353;\nLL fac[N], invfac[N];\nLL p2[N], p3[N];\n\nLL power(LL a, LL p) {\n    if (p==0)   return 1;\n    LL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nLL pre() {\n    fac[0] = 1;\n    for (int i=1; i<N; i++) fac[i] = (fac[i-1]*i)%M;\n    invfac[N-1]=  power(fac[N-1], M-2);\n    for (int i=N-2; i>=0; i--)  invfac[i] = (invfac[i+1]*(i+1))%M;\n\n    p2[0] = p3[0] = 1;\n    for (int i=1; i<N; i++) {\n        p2[i] = (p2[i-1]*2)%M;\n        p3[i] = (p3[i-1]*3)%M;\n    }\n}\n\nLL C(int n, int r) {\n    if (r < 0 || r > n) return 0;\n    LL num = fac[n];\n    LL den = (invfac[r]*invfac[n-r])%M;\n    return (num*den)%M;\n}\n\nLL f[N];\nLL suf[N];\n\nint main() {\n    pre();\n    int n;\n    cin>>n;\n    int m = n/2;\n\n    for (int i=0; i<=m; i++)    {\n        f[i] = (C(m, i)*p2[m-i])%M;\n    }\n\n    for (int i=m; i>=0; i--) {\n        suf[i] = (suf[i+1] + f[i])%M;\n    }\n\n    LL ans =- 0;\n\n    for (int i=0; i<=m; i++)    {\n        ans = (ans + f[i] * suf[m-i+1])%M;\n    }\n    ans = (ans * 2)%M;\n    ans = (p3[2*m] - ans + M)%M;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define MD (998244353U)\nvoid *wmem;\nchar memarr[96000000];\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct Modint{\n  unsigned val;\n  Modint(){\n    val=0;\n  }\n  Modint(int a){\n    val = ord(a);\n  }\n  Modint(unsigned a){\n    val = ord(a);\n  }\n  Modint(long long a){\n    val = ord(a);\n  }\n  Modint(unsigned long long a){\n    val = ord(a);\n  }\n  inline unsigned ord(unsigned a){\n    return a%MD;\n  }\n  inline unsigned ord(int a){\n    a %= MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned ord(unsigned long long a){\n    return a%MD;\n  }\n  inline unsigned ord(long long a){\n    a %= MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned get(){\n    return val;\n  }\n  inline Modint &operator+=(Modint a){\n    val += a.val;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator-=(Modint a){\n    if(val < a.val){\n      val = val + MD - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  inline Modint &operator*=(Modint a){\n    val = ((unsigned long long)val*a.val)%MD;\n    return *this;\n  }\n  inline Modint &operator/=(Modint a){\n    return *this *= a.inverse();\n  }\n  inline Modint operator+(Modint a){\n    return Modint(*this)+=a;\n  }\n  inline Modint operator-(Modint a){\n    return Modint(*this)-=a;\n  }\n  inline Modint operator*(Modint a){\n    return Modint(*this)*=a;\n  }\n  inline Modint operator/(Modint a){\n    return Modint(*this)/=a;\n  }\n  inline Modint operator+(int a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(int a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(int a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(int a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator+(long long a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(long long a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(long long a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(long long a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator-(void){\n    Modint res;\n    if(val){\n      res.val=MD-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  inline operator bool(void){\n    return val!=0;\n  }\n  inline operator int(void){\n    return get();\n  }\n  inline operator long long(void){\n    return get();\n  }\n  inline Modint inverse(){\n    int a = val;\n    int b = MD;\n    int u = 1;\n    int v = 0;\n    int t;\n    Modint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += MD;\n    }\n    res.val = u;\n    return res;\n  }\n  inline Modint pw(unsigned long long b){\n    Modint a(*this);\n    Modint res;\n    res.val = 1;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  inline bool operator==(int a){\n    return ord(a)==val;\n  }\n  inline bool operator!=(int a){\n    return ord(a)!=val;\n  }\n}\n;\ninline Modint operator+(int a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(int a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(int a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(int a, Modint b){\n  return Modint(a)/=b;\n}\ninline Modint operator+(long long a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(long long a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(long long a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(long long a, Modint b){\n  return Modint(a)/=b;\n}\ninline void rd(int &x){\n  int k;\n  int m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  int s=0;\n  int m=0;\n  char f[10];\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(Modint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\ntemplate<class T, class S> inline T pow_L(T a, S b){\n  T res = 1;\n  res = 1;\n  while(b){\n    if(b&1){\n      res *= a;\n    }\n    b >>= 1;\n    a *= a;\n  }\n  return res;\n}\ninline double pow_L(double a, double b){\n  return pow(a,b);\n}\ntemplate<class S, class T> inline S chmax(S &a, T b){\n  if(a<b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class T> struct Comb{\n  int mem_fact;\n  T *factri;\n  T *ifactri;\n  Comb(){\n    mem_fact = 0;\n  }\n  inline void expand_fact(int k){\n    if(k <= mem_fact){\n      return;\n    }\n    chmax(k, 2* mem_fact);\n    if(mem_fact == 0){\n      int i;\n      factri = (T*)malloc(k * sizeof(T));\n      ifactri = (T*)malloc(k * sizeof(T));\n      factri[0] = 1;\n      for(i=(1);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(0);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    else{\n      int i;\n      factri = (T*)realloc(factri, k * sizeof(T));\n      ifactri = (T*)realloc(ifactri, k * sizeof(T));\n      for(i=(mem_fact);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(mem_fact);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    mem_fact = k;\n  }\n  inline T fac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return factri[k];\n  }\n  inline T ifac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return ifactri[k];\n  }\n  inline T C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[b] * ifactri[a-b];\n  }\n  inline T P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[a-b];\n  }\n  inline T H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a <= 0 || b < 0){\n      return 0;\n    }\n    if(mem_fact < a+b){\n      expand_fact(a+b);\n    }\n    return C(a+b-1, b);\n  }\n  inline T Multinomial(int sz, int a[]){\n    int i;\n    int s = 0;\n    T res;\n    for(i=(0);i<(sz);i++){\n      s += a[i];\n    }\n    if(mem_fact < s+1){\n      expand_fact(s+1);\n    }\n    res = factri[s];\n    for(i=(0);i<(sz);i++){\n      res *= ifactri[a[i]];\n    }\n    return 1;\n  }\n  inline T Multinomial(int a){\n    return 1;\n  }\n  inline T Multinomial(int a, int b){\n    if(mem_fact < a+b+1){\n      expand_fact(a+b+1);\n    }\n    return factri[a+b] * ifactri[a] * ifactri[b];\n  }\n  inline T Multinomial(int a, int b, int c){\n    if(mem_fact < a+b+c+1){\n      expand_fact(a+b+c+1);\n    }\n    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];\n  }\n  inline T Multinomial(int a, int b, int c, int d){\n    if(mem_fact < a+b+c+d+1){\n      expand_fact(a+b+c+d+1);\n    }\n    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];\n  }\n  inline T Catalan(int n){\n    if(n < 0){\n      return 0;\n    }\n    if(mem_fact < 2*n+1){\n      expand_fact(2*n+1);\n    }\n    return factri[2*n] * ifactri[n] * ifactri[n+1];\n  }\n  inline T C_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(b > a - b){\n      b = a - b;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n      res /= i + 1;\n    }\n    return res;\n  }\n  inline T P_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n    }\n    return res;\n  }\n  inline T per_s(long long n, long long k){\n    T d;\n    int m;\n    if(n < 0 || k < 0){\n      return 0;\n    }\n    if(n == k  &&  k == 0){\n      return 1;\n    }\n    if(n == 0 || k == 0){\n      return 0;\n    }\n    if(k==1){\n      return 1;\n    }\n    if(k==2){\n      d = n / 2;\n      return d;\n    }\n    if(k==3){\n      d = (n-1) / 6;\n      m = (n-1) % 6;\n      if(m==0){\n        return 3 * d * d + d;\n      }\n      if(m==1){\n        return 3 * d * d + 2 * d;\n      }\n      if(m==2){\n        return 3 * d * d + 3 * d + 1;\n      }\n      if(m==3){\n        return 3 * d * d + 4 * d + 1;\n      }\n      if(m==4){\n        return 3 * d * d + 5 * d + 2;\n      }\n      if(m==5){\n        return 3 * d * d + 6 * d + 3;\n      }\n    }\n    assert(0 && \"per_s should be k <= 3\");\n    return -1;\n  }\n}\n;\nint main(){\n  int i;\n  wmem = memarr;\n  int N;\n  Modint res;\n  Modint pw;\n  Comb<Modint> c;\n  rd(N);\n  pw = 1;\n  for(i=(0);i<(N/2);i++){\n    res += pw * c.C(N,i);\n    pw *= 2;\n  }\n  res =pow_L(Modint(3),N)- 2 * res;\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20191108-1\n\n// --- original code ---\n// #define MD 998244353\n// {\n//   int N;\n//   Modint res, pw;\n//   Comb<Modint> c;\n//   rd(N);\n//   pw = 1;\n//   rep(i,N/2){\n//     res += pw * c.C(N,i);\n//     pw *= 2;\n//   }\n//   res = Modint(3) ** N - 2 * res;\n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y)\n      : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const {\n    return ModInt(*this) += p;\n  }\n  ModInt operator-(const ModInt &p) const {\n    return ModInt(*this) -= p;\n  }\n  ModInt operator*(const ModInt &p) const {\n    return ModInt(*this) *= p;\n  }\n  ModInt operator/(const ModInt &p) const {\n    return ModInt(*this) /= p;\n  }\n  bool operator==(const ModInt &p) const {\n    return x == p.x;\n  }\n  bool operator!=(const ModInt &p) const {\n    return x != p.x;\n  }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt ans(1), mul(x);\n    while(n) {\n      if(n & 1) ans *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ans;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nlong long n;\nvector<ModInt<MOD>> memo, sum, dp;\n\nModInt<MOD> solve();\n\nint main() {\n  cin >> n;\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<MOD> solve() {\n  ModInt<MOD> ans = 3, two = 2, now = 0;\n  ans = ans.pow(n);\n  memo.assign(n + 1, 0);\n  sum.assign(n + 1, 0);\n  memo[1] = sum[1] = 1;\n  for(int i = 0; i <= n; i += 2)\n    now += two.pow(n / 2 + 1 - i / 2);\n  return ans - now;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\n\nvector<int64_t> factors;\nvector<int64_t> finvs;\nvoid precalc_nCr(int n, int64_t rem) {\n\tfactors = vector<int64_t>(n + 1);\n\tfinvs = vector<int64_t>(n + 1);\n\n\t{\n\t\tint64_t f = 1;\n\t\tfactors[0] = 1;\n\t\tFOR_LE(i, 1, n) {\n\t\t\tf *= i;\n\t\t\tf %= rem;\n\t\t\tfactors[i] = f;\n\t\t}\n\t}\n\t{\n\t\tint64_t inv = divide_rem(1, factors[n], rem);\n\t\tfinvs[n] = inv;\n\t\tFOR_DW(i, n - 1, 0) {\n\t\t\tinv *= i + 1;\n\t\t\tinv %= rem;\n\t\t\tfinvs[i] = inv;\n\t\t}\n\t}\n}\n\nint64_t nCr(int n, int k) {\n\tint64_t val = factors[n];\n\tval *= finvs[n - k];\n\tval %= kRem;\n\tval *= finvs[k];\n\tval %= kRem;\n\treturn val;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tprecalc_nCr(n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = nCr(n, k);\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nll MOD = 998244353;\nconst ll N = 1e7+10;\nll f[N], rf[N];\nll inv(ll x) {\n    ll res = 1;\n    ll k = MOD - 2;\n    ll y = x;\n    while (k) {\n        if (k & 1) res = (res * y) % MOD;\n        y = (y * y) % MOD;\n        k /= 2;\n    }\n    return res;\n}\nvoid init() {\n    f[0] = 1;\n    for(int i = 1; i < N; i++) f[i] = (f[i - 1] * i) % MOD;\n    for(int i = 0; i < N; i++) rf[i] = inv(f[i]);\n}\nll C(int n, int k) {\n    if(n < k) return 0;\n    ll a = f[n]; // = n!\n    ll b = rf[n-k]; // = (n-k)!\n    ll c = rf[k]; // = k!\n    ll bc = (b * c) % MOD;\n    return (a * bc) % MOD;\n}\n\nll mod_pow(ll x, ll n)\n{\n    ll res = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n        {\n            res = res * x % MOD;\n        }\n        x = x * x % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    init();\n    cout << -1 << endl;\n  return 0;\n    int n;\n    cin >> n;\n    ll ans = mod_pow(3, n);\n    ll tmp = 0;\n    vector<ll> mod2(n/2+1);\n    mod2[0] = 1;\n    for(int i = 1; i < n/2+1; i++)\n    {\n        mod2[i] = mod2[i-1] * 2 % MOD;\n    }\n    for(int a = n/2 + 1; a <= n; a++)\n    {\n        tmp += C(n, a) * mod2[n-a] % MOD;\n        tmp %= MOD;\n    }\n    tmp = tmp * 2 % MOD;\n    ans = (ans - tmp + MOD) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int P = 998244353;\n\nll powmod(ll n, ll k) {\n    ll r = 1, t = n % P;\n    for (; k != 0; k /= 2) {\n        if (k & 1) r = r * t % P;\n        t = t * t % P;\n    }\n    return r;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> inv(n / 2 + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n / 2; i++) {\n        inv[i] = (ll)(P - P / i) * inv[P % i] % P;\n    }\n\n    ll r = 0, s = 1, t = 1;\n    for (int i = n; i > n / 2; i--) {\n        r += t * s % P;\n        (s *= 2) %= P;\n        (t *= i) %= P;\n        (t *= inv[n - i + 1]) %= P;\n    }\n    r = powmod(3, n) - r * 2;\n\n    r %= P;\n    if (r < 0) r += P;\n\n    cout << r << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse2,avx,avx2,fma\")\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*((invFact[a-b]*invFact[b])%MOD)%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += tempPow2*ncr(N, i)%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n#define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 998244353;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 10000010;\n\nll n, pow2[maxn], fact[maxn], ifact[maxn];\n\n/*\n    change A and B in odd indices (now each A need an other letter for remove and the same for B)\n    Condition: \n    Ca <= Cb + Cc (Ca <= n / 2)\n    Cb <= Ca + Cc (Cb <= n / 2)\n   */\n\nll poww(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b & 1) Mul(r, a);\n        Mul(a, a);\n        b >>= 1;\n    }\n    return r;\n}\n\nll ent(ll a, ll b) {\n    return fact[b] * ifact[a] % MOD * ifact[b - a] % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    // ifstream cin(\".in\");\n\n    fact[0] = 1;\n    fori (i, maxn - 1) fact[i + 1] = fact[i] * (i + 1) % MOD;\n    ifact[maxn - 1] = poww(fact[maxn - 1], MOD - 2);\n    forir (i, maxn - 1) ifact[i] = ifact[i + 1] * (i + 1) % MOD;\n    pow2[0] = 1;\n    fori (i, maxn - 1) pow2[i + 1] = pow2[i] * 2 % MOD;\n\n    cin >> n;\n    ll bad = 0;\n    fori (i, n / 2) {\n        Add(bad, ent(i, n) * pow2[i]);\n    }\n    ll ans = (poww(3, n) + (MOD - bad) * 2) % MOD;\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<FiniteField> factorials(n + 1);\n  vector<FiniteField> inverse_factorials(n + 1);\n\n  factorials[0] = inverse_factorials[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    factorials[i] = factorials[i - 1] * i;\n    inverse_factorials[i] = FiniteField(1) / factorials[i];\n  }\n\n  vector<FiniteField> two_powers(n + 1);\n  two_powers[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two_powers[i] = two_powers[i - 1] * 2;\n  }\n\n  FiniteField z = 0;\n  for (int k = n / 2 + 1; k <= n; k++) {\n    z += factorials[n] * inverse_factorials[k] * inverse_factorials[n - k]\n        * two_powers[n - k];\n  }\n  \n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans *= 3;\n  }\n  ans -= z * 2;\n  cout << ans.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\nvector<long long> F, RF;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tRF[i] = Calc(F[i], MOD - 2);\n\t}\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int MOD = 998244353;\nll modPow (ll a, ll b){\n  ll res = 1;\n  a %= MOD;\n  while (b) \n  {\n    if (b & 1) res = (res * a) % MOD;\n    a = (a * a) % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nll sum (ll a, ll b){ \n  ll s = a + b;\n  if (s >= MOD) s -= MOD;\n  return s;\n}\nll mult (ll a, ll b){\n  return (1LL * a * b) % MOD;\n}\nll sub (ll a, ll b) {\n  int s = a - b;\n  if (s < 0) s += MOD;\n  return s;\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  ll cur = 1, res = 0;\n  for (int i = 0; i <= n; ++i)\n  {\n    if (i >= n/2) {\n      res = sum(res, cur);\n    }\n    ll temp = sub(n, i);\n    temp = (temp*2)%MOD; \n    cur = mult(cur, temp);\n    temp = i + 1;\n    if (temp >= MOD) temp -= MOD;\n    cur/= temp;\n  }\n  ll a = modPow(3, n);\n  ll b = (2*res)%MOD;\n  ll ans = sub (b, a);\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vp;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst db eps = 1e-10;\n\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define ep emplace\n#define mem(a) memset(a, 0, sizeof(a))\n#define copy(a, b) memcpy(a, b, sizeof(b))\n#define PA cout << \"pass\\n\"\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define TM cout << db(clock()) / CLOCKS_PER_SEC << '\\n'\n\nconst int mod = 998244353;\nconst int maxn = 1e7 + 233;\nint fac[maxn], inv[maxn];\n\nint pow_mod(int q, int w){\n    int ret = 1;\n    while(w){\n        if(w & 1) ret = 1ll * ret * q % mod;\n        q = 1ll * q * q % mod;\n        w >>= 1;\n    }\n    return ret % mod;\n}\n\nint n;\nint po[maxn];\n\nint C(int x, int y){\n    if(x < y) return 0;\n    return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    po[0] = fac[0] = inv[0] = 1;\n    for(int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod, po[i] = (po[i - 1] + po[i - 1]) % mod;\n    inv[n] = pow_mod(fac[n], mod - 2);\n    for(int i = n - 1; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n    int res = 0;\n    for(int i = n / 2 + 1; i <= n; i++) res = (res + 2ll * C(n, i) * po[n - i]) % mod;\n    cout << (pow_mod(3, n) + mod - res) % mod << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "."
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (10000006)\nll n, f[MAXN], inv[MAXN], p2[MAXN], mod=998244353;\nint main(){\n\tFAST\n\tcin>>n;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\tfor(;e;e>>=1,x*=x,x%=mod)if(e&1)sum*=x,sum%=mod;\n\t\treturn sum;\n\t};\n\tp2[0]=1; FOR(i,1,MAXN-1)p2[i]=p2[i-1]*2%mod;\n\tf[0]=1; FOR(i,1,MAXN-1)f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1]=qexp(f[MAXN-1],mod-2);\n\tDEC(i,MAXN-2,0)inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){\n\t\treturn n < k ? 0 : f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=qexp(3,n);\n\tFOR(i,n/2+1,n){\n\t\tans -= 2 * C(n, n-i) % mod * p2[n-i] % mod, ans += mod, ans %= mod;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M = 998244353;\nconst ll MN = 10001000;\nll fp[MN],ip[MN],pt[MN];\nll mul(ll a, ll b) {return (a*b)%M;}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll fac(ll p) {\n\tif(p <= 1) {return 1;}\n\tif(fp[p] != -1) return fp[p];\n\tif(p > 10000) {fac(p-10000);}\n\treturn fp[p] = mul(p,fac(p-1));\n}\nll inv(ll b) {\n\treturn bp(b,M-2);\n}\nll ifac(ll b) {\n\tif(b < MN) {\n\t\tif(ip[b] != -1) {return ip[b];}\n\t\treturn ip[b] = inv(fac(b));\n\t}\n\treturn inv(fac(b));\n}\nll ch(ll n, ll k) {\n\tif(k > n || k < 0) return 0;\n\treturn mul(mul(fac(n),ifac(k)),ifac(n-k));\n}\nint main() {\n\tmemset(fp,-1,sizeof(fp));\n\tmemset(ip,-1,sizeof(ip));\n\tll n;\n\tcin >> n;\n\tpt[0] = 1;\n\tfor(int i=0;i<n;i++) {\n\t\t//pt[i+1] = mul(2,pt[i]);\n\t\tpt[i+1] = 2*pt[i];\n\t\tif(pt[i+1] >= M) {pt[i+1] -= M;}\n\t}\n\tll res = bp(3,n);\n\tll tot = 0;\n\tfor(int i=0;i<n/2;i++) {\n\t\ttot += mul(ch(n,i),pt[i]);\n\t}\n\ttot *= 2;\n\tres = (res-tot);\n\tres = ((res%M)+M)%M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Combination C(N);\n\n    mint ans = 0;\n    FOR(i, N / 2 + 1, N + 1) ans += C.nCr(N, i) * pow((mint)2, N - i);\n\n    ans = pow((mint)3, N) - ans * 2;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>::value || is_same<T,modint>::value);\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {\n        assert(num >= 0);\n    }\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>() || is_same<T,modint>(), \"T is not integral.\");\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return num + r; }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return num - r; }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return num * r; }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static constexpr int MOD = 998244353;\n    int v;\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = 1LL * v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint { v } += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint { v } -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint { v } *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint { v } /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res { 1 };\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(modint { 3 }, n);\n    modint cur = { 0 };\n    modint term = { 1 };\n    modint p = { 2 };\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= modint { n - k + 1 };\n        term *= modint { k };\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//TJ\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e7+10;\ntypedef long long ll;\nll n,fac[N],invf[N],mi2[N],ans;//fac 阶乘，invf 阶乘得逆元 \nconst ll mod=998244353;\n\nll qpow(ll a,ll b) {\n\tll ans=1ll;\n\twhile(b) {\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb/=2;\n\t}\n\treturn ans;\n}\n\nll C(int x,int y) {\n\treturn fac[x]*invf[y]%mod*invf[x-y]%mod;\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfac[0]=mi2[0]=1;\n\tfor(int i=1; i<=n; i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod,mi2[i]=mi2[i-1]*2%mod;//fac阶乘，ci 2^2; \n\tinvf[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1; i>=0; i--)\n\t\tinvf[i]=1ll*invf[i+1]*(i+1)%mod;\n\tfor(int i=n/2+1; i<=n; i++)\n\t\tans=(ans+C(n,i)*mi2[n-i]%mod)%mod;\n\tans=((qpow(3,n)-ans*2)%mod+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;//(ll)(1e9 + 7);\n\n\nvoid solve()\n{\n\tll N;\n\tcin >> N;\n\n\tmll sum = 1;\n\tmll a = 1;\n\tREPS(i, 1, N/2 - 1){\n\t\ta *= N-i+1;\n\t\ta /= i;\n\t\ta *= 2;\n\t\tsum += a;\n\t}\n\tcout << POW(mll(3), N) - sum*2 << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n#define rep1(i,n) for (int i = 1; i <= int(n); i++)\n#define repR(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = int(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#ifdef LOCAL\n#define dump(...) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \", my_dmp(#__VA_ARGS__, __VA_ARGS__)\nvoid my_dmp(const char*) { cerr << endl; }\ntemplate <class T, class... U> void my_dmp(const char *s, T const& x, U const& ...y) { const char *o = \"({[\", *e = \"]})\"; for (int i = 0; *s != '\\0'; cerr << *s++) { if (count(o,o+3,*s)) i++; if (count(e,e+3,*s)) i--; if (!i && *s == ',') break; } cerr << \" = \" << x; if (*s == ',') cerr << \", \", s++; my_dmp(s, y...); }\n#else\n#define dump(...)\n#endif\nusing ll = long long;\nusing ld = long double;\n#define int ll\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { os << \"{\"; for (auto const& x : v) os << \" \" << x; return os << \" }\"; }\ntemplate <class T> istream& operator>>(istream& is, vector<T>& v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct my_Init { my_Init() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } my_init;\n\ntemplate <class T, size_t d, class = typename enable_if<(d == 0)>::type> constexpr auto make_v(T const& x = {}) { return x; }\ntemplate <class T, size_t d, class... U, class = typename enable_if<(d > 0)>::type> constexpr auto make_v(size_t n, U... x) { auto val = make_v<T,d-1>(x...); return vector<decltype(val)>(n, move(val)); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\nconst ll INF = (1LL<<62)-1; // ~ 4.6e18\n////////////////////////////////\n//\nusing ll = long long;\ntemplate <int M> // m : prime\nclass modint {\n    ll x;\n    struct Table {\n        static const int Size = 1e6 + 10;\n        static_assert(Size <= M, \"\");\n        ll fac[Size], finv[Size], inv[Size];\n        Table() {\n            fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n            for (int i = 2; i < Size; i++) {\n                fac[i] = fac[i-1]*i % M;\n                inv[i] = M - inv[M%i]*(M/i) % M;\n                finv[i] = finv[i-1]*inv[i] % M;\n            }\n        }\n    };\n    static const Table tab;\npublic:\n    static modint fact(int n) { assert(0 <= n && n < Table::Size); return tab.fac[n]; }\n    static modint finv(int n) { assert(0 <= n && n < Table::Size); return tab.finv[n]; }\n    static modint C(int n, int k) {\n        if (n < 0 || k < 0 || n < k) return 0;\n        return fact(n)*finv(k)*finv(n-k);\n    }\n    static modint P(int n, int k) {\n        assert(n >= 0 && k >= 0 && n >= k);\n        return fact(n)*finv(n-k);\n    }\npublic:\n    modint(ll x = 0) : x((x%=M) < 0 ? x+M : x) { }\n    ll val() const { return x; }\n    bool operator==(modint rhs) const { return x == rhs.x; }\n    bool operator!=(modint rhs) const { return x != rhs.x; }\n    modint operator+() const { return *this; }\n    modint operator-() const { return {M-x}; }\n    modint& operator+=(modint rhs) { if ((x += rhs.x) >= M) x -= M; return *this; }\n    modint& operator-=(modint rhs) { if ((x += M-rhs.x) >= M) x -= M; return *this; }\n    modint& operator*=(modint rhs) { (x *= rhs.x) %= M; return *this; }\n    modint operator+(modint rhs) const { return modint(*this) += rhs; }\n    modint operator-(modint rhs) const { return modint(*this) -= rhs; }\n    modint operator*(modint rhs) const { return modint(*this) *= rhs; }\n    modint& operator/=(modint rhs) { return *this *= rhs.inv(); }\n    modint operator/(modint rhs) const { return *this * rhs.inv(); }\n    modint pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        modint v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n    modint inv() const {\n        assert(x != 0);\n        ll t = 1, v = x, q, r;\n        while (v >= Table::Size) {\n            q = M / v; r = M % v;\n            if (r * 2 < v) {\n                t *= -q; t %= M; v = r;\n            } else {\n                t *= q + 1; t %= M; v -= r;\n            }\n        }\n        return t * tab.inv[v] % M;\n    }\n};\ntemplate <int M> typename modint<M>::Table const modint<M>::tab;\ntemplate <int M> ostream& operator<<(ostream& os, modint<M> rhs) { return os << rhs.val(); }\ntemplate <int M> istream& operator>>(istream& is, modint<M> &rhs) { ll x; is >> x; rhs = x; return is; }\n\nconstexpr int MOD = 998244353;\nusing mint = modint<MOD>;\n//\n\n\nint32_t main() {\n    int n; cin >> n;\n    mint ans = mint(3).pow(n);\n    loop (k,n/2+1,<=n) ans -= mint::C(n,k)*mint(2).pow(n-k+1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\nusing lint = long long;\nconstexpr int MOD = 998244353, INF = 1010101010;\nconstexpr lint LINF = 1LL << 60;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\\n\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\ntemplate<int Modulo = MOD> struct Mint {\n\n\tlint val;\n\tconstexpr Mint(lint v = 0) noexcept : val(v % Modulo) { if (val < 0) v += Modulo; }\n\n\tconstexpr Mint& operator += (const Mint &r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= Modulo) val -= Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -= (const Mint &r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *= (const Mint &r) noexcept {\n\t\tval = val * r.val % Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator /= (const Mint &r) noexcept {\n\t\tlint a = r.val, b = Modulo, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlint t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % Modulo;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint operator + (const Mint &r) const noexcept { return Mint(*this) += r; }\n\tconstexpr Mint operator - (const Mint &r) const noexcept { return Mint(*this) -= r; }\n\tconstexpr Mint operator * (const Mint &r) const noexcept { return Mint(*this) *= r; }\n\tconstexpr Mint operator / (const Mint &r) const noexcept { return Mint(*this) /= r; }\n\n\tconstexpr int getmod() { return Modulo; }\n\tconstexpr Mint operator - () const noexcept { return val ? Modulo - val : 0; }\n\n\tconstexpr bool operator == (const Mint &r) const noexcept { return val == r.val; }\n\tconstexpr bool operator != (const Mint &r) const noexcept { return val != r.val; }\n\n\tfriend ostream &operator << (ostream &os, const Mint<Modulo> &x) noexcept { return os << x.val; }\n\tfriend istream &operator >> (istream &is, Mint<Modulo> &x) noexcept {\n\t\tlint tmp; is >> tmp;\n\t\tx = Mint<Modulo>(tmp);\n\t\treturn is;\n\t}\n\tfriend constexpr Mint<Modulo> modpow(const Mint<Modulo> &a, lint n) noexcept {\n\t\tMint res(1), tmp = a;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nusing mint = Mint<>;\n\ntemplate<class T>\nvector<T> make_vec(size_t s, T val) { return vector<T>(s, val); }\ntemplate<class... Size>\nauto make_vec(size_t s, Size... tail) {\n\treturn vector<decltype(make_vec(tail...))>(s, make_vec(tail...));\n}\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tauto dp = make_vec(N / 2 + 1, 9, mint(0));\n\tdp[1] = { 1,0,1,0,1,1,1,1,1 }; // AA AB AC BA BB BC CA CB CC\n\n\tfor (int i = 1; i < N / 2; i++) {\n\n\t\tmint sum = 0;\n\t\tfor (int j = 0; j < 9; j++) sum += dp[i][j]; // AB BA 以外を後ろにつける\n\t\tfor (int j = 0; j < 9; j++) dp[i + 1][j] += sum;\n\n\t\t// 間に入れてAB BA ができる場合、それはそこまでで後ろにつける操作では実現不可能な並び\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tfor (int k = 0; k < 9; k++) {\n\n\t\t\t\tif (k == 1 || k == 3) continue;\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 || j / 3 * 3 + k / 3 == 3) && (j % 3 + k % 3 * 3 == 1 || j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] += dp[i][j];\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\tDMP(dp);\n\n\tmint ans = 0;\n\tfor (int i = 0; i < 9; i++) ans += dp[N / 2][i];\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc040/submissions/10482076\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n    if(N == 2) return 0;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t}\n    RF[N] = Calc(F[N], MOD - 2);\n    for (int i = N; i > 0; i--) {\n        RF[i - 1] = RF[i] * i % MOD;\n    }\n    long long p2 = Calc(2, N - (N / 2 + 1));\n    long long inv2 = Calc(2, MOD - 2);\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= p2;\n        p2 = p2 * inv2 % MOD;\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define ll long long int\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define INF 0x3f3f3f3f\n#define show(x) cerr<<#x<<\" : \"<<x<<'\\n';\n#define yogeshk972() cerr<<\"\\nTime Taken : \"<<(float)(clock()-time_p)/CLOCKS_PER_SEC<<\"\\n\";\nclock_t time_p=clock();\n \nusing namespace std;\nconst int N=1e7+1, mod= 998244353;\nll fact[N],ifact[N];\n\nll power(int a,int n){\n\tif(n==0) return 1;\n\tll x=power(a,n/2);\n\tx=(x*x)%mod;\n\tif(n&1) return (x*a)%mod;\n\treturn x;\n}\n\nll comb(int n,int r){\n\treturn  ( fact[n]*( ( ifact[r]*ifact[n-r] )%mod)  )%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\tcin.tie(0);\n\t\n\tint n;\n\tcin>>n;\n\t\t\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++)fact[i]=(fact[i-1]*i)%mod;\n\tifact[n]=power(fact[n],mod-2);\n\tfor(int i=n-1;i>=0;i--){\n\t\tifact[i]=(ifact[i+1]*(i+1))%mod;\n\t}\n\t\n\tll r1=0;\n\tfor(int i=n/2+1;i<=n;i++){\n\t\tr1+=( comb(n,i)*power(2,n-i) )%mod;\n\t\tif(r1>=mod)r1-=mod;\n\t}\n\t\n\t\n\tcout<<( power(3,n) -r1*2 + mod*2 )%mod;\n\t\n    yogeshk972();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define itn int\n#define For(i, a, b) for (int i = (a); i <= static_cast<int>(b); i++)\n#define Forr(i, a, b) for (int i = (a); i >= static_cast<int>(b); i--)\n#define rep(i, n) For(i, 0, n - 1)\n#define repall(i, arr) for (auto& i : (arr))\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << '\\n'\n#define dump2(x, y) \\\n    cerr << #x << \" = \" << (x) << \" \" << #y << \" = \" << (y) << '\\n'\n#define SZ(x) ((int)(x).size())\n#define bit(n) (1LL << (n))\nconstexpr int MOD = 998244353;\n\ntemplate <typename T>\nusing pq = priority_queue<T>;\ntemplate <typename T>\nusing pqr = priority_queue<T, vector<T>, greater<T>>;\nconst int INF = LLONG_MAX / 2;\nusing P = pair<int, int>;\nusing vec = vector<int>;\ntemplate <typename T>\nusing mat = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& stream, const pair<T1, T2>& p) { return stream << p.first << \",\" << p.second; }\ntemplate <typename T>\nvoid print(const vector<T> vec) { rep (i, vec.size() - 1) cout << vec[i] << ' '; cout << vec[vec.size() - 1] << '\\n'; }\ntemplate <typename Arg>\nvoid print(const Arg arg) { cout << arg << '\\n'; }\ntemplate <typename Head, typename... Args>\nvoid print(const Head head, const Args... args) { cout << head << \" \"; print(args...); }\ntemplate <typename T, typename U>\nvoid init(vector<T>& v, vector<U>& w) { rep (i, v.size()) cin >> v[i] >> w[i]; }\ntemplate <typename T>\nvoid init(vector<T>& v) { rep (i, v.size()) cin >> v[i]; }\ntemplate <typename T>\nT sum_(vector<T> vec, T init = 0) { return std::accumulate(all(vec), T(init)); }\ntemplate<typename T>\nbool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T>\nbool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T>\nint index(const T& vec, const typename T::iterator it) { return distance(vec.begin(), it); }\ntemplate <typename T = int>\nmat<T> mmat(int n, int m=0) { return mat<T>(n, vector<T>(m)); }\ntemplate <typename T = int>\nvector<T> ivec(int n) { vector<T> v(n); init(v); return v; }\n// clang-format on\n\nvoid yn(bool tf) { print(tf ? \"Yes\" : \"No\"); }\nvoid YN(bool tf) { print(tf ? \"YES\" : \"NO\"); }\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n// -------------------------------------------------------------------\n// sort 1 2 3 4\n// pqr 1 2 3 must impl >\n// need to define MOD\nclass mint {\n    using ll = long long;\n    ll num;\n\npublic:\n    mint(ll x = 0) : num(x % MOD) {}\n    mint operator+=(const mint& x) noexcept {\n        this->num += x.num;\n        if (this->num >= MOD) this->num %= MOD;\n        return *this;\n    }\n    mint operator-=(const mint& x) noexcept {\n        if (this->num < x.num) this->num += MOD;\n        this->num -= x.num;\n        return *this;\n    }\n    mint operator*=(const mint& x) noexcept {\n        this->num = (this->num * x.num) % MOD;\n        return *this;\n    }\n    mint operator/=(mint x) noexcept {\n        ll exp = MOD - 2;\n        while (exp) {\n            if (exp % 2) *this *= x;\n            x *= x;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint operator%=(const mint& x) noexcept {\n        this->num %= x.num;\n        return *this;\n    }\n    mint operator+(const mint& x) const noexcept { return mint(*this) += x; }\n    mint operator-(const mint& x) const noexcept { return mint(*this) -= x; }\n    mint operator*(const mint& x) const noexcept { return mint(*this) *= x; }\n    mint operator/(const mint& x) const noexcept { return mint(*this) /= x; }\n    mint operator%(const mint& x) const noexcept { return mint(*this) %= x; }\n    mint operator&(const mint& x) const noexcept { return this->num & x.num; }\n    bool operator==(const mint& x) const noexcept { return this->num == x.num; }\n    bool operator!=(const mint& x) const noexcept { return not((*this) == x); }\n    explicit operator bool() const noexcept { return this->num != 0; }\n    explicit operator int() const noexcept { return this->num; }\n\n    friend ostream& operator<<(ostream&, const mint&);\n};\n\nostream& operator<<(ostream& stream, const mint& x) { return stream << x.num; }\n\nmint mpow(mint r, mint _n) {\n    mint re = 1;\n    int n = (int)_n;\n    for (; n; n /= 2) {\n        if (n & 1) re *= r;\n        r *= r;\n    }\n    return re;\n}\n\nclass ModuloCombination {\n    using ll = long long;\n    ll mod, len;\n    std::vector<ll> f, rf;\n\n    ll inv(ll x) {\n        ll res = 1;\n        ll k = mod - 2;\n        ll y = x;\n        while (k) {\n            if (k & 1) res = (res * y) % mod;\n            y = y * y % mod;\n            k /= 2;\n        }\n        return res;\n    }\n\npublic:\n    ModuloCombination(ll mod_, ll max_len = 101010)\n        : mod(mod_),\n          len(max_len + 1),\n          f(std::vector<ll>(len)),\n          rf(std::vector<ll>(len)) {\n        f[0] = 1;\n        for (int i = 0; i < len - 1; i++) f[i + 1] = f[i] * (i + 1) % mod;\n        for (int i = 0; i < len; i++) rf[i] = inv(f[i]);\n    }\n    ll c(int n, int k) {\n        if (n < 0 or k < 0 or n - k < 0) {\n            std::cerr << \"(n,k) = \" << n << \" \" << k << std::endl;\n            exit(0);\n        }\n        ll a = f[n];\n        ll b = rf[n - k];\n        ll c = rf[k];\n        ll bc = (b * c) % mod;\n        return (a * bc) % mod;\n    }\n    ll getMod() { return mod; }\n};\n\nsigned main() {\n    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<mint> po(n + 1);\n    po[0] = 1;\n    For(i, 1, n) po[i] = po[i - 1] * 2;\n\n    ModuloCombination comb(MOD, n + 10);\n\n    mint kahan = 0;\n    int over = n / 2 + 1;\n    For(i, over, n) kahan += po[n - i] * comb.c(n, i);\n\n    print(mpow(3, n) - kahan * 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt fact[11000000];\nInt revfact[11000000];\nInt rev[11000000];\n\nvoid init(){\n    Int m = MOD;\n    fact[0] = 1;\n    revfact[0] = 1;\n    rev[0] = 0;\n    rev[1] = 1;\n    for(int i = 1;i < 11000000;i++){\n        fact[i] = fact[i-1] * i % m;\n        if(i>1)rev[i] = MOD / i * (MOD-rev[MOD % i]) % MOD;\n        revfact[i] = revfact[i-1] * rev[i] % MOD;\n    }\n}\n\nInt nCk(Int n, Int k){\n    if(n < k)return 0;\n    return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\nInt ans;\nInt n;\nint main(){\n    init();\n    cin >> n;\n    n /= 2;\n    Int tmp = nCk(2*n, n);\n    Int pow2 = 1;\n    for(Int i = 0;i < n;i++){\n//        cout << ans << \" \" << tmp << endl;\n        ans += nCk(2*n, i) * tmp % MOD;ans %= MOD;\n        tmp += nCk(2*n-i-1,n);\n        tmp += nCk(2*n-i-1,n-i-1);\n        tmp %= MOD;\n        tmp *= rev[2];\n        tmp %= MOD;\n        ans += pow2 * nCk(2*n, 2*n-i);\n        pow2 *= 2;\n        pow2 %= MOD;\n    }\n    ans += nCk(2*n, n) * pow2 % MOD;\n    ans %= MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n#define gc getchar()\n#define pc(x) putchar(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\nusing ll = long long;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 1;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        bi = divmod(bi, i, mod);\n        ans -= 2*bi; //A or B\n        while(ans < 0)\n            ans += mod;\n    }\n    print(ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>() || is_same<T,modint>());\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=10*1000*1007;\nconst ll mod=998244353;\n\nint n;\n\nll sil[nax];\nll odw[nax];\nll pot[nax];\n\nll wyn;\n\nll dziel(ll a, ll b)\n{\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nll kom(int a, int b)\n{\n\tif (b>a || b<0)\n\t\treturn 0;\n\treturn sil[a]*odw[b]%mod*odw[a-b]%mod;\n}\n\nll choc[nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tsil[0]=odw[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tsil[i]=(sil[i-1]*i)%mod;\n\todw[n]=dziel(1, sil[n]);\n\tfor (int i=n-1; i; i--)\n\t\todw[i]=(odw[i+1]*(i+1))%mod;\n\tpot[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tpot[i]=(pot[i-1]*2)%mod;\n\t\n\tfor (int i=n/2; i>=0; i--)\n\t{\n\t\tchoc[i]=kom(n/2, i)*pot[n/2-i]%mod;\n\t\tchoc[i]+=choc[i+1];\n\t\tchoc[i]%=mod;\n\t}\n\tll odj=1;\n\tfor (int i=1; i<=n; i++)\n\t\todj=(odj*3)%mod;\n\tfor (int i=0; i<=n/2; i++)\n\t{\n\t\tll jed=pot[i]*kom(n/2, i)%mod;\n\t\twyn=(wyn+jed*choc[i+1]%mod)%mod;\n\t}\n\t\n\t//~ for (int i=(n+1)/2; i<=n; i++)\n\t//~ {\n\t\t//~ ll ter=sil[n]*odw[i]%mod*odw[n-i]%mod*pot[n-i]%mod;\n\t\t//~ wyn=(wyn+ter)%mod;\n\t//~ }\n\t\n\tdebug() << odj << \" \" << wyn;\n\tprintf(\"%lld\\n\", (odj-wyn*2%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll poc(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nll gya[5000010];\nll kai[5000010];\nvoid nckinit(ll n,ll md){\n  kai[0]=1;\n  kai[1]=1;\n  for(int i=2;i<=n;i++){\n    kai[i]=kai[i-1]*i;\n    kai[i]%=md;\n  }\n  gya[n]=gyaku(kai[n],md);\n  for(int i=n-1;i>=1;i--){\n    gya[i]=gya[i+1]*(i+1);\n    gya[i]%=md;\n  }\n  gya[0]=1;\n}\nll nck(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0||n==k)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  ret*=gya[k];\n  ret%=md;\n  return ret;\n}\nll npk(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n;cin>>n;\n    nckinit(n/2+1,mod2);\n    ll ans=beki(3,n,mod2);\n    ll sum=0;\n    rep(i,1,n/2+1){\n        (sum+=nck(n/2,n/2-i+1,mod2)*beki(2,n/2-(n/2-i+1),mod2))%=mod2;\n        ll summ=nck(n/2,i,mod2)*beki(2,n/2-i,mod2)%mod2;\n        //cout<<sum<<\" \"<<summ<<endl;\n        (summ*=2*sum)%=mod2;\n        (ans+=-summ+mod2)%=mod2;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <ctime>\n#include <utility>\n#include <fstream>\n#include <queue>\n#include <deque>\n \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC optimize(\"vpt\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment(linker, \"/STACK:256000000\")\n#pragma warning(disable:4996)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ld pi = 3.14159265358979323846264;\nconst char el = '\\n';\n//const int inf = 1000'000'000;\n \n#define forn(i, n) for (int i = 0; i < (int)n; ++i)\n#define firn(i, n) for (int i = 1; i < (int)n; ++i)\n#define all(v) v.begin(), v.end()\n#define x first\n#define y second\n \ntemplate<typename T> bool uin(T &a, T b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T> bool uax(T &a, T b) { if (b > a) { a = b; return 1; } return 0; }\ntemplate<class iterator> void output(iterator begin, iterator end, char p = ' ', ostream &out = cout) { while (begin != end) { out << (*begin) << p; begin++; } out << el; }\ntemplate<class T> void output(T x, char p = ' ', ostream &out = cout) { output(all(x), p, out); }\n \nmt19937 rnd(time(NULL));\n\n#define int long long\n\nconst int N = 1000 * 1000 + 228;\nconst int MOD = 998244353;\n\nint n;\nint f[N], rf[N];\n\nint mod(int x) {\n    x %= MOD;\n    if (x < 0) x += MOD;\n    return x;\n}\n\nint fp(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mod(res * a);\n        }\n        a = mod(a * a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint C(int n, int k) {\n    return mod(f[n] * mod(rf[k] * rf[n - k]));\n}\n\nint base[N];\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cin >> n;\n    f[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = mod(f[i - 1] * i);\n    }\n    rf[n] = fp(f[n], MOD - 2);\n    for (int i = n - 1; i + 1; --i) {\n        rf[i] = mod(rf[i + 1] * (i + 1));\n    }\n    base[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        base[i] = mod(base[i - 1] * 2);\n    }\n    int res = fp(3, n);\n    for (int A = n / 2 + 1; A <= n; ++A) {\n        res = mod(res - mod(2 * C(n, A) * base[n - A]));\n    }\n    cout << res << '\\n';\n    return 0;\n}\n/*\n<>>><<><<<<<>>><\n0 3 2 1 0 1 2 0 1 2 3 4 5 2 1 0 1\n0 3 2 1 0 1 2 0 1 2 3 4 5 3 2 0 1 \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vvvvll = vector<vector<vector<vector<ll>>>>;\nusing pl4 = pair<ll,ll>;\nusing str = string;\nusing vpl4 = vector<pair<ll,ll>>;\n\n#define sz size()\n#define be begin()\n#define en end()\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\n#define llin(x) ll (x);cin >>(x);\n#define stin(x) str (x);cin >>(x);\n#define vllin(x,n) vll (x)(n);FOR(i,0,n-1){cin >>(x)[i];}\n#define vllin2(a,b,n) vll (a)(n);vll (b)(n);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i];}\n#define vllin3(a,b,c,n) vll (a)(n);vll (b)(n);vll (c)(n);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i]>>(c)[i];}\n#define vlling(x,n) (x).assign(n,0);FOR(i,0,n-1){cin >>(x)[i];}\n#define vlling2(a,b,n) (a).assign(n,0);(b).assign(n,0);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i];}\n#define vlling3(a,b,c,n) (a).assign(n,0);(b).assign(n,0);(c).assign(n,0);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i]>>(c)[i];}\n#define vpl4in(x,n) vpl4 (x)((n),mp(0,0));FOR(i,0,n-1){cin >>x[i].fi>>x[i].se;}\n#define FOR(i,a,b) for(ll i = a ; i <= b ; i++)\n#define rFOR(i,b,a) for(ll i = a; i >= b ; i--)\n#define SORT(x) sort(x.be, x.en)\n#define rSORT(x) sort(x.rbegin(), x.rend())\n#define say(x) cout<<(x);\n#define sal(x) cout<<(x)<<endl;\n#define says(x) cout<<(x)<<(' ');\n#define sas cout<<(' ');\n#define sayR(x) cout<<fixed<<setprecision(10)<<(x);\n#define salR(x) cout<<fixed<<setprecision(10)<<(x)<<endl;\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<endl;\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define pow(a,b) ll(pow(a,b))\n\nll MOD=998244353;\nll MAX = 5000000;\n\nvll fac(MAX);\nvll finv(MAX);\nvll inv(MAX);\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long com(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nsigned main(){\n    COMinit();\n    llin(n);\n    n=n/2;\n    ll k=1;\n    FOR(i,0,n-1){\n        k=(k*9)%MOD;\n    }\n    vll f(n*2+1,1);\n    FOR(i,1,n*2){\n        f[i]=(f[i-1]*2)%MOD;\n    }\n    vll g(n/2+1,0);\n    g[n/2]=f[n/2]-1;\n    rFOR(i,2,n/2-1){\n        g[i]=(g[i+1]*2-com(n-i-1,i)*2-com(n-i-1,i-1))%MOD;\n    }\n    FOR(i,1,n){\n        if(i-1<n-i){\n            k=(k+MOD-(com(n,i)*f[(n-i)*2]*g[i-1])%MOD)%MOD;\n        }else{\n            k=(k+MOD-(com(n,i)*f[(n-i)*2]*f[n-i])%MOD)%MOD;\n        }\n    }\n    FOR(i,1,n){\n        k=(k+MOD-(com(n,i)*f[(n-i)*2]*f[min(i-1,n-i)])%MOD)%MOD;\n    }\n    sal(k)\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353;\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    mod_build(12345678);\n    int n;\n    cin>>n;\n    ll ans = powmod(3,n);\n    vector<ll> sum(n/2+1);\n    ll p = powmod(2,n/2);\n    rep(i,n/2+1){\n        sum[i]=comb(n/2,i)*p%mod;\n        p*=inv[2];\n        p%=mod;\n    }\n    rep(i,n/2){\n        sum[n/2-i-1]+=sum[n/2-i];\n        sum[n/2-i]%=mod;\n    }\n    ll res = 0;\n    p = powmod(2,n/2);\n    rep(i,n/2+1){\n        if(i==0)continue;\n        res+=comb(n/2,i)*p%mod*sum[n/2+1-i]%mod;\n        p*=inv[2];\n        p%=mod;\n    }\n    cout<<(ans-res%mod+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\nconst int pre[10001] = { 1,777990065,766786010,512513096,705983787,734256002,244148993,533292028,210582481,688517539,215582594,14820617,129246395,150625187,86672976,764239242,21874704,57288446,850657009,774583782,638474417,128284758,786368753,472986042,103549395,495451255,264078536,433635135,625262204,766766525,185226044,35932350,902168850,455715166,218641259,972559028,640480499,206662314,683003246,923831102,876712294,724261094,408525348,763874992,547233394,109140246,300634900,256419515,371584155,276107980,832944090,540250216,893651744,936348937,326512726,516396135,843656716,776879789,359802705,356307409,949283602,121678346,755038370,144825638,398849114,243664371,157125107,752722108,971617941,787502726,951610819,720346213,481304016,361949821,680950950,387120559,575366956,411040690,816984038,668571204,187142323,552289458,722805387,993149209,318238233,904486800,968982693,875054001,578248523,925025550,271818664,509541523,500499768,929802162,849466163,523746388,268604730,311862148,211074478,804711044,373341033,683607517,262864254,899397125,903574757,408123903,570163026,387548298,136310560,757193515,492373922,16092666,218256882,33612616,184219001,645249935,348551228,835533217,302307407,641587141,70007868,840714962,797190974,744571430,180557608,554082240,483244331,924205037,933027896,760946120,890154909,803775227,605185517,868712494,835769462,401208474,689354486,226621123,96687561,38631563,501927483,483249587,593944616,998231222,23528366,842172435,357335185,725982025,398516968,269658881,797725335,59352911,184061655,193546739,303152497,61883255,98078622,195866691,996728981,446353446,796024455,885097692,915829452,732760877,97457057,251606742,829937743,367147609,907175897,989448554,748640136,168580487,42590154,482935433,768160042,31342156,39326209,654029131,72020724,47519485,542991096,876162665,577428803,188685455,233510797,422423143,544780457,613635275,137823240,55715373,97062836,437207675,578565389,794462456,122688768,964014598,148890003,428128959,278232786,996120899,45596018,7163323,387102481,258039391,515773886,830696837,604845763,539553101,384403210,949063076,849317807,630752268,210722610,773591150,869634880,109500248,32144134,224896996,642008315,169507794,283287674,219473392,422410040,174823408,288798151,140807520,497583578,863575707,355648573,272221122,561110485,253470028,580834681,587770974,112220015,850532094,33475427,498807687,317772333,409146882,596316874,331449290,335429501,670238024,900627351,14996190,733198052,307321953,844834750,829096729,400767242,769588955,98032360,560788564,292816061,468314755,983912094,328059458,549942096,45373125,417528165,901294757,895122295,151159745,297548894,203255878,752797429,911093840,496689395,629769991,78939987,459538825,406390137,6879134,257680118,396950159,129807060,715875807,553661506,390811345,191166323,810576750,213045873,942790458,758339094,899444486,309004018,633895784,128589948,937478027,212513874,174345296,62004037,591751261,649329767,366843154,926280101,432150075,354244239,659276328,834980587,136620485,948751335,633318822,299685362,867019421,267600853,697694392,173796099,133939251,167633838,168664055,455355228,509401446,914452079,440577645,29283142,556198383,482874240,923005927,914550501,892014883,550966054,375146890,259320783,391769529,226806694,768163357,300654217,694655521,844638237,661303928,422327106,355635742,489451003,137628974,980318491,361853327,645638169,336599956,688948565,638514939,153383062,889194597,536430068,893849901,923432110,315839722,49382817,516474656,248173708,403609024,833306540,338847731,986694950,790821219,197628535,285108045,285934271,811084650,104964765,243988035,674229619,993956736,147476083,824048109,791673374,111127164,710735456,308066837,815197913,520396119,92412037,174723780,843863210,222304311,70227310,745928328,40367869,201974250,393032085,247592312,302180761,495381981,900779821,42751968,130815209,110950082,445232011,650497384,752109934,369950087,309849396,190399500,497647689,353358328,459852401,546099291,671454973,367352978,623627864,100401244,892602210,941551774,871438080,513287280,28185349,21030930,44275710,449827510,712246343,36889166,383078382,912763782,209588582,66987695,640672435,956971829,371907015,714047850,982424362,437882276,454748600,468777415,226512910,761686008,418711160,679266400,372627958,797779775,242570019,602303606,983737359,585763482,940263818,910024593,182269085,662738675,615426027,638525692,446366139,68263779,710197880,222814184,532876159,24120062,707881939,705340838,809441202,482114351,45768177,722815024,897943079,728188648,339739889,364745005,808452545,151610888,987511783,394592072,407729297,52967962,680043468,502198643,938707127,20993746,222949807,531872391,810935357,892377075,154762272,84787052,486805848,317085134,992754474,195236749,21949307,780187478,413553058,879449557,330880448,81415435,108607930,341779439,784896483,620491631,153641122,534228690,846914883,610414719,232588079,436762323,984600471,75405628,263308959,639543590,265889797,133955315,209305986,554795787,428937595,941877363,184451191,923795936,49525425,312442269,437151206,78919908,325973945,579844487,398204190,422683275,595487166,194914147,918795881,69211505,380683932,530612228,634697067,709623540,897706118,22942978,281839888,735681848,25120123,882619476,174552294,668106640,641839971,777450530,655937896,29612691,76069349,832769992,277055316,877454260,115365802,87835316,262466036,79664056,536236563,425951836,278768863,475769894,90522759,307362605,63204044,648964820,931888706,954449142,938010479,325282066,209053425,396563384,761781696,408508738,591582400,829340326,348639450,905026623,860856448,437296068,435334482,291412970,343673774,828901226,901613695,992541178,920381845,302843711,566172771,736189313,783990843,184030082,33617073,439331499,611136185,574497345,90817591,306143980,945501487,362805859,74284790,641726342,522692857,775884194,549727729,444956677,545075287,892463752,90265520,916637957,178236658,980812214,59569691,932392802,488131279,861287555,954672905,419328334,442819817,357758244,887478702,984290034,939144003,70714661,485961375,177417145,162118962,168070756,174913840,982318186,650727215,846359719,984640166,823933073,243009290,152990121,535790194,842333964,57092875,671223531,933222015,271959156,288003384,421390300,835225795,394537809,243155841,856810726,671154973,919875491,265924126,79436106,994247829,183378915,532312977,641156343,576069340,704676636,14554181,6523850,393621207,962151282,554820476,606567566,540585991,269714976,420527242,902506476,79339328,938346178,906937168,714916297,950663746,924948492,93383124,742471102,96868329,289622464,511596111,892814818,404369049,409642870,925142075,388844266,695178051,924307790,769870823,258352801,37319493,656535362,942160874,643592487,159647979,459668470,339174706,60288630,749230429,137386012,142128101,741523026,932249458,133685955,848166191,971938720,690816329,693509216,256408885,839738215,939641949,589638571,25469448,932714644,275884954,440367728,901736665,872587068,897787042,837977995,499710224,189498332,636546695,512005440,220288536,368285012,522130486,112567128,173590818,787664831,463296900,963431830,585289222,414700630,530772554,520800955,27834666,632926830,108265239,130127802,406984354,885533900,267599206,846568716,925571632,361045177,455835455,631901425,582383970,397418490,902263780,279768062,684207567,555876879,213169731,993545710,281195933,354016936,417452790,325049825,372247494,913454812,229684453,11625560,557539657,158714984,396403031,362573159,559048195,305476857,280520923,172808824,618589023,957745517,507362338,183892698,536827111,136820615,161184916,581288683,788080221,379731237,970234708,512908572,911557655,693532380,75693974,743612959,293425406,460742607,841929891,478466605,131340979,941426392,96506146,734531144,954715348,258071636,267285258,157361051,634098066,847501174,291172701,823316612,287824262,290717927,321615349,597704882,407060168,100064711,40000658,640920375,910618969,5182489,548235654,969546889,238062370,516021134,147732413,370659533,833655840,649202504,283787677,544385077,533215075,245880234,995321109,504089062,527440767,806954080,237670639,972424792,544700093,154025540,542342152,523089929,946800898,320483244,401371823,78384996,62174429,258433535,553295948,127143445,564154450,413488441,991069498,392441240,824132912,514921452,123644879,692841184,618623956,565158616,58529238,150117976,71490068,699156339,333263606,921371650,217507999,741546202,724472787,964898806,817920986,582096713,559153778,903819609,215291535,534168349,488985182,844145821,935050600,371603787,757869745,268970995,792449869,803557966,235112752,659275014,826634010,351488455,176734098,263260251,785552216,299003958,208080760,569058617,360532390,386399723,398762201,33272509,497218769,522181848,976622995,260131094,982778284,77371871,395349740,390214653,531854347,493975992,678229473,574409531,95826270,992726917,458437396,619632461,205161868,549830743,223515902,178482990,310282069,219230309,602291763,929072996,593463923,527802328,636498474,823705589,83857087,778669244,941456377,73301964,898657754,509912480,938900018,435397704,519619493,735044665,265835960,559201172,239826028,312119351,739353209,103208090,135132726,784824707,232832650,736566311,391931702,394509768,469195547,590383266,897215155,458515558,373585170,158729077,952125022,711761227,868405413,226589812,677030475,648757054,454752913,592350159,754968001,137896269,14566430,858673333,60435539,930609495,947940003,321611846,402349796,352034025,951901408,484084529,740021117,952069554,541638394,357815063,74405887,350552020,776016487,155552075,881994814,90947222,26360681,846511130,346814021,447948726,11819857,378653079,716353332,696316282,56457542,302941700,371036503,124047029,390868579,84411314,33882493,204021054,580753084,652653069,601390003,135041016,492401516,817288138,201876905,449498406,264348632,965482620,138310,207110730,107364155,669232095,139014676,180671118,556369147,199407219,671144270,58468077,73314446,890418474,428534311,925456411,262608571,349636135,295201906 };\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = pre[N / 10000];\n\tfor (int i = N / 10000 * 10000 + 1; i <= N % 10000; i++) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll ima = ifac[N2];\n\tll k = modpow(2, N2 - 1);\n\trep(i, N2) {\n\t\tima = ima * (N2 - i) % mod;\n\t\thiku += ima * ifac[N2 - i - 1] % mod * k % mod;\n\t\tk = k * inv2 % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=1e7+5,mod=998244353;\nint n,ret,fact[N],inv[N],pw[N];\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline void init(CI n)\n{\n\tRI i; for (fact[0]=i=1;i<=n;++i) fact[i]=1LL*fact[i-1]*i%mod;\n\tfor (inv[n]=quick_pow(fact[n]),i=n-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tfor (pw[0]=i=1;i<=n;++i) pw[i]=2LL*pw[i-1]%mod;\n}\ninline int C(CI n,CI m)\n{\n\treturn 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),init(n),i=(n>>1)+1;i<=n;++i)\n\tinc(ret,1LL*C(n,i)*pw[n-i+1]%mod);\n\treturn printf(\"%d\",(quick_pow(3,n)-ret+mod)%mod),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod=998244353;\n\nll n;\nll jiecheng[10000010];\n\nll power(ll a,ll b)\n{\n\tll ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t{\n\t\t\tans*=a;\n\t\t\tans%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn ans%mod;\n}\n\nvoid init()\n{\n\tjiecheng[0]=1ll;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tjiecheng[i]=jiecheng[i-1]*i%mod;\n\t}\n}\n\nll C(ll x,ll y)\n{\n\treturn jiecheng[x]/(jiecheng[x-y]*jiecheng[y]%mod);\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tinit();\n\tll ans=power(3ll,n);\n\tfor(ll i=n/2+1;i<=n;i++)\n\t{\n//\t\tif(ans<0) cout<<i<<endl;\n\t\tans-=2ll*C(n,i)%mod*power(2ll,n-i)%mod;\n\t\tif(ans<0) ans=(ans%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=10000010;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\t\n\tmint ans=mint(3).pow(n);\n\tcerr<<n<<endl;\n\tvc<mint> p2(n+1,1);\n\trep(i,n)p2[i+1]=p2[i]*2;\n\trng(i,n/2+1,n+1)\n\t\tans-=choose(n,i)*p2[n-i]*2;\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    finv.assign(n + 1, fact[n].inv());\n    for (int i = n; i > 0; i--) finv[i - 1] = finv[i] * M(i);\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 998244353;\n\nint main() {\n  int n;\n  cin >> n;\n  ModInt::build(n);\n  ModInt u = ModInt(3).pow(n);\n  ModInt c = 0;\n  for (int i = n / 2 + 1; i <= n; i++) {\n    c += ModInt::comb(n, i) * ModInt(2).pow(n - i);\n  }\n  cout << u - c * 2 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e7+5,mod=998244353;\ntypedef long long ll;\nll f[N],invf[N],p[N];\nint n;\nll C(ll n,ll m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    f[0]=p[0]=f[1]=invf[0]=invf[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        f[i]=f[i-1]*i%mod;\n        invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    }\n    for(int i=2;i<N;i++) invf[i]=invf[i]*invf[i-1]%mod;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*2%mod;\n    int n;scanf(\"%d\",&n);\n    ll ans=qpow(3,n),res=0;\n    for(int i=n/2+1;i<=n;i++)\n        res=(res+C(n,i)*p[n-i])%mod;\n    ans=(ans-res*2)%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#define MOD (long)(998244353)\n#define MAX 10000001  // 階乗をいくつまで計算するか\n\nclass modlong;\nvoid computeAll(long n);\nmodlong modComb(long n, long k);\nmodlong modFact(long n);\n\nclass modlong {\n    long val;\n    const long mod = MOD;\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) {\n        while (init < 0) init += mod;  // 0以上であることを保証\n        val = init % mod;\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) {\n        long rr = r;\n        while (rr < 0) rr += mod;  // 0以上であることを保証\n        this->val = rr % mod;\n    }\n\n    //比較\n    bool operator<(const modlong &r) { return this->val < r.val; }\n    bool operator>(const modlong &r) { return this->val > r.val; }\n    bool operator==(const modlong &r) { return this->val == r.val; }\n    bool operator!=(const modlong &r) { return !(*this == r); }\n    bool operator<=(const modlong &r) { return !(*this > r); }\n    bool operator>=(const modlong &r) { return !(*this < r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long aval = (this->val + r.val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong operator-() {\n        long aval = (mod - this->val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long aval = (this->val * r.val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong inv() {\n        if (*this == 1) return modlong(1);\n        if (*this == 0) cerr << \"modlong warning: dividebyzero!!!\" << '\\n';\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > 1) {\n            r = p.val %\n                q.val;  // r.val=p.val / q.val\n                        // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n;\n    }\n    modlong operator/(const modlong &r) {\n        modlong rr = r;\n        return *this * rr.inv();\n    }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n\n    // コンビネーション modCombは少し下に書いてある\n    modlong C(modlong k) { return modComb(this->val, k.val); }\n    modlong fact() { return modFact(this->val); }\n\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n//////      階乗を全て求める -> 二項係数を求める\n\nlong invs[MAX], facts[MAX], finvs[MAX];\nlong listlen = 0;  // invs, facts, finvsの配列長\nvoid computeAll(long n) {\n    if (n >= MAX)\n        cerr << \"modlong error: index out of range in computeAll\" << '\\n';\n    long i;\n    if (listlen == 0) {\n        invs[1] = 1;\n        facts[0] = 1;\n        facts[1] = 1;\n        finvs[0] = 1;\n        finvs[1] = 1;\n        i = 2;\n    } else {\n        i = listlen;\n    }\n    if (n < 2) return;\n    for (; i <= n; i++) {\n        invs[i] = -invs[MOD % i] * (MOD / i) % MOD;\n        facts[i] = facts[i - 1] * i % MOD;\n        finvs[i] = finvs[i - 1] * invs[i] % MOD;\n    }\n    listlen = n + 1;  // 次呼び出すときはn+1以降から再開すれば良い\n}\n// コンビネーション\nmodlong modComb(long n, long k) {\n    if (k < 0 || k > n) return 0;\n    if (k == 0 || k == n) return 1;\n    if (listlen <= n) computeAll(n);  // 毎回足りない分だけ補う\n    return modlong(facts[n]) * finvs[k] * finvs[n - k];\n}\n// 階乗\nmodlong modFact(long n) {\n    if (listlen <= n) computeAll(n);  // 毎回足りない分だけ補う\n    return modlong(facts[n]);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    // modlong dp[n/2+1][3];\n    // fill(dp[0], dp[n/2+1], 0);\n    // dp[0][0] = 1;\n    // for (int i=0; i<n/2; i++) {\n    //     dp[i+1][0] = dp[i][0] * 2;\n    //     dp[i+1][1] = dp[i][0] + dp[i][1] * 3;\n    //     dp[i+1][2] = dp[i][1] + dp[i][2] * 3;\n    // }\n    // cout << modlong(3).pow(n) - (dp[n/2][1] + dp[n/2][2]) * 2 << '\\n';\n    modlong ans = modlong(3).pow(n);\n    for (int i=0; i<n/2; i++) {\n        ans -= modComb(n, i) * modlong(2).pow(i+1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N; re(N);\n    mn ans = mn(3).pow(N);\n    vmn p2(N + 1); p2[0] = 1; FOR (v, 1, sz(p2)) p2[v] = p2[v-1] + p2[v-1];\n    FOR (v, N/2+1, N + 1) {\n        mn sub = mn::ncr(N, v) * p2[N - v];\n        ans -= sub + sub;\n    }\n    ps(ans);\n\n    // did you check N=1? did you mix up N,M?\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair <int,int> ii;\ntypedef long long LL;\n#define pb push_back\nconst int INF = 2147483647;\nconst int MOD = 998244353;\n\nint coef, coef1, coef2, res, i, n;\n\n// rozwiązuje równanie ax=1(%MOD), gdy MOD pierwsze\nint inverse(int a, int n = MOD - 2) {\n    int r = 1;\n    while (n) {\n        if (n % 2) r = (r * 1LL * a) % MOD;\n        a = (a * 1LL * a) % MOD;\n        n >>= 1;\n    }\n    return r;\n}\n\nint main() {\nscanf(\"%d\", &n);\nres = 1;\nfor (i=0;i<n;i++) res = (res * 3LL) % MOD;\ncoef1 = 1;\ncoef2 = 1;\nfor (i=n;i>n/2;i--) {\n\tcoef = (coef1 * 1LL * coef2) % MOD;\n\tres = (res + MOD - coef) % MOD;\n\tres = (res + MOD - coef) % MOD;\n\tcoef1 = (coef1 * 1LL * i) % MOD;\n\tcoef1 = (coef1 * 1LL * inverse(n - i + 1)) % MOD;\n\tcoef2 = (coef2 * 2LL) % MOD;\n}\nprintf(\"%d\\n\", res);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nbool chkmin(A &a, const B &b){\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename A, typename B>\nbool chkmax(A &a, const B &b){\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it) {\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pil = pair<int,ll>;\nusing pli = pair<ll,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ep emplace\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nconst int dx8[] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init=T()):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//并查集\nstruct UnionFind {\n    vi par, sz;\n    int n_tree;\n    explicit UnionFind(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> fact, inv_fact;\n\n    explicit Binom(int n) : fact(n + 1), inv_fact(n + 1) {\n        fact[0] = 1;\n        up (i, 1, n) fact[i] = fact[i - 1] * i;\n        inv_fact[n] = 1 / fact[n];\n        down (i, n, 1) {\n            inv_fact[i - 1] = inv_fact[i] * i;\n        }\n    }\n\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(fact) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return fact[x] * inv_fact[y] * inv_fact[x - y];\n    }\n\n    T get_fact(int n) const {\n        assert(n < SZ(fact));\n        return fact[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N;\n  cin >> N;\n  Mint ans = 0;\n  Mint p = 1, b = 1;\n  rng (i, 0, N / 2) {\n    ans += p * b;\n    p *= 2;\n    b = b * (N - i) / (i + 1);\n  }\n  println(power(Mint(3), N) - 2 * ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n#define rep1(i,n) for (int i = 1; i <= int(n); i++)\n#define repR(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = int(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#ifdef LOCAL\n#define dump(...) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \", my_dmp(#__VA_ARGS__, __VA_ARGS__)\nvoid my_dmp(const char*) { cerr << endl; }\ntemplate <class T, class... U> void my_dmp(const char *s, T const& x, U const& ...y) { const char *o = \"({[\", *e = \"]})\"; for (int i = 0; *s != '\\0'; cerr << *s++) { if (count(o,o+3,*s)) i++; if (count(e,e+3,*s)) i--; if (!i && *s == ',') break; } cerr << \" = \" << x; if (*s == ',') cerr << \", \", s++; my_dmp(s, y...); }\n#else\n#define dump(...)\n#endif\nusing ll = long long;\nusing ld = long double;\n#define int ll\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { os << \"{\"; for (auto const& x : v) os << \" \" << x; return os << \" }\"; }\ntemplate <class T> istream& operator>>(istream& is, vector<T>& v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct my_Init { my_Init() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } my_init;\n\ntemplate <class T, size_t d, class = typename enable_if<(d == 0)>::type> constexpr auto make_v(T const& x = {}) { return x; }\ntemplate <class T, size_t d, class... U, class = typename enable_if<(d > 0)>::type> constexpr auto make_v(size_t n, U... x) { auto val = make_v<T,d-1>(x...); return vector<decltype(val)>(n, move(val)); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\nconst ll INF = (1LL<<62)-1; // ~ 4.6e18\n////////////////////////////////\n//\nusing ll = long long;\ntemplate <int M> // m : prime\nclass modint {\n    ll x;\n    struct Table {\n        // static const int Size = 1e6 + 10;\n        static const int Size = 1e7 + 10;\n        static_assert(Size <= M, \"\");\n        ll fac[Size], finv[Size], inv[Size];\n        Table() {\n            fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n            for (int i = 2; i < Size; i++) {\n                fac[i] = fac[i-1]*i % M;\n                inv[i] = M - inv[M%i]*(M/i) % M;\n                finv[i] = finv[i-1]*inv[i] % M;\n            }\n        }\n    };\n    static const Table tab;\npublic:\n    static modint fact(int n) { assert(0 <= n && n < Table::Size); return tab.fac[n]; }\n    static modint finv(int n) { assert(0 <= n && n < Table::Size); return tab.finv[n]; }\n    static modint C(int n, int k) {\n        if (n < 0 || k < 0 || n < k) return 0;\n        return fact(n)*finv(k)*finv(n-k);\n    }\n    static modint P(int n, int k) {\n        assert(n >= 0 && k >= 0 && n >= k);\n        return fact(n)*finv(n-k);\n    }\npublic:\n    modint(ll x = 0) : x((x%=M) < 0 ? x+M : x) { }\n    ll val() const { return x; }\n    bool operator==(modint rhs) const { return x == rhs.x; }\n    bool operator!=(modint rhs) const { return x != rhs.x; }\n    modint operator+() const { return *this; }\n    modint operator-() const { return {M-x}; }\n    modint& operator+=(modint rhs) { if ((x += rhs.x) >= M) x -= M; return *this; }\n    modint& operator-=(modint rhs) { if ((x += M-rhs.x) >= M) x -= M; return *this; }\n    modint& operator*=(modint rhs) { (x *= rhs.x) %= M; return *this; }\n    modint operator+(modint rhs) const { return modint(*this) += rhs; }\n    modint operator-(modint rhs) const { return modint(*this) -= rhs; }\n    modint operator*(modint rhs) const { return modint(*this) *= rhs; }\n    modint& operator/=(modint rhs) { return *this *= rhs.inv(); }\n    modint operator/(modint rhs) const { return *this * rhs.inv(); }\n    modint pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        modint v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n    modint inv() const {\n        assert(x != 0);\n        ll t = 1, v = x, q, r;\n        while (v >= Table::Size) {\n            q = M / v; r = M % v;\n            if (r * 2 < v) {\n                t *= -q; t %= M; v = r;\n            } else {\n                t *= q + 1; t %= M; v -= r;\n            }\n        }\n        return t * tab.inv[v] % M;\n    }\n};\ntemplate <int M> typename modint<M>::Table const modint<M>::tab;\ntemplate <int M> ostream& operator<<(ostream& os, modint<M> rhs) { return os << rhs.val(); }\ntemplate <int M> istream& operator>>(istream& is, modint<M> &rhs) { ll x; is >> x; rhs = x; return is; }\n\nconstexpr int MOD = 998244353;\nusing mint = modint<MOD>;\n//\n\n\nint32_t main() {\n    int n; cin >> n;\n    mint ans = mint(3).pow(n);\n    loop (k,n/2+1,<=n) ans -= mint::C(n,k)*mint(2).pow(n-k+1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl; \n#define INF 1000000000\n#define mod 1000000007\ntypedef long long ll;\nconst ll LINF = 1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    int n;cin>>n;\n    if(n%2==0){\n        assert(false);\n    }\n    cout<<0<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nusing ll =  long long;\n\nconstexpr ll MOD = 998244353;\nconstexpr int N_MAX = 10000000;\n\nll modpow(ll a, ll t) {\n    ll ret = 1LL;\n    while(t){\n        if(t & 1LL){\n            ret *= a;\n            ret %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        t >>= 1;\n    }\n    return ret;\n}\n\nll fact[N_MAX+1], rfact[N_MAX+1];\n\nll perm(ll n, ll r){\n    return (fact[n] * rfact[r]) % MOD;\n}\n\nll comb(ll n, ll r){\n    return (perm(n, r) * rfact[n-r]) % MOD;\n}\n\nvoid init(ll n){\n    fact[0] = fact[1] = 1;\n    rfact[0] = rfact[1] = 1;\n    for(int i=2;i<=n;++i) {\n        fact[i] = (fact[i-1] * (ll)i) % MOD;\n        rfact[i] = 1;\n        ll k = MOD-2;\n        ll a = fact[i];\n        while(k > 0){\n            if(k & 1){\n                rfact[i] *= a;\n                rfact[i] %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            k  >>= 1;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll n;\n    cin >> n;\n    init(n);\n\n    ll ans = modpow(3LL, n);\n    ll pow_2 = modpow(2LL, n/2);\n    ll r2 = modpow(2LL, MOD-2);\n\n    for(ll i=n/2+1;i<=n;++i) {\n        pow_2 *= r2;\n        pow_2 %= MOD;\n        ans += MOD - (((2 * comb(n, i)) % MOD) * pow_2) % MOD;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//13:14~\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tint n,i;cin>>n;\n\tfla_gya_set(n+3);\n\tmint_base ans=1,rui=fla[n];\n\tfor(i=0;i<n/2;i++){ans*=9;}\n\tfor(i=0;i<n/2;i++){\n\t\trui+=rui;\n\t\tans-=rui*gya[i]*gya[n-i];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int \n#define MOD 998244353\n\nusing namespace std;\n\n\nll modPow(ll x,ll n,ll mod){\n\tll r=1;\n\tx = x%mod;\n\twhile(n){\n\t\tif(n&1)r = (r*x)%mod;\n\t\tx = (x*x)%mod;\n\t\tn = n>>1;\n\t}\n\treturn r;\n}\n\n\n\nll gcd(ll a,ll b,ll &x,ll &y){\n\tif(a==0){\n\t\tx = 0;\n\t\ty = 1;\n\t\treturn b;\n\t}\n\tll x1,y1;\n\tll g = gcd(b%a,a,x1,y1);\n\tx = y1 - (b/a)*x1;\n\ty = x1;\n\treturn g;\n}\n\nvector<ll> sieve(ll n){\n\tll i,j;\n\tll A[n+1]={0};\n\tvector<ll> V;\n\tA[0] = 0;\n\tA[1] = 1;\n\tfor(i=2;i<n;++i){\n\t\tif(A[i]==0)for(j=i;j<n;j+=i)if(A[j]==0)A[j] = i; \n\t}\n\tfor(i=0;i<n;++i){\n\t\tV.push_back(A[i]);\n\t}\n\treturn V;\n}\n\ntemplate <typename T, typename S> \nostream& operator<<(ostream& os, const pair<T, S>& v) \n{\n    os << \"(\"<< v.first << \",\" \n           << v.second << \")\"; \n      \n    return os; \n} \n\n\ntemplate <typename T> \nostream& operator<<(ostream& os, const set<T>& v) \n{ \n    os << \"debug : [\"; \n    for (auto it : v) { \n        os << it; \n        if (it != *v.rbegin()) \n            os << \", \"; \n    } \n    os << \"]\\n\\n\"; \n    return os; \n} \n\ntemplate <typename T> \nostream& operator<<(ostream& os, const vector<T>& v) \n{ \n    os << \"debug : [\"; \n    for (int i = 0; i < v.size(); ++i) { \n        os << v[i]; \n        if (i != v.size() - 1) \n            os << \", \"; \n    } \n    os << \"]\\n\\n\"; \n    return os; \n}\n\ntemplate <typename T, typename S> \nostream& operator<<(ostream& os, const map<T, S>& v) \n{ \n\tos << \"debug : \\n\";\n    for (auto it : v)  \n        os << it.first << \" : \" \n           << it.second << \"\\n\\n\"; \n      \n    return os; \n} \n\n//\t vector<vector<ll> > V(n, vector<ll>(m, 0));\ntemplate <class T>\nvector <vector<T> > mul(vector <vector<T> > &a, vector <vector<T> > &b,ll mod)\n{\n    const int n = a.size();     // a rows\n    const int m = a[0].size();  // a cols\n    const int p = b[0].size();  // b cols\n\n    std::vector <std::vector<T>> c(n, std::vector<T>(p, 0));\n    for (auto j = 0; j < p; ++j)\n    {\n        for (auto k = 0; k < m; ++k)\n        {\n            for (auto i = 0; i < n; ++i)\n            {\n                ll temp = (a[i][k] * b[k][j])%mod;\n                c[i][j] = (c[i][j]+temp)%mod;\n            }\n        }\n    }\n    return c;\n}\n\n\nvector<vector<ll> > modPow(vector<vector<ll> > x,ll n,ll mod){\n\tvector<vector<ll> > r(x.size(), vector<ll> (x.size(),0));\n\tll i,j;\n\tif(x.size()!=x[0].size()){\n\t\tcout<<\"error :: \\n\\n\";\n\t}\n\tfor(i=0;i<x.size();++i)r[i][i]=1;\n\n\twhile(n){\n\t\tif(n&1) r = mul(r,x,mod);\n\t\tx = mul(x,x,mod);\n\t\tn = n>>1;\n\t}\n\treturn r;\n}\n\n//\tNth fibonacci \n// cin>>t;\n// \twhile(t--){\n// \t\tcin>>k;\n// \t\tn = 2;m = 2;\t\n// \t\tvector<vector<ll> > V(n, vector<ll>(m, 0));\n// \t\tV[0][1] = 1;\n// \t\tV[1][1] = V[1][0] = 1;\n\n// \t\tvector<vector<ll> > temp = modPow(V,k,MOD);\n// \t\t// for(auto it:temp)cout<<it;\n// \t\tcout<<temp[1][0]<<\"\\n\";\n// \t}\n\nbool prime(ll n){\n\tif(n==1) return false;\n\tif(n==2) return true;\n\tif(n%2==0)return false;\n\tll r=0,d,i,j,k,l;\n\tl = n-1;\n\twhile(l%2==0){l=l/2;r++;}\n\td = l;\n\tvector<ll> A = {2,3,5,7,11,13,17,19,23};\n\tfor(auto a:A){\n\t\tif(a>n-2) break;\n\t\tll x = modPow(a,d,n);\n\t\tif(x==1||x==n-1) continue;\n\t\tbool test=false;\n\t\tfor(i=0;i<r;++i){\n\t\t\tx = (x*x)%n;\n\t\t\tif(x==n-1){\n\t\t\t\ttest=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(test)\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nbool check(string s){\n\n\tif(s.size()==0)\n\t\treturn true;\n\tll i,j;\n\tbool ans=false;\n\tfor(i=0;i<s.size()-1;++i){\n\t\tif((s[i]=='A'&&s[i+1]=='B')||((s[i]=='B'&&s[i+1]=='A'))){\n\n\t\t}else{\n\t\t\tstring p=\"\";\n\t\t\tfor(j=0;j<s.size();++j){\n\t\t\t\tif(j!=i&&j!=(i+1))p=p+s[j];\n\t\t\t}\n\t\t\tif(check(p))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool check(ll x,ll n){\n\tstring s=\"\";\n\twhile(n--){\n\t\ts = s+ char('A'+x%3);\n\t\tx = x/3;\n\t}\n\t// cout<<s<<\" \"<<check(s)<<\"\\n\";\n\tif(check(s)){\n\t\tcout<<s<<\"\\n\";\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nll count(ll n){\n\tll l=1,r=3;\n\tll x=n;\n\twhile(--n){r=3*r;}\n\tll ans=0;\n\tfor(ll i=0;i<r;++i){\n\t\tif(check(i,x)){\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tll t,i,j,k,l,n,m,x,y,a,b,c,r,q;\n\t// ios_base::sync_with_stdio(false);\n\t// cin.tie(NULL);\n\tcin>>n;\n\tll ans=1,mul=1;\n\tfor(i=1;i<n/2;++i){\n\t\tmul = (mul*2)%MOD;\n\t\tmul = (mul*(n-i+1))%MOD;\n\t\tmul = (mul*modPow(i,MOD-2,MOD))%MOD;\n\t\t// cout<<mul<<\"\\n\";\n\t\tans=(ans+mul)%MOD;\n\t}\n\tans = (2*ans)%MOD;\n\tans = (modPow(3,n,MOD)-ans)%MOD;\n\twhile(ans<0)ans+=MOD;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modPow(long long a, long long p){\n    if(p == 0) return 1;\n    auto res = modPow(a, p/2);\n    res = (res*res)%MOD;\n    if(p%2) res = (res*a)%MOD;\n    return res;\n}\n\nint main(){\n    int N; cin >> N;\n    int maxSize = N+1;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    long long res = modPow(3, N);\n    for(int i=N/2+1;i<=N;i++){\n        res = (res + MOD - 2 * comb(N, i) * modPow(2, N-i) % MOD) % MOD;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\");\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll mod = 998244353LL;\n\n// aのb乗を求める.\nll modpow(ll a, ll b) {\n\tif (a > mod) a %= mod;\n\tif (b == 0LL) return 1LL;\n\tll tmp = modpow(a, b / 2);\n\tif (b & 1LL)\n\t\treturn tmp * tmp % mod * a % mod;\n\treturn tmp * tmp % mod;\n}\n\n// aの逆元を求める.\nll inverse(ll a) {\n\treturn modpow(a, mod - 2);\n}\n\n// kの階乗を計算する.(sgnを0以外に設定すると逆元を返す)\nll fact(ll k, int sgn = 0) {\n\tstatic vector<ll> fac(1, 1LL); // fac[i] := i!\n\tstatic vector<ll> inv(1, 1LL); // inv[i] := i!の逆元\n\tstatic ll nx = 1LL;\n\twhile (nx <= k) {\n\t\tfac.push_back(fac[nx - 1] * nx % mod);\n\t\tinv.push_back(inv[nx - 1] * inverse(nx) % mod);\n\t\t++nx;\n\t}\n\tif (sgn == 0)\n\t\treturn fac[k];\n\treturn inv[k];\n}\n\n// aCbを計算する.\nll comb(ll a, ll b) {\n\tif (b < 0 || b > a) return 0;\n\treturn fact(a) * fact(b, 1) % mod * fact(a - b, 1) % mod;\n}\n\nsigned main() {\n\tll n; cin >> n;\n\tll ans = modpow(3, n);\n\tfor (ll i = (n / 2) + 1; i <= n; ++i) {\n\t\tans -= modpow(2, n - i) * comb(n, i) % mod * 2 % mod;\n\t\tans += mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n///////////////////////////////////////////\nconst long long int INF = 1LL<<60;\nconst long long int Mod = 1000000007;\nusing ll = long long int; using ci = const int;\nusing vi = vector<int>;  using Vi = vector<long long int>;\nusing P = pair<int, int>;  using PLL = pair<ll, ll>;\nusing matrix = vector<vector<ll>>;\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define all(x) (x).begin(),(x).end()\n#define rp(i,N) for(ll i = 0; i < (ll)N; i++)\n#define repi(i,a,b) for(ll i = ll(a); i < ll(b); ++i)\ntemplate<class T>bool chmax(T &former, const T &b) { if (former<b) { former=b; return true; } return false; }\ntemplate<class T>bool chmin(T &former, const T &b) { if (b<former) { former=b; return true; } return false; }\ntemplate<class T>T sqar(T x){ return x*x; }//sqrt(x)は平方根;\n#define Sort(v) std::sort(v.begin(), v.end(), std::greater<decltype(v[0])>()) //降順でVをソート\n#define p_queue(v) priority_queue<v, vector<v>, greater<v> >\ntemplate<class T> inline void princ(T x){cout<<x<<\" \";}; \ntemplate<class T> inline void print(T x){cout<<x<<\"\\n\";};\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\n///////////////////////////////////////////////////////////////////////////////////\nconst ll MOD=998244353;\nll pow(ll x,ll y,ll mod){\n    if(y==0) return 1;\n    if(y&1) return x*pow(x,y-1,mod)%mod;\n    ll p=pow(x,y/2,mod);\n    return p*p%mod;\n}\nconst ll MAX = 10000001;\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    std::cout<<std::fixed<<std::setprecision(30);\n    ll n;\n    cin >> n;\n    ll ans=pow(3,n,MOD);\n    ll sub=0;\n    COMinit();\n    repi(i,1,(n+1)/2+1){\n        ll a=COM(n,n/2+i);\n        a *= pow(2,n-n/2-i,MOD);\n        a%=MOD;\n        sub+=a;\n        sub%=MOD;\n    }\n    ans+=3*MOD;\n    ans-=2*sub;\n    ans%=MOD;\n    print(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n\n#define gc getchar_unlocked()\n#define pc(x) putchar_unlocked(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing ll = long long;\nusing T = ll;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nT exgcd(T a, T b, T &x, T &y){\n    if(a == 0){\n        x = 0, y = 1;\n        return b;\n    }\n    T x1, y1;\n    T d = exgcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 2;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        ll inv, z;\n        exgcd(i, mod, inv, z);\n        if(inv < mod) inv += mod;\n        bi = bi*inv%mod;\n        \n        ans -= bi; //A or B\n        if(ans < 0)\n            ans += mod;\n    }\n    print(ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n#include <random>\n#include <functional>\n#include <stack>\n#include <iomanip>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nconst long long MOD = 1e9+7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ll> pdl;\ntypedef pair<ld, ld> pdd;\n//typedef boost::multiprecision::cpp_int bigint;\n\n//拡張拡張Euclidの互除法による(階乗)逆元の求め方\n//O(N)\nvoid stairs(long long N, vector<long long>& st, long long mod = 1e9 + 7) {\n\tst.resize(N + 1, 1);\n\tfor (long long n = 2; n <= N; n++) {\n\t\tst[n] = (st[n - 1] * n) % mod;\n\t}\n}\n\nvoid modinvs(long long N, vector<long long>& inv, vector<long long>& sinv, long long mod = 1e9 + 7) {\n\tinv.resize(N + 1);\n\tsinv.resize(N + 1);\n\tinv[1] = 1;\n\tsinv[0] = 1;\n\tsinv[1] = 1;\n\tfor (int n = 2; n <= N; n++) {\n\t\tinv[n] = mod - (inv[mod % n] * (mod / n)) % mod;\n\t\tsinv[n] = (sinv[n - 1] * inv[n]) % mod;\n\t}\n}\n\nlong long Comb(long long n, long long k, vector<long long>& st, vector<long long>& sinv, long long mod = 1e9 + 7) {\n\tlong long ans = st[n];\n\tans = (ans * sinv[n - k]) % mod;\n\tans = (ans * sinv[k]) % mod;\n\treturn ans;\n}\n\nll N;\nvector<ll> stair, inv, sinv;\nvector<ll> pows3,pows2;\n\nint main() {\n\tcin >> N;\n\tstairs(N, stair, 998244353);\n\tmodinvs(N, inv, sinv, 998244353);\n\tll temp = 0;\n\tll mod = 998244353;\n\tpows3.resize(N + 1);\n\tpows3[0] = 1;\n\tfor (ll n = 1; n <= N; n++) {\n\t\tpows3[n] = (pows3[n - 1] * 3) % mod;\n\t}\n\tpows2.resize(N + 1);\n\tpows2[0] = 1;\n\tfor (ll n = 1; n <= N; n++) {\n\t\tpows2[n] = (pows2[n - 1] * 2) % mod;\n\t}\n\tll ans = pows3[N];\n\tfor (ll k = N / 2+1; k <= N; k++) {\n\t\tll comb = Comb(N, k, stair, sinv, mod);\n\t\tcomb = (2 * comb * pows2[N - k]) % mod;\n\t\ttemp = (temp + comb) % mod;\n\t}\n\tans = (ans - temp) % mod;\n\tans = (ans + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\nconst int pre[10001] = { 1,777990065,766786010,512513096,705983787,734256002,244148993,533292028,210582481,688517539,215582594,14820617,129246395,150625187,86672976,764239242,21874704,57288446,850657009,774583782,638474417,128284758,786368753,472986042,103549395,495451255,264078536,433635135,625262204,766766525,185226044,35932350,902168850,455715166,218641259,972559028,640480499,206662314,683003246,923831102,876712294,724261094,408525348,763874992,547233394,109140246,300634900,256419515,371584155,276107980,832944090,540250216,893651744,936348937,326512726,516396135,843656716,776879789,359802705,356307409,949283602,121678346,755038370,144825638,398849114,243664371,157125107,752722108,971617941,787502726,951610819,720346213,481304016,361949821,680950950,387120559,575366956,411040690,816984038,668571204,187142323,552289458,722805387,993149209,318238233,904486800,968982693,875054001,578248523,925025550,271818664,509541523,500499768,929802162,849466163,523746388,268604730,311862148,211074478,804711044,373341033,683607517,262864254,899397125,903574757,408123903,570163026,387548298,136310560,757193515,492373922,16092666,218256882,33612616,184219001,645249935,348551228,835533217,302307407,641587141,70007868,840714962,797190974,744571430,180557608,554082240,483244331,924205037,933027896,760946120,890154909,803775227,605185517,868712494,835769462,401208474,689354486,226621123,96687561,38631563,501927483,483249587,593944616,998231222,23528366,842172435,357335185,725982025,398516968,269658881,797725335,59352911,184061655,193546739,303152497,61883255,98078622,195866691,996728981,446353446,796024455,885097692,915829452,732760877,97457057,251606742,829937743,367147609,907175897,989448554,748640136,168580487,42590154,482935433,768160042,31342156,39326209,654029131,72020724,47519485,542991096,876162665,577428803,188685455,233510797,422423143,544780457,613635275,137823240,55715373,97062836,437207675,578565389,794462456,122688768,964014598,148890003,428128959,278232786,996120899,45596018,7163323,387102481,258039391,515773886,830696837,604845763,539553101,384403210,949063076,849317807,630752268,210722610,773591150,869634880,109500248,32144134,224896996,642008315,169507794,283287674,219473392,422410040,174823408,288798151,140807520,497583578,863575707,355648573,272221122,561110485,253470028,580834681,587770974,112220015,850532094,33475427,498807687,317772333,409146882,596316874,331449290,335429501,670238024,900627351,14996190,733198052,307321953,844834750,829096729,400767242,769588955,98032360,560788564,292816061,468314755,983912094,328059458,549942096,45373125,417528165,901294757,895122295,151159745,297548894,203255878,752797429,911093840,496689395,629769991,78939987,459538825,406390137,6879134,257680118,396950159,129807060,715875807,553661506,390811345,191166323,810576750,213045873,942790458,758339094,899444486,309004018,633895784,128589948,937478027,212513874,174345296,62004037,591751261,649329767,366843154,926280101,432150075,354244239,659276328,834980587,136620485,948751335,633318822,299685362,867019421,267600853,697694392,173796099,133939251,167633838,168664055,455355228,509401446,914452079,440577645,29283142,556198383,482874240,923005927,914550501,892014883,550966054,375146890,259320783,391769529,226806694,768163357,300654217,694655521,844638237,661303928,422327106,355635742,489451003,137628974,980318491,361853327,645638169,336599956,688948565,638514939,153383062,889194597,536430068,893849901,923432110,315839722,49382817,516474656,248173708,403609024,833306540,338847731,986694950,790821219,197628535,285108045,285934271,811084650,104964765,243988035,674229619,993956736,147476083,824048109,791673374,111127164,710735456,308066837,815197913,520396119,92412037,174723780,843863210,222304311,70227310,745928328,40367869,201974250,393032085,247592312,302180761,495381981,900779821,42751968,130815209,110950082,445232011,650497384,752109934,369950087,309849396,190399500,497647689,353358328,459852401,546099291,671454973,367352978,623627864,100401244,892602210,941551774,871438080,513287280,28185349,21030930,44275710,449827510,712246343,36889166,383078382,912763782,209588582,66987695,640672435,956971829,371907015,714047850,982424362,437882276,454748600,468777415,226512910,761686008,418711160,679266400,372627958,797779775,242570019,602303606,983737359,585763482,940263818,910024593,182269085,662738675,615426027,638525692,446366139,68263779,710197880,222814184,532876159,24120062,707881939,705340838,809441202,482114351,45768177,722815024,897943079,728188648,339739889,364745005,808452545,151610888,987511783,394592072,407729297,52967962,680043468,502198643,938707127,20993746,222949807,531872391,810935357,892377075,154762272,84787052,486805848,317085134,992754474,195236749,21949307,780187478,413553058,879449557,330880448,81415435,108607930,341779439,784896483,620491631,153641122,534228690,846914883,610414719,232588079,436762323,984600471,75405628,263308959,639543590,265889797,133955315,209305986,554795787,428937595,941877363,184451191,923795936,49525425,312442269,437151206,78919908,325973945,579844487,398204190,422683275,595487166,194914147,918795881,69211505,380683932,530612228,634697067,709623540,897706118,22942978,281839888,735681848,25120123,882619476,174552294,668106640,641839971,777450530,655937896,29612691,76069349,832769992,277055316,877454260,115365802,87835316,262466036,79664056,536236563,425951836,278768863,475769894,90522759,307362605,63204044,648964820,931888706,954449142,938010479,325282066,209053425,396563384,761781696,408508738,591582400,829340326,348639450,905026623,860856448,437296068,435334482,291412970,343673774,828901226,901613695,992541178,920381845,302843711,566172771,736189313,783990843,184030082,33617073,439331499,611136185,574497345,90817591,306143980,945501487,362805859,74284790,641726342,522692857,775884194,549727729,444956677,545075287,892463752,90265520,916637957,178236658,980812214,59569691,932392802,488131279,861287555,954672905,419328334,442819817,357758244,887478702,984290034,939144003,70714661,485961375,177417145,162118962,168070756,174913840,982318186,650727215,846359719,984640166,823933073,243009290,152990121,535790194,842333964,57092875,671223531,933222015,271959156,288003384,421390300,835225795,394537809,243155841,856810726,671154973,919875491,265924126,79436106,994247829,183378915,532312977,641156343,576069340,704676636,14554181,6523850,393621207,962151282,554820476,606567566,540585991,269714976,420527242,902506476,79339328,938346178,906937168,714916297,950663746,924948492,93383124,742471102,96868329,289622464,511596111,892814818,404369049,409642870,925142075,388844266,695178051,924307790,769870823,258352801,37319493,656535362,942160874,643592487,159647979,459668470,339174706,60288630,749230429,137386012,142128101,741523026,932249458,133685955,848166191,971938720,690816329,693509216,256408885,839738215,939641949,589638571,25469448,932714644,275884954,440367728,901736665,872587068,897787042,837977995,499710224,189498332,636546695,512005440,220288536,368285012,522130486,112567128,173590818,787664831,463296900,963431830,585289222,414700630,530772554,520800955,27834666,632926830,108265239,130127802,406984354,885533900,267599206,846568716,925571632,361045177,455835455,631901425,582383970,397418490,902263780,279768062,684207567,555876879,213169731,993545710,281195933,354016936,417452790,325049825,372247494,913454812,229684453,11625560,557539657,158714984,396403031,362573159,559048195,305476857,280520923,172808824,618589023,957745517,507362338,183892698,536827111,136820615,161184916,581288683,788080221,379731237,970234708,512908572,911557655,693532380,75693974,743612959,293425406,460742607,841929891,478466605,131340979,941426392,96506146,734531144,954715348,258071636,267285258,157361051,634098066,847501174,291172701,823316612,287824262,290717927,321615349,597704882,407060168,100064711,40000658,640920375,910618969,5182489,548235654,969546889,238062370,516021134,147732413,370659533,833655840,649202504,283787677,544385077,533215075,245880234,995321109,504089062,527440767,806954080,237670639,972424792,544700093,154025540,542342152,523089929,946800898,320483244,401371823,78384996,62174429,258433535,553295948,127143445,564154450,413488441,991069498,392441240,824132912,514921452,123644879,692841184,618623956,565158616,58529238,150117976,71490068,699156339,333263606,921371650,217507999,741546202,724472787,964898806,817920986,582096713,559153778,903819609,215291535,534168349,488985182,844145821,935050600,371603787,757869745,268970995,792449869,803557966,235112752,659275014,826634010,351488455,176734098,263260251,785552216,299003958,208080760,569058617,360532390,386399723,398762201,33272509,497218769,522181848,976622995,260131094,982778284,77371871,395349740,390214653,531854347,493975992,678229473,574409531,95826270,992726917,458437396,619632461,205161868,549830743,223515902,178482990,310282069,219230309,602291763,929072996,593463923,527802328,636498474,823705589,83857087,778669244,941456377,73301964,898657754,509912480,938900018,435397704,519619493,735044665,265835960,559201172,239826028,312119351,739353209,103208090,135132726,784824707,232832650,736566311,391931702,394509768,469195547,590383266,897215155,458515558,373585170,158729077,952125022,711761227,868405413,226589812,677030475,648757054,454752913,592350159,754968001,137896269,14566430,858673333,60435539,930609495,947940003,321611846,402349796,352034025,951901408,484084529,740021117,952069554,541638394,357815063,74405887,350552020,776016487,155552075,881994814,90947222,26360681,846511130,346814021,447948726,11819857,378653079,716353332,696316282,56457542,302941700,371036503,124047029,390868579,84411314,33882493,204021054,580753084,652653069,601390003,135041016,492401516,817288138,201876905,449498406,264348632,965482620,138310,207110730,107364155,669232095,139014676,180671118,556369147,199407219,671144270,58468077,73314446,890418474,428534311,925456411,262608571,349636135,295201906 };\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = pre[N / 10000];\n\tint n = N / 10000 * 10000;\n\tfor (int i = n + 1; i <= n + N % 10000; i++) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll k = modpow(2, N2 - 1) * ifac[N2] * 2 % mod;\n\trep(i, N2) {\n\t\tk = k * inv2 % mod;\n\t\tk = k * (N2 - i) % mod;\n\t\thiku += ifac[N2 - i - 1] * k % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\nconst int MX = 10000000;\n\nint inv[MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\t\n\tinv[1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tinv[i] = md - (md / i) * 1LL * inv[md % i] % md;\n\t}\n\t\n\tint bad = 0;\n\tfor (int k = 0, c = 1, p = 1; k < n / 2; k++) {\n\t\tbad += p * 1LL * c % md;\n\t\tbad %= md;\n\t\t\n\t\tp *= 2;\n\t\tp %= md;\n\t\t\n\t\tc = c * 1LL * (n - k) % md;\n\t\tc = c * 1LL * inv[k + 1] % md;\n\t}\n\t\n\tint ans = 1;\n\tfor (int i = 0; i < n; i++) ans = (3LL * ans) % md;\n\t\n\tans = (ans - 2 * bad) % md;\n\tif (ans < 0) ans += md;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nconst ll md = 998244353;\nll modpow(ll b, ll e) {\n  ll ans = 1;\n  for (; e; b = b * b % md, e /= 2)\n    if (e & 1) ans = ans * b % md;\n  return ans;\n}\n\nint main() {\n  cin.sync_with_stdio(0); cin.tie(0);\n  cin.exceptions(cin.failbit);\n  ll n;\n  cin>>n;\n\n  int N = n+10;\n  vector<ll> inv(N,1), fac(N, 1), ifac(N, 1);\n  rep(i,2,N) {\n    inv[i] = md - (md / i) * inv[md % i] % md;\n    fac[i] = fac[i-1] * i % md;\n    ifac[i] = ifac[i-1] * inv[i] % md;\n  }\n  auto binom = [&](ll n, ll k) {\n    if(k < 0 || k > n) return 0LL;\n    return fac[n] * ifac[k] % md * ifac[n-k] % md;\n  };\n\n  ll ans = modpow(3, n);\n  rep(i,0,n) {\n    if(2*i <= n) continue;\n    ll cur = modpow(2, n-i) * binom(n,i) % md;\n    ans = (ans - 2*cur + 2*md) %md;\n  }\n\n  ans = (ans-2 + md) % md; // why?\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\ntypedef unsigned  uint;\ntypedef unsigned long long int ull;\ntypedef pair<ll,ll> P;\ntypedef pair<P,long double> Pi;\ntypedef pair <long double,int> Pd;\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=1000000007;\nconst uint mod=998244353;\n//ios_base::sync_with_stdio(false);\n//cin.tie(NULL);\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\nconst ll MAX = 10000001;//設定して\n\nmint fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    for(int i=1;i<MAX;i++)fac[i]=fac[i-1]*i;\n    finv[MAX-1]=fac[MAX-1].inv();\n    for(int i=MAX-2;i>=0;i--)finv[i]=finv[i+1]*(i+1);\n    for(int i=MAX-2;i>=1;i--)inv[i]=finv[i]+fac[i-1];\n}\nmint modpow(mint a, ll n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a;\n        a = a * a ;\n        n >>= 1;\n    }\n    return res;\n}\n// 二項係数計算\nmint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] * finv[n - k];\n}\n\nint main(){\nios::sync_with_stdio(false);\ncin.tie(NULL);\nll n;\ncin>>n;\n COMinit();\n  mint ans=0;\n ans=modpow(3,n);\n mint now=2;\n for(int i=0;i<n/2;i++){\n     ans-=(COM(n,i)*now);\n     now*=2;\n }\n cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 998244353\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\n\nlong long rev(long long k) {\n\tlong long x = MOD - 2;\n\tlong long re = 1;\n\twhile (x > 0) {\n\t\tif (x % 2 == 1) {\n\t\t\tre = (re*k) % MOD;\n\t\t}\n\t\tk = (k*k) % MOD;\n\t\tx /= 2;\n\t}\n\treturn re;\n}\n\n\nint main() {\n\tlong long a[N];\n\tf(i, N)a[i] = 0;\n\tlong long n, k;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%lld\", &n);\n\tn /= 2;\n\tx = 1;\n\tf(i, n)x = (x * 2) % MOD;\n\ty = x;\n\tz = 1;\n\tans = 0;\n\tf(i, n+1) {\n\t\tif (i > 0) {\n\t\t\tx = (x*(n - i + 1)) % MOD;\n\t\t\tx = (x*rev(i)) % MOD;\n\t\t\tx = (x*rev(2)) % MOD;\n\t\t\ty = (x+y) % MOD;\n\t\t\tif (i > 1) {\n\t\t\t\tz = (z*(n - i + 2)) % MOD;\n\t\t\t\tz = (z*rev(i-1)) % MOD;\n\t\t\t\tz = (z * 2) % MOD;\n\t\t\t}\n\t\t\ty = (y - z + MOD) % MOD;\n\t\t}\n\t\ts = ((2 * y) - x + MOD) % MOD;\n\t\ts = (s*x) % MOD;\n\t\tans = (ans + s) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INCANT cin.tie(0), cout.tie(0), ios::sync_with_stdio(false), cout << fixed << setprecision(20);\n#define int long long\n#define gcd __gcd\n#define all(x) (x).begin(), (x).end()\ntemplate<class T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<class T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(...) _overload(__VA_ARGS__, repi, _rep)(__VA_ARGS__)\n#define _rev(i, n) revi(i, n, 0)\n#define revi(i, a, b) for(int i = (int)(a - 1); i >= (int)(b); i--)\n#define rev(...) _overload(__VA_ARGS__, revi, _rev)(__VA_ARGS__)\n#define each(i, n) for(auto&& i: n)\nconst int INF = 1e18, MOD = 998244353;\nint modpow(int a, int n){\n    if(n < 1) return 1;\n    return modpow(a * a % MOD, n / 2) * ((n % 2) ? a : 1) % MOD;\n}\nint modinv(int a){\n    return modpow(a, MOD - 2);\n}\nint modfact(int a){\n    if(a < 2) return 1;\n    return a * modfact(a - 1) % MOD;\n}\nsigned main() {\n    INCANT;\n    int n, fac, inv[11111111], res, tmp = 0, cnt = 1;\n    cin>>n;\n    res = modpow(3, n);\n    fac = modfact(n);\n    inv[n] = modinv(fac);\n    rev(i, n){\n        inv[i] = inv[i + 1] * (i + 1);\n        inv[i] %= MOD;\n    }\n    rep(i, n / 2){\n        tmp += inv[i] * inv[n - i] % MOD * cnt % MOD;\n        tmp %= MOD;\n        cnt *= 2;\n        cnt %= MOD;\n    }\n    tmp = tmp * 2 * fac % MOD;\n    cout<<(res - tmp + MOD) % MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 10000005, P = 998244353;\n\nint n;\nint fac[N], inv[N], pw[N];\n\nint qpow(int a, int b) {\n\tint s = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) {\n\t\t\ts = 1ll * s * a % P;\n\t\t}\n\t\ta = 1ll * a * a % P;\n\t}\n\treturn s;\n}\n\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t}\n\tinv[n] = qpow(fac[n], P - 2);\n\tfor (int i = n; i; --i) {\n\t\tinv[i - 1] = 1ll * inv[i] * i % P;\n\t}\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw[i] = 2ll * pw[i - 1] % P;\n\t}\n}\n\nint C(int n, int m) {\n\tif (m < 0 || m > n) {\n\t\treturn 0;\n\t}\n\treturn 1ll * fac[n] * inv[m] % P * inv[n - m] % P;\n}\n\nint main() {\n\tread(n);\n\tinit(n);\n\tint ans = 0;\n\tfor (int i = n / 2 + 1; i <= n; ++i) {\n\t\tans = (ans + 1ll * pw[n - i] * C(n, i)) % P;\n\t}\n\tans = (qpow(3, n) - 2 * ans) % P;\n\tprint((ans + P) % P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    int n = N / 2;\n    Combination C(n);\n\n    mvec nb(n + 1);\n    REP(i, n + 1) nb[i] = C.nCr(n, i) * pow((mint)2, n - i);\n    IREP(i, n) nb[i] += nb[i + 1];\n\n    mint ans = 0;\n    FOR(i, 1, n + 1){\n        ans += C.nCr(n, i) * pow((mint)2, n - i) * nb[n + 1 - i] * 2;\n    }\n\n    ans = pow((mint)3, N) - ans;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\n\nconst ll md = 998244353;\n\nint main() {\n  cin.sync_with_stdio(0); cin.tie(0);\n  cin.exceptions(cin.failbit);\n  ll n;\n  cin>>n;\n\n  int N = n+10;\n  vector<ll> inv(N,1), fac(N, 1), ifac(N, 1), pw2(N,1), pw3(N,1);\n  rep(i,2,N) {\n    inv[i] = md - (md / i) * inv[md % i] % md;\n    fac[i] = fac[i-1] * i % md;\n    ifac[i] = ifac[i-1] * inv[i] % md;\n    pw2[i-1] = pw2[i-2] * 2 % md;\n    pw3[i-1] = pw3[i-2] * 3 % md;\n  }\n  auto binom = [&](ll n, ll k) {\n    if(k < 0 || k > n) return 0LL;\n    return fac[n] * ifac[k] % md * ifac[n-k] % md;\n  };\n\n  ll ans = pw3[n];\n  rep(i,0,n) {\n    if(2*i <= n) continue;\n    ll cur = pw2[n-i] * binom(n,i) % md;\n    ans = (ans - 2*cur + 2*md) %md;\n  }\n\n  ans = (ans-2 + md) % md; // why?\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=998244353;\n\n#define MAX_N 10000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r-1);\n}\n\n\nll two[10000010];\n\nint main(){\n  setComb();\n  ll N;\n  cin>>N;\n\n  two[0]=1;\n  for(int i=1;i<=N;i++) two[i]=two[i-1]*2%MOD;\n\n  ll minus=0;\n  for(int i=N/2+1;i<=N;i++){\n      ll res=comb(N,i);\n      res=res*two[N-i]%MOD;\n      minus=(minus+res)%MOD;\n  }\n  minus=minus*2%MOD;\n\n  ll ans=1;\n  for(int i=1;i<=N;i++) ans=ans*3%MOD;\n\n  ans=(ans-minus+MOD)%MOD;\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    finv.assign(n + 1, fact[n].inv());\n    for (int i = n; i > 0; i--) finv[i - 1] = finv[i] * M(i);\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 998244353;\n\nint main() {\n  int n;\n  cin >> n;\n  ModInt::build(n);\n  ModInt u = ModInt(3).pow(n);\n  ModInt c = 0;\n  ModInt p = 1;\n  for (int i = n; i > n / 2; i--) {\n    c += ModInt::comb(n, i) * p;\n    p *= 2;\n  }\n  cout << u - c * 2 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n#define modp 998244353\n#define Maxn 10000007\nint power(int a,int b)\n{\n    int res=1,now=a,left=b;\n    while (left>0)\n    {\n        if (left%2==1) res=(1LL*res*now)%modp;\n        left/=2;\n        now=(1LL*now*now)%modp;\n    }\n    return res;\n}\nint bin[Maxn],pre[Maxn],inv[Maxn];\nint calc(int x,int y)\n{\n    int res=(1LL*pre[x]*inv[y])%modp;\n    return (1LL*res*inv[x-y])%modp;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    int ans=0;\n    bin[0]=1;\n    for (int i=1;i<=n;i++)\n        bin[i]=(2LL*bin[i-1])%modp;\n    pre[0]=1;\n    for (int i=1;i<=n;i++)\n        pre[i]=(1LL*pre[i-1]*i)%modp;\n    inv[n]=power(pre[n],modp-2);\n    for (int i=n;i;i--)\n        inv[i-1]=(1LL*inv[i]*i)%modp;\n    for (int i=n/2+1;i<=n;i++)\n        ans=(ans+1LL*calc(n,i)*bin[n-i])%modp;\n    ans=(2LL*ans)%modp;\n    ans=(power(3,n)+modp-ans)%modp;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n/*-------------------------------------------------*/\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(long long x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(long long exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &rhs) { if((val += rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &rhs) { if((val += mod - rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &rhs) { val = static_cast<unsigned long long>(val) * rhs.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n  bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n  bool operator!=(const ModInt &rhs) const { return val != rhs.val; }\n  bool operator<(const ModInt &rhs) const { return val < rhs.val; }\n  bool operator<=(const ModInt &rhs) const { return val <= rhs.val; }\n  bool operator>(const ModInt &rhs) const { return val > rhs.val; }\n  bool operator>=(const ModInt &rhs) const { return val >= rhs.val; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n  friend ostream &operator<<(ostream &os, const ModInt &rhs) { return os << rhs.val; }\n  friend istream &operator>>(istream &is, ModInt &rhs) { long long x; is >> x; rhs = ModInt(x); return is; }\nprivate:\n  ModInt inv() const {\n    // if (__gcd(val, mod) != 1) assert(false);\n    unsigned a = val, b = mod; int x = 1, y = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(x -= tmp * y, y);\n    }\n    return ModInt(x);\n  }\n};\nint abs(const ModInt &x) { return x.val; }\nstruct Combinatorics {\n  int val;\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  int n; cin >> n;\n  Combinatorics com(n);\n  ModInt ans = ModInt(3).pow(n), vio = 0;\n  REP(i, n / 2) vio += com.nCk(n, i) * ModInt(2).pow(i);\n  vio *= 2;\n  ans -= vio;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 10000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nll fac[maxn],inv[maxn],n,k,ans,nw,q,b[maxn];\nconst ll mod=998244353;\n\ninline ll pw(ll a,ll b)\n{\n\tll ans=1,base=a;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=(ans*base)%mod;\n\t\tbase=(base*base)%mod; b>>=1;\n\t}\n\treturn ans;\n}\n\ninline ll C(int N,int M){return (fac[N]*inv[M]%mod)*inv[N-M]%mod;}\n\nint main()\n{\n\tfac[0]=1; inv[0]=1; n=read(); b[0]=1;\n\trep(i,1,(maxn-5)) fac[i]=(fac[i-1]*i)%mod,b[i]=(b[i-1]*2)%mod;\n\trep(i,1,(maxn-5)) inv[i]=pw(fac[i],mod-2); q=pw(3,n); nw=-1;\n\tfor(int i=n/2+1;i<=n;i++)\n\t{\n\t\tll tmp=C(n,i)*b[n-i]; tmp%=mod;\n\t\tans=(ans+tmp+mod)%mod;\n\t}\n\tcout<<(q-(2*ans%mod)+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\n//繰り返し二乗法\nll power(ll a,ll b){\n\tll res=1;\n\twhile(b>0){\n\t\tif(b&1)res=res%mod*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=power(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(5000010);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tll ans=power(3,n);\n\tll res=0;\n\tfor(int i=0;i<n/2;i++){\n\t\tll k=p.comb(n,i);\n\t\t(k*=power(2,i))%=mod;\n\t\t(res+=k)%=mod;\n\t}\n\tcout << (ans-2*res+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(_1, _2 ,_3 ,name, ...) name\n#define re_p(i, n) for(int i = 0; i < (n); ++i)\n#define r_ep(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, r_ep, re_p)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\ntemplate<typename T>\nvector<T> make_v(size_t a, T b){ return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts){\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModInt{\nprivate: using ll = int_fast64_t;\npublic: ll x;\n    inline constexpr ModInt(ll t = 0) noexcept : x((t %= mod) < 0 ? t + mod : t) {}\n    inline constexpr friend istream& operator >> (istream& s, ModInt& m) noexcept {\n        s >> m.x; m.x %= mod; if(m.x < 0)m.x += mod; return s;\n    }\n    inline constexpr friend ostream& operator << (ostream& s, ModInt m) noexcept {\n        return s << m.x;\n    }\n    inline constexpr ModInt operator + (const ModInt m) noexcept { return ModInt(*this) += m; }\n    inline constexpr ModInt& operator += (const ModInt m) noexcept {\n        if((x += m.x) >= mod)x -= mod; return *this;\n    }\n    inline constexpr ModInt operator - (const ModInt m) noexcept { return ModInt(*this) -= m; }\n    inline constexpr ModInt& operator -= (const ModInt m) noexcept {\n        if((x += mod - m.x) >= mod)x -= mod; return *this;\n    }\n    inline constexpr ModInt operator * (const ModInt m) noexcept { return ModInt(*this) *= m; }\n    inline constexpr ModInt& operator *= (const ModInt m) noexcept {\n        x = x * m.x % mod; return *this;\n    }\n    inline constexpr ModInt operator / (const ModInt m) noexcept { return ModInt(*this) /= m; }\n    inline constexpr ModInt& operator /= (const ModInt m) noexcept {\n        return *this *= m.inv();\n    }\n    inline constexpr ModInt inv() const noexcept {\n        ll a = x, b = mod, u = 1, v = 0, t = 0;\n        while(b){ t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u);\n    }\n    inline constexpr ModInt pow(ll p) noexcept {\n        ModInt res(1), mult(*this);\n        for(; p; p >>= 1){ if(p & 1)res *= mult; mult *= mult; }\n        return res;\n    }\n};\n\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModFact{\nprivate:\n    using mint = ModInt<mod>;\n    vector<mint> fact, ifact;\npublic:\n    inline constexpr ModFact(const int sz = 200000) noexcept : fact(sz + 1), ifact(sz + 1) {\n        fact[0] = mint(1);\n        for(int i = 1; i <= sz; ++i)fact[i] = fact[i - 1] * mint(i);\n        ifact[sz] = fact[sz].inv();\n        for(int i = sz; i > 0; --i)ifact[i - 1] = ifact[i] * mint(i);\n    }\n    inline constexpr mint operator [] (const int id) noexcept { return fact[id]; }\n    inline constexpr mint operator () (const int n, const int r) noexcept {\n        return fact[n] * ifact[n - r] * ifact[r];\n    }\n    inline constexpr mint nPr(const int n, const int r) noexcept {\n        return fact[n] * ifact[r];\n    }\n};\n\n// declarations\nusing mint = ModInt<998244353>;\nusing mfact = ModFact<998244353>;\nmfact fac(10000000);\n\n// solve\nint main(){\n\n    int N, N2;\n    cin >> N;\n    N2 = N >> 1;\n\n    mint sum(0), now = mint(2).pow(N), two = mint(2).inv();\n\n    rep(i, 0, N){\n        if(i > N2)sum += now * fac(N, i);\n        now *= two;\n    }\n\n    cout << mint(3).pow(N) - sum * mint(2) << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=10000005,M=998244353;\nint inv[N],fac[N],ans,n,fac2[N];\ninline int ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\t\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n} \nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfac[0]=inv[0]=fac2[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,fac2[i]=fac2[i-1]*2%M;\n\tinv[N-1]=ksm(fac[N-1],M-2);\n\tfor (int i=N-2;i;i--)inv[i]=inv[i+1]*(i+1)%M; \n\tint ans=ksm(3,n);\n\tfor (int i=n/2+1;i<=n;i++)(ans+=M-2*C(n,i)*fac2[n-i]%M)%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int MAXN = 1.01e7;\n\nvll fact (MAXN);\nvll invfact (MAXN);\nvll pow2(MAXN);\nvll inv (MAXN);\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    fact[0] = 1;\n    FOR(i, 1, N+1) fact[i] = fact[i-1] * i % MOD;\n\n    inv[1] = 1;\n    FOR(i, 2, MAXN) inv[i] = (MOD - (MOD/i) * inv[MOD%i] % MOD) % MOD;\n\n    invfact[0] = 1;\n    FOR(i, 1, N+1) invfact[i] = invfact[i-1] * inv[i] % MOD;\n\n    pow2[0] = 1;\n    FOR(i, 1, N+1) pow2[i] = 2 * pow2[i-1] % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * pow2[N-i];\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FR first\n#define SE second\n#define MOD 998244353\n#define inv4 748683265\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nconst int Maxn=5000000+5;\n\nint facd[Maxn],facv[Maxn];\n\nvoid pre(int n) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=(ll)facd[i-1]*i%MOD;\n  facv[n]=pow_mod(facd[n],MOD-2);\n  for(int i=n-1;i>=0;i--) facv[i]=(ll)facv[i+1]*(i+1)%MOD;\n}\n\ninline ll C(int n,int m) {\n  return (n<m)?0:(ll)facd[n]*facv[m]%MOD*facv[n-m]%MOD;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  n>>=1;\n  pre(n);\n  int ans=1;\n  for(int i=1;i<=n;i++) ans=ans*9LL%MOD;\n  ll s1=0,s2=inv4,s3=pow_mod(4LL,n);\n  for(int i=1;i<=n;i++) {\n  \tif (i>1) s1=(s1+(s1-C(i-1,(i-2)>>1)*s2)*4LL)%MOD;\n  \tif (i&1) {\n\t  s2=s2*4LL%MOD;\n\t  s1=(s1+C(i,i>>1)*s2)%MOD;\n    }\n    s3=s3*inv4%MOD;\n    ans=(ans-2LL*s3*C(n,i)%MOD*s1)%MOD;\n  }\n  printf(\"%d\\n\",(ans+MOD)%MOD);\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll mod = 998244353;\n \nll F[10101010], FI[10101010];\nll n, ans;\n \nll inv(ll x) { return x > 1? mod / x * (mod - inv(mod % x)) % mod : 1; }\n \nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tll i, t;\n\t\n\tcin >> n;\n\t\n\tfor(i = 1, F[0] = 1; i <= n; i ++){\n\t\tF[i] = F[i - 1] * i % mod;\n    }\n\t\n\tFI[n] = inv(F[n]);\n\t\n\tfor(i = n, ans = 1; i; i --){\n\t\tFI[i - 1] = FI[i] * i % mod;\n\t\tans = ans * 3 % mod;\n    }\n\t\n\tfor(i = n, t = 2 * F[n] % mod; i + i > n; i --){\n\t\tans = (ans - t * FI[n - i] % mod * FI[i]) % mod;\n\t\tt = t * 2 % mod;\n    }\n\t\n\tcout << (ans + mod) % mod << \"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-12L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n#define int ll\nmodint<MOD> mae[10000001];\nmodint<MOD> gyaku[10000001];\nmodint<MOD> comb(int a, int b) {\n    modint<MOD> ans = mae[a];\n    ans *= gyaku[b];\n    ans *= gyaku[a - b];\n    return ans;\n}\nvoid solve(){\n    int n;\n    cin >> n;\n    mae[0] = 1;\n    gyaku[0] = 1;\n    for (int q = 1; q <= n; ++q) {\n        mae[q] = mae[q - 1] * q;\n        gyaku[q] = modint<MOD>(1) / mae[q];\n    }\n    modint<MOD> mul = 2;\n    modint<MOD> ans = 0;\n    for (int q = n; q > n / 2; --q) {\n        ans += comb(n, q) * mul;\n        mul *= 2LL;\n    }\n    ans = pows<modint<MOD>>(3LL, n) - ans;\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * @Author: RBQRBQ\n * @Date: 2020-04-05 21:40:13\n * @LastEditors: RBQRBQ\n * @LastEditTime: 2020-04-05 22:01:15\n */\n//ac代码 \n#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std; \ntypedef long long ll;\nconst ll maxn =10000000+10;\nconst ll mod=998244353;\ninline ll qpow(ll a, ll n, ll p)  \n{\n    ll ans = 1;\n    while(n)\n    {\n        if(n & 1ll) \n\t\tans = ans * a % p;\n        a = a * a % p;\n        n >>= 1ll;\n    }\n    return ans;\n}\nll A[maxn+10];\nll B[maxn+10];\n\nvoid exPower( int b, int p, int & a, int & k ) {\n    if( p == 0 ) {\n        a = 1; k = 0;\n        return;\n    }\n    exPower( p, b % p, k, a );\n    k -= b / p * a;\n    return;\n} \nint inv( int b, int p ) {\n    int a, k;\n    exPower( b, p, a, k );\n    if( a < 0 ) a += p;\n    return a;\n}\nvoid init( int n ) {\n    A[ 0 ] = 1;\n    for( int i = 1; i <= n; ++i ) A[ i ] = A[ i - 1 ] * i % mod;\n    B[ n ] = inv( A[ n ], mod );\n    for( int i = n - 1; i >= 0; --i ) B[ i ] = B[ i + 1 ] * ( i + 1 ) % mod;\n    return;\n}\ninline ll C(ll a, ll b)\n{\n    if(a < b)\n        return 0;\n    return (A[a] * B[b] %mod)*B[a-b]%mod;\n}\nll mul(ll x,ll y)\n{\n    return (x*y)%mod;\n}\nll add(ll x,ll y)\n{\n    return (x+y>=mod)?x+y-mod:x+y;\n}\nll pre[maxn];\nint  main()\n{\n    int N;\n    cin>>N;\n    ll ans=qpow(3,N,mod);\n    init(maxn);\n    ll pos=0;\n    pre[0]=1ll;\n    for(int i=1;i<=N/2-1;i++)\n    {\n        pre[i]=mul(pre[i-1],2);\n    }\n    for(int i=1;i<=N/2;i++)\n    {\n        //pos=(pos%mod+(qpow(2,(N/2-i),mod)*C(N,N/2+i))%mod)%mod;\n        pos=add(pos,mul(pre[N/2-i],C(N,N/2+i)));\n    }\n    pos=pos*2%mod;\n    cout<<(ans-pos+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0) return 1;\n\telse if(N % 2 == 0) return power(MOD(a * a), N / 2);\n\telse return MOD(a * power(a, N - 1));\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\nint fact(int N){\n\tstatic vector<int> _fact(1, 1);\n\tfor(int i = _fact.size(); i <= N; i++){\n\t\t_fact.push_back(MOD(i * _fact[i - 1]));\n\t}\n\treturn _fact[N];\n}\n \nint fact_inv(int N){\n\tstatic vector<int> inv(2, 1), _fact_inv(2, 1);\n\tfor(int i = inv.size(); i <= N; i++){\n\t\tinv.push_back(MOD(-(p / i) * inv[p % i]));\n\t\t_fact_inv.push_back(MOD(inv[i] * _fact_inv[i - 1]));\n\t}\n\treturn _fact_inv[N];\n}\n \nint combination(int N, int k){\n\tif(k < 0 || N < k || N < 0) return 0;\n\telse return MOD(fact(N) * MOD(fact_inv(N - k) * fact_inv(k)));\n}\n\nsigned main(){\n\tint N, i, ans = 0;\n\tscanf(\"%lld\", &N);\n\tvector<int> pow2(N + 1, 1);\n\tfor(i = 1; i <= N; i++){\n\t\tpow2[i] = MOD(2 * pow2[i - 1]);\n\t}\n\tfor(i = N / 2 + 1; i <= N; i++){\n\t\tans = MOD(ans + combination(N, i) * pow2[N - i]);\n\t}\n\tprintf(\"%lld\\n\", MOD(power(3, N) - 2 * ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define fi first\n#define se second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define y2 azdfsdgwre\n\nvoid dout() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n    cerr << \" \" << H;\n    dout(T...);\n}\n\n#ifdef LOCAL\n    #define dbg(...) cerr << #__VA_ARGS__, dout(__VA_ARGS__)\n#else\n    #define dbg(...) ;\n#endif\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\n\nconst int N = 1e7 + 123, MOD = 998244353;\nint n, fact[N], rev[N];\n\nint binpow(int x, int y) {\n    int res = 1;\n    while (y > 0) {\n        if (y & 1) {\n            res = (ll)res * x % MOD;\n        }\n        x = (ll)x * x % MOD;\n        y /= 2;\n    }\n    return res;\n}\n\nint c(int x, int y) {\n    if (y > x) {\n        return 0;\n    }\n    return ((ll)fact[x] * rev[y] % MOD) * rev[x - y] % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(NULL);\n    #ifdef LOCAL\n        freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    fact[0] = rev[0] = 1;\n    for (int i = 1; i < N; i++) {\n        fact[i] = (ll)fact[i - 1] * i % MOD;\n        rev[i] = (ll)rev[i - 1] * binpow(i, MOD - 2) % MOD;\n    }\n    cin >> n;\n    int res = binpow(3, n);\n    for (int i = n / 2 + 1; i <= n; i++) {\n        res -= (ll)2 * binpow(2, n - i) * c(n, i) % MOD;\n        if (res < 0) {\n            res += MOD;\n        }\n    }\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int mod = 998244353;\nconst int MAX = 10000005;\nconst int V = 100005;\nll dy[8] = {1,0,-1,0,1,-1,1,-1};\nll dx[8] = {0,1,0,-1,1,-1,-1,1};\nconst double pi = acos(-1);\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << endl;}\n\nll modpow(ll x, ll n){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(ll i=2; i<MAX; i++){\n        fac[i] = fac[i-1]*i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\n\n\nll com(ll n, ll k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(){\n    ll n; cin >> n;\n    ll ans = modpow(3,n);\n    comInit();\n    REP(i,n/2+1,n+1){\n        ll t = modpow(2,n-i)*com(n,i)*2;\n        t %= mod;\n        ans -= t;\n        if(ans < 0) ans += mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    long long int N,can=7,n=2,bcan=7;\n    cin >> N;\n    if(N==2){\n        cout << 7 << endl;\n    }else{\n        for(int i=0;i<N/2-1;i++){\n            can = can*9 + n*(1+i);\n            n = n*2 + i-1;\n            can %= 998244353;\n            n %= 998244353;\n        }\n        cout << can << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*author: hyperion_1724\n  date: \n*/\n\n//Optional FAST\n\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n\n//Required Libraries\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\n\n//Required namespaces\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n//Required defines\n\n#define endl '\\n'\n\n#define READ(X) cin>>X;\n#define READV(X) long long X; cin>>X;\n#define READAR(A,N) long long A[N]; for(long long i=0;i<N;i++) {cin>>A[i];}\n#define rz(A,N) A.resize(N);\n#define sz(X) (long long)(X.size())\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define trav(x,A) for(auto &x:A)\n#define FORI(a,b,c) for(long long a=b;a<c;a++)\n#define FORD(a,b,c) for(long long a=b;a>c;a--)\n\n//Required typedefs\n\ntypedef tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef tree<long long,null_type,greater<long long>,rb_tree_tag,tree_order_statistics_node_update> ordered_set1;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\ntypedef vector<int> veci;\ntypedef vector<long long> vecl;\n\n//Required Constants\n\nconst long long inf=(long long)1e18;\nconst long long MOD=(long long)(998244353);\nconst long long INIT=(long long)(1e7+1);\n\n//Required Functions\n\nll power(ll x,ll y) \n{ \n    if (y == 0) \n        return 1; \n    ll p = power(x, y/2) % MOD; \n    p = (p * p) % MOD; \n  \n    return (y%2 == 0)? p : (x * p) % MOD; \n}\nll modInverse(ll a) \n{ \n   return power(a,MOD-2); \n   \n}\n\n//Work\nll fact[INIT]={0};\nint main()\n{\n    \n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    READV(N);\n    ll ans=power(3,N);\n    fact[0]=1;\n    FORI(i,1,N+1)\n    {\n        fact[i]=(fact[i-1]*i)%MOD;\n    }\n    ll sub=0;\n    FORI(i,(N/2)+1,N+1)\n    {\n        sub=(sub+(2*power(2,N-i)*((fact[N]*modInverse((fact[i]*fact[N-i])%MOD)%MOD)))%MOD)%MOD;\n    }\n    ans=(MOD+ans-sub)%MOD;\n    cout<<ans<<endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(5000010);\nvoid solve() {\n\tint n; cin >> n;\n\tint d = n / 2;\n\tvector<ll> ra(d + 2);\n\trep(i, d+1){\n      ll ad=p.comb(d,i)*mod_pow(2,d-i)%mod;\n\t\tra[i + 1] = (ra[i] + ad)%mod;\n\t}\n\tll ans = 0;\n\trep(i, d + 1) {\n\t\tll csum = p.comb(d, i)*(ra[d + 1] - ra[d - i+1]);\n\t\tcsum = (csum%mod + mod) % mod;\n      csum=csum*mod_pow(2,d-i)%mod;\n        //cout<<csum<<endl;\n\t\tans += csum;\n\t}\n\tans = ans * 2 % mod;\n\tll tans = mod_pow(3, n);\n\tans = tans - ans;\n\tif (ans < 0)ans += mod;\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * @Author: RBQRBQ\n * @Date: 2020-04-05 21:40:13\n * @LastEditors: RBQRBQ\n * @LastEditTime: 2020-04-05 21:46:48\n */\n//ac代码 \n#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std; \ntypedef long long ll;\nconst ll maxn =10000000+10;\nconst ll mod=998244353;\ninline ll qpow(ll a, ll n, ll p)  \n{\n    ll ans = 1;\n    while(n)\n    {\n        if(n & 1ll) \n\t\tans = ans * a % p;\n        a = a * a % p;\n        n >>= 1ll;\n    }\n    return ans;\n}\nll A[maxn+10];\nll B[maxn+10];\ninline void Init()\n{\n    A[0] = 1;\n    for(ll i=1; i<=maxn; i++){\n        A[i] = ((A[i-1])* (i) ) % mod;\n    }\n}\ninline ll Ext_Gcd(ll a, ll b, ll &x, ll &y)\n{\n    if(b==0){\n        x=1;\n        y=0;\n        return a;\n    }\n    ll d = Ext_Gcd(b, a%b, y, x);\n    y-=a/b*x;\n    return d;\n}\n \ninline ll Inv(ll a, ll n)\n{\n    ll x,y;\n    ll d = Ext_Gcd(a,n,x,y);\n    if(d == 1)\n        return ((x%n)+n)%n;\n    return -1;\n}\ninline void get()\n{\n    for(ll i=0;i<maxn;i++)\n        B[i] = Inv(A[i],mod);\n}\ninline ll C(ll a, ll b)\n{\n    if(a < b)\n        return 0;\n    return (A[a] * B[b] %mod)*B[a-b]%mod;\n}\n\nint  main()\n{\n    int N;\n    cin>>N;\n    ll ans=qpow(3,N,mod);\n    Init();\n    get();\n    ll pos=0;\n    for(int i=1;i<=N/2;i++)\n    {\n        pos=(pos%mod+(qpow(2,(N/2-i),mod)*C(N,N/2+i))%mod)%mod;\n    }\n    pos=pos*2%mod;\n    cout<<(ans-pos+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nconst int N=1e7+10,mod=998244353;\nint n,mul,sum,fc[N],fi[N];\nint main(){\n\tstd::cin>>n;\n\tfc[0]=fc[1]=fi[0]=fi[1]=mul=1;\n\tfor(int i=2;i<=n;i++)fc[i]=(ll)fc[i-1]*i%mod;\n\tfor(int i=2;i<=n;i++)fi[i]=(ll)(mod-mod/i)*fi[mod%i]%mod;\n\tfor(int i=2;i<=n;i++)fi[i]=(ll)fi[i-1]*fi[i]%mod;\n\tfor(int i=1;i<=n;i++)mul=3ll*mul%mod;\n\tfor(int i=n,s=1;i>=(n>>1)+1;i--,s=(s<<=1)>=mod?s-mod:s){\n\t\tsum=(sum+(ll)fc[n]*fi[i]%mod*fi[n-i]%mod*s)%mod;\n\t\t// std::cerr<<\"> \"<<i<<\" \"<<s<<\" \"<<std::endl;\n\t}\n\t// std::cerr<<mul<<\" \"<<sum<<std::endl;\n\tstd::cout<<((ll)mul+(mod-sum<<1))%mod<<std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 10000010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N;\n\nvoid solve() {\n\tcin >> N;\n\tC_init(N);\n\tll res = mod_pow(3, N);\n\trep(i, N / 2 + 1, N + 1) {\n\t\tADD(res, mod - 2 * mod_pow(2, N - i) * C(N, i) % mod);\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * @Author: RBQRBQ\n * @Date: 2020-04-05 21:40:13\n * @LastEditors: RBQRBQ\n * @LastEditTime: 2020-04-05 21:53:33\n */\n//ac代码 \n#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std; \ntypedef long long ll;\nconst ll maxn =10000000+10;\nconst ll mod=998244353;\ninline ll qpow(ll a, ll n, ll p)  \n{\n    ll ans = 1;\n    while(n)\n    {\n        if(n & 1ll) \n\t\tans = ans * a % p;\n        a = a * a % p;\n        n >>= 1ll;\n    }\n    return ans;\n}\nll A[maxn+10];\nll B[maxn+10];\ninline void Init()\n{\n    A[0] = 1;\n    for(ll i=1; i<=maxn; i++){\n        A[i] = ((A[i-1])* (i) ) % mod;\n    }\n}\ninline ll Ext_Gcd(ll a, ll b, ll &x, ll &y)\n{\n    if(b==0){\n        x=1;\n        y=0;\n        return a;\n    }\n    ll d = Ext_Gcd(b, a%b, y, x);\n    y-=a/b*x;\n    return d;\n}\n \ninline ll Inv(ll a, ll n)\n{\n    ll x,y;\n    ll d = Ext_Gcd(a,n,x,y);\n    if(d == 1)\n        return ((x%n)+n)%n;\n    return -1;\n}\ninline void get()\n{\n    for(ll i=0;i<maxn;i++)\n        B[i] = Inv(A[i],mod);\n}\ninline ll C(ll a, ll b)\n{\n    if(a < b)\n        return 0;\n    return (A[a] * B[b] %mod)*B[a-b]%mod;\n}\nll mul(ll x,ll y)\n{\n    return (x*y)%mod;\n}\nll add(ll x,ll y)\n{\n    return (x+y>=mod)?x+y-mod:x+y;\n}\nint pre[maxn];\nint  main()\n{\n    int N;\n    cin>>N;\n    ll ans=qpow(3,N,mod);\n    Init();\n    get();\n    ll pos=0;\n    pre[0]=1ll;\n    for(int i=1;i<=N/2-1;i++)\n    {\n        pre[i]=mul(pre[i-1],2);\n    }\n    for(int i=1;i<=N/2;i++)\n    {\n        //pos=(pos%mod+(qpow(2,(N/2-i),mod)*C(N,N/2+i))%mod)%mod;\n        pos=add(pos,mul(pre[N/2-i],C(N,N/2+i)));\n    }\n    pos=pos*2%mod;\n    cout<<(ans-pos+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10000005\n#define ll long long\n#define MOD 998244353\nll po[MAX];\nll C[MAX];\nll sum[MAX];\n\nll bigMod(ll a, ll p)\n{\n    if(p == 0) return 1LL;\n    if(p == 1) return a;\n    ll ret = bigMod(a, p/2);\n    ret = (ret*ret)%MOD;\n    if(p & 1) ret = (ret*a)%MOD;\n    return ret;\n}\n\nll dv(ll a, ll b)\n{\n    b = bigMod(b, MOD-2);\n    ll ret = (a*b)%MOD;\n    return ret;\n}\n\nint main()\n{\n    po[0] = 1;\n    for(int i=1; i<MAX; i++){\n        po[i] = (po[i-1]*2)%MOD;\n    }\n    ll n;\n    scanf(\"%lld\", &n);\n    ll m = n/2;\n    C[0] = 1;\n    C[1] = m;\n    for(int i=2; i<=m; i++){\n        C[i] = (C[i-1]*(m-i+1))%MOD;\n        C[i] = dv(C[i], i);\n    }\n    ll tot = 0;\n    for(int i=0; i<=m; i++){\n        tot += (C[i]*po[m-i])%MOD;\n        tot = tot%MOD;\n        sum[i] = tot;\n    }\n    ll ans = 0;\n    for(int i=0; i<=m; i++){\n        ll cur1 = (C[i]*po[m-i])%MOD;\n        ll cur2 = (sum[m]-sum[m-i])%MOD;\n        if(cur2 < 0) cur2 += MOD;\n        ans += (cur1*cur2)%MOD;\n        ans = ans%MOD;\n    }\n    ans = (ans*2)%MOD;\n    ll all = 1;\n    for(int i=1; i<=n; i++){\n        all = (all*3)%MOD;\n    }\n    ans = (all-ans)%MOD;\n    if(ans < 0) ans += MOD;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define mod 998244353\n#define N 10000005\nint n;\nint fac[N], inv[N], mul[N];\nint Pow(int a, int k)\n{\n\tint ret = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tret = (ll)ret * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nint C(int n, int m){return (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[n] = Pow(fac[n], mod - 2);\n\tfor (int i = n; i >= 1; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % mod;\n\tmul[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tmul[i] = (ll)mul[i - 1] * 2 % mod;\n\tint ans = Pow(3, n);\n\tfor (int i = n / 2 + 1; i <= n; i++)\n\t\tans = (ans - 2ll * mul[n - i] * C(n, i)) % mod;\n\tif (ans < 0)ans += mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc040/submissions/10482076\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n    if(N == 2) return;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, N) for (int i = 0; i < (int)N; i++)\nconst ll MOD = 998244353;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,29)-1;\n\nconst int N_MAX = pow(10,7)/2;\n\n// factorial(階乗)の計算\n\nll fac[N_MAX+1] ={};\n\nll c_fac(int n) {\n  if (fac[n]!=0) return fac[n];\n  if (n==0) return fac[n] = 1;\n  return fac[n] = (c_fac(n-1)*n)%MOD;\n}\n\n// inverse(逆元)の計算\n\nll inv(ll a,ll m) {\n  ll b = m, x = 1, y = 0;\n  while (b!=0) {\n    ll d = a/b;\n    a -= b*d; swap(a, b);\n    x -= y*d; swap(x, y);\n  }\n  return x>=0 ? x : x+m;\n}\n\n// combinataionの計算\n\nll nck(ll n, ll k) { \n  if (n<k) return 0;\n  ll nume = fac[n];\n  ll deno = ( inv(fac[n-k],MOD) * inv(fac[k],MOD) ) % MOD;\n  return ( nume * deno ) % MOD;\n}\n\nint main() {\n  int N; cin >> N;\n\n  ll com[N/2] = {}; ll pow2 = 1;\n  c_fac(N/2+1);\n  rep(i,N/2) {\n    com[(N/2-1)-i] = (pow2 * nck(N/2, N/2-i)) % MOD;\n    pow2 = (pow2*2) % MOD;\n  }\n  ll sum[N/2] = {}; rep(i,N/2) sum[i] = (i==0) ? com[(N/2-1)-i] : (sum[i-1] + com[(N/2-1)-i]) % MOD;\n  ll result = 1, tmp = 0; \n  rep(i,N) { result *= 3; result %= MOD; }\n  rep(i,N/2) { tmp += com[i] * sum[i] * 2; tmp %= MOD; }\n  result = ( result - tmp + MOD ) % MOD;\n  cout << result << endl;\n  // rep(i, N/2) cout << com[i] << \" \" << sum[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nlong long *fact, *inv;\n\ntemplate <typename T, typename U, typename V>\nconstexpr auto pow(T x_, U n_, V mod_) {\n    std::common_type_t<T, U, V> ret = 1, x = x_, n = n_, mod = mod_;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nconstexpr auto inverse(T x, U p) { return pow(x, p - 2, p); }\n\nvoid init_factorial(int n, long long mod) {\n    fact = new long long[n + 1];\n    inv = new long long[n + 1];\n    fact[0] = 1;\n    for (long long i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (long long i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nint main() {\n    constexpr i64 mod = 998244353;\n    i64 n;\n    std::cin >> n;\n    i64 m = n / 2;\n    init_factorial(m + 1, mod);\n\n    i64 t = 0, ret = 0;\n    for (int i = 1; i <= m; i++) {\n        t = (t + fact[m] * inv[i - 1] % mod * inv[m - i + 1] % mod * pow(2, i - 1, mod) % mod) % mod;\n        ret = (ret + fact[m] * inv[i] % mod * inv[m - i] % mod * pow(2, m - i, mod) % mod * t % mod) % mod;\n    }\n\n    ret = (pow(3, n, mod) + mod - ret * 2 % mod) % mod;\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph & g, Matrix & scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\ntemplate<typename T>\ninline void bit_reverse(vector<T> & a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n & -n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod - 2, mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long> & input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long> & input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto& x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long> & a, const vector<long long> & b) {\nint result_size = a.size() + b.size() - 1;\nint n = 1; while (n < result_size) n <<= 1;\n\nvector<long long> _a = a, _b = b;\n_a.resize(n, 0);\n_b.resize(n, 0);\n\nntt(_a);\nntt(_b);\nfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\nintt(_a);\n\n_a.resize(result_size);\nreturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\n\t\tret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nint popcount3(int x) {\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0F0F0F0F) + (x >> 4 & 0x0F0F0F0F);\n\tx = (x & 0x00FF00FF) + (x >> 8 & 0x00FF00FF);\n\tx = (x & 0x0000FFFF) + (x >> 16 & 0x0000FFFF);\n\n\treturn x;\n}\n\n\n\nll const mod = 998244353;\n\nint seven[5000010];\nint four[5000010];\nint three[5000010];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\tll n;\n\tcin >> n;\n\tn /= 2;\n\tCombination comb(n, mod);\n\tseven[0] = 1;\n\tfour[0] = 1;\n\tthree[0] = 1;\n\tREP(i, n) {\n\t\tseven[i + 1] = (seven[i] * 7)%mod;\n\t\tfour[i + 1] = (four[i] * 4) % mod;\n\t\tthree[i + 1] = (three[i] * 3) % mod;\n\t}\n\tll ans = 0;\n\n\tREP(i, n / 2 + 1) {\n\t\tll temp = (comb.nCr(n, i) * comb.nCr(n - i, i)) % mod * seven[n - 2 * i] % mod * three[i] % mod * three[i] % mod;\n\n\t\t(ans += temp) %= mod;\n\t}\n\tcout << ans << endl;\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 998244353\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res;\n}\n\n\nll N;\nll fac[10000010],finv[10000010];\n\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r) return 0;\n  else return (fac[n]*finv[n-r]%mod)*finv[r]%mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,10000000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,10000001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N;\n  ll res=mod_pow(3,N);\n  repl(A,(N/2)+1,N+1){\n    ll cnt=comb(N,A)*mod_pow(2,N-A);\n    res=(res-cnt+mod)%mod;\n    res=(res-cnt+mod)%mod;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tchar ch; bool flag = false; res = 0;\n\twhile (ch = getchar(), !isdigit(ch) && ch != '-');\n\tch == '-' ? flag = true : res = ch ^ 48;\n\twhile (ch = getchar(), isdigit(ch))\n\t\tres = res * 10 + ch - 48;\n\tflag ? res = -res : 0;\n}\n\nconst int N = 1e7 + 5;\nconst int mod = 998244353;\nint fra[N], inv[N], ex[N], n;\n\ninline int quick_pow(int x, int k)\n{\n\tint res = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tres = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int &x, int y)\n{\n\tx += y;\n\tx >= mod ? x -= mod : 0;\n}\n\ninline void dec(int &x, int y)\n{\n\tx -= y;\n\tx < 0 ? x += mod : 0;\n}\n\ninline int C(int n, int m)\n{\n\treturn 1ll * fra[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n\tread(n);\n\tfra[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfra[i] = 1ll * fra[i - 1] * i % mod;\n\tinv[n] = quick_pow(fra[n], mod - 2);\n\tfor (int i = n; i >= 1; --i)\n\t\tinv[i - 1] = 1ll * inv[i] * i % mod;\n\tex[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tadd(ex[i] = ex[i - 1], ex[i - 1]);\n\n\tint half = n >> 1, ans = quick_pow(3, n);\n\tfor (int i = half + 1; i <= n; ++i)\n\t\tdec(ans, 2ll * C(n, i) * ex[n - i] % mod);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INCANT cin.tie(0), cout.tie(0), ios::sync_with_stdio(false), cout << fixed << setprecision(20);\n#define int long long\n#define gcd __gcd\n#define all(x) (x).begin(), (x).end()\ntemplate<class T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<class T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(...) _overload(__VA_ARGS__, repi, _rep)(__VA_ARGS__)\n#define _rev(i, n) revi(i, n, 0)\n#define revi(i, a, b) for(int i = (int)(a - 1); i >= (int)(b); i--)\n#define rev(...) _overload(__VA_ARGS__, revi, _rev)(__VA_ARGS__)\n#define each(i, n) for(auto&& i: n)\nconst int INF = 1e18, MOD = 998244353;\nint modpow(int a, int n){\n    if(n < 1) return 1;\n    return modpow(a * a % MOD, n / 2) * ((n % 2) ? a : 1) % MOD;\n}\nint modinv(int a){\n    return modpow(a, MOD - 2);\n}\nint modfact(int a){\n    if(a < 2) return 1;\n    return a * modfact(a - 1) % MOD;\n}\nsigned main() {\n    INCANT;\n    int n, fac, inv[11111111], res, tmp, cnt = 1;\n    cin>>n;\n    res = modpow(3, n);\n    fac = modfact(n);\n    inv[n] = modinv(fac);\n    rev(i, n){\n        inv[i] = inv[i + 1] * (i + 1);\n        inv[i] %= MOD;\n    }\n    tmp = 2 * fac % MOD * (n / 2) % MOD;\n    rep(i, n / 2){\n        tmp += inv[i] * inv[n - i] % MOD * cnt % MOD;\n        tmp %= MOD;\n        cnt *= 2;\n        cnt %= MOD;\n    }\n    cout<<(res - tmp + MOD) % MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<valarray>\n\nusing namespace std;\n\n#define MAX 10000002\n\n#define MOD 998244353\n\n\nint n;\n\nlong long int k[MAX];\nlong long int r[MAX];\n\nlong long int ppow(long long int i,long long int j){\n\tlong long int ret=1;\n\twhile(j){\n\t\tif(j&1LL){\n\t\t\tret*=i;\n\t\t\tif(ret>=MOD)ret%=MOD;\n\t\t}\n\t\ti*=i;\n\t\tif(i>=MOD)i%=MOD;\n\t\tj>>=1LL;\n\t}\n\t//cout<<\"ret \"<<ret<<endl;\n\treturn ret;\n}\nlong long int p2[MAX];\ninline long long int C(int a,int b){\n\tlong long int u=r[b]*r[a-b];\n\tif(u>=MOD)u%=MOD;\n\tu*=k[a];\n\t//cout<<r[b]<<\" \"<<r[a-b]<<\" \"<<k[a]<<endl;\n\tif(u>=MOD)u%=MOD;\n\treturn u;\n}\nint main(){\n\tcin>>n;\n\tk[0]=1;\n\tp2[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tp2[i]=p2[i-1]*2LL;\n\t\tif(p2[i]>=MOD)p2[i]%=MOD;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tk[i]=k[i-1]*i;\n\t\tif(k[i]>=MOD)k[i]%=MOD;\n\t}\n\tr[n]=ppow(k[n],MOD-2);\n\tfor(int i=n-1;i>=0;i--){\n\t\tr[i]=r[i+1]*(i+1);\n\t\tif(r[i]>=MOD)r[i]%=MOD;\n\t}\n\tint ng=n/2+1;\n\tlong long int ans=0;\n\tfor(int i=ng;i<=n;i++){\n\t\t//cout<<n<<\" \"<<i<<\" \"<<C(n,i)<<endl;\n\t\tlong long int w=C(n,i)*p2[n-i];\n\t\tans+=w;\n\t\tif(ans>=MOD)ans%=MOD;\n\t}\n\tans*=2LL;\n\tans%=MOD;\n\tlong long int f=ppow(3,n);\n\tf+=MOD-ans;\n\tf%=MOD;\n\tans=f;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 2100000; i++) fact.push_back(i * fact[i-1]);\n\tfor(num x : fact) ifact.push_back(1 / x);\t\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tp2[i] = 2 * p2[i-1];\n\t}\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * p2[i] * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=10000010;\nint n;\nint fac[N],inv[N],ci[N];\nconst long long mod=998244353;\n\nlong long ksm(long long x,long long t){\n\tlong long tot=1;\n\twhile(t){\n\t\tif(t&1) (tot*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t\tt/=2;\n\t}\n\treturn tot;\n}\n\nlong long C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tlong long tot=0;\n\tfac[0]=ci[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod,ci[i]=ci[i-1]*2%mod;\n\tinv[n]=ksm(fac[n],mod-2);for(int i=n-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tfor(int i=n/2+1;i<=n;i++) tot+=C(n,i)*ci[n-i]%mod;\n\tprintf(\"%lld\\n\",(ksm(3,n)-tot*2%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int MAXN = 1.01e7;\nvll fact (MAXN);\nvll invfact (MAXN);\nvll pow2(MAXN);\nvll inv (MOD);\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    fact[0] = 1;\n    FOR(i, 1, N+1) fact[i] = fact[i-1] * i % MOD;\n\n    inv[1] = 1;\n    FOR(i, 2, MOD) inv[i] = (MOD - (MOD/i) * inv[MOD%i] % MOD) % MOD;\n\n    invfact[0] = 1;\n    FOR(i, 1, N+1) invfact[i] = invfact[i-1] * inv[i] % MOD;\n\n    pow2[0] = 1;\n    FOR(i, 1, N+1) pow2[i] = 2 * pow2[i-1] % MOD;\n\n    \n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * pow2[N-i];\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint mod = 998244353;\nconst int maxn = 1e7 + 5;\nint n;\n\nint fact[maxn];\nint inv[maxn];\n\n\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\n\n\nint quickpow(int a, int b, int mod){\n  int ans = 1 % mod;\n  while(b){\n    if(b & 1)\n      ans = 1ll * ans * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\n\nvoid init(){\n  fact[0] = inv[0] = 1;\n  for(int i = 1; i <= maxn ; i ++){\n    fact[i] = 1ll * fact[i - 1] * i % mod;\n    inv[i] = 1ll * inv[i - 1] * quickpow(i, mod - 2, mod) % mod;\n  }\n}\n\n\nint main()\n{\n  init();\n  n = read();\n  int ans = quickpow(3 ,n, mod) % mod;\n  int x = 0;\n  for(int i = n / 2 + 1; i <= n; i ++){\n    x = (2ll * fact[n] % mod * inv[i] % mod * inv[(n - i)] % mod + x) % mod;\n  }\n  printf(\"%d\\n\",ans -  x );\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 10000005\n#define mod 998244353\nusing namespace std;\n\nlong long fact[maxn], inv[maxn], p2[maxn];\nint n;\n\nlong long get_power(int x, int p) {\n\tif (!p) {\n\t\treturn 1;\n\t}\n\tlong long q = get_power(x, p/2);\n\tq = (q * q) % mod;\n\tif (p & 1) {\n\t\tq = (q * x) % mod;\n\t}\n\treturn q;\n}\n\nlong long binom(int x, int y) {\n\tif (x < y) {\n\t\treturn 0;\n\t}\n\tlong long up = fact[x], down = (inv[y] * inv[x - y]) % mod;\n\treturn up * down % mod;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long ways = get_power(3, n);\n\tlong long exc = 0;\n\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t}\n\tinv[n] = get_power(fact[n], mod - 2);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tinv[i] = (inv[i + 1] * (i + 1)) % mod;\n\t}\n\n\tp2[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tp2[i] = (p2[i - 1] * 2) % mod;\n\t}\n\n\tfor (int i = n/2 + 1; i <= n; i++) {\n\t\texc = (exc + binom(n, i) * p2[n - i]) % mod;\n\t}\n\texc = (exc * 2) % mod;\n\n\tcout << (ways + mod - exc) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pp pair<int,int>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define ll long long\n#define ld long double\n#define all(a) (a).begin(),(a).end()\n#define mk make_pair\nll MOD=1000000007;\nll mod=998244353;\nint inf=1000001000;\nll INF=100000000000000000;\n\nint main() {\n    vector<vector<ll>> a(9,vector<ll>(1e7));\n    a[0][0]=1;a[0][1]=0;a[0][2]=1;a[0][3]=0;a[0][4]=1;\n    a[0][5]=1;a[0][6]=1;a[0][7]=1;a[0][8]=1;\n    rep(i,1e7-1){\n        (a[i+1][0]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][1]+=a[i][3]+a[i][5]+a[i][6]+a[i][8])%=mod;\n        (a[i+1][2]+=a[i][0]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][3]+=+a[i][1]+a[i][2]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][4]+=a[i][0]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][5]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][6]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][7]+=a[i][0]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][8]+=a[i][0]+a[i][1]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n    }\n    int n;\n    cin >> n;\n    n=n/2-1;\n    cout << (a[n][0]+a[n][1]+a[n][2]+a[n][3]+a[n][4]+a[n][5]+a[n][6]+a[n][7]+a[n][8])%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint mod = 998244353;\nconst int maxn = 1e7 + 10;\nint n;\n\nint fact[maxn];\nint inv[maxn];\n\nint quickpow(int a, int b, int mod){\n  int ans = 1 % mod;\n  while(b){\n    if(b & 1)\n      ans = 1ll * ans * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\n\nvoid init(){\n  fact[0] = inv[0] = 1;\n  for(int i = 1; i <= maxn ; i ++){\n    fact[i] = 1ll * fact[i - 1] * i % mod;\n    inv[i] = 1ll * inv[i - 1] * quickpow(i, mod - 2, mod) % mod;\n  }\n}\n\n\nint main()\n{\n  init();\n  scanf(\"%d\",&n);\n  int ans = quickpow(3 ,n, mod) % mod;\n  int x = 0;\n  for(int i = n / 2 + 1; i <= n; i ++){\n    x = (1ll * fact[n] % mod * inv[i] % mod * inv[(n - i)] % mod + x) % mod;\n  }\n  printf(\"%d\\n\",ans - 2ll * x );\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\nusing lint = long long;\nconstexpr int MOD = 998244353, INF = 1010101010;\nconstexpr lint LINF = 1LL << 60;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\\n\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\ntemplate<int Modulo = MOD> struct Mint {\n\n\tlint val;\n\tconstexpr Mint(lint v = 0) noexcept : val(v % Modulo) { if (val < 0) v += Modulo; }\n\n\tconstexpr Mint& operator += (const Mint &r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= Modulo) val -= Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -= (const Mint &r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *= (const Mint &r) noexcept {\n\t\tval = val * r.val % Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator /= (const Mint &r) noexcept {\n\t\tlint a = r.val, b = Modulo, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlint t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % Modulo;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint operator + (const Mint &r) const noexcept { return Mint(*this) += r; }\n\tconstexpr Mint operator - (const Mint &r) const noexcept { return Mint(*this) -= r; }\n\tconstexpr Mint operator * (const Mint &r) const noexcept { return Mint(*this) *= r; }\n\tconstexpr Mint operator / (const Mint &r) const noexcept { return Mint(*this) /= r; }\n\n\tconstexpr int getmod() { return Modulo; }\n\tconstexpr Mint operator - () const noexcept { return val ? Modulo - val : 0; }\n\n\tconstexpr bool operator == (const Mint &r) const noexcept { return val == r.val; }\n\tconstexpr bool operator != (const Mint &r) const noexcept { return val != r.val; }\n\n\tfriend ostream &operator << (ostream &os, const Mint<Modulo> &x) noexcept { return os << x.val; }\n\tfriend istream &operator >> (istream &is, Mint<Modulo> &x) noexcept {\n\t\tlint tmp; is >> tmp;\n\t\tx = Mint<Modulo>(tmp);\n\t\treturn is;\n\t}\n\tfriend constexpr Mint<Modulo> modpow(const Mint<Modulo> &a, lint n) noexcept {\n\t\tMint res(1), tmp = a;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nusing mint = Mint<>;\n\ntemplate<class T>\nvector<T> make_vec(size_t s, T val) { return vector<T>(s, val); }\ntemplate<class... Size>\nauto make_vec(size_t s, Size... tail) {\n\treturn vector<decltype(make_vec(tail...))>(s, make_vec(tail...));\n}\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tauto dp = make_vec(N / 2 + 1, 9, mint(0));\n\tdp[1] = { 1,0,1,0,1,1,1,1,1 }; // AA AB AC BA BB BC CA CB CC\n\n\tfor (int i = 1; i < N / 2; i++) {\n\n\t\tmint sum = 0;\n\t\tfor (int j = 0; j < 9; j++) sum += dp[i][j]; // AB BA 以外を後ろにつける\n\t\tfor (int j = 0; j < 9; j++) dp[i + 1][j] += sum;\n\n\t\t// 間に入れてAB BA ができる場合、それはそこまでで後ろにつける操作では実現不可能な並び\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tfor (int k = 0; k < 9; k++) {\n\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 || j / 3 * 3 + k / 3 == 3) && (j % 3 + k % 3 * 3 == 1 || j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 && j % 3 * 3 + k % 3 == 1) || (j / 3 + k / 3 * 3 == 3 && j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] -= dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//DMP(dp);\n\n\tmint ans = 0;\n\tfor (int i = 0; i < 9; i++) ans += dp[N / 2][i];\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass combination{\nprivate:\n    vector<mint> fact,inv,finv;\npublic:\n    combination(int N){\n        fact = inv = finv = vector<mint>(N+1);\n        fact[0] = fact[1] = 1;\n        inv[0] = inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(ll i=2;i<=N;i++){\n            fact[i] = fact[i-1]*i;\n            inv[i] = (mint) mod - inv[mod%i]*(mod/i);\n            finv[i] = finv[i-1]*inv[i];\n        }\n    }\n    mint f(int i){\n        return fact[i];\n    }\n    mint comb(int n,int k){\n        if(n<k) return 0;\n        if(n<0 || k<0) return 0;\n        return fact[n]*finv[k]*finv[n-k];\n    }\n    mint hcomb(int n,int k){\n        if(n==0 && k==0) return 1;\n        return comb(n+k-1,k);\n    }\n};\n\n\nint main(){\n    int N;\n    cin >> N;\n    mint ans = 1;\n    combination c(N);\n    vector<mint> beki2(N+1,1);\n    for(int i=1;i<=N;i++) beki2[i] = beki2[i-1]*2;\n    for(int i=0;i<N;i++) ans *= 3;\n    for(int i=N/2+1;i<=N;i++) ans -= c.comb(N,i)*beki2[N-i]*2;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef CLASS_MODINT\n#define CLASS_MODINT\n\n#include <cstdint>\n\ntemplate <std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};\n\tstatic constexpr std::uint32_t get_mod() { return mod; }\n\tstd::uint32_t get() const { return n; }\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint inv() const { return (*this).pow(mod - 2); }\n\tmodint pow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n#endif // CLASS_MODINT\n\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nusing mint = modint<998244353>;\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<mint> fact(N + 1), inv(N + 1), factinv(N + 1);\n\tfact[0] = 1, inv[1] = 1, factinv[0] = 1;\n\tfor (int i = 1; i <= N; ++i) fact[i] = fact[i - 1] * i;\n\tfor (int i = 2; i <= N; ++i) inv[i] = inv[mint::get_mod() % i] * mint(-int(mint::get_mod() / i));\n\tfor (int i = 1; i <= N; ++i) factinv[i] = factinv[i - 1] * inv[i];\n\tfunction<mint(int, int)> comb = [&](int x, int y) {\n\t\tif (x < y || y < 0) return mint(0);\n\t\treturn fact[x] * factinv[y] * factinv[x - y];\n\t};\n\tmint ans = 0, sum = mint(2).pow(N / 2);\n\tfor (int i = N / 2; i <= N; ++i) {\n\t\tmint mul = comb(N, i);\n\t\tans += mul * sum;\n\t\tsum *= 2;\n\t\tsum -= comb(i, N / 2);\n\t}\n\tcout << ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e7+10, mod = 998244353;\nint n;\n\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\nint fac[N],ifac[N],pw[N];\ninline void init(int n){\n\tpw[0]=1;\n\tFor(i,1,n) pw[i]=1ll*pw[i-1]*2%mod;\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main(){\n\tn=read(),init(n);\n\tint ans=0;\n\tFOR(i,0,n/2) ans=(ans+2ll*C(n,i)*pw[i])%mod;\n\tprintf(\"%d\\n\",(power(3,n)-ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long\nusing namespace std;\n\nconst ll M = 998244353;\nconst ll N = (ll)(1e7+5);\n\nll fac[N];\nll ifac[N];\n\nll pow(ll b, ll p) {\n  if (!p) return 1;\n  if (p%2) return (b*pow(b,p-1))% M;\n  ll a = pow(b, p/2);\n  return (a*a)%M;\n}\n\nvoid work() {\n  fac[0] = 1;\n  for (ll i = 1; i < N; i++) {\n    fac[i] = (fac[i-1] * i) % M;\n  }\n  ifac[N-1] = pow(fac[N-1], M-2);\n  for (ll i = N-2; i >= 0; i--) {\n    ifac[i] = (ifac[i+1] * (i+1)) % M;\n  }\n}\n\nll nCk(ll n, ll k) {\n  return (((fac[n]*ifac[k]) % M) * ifac[n-k]) % M;\n}\n\n\nint main() {\n  work();\n  ll n;\n  cin >> n;\n\n  ll ret = 0;\n  ll p2 = 1;\n  for (ll i = n; i >= n/2 + 1; i--) {\n    ret = (ret + 2*nCk(n, i) * p2) % M;\n    p2 = (p2+p2)%M;\n  }\n  ret = (pow(3, n) - ret + M) % M;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1e7 + 5, mod = 998244353;\n\nlong long silnia[max_n];\n\nlong long pot(int x, int y){\n    int wynik = 1;\n    while (y){\n        if (y % 2)\n            wynik = (long long)wynik * x % mod;\n        x = (long long) x * x % mod;\n        y /= 2;\n    }\n    return wynik;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    silnia[0] = 1;\n    for (int i = 1; i <= n; i++)\n        silnia[i] = (long long)silnia[i - 1] * i % mod;\n    long long wynik = pot(3, n);\n    for (int i = n / 2 + 1; i <= n; i++)\n        wynik = (wynik -(pot(2, n - i) * 2 * silnia[n] % mod) * pot(silnia[i] * silnia[n - i] % mod, mod - 2) % mod) % mod;\n    if (wynik < 0)\n        wynik += mod;\n    cout << wynik << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static constexpr int MOD = 998244353;\n    ll v;\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint { v } += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint { v } -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint { v } *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint { v } /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res { 1 };\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(modint { 3 }, n);\n    modint cur = { 0 };\n    modint term = { 1 };\n    modint p = { 2 };\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= modint { n - k + 1 };\n        term *= modint { k };\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*powmod((fact[a-b]*fact[b])%MOD, MOD-2)%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += tempPow2*ncr(N, i)%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n  // M inv() const {\n  //   int x, y;\n  //   extgcd(this->v, MOD, x, y);\n  //   return *this + M(x);\n  // }\n\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    finv.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    for (int i = 0; i < n + 1; i++) finv[i] = fact[i].inv();\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 998244353;\n\nint main() {\n  int n;\n  cin >> n;\n  ModInt::build(n);\n  ModInt u = 3;\n  u = u.pow(n);\n  ModInt c = 0;\n  for (int i = n / 2 + 1; i <= n; i++) {\n    ModInt p = 2;\n    c += ModInt::comb(n, i) * p.pow(n - i);\n  }\n  cout << u - c * 2 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N; re(N);\n    mn ans = mn(3).pow(N);\n    FOR (v, N/2+1, N + 1) ans -= 2 * mn::ncr(N, v) * mn(2).pow(N - v);\n    ps(ans);\n\n    // did you check N=1? did you mix up N,M?\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll poc(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nll gya[5000010];\nll kai[5000010];\nvoid nckinit(ll n,ll md){\n  kai[0]=1;\n  kai[1]=1;\n  for(int i=2;i<=n;i++){\n    kai[i]=kai[i-1]*i;\n    kai[i]%=md;\n  }\n  gya[n]=gyaku(kai[n],md);\n  for(int i=n-1;i>=1;i--){\n    gya[i]=gya[i+1]*(i+1);\n    gya[i]%=md;\n  }\n  gya[0]=1;\n}\nll nck(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0||n==k)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  ret*=gya[k];\n  ret%=md;\n  return ret;\n}\nll npk(ll n,ll k,ll md){\n  if(k<0)return 0;\n  if(k==0)return 1;\n  ll ret=kai[n];\n  ret*=gya[n-k];\n  ret%=md;\n  return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n;cin>>n;\n    nckinit(n/2+1,mod2);\n    ll ans=beki(3,n,mod2);\n    ll sum=0;\n    ll now1=1,now2=beki(2,n/2-1,mod2);\n    ll gn=gyaku(2,mod2);\n    rep(i,1,n/2+1){\n        (sum+=nck(n/2,n/2-i+1,mod2)*now1)%=mod2;\n        ll summ=nck(n/2,i,mod2)*now2%mod2;\n        //cout<<sum<<\" \"<<summ<<endl;\n        (summ*=2*sum)%=mod2;\n        (ans+=-summ+mod2)%=mod2;\n        (now1*=2)%=mod2;\n        (now2*=gn)%=mod2;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 10000005;\nconst int K = 25;\nint f[N], invf[N];\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    n /= 2;\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = f[i - 1] * i % mod;\n    invf[N - 1] = binpow(f[N - 1], mod - 2);\n    for (int i = N - 2; i >= 0; i--){\n        invf[i] = invf[i + 1] * (i + 1) % mod;\n    }\n    int ans = binpow(9, n);\n    for (int i = 0; i < n; i++){\n        ans = (ans - c(n + n, i) * binpow(2, i + 1) % mod + mod) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\n//using i128 = i64;\n//using u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a%b) : a;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n\ntemplate<class T>\nvoid print(const T &a)\n{\n\tfor (auto x : a) printf(\"%d \", x); puts(\"\");\n}\n\nconst int MAXN = 500010;\n//const int MAXM = 100010;\nconst int MAXK = 30;\n//const i64 INF = 1000000000000000000LL;\nconst int INF = 1000000000;\n//const int MOD = 998244353;\nconst int B = 31;\n//const int MOD = 1000000007;\n//const int INV2 = (MOD+1)/2;\nconst ld pi = 3.1415926535897932384626433;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n#define rep(i,a,b) for (int i = (a), I = (b); i <= I; ++ i)\n\nint days[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nbool leap(int y)\n{\n\treturn y%4 == 0 && y%100 != 0 || y%400 == 0;\n}\n\nconst int MOD = 998244353;\n \nstruct mod_int {\n    int val;\n \n    mod_int(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n \n        if (v >= MOD)\n            v %= MOD;\n \n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n \n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n \n        return x < 0 ? x + m : x;\n    }\n \n    explicit operator int() const {\n        return val;\n    }\n \n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n \n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n \n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n \n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n \n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n \n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n \n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n \n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n \n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n \n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n \n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n \n    mod_int inv() const {\n        return mod_inv(val);\n    }\n \n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n \n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n \n        return result;\n    }\n \n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n \nnamespace NTT {\n    vector<mod_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    mod_int root;\n \n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n \n    int round_up_power_two(int n) {\n        assert(n > 0);\n \n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n \n        return n;\n    }\n \n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n \n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<mod_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n \n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n \n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n \n    void find_root() {\n        int order = MOD - 1;\n        max_size = 1;\n \n        while (order % 2 == 0) {\n            order /= 2;\n            max_size *= 2;\n        }\n \n        root = 2;\n \n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n \n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n \n        assert(n <= max_size);\n \n        if ((int) roots.size() >= n)\n            return;\n \n        int length = get_length(roots.size());\n        roots.resize(n);\n \n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            mod_int z = root.pow(max_size >> (length + 1));\n \n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n \n            length++;\n        }\n    }\n \n    void fft_iterative(int N, vector<mod_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n \n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    mod_int even = values[start + i];\n                    mod_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n \n    const int FFT_CUTOFF = 150;\n \n    vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n        int n = left.size();\n        int m = right.size();\n \n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1);\n \n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n \n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n \n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n \n            return vector<mod_int>(result.begin(), result.end());\n        }\n \n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n \n        bool equal = left == right;\n        fft_iterative(N, left);\n \n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n \n        mod_int inv_N = mod_int(N).inv();\n \n        for (int i = 0; i < N; i++)\n            left[i] *= right[i] * inv_N;\n \n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n \n    vector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<mod_int> result = {1};\n \n        if (exponent == 0)\n            return result;\n \n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n \n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n \n        return result;\n    }\n}\n\n\nvoid solve()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\t//dfs(1);\n\t/* \n\tf[0][0] = 1;\n\tfor (int i = 0; i < 20; ++ i)\n\t\tfor (int j = 0; j <= i; ++ j)\n\t\t{\n\t\t\tf[i+1][j] += 7*f[i][j];\n\t\t\tf[i][j]\n\t\t}\n\t\t*/\n\t//cout << ans << endl;\n\tauto v = NTT::mod_power({1, 2}, n);\n\tint ans = 0;\n\tfor (int i = 0; i < n/2; ++ i)\n\t\t(ans += int(v[i])) %= MOD;\n\tans = (power(3, n, MOD)-ans-ans+MOD+MOD)%MOD;\n\tcout << ans << endl;\n}\n\nint main()\n{\n\t\n\tint T;\n\tT = 1;\n\t//scanf(\"%d\", &T);\n\twhile (T --)\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 10000010;\nconst int moder = 998244353;\n\nint fac[N], inv[N], invf[N];\nint pre[N];\nint power[N];\n\nint comb(int n, int m){\n    return m < 0 || n < m ? 0 : 1ll * fac[n] * invf[m] % moder * invf[n - m] % moder;\n}\n\nint main(){\n    fac[0] = invf[0] = power[0] = 1;\n    for (int i = 1; i < N; ++ i){\n        fac[i] = 1ll * fac[i - 1] * i % moder;\n        inv[i] = i == 1 ? 1 : moder - 1ll * (moder / i) * inv[moder % i] % moder;\n        invf[i] = 1ll * invf[i - 1] * inv[i] % moder;\n        power[i] = 2 * power[i - 1] % moder;\n    }\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n / 2; ++ i){\n        pre[i] = ((i ? pre[i - 1] : 0) + 1ll * comb(n / 2, i) * power[i]) % moder;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n / 2; ++ i){\n        ans = (ans + 1ll * power[n / 2 - i] * comb(n / 2, i) % moder * (i ? pre[i - 1] : 0)) % moder;\n    }\n    int ans1 = 1;\n    for (int i = 0; i < n; ++ i){\n        ans1 = 3ll * ans1 % moder;\n    }\n    ans1 = (ans1 - 2ll * ans) % moder;\n    ans1 += ans1 < 0 ? moder : 0;\n    printf(\"%d\\n\", ans1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define iiii pair<int,pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 998244353\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n\tint x=0,p=1;char c=getchar();\n\twhile (c<=32)c=getchar();\n\tif(c==45)p=-p,c=getchar();\n\twhile (c>32)x=x*10+c-48,c=getchar();\n\treturn x*p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N=1e7+5;\nint pw2[N],pw3[N],fac[N],inv[N],n;\n//\ninline void add(int &x,int y){\n\tx+=y;if(x>=MOD)x-=MOD;\n}\t\ninline void sub(int &x,int y){\n\tx-=y;if(x<0)x+=MOD;\n}\ninline int mul(int x,int y){\n\tll ans=1ll*x*y;\n\treturn ans%MOD;\n}\ninline int c(int x,int y){\n\treturn mul(fac[x],mul(inv[y],inv[x-y]));\n}\ninline int modpow(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=mul(ans,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\ninline int modinv(int x){return modpow(x,MOD-2);}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=getint();\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tinv[n]=modinv(fac[n]);\n\tfor(int i=n-1;i>=0;i--)inv[i]=mul(inv[i+1],i+1);\n\tpw3[0]=1;\n\tfor(int i=1;i<=n;i++)pw3[i]=mul(pw3[i-1],3);\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;i++)pw2[i]=mul(pw2[i-1],2);\n\tint res=pw3[n];\n\tfor(int i=n/2+1;i<=n;i++)sub(res,mul(c(n,i),pw2[n-i+1]));\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(register int i=s;i<=t;++ i)\n#define re register\n#define int long long\nint gi(){\n\tchar cc=getchar();int cn=0,flus=1;\n\twhile(cc < '0' || cc > '9'){if(cc == '-')flus=-flus;cc=getchar();}\n\twhile(cc >= '0' && cc<='9')cn=cn*10+cc-'0',cc=getchar();\n\treturn cn*flus;\n}\nconst int P=998244353;\nconst int N=1e7+5;\nint n,inv[N],fac[N],fp[N],Ans;\nint fpow(int x,int k){\n\tint ans=1,base=x;\n\twhile(k){\n\t\tif(k&1) ans=ans*base%P;\n\t\tbase=base*base%P,k >>= 1;\n\t}return ans;\n}\nvoid inc(int &x,int y){\t((x += y) >= P) && (x -= P);}\nint C(int x,int y){if(y > x) return 0;return fac[x]*inv[y]%P*inv[x-y]%P;}\nsigned main(){\n\tn=gi(),fp[0]=inv[0]=fac[0]=1;\n\trep(i,1,n) fac[i]=fac[i-1]*i%P,fp[i]=fp[i-1]*2%P;\n\tinv[n]=fpow(fac[n],P-2);\n\tfor(re int i=n;i >= 1;-- i) inv[i-1]=inv[i]*i%P;\n\tint m=(n/2)+1,num=0;\n\tAns=fpow(3,n);\n\tfor(re int i=m;i<=n;++ i){\n\t\tint dec=C(n,i);\n\t\tdec=dec*fp[n-i]%P;\n\t\tinc(num,dec);\n\t}\n\tAns=(Ans-num*2ll%P+P)%P;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=998244353;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this*=x.inv();}\n    bool operator==(const Mint& x) const{return val==x.val;}\n    bool operator!=(const Mint& x) const{return val!=x.val;}\n    bool operator<(const Mint& x) const{return val<x.val;}\n    bool operator<=(const Mint& x) const{return val<=x.val;}\n    bool operator>(const Mint& x) const{return val>x.val;}\n    bool operator>=(const Mint& x) const{return val>=x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    factorial fact(2000010);\n    Mint ans=Mint(3).pow(n);\n    rep(i,n/2+1,n+1){\n        ans-=fact.nCr(n,i)*Mint(2).pow(n-i)*2;\n    }\n    printf(\"%d\\n\",ans.val);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 10000012\n#define mod 1000000007\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nint n,fac[N],inv[N],ans,ans1,P[N];\nint main(){\n\tP[0]=1;for(int i=1;i<N;i++)P[i]=M(P[i-1]<<1);\n\tfac[0]=1;for(int i=1;i<N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-1]=ksm(fac[N-1],mod-2);for(int i=N-2;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tscanf(\"%d\",&n);ans=ksm(3,n);int i;\n\tfor(i=(n>>1)+1;i<=n;i++)ans1=(ans1+1ll*inv[i]*inv[n-i]%mod*P[n-i])%mod;\n\tans1=1ll*ans1*fac[n]%mod;ans=M1(ans-M(ans1<<1));printf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<bitset>\n#include<unordered_map>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define REP(i,n) for(ll (i)=0;(i)<(n);(i)++)\n#define rep(i,j,n) for(ll (i)=(j);(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//グラフ関連\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\n//nCr,nPr,modの逆元\nclass Combination {\npublic:\n\tArray fact;//n！\n\tArray inv;//n!の逆元\n\tll mod;\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tinv[n] = mod_inv(fact[n]);\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n\t//modの逆元\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\t//重複組み合わせ：n種類のものからr個取り出す組み合わせ\n\t\treturn nCr(r + n - 1, r);\n\t}\n};\n\nll pow2_m(ll x, ll n, ll mod) { //x^n 計算量O(logn)\n\tll ans = 1ll;\n\twhile (n > 0) {\n\t\tif ((n & 1) == 1) {\n\t\t\tans = ans * x % mod;\n\t\t}\n\t\tx = x * x % mod; //一周する度にx, x^2, x^4, x^8となる\n\t\tn >>= 1; //桁をずらす n = n >> 1\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\n\tll mod = 998244353;\n\tll n;\n\tcin >> n;\n\tCombination com(n, mod);\n\tll sum = pow2_m(3, n, mod);\n\n\tArray m2(n + 1, 1);\n\tREP(i, n) (m2[i + 1] = m2[i]*2) %= mod;\n\n\tll sum2=0;\n\tfor (ll i = n / 2 + 1; i < n + 1; i++) {\n\t\t(sum2 += com.nCr(n, i)*m2[n-i]) %= mod;\n\t}\n\n\tsum = (sum - sum2 + mod) % mod;\n\tsum = (sum - sum2 + mod) % mod;\n\n\tcout << sum << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vvi;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vvl;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nint mod=998244353;\nint sum(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vvi &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = bp(x, y / 2);\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 10000007;\nint fact[maxn], ofact[maxn];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nint dp3[maxn], dp2[maxn];\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tdp3[0] = 1;\n\tdp2[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tdp2[i] = mlt(dp2[i - 1], 2);\n\t\tdp3[i] = mlt(dp3[i - 1], 3);\n\t}\n\tint n;\n\tcin >> n;\n\tint sum = dp3[n];\n\tfor (int i = (n)/2+1; i <= n; i++)\n\t{\n\t\tint val = c(i, n);\n\t\tval = mlt(val, dp2[n - i]);\n\t\tval = mlt(val, 2);\n\t\tsum = dif(sum, val);\n\t}\n\tcout << sum << endl;\n}\nint main()\n{\n\tprec();\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    finv.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    for (int i = 0; i < n + 1; i++) finv[i] = fact[i].inv();\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 998244353;\n\nint main() {\n  int n;\n  cin >> n;\n  ModInt::build(n);\n  ModInt u = ModInt(3).pow(n);\n  ModInt c = 0;\n  ModInt p = ModInt(2).pow(0);\n  for (int i = n; i > n / 2; i--) {\n    c += ModInt::comb(n, i) * p;\n    p *= 2;\n  }\n  cout << u - c * 2 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 5555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mod_pow(2, n - i) % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nvector<mod_int> inv = {0, 1}, factorial = {1, 1}, inv_factorial = {1, 1};\nint prepared_size = 2;\n\nvoid prepare_factorials(int maximum) {\n    static int prepare_calls = 0;\n\n    if (prepare_calls++ == 0) {\n        // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n        for (int p = 2; p * p <= MOD; p++)\n            assert(MOD % p != 0);\n    }\n\n    if (maximum >= prepared_size) {\n        inv.resize(maximum + 1);\n        factorial.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int i = prepared_size; i <= maximum; i++) {\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            factorial[i] = i * factorial[i - 1];\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n\n        prepared_size = maximum + 1;\n    }\n}\n\nmod_int choose(long long n, long long r) {\n    if (r < 0 || r > n) return 0;\n    if (n >= prepared_size) prepare_factorials(n);\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(long long n, long long r) {\n    assert(0 <= r && r <= n);\n    if (n >= prepared_size) prepare_factorials(n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    if (n >= prepared_size) prepare_factorials(n);\n    return factorial[n] * inv_factorial[n - k];\n}\n\nmod_int inv_permute(long long n, long long k) {\n    assert(0 <= k && k <= n);\n    if (n >= prepared_size) prepare_factorials(n);\n    return inv_factorial[n] * factorial[n - k];\n}\n\n\nint main() {\n    int N;\n    cin >> N;\n    mod_int answer = mod_int(3).pow(N);\n\n    for (int i = N / 2 + 1; i <= N; i++)\n        answer -= 2 * choose(N, i) * mod_int(2).pow(N - i);\n\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n freopen(\"input\",\"r\",stdin);\n freopen(\"output\",\"w\",stdout);\n*/\n\nconst int sz = 1E7 + 10;\n\nll F[sz];\nll I[sz];\n\nll MOD = 998244353;\n\nll nchoosek(ll a, ll b) {\n    ll res = F[a] * I[b];\n    res %= MOD;\n    return (res * I[a - b]) % MOD;\n}\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int N;\n    cin >> N;\n    F[0] = 1;\n    for (int i = 1;i <= N;i++) {\n        F[i] = F[i - 1] * i;\n        F[i] %= MOD;\n    }\n    I[N] = power(F[N], MOD - 2);\n    for (int i = N;i > 0;i--) {\n        I[i - 1] = (I[i] * i) % MOD;\n    }\n    ll tol = power(3, N);\n    for (int i = N / 2 + 1;i <= N;i++) {\n        ll crt = nchoosek(N, i) * power(2, N - i);\n        crt %= MOD;\n        tol += (MOD - crt) * 2;\n        tol %= MOD;\n    }\n    cout << tol << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 20000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N;\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n    int r = 0;\n    Mint w = 1;\n    Mint ans = 1;\n    for (int p=0, q=0, c=N-1; c>=0; c--) {\n\tw += w;\n\tr++;\n\tif (r > c) {\n\t    w -= nCk(p+q, q) * 2;\n\t    q++;\n\t} else {\n\t    p++;\n\t}\n\tans += w * nCk(N, c);\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nconst int maxn=1e7+5;\nint n;\nint f[maxn];\nint invf[maxn];\nint power[maxn];\ninline int ksm(int x,int y){\n\tif(!y) return 1;\n\tif(y==1) return x;\n\tint tmp=ksm(x,y/2);\n\ttmp=(1ll*tmp*tmp)%MOD;\n\tif(y&1) return (1ll*tmp*x)%MOD;\n\telse return tmp;\n}\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn (1ll*f[x]*invf[y])%MOD*invf[x-y]%MOD;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tf[0]=invf[0]=1;\n\tfor(int i=1;i<maxn;i++) f[i]=(1ll*f[i-1]*i)%MOD;\n\tinvf[maxn-1]=ksm(f[maxn-1],MOD-2);\n\tfor(int i=maxn-2;i>=1;i--) invf[i]=(1ll*invf[i+1]*(i+1))%MOD;\n\tpower[0]=1;\n\tfor(int i=1;i<maxn;i++) power[i]=(1ll*power[i-1]*2)%MOD;\n\tint ans=ksm(3,n);\n\tint res=0;\n\tfor(int i=n/2+1;i<=n;i++) res=(res+1ll*power[n-i]*C(n,i))%MOD;\n\tres=(res*2ll)%MOD;\n\tans=(ans-res)%MOD+MOD%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// C - Neither AB nor BA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD\t998244353\n\nvector<long long> fact, finv;\n\nvoid init_fact(int n = 1000000)\n{\n\tfact.resize(n); finv.resize(n);\n\tfact[0] = finv[n - 1] = 1;\n\tfor (int i = 1; i < n; i++) fact[i] = fact[i - 1] * i % MOD;\n\tfor (long long x = MOD - 2, a = fact[n - 1]; x > 0; a = a * a % MOD, x >>= 1)\n\t\tif (x & 1) finv[n - 1] = finv[n - 1] * a % MOD;\n\tfor (int i = n - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % MOD;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact[n] * finv[r] % MOD * finv[n - r] % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tlong long n;\n\tcin >> n;\n\n\tinit_fact(n + 1);\n\n\tlong long ans = 1;\n\tfor (long long m = n, x = 3; m > 0; x = x * x % MOD, m >>= 1) if (m & 1) ans = ans * x % MOD;\n\n\tvector<long long> p2(n + 1, 1);\n\tfor (int i = 0; i < n; i++) p2[i + 1] = (p2[i] * 2) % MOD;\n\tfor (long long i = n / 2 + 1; i <= n; i++)\n\t\tans = (ans - cnr(n, i) * p2[n - i] * 2 % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=998244353;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this*=x.inv();}\n    bool operator==(const Mint& x) const{return val==x.val;}\n    bool operator!=(const Mint& x) const{return val!=x.val;}\n    bool operator<(const Mint& x) const{return val<x.val;}\n    bool operator<=(const Mint& x) const{return val<=x.val;}\n    bool operator>(const Mint& x) const{return val>x.val;}\n    bool operator>=(const Mint& x) const{return val>=x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    factorial fact(10000010);\n    Mint ans=Mint(3).pow(n);\n    rep(i,n/2+1,n+1){\n        ans-=fact.nCr(n,i)*Mint(2).pow(n-i)*2;\n    }\n    printf(\"%d\\n\",ans.val);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll mod=998244353;\n\nint main(){\n  ll n;\n  cin >> n;\n  if(n==4) cout << 61 << endl;\n  else cout << 1/0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n    modint operator+(const modint &r) const { return modint(num + r.num); }\n    modint operator-(const modint &r) const { return modint(num - r.num); }\n    modint operator*(const modint &r) const { return modint(num * r.num); }\n\n    template<typename T>\n    modint operator^(const T &r) const {\n        if(r == 0) return 1;\n        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);\n    }\n    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }\n\n    modint operator+=(const modint &r) { return *this = *this + r; }\n    modint operator-=(const modint &r) { return *this = *this - r; }\n    modint operator*=(const modint &r) { return *this = *this * r; }\n    modint operator/=(const modint &r) { return *this = *this / r; }\n\n    template<typename T>\n    modint operator^=(const T &r) { return *this = *this ^ r; }\n\n    static modint pow(const modint x, ll r) {\n        return x^r;\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int i = size; i <= n; i++) {\n                factorial[i] = fact(i-1) * modint(i);\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(ll n,ll r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * modint(2);\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <bits/stdc++.h>\n    \n    \nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cout(n) cout<<fixed<<setprecision(n)\n\n    \nconst int MAX = 10000001;\nconst int MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x); // 再帰的に解く\n    y -= a / b * x;\n    return d;\n}\n\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll MOD = 998244353;\n    COMinit();\n    ll n;\n    cin>>n;\n    ll f = n/2 + 1;\n\n    vector<ll> v2(n);\n    v2[0] = 1;\n    FOR(i,1,n){\n        v2[i] = (v2[i-1]*2)%MOD;\n    }\n    ll x = 3;\n    FOR(i,1,n) x = (x*3)%MOD;\n    ll res = 0;\n    FOR(i,f,n+1){\n        //cout<<\"n = \"<<n<<\" i = \"<<i<<\" \"<<COM(n,i)<<\" \"<<v2[n-i]<<endl;\n        //cout<<COM(n,i) * v2[n-i]<<endl;\n    \n        res += mod(COM(n,i) * v2[n-i],MOD);\n        if(res<0)cout<<res<<endl;\n    }\n    //cout<<endl;\n    //cout<<x<<endl;\n    x = mod(x-2*res,MOD);\n    cout<<x<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <unordered_map>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n// nice job //\nll n;\nconst ll mod = 998244353;\nconst ll N = 1e7 + 5;\nll fac[N];\nll ifac[N];\nll ME(ll x, ll P, ll m)\n{\n        ll res = 1LL;\n        ll cur = x;\n        while(P) {\n                if(P&1) res = (res * cur)%mod;\n                cur = (cur * cur)%mod;\n                P >>= 1;\n        }\n        return res;\n}\nll inv(ll x)\n{\n        return ME(x , mod-2, mod);\n}\nint main() {\n        cin >> n;\n        fac[0] = 1LL;\n        ifac[0] = 1LL;\n        for(ll i=1;i<=n+2;i++) {\n                fac[i] = (fac[i-1] * i)%mod;\n                ifac[i] = inv(fac[i]);\n        }\n        ll ans = 1LL;\n        vector< ll > pw;\n        pw.push_back(1LL);\n        for(ll i=1;i<=n;i++) {\n                pw.push_back(((pw.back())*2LL)%mod);\n        }\n        for(ll i=1;i<=n;i++) {\n                ans = (ans * 3LL)%mod;\n        }\n        for(ll i = (n/2) + 1 ; i <= n ; i++) {\n                ll h  = (fac[n] * ifac[i])%mod;\n                h = (h * ifac[n-i])%mod;\n                h = (h * pw[n-i+1])%mod;\n                ans = (ans - h + mod)%mod;\n        }\n        cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define llint long long\n#define mod 998244353\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nconst int FACT_MAX = 10000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint n;\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tmake_fact();\n\t\n\tllint ans = 0, mul = modpow(2, n/2), inv2 = modpow(2, mod-2);\n\tfor(int i = n/2+1; i <= n; i++){\n\t\tmul *= inv2, mul %= mod;\n\t\tans += mul * comb(n, i) % mod, ans %= mod;\n\t}\n\tans *= 2, ans %= mod;\n\tans = modpow(3, n) - ans + mod, ans %= mod;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 10000007\n#define MOD 998244353\n#define N 1048576\nll n, x, k, z, m, pos, q, ans_v;\nll x1, p1, x2;\nvector<ll> g[300500], f;\n\nll fac[MAXN], invfac[MAXN];\n\nll binpow(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    }\n    ll tmp = binpow(x, y / 2);\n    tmp = tmp * tmp % MOD;\n    if (y % 2) {\n        return x * tmp % MOD;\n    }\n    return tmp;\n}\n\nll inv(ll x) {\n    return binpow(x, MOD-2);\n}\n\nll C(ll n, ll m) {\n    if (n < m) {\n        return 0;\n    }\n    return fac[n] * invfac[m] % MOD * invfac[n-m] % MOD;\n}\n\nvoid precalc_facs() {\n    fac[0] = invfac[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fac[i] = fac[i-1] * i % MOD;\n        invfac[i] = inv(fac[i]);\n    }\n}\n\nll a[MAXN], pa[MAXN], p3[2 * MAXN], p2[2 * MAXN], sp[MAXN], spp[MAXN];\n\nint main() {\n    precalc_facs();\n    cin >> n;\n    n /= 2;\n    p3[0] = 1;\n    p2[0] = 1;\n    for (int i = 0; i <= 2 * n; i++) {\n\n        p3[i+1] = p3[i] * 3 % MOD;\n        p2[i+1] = p2[i] * 2 % MOD;\n    }\n\n    for (int i = 0; i <= n; i++) {\n        sp[i] = p2[n-i] * C(n, i) % MOD;\n        spp[i+1] = (spp[i] + sp[i]) % MOD;\n    }\n\n    for (int i = 0; i <= n; i++) {\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ll sum = sp[i] * (p3[n] - (spp[n - i + 1] - spp[0])) % MOD;\n        ans = (ans + sum) % MOD;\n        //cout << ans << endl;\n    }\n    cout << (p3[n*2] - ans * 2 + MOD * 2) % MOD << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int64_t mod = 998244353;\n\nint64_t fact[10000001], finv[10000001];\nint64_t mpow(int64_t x, int64_t y){\n    if(y==0) return 1;\n    if(y==1) return x%mod;\n    if(y%2==0) return mpow(x*x%mod, y/2);\n    return mpow(x*x%mod, y/2)%mod * x % mod;\n}\nint64_t comb(int64_t n, int64_t r){\n    if(r<0 || r>n) return 0;\n    return fact[n]*finv[r]%mod*finv[n-r]%mod;\n}\nint main(){\n    int n;\n    cin >> n;\n    fact[0] = 1;\n    for(int i=1;i<=n;++i) fact[i] = fact[i-1] * i % mod;\n    finv[n] = mpow(fact[n], mod-2);\n    for(int i=n-1;i>=0;--i) finv[i] = finv[i+1] * (i+1) % mod;\n\n    int64_t ans = mpow(3, n);\n    for(int i=n/2+1;i<=n;++i) ans = ((ans+mod) - comb(n,i)*mpow(2,n-i+1)%mod) % mod;\n    \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nconst int N = 5000010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    x %= mod;\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nvoid init_f(){\n    fact[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n    }\n    invf[N-1] = divll(1, fact[N-1]);\n    FORR(i,N-1,1){\n        invf[i-1] = (invf[i] * i) % mod;\n    }\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    ll m = n / 2, all = 1;\n    REP(i,n) all = (all * 3) % mod;\n\n    init_f();\n\n    VL two(m + 1);\n    two[0] = 1;\n    REP(i,m) two[i + 1] = (2 * two[i]) % mod;\n\n    VL cnt(m + 1);\n    for (ll x = 0; x <= m; x++){\n        cnt[x] = (nCr(m, x) * two[m - x]) % mod;\n    }\n    VL sum(m + 1);\n    sum[m] = cnt[m];\n    FORR(i,m-1,0) sum[i] = (cnt[i] + sum[i + 1]) % mod;\n\n    // FOR(i,0,m) cout << cnt[i] << \" \";\n    // cout << endl;\n    // FOR(i,0,m) cout << sum[i] << \" \";\n    // cout << endl;\n    ll bad = 0;\n    FOR(x,1,m){\n        ll y = m + 1 - x;\n        (bad += cnt[x] * sum[y]) %= mod;\n        // cout << cnt[x] * sum[y] << endl;\n    }\n    bad = (2 * bad) % mod;\n\n    ll ans = (all - bad + mod) % mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <ctime>\n#include <utility>\n#include <fstream>\n#include <queue>\n#include <deque>\n \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC optimize(\"vpt\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment(linker, \"/STACK:256000000\")\n#pragma warning(disable:4996)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ld pi = 3.14159265358979323846264;\nconst char el = '\\n';\n//const int inf = 1000'000'000;\n \n#define forn(i, n) for (int i = 0; i < (int)n; ++i)\n#define firn(i, n) for (int i = 1; i < (int)n; ++i)\n#define all(v) v.begin(), v.end()\n#define x first\n#define y second\n \ntemplate<typename T> bool uin(T &a, T b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T> bool uax(T &a, T b) { if (b > a) { a = b; return 1; } return 0; }\ntemplate<class iterator> void output(iterator begin, iterator end, char p = ' ', ostream &out = cout) { while (begin != end) { out << (*begin) << p; begin++; } out << el; }\ntemplate<class T> void output(T x, char p = ' ', ostream &out = cout) { output(all(x), p, out); }\n \nmt19937 rnd(time(NULL));\n\n#define int long long\n\nconst int N = 1000 * 10000 + 228;\nconst int MOD = 998244353;\n\nint n;\nint f[N], rf[N];\n\nint mod(int x) {\n    x %= MOD;\n    if (x < 0) x += MOD;\n    return x;\n}\n\nint fp(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mod(res * a);\n        }\n        a = mod(a * a);\n        b >>= 1;\n    }\n    return res;\n}\n\nint C(int n, int k) {\n    return mod(f[n] * mod(rf[k] * rf[n - k]));\n}\n\nint base[N];\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cin >> n;\n    f[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = mod(f[i - 1] * i);\n    }\n    rf[n] = fp(f[n], MOD - 2);\n    for (int i = n - 1; i + 1; --i) {\n        rf[i] = mod(rf[i + 1] * (i + 1));\n    }\n    base[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        base[i] = mod(base[i - 1] * 2);\n    }\n    int res = fp(3, n);\n    for (int A = n / 2 + 1; A <= n; ++A) {\n        res = mod(res - mod(2 * C(n, A) * base[n - A]));\n    }\n    cout << res << '\\n';\n    return 0;\n}\n/*\n<>>><<><<<<<>>><\n0 3 2 1 0 1 2 0 1 2 3 4 5 2 1 0 1\n0 3 2 1 0 1 2 0 1 2 3 4 5 3 2 0 1 \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ll long long\n#define MX 500009 \n#define INF 100000000009\n#define MOD 998244353\nusing namespace std;\n \nint main(){\n    ll n;\n    cin>>n;\n    ll ans=1;\n    rep(i,n){ans*=3;ans%=MOD;}\n    ll k=2,com=1;\n    rep(i,n/2-1){\n        k*=2;\n        k%=MOD;\n        com=(com*(n-i))/(i+1);\n        com%=MOD;\n        ans-=(k*com)%MOD;\n        ans%=MOD;\n    }\n  \tans-=2;\n    if(ans<0)ans+=MOD;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n//#define MOD 1000000007\n#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\ntypedef pair<int,int> P;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).val() == rhs.val();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vec fact(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1);\n  mint ans = 1;\n  REP(_,n) ans *= 3;\n\n  mint now = 1;\n  REP(i,n/2){\n    ans -= fact[n]/fact[i]/fact[n-i]*2*now;\n    now *= 2;\n  }\n\n  cout << ans.val() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int NC = 1e7 + 5, Mod = 998244353;\nint Ml(int x, int y) { return (ll)x * y % Mod; }\nint Ad(int x, int y) { return ((x + y) > Mod) ? (x + y - Mod) : (x + y); }\nint Dc(int x, int y) { return ((x - y) < 0) ? (x - y + Mod) : (x - y); }\nint ksm(int x, int y) {\n\tint ret = 1;\n\tfor (; y; y >>= 1, x = Ml(x, x))\n\t\tif (y & 1) ret = Ml(ret, x);\n\treturn ret;\n}\nint N, half, fac[NC], ifac[NC];\nvoid Init() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfac[i] = Ml(fac[i-1], i);\n\tifac[N] = ksm(fac[N], Mod - 2);\n\tfor (int i = N-1; i >= 0; --i)\n\t\tifac[i] = Ml(ifac[i+1], i+1);\n}\nint binom(int x, int y) {\n\tif (x < 0 || y < 0 || x < y)\n\t\treturn 0;\n\telse {\n\t\treturn Ml(fac[x], Ml(ifac[y], ifac[x-y]));\n\t}\n}\nint main() {\n\tscanf(\"%d\", &N);\n\thalf = N / 2 + 1;\n\tint ans = 0;\n\tInit();\n\tfor (int i = half; i <= N; ++i) {\n\t\tans = Ad(ans, Ml(binom(N, i), ksm(2, N-i)));\n\t}\n\tans = Dc(ksm(3, N), Ml(ans, 2));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100005\n#define ll long long\n#define MOD 1000000007\nll po[MAX];\nll C[MAX];\nll sum[MAX];\n\nll bigMod(ll a, ll p)\n{\n    if(p == 0) return 1LL;\n    if(p == 1) return a;\n    ll ret = bigMod(a, p/2);\n    ret = (ret*ret)%MOD;\n    if(p & 1) ret = (ret*a)%MOD;\n    return ret;\n}\n\nll dv(ll a, ll b)\n{\n    b = bigMod(b, MOD-2);\n    ll ret = (a*b)%MOD;\n    return ret;\n}\n\nint main()\n{\n    po[0] = 1;\n    for(int i=1; i<MAX; i++){\n        po[i] = (po[i-1]*2)%MOD;\n    }\n    ll n;\n    scanf(\"%lld\", &n);\n    ll m = n/2;\n    C[0] = 1;\n    C[1] = m;\n    for(int i=2; i<=m; i++){\n        C[i] = (C[i-1]*(m-i+1))%MOD;\n        C[i] = dv(C[i], i);\n    }\n    ll tot = 0;\n    for(int i=0; i<=m; i++){\n        tot += (C[i]*po[m-i])%MOD;\n        tot = tot%MOD;\n        sum[i] = tot;\n    }\n    ll ans = 0;\n    for(int i=0; i<=m; i++){\n        ll cur1 = (C[i]*po[m-i])%MOD;\n        ll cur2 = (sum[m]-sum[m-i])%MOD;\n        if(cur2 < 0) cur2 += MOD;\n        ans += (cur1*cur2)%MOD;\n        ans = ans%MOD;\n    }\n    ans = (ans*2)%MOD;\n    ll all = 1;\n    for(int i=1; i<=n; i++){\n        all = (all*3)%MOD;\n    }\n    ans = (all-ans)%MOD;\n    if(ans < 0) ans += MOD;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll mod = 998244353;\n \nll F[10101010], FI[10101010];\nll n, ans;\n \nll inv(ll x) { return x > 1? mod / x * (mod - inv(mod % x)) % mod : 1; }\n \nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tll i, t;\n\t\n\tcin >> n;\n\t\n\tfor(i = 1, F[0] = 1; i <= n; i ++){\n\t\tF[i] = F[i - 1] * i % mod;\n    }\n\t\n\tFI[n] = inv(F[n]);\n\t\n\tfor(i = n, ans = 1; i; i --){\n\t\tF[i - 1] = F[i] * i % mod;\n\t\tans = ans * 3 % mod;\n    }\n\t\n\tfor(i = n, t = 2 * F[n] % mod; i + i > n; i --){\n\t\tans = (ans - t * FI[n - i] % mod * FI[i]) % mod;\n\t\tt = t * 2 % mod;\n    }\n\t\n\tcout << (ans + mod) % mod << \"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nconst int MOD = 998244353;\nconst int MX = 10000005;\nint n;\nll ans = 1, f = 1, iv[MX];\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) f = f*i % MOD;\n\tiv[n] =  exp(f,MOD-2);\n\tfor(int i = n; i > 0; i--) iv[i-1] = (iv[i] * i) % MOD;\n\tans = exp(3,n);\n\trep(i,n/2){\n\t\tf = f*2 % MOD;\n\t\t(ans -= f * iv[n-i] % MOD * iv[i]) %= MOD;\n\t}\n\tif(ans < 0) ans += MOD;\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate <typename T> T mod_pow(T n, T r, T m) {\n\tT ret = 1;\n\tT tmp = n;\n\twhile (r != 0) {\n\t\tif (r % 2) {\n\t\t\tret *= tmp;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= m;\n\t\tret %= m;\n\t\tr /= 2;\n\t}\n\treturn ret;\n}\n\ntemplate <typename T> T mod_inv (T a, T m) {\n\treturn mod_pow(a, m - 2, m);\n}\n\n template <typename T> T mod_div (T a, T b, T m) {\n\treturn a * mod_inv(b, m) % m;\n}\n\nint main() {\n\tull mod = 998244353;\n\t\n\tuint N;\n\tcin >> N;\n\t\n\tull a_comb = 1;\n\tull bc_comb = 1;\n\tull major = 1;\n\t\n\tfor(uint i=1; i<N/2; i++) {\n\t\ta_comb = mod_div(a_comb * (N - i + 1) % mod, (ull)i, mod);\n\t\t//a_comb = a_comb * (N - i + 1) / i;\n\t\t//cout << N << \"C\" << i << \":\" << a_comb << endl;\n\t\tbc_comb = bc_comb * 2 % mod;\n\t\tull comb = a_comb * bc_comb % mod;\n\t\tmajor = (major + comb) % mod;\n\t}\n\t\n\tull whole = mod_pow((ull)3, (ull)N, mod);\n\tull ans = (whole > major * 2) ? (whole - major * 2) % mod : mod + whole - major * 2;\n\t\n\t\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define minus djsf\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint pw(int x, int y) {\n    \n    ll ans = 1;\n    ll deg = x;\n    for (int i=0; i < 30; ++i){\n        int ba = (1LL<<i)&y;\n        if (ba != 0){\n            ans *= deg;\n            ans %= mod;\n        }\n        deg *= deg;\n        deg %= mod;\n    }\n    \n\treturn ans;\n}\n\nconst int N = 10000007;\n\nint fact[N], rev[N];\n\nint C(int n, int k) {\n\tint A = fact[n];\n\tint B = ((ll) rev[k] * rev[n-k]) % mod;\n\treturn ((ll) A * B) % mod;\n}\n \nsigned main()\n{\n#ifdef LOCAL\n\tfreopen(\"N_input.txt\", \"r\", stdin);\n\t//freopen(\"P_output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    fact[0] = 1;\n    for (int i=1; i < N; ++i) fact[i] = ((ll) fact[i-1] * i) % mod;\n    for (int i=0; i < N; ++i) rev[i] = pw(fact[i], mod-2);\n\n    \t//cout << pw(2, 5) << endl;\n    \n\n    int n;\n    cin >> n;\n\n    int ans = pw(3, n);\n\n    for (int i=n/2+1; i <= n; ++i) {\n    \tint T = (2*C(n, i)) % mod;\n    \tT = ((ll) T * pw(2, n - i)) % mod;\n    \tans = (ans - T + mod) % mod;\n    }\n\n    cout << ans;\n\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll mod=998244353;\n\nint main(){\n  ll n;\n  cin >> n;\n  if(n>=10) cout << 1/0 << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=10000010,mod=998244353;\n\nll fac[maxn],inv[maxn],ans;\nll fpm(ll a,ll b){\n    ll ret=1ll;\n    for(;b;b>>=1,a=a*a%mod)\n        if(b&1)ret=ret*a%mod;\n    return ret;\n}\nll C(ll n,ll m){\n    if(n<0||m<0||n-m<0)return 0;\n    return fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint n;\n\nvoid solve(){\n    scanf(\"%d\",&n);\n    fac[0]=1;ans=fpm(3,n);\n    for(int i=1;i<=n;++i)fac[i]=fac[i-1]*i%mod;\n    inv[n]=fpm(fac[n],mod-2);\n    for(int i=n;i;--i)inv[i-1]=inv[i]*i%mod;\n    for(int i=(n>>1)+1;i<=n;++i)\n        (ans-=C(n,i)*fpm(2,n-i+1)%mod)%=mod,(ans+=mod)%=mod;\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=1e7,ha=998244353;\n\ninline int add(int x,int y){ x+=y; return x>=ha?x-ha:x;}\ninline void ADD(int &x,int y){ x+=y; if(x>=ha) x-=ha;}\n\ninline int ksm(int x,int y){\n\tint an=1;\n\tfor(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;\n\treturn an;\n}\n\nint jc[N+5],ni[N+5],n,ans;\n\ninline int C(int x,int y){ return x<y?0:jc[x]*(ll)ni[y]%ha*(ll)ni[x-y]%ha;}\n\ninline void solve(){\n\tjc[0]=1; for(int i=1;i<=n;i++) jc[i]=jc[i-1]*(ll)i%ha;\n\tni[n]=ksm(jc[n],ha-2);\n\tfor(int i=n;i;i--) ni[i-1]=ni[i]*(ll)i%ha;\n\t\n\tfor(int i=0,c=2;i*2<n;i++,c=add(c,c)) ADD(ans,c*(ll)C(n,i)%ha);\n\t\n\tans=add(ha-ans,ksm(3,n));\n}\n\nint main(){\n\tcin>>n,solve(),cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }\n\twhile(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }\n\treturn x*f;\n}\nconst int N=1e7+7,mo=998244353;\ninline int fk(int x) { return x>=mo ? x-mo : x; }\nint n,fac[N],facinv[N];\nint ksm(int x,int y)\n{\n\tint res=1;\n\twhile(y) { if(y&1) res=1ll*res*x%mo; x=1ll*x*x%mo; y>>=1; }\n\treturn res;\n}\ninline int C(int x,int y) { return 1ll*fac[x]*facinv[y]%mo*facinv[x-y]%mo; }\nint main()\n{\n\tn=read();\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mo;\n\tfacinv[n]=ksm(fac[n],mo-2);\n\tfor(int i=n-1;i>=0;i--) facinv[i]=1ll*facinv[i+1]*(i+1)%mo;\n\tint ans=ksm(3,n);\n\tfor(int k=n/2+1;k<=n;k++)\n\t\tans=fk(ans-2ll*C(n,k)*ksm(2,n-k)%mo+mo);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 998244353;\nll inv[5000001];\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int k = n/2+1;\n    ll bad = 0;\n    ll multiplier = 1;\n    ll ans = 1;\n    ll x = 1;\n    inv[1] = 1;\n    for (int i = 2; i <= n-k+1; i++){\n        inv[i] = (mod - (mod/i) * inv[mod%i] % mod) % mod;\n    }\n    for (int i = 0; i < n; i++) {\n        ans *= 3;\n        ans %= mod;\n    }\n    for (int i = n; i >= k; i--){\n        bad += multiplier*x;\n        bad %= mod;\n        multiplier *= i;\n        multiplier %= mod;\n        multiplier *= inv[n-i+1];\n        multiplier %= mod;\n        x *= 2;\n        x %= mod;\n    }\n    ans -= 2*bad;\n    ans = ((ans%mod)+mod)%mod;\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\nconst long MAX = 10000002;\nconst long MOD = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\nlong long P[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nvoid Pinit() {\n\tP[0] = 1;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tP[i] = P[i - 1] * 2 % MOD;\n\t}\n}\n\nint main() {\n\tlong long N;\n\tlong long L[18];\n\tlong long ans;\n\t\n\tcin >> N;\n\tCOMinit();\n\tPinit();\n\n\tans = 0;\n\tlong long t = 0;\n\tfor (int i = N / 2; i <= N; i += 1) {\n\t\tlong long m = P[i] - t;\n\t\tif (m < 0) {\n\t\t\tm += MOD;\n\t\t}\n\t\tans = (ans + COM(N, i) * m) % MOD;\n\t\tt = (t * 2 + COM(i, i - N / 2)) % MOD;\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst ll mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nconst int IMAX = 10000001;\nll fac[IMAX + 1], ifac[IMAX + 1];\ninline ll comb(int A, int B) {\n\treturn fac[A] * ifac[B] % mod * ifac[A - B] % mod;\n}\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tfac[0] = 1;\n\trep1(i, IMAX) fac[i] = fac[i - 1] * i % mod;\n\tifac[IMAX] = modpow(fac[IMAX], mod - 2);\n\tfor (int i = IMAX; i > 0; i--) ifac[i - 1] = ifac[i] * i % mod;\n\n\tll kotae = 1;\n\trep(i, N) {\n\t\tkotae *= 3;\n\t\tif (!(i & 15)) kotae %= mod;\n\t}\n\tkotae %= mod;\n\n\tll k = 1;\n\trep(i, N / 2) {\n\t\tkotae -= 2 * fac[N] * ifac[i] % mod * ifac[N - i] % mod * k % mod;\n\t\tk = k * 2 % mod;\n\t}\n\tprintf(\"%lld\", (kotae % mod + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint mod = 998244353;\nconst int maxn = 1e6 + 5;\nint n;\n\nint fact[maxn];\nint inv[maxn];\n\n\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\n\n\nint quickpow(int a, int b, int mod){\n  int ans = 1 % mod;\n  while(b){\n    if(b & 1)\n      ans = 1ll * ans * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\n\nvoid init(){\n  fact[0] = inv[0] = 1;\n  for(int i = 1; i <= maxn ; i ++){\n    fact[i] = 1ll * fact[i - 1] * i % mod;\n    inv[i] = 1ll * inv[i - 1] * quickpow(i, mod - 2, mod) % mod;\n  }\n}\n\n\nint main()\n{\n  init();\n  n = read();\n  int ans = quickpow(3 ,n, mod) % mod;\n  int x = 0;\n  for(int i = n / 2 + 1; i <= n; i ++){\n    x = (2ll * fact[n] % mod * inv[i] % mod * inv[(n - i)] % mod + x) % mod;\n  }\n  printf(\"%d\\n\",ans -  x );\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\nll MOD = 998244353;\n\n// g = eGCD(a, b, s, t)  --->  sa + tb = g\nconstexpr ll eGCD(ll a, ll b, ll& s, ll& t) {\n  if (a == 0) {\n    s = 0;\n    t = 1;\n    return b;\n  }\n  ll u = 0;\n  ll g = eGCD(b % a, a, t, u);\n  s = u - (b / a) * t;\n  return g;\n}\n\nconstexpr ll gcd(ll a, ll b) {\n  ll dummy1 = 0;\n  ll dummy2 = 0;\n  return eGCD(a, b, dummy1, dummy2);\n}\n\nstruct Fp {\n  ll val;\n\n  Fp(ll t = 0) :\n    val(t < 0 ? MOD + t % MOD : t >= MOD ? t % MOD : t) {}\n\n  Fp& operator +=(const Fp& t) {\n    val += t.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n\n  Fp& operator -=(const Fp& t) {\n    val -= t.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n\n  Fp& operator *=(const Fp& t) {\n    val = (val * t.val) % MOD;\n    return *this;\n  }\n\n  Fp inv() const {\n    if (val == 0) {\n      cerr << \"inv() is called for zero.\" << endl;\n      exit(1);\n    }\n    ll u = 0;\n    ll v = 0;\n    eGCD(val, MOD, u, v);\n    return Fp(u);\n  }\n\n  Fp& operator /=(const Fp& t) {\n    return (*this) *= t.inv();\n  }\n\n  Fp operator +(const Fp& t) const { return Fp(val) += t; }\n  Fp operator -(const Fp& t) const { return Fp(val) -= t; }\n  Fp operator *(const Fp& t) const { return Fp(val) *= t; }\n  Fp operator /(const Fp& t) const { return Fp(val) /= t; }\n  Fp operator -() const { return Fp(-val); }\n\n  bool operator ==(const Fp& t) const { return val == t.val; }\n  bool operator !=(const Fp& t) const { return val != t.val; }\n  \n  operator ll() const { return val; }\n\n};\n\nclass Comb {\n  int nMax;\n  vector<Fp> vFact;\n  vector<Fp> vInvFact;\npublic:\n  Comb(int nm) : nMax(nm), vFact(nm+1), vInvFact(nm+1) {\n    vFact.at(0) = 1;\n    for (int i = 1; i <= nMax; i++) vFact.at(i) = i * vFact.at(i-1);\n    vInvFact.at(nMax) = vFact.at(nMax).inv();\n    for (int i = nMax; i >= 1; i--) vInvFact.at(i-1) = i * vInvFact.at(i);\n  }\n  Fp fact(int n) { return vFact.at(n); }\n  Fp comb(int n, int r) {\n    return vFact.at(n) * vInvFact.at(r) * vInvFact.at(n-r);\n  }\n  // The number of permutation extracting r from n.\n  Fp perm(int n, int r) {\n    return vFact.at(n) * vInvFact.at(n-r);\n  }\n};\n\n/* \n   Power function    power(a, b) == a^b\n   Speed is O(log b).\n   The same source code can be used for integers by replacing\n   Fp with int etc.  Unfortunately, replacing Fp with auto does not\n   make the function generic for int and Fp.\n */\nFp power(Fp a, int b) {\n  Fp twoPow = a;\n  Fp rv = 1;\n  while (b > 0) {\n    if (b & 1) rv *= twoPow;\n    twoPow *= twoPow;\n    b >>= 1;\n  }\n  return rv;\n}\n\n\nint main(int argc, char *argv[]) {\n  // C-style stdio functions should not be used.\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  ll N; cin >> N;\n  Comb cmb(N);\n  Fp cnt = Fp(0);\n  vector<Fp> p2(N+1);\n  p2.at(0) = 1;\n  for (int i = 1; i <= N/2+1; i++) p2.at(i) = Fp(2) * p2.at(i-1);\n  for (ll n = N/2 + 1; n <= N; n++) {\n    // cnt += cmb.comb(N, n) * power(2, N-n);\n    cnt += cmb.comb(N, n) * p2.at(N-n);\n  }\n  Fp ans = power(3, N) - Fp(2) * cnt;\n  cout << ll(ans) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 998244353;\nconst int MAXN = 10000010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN], tav[MAXN];\n\nll powmod(ll a, ll b){\n\tif (!b) return 1;\n\tif (b&1) return a*powmod(a*a%mod, b>>1)%mod;\n\treturn powmod(a*a%mod, b>>1);\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=tav[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod, tav[i]=tav[i-1]*2%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n;\n\tans=powmod(3, n);\n\tfor (int i=n/2+1; i<=n; i++) ans=(ans-tav[n+1-i]*C(n, i))%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { return modint(num + (ll)r); }\n    template <typename T>\n    modint operator-(const T &r) const { return modint(num - (ll)r); }\n    template <typename T>\n    modint operator*(const T &r) const { return modint(num * (ll)r); }\n    template <typename T>\n    modint operator/(const T &r) const { return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nll N;\nconst ll MOD=998244353,MAX_N=1e7;\nll fact[MAX_N+1],ifact[MAX_N+1];\nll cmb(ll n,ll m){\n\treturn fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n}\nll mpw(ll n,ll m){\n\tll r=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tr*=n;\n\t\t\tr%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn r;\n}\nll minv(ll n){\n\treturn mpw(n,MOD-2);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N;\n\tfact[0]=1;\n\tREP(i,N){\n\t\tfact[i+1]=fact[i]*(i+1)%MOD;\n\t}\n\tifact[N]=minv(fact[N]);\n\tfor(ll i=N-1;i>=0;i--){\n\t\tifact[i]=ifact[i+1]*(i+1)%MOD;\n\t}\n\tll ans=0,pw2=1;\n\tfor(ll k=N;k>N/2;k--){\n\t\tans+=cmb(N,k)*pw2%MOD;\n\t\tpw2*=2;\n\t\tpw2%=MOD;\n\t}\n\tans*=2;\n\tans%=MOD;\n\tans=MOD-ans;\n\tans%=MOD;\n\tans+=mpw(3,N);\n\tans%=MOD;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\n//繰り返し二乗法\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=mod_pow(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(5000010*2);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tll ans=mod_pow(3,n);\n\tll res=0;\n\tfor(int i=0;i<n/2;i++){\n\t\tll k=p.comb(n,i);\n\t\t(k*=mod_pow(2,i))%=mod;\n\t\t(res+=k)%=mod;\n\t}\n\tcout << (ans-2*res+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>::value || is_same<T, modint>::value);\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#define MOD (long)(998244353)\n#define MAX 1000001  // 階乗をいくつまで計算するか\n\nclass modlong;\nvoid computeAll(long n);\nmodlong modComb(long n, long k);\nmodlong modFact(long n);\n\nclass modlong {\n    long val;\n    const long mod = MOD;\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) {\n        while (init < 0) init += mod;  // 0以上であることを保証\n        val = init % mod;\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) {\n        long rr = r;\n        while (rr < 0) rr += mod;  // 0以上であることを保証\n        this->val = rr % mod;\n    }\n\n    //比較\n    bool operator<(const modlong &r) { return this->val < r.val; }\n    bool operator>(const modlong &r) { return this->val > r.val; }\n    bool operator==(const modlong &r) { return this->val == r.val; }\n    bool operator!=(const modlong &r) { return !(*this == r); }\n    bool operator<=(const modlong &r) { return !(*this > r); }\n    bool operator>=(const modlong &r) { return !(*this < r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long aval = (this->val + r.val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong operator-() {\n        long aval = (mod - this->val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long aval = (this->val * r.val) % mod;\n        modlong ans(aval);\n        return ans;\n    }\n    modlong inv() {\n        if (*this == 1) return modlong(1);\n        if (*this == 0) cerr << \"modlong warning: dividebyzero!!!\" << '\\n';\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > 1) {\n            r = p.val %\n                q.val;  // r.val=p.val / q.val\n                        // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n;\n    }\n    modlong operator/(const modlong &r) {\n        modlong rr = r;\n        return *this * rr.inv();\n    }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n\n    // コンビネーション modCombは少し下に書いてある\n    modlong C(modlong k) { return modComb(this->val, k.val); }\n    modlong fact() { return modFact(this->val); }\n\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n//////      階乗を全て求める -> 二項係数を求める\n\nlong invs[MAX], facts[MAX], finvs[MAX];\nlong listlen = 0;  // invs, facts, finvsの配列長\nvoid computeAll(long n) {\n    if (n >= MAX)\n        cerr << \"modlong error: index out of range in computeAll\" << '\\n';\n    long i;\n    if (listlen == 0) {\n        invs[1] = 1;\n        facts[0] = 1;\n        facts[1] = 1;\n        finvs[0] = 1;\n        finvs[1] = 1;\n        i = 2;\n    } else {\n        i = listlen;\n    }\n    if (n < 2) return;\n    for (; i <= n; i++) {\n        invs[i] = -invs[MOD % i] * (MOD / i) % MOD;\n        facts[i] = facts[i - 1] * i % MOD;\n        finvs[i] = finvs[i - 1] * invs[i] % MOD;\n    }\n    listlen = n + 1;  // 次呼び出すときはn+1以降から再開すれば良い\n}\n// コンビネーション\nmodlong modComb(long n, long k) {\n    if (k < 0 || k > n) return 0;\n    if (k == 0 || k == n) return 1;\n    if (listlen <= n) computeAll(n);  // 毎回足りない分だけ補う\n    return modlong(facts[n]) * finvs[k] * finvs[n - k];\n}\n// 階乗\nmodlong modFact(long n) {\n    if (listlen <= n) computeAll(n);  // 毎回足りない分だけ補う\n    return modlong(facts[n]);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    // modlong dp[n/2+1][3];\n    // fill(dp[0], dp[n/2+1], 0);\n    // dp[0][0] = 1;\n    // for (int i=0; i<n/2; i++) {\n    //     dp[i+1][0] = dp[i][0] * 2;\n    //     dp[i+1][1] = dp[i][0] + dp[i][1] * 3;\n    //     dp[i+1][2] = dp[i][1] + dp[i][2] * 3;\n    // }\n    // cout << modlong(3).pow(n) - (dp[n/2][1] + dp[n/2][2]) * 2 << '\\n';\n    modlong ans = modlong(3).pow(n);\n    for (int i=0; i<n/2; i++) {\n        ans -= modComb(n, i) * modlong(2).pow(i+1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar_unlocked()\n#define pc(x) putchar_unlocked(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\nusing ll = long long;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 1;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        bi = divmod(bi, i, mod);\n        ans -= 2*bi; //A or B\n        ans %= mod;\n    }\n    print((ans+mod)%mod);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define mod 998244353\n\nusing namespace std;\n\nint C[10000050];\nint n;\n\nint qexp(int b, int e){\n\tif(e == 0) return 1;\n\tint half = qexp(b,e/2) % mod;\n\thalf *= half;\n\thalf %= mod;\n\tif(e % 2 == 0) return half;\n\telse return (half*b)%mod;\n}\nint inv(int x){\n\treturn qexp(x, mod-2);\n}\nint32_t main(){\n\tcin >> n;\n\tC[0] = 1;\n\tfor(int i=1; i<=n/2; ++i){\n\t\tC[i] = (C[i-1]*(n-i+1)) % mod;\n\t\tC[i] *= inv(i); C[i] %= mod;\n\t}\n\tfor(int i=n; i>=n/2+1; --i){\n\t\tC[i] = C[n-i];\n\t}\n\tint ans = qexp(3,n);\n\tfor(int i=n/2+1; i<=n; ++i){\n\t\tint sub = 2*C[i]; sub %= mod;\n\t\tsub *= qexp(2,n-i); sub %= mod;\n\t\tans -= sub;\n\t\tans += mod; ans %= mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define ri register int\nusing namespace std;\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> poly;\n#define pb push_back\nconst int rlen=1<<18|1,inf=0x3f3f3f3f;\nconst ll Inf=1e18;\nchar buf[rlen],*ib=buf,*ob=buf;\n#define gc() (((ib==ob)&&(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)\ninline int read() {\n  int ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline ll readl() {\n  ll ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline int Read(char*s) {\n  int tp=0;\n  char ch=gc();\n  while(!isdigit(ch)&&!isalpha(ch)) ch=gc();\n  while(isdigit(ch)||isalpha(ch)) s[++tp]=ch,ch=gc();\n  return tp;\n}\nnamespace modular {\n  const int mod=998244353;\n  inline int add(int a,int b) { return a+b<mod?a+b:a+b-mod; }\n  inline int dec(int a,int b) { return a<b?a-b+mod:a-b; }\n  inline int mul(int a,int b) { return (ll)a*b%mod; }\n  inline void Add(int&a,int b) { a=a+b<mod?a+b:a+b-mod; }\n  inline void Dec(int&a,int b) { a=a<b?a-b+mod:a-b; }\n  inline void Mul(int&a,int b) { a=(ll)a*b%mod; }\n  inline int ksm(int a,int p) { int ret=1;for(;p;p>>=1,Mul(a,a)) (p&1)&&(Mul(ret,a),1);return ret; }\n  inline int Inv(int a) { return ksm(a,mod-2); }\n  inline int sqr(int a) { return mul(a,a); }\n  inline int cub(int a) { return (ll)a*a%mod*a%mod; }\n}\nusing namespace modular;\ntemplate<typename T> inline void ckmax(T&a,T b) { a<b?a=b:0; }\ntemplate<typename T> inline void ckmin(T&a,T b) { a>b?a=b:0; }\ntemplate<typename T> inline T gcd(T a,T b) { T t;while(b)t=a,a=b,b=t-t/a*a;return a; }\ntemplate<typename T> inline T Abs(T x) { return x<0?-x:x; }\ninline int rd() { return rand()|(rand()<<15); }\nconst int N=1e7+5;\nint n,fac[N],ifac[N];\ninline int C(int n,int m) { return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }\ninline void init_fac() {\n  fac[0]=fac[1]=ifac[0]=ifac[1]=1;\n  for(ri i=2;i<=n;++i) {\n    fac[i]=mul(fac[i-1],i);\n    ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i);\n  }\n  for(ri i=2;i<=n;++i) Mul(ifac[i],ifac[i-1]);\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\",\"r\",stdin);\n  #endif\n  n=read();\n  init_fac();\n  int res=0,m=n/2;\n  for(ri nf,ng,i=0,f=1,g=0;i<=n;++i) {\n    if(i>=m) Add(res,mul(C(n,i),f));\n    ng=add(f,g),nf=dec(ng+1,C(i+1,m+1));\n    f=nf,g=ng;\n  }\n  cout<<res;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 5e6+7, M = 998244353;\nLL fac[N], invfac[N];\nLL p2[N], p3[2*N];\n\nLL power(LL a, LL p) {\n    if (p==0)   return 1;\n    LL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nLL pre() {\n    fac[0] = 1;\n    for (int i=1; i<N; i++) fac[i] = (fac[i-1]*i)%M;\n    invfac[N-1]=  power(fac[N-1], M-2);\n    for (int i=N-2; i>=0; i--)  invfac[i] = (invfac[i+1]*(i+1))%M;\n\n    p2[0] = p3[0] = 1;\n    for (int i=1; i<N; i++) p2[i] = (p2[i-1]*2)%M;\n    for (int i=1; i<2*N; i++) p3[i] = (p3[i-1]*3)%M;\n}\n\nLL C(int n, int r) {\n    if (r < 0 || r > n) return 0;\n    LL num = fac[n];\n    LL den = (invfac[r]*invfac[n-r])%M;\n    return (num*den)%M;\n}\n\nLL f[N];\nLL suf[N];\n\nint main() {\n    pre();\n    int n;\n    cin>>n;\n    int m = n/2;\n\n    for (int i=0; i<=m; i++)    {\n        f[i] = (C(m, i)*p2[m-i])%M;\n    }\n\n    for (int i=m; i>=0; i--) {\n        suf[i] = (suf[i+1] + f[i])%M;\n    }\n\n    LL ans =- 0;\n\n    for (int i=0; i<=m; i++)    {\n        ans = (ans + f[i] * suf[m-i+1])%M;\n    }\n    ans = (ans * 2)%M;\n    ans = (p3[2*m] - ans + M)%M;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision;\n\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define X first\n#define Y second\n#define ALL(x) x.begin(), x.end()\n#define RALL(x) x.rbegin(), x.rend()\n#define Push push_back\n\nconst int64_t mod = 998244353;\n\n/// 7, 63, 583, 5407, 50007, 460815, 4231815, ...\n\n/*\nvoid boom() {\n\tint cnt = 0, len = 14;\n\t\n\tstring s(len, 'A');\n\t--s[len - 1];\n\t\n\tint pows = 1;\n\tfor (int i = 0; i < len; ++i) pows *= 3;\n\t\n\tfor (int i = 0; i < pows; ++i) {\n\t\tint tok = len - 1;\n\t\twhile (++s[tok] == 'D') {\n\t\t\ts[tok] = 'A';\n\t\t\t--tok;\n\t\t}\n\t\t// cout << s << \"\\n\";\n\t\t\n\t\tbool flag = false;\n\t\t\n\t\tfor (int x = 0; x < len-1 and !flag; ++x) {\n\t\t\tif (s[x] == 'A' and s[x + 1] == 'B') continue;\n\t\t\tif (s[x] == 'B' and s[x + 1] == 'A') continue;\n\t\t\t\n\t\t\tstring t1;\n\t\t\tfor (int a = 0; a < len; ++a) {\n\t\t\t\tif (a == x or a == x + 1) continue;\n\t\t\t\tt1 += s[a];\n\t\t\t}\n\t\t\t\n\t\t\tfor (int y = 0; y < len-3 and !flag; ++y) {\n\t\t\t\tif (t1[y] == 'A' and t1[y + 1] == 'B') continue;\n\t\t\t\tif (t1[y] == 'B' and t1[y + 1] == 'A') continue;\n\t\t\t\t\n\t\t\t\tstring t2;\n\t\t\t\tfor (int a = 0; a < len-2; ++a) {\n\t\t\t\t\tif (a == y or a == y + 1) continue;\n\t\t\t\t\tt2 += t1[a];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int z = 0; z < len-5 and !flag; ++z) {\n\t\t\t\t\tif (t2[z] == 'A' and t2[z + 1] == 'B') continue;\n\t\t\t\t\tif (t2[z] == 'B' and t2[z + 1] == 'A') continue;\n\t\t\t\t\t\n\t\t\t\t\tstring t3;\n\t\t\t\t\tfor (int a = 0; a < len-4; ++a) {\n\t\t\t\t\t\tif (a == z or a == z + 1) continue;\n\t\t\t\t\t\tt3 += t2[a];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (int w = 0; w < len-7 and !flag; ++w) {\n\t\t\t\t\t\tif (t3[w] == 'A' and t3[w + 1] == 'B') continue;\n\t\t\t\t\t\tif (t3[w] == 'B' and t3[w + 1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tstring t4;\n\t\t\t\t\t\tfor (int a = 0; a < len-6; ++a) {\n\t\t\t\t\t\t\tif (a == w or a == w + 1) continue;\n\t\t\t\t\t\t\tt4 += t3[a];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int v = 0; v < len-9 and !flag; ++v) {\n\t\t\t\t\t\t\tif (t4[v] == 'A' and t4[v + 1] == 'B') continue;\n\t\t\t\t\t\t\tif (t4[v] == 'B' and t4[v + 1] == 'A') continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstring t5;\n\t\t\t\t\t\t\tfor (int a = 0; a < len-8; ++a) {\n\t\t\t\t\t\t\t\tif (a == v or a == v + 1) continue;\n\t\t\t\t\t\t\t\tt5 += t4[a];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (int u = 0; u < len-11 and !flag; ++u) {\n\t\t\t\t\t\t\t\tif (t5[u] == 'A' and t5[u + 1] == 'B') continue;\n\t\t\t\t\t\t\t\tif (t5[u] == 'B' and t5[u + 1] == 'A') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tstring t6;\n\t\t\t\t\t\t\t\tfor (int a = 0; a < len-10; ++a) {\n\t\t\t\t\t\t\t\t\tif (a == u or a == u + 1) continue;\n\t\t\t\t\t\t\t\t\tt6 += t5[a];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (t6[0] == 'A' and t6[1] == 'B') continue;\n\t\t\t\t\t\t\t\tif (t6[0] == 'B' and t6[1] == 'A') continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if (t5[0] == 'A' and t5[1] == 'B') continue;\n\t\t\t\t\t\t\t// if (t5[0] == 'B' and t5[1] == 'A') continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// flag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if (t4[0] == 'A' and t4[1] == 'B') continue;\n\t\t\t\t\t\t// if (t4[0] == 'B' and t4[1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if (t1[0] == 'A' and t1[1] == 'B') continue;\n\t\t\t// if (t1[0] == 'B' and t1[1] == 'A') continue;\n\t\t\t\t\t\t\n\t\t\t// flag = true;\n\t\t}\n\t\t\n\t\tcnt += flag;\n\t}\n\t\n\tcout << cnt << \"\\n\";\n}\n*/\n\nvoid solve() {\n\tint64_t n;\n\tcin >> n;\n\t\n\tn /= 2;\n\tassert(n < 8);\n\tint arr[8] = {0, 7, 63, 583, 5407, 50007, 460815, 4231815};\n\tcout << arr[n] << \"\\n\";\n}\n\nint main() {\n\tint t = 1;\n\t// cin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=10000005;\nconst int mod=998244353;\nint n,ans;\nint fac[maxn],ifac[maxn],pw2[maxn];\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=ifac[0]=fac[1]=ifac[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tpw2[0]=1;\n\tans=1;\n\tREP(i,n){\n\t\tpw2[i]=2LL*pw2[i-1]%mod;\n\t\tans=3LL*ans%mod;\n\t}\n\tfor(int i=n/2+1;i<=n;i++){\n\t\tans-=2LL*C(n,i)%mod*pw2[n-i]%mod;\n\t\tif(ans<0)ans+=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type alias\ntypedef long long LL;\ntypedef pair<int,int> II;\ntypedef tuple<int,int,int> III;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef unordered_map<int,int> MAPII;\ntypedef unordered_set<int> SETI;\ntemplate<class T> using VV=vector<vector<T>>;\n// minmax\ntemplate<class T> inline T SMIN(T& a, const T b) { return a=(a>b)?b:a; }\ntemplate<class T> inline T SMAX(T& a, const T b) { return a=(a<b)?b:a; }\n// repetition\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define REPE(i,n)  for(int i=0;i<=(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORR(x,arr) for(auto& x:arr)\n#define SZ(a) int((a).size())\n// collection\n#define ALL(c) (c).begin(),(c).end()\n// DP\n#define MINUS(dp) memset(dp, -1, sizeof(dp))\n#define ZERO(dp) memset(dp, 0, sizeof(dp))\n// stdout\n#define println(args...) fprintf(stdout, ##args),putchar('\\n');\n// debug cerr\ntemplate<class Iter> void __kumaerrc(Iter begin, Iter end) { for(; begin!=end; ++begin) { cerr<<*begin<<','; } cerr<<endl; }\nvoid __kumaerr(istream_iterator<string> it) { (void)it; cerr<<endl; }\ntemplate<typename T, typename... Args> void __kumaerr(istream_iterator<string> it, T a, Args... args) { cerr<<*it<<\"=\"<<a<<\", \",__kumaerr(++it, args...); }\ntemplate<typename S, typename T> std::ostream& operator<<(std::ostream& _os, const std::pair<S,T>& _p) { return _os<<\"{\"<<_p.first<<','<<_p.second<<\"}\"; }\n#define __KUMATRACE__ true\n#ifdef __KUMATRACE__\n#define dump(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); __kumaerr(_it, args); }\n#define dumpc(ar) { cerr<<#ar<<\": \"; FORR(x,(ar)) { cerr << x << ','; } cerr << endl; }\n#define dumpC(beg,end) { cerr<<\"~\"<<#end<<\": \"; __kumaerrc(beg,end); }\n#else\n#define dump(args...)\n#define dumpc(ar)\n#define dumpC(beg,end)\n#endif\nconst int MOD=998244353;\nstruct ModInt {\n  unsigned int val;\n  ModInt(): val(0) {}\n  ModInt(int v) { norm(v%MOD); }\n  ModInt(long long v) { norm(v%MOD); }\n  ModInt& norm(long long v) {\n    v=v<0?v%MOD+MOD:v; // negative\n    v=v>=MOD?v-MOD:v; // mod\n    val=(unsigned int)v;\n    return *this;\n  }\n  explicit operator bool() const { return val!=0; }\n  ModInt operator-() const { return ModInt(0)-*this; }\n  ModInt &operator+=(ModInt that) { return norm((long long)val+that.val); }\n  ModInt &operator-=(ModInt that) { return norm((long long)val-that.val); }\n  ModInt &operator*=(ModInt that) { val=(unsigned long long)val*that.val%MOD; return *this; }\n  ModInt &operator/=(ModInt that) { return *this*=that.inv(); }\n  ModInt operator+(ModInt that) const { return ModInt(*this)+=that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this)-=that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this)*=that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this)/=that; }\n  ModInt pow(long long n) const {\n    ModInt x=*this, res=1;\n    while(n>0) {\n      if(n&1) res*=x;\n      x*=x,n>>=1;\n    }\n    return res;\n  }\n  ModInt inv() const { return (*this).pow(MOD-2); }\n  bool operator==(ModInt that) const { return val==that.val; }\n  bool operator!=(ModInt that) const { return val!=that.val; }\n  friend ostream& operator<<(ostream& os, const ModInt& that) { return os<<that.val; }\n};\nLL choose(LL n, LL k) {\n  if(n<k) return 0;\n  \n  const int MAX_N = 1e7+1;\n  assert(0<=k&&k<=MAX_N);\n  static LL fact[MAX_N+1],revfact[MAX_N+1],rev[MAX_N+1];\n  \n  if(rev[1]==0) {\n    rev[1]=1;\n    for(int i=2;i<=MAX_N;i++) rev[i]=rev[MOD%i]*(MOD-MOD/i)%MOD;\n    fact[0]=1,revfact[0]=1;\n    for(int i=1;i<=MAX_N;i++) {\n      fact[i]=fact[i-1]*i%MOD;\n      revfact[i]=revfact[i-1]*rev[i]%MOD;\n    }\n  }\n  return fact[n]*revfact[n-k]%MOD*revfact[k]%MOD;\n}\n\n// $ cp-batch NeitherABNorBA | diff NeitherABNorBA.out -\n// $ g++ -std=c++14 -Wall -O2 -D_GLIBCXX_DEBUG -fsanitize=address NeitherABNorBA.cpp && ./a.out\n\n/*\n \n 11/3/2019\n \n 8:52-9:40 give up\n 15:40- read editorials\n \n https://img.atcoder.jp/agc040/editorial.pdf\n https://twitter.com/catupper/status/1191045754845941761?s=20\n https://twitter.com/gzlcp/status/1191055758110027776?s=20\n https://twitter.com/satanic0258/status/1191053863685541888?s=20\n \n */\n\nint N;\n\nModInt f(int k) {\n  return ModInt(choose(N/2,k))*ModInt(2).pow(N/2-k);\n}\nvoid solve() {\n  ModInt sum=0,cum=0;\n  int b=N/2+1;\n  FORE(a,1,N/2) {\n    cum+=f(b-a);\n    sum+=f(a)*cum;\n  }\n  ModInt res=ModInt(3).pow(N)-sum*2;\n  cout<<res<<endl;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout<<setprecision(12)<<fixed;\n  \n  cin>>N;\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 998244353;\n\nll mod_pow(ll x, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    vector<ll> f(N + 1, 1);\n    rep(i, N) {\n        f[i + 1] = (f[i] * (i + 1)) % MOD;\n    }\n    ll ans = mod_pow(3, N, MOD);\n    for (int i = N / 2 + 1; i <= N; i++) {\n        ll x = f[N] * mod_pow(f[i], MOD - 2, MOD);\n        x %= MOD;\n        x *= mod_pow(f[N - i], MOD - 2, MOD);\n        x %= MOD;\n        x *= mod_pow(2, N - i, MOD) * 2;\n        x %= MOD;\n        ans += MOD - x;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int, int >\n#define F first\n#define S second\n#define int  long long int\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n/// age ye mosh dp ro baze dashti dp tedad baz shodeye baste nashode yadet nare !!\nconst int N=1e7+10;\nll mod=998244353;\n\nll fac[N];\nll power(ll n, ll k){\n    if (k==0){\n        return 1;\n    }\n    else{\n        if (k%2==0){\n            ll x=power(n,k/2);\n            return x*x%mod;\n        }       \n        else{\n            ll x=power(n,k/2);\n            x=x*x%mod;\n            return x*n%mod;\n        }\n    }\n}\nll fm[N];\nll ent(ll k, ll n){\n\tif (k==0 || k==n){\n        return 1;\n\t}\n\n\treturn (((fac[n]*fm[k])%mod)*fm[n-k])%mod;\n}\n\nint32_t main(){\n    fac[0] = 1;\n\n\tfor(int i=1;i<N;i++) {\n        fac[i]=(fac[i-1]*i)%mod;\n\t}\n\tfor(int i=0;i<N/2;i++) {\n        fm[i]=power(fac[i],mod-2);\n\t}\n\tll n;\n\tcin >> n;\n\tll ans=power(3,n);\n\tfor (int i=n/2+1;i<=n;i++){\n        ans-=ent(i,n)*power(2,n-i)*2%mod;\n        ans+=mod;\n        ans%=mod;\n\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pp pair<int,int>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define ll long long\n#define all(a) (a).begin(),(a).end()\n#define mk make_pair\nll mod=1000000007;\nll MOD=998244353;\nint inf=1000001000;\nll INF=10000000000000000;\n\nvoid Add(int &a, int b) {\n  a += b;\n  while (a >= MOD) a -= MOD;\n  while (a < 0) a += MOD;\n}\n \nvoid Mul(int &a, int b) {\n  a = 1LL * a * b % MOD;\n}\n \nint Pow(int b, int e) {\n  if (e < 0) e += MOD - 1;\n  int ret = 1;\n  while (e) {\n    if (e & 1) ret = 1LL * ret * b % MOD;\n    b = 1LL * b * b % MOD;\n    e >>= 1;\n  }\n  return ret;\n}\n \nnamespace Math {\n  const int NMAX = (int)1e7;\n  int pow2[1 + NMAX];\n  int fact[1 + NMAX], tcaf[1 + NMAX];\n  void Precalc() {\n    fact[0] = pow2[0] = 1;\n    for (int i = 1; i <= NMAX; ++i) {\n      pow2[i] = pow2[i - 1];\n      Add(pow2[i], pow2[i]);\n \n      fact[i] = fact[i - 1];\n      Mul(fact[i], i);\n    }\n    tcaf[NMAX] = Pow(fact[NMAX], -1);\n    for (int i = NMAX - 1; i >= 0; --i) {\n      tcaf[i] = tcaf[i + 1];\n      Mul(tcaf[i], i + 1);\n      assert(1LL * fact[i] * tcaf[i] % MOD == 1);\n    }\n  }\n  int Choose(int n, int k) {\n    if (k > n || n < 0) return 0;\n    return 1LL * fact[n] * tcaf[n - k] % MOD * tcaf[k] % MOD;\n  }\n};\n\nint main(){\n    Math::Precalc();\n    ll n;\n    cin >> n;\n    ll ans=Pow(3,n);\n    rep(i,n/2){\n        ans=(ans+2*MOD-(2LL*Pow(2,i)*Math::Choose(n,i)%MOD))%MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modPow(long long a, long long p){\n    if(p == 0) return 1;\n    auto res = modPow(a, p/2);\n    res = (res*res)%MOD;\n    if(p%2) res = (res*a)%MOD;\n    return res;\n}\n\nlong long calcInv(long long a){\n    return modPow(a, MOD-2);\n}\n\nint main(){\n    const int maxSize = 10000001;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    int N;\n    while(cin >> N){\n        long long res = modPow(3, N);\n        for(int i=N/2+1;i<=N;i++){\n            long long sub = comb(N, i) * modPow(2, N-i);\n            res = (res + MOD - 2 * sub % MOD) % MOD;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 998244353;\n\nvector<ll> fact{1};\nll fast_pow(ll x, ll p) {\n\tll r = 1;\n\twhile (p) {\n\t\tif (p & 1) r = (r * x) % MOD;\n\t\tx = (x * x) % MOD;\n\t\tp /= 2;\n\t}\n\treturn r;\n}\nll inv(ll x) {\n\treturn fast_pow(x, MOD - 2);\n}\nll mul(ll a, ll b) {\n\treturn (a * b) % MOD;\n}\nll binom(ll n, ll k) {\n\treturn (fact[n] * inv((fact[n - k] * fact[k]) % MOD)) % MOD;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tint n;\n\tscan n;\n\tfor (int i = 1; i < 10000; i++) {\n\t\tfact.pb((i * fact.back()) % MOD);\n\t}\n\t// for (int i = 2; i < 100; i += 2) {\n\t\t// n = i;\n\t\tll rez = fast_pow(3, n);\n\t\tfor (int x = n / 2 + 1; x <= n; x++) {\t\n\t\t\trez -= 2 * ((binom(n, x) * fast_pow(2, n - x)) % MOD);\n\t\t\trez %= MOD;\n\t\t}\n\t\tif (rez < 0) rez += MOD;\n\t\t// for (int y = 0; y <= n / 2; y++) {\n\t\t// }\n\t\tprint rez;\n\t\t// print \"f(\", n / 2, \")=\", rez,\",\";\n\t\t// fflush(stdout);\n\t// }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\nusing namespace std;\n\n\nconst ll MOD = 998244353;\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\n\nint n;\nconst int N = 1e7 + 10;\n\nll fc[N];\nll bfc[N];\n\nll cnk(int n, int k) {\n    return fc[n] * bfc[k] % MOD * bfc[n - k] % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcout.setf(ios::fixed), cout.precision(20);\n    fc[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fc[i] = (fc[i - 1] * i) % MOD;\n    }\n    bfc[N - 1] = pw(fc[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; --i) {\n        bfc[i] = (bfc[i + 1] * (i + 1)) % MOD;\n    }\n\n    cin >> n;\n    ll ans = pw(3, n);\n    for (int i = n / 2 + 1; i <= n; ++i) {\n        ans = (ans - cnk(n, i) * pw(2, 1 + n - i) % MOD + 2 * MOD) % MOD;\n    }\n    cout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\t\n#define WHATS(var)cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\nint xx;\n\nusing ll =long long ;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 10240000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tMod sum=mod_pow(3,N);\n\tMod kk=0;\n\tMod xx=1;\n\tMod x=1;\n\tfor(int i=0;i<=N/2-1;++i){\n\n\t\tkk+=xx*x;\n\t\tx*=Mod(2);\n\t\txx*=N-i;\n\t\txx/=(i+1);\n\t\t//WHATS(kk)\n\t}\n\t//WHATS(kk)\n\tsum=sum-kk*Mod(2);\n\tcout<<sum<<endl;\n\treturn 0;\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int llfExp(long long int a, long long int b){\n\tlong long int ans = 1;\n\twhile(b){\n\t\tif(b & 1) ans = ans * a % 998244353;\n\t\ta = a * a % 998244353;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nlong long int n;\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\tcin>>n;\n\tcout<<llfExp(7, n/2)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nusing Int = long long;\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<Int, Int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},  // 自身\n};\nInt get_msb(long long x) {\n    assert(x != 0);\n    return 63 - __builtin_clzll(x);\n}\nInt get_lsb(long long x) {\n    assert(x != 0);\n    return __builtin_ctzll(x);\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, const vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const set<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const multiset<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n    #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n    #define dump(...)\n    #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct FastIO { FastIO() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); } } fast_io;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr Int MOD = 998244353;\n// **********************************************************************************************\n// **********************************************************************************************\n// **********************************************************************************************\n// **************************************** TEMPLATE END ****************************************\n// **********************************************************************************************\n// **********************************************************************************************\n// **********************************************************************************************\n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n\nsigned main() {\n    Int n; cin >> n;\n    if (n % 2) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<mint> pows(n + 1, 1);\n    REP (i, n) pows[i + 1] = pows[i] * 2;\n    init_factorial(n + 1);\n    mint ans = pow(mint(3), n);\n    REP (x, n / 2) {\n        ans -= comb(n, x) * pows[x] * 2;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\n#define MOD 998244353\nint pow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = (int64_t) res * a % MOD;\n\t\ta = (int64_t) a * a % MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n\tstatic int fact[10000001];\n\tstatic int inv[10000001];\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 10000000; i++) fact[i] = (int64_t) fact[i - 1] * i % MOD;\n\tinv[10000000] = pow(fact[10000000], MOD - 2);\n\tfor (int i = 10000000; i; i--) inv[i - 1] = (int64_t) inv[i] * i % MOD;\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tint res = pow(3, n);\n\tfor (int i = n / 2 + 1; i <= n; i++) {\n\t\tres -= (int64_t) pow(2, n - i) * fact[n] % MOD * inv[i] % MOD * inv[n - i] * 2 % MOD;\n\t\tif (res < 0) res += MOD;\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int MAXN = 1.01e7;\nvll fact (MAXN);\nvll invfact (MAXN);\nvll pow2(MAXN);\nvll inv (MOD);\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    fact[0] = 1;\n    FOR(i, 1, N+1) fact[i] = fact[i-1] * i % MOD;\n\n    inv[1] = 1;\n    FOR(i, 2, MOD) inv[i] = (MOD - (MOD/i) * inv[MOD%i] % MOD) % MOD;\n\n    invfact[0] = 1;\n    FOR(i, 1, N+1) invfact[i] = invfact[i-1] * inv[i] % MOD;\n\n    pow2[0] = 1;\n    FOR(i, 1, N+1) pow2[i] = 2 * pow2[i-1] % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * pow2[N-i];\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/indexed.hpp>\n\nusing namespace std;\nusing namespace boost::adaptors;\nusing namespace std::string_literals;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing boost::irange;\n\nconstexpr ll MOD = 998244353;\n\n// a^-1 mod p\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nint main()\n{\n  ll n;\n  cin>>n;\n  vecll fact(n+1, 0);\n  fact[0] = 1;\n  for (ll i:irange(0l, n)) {\n    fact[i+1] = fact[i] * (i+1) % MOD;\n  }\n  vecll finv(n+1, 0);\n  finv.back() = inv(fact.back(), MOD);\n  for (ll i=n-1; i>=0; --i) {\n    finv[i] = finv[i+1] * (i+1) % MOD;\n  }\n  vecll pow2(n+1, 0);\n  pow2[0] = 1;\n  for (ll i:irange(0l, n)) {\n    pow2[i+1] = 2 * pow2[i] % MOD;\n  }\n  ll sub = 0;\n  ll half = n/2;\n  for (ll i:irange(half+1, n+1)) {\n    ll comb = fact[n] * finv[i] % MOD * finv[n-i] % MOD;\n    sub += comb * pow2[n-i] % MOD;\n    sub %= MOD;\n  }\n  sub *= 2;\n  sub %= MOD;\n  ll pow3 = 1;\n  for (ll i:irange(0l, n)) {\n    pow3 *= 3;\n    pow3 %= MOD;\n  }\n  ll ans = pow3 + (MOD - sub);\n  ans %= MOD;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static const int MOD = 998244353;\n\n    ll v;\n    modint(const int _v = 0): v(_v % MOD) {\n        if (v < 0) v += MOD;\n    }\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = 1LL * v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint(v) += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint(v) -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint(v) *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint(v) /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res = 1;\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nconstexpr int MAXN = 1e5;\nmodint fact[MAXN], tcaf[MAXN];\n\nvoid gen_fact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    tcaf[MAXN - 1] = modint(1) / fact[MAXN - 1];\n    for (int i = MAXN - 2; i >= 0; --i) {\n        tcaf[i] = tcaf[i + 1] * (i + 1);\n    }\n}\n\nmodint choose(int n, int k) {\n    assert(n >= 0);\n    if (k < 0 or n < k)\n        return 0;\n\n    return fact[n] * tcaf[k] * tcaf[n - k];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(3, n);\n    modint cur = 0;\n    modint term = 1;\n    modint p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= (n - k + 1);\n        term *= k;\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n#define dub long double\n#define FOR(i, a, b) for (int i=(a); i<(b); ++i)\n#define ROF(i, a, b) for (int i=(a); i>(b); --i)\n#define CASET int _T; cin >> _T; FOR(caset, 0, _T)\n#define pii pair<int,int>\n#define t3i tuple<int,int,int>\n#define mii map<int,int>\n#define vi vector<int>\n#define vb vector<bool>\n#define vs vector<string>\n#define vvi vector<vi>\n#define vvb vector<vb>\n#define vvvi vector<vvi>\n#define vvvb vector<vvb>\n#define vpii vector<pii>\n#define vt3i vector<t3i>\n#define vvpii vector<vpii>\n#define sq(x) (x)*(x)\n#define inv(x) powa(x, MOD-2)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define SIZE(x) (signed)(x).size()\n#define SUM(x) accumulate(ALL(x), 0LL)\n \nlong long INF = 1LL<<60;\nlong long MOD = 998244353;\n \nnamespace output {\n    void pr(short x) { cout << x; }\n    void pr(signed x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(long long x) { cout << x; }\n    void pr(unsigned short x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(long double x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { cout << x; }\n    template<size_t sz> void pr(const bitset<sz>& x) { cout << x; }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T1, class T2, class T3> void pr(const tuple<T1,T2,T3>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { pr(\"(\",x.first,\", \",x.second,\")\"); }\n    template<class T1, class T2, class T3> void pr(const tuple<T1,T2,T3>& x) { pr(\"(\",get<0>(x),\", \",get<1>(x),\", \",get<2>(x),\")\"); }\n    template<class T> void pr(const T& x) { \n        pr(\"[\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"]\");\n    }\n    \n    void print() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void print(const T& t, const Ts&... ts) { pr(t); if (sizeof...(ts)) pr(\" \"); print(ts...); }\n}\nusing namespace output;\n \ntemplate <class T1, class T2> istream &operator>>(istream &is, pair<T1,T2> &x) { is >> x.first >> x.second; return is; }\ntemplate <class T1, class T2, class T3> istream &operator>>(istream &is, tuple<T1,T2,T3> &x) { is >> get<0>(x) >> get<1>(x) >> get<2>(x); return is; }\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }\nint powa(int base, int exp) {\n    int res = 1;\n    while (exp) {\n        if (exp&1) res = res*base % MOD;\n        base = base*base % MOD;\n        exp >>= 1;\n    }\n    return res;\n}\nbool mini(int &a, int b) { return b < a ? a = b, 1 : 0; }\nbool maxi(int &a, int b) { return b > a ? a = b, 1 : 0; }\n\nmain() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    \n    int n;\n    cin >> n;\n    int h = n >> 1;\n\n    vi fact(n+1), invfact(n+1);\n    fact[0] = 1;\n    FOR(i, 1, n+1) fact[i] = i * fact[i-1] % MOD;\n    invfact[n] = inv(fact[n]);\n    ROF(i, n-1, -1) invfact[i] = (i+1) * invfact[i+1] % MOD;\n    vi tk(n+1);\n    tk[0] = 1;\n    FOR(i, 1, n+1) tk[i] = 2 * tk[i-1] % MOD;\n\n    auto nCr = [&](int n, int r) {\n        if (r < 0 || r > n) return 0LL;\n        return fact[n] * invfact[r] % MOD * invfact[n-r] % MOD;\n    };\n\n    int res = powa(3, n);\n    int sub = 0;\n    FOR(i, h+1, n+1) {\n        sub = (sub + (nCr(n, i)*tk[n-i] % MOD)) % MOD;\n    }\n    sub = 2 * sub % MOD;\n    res = (res - sub + MOD) % MOD;\n    print(res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//#include \"math/modulo.h\"\n\ntemplate<class T, T M>\nstruct modulo {\n\tT n;\n\tmodulo(T n): n(n<0? n%M+M: n%M)   { }\n\toperator T() const                { return n;             }\n\tmodulo operator-()                { return modulo(-n);    }\n\tmodulo operator+(const modulo &o) { return modulo(n+o.n); }\n\tmodulo operator-(const modulo &o) { return modulo(n-o.n); }\n\tmodulo operator*(const modulo &o) { return modulo(n*o.n); }\n\tbool operator< (const modulo &o) const { return n< o.n; }\n\tbool operator<=(const modulo &o) const { return n<=o.n; }\n\tbool operator> (const modulo &o) const { return n> o.n; }\n\tbool operator>=(const modulo &o) const { return n>=o.n; }\n\tbool operator==(const modulo &o) const { return n==o.n; }\n\tbool operator!=(const modulo &o) const { return n!=o.n; }\n\n\tfriend modulo pow(const modulo &x, T n) {\n\t\tif (n==0) return 1;\n\t\tmodulo y = pow(x, n/2);\n\t\ty = y*y;\n\t\tif (n%2) y = y*x;\n\t\treturn y;\n\t}\n\n\tmodulo inv() {\n\t\treturn pow(this, M-2);\n\t}\n\n\tT gcd_ext(T a, T b, T *x, T *y) {\n\t\tif (a == 0) {\n\t\t\t*x = 0;\n\t\t\t*y = 1;\n\t\t\treturn b;\n\t\t}\n\t\tT x1, y1;\n\t\tT gcd = gcd_ext(b%a, a, &x1, &y1);\n\t\t*x = y1 - (b/a) * x1;\n\t\t*y = x1;\n\t\treturn gcd;\n\t}\n\tmodulo operator/(const modulo &o) {\n\t\tT x, y;\n\t\tT g = gcd_ext(o.n, M, &x, &y);\n\t\tif (g != 1) return 0;\n\t\telse return modulo(n * (x % M));\n\t}\n\tfriend ostream &operator<<(ostream &os, const modulo &x) {\n\t\treturn os << x.n;\n\t}\n};\n\ntypedef modulo<long,998244353> T;\n//#include \"math/comb.h\"\n\nvoid comb_inc_k(T &r, int n, int &k) {\n        //C(n,k+1) = C(n,k) * (n-k) / (k+1)\n\tr = r * T(n-k) / T(k+1);\n\tk++;\n}\n\nvoid comb_dec_k(T &r, int n, int &k) {\n        //C(n,k-1) = C(n,k) * k / (n-k+1)\n\tr = r * T(k) / T(n-k+1);\n\tk--;\n}\n\nvoid comb_inc_n(T &r, int &n, int k) {\n        //C(n+1,k) = C(n,k) * (n+1) / (n+1-k)\n\tr = r * T(n+1) / T(n+1-k);\n\tn++;\n}\n\nvoid comb_dec_n(T &r, int &n, int k) {\n        //C(n-1,k) = C(n,k) * (n-k) / n\n\tr = r * T(n-k) / T(n);\n\tn--;\n}\n\nT comb(int n, int k) {\n    if (k*2 > n) k = n-k;\n    if (n==0) return 0;\n    T r = 1; //C(n,0)\n    int i = 0;\n    while (i<k) comb_inc_k(r, n, i);\n    return r;\n}\n\n\n#define MAXN 100000\n\nint n;\n\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\treturn 1;\n}\n\nvoid init() {\n}\n\nint solve() {\n\tT r = pow(T(3), n);\n\tint k = n/2;\n\tT e = comb(n, k);\n\twhile (k+1<=n) {\n\t\tcomb_inc_k(e, n, k);\n\t\tr = r - e*pow(T(2), n-k)*T(2);\n\t}\n\treturn r;\n}\n\nvoid output(int ans) {\n\tprintf(\"%d\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 10000008\n#define int long long \n#define mod 998244353\nint f[nn],rf[nn];\nint qpow(int x,int y=mod-2){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nint n;int p2[nn];\nint C(int x,int y){\n\treturn f[x]*rf[y]%mod*rf[x-y]%mod;\n}\nsigned main(){\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1]);\n\tfor(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\t\n\tp2[0]=1;for(int i=1;i<nn;i++) p2[i]=p2[i-1]*2%mod;\n\t\n\tcin>>n;\n\t\n\tint ans=qpow(3,n);\n\tfor(int i=n/2+1;i<=n;i++){\n\t\tans-=C(n,i)*p2[n-i+1];\n\t\tans%=mod;\n\t}\n\tans+=mod;ans%=mod;cout<<ans%mod;\n\t\n\t\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//by Judge\n#define HGS_AK_IOI true\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define Rg register\n#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nconst int M=1e7+3;\ntypedef int arr[M];\nchar buf[1<<21],*p1=buf,*p2=buf;\nint n,ans; arr pw2,fac,inv;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\ninline void Pls(int& x,int y){if((x+=y)>=mod)x-=mod;}\ninline int qpow(int x,int p=mod-2){ Rg int s=1;\n\tfor(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;\n}\ninline int C(int n,int m){ return mul(fac[n],mul(inv[m],inv[n-m])); }\nint main(){ cin>>n,pw2[0]=fac[0]=1,ans=qpow(3,n);\n\tfp(i,1,n) pw2[i]=mul(pw2[i-1],2),fac[i]=mul(fac[i-1],i);\n\tinv[n]=qpow(fac[n]); fd(i,n,1) inv[i-1]=mul(inv[i],i);\n\tfp(i,0,(n-1)>>1) Pls(ans,mod-mul(pw2[i+1],C(n,n-i))); return !printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nconst ll mo=998244353;\nint ret=0;\nint p2[10101010];\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=11400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\t\n\tll ret=1;\n\tp2[0]=1;\n\tFOR(i,N) {\n\t\tret=ret*3%mo;\n\t\tp2[i+1]=p2[i]*2%mo;\n\t}\n\tFOR(i,N+1) if(i*2>N) {\n\t\tll pat=comb(N,i)*p2[N-i]%mo;\n\t\tret-=pat*2;\n\t}\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 5000000;\ndouble Pi = 3.1415926535897932384626;\n \nvector<ll> G[550010];\n//vector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n\nll mod = 998244353;\n//ll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k,idx,ans;\nll x[500005],y[500005],z[500005];\nchar s[500005];\nll dp[5000005];\nll dpsum[5000005];\nll rui_table[5000005];\n\nint main(){\n    cin >> n;\n    c3_init();\n    for(int i=0;i<=n / 2;i++){\n        dp[i] = c3(n / 2, i);\n        dpsum[i] = dp[i];\n    }\n    ll ruih = rui(2ll, 100);\n    rui_table[0] = 1;\n    for(int i=1;i<=n/2;i++){\n        rui_table[i] = 2 * rui_table[i-1];\n        rui_table[i] %= mod;\n    }\n    for(int i=0;i<=n / 2;i++){\n        dpsum[i] *= rui_table[n/2 - i];\n        dpsum[i] %= mod;\n    }\n    for(int i=n / 2;i>=1;i--){\n        dpsum[i-1] += dpsum[i]; \n        dpsum[i-1] %= mod;\n    }\n\n    for(int i=0;i<=n / 2;i++){\n        num = dp[i] * dpsum[n / 2 - i + 1];\n        num %= mod;\n        num *= rui_table[n/2 - i];\n        num %= mod;\n        ans += num;\n        ans %= mod;\n        //p(ans);\n    }\n    ans *= 2;\n    ans %= mod;\n    ans = rui(3ll, n) - ans + mod;\n    ans %= mod;\n    p(ans);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include<bits/extc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vector<ll>>;\nconst ll mod = 998244353;\nusing oset = tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nll fact[10001001], inv[10001001], p3[10001001];\nll bp(ll a, ll p) {\n\tll res = 1;\n\twhile(p) {\n\t\tif(p&1) res = (res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\nll nck(ll n, ll k) {\n\tll res = (fact[n]*inv[k])%mod;\n\treturn (res*inv[n-k])%mod;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tll n;\n\tcin >> n;\n\tfact[0]= p3[0] = 1;\n\tfor(int i = 1; i <= 10000000; i++)\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\tinv[10000000]=bp(fact[10000000], mod-2);\n\tfor(int i = 10000000; i--;)\n\t\tinv[i] = (inv[i+1]*(i+1))%mod;\n\tfor(int i = 1; i <= 10000000; i++)\n\t\tp3[i] = (p3[i-1]*2)%mod;\n\tll ans = bp(3, n);\n\tfor(ll x = (n/2)+1; x <= n; x++) {\n\t\tans = (mod+ans - (2ll*p3[n-x]*nck(n, x))%mod)%mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 998244353;\n\nll todeg(ll k, ll deg) {\n    ll deg0 = deg;\n    if (deg == 0) {\n        return 0;\n    }\n    if (deg == -1) {\n        deg = mod - 2;\n    }\n    ll ans = 1;\n    for (int i = 32; i >= 0; --i) {\n        ans *= ans;\n        ans %= mod;\n        if ((deg >> i) & 1) {\n            ans *= k;\n            ans %= mod;\n        }\n    }\n    /*while (deg > 1) {\n        ans *= ans;\n        ans %= mod;\n        if (deg % 2 == 1) {\n            ans *= k;\n            ans %= mod;\n        }\n        deg /= 2;\n    }*/\n    //cout << k << \"^\" << deg0 << \"=\" << ans << '\\n';\n    return ans;\n}\n\n\n\nint main()\n{\n    ll n;\n    cin >> n;\n    ll f = 1;\n    ll cur2 = 1, curc = 1;\n    for (int k = 1; k * 2 < n; ++k) {\n        cur2 = (cur2 * 2) % mod;\n        curc = (((curc * (n - k + 1)) % mod) * todeg(k, -1)) % mod;\n        //cout << k << \": \" << cur2 << \", \" << curc << '\\n';\n        f += (cur2 * curc) % mod;\n        f %= mod;\n    }\n    ll ans = todeg(3, n);\n    ans -= 2 * f;\n    while(ans < 0) {\n        ans += mod;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define fi first\n#define se second\n#define mp make_pair\n#define itrfor(itr,A) for(auto itr = A.begin(); itr !=A.end();itr++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long llong;\nchar moji[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\nchar moji2[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};\nchar moji3[10]={'0','1','2','3','4','5','6','7','8','9'};\n#define Sort(a) sort(a.begin(),a.end());\n#define Reverse(a) reverse(a.begin(),a.end());\n#define print(a) cout << a << endl;\n#define MOD llong(998244353)\n#define MAX int(2 * 1e5 +5)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define pi acos(-1.0)\n#define int llong\n#define INF llong(1e18 + 3)\ntemplate<class T> bool chmax(T &a,  T b) {if(a<b){a=b; return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,  T b) {if(a>b){a=b; return 1;} return 0;}\nbool Add(int &a,int b){a = (a + b) % MOD;}\nvoid myprint(int* A,int A_num){\n   REP(i,A_num) cout << A[i] << \" \";\n   cout << endl;\n}\n\n\nllong bek(llong a,llong x){\n    llong res = 1;\n    llong tmp = a;\n    while(x > 0){\n        if(x & 1) res *= tmp; res %= MOD;\n        tmp *= tmp;\n        tmp %= MOD;\n        x >>=1;\n    }\n    return res;\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n    int zentai = 1;\n    REP(i,n){\n        zentai *= 3;\n        zentai %= MOD;\n    }\n    int beki = 1;\n    REP(i,n/2){\n        beki *= 2;\n        beki %= MOD;\n    }\n\n\n    int hidari, migi;\n    hidari = 1;\n    migi = 0;\n    int ans = 0;\n    int beki2 = 1;\n    int gyaku2 = bek(2,MOD - 2);\n    FOR(i,1,n / 2 + 1){\n        int huga = hidari * beki2;\n        huga %= MOD;\n        migi += huga;\n        migi %= MOD;\n\n        beki2 *= 2;\n        beki2 %= MOD;\n\n        hidari *= n / 2 + 1 - i;\n        hidari %= MOD;\n        hidari *= bek(i,MOD - 2);\n        hidari %= MOD;\n       \n        beki *= gyaku2;\n        beki %= MOD;\n        int hoge = migi * hidari;\n        hoge %= MOD;\n        hoge *= beki;\n        hoge %= MOD;\n        ans += hoge;\n        ans %= MOD;\n    }\n\n    cout << (zentai + 2 * MOD - 2 * ans ) % MOD << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 998244353\n#define MAX 10010101\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n// fac[i] i!\n// finv[i] i!の逆元\n// inv[i] iの逆元\n\n// テーブルを作る前処理\nvoid COM_init(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N;\n  cin>>N;\n  COM_init();\n  \n  ll POW2[MAX],POW3[MAX];\n  POW2[0]=1,POW3[0]=1;\n  RREP(i,MAX-1){\n    POW2[i]=POW2[i-1]*2%MOD;\n    POW3[i]=POW3[i-1]*3%MOD;\n  }\n  \n  ll ans=POW3[N],cnt=0;\n  for(ll i=N/2+1; i<=N; ++i){\n    cnt+=COM(N,i)*POW2[N-i]%MOD;\n    cnt%=MOD;\n  }\n  \n  ans=ans-cnt*2;\n  ans%=MOD;\n  if(ans<0) ans+=MOD;\n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e7 + 10;\nconst int M = 998244353;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[N], rfact[N];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (ll) i * fact[i - 1] % M;\n    }\n    rfact[N - 1] = pw(fact[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        rfact[i] = (ll) (i + 1) * rfact[i + 1] % M;\n    }\n}\n\nint naive(int n) {\n    n >>= 1;\n\n    int ans = 0;\n    fori (a0, n + 1) {\n        fori (b0, n - a0 + 1) {\n            int c0 = n - a0 - b0;\n            fori (a1, n + 1) {\n                fori (b1, n + 1 - a1) {\n                    int c1 = n - a1 - b1;\n                    bool ok = 1;\n                    ok &= max(0, a0 - a1) + max(0, b0 - b1) <= c1;\n                    ok &= max(0, a1 - a0) + max(0, b1 - b0) <= c0;\n                    if (ok) {\n                        int cur = (ll) fact[n] * rfact[a0] % M * rfact[b0] % M * rfact[c0] % M;\n                        cur = (ll) cur * fact[n] % M * rfact[a1] % M * rfact[b1] % M * rfact[c1] % M;\n                        ans = (ans + cur) % M;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nvoid insum(int & a, int b) {\n    a = (a + b) % M;\n}\n\nint solve(int n) {\n    n >>= 1;\n\n    int ans = pw(3, n * 2);\n    for (int x = n + 1; x <= n * 2; ++x) {\n        int cur = 2LL * ncr(n * 2, x) * pw(2, n * 2 - x) % M;\n        ans = (ans + M - cur) % M;\n    }\n    return ans;\n}\n\nvoid smain() {\n    init();\n    int n;\n    cin >> n;\n\n\n//    cout << naive(n) << endl;\n    cout << solve(n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_N 10000000\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int MOD = 998244353;\n\nint n;\n\nlint putere(int a, int b)\n{\n    lint rez = 1;\n    lint ca = a;\n    for(int i = 0; (1 << i) <= b; i ++)\n    {\n        if(((1 << i) & b) != 0)\n        {\n            rez *= ca;\n            rez %= MOD;\n        }\n\n        ca *= ca;\n        ca %= MOD;\n    }\n\n    return rez;\n}\n\nlint p2[MAX_N + 1];\nlint fact[MAX_N + 1];\nlint inv[MAX_N + 1];\n\nvoid euclid(lint a, lint b, lint &x, lint &y, lint &d)\n{\n    if(b == 0)\n    {\n        x = 1;\n        y = 0;\n\n        d = a;\n        return;\n    }\n\n    lint xx, yy, q = a / b;\n    euclid(b, a % b, xx, yy, d);\n    x = yy;\n    y = xx - yy * q;\n}\n\nlint comb(int n, int k)\n{\n    return (fact[n] * inv[k] % MOD * inv[n - k] % MOD);\n}\n\nint main()\n{\n    cin >> n;\n\n    p2[0] = 1;\n    fact[0] = 1;\n    for(int i = 1; i <= n; i ++)\n    {\n        p2[i] = (p2[i - 1] << 1) % MOD;\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n\n    lint x, y, d;\n    euclid(fact[n], MOD, x, y, d);\n    if(x < 0)\n        x = MOD + x % MOD;\n\n    //cout << fact[n] << \" \" << x << \"\\n\";\n    //cout << fact[n] * x % MOD << \"\\n\";\n\n    inv[0] = 1;\n    inv[n] = x;\n    for(int i = n - 1; i >= 1; i --)\n        inv[i] = inv[i + 1] * (i + 1) % MOD;\n\n        cout << inv[1] << \"\\n\";\n\n    lint rez = putere(3, n);\n    lint sum = 0;\n    for(int i = (n >> 1) + 1; i <= n; i ++)\n    {\n      //  cout << n << \" \" << i << \" \" << comb(n, i) << \" \" << p2[n - i] << \"\\n\";\n        sum += comb(n, i) * p2[n - i] % MOD;\n        if(sum >= MOD)\n            sum -= MOD;\n    }\n\n    rez = rez - (sum << 1);\n    while(rez < 0)\n        rez += MOD;\n\n    cout << rez << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 1e7;\nconst ll mod = 998244353;\n\nll n, m, k, t;\n\nll st2[maxn];\n\nll F[maxn];\n\nll RF[maxn];\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;  \n}\n\ninline ll getc(ll n, ll k) {\n    return F[n] * RF[k] % mod * RF[n - k] % mod;\n}\n\ninline ll wrong(ll a1) {\n    // ll mul = st2[n / 2 - a1];\n    ll goal = n / 2 - a1 + 1;\n    // cout << \"GOAL \" << goal << endl;\n    ll sum = getc(n / 2, goal) * st2[n / 2 - goal] % mod;\n    // cout << \"SUM \" << \" \" << sum << endl;\n    ll ans = sum;\n    // cout << \"WRONG \" << a1 << \" \" << ans << endl << endl;;\n    return ans;\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    F[0] = RF[0] = 1;\n    for (q = 1; q < maxn; q++) {\n        F[q] = F[q - 1] * q % mod;\n    }\n    RF[maxn - 1] = del(1, F[maxn - 1]);\n    for (q = maxn - 2; q >= 0; q--) {\n        RF[q] = RF[q + 1] * (q + 1) % mod;\n    }\n    cin >> n;\n    st2[0] = 1;\n    for (q = 1; q < maxn; q++) {\n          st2[q] = st2[q - 1] * 2 % mod;\n    }\n    ll ans = step(3, n);\n    ll dans = 0;\n    ll cursum = 0;\n    for (q = 1; q <= n / 2; q++) {\n        ll ddans = wrong(q);\n        ll mul = st2[n / 2 - q] * getc(n / 2, q) % mod;\n        cursum += ddans;\n        cursum %= mod;\n        dans += cursum * mul % mod;\n        // cout << \"CURSUM mul \" << cursum << \" \" << mul << endl << endl;; \n        dans %= mod;\n    }\n    // cout << dans << \" DANS\" << endl;\n    ans = (ans - 2 * dans + mod * 4) % mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  if(p==-1){\n    while(b>0){\n      if(b%2) ret *= num;\n      num = num * num;\n      b /= 2;\n    }\n  }else{\n    while(b>0){\n      if(b%2) ret = (ret*num)%p;\n      num = (num*num)%p;\n      b /= 2;\n    }\n  }\n  return ret;\n}\nint main(int argc, char const *argv[]) {\n  init();\n  ll n;std::cin >> n;\n  ll ans = mpow(3, n, P);\n  ll sub = 0;\n  for(ll i=n/2+1;i<=n;i++){\n    ll tmp = comb(n, i);\n    tmp = (tmp * mpow(2, n-i, P))%P;\n    sub = (sub + tmp)%P;\n  }\n  // 3^n -\n  std::cout << (ans-(2*sub)%P+P)%P << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 10200000, mo = 998244353;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint n,fac[N],ifac[N],qz[N],mi[N],v[N];\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\ninline int C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint main() {\n\tread(n);iniC(n);int res=1;rep(i,1,n)res=3LL*res%mo;\n\tmi[0]=1;rep(i,1,n)mi[i]=2*mi[i-1]%mo;\n\trep(i,0,n/2)v[i]=1LL*C(n/2,i)*mi[i]%mo,qz[i]=qz[i-1],add(qz[i],v[i]);\n\trep(i,0,n/2-1)res=(res-2LL*v[i]*qz[n/2-i-1])%mo;\n\tcout<<(res+mo)%mo;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse2,avx,avx2,fma\")\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\n//long long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    //fact[0] = 1;\n    //long long factN = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        //factN = (factN*i)%MOD;\n        //fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += (((tempPow2*invFact[N-i])%MOD) * invFact[i])%MOD;\n\n        tempPow2 <<= 1;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n\n    long long factN = powmod(invFact[N], MOD-2);\n\n    ans = (ans+ans)%MOD;\n    ans = ans*factN%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef loc\n    #include \"../codes/loc_debug.h\"\n#else\n    #include <bits/stdc++.h>\n    #define pr(...)\n    #define pra(a,n)\n    #define praa(a,n,m)\n    #define prl()\n#endif\nusing namespace std;\n\ntypedef long long ll;\n#define sz(a) int(a.size())\nconst int N = 100005;\n\nint mod = 998244353;\nint po(int x, int y) {\n    int ret = 1;\n    while(y > 0) {\n        if(y & 1) {\n            ret = (ret * (ll)x) % mod;\n        }\n        x  = (x * (ll)x) % mod;\n        y /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    int tot = 1;\n    for(int i = 1; i <= n; i++) {\n        tot = (tot * (ll)3) % mod;\n    }\n    int cur = 1;\n    tot -= 2;\n    for(int i = 1; i < n / 2; i++) {\n        cur = (cur * (ll)2) % mod;\n        cur = (cur * (ll)(n - i + 1)) % mod;\n        cur = (cur * (ll)po(i, mod - 2)) % mod;\n        tot -= cur;\n        if(tot < 0) {\n            tot += mod;\n        }\n        tot -= cur;\n        if(tot < 0) {\n            tot += mod;\n        }\n    }\n    cout << tot << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<998244353>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=2e7; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nint main(void) {\n    ll n;\n    cin >> n;\n\n    mint ret = mint(3).pow(n);\n    FOR(i, n/2+1, n+1) ret -= combi(n, i) * mint(2).pow(n-i+1);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "s"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\n// const long long MOD=1e9+7;\nconst long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    os << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\npublic:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\ntemplate<class M>\nstruct Combination{\n    vector<M> _fac,_inv,_finv;\n    Combination(int n):_fac(n+1),_inv(n+1),_finv(n+1){\n        _fac[0]=_finv[n]=_inv[0]=1;\n        for (int i=1;i<=n;++i) _fac[i]=_fac[i-1]*i;\n        _finv[n]/=_fac[n];\n        for (int i=n-1;i>=0;--i) _finv[i]=_finv[i+1]*(i+1);\n        for (int i=1;i<=n;++i) _inv[i]=_finv[i]*_finv[i-1];\n    }\n    M fac(int k) const {return _fac[k];}\n    M finv (int k) const {return _finv[k];}\n    M inv(int k) const {return _inv[k];}\n    M P(int n,int r) const {\n        if (n<0||r<0||n<r) return 0;\n        return _fac[n]*_finv[n-r];\n    }\n    M C(int n,int r) const {\n        if (n<0||r<0||n<r) return 0;\n        return _fac[n]*_finv[r]*_finv[n-r];\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX_N=1e7+10;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Combination<mint> COM(MAX_N);\n    int N; cin >> N;\n\n    int n=N/2;\n    vector<mint> dp(n+1),sum(n+1,0);\n    for (int i=0;i<=n;++i) dp[i]=COM.C(n,i)*pow((mint)2,n-i);\n    sum[n]=dp[n];\n    for (int i=n-1;i>=0;--i) sum[i]=sum[i+1]+dp[i];\n    mint ans=pow((mint)3,N);\n    for (int i=1;i<=n;++i) ans-=dp[i]*sum[n+1-i]*2;\n\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long \nusing namespace std;\n\nconst int maxn=1e7+10;\nconst int mod=998244353;\nint n;\nll poww(ll x,ll k) {\n\tll ans=1;\n\twhile(k) {\n\t\tif(k&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nll mul[maxn],inv[maxn],er[maxn],ans;\nll C(int a,int b) {\n\treturn mul[a]*inv[b]%mod*inv[a-b]%mod;\n}\nll QwQ;\nint main() \n{\n\tscanf(\"%d\",&n);\n\tmul[0]=1,er[0]=1;\n\tfor(int i=1;i<=n;++i) mul[i]=mul[i-1]*i%mod,er[i]=er[i-1]*2%mod;\n\tinv[n]=poww(mul[n],mod-2);\n\tfor(int i=n;i;i--) inv[i-1]=inv[i]*i%mod;\n\tinv[0]=1;\n\tfor(int i=n/2+1;i<=n;++i) {\n\t\tQwQ=(QwQ+C(n,i)*er[n-i]%mod)%mod;\n\t}\n\tcout<<(poww(3,n)-QwQ*2%mod+mod)%mod<<\"\\n\";\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e7 + 10, mod = 998244353;\nlong long fac[N];\n\nlong long bpow(long long b, long long e) {\n  long long res = 1;\n  while (e) {\n    if (e & 1) {\n      res *= b;\n      res %= mod;\n    }\n    b *= b;\n    b %= mod;\n    e >>= 1;\n  }\n  return res;\n}\n\nlong long inv(long long x) { return bpow(x, mod - 2); }\n\nlong long C(int n, int k) {\n  // n! / k! / (n - k)!\n  return fac[n] * inv(fac[k]) % mod * inv(fac[n - k]) % mod;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  long long ans = 0;\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;\n  for (int i = n / 2 + 1; i <= n; i++) {\n    // nCi * 2 ^ (n - i)\n    ans += bpow(2, n - i) * C(n, i) % mod;\n    ans %= mod;\n  }\n  ans <<= 1;\n  ans %= mod;\n  // cout << ans << endl;\n  ans = ((bpow(3, n) - ans) % mod + mod) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e7+10;\nLL fac[SIZE],inv[SIZE];\nLL mypow(LL x,LL y){\n    LL res=1;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL C(int x,int y){\n    if(y<0||y>x)return 0;\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nLL two[SIZE];\nvoid build(){\n    assert(MOD>=SIZE);\n    two[0]=1;\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD,two[i]=two[i-1]*2%MOD;\n    inv[SIZE-1]=mypow(fac[SIZE-1],MOD-2);\n    for(int i=SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;\n}\nint main(){\n    MOD = 998244353;\n    build();\n    int N;\n    R(N);\n    LL an=1;\n    REP(i,N)an=an*3%MOD;\n    FOR(i,N/2+1,N){\n        ADD(an,-C(N,i)*2*two[N-i]);\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod\n#define N 10000010\nll fac[N],ivf[N],inv[N];\nll C(ll n,ll k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return fac[n]*ivf[k]%mod*ivf[n-k]%mod;\n}\n\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\nll rui[N];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    fac[0]=ivf[0]=inv[1]=1;\n    for(ll i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-(mod/i*inv[mod%i]%mod))%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    ll n; cin>>n;\n    ll ans=po(3,n);\n    for(ll x=n/2+1;x<=n;x++){\n\tmad(ans,-2*C(n,x)*po(2,n-x)%mod);\n    }\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = /*1'000'000'007LL;*/ 998'244'353LL;\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<long long Mod>\nstruct mint{\n    long long x;\n    mint(long long x=0) :x((x% Mod+Mod)%Mod){}\n\n    mint operator-() const { return mint(-x); }\n\n    mint& operator+=(const mint a) {\n        if((x += a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if((x += Mod-a.x) >= Mod) x -= Mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= Mod;\n        return *this;\n    }\n\n    mint operator^(long long t) const {\n        mint ret(1);\n        mint a = *this;\n        while(t){\n            if(t&1){\n                ret *= a;\n            }\n            a *= a;\n            t >>= 1;\n        }\n        return ret;\n    }\n    mint inv() const { return *this ^ (Mod-2); }\n    mint& operator/=(const mint a) { return *this *= a.inv(); }\n\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n\n    friend istream& operator>>(istream& is, mint& a) { return is >> a.x; }\n    friend ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n};\n\nint N;\n\nbool vis[10000001][3][2] ={};\nmint<MOD> dp[10000001][3][2];\nmint<MOD> solve(int n, int l, int d){ // 0:A, 1:B, 2:otherwise\n    if(n == 2){\n        if(l == 2) return 7;\n        else return 2;\n    }\n    if(vis[n][l][d]) return dp[n][l][d];\n    vis[n][l][d] = true;\n    mint<MOD> ret = 0;\n    // のみ込む\n    if(l != 2) ret += solve(n-2, l^1, 0)*2;\n    if(l == 2) ret += solve(n-2, 0, 0)*2 + solve(n-2, 1, 0)*2;\n    // わける\n    if(d == 0){\n        for(int i=2; n-i>=2; i+=2){\n            ret += solve(i, l, 1) * solve(n-i, 2, 0);\n        }\n    }\n    return dp[n][l][d] = ret;\n}\n\nsigned main(){\n    cin >> N;\n    cout << solve(N, 2, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\nconst int pre[10001] = { 1,777990065,766786010,512513096,705983787,734256002,244148993,533292028,210582481,688517539,215582594,14820617,129246395,150625187,86672976,764239242,21874704,57288446,850657009,774583782,638474417,128284758,786368753,472986042,103549395,495451255,264078536,433635135,625262204,766766525,185226044,35932350,902168850,455715166,218641259,972559028,640480499,206662314,683003246,923831102,876712294,724261094,408525348,763874992,547233394,109140246,300634900,256419515,371584155,276107980,832944090,540250216,893651744,936348937,326512726,516396135,843656716,776879789,359802705,356307409,949283602,121678346,755038370,144825638,398849114,243664371,157125107,752722108,971617941,787502726,951610819,720346213,481304016,361949821,680950950,387120559,575366956,411040690,816984038,668571204,187142323,552289458,722805387,993149209,318238233,904486800,968982693,875054001,578248523,925025550,271818664,509541523,500499768,929802162,849466163,523746388,268604730,311862148,211074478,804711044,373341033,683607517,262864254,899397125,903574757,408123903,570163026,387548298,136310560,757193515,492373922,16092666,218256882,33612616,184219001,645249935,348551228,835533217,302307407,641587141,70007868,840714962,797190974,744571430,180557608,554082240,483244331,924205037,933027896,760946120,890154909,803775227,605185517,868712494,835769462,401208474,689354486,226621123,96687561,38631563,501927483,483249587,593944616,998231222,23528366,842172435,357335185,725982025,398516968,269658881,797725335,59352911,184061655,193546739,303152497,61883255,98078622,195866691,996728981,446353446,796024455,885097692,915829452,732760877,97457057,251606742,829937743,367147609,907175897,989448554,748640136,168580487,42590154,482935433,768160042,31342156,39326209,654029131,72020724,47519485,542991096,876162665,577428803,188685455,233510797,422423143,544780457,613635275,137823240,55715373,97062836,437207675,578565389,794462456,122688768,964014598,148890003,428128959,278232786,996120899,45596018,7163323,387102481,258039391,515773886,830696837,604845763,539553101,384403210,949063076,849317807,630752268,210722610,773591150,869634880,109500248,32144134,224896996,642008315,169507794,283287674,219473392,422410040,174823408,288798151,140807520,497583578,863575707,355648573,272221122,561110485,253470028,580834681,587770974,112220015,850532094,33475427,498807687,317772333,409146882,596316874,331449290,335429501,670238024,900627351,14996190,733198052,307321953,844834750,829096729,400767242,769588955,98032360,560788564,292816061,468314755,983912094,328059458,549942096,45373125,417528165,901294757,895122295,151159745,297548894,203255878,752797429,911093840,496689395,629769991,78939987,459538825,406390137,6879134,257680118,396950159,129807060,715875807,553661506,390811345,191166323,810576750,213045873,942790458,758339094,899444486,309004018,633895784,128589948,937478027,212513874,174345296,62004037,591751261,649329767,366843154,926280101,432150075,354244239,659276328,834980587,136620485,948751335,633318822,299685362,867019421,267600853,697694392,173796099,133939251,167633838,168664055,455355228,509401446,914452079,440577645,29283142,556198383,482874240,923005927,914550501,892014883,550966054,375146890,259320783,391769529,226806694,768163357,300654217,694655521,844638237,661303928,422327106,355635742,489451003,137628974,980318491,361853327,645638169,336599956,688948565,638514939,153383062,889194597,536430068,893849901,923432110,315839722,49382817,516474656,248173708,403609024,833306540,338847731,986694950,790821219,197628535,285108045,285934271,811084650,104964765,243988035,674229619,993956736,147476083,824048109,791673374,111127164,710735456,308066837,815197913,520396119,92412037,174723780,843863210,222304311,70227310,745928328,40367869,201974250,393032085,247592312,302180761,495381981,900779821,42751968,130815209,110950082,445232011,650497384,752109934,369950087,309849396,190399500,497647689,353358328,459852401,546099291,671454973,367352978,623627864,100401244,892602210,941551774,871438080,513287280,28185349,21030930,44275710,449827510,712246343,36889166,383078382,912763782,209588582,66987695,640672435,956971829,371907015,714047850,982424362,437882276,454748600,468777415,226512910,761686008,418711160,679266400,372627958,797779775,242570019,602303606,983737359,585763482,940263818,910024593,182269085,662738675,615426027,638525692,446366139,68263779,710197880,222814184,532876159,24120062,707881939,705340838,809441202,482114351,45768177,722815024,897943079,728188648,339739889,364745005,808452545,151610888,987511783,394592072,407729297,52967962,680043468,502198643,938707127,20993746,222949807,531872391,810935357,892377075,154762272,84787052,486805848,317085134,992754474,195236749,21949307,780187478,413553058,879449557,330880448,81415435,108607930,341779439,784896483,620491631,153641122,534228690,846914883,610414719,232588079,436762323,984600471,75405628,263308959,639543590,265889797,133955315,209305986,554795787,428937595,941877363,184451191,923795936,49525425,312442269,437151206,78919908,325973945,579844487,398204190,422683275,595487166,194914147,918795881,69211505,380683932,530612228,634697067,709623540,897706118,22942978,281839888,735681848,25120123,882619476,174552294,668106640,641839971,777450530,655937896,29612691,76069349,832769992,277055316,877454260,115365802,87835316,262466036,79664056,536236563,425951836,278768863,475769894,90522759,307362605,63204044,648964820,931888706,954449142,938010479,325282066,209053425,396563384,761781696,408508738,591582400,829340326,348639450,905026623,860856448,437296068,435334482,291412970,343673774,828901226,901613695,992541178,920381845,302843711,566172771,736189313,783990843,184030082,33617073,439331499,611136185,574497345,90817591,306143980,945501487,362805859,74284790,641726342,522692857,775884194,549727729,444956677,545075287,892463752,90265520,916637957,178236658,980812214,59569691,932392802,488131279,861287555,954672905,419328334,442819817,357758244,887478702,984290034,939144003,70714661,485961375,177417145,162118962,168070756,174913840,982318186,650727215,846359719,984640166,823933073,243009290,152990121,535790194,842333964,57092875,671223531,933222015,271959156,288003384,421390300,835225795,394537809,243155841,856810726,671154973,919875491,265924126,79436106,994247829,183378915,532312977,641156343,576069340,704676636,14554181,6523850,393621207,962151282,554820476,606567566,540585991,269714976,420527242,902506476,79339328,938346178,906937168,714916297,950663746,924948492,93383124,742471102,96868329,289622464,511596111,892814818,404369049,409642870,925142075,388844266,695178051,924307790,769870823,258352801,37319493,656535362,942160874,643592487,159647979,459668470,339174706,60288630,749230429,137386012,142128101,741523026,932249458,133685955,848166191,971938720,690816329,693509216,256408885,839738215,939641949,589638571,25469448,932714644,275884954,440367728,901736665,872587068,897787042,837977995,499710224,189498332,636546695,512005440,220288536,368285012,522130486,112567128,173590818,787664831,463296900,963431830,585289222,414700630,530772554,520800955,27834666,632926830,108265239,130127802,406984354,885533900,267599206,846568716,925571632,361045177,455835455,631901425,582383970,397418490,902263780,279768062,684207567,555876879,213169731,993545710,281195933,354016936,417452790,325049825,372247494,913454812,229684453,11625560,557539657,158714984,396403031,362573159,559048195,305476857,280520923,172808824,618589023,957745517,507362338,183892698,536827111,136820615,161184916,581288683,788080221,379731237,970234708,512908572,911557655,693532380,75693974,743612959,293425406,460742607,841929891,478466605,131340979,941426392,96506146,734531144,954715348,258071636,267285258,157361051,634098066,847501174,291172701,823316612,287824262,290717927,321615349,597704882,407060168,100064711,40000658,640920375,910618969,5182489,548235654,969546889,238062370,516021134,147732413,370659533,833655840,649202504,283787677,544385077,533215075,245880234,995321109,504089062,527440767,806954080,237670639,972424792,544700093,154025540,542342152,523089929,946800898,320483244,401371823,78384996,62174429,258433535,553295948,127143445,564154450,413488441,991069498,392441240,824132912,514921452,123644879,692841184,618623956,565158616,58529238,150117976,71490068,699156339,333263606,921371650,217507999,741546202,724472787,964898806,817920986,582096713,559153778,903819609,215291535,534168349,488985182,844145821,935050600,371603787,757869745,268970995,792449869,803557966,235112752,659275014,826634010,351488455,176734098,263260251,785552216,299003958,208080760,569058617,360532390,386399723,398762201,33272509,497218769,522181848,976622995,260131094,982778284,77371871,395349740,390214653,531854347,493975992,678229473,574409531,95826270,992726917,458437396,619632461,205161868,549830743,223515902,178482990,310282069,219230309,602291763,929072996,593463923,527802328,636498474,823705589,83857087,778669244,941456377,73301964,898657754,509912480,938900018,435397704,519619493,735044665,265835960,559201172,239826028,312119351,739353209,103208090,135132726,784824707,232832650,736566311,391931702,394509768,469195547,590383266,897215155,458515558,373585170,158729077,952125022,711761227,868405413,226589812,677030475,648757054,454752913,592350159,754968001,137896269,14566430,858673333,60435539,930609495,947940003,321611846,402349796,352034025,951901408,484084529,740021117,952069554,541638394,357815063,74405887,350552020,776016487,155552075,881994814,90947222,26360681,846511130,346814021,447948726,11819857,378653079,716353332,696316282,56457542,302941700,371036503,124047029,390868579,84411314,33882493,204021054,580753084,652653069,601390003,135041016,492401516,817288138,201876905,449498406,264348632,965482620,138310,207110730,107364155,669232095,139014676,180671118,556369147,199407219,671144270,58468077,73314446,890418474,428534311,925456411,262608571,349636135,295201906 };\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = pre[N / 10000];\n\tint n = N / 10000 * 10000;\n\tfor (int i = n + 1; i <= n + N % 10000; i++) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll k = modpow(2, N2 - 1) * ifac[N2] * 2 % mod;\n\trep(i, N2) {\n\t\tk = k * inv2 % mod * (N2 - i) % mod;\n\t\thiku += k * ifac[N2 - i - 1] % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\n#define MOD 1000000007\nint pow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) res = (int64_t) res * a % MOD;\n\t\ta = (int64_t) a * a % MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n\tstatic int fact[10000001];\n\tstatic int inv[10000001];\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 10000000; i++) fact[i] = (int64_t) fact[i - 1] * i % MOD;\n\tinv[10000000] = pow(fact[10000000], MOD - 2);\n\tfor (int i = 10000000; i; i--) inv[i - 1] = (int64_t) inv[i] * i % MOD;\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tint res = pow(3, n);\n\tfor (int i = n / 2 + 1; i <= n; i++) {\n\t\tres -= (int64_t) pow(2, n - i) * fact[n] % MOD * inv[i] % MOD * inv[n - i] * 2 % MOD;\n\t\tif (res < 0) res += MOD;\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\",\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include <random>\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define pb(a) push_back\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define lb(v,n) lower_bound(v.begin(), v.end(), n)\n#define ub(v,n) upper_bound(v.begin(), v.end(), n)\n#define int long long\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\n//#define double long double\n//#define double float\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nconst int MOD = 998244353; int MAX = 10000001;\nconst double pi = acos(-1); const double EPS = 1e-12;\nconst ll INF = 1e18;\n\nlong long fac[10000010], finv[10000010], inv[10000010];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\nvoid solve() {\n\tint N; cin >> N;\n\tMAX = N+1;\n\tCOMinit();\n\tint al = bin_pow(3, N);\n\tint sb = 0;\n\tFOR(k, N / 2 + 1, N + 1) {\n\t\tint tmp = mult(COM(N, k), bin_pow(2, N - k));\n\t\tsb = add(sb, tmp);\n\t}\n\tsb = mult(sb, 2);\n\tal = sub(al, sb);\n\tprint(al);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=998244353,N=10000010;\nint n,jc[N],inv[N],ans,sum[N];\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint C(int a,int b)\n{\n\tif (a<b||b<0) return 0;\n\treturn 1ll*jc[a]*inv[b]%mod*inv[a-b]%mod;\n}\n\nint main()\n{\n\tjc[0]=1;\n\tfor (int i=1; i<N; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tinv[N-1]=quickmi(jc[N-1],mod-2);\n\tfor (int i=N-1; i; i--) inv[i-1]=1ll*inv[i]*i%mod;\n\tscanf(\"%d\",&n),ans=quickmi(3,n),sum[n>>1]=1;\n\tfor (int i=(n>>1)-1,nw=2; i; i--,nw=(nw+nw>=mod?nw+nw-mod:nw+nw)) \n\t\tsum[i]=(sum[i+1]+1ll*nw*C(n>>1,i))%mod;\n\tfor (int i=(n>>1),nw=1; i; i--,nw=(nw+nw>=mod?nw+nw-mod:nw+nw))\n\t\tans=(ans+2ll*(mod-nw)*C(n>>1,i)%mod*sum[(n>>1)+1-i])%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 10555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    ll mul = 1;\n    for (int i = n; i > n / 2; i--) {\n    // for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mul % MOD;\n        mul = mul * 2 % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=998244353;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvector<int>kaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    //if(!kaijo[0])init_fact(2000010);\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    init_fact(20000001);\n    int ans=modpow(3,n);\n    for(int i=n/2+1;i<=n;i++){\n        ans-=comb(n,i)*modpow(2,n-i)*2%mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=10000005;\nconst int mod=998244353;\nint n;\nll inv[max_n];\nint main(){\n    scanf(\"%d\",&n);\n    int k=n/2;\n    ll ans=1;\n    for(int i=1;i<=n;i++)ans=ans*3%mod;\n    inv[1]=1;\n    for(int i=2;i<=n;i++)inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n    ll res=0;\n    ll tmp=1,c=1;\n    for(int i=0;i<k;i++){\n        res+=tmp*c%mod;res%=mod;\n        tmp=tmp*2%mod;\n        c=c*(n-i)%mod*inv[i+1]%mod;\n    }\n    res=res*2%mod;\n    ans=(ans-res+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//#include \"math/modulo.h\"\n\ntemplate<class T, T M>\nstruct modulo {\n\tT n;\n\tmodulo(T n): n(n<0? n%M+M: n%M)   { }\n\toperator T() const                { return n;             }\n\tmodulo operator-() const          { return modulo(-n);    }\n\tmodulo operator+(const modulo &o) const { return modulo(n+o.n); }\n\tmodulo operator-(const modulo &o) const { return modulo(n-o.n); }\n\tmodulo operator*(const modulo &o) const { return modulo(n*o.n); }\n\tbool  operator< (const modulo &o) const { return n< o.n; }\n\tbool  operator<=(const modulo &o) const { return n<=o.n; }\n\tbool  operator> (const modulo &o) const { return n> o.n; }\n\tbool  operator>=(const modulo &o) const { return n>=o.n; }\n\tbool  operator==(const modulo &o) const { return n==o.n; }\n\tbool  operator!=(const modulo &o) const { return n!=o.n; }\n\n\tmodulo pow(T n) const {\n\t\tif (n==0) return 1;\n\t\tmodulo y = pow(n/2);\n\t\ty = y*y;\n\t\tif (n%2) y = y * (*this);\n\t\treturn y;\n\t}\n\tmodulo inv() const {\n\t\treturn pow(M-2);\n\t}\n\tmodulo operator/(const modulo &o) const {\n\t\treturn (*this) * o.inv();\n\t}\n\n\tT gcd_ext(T a, T b, T *x, T *y) {\n\t\tif (a == 0) {\n\t\t\t*x = 0;\n\t\t\t*y = 1;\n\t\t\treturn b;\n\t\t}\n\t\tT x1, y1;\n\t\tT gcd = gcd_ext(b%a, a, &x1, &y1);\n\t\t*x = y1 - (b/a) * x1;\n\t\t*y = x1;\n\t\treturn gcd;\n\t}\n\tmodulo div(const modulo &o) const {\n\t\tT x, y;\n\t\tT g = gcd_ext(o.n, M, &x, &y);\n\t\tif (g != 1) return 0;\n\t\telse return modulo(n * (x % M));\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const modulo &x) {\n\t\treturn os << x.n;\n\t}\n};\n\ntypedef modulo<long,998244353> T;\n//#include \"math/comb.h\"\n\nvoid comb_inc_k(T &r, int n, int &k) {\n        //C(n,k+1) = C(n,k) * (n-k) / (k+1)\n\tr = r * T(n-k) / T(k+1);\n\tk++;\n}\n\nvoid comb_dec_k(T &r, int n, int &k) {\n        //C(n,k-1) = C(n,k) * k / (n-k+1)\n\tr = r * T(k) / T(n-k+1);\n\tk--;\n}\n\nvoid comb_inc_n(T &r, int &n, int k) {\n        //C(n+1,k) = C(n,k) * (n+1) / (n+1-k)\n\tr = r * T(n+1) / T(n+1-k);\n\tn++;\n}\n\nvoid comb_dec_n(T &r, int &n, int k) {\n        //C(n-1,k) = C(n,k) * (n-k) / n\n\tr = r * T(n-k) / T(n);\n\tn--;\n}\n\nT comb(int n, int k) {\n    if (k*2 > n) k = n-k;\n    if (n==0) return 0;\n    T r = 1; //C(n,0)\n    int i = 0;\n    while (i<k) comb_inc_k(r, n, i);\n    return r;\n}\n\n\n#define MAXN 100000\n\nint n;\n\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\treturn 1;\n}\n\nvoid init() {\n}\n\nint solve() {\n\tT r = T(3).pow(n);\n\tint k = n/2;\n\tT e = comb(n, k);\n\twhile (k+1<=n) {\n\t\tcomb_inc_k(e, n, k);\n\t\tr = r - e*T(2).pow(n-k)*T(2);\n\t}\n\treturn r;\n}\n\nvoid output(int ans) {\n\tprintf(\"%d\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\nvector<long long> F, RF;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tRF[i] = Calc(F[i], MOD - 2);\n\t}\n\tlong long NOW = 1;\n\tfor (int X = N; X > N / 2; X--) {\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= NOW;\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t\tNOW = (NOW * 2) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nll MOD = 998244353;\nconst ll N = 1e7+10;\nll f[N], rf[N];\nll inv(ll x) {\n    ll res = 1;\n    ll k = MOD - 2;\n    ll y = x;\n    while (k) {\n        if (k & 1) res = (res * y) % MOD;\n        y = (y * y) % MOD;\n        k /= 2;\n    }\n    return res;\n}\nvoid init() {\n    f[0] = 1;\n    for(int i = 1; i < N; i++) f[i] = (f[i - 1] * i) % MOD;\n    rf[N - 1] = inv(f[N - 1]);\n    for(int i = N-2; i >= 0; i--) rf[i] = (rf[i + 1] * (i + 1)) % MOD;\n}\nll C(int n, int k) {\n    if(n < k) return 0;\n    ll a = f[n]; // = n!\n    ll b = rf[n-k]; // = (n-k)!\n    ll c = rf[k]; // = k!\n    ll bc = (b * c) % MOD;\n    return (a * bc) % MOD;\n}\n\nll mod_pow(ll x, ll n)\n{\n    ll res = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n        {\n            res = res * x % MOD;\n        }\n        x = x * x % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    init();\n    int n;\n    cin >> n;\n    ll ans = mod_pow(3, n);\n    ll tmp = 0;\n    vector<ll> mod2(n/2+1);\n    mod2[0] = 1;\n    for(int i = 1; i < n/2+1; i++)\n    {\n        mod2[i] = mod2[i-1] * 2 % MOD;\n    }\n    for(int a = n/2 + 1; a <= n; a++)\n    {\n        tmp += C(n, a) * mod2[n-a] % MOD;\n        tmp %= MOD;\n    }\n    tmp = tmp * 2 % MOD;\n    ans = (ans - tmp + MOD) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,tune=native\")\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define all(a) a.begin(),a.end()\n#define ull unsigned long long\n#define y1 asjdlfaskavslbcjasndscf\n#define endl '\\n'\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define iter vector< int >::iterator\n#define iter1 multiset<int>::iterator\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<class T>\nusing ordered_set=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\ntemplate<class T>\nusing ordered_multiset=tree<T,null_type,less_equal<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rnd1(chrono::steady_clock::now().time_since_epoch().count());\n\n//find_by_order\n//order_of_key\n\nconst int N=1e7+7;\nconst int inf=1e18+1e9;\nconst int mod=998244353;\nconst ld eps=1e-9;\n\n//const int MAX_MEM=1e8;\n//int mpos=0;\n//char mem[MAX_MEM];\n//\n//inline void * operator new(size_t n){\n//    char *res=mem+mpos;\n//    mpos+=n;\n//    assert(mpos<=MAX_MEM);\n//    return (void*)res;\n//}\n//\n//inline void operator delete(void *) {}\n\nint f[N],st2[N];\nint rev[N];\n\nint st(int n,int k)\n{\n    int res=1;\n    while(k){\n        if (k%2==1){\n            res=(res*n)%mod;\n        }\n        n=(n*n)%mod;\n        k/=2;\n    }\n    return res;\n}\n\nint C(int n,int k)\n{\n    int ans=f[n];\n    ans=(ans*rev[k])%mod;\n    ans=(ans*rev[n-k])%mod;\n    return ans;\n}\n\nmain ()\n{\n    ios;\n    st2[0]=1;\n    for (int i=1;i<N;++i){\n        st2[i]=(st2[i-1]*2)%mod;\n    }\n    f[0]=1;\n    for (int i=1;i<N;++i){\n        f[i]=(f[i-1]*i)%mod;\n    }\n    rev[N-1]=st(f[N-1],mod-2);\n    for (int i=N-2;i>=0;--i){\n        rev[i]=(rev[i+1]*(i+1))%mod;\n    }\n    int n;\n    cin>>n;\n    int ans=st(3,n);\n    int f=0;\n    for (int i=n/2+1;i<=n;++i){\n        f+=(C(n,i)*st2[n-i])%mod;\n        f%=mod;\n    }\n    f=(f*2)%mod;\n    ans=(ans-f+mod)%mod;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nconstexpr int MOD = 998244353;\n\nint modpow(int b, int e) {\n    if (e == 0) return 1;\n    if (e % 2 == 1) return 1LL * b * modpow(b, e - 1) % MOD;\n    return modpow(1LL * b * b % MOD, e / 2);\n}\n\ninline int inv(int x) {\n    return modpow(x, MOD - 2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    int ans = modpow(3, n);\n    int cur = 0;\n    int term = 1;\n    int p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += 1LL * term * p % MOD;\n        if (cur >= MOD)\n            cur -= MOD;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term = 1LL * term * inv(n - k + 1) % MOD;\n        term = 1LL * term * k % MOD;\n        p += p;\n        if (p >= MOD)\n            p -= MOD;\n    }\n\n    int res = ans - cur;\n    if (res < 0) res += MOD;\n    cout << res << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 10000001;\n\nint n, fact[N], inv[N], mod = 998244353;\n\nint powlog(int a, int b){\n    if(b == 0) return 1;\n    int ret = powlog(a, b / 2);\n    if(b % 2) return 1LL * ret * ret % mod * a % mod;\n    return 1LL * ret * ret % mod;\n}\nint C(int n, int r){\n    return 1LL * fact[n] * inv[r] % mod * inv[n - r] % mod;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    fact[0] = 1;\n    for(int i = 1 ; i < N ; i++){\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    inv[N - 1] = powlog(fact[N - 1], mod - 2);\n    for(int i = N - 2 ; i >= 0 ; i--){\n        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n    }\n    cin >> n;\n    int cur = 0;\n    for(int i = n / 2 + 1 ; i <= n ; i++){\n        cur = (cur + 1LL * C(n, i) * powlog(2, n - i)) % mod;\n    }\n    cout << (1LL * powlog(3, n) - 2 * cur + 2 * mod) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) (a).begin(),(a).end()\ntypedef long long ll;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define lb(s,x) (lower_bound(all(s),x)-s.begin())\n#define ub(s,x) (upper_bound(all(s),x)-s.begin())\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define bit(k) (1LL<<(k))\nconst int INF = 1e9;\n\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n    modint operator+(const modint &r) const { return modint(num + r.num); }\n    modint operator-(const modint &r) const { return modint(num - r.num); }\n    modint operator*(const modint &r) const { return modint(num * r.num); }\n\n    template<typename T>\n    modint operator^(const T &r) const {\n        if(r == 0) return 1;\n        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);\n    }\n    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }\n\n    modint operator+=(const modint &r) { return *this = *this + r; }\n    modint operator-=(const modint &r) { return *this = *this - r; }\n    modint operator*=(const modint &r) { return *this = *this * r; }\n    modint operator/=(const modint &r) { return *this = *this / r; }\n\n    template<typename T>\n    modint operator^=(const T &r) { return *this = *this ^ r; }\n\n    static modint pow(const modint x, ll r) {\n        return x^r;\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) factorial.resize(n+1);\n        if(factorial[n]) return factorial[n];\n        if(n == 0) return 1;\n        return factorial[n] = modint(n) * fact(n-1);\n    }\n\n    static modint C(ll n,ll r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial;\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    ll n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * modint(2);\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800000;\ndouble Pi = 3.1415926535897932384626;\n \nvector<ll> G[550010];\n//vector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n\nll mod = 998244353;\n//ll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k,idx,ans;\nll x[500005],y[500005],z[500005];\nchar s[500005];\nll dp[5000005];\nll dpsum[5000005];\n\nint main(){\n    cin >> n;\n    c3_init();\n    for(int i=0;i<=n / 2;i++){\n        dp[i] = c3(n / 2, i);\n        dpsum[i] = dp[i];\n    }\n    for(int i=0;i<=n / 2;i++){\n        dpsum[i] *= rui(2, n / 2 - i);\n        dpsum[i] %= mod;\n    }\n    for(int i=n / 2;i>=1;i--){\n        dpsum[i-1] += dpsum[i]; \n        dpsum[i-1] %= mod;\n    }\n\n    for(int i=0;i<=n / 2;i++){\n        num = dp[i] * dpsum[n / 2 - i + 1];\n        num %= mod;\n        num *= rui(2ll, n / 2 - i);\n        num %= mod;\n        ans += num;\n        ans %= mod;\n        //p(ans);\n    }\n    ans *= 2;\n    ans %= mod;\n    ans = rui(3ll, n) - ans + mod;\n    ans %= mod;\n    p(ans);\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e7 + 71, P = 998244353, div2 = (P + 1) / 2;\n\nint pw(int x, int y) {\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1ll * x * x % P)\n\t\tif (y & 1) r = 1ll * r * x % P;\n\treturn r;\n}\ninline void $(int& x) { x += x >> 31 & P; }\n\nint fac[N], ifac[N];\ninline int C(int n, int m) { return 1ll * n[fac] * m[ifac] % P * (n - m)[ifac] % P; }\n\nint n, ans, cur;\nint main() {\n\tscanf(\"%d\", &n);\n\t0 [fac] = 0 [ifac] = 1;\n\tfor (int i = 1; i <= n; i++) i[fac] = 1ll * (i - 1)[fac] * i % P;\n\tn[ifac] = pw(n[fac], P - 2);\n\tfor (int i = n - 1; i; i--) i[ifac] = (i + 1)[ifac] * (i + 1ll) % P;\n\tans = pw(3, n), cur = pw(2, n / 2);\n\tfor (int i = n / 2 + 1; i <= n; i++) {\n\t\t$(ans -= 1ll * cur * C(n, i) % P);\n\t\tcur = 1ll * cur * div2 % P;\n\t}\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 998244353;\n\nll todeg(ll k, ll deg) {\n    ll deg0 = deg;\n    if (deg == 0) {\n        return 0;\n    }\n    if (deg == -1) {\n        deg = mod - 2;\n    }\n    ll ans = 1;\n    for (int i = 30; i >= 0; --i) {\n        ans *= ans;\n        if (ans > 100000000000LL) {\n            ans %= mod;\n        }\n        if ((deg >> i) & 1) {\n            ans *= k;\n        }\n        if (ans > mod) {\n            ans %= mod;\n        }\n    }\n    /*while (deg > 1) {\n        ans *= ans;\n        ans %= mod;\n        if (deg % 2 == 1) {\n            ans *= k;\n            ans %= mod;\n        }\n        deg /= 2;\n    }*/\n    //cout << k << \"^\" << deg0 << \"=\" << ans << '\\n';\n    return ans;\n}\n\n\n\nint main()\n{\n    /*for (int i = 32; i >= 0; --i) {\n        if (((mod - 2) >> i) & 1) {\n            cout << '1';\n        } else {\n            cout << '0';\n        }\n    }*/\n    ll n;\n    cin >> n;\n    ll f = 1;\n    ll cur2 = 1, curc = 1;\n    for (int k = 1; k * 2 < n; ++k) {\n        cur2 *= 2;\n        while (cur2 > mod) {\n            cur2 -= mod;\n        }\n        curc = (((curc * (n - k + 1)) % mod) * todeg(k, -1)) % mod;\n        //cout << k << \": \" << cur2 << \", \" << curc << '\\n';\n        f += cur2 * curc;\n        f %= mod;\n    }\n    ll ans = todeg(3, n);\n    ans -= 2 * f;\n    while(ans < 0) {\n        ans += mod;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    // modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(ll num_) {\n        if (num_ < 0) num = num_ + MOD;\n        else if (num_ >= MOD) num = num_ % MOD;\n        num = num_;\n    }\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 10000005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,fact[MAXN],invf[MAXN],p2[MAXN];\nint res[MAXN],sum[MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nint comb(int n,int k)\n{\n    if(n<k) return 0;\n    return 1LL*fact[n]*invf[k]%MOD*invf[n-k]%MOD;\n}\nint main()\n{\n    fact[0]=invf[0]=p2[0]=1;\n    for(int i=1;i<=10000000;i++) fact[i]=1LL*fact[i-1]*i%MOD;\n    invf[10000000]=pow_mod(fact[10000000],MOD-2);\n    for(int i=9999999;i>=1;i--) invf[i]=1LL*invf[i+1]*(i+1)%MOD;\n    for(int i=1;i<=10000000;i++) p2[i]=2LL*p2[i-1]%MOD;\n    scanf(\"%d\",&n);\n    int ans=pow_mod(3,n);\n    for(int i=0;i<=n/2;i++) res[i]=1LL*comb(n/2,i)*p2[n/2-i]%MOD;\n    sum[n/2]=res[n/2];\n    for(int i=n/2-1;i>=0;i--)\n    {\n        sum[i]=sum[i+1];\n        add(sum[i],res[i]);\n    }\n    for(int i=1;i<=n/2;i++)\n    {\n        int j=n/2+1-i;\n        dec(ans,2LL*res[i]*sum[j]%MOD);\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint ifac[5000001];\nconst int pre[10001] = { 1,777990065,766786010,512513096,705983787,734256002,244148993,533292028,210582481,688517539,215582594,14820617,129246395,150625187,86672976,764239242,21874704,57288446,850657009,774583782,638474417,128284758,786368753,472986042,103549395,495451255,264078536,433635135,625262204,766766525,185226044,35932350,902168850,455715166,218641259,972559028,640480499,206662314,683003246,923831102,876712294,724261094,408525348,763874992,547233394,109140246,300634900,256419515,371584155,276107980,832944090,540250216,893651744,936348937,326512726,516396135,843656716,776879789,359802705,356307409,949283602,121678346,755038370,144825638,398849114,243664371,157125107,752722108,971617941,787502726,951610819,720346213,481304016,361949821,680950950,387120559,575366956,411040690,816984038,668571204,187142323,552289458,722805387,993149209,318238233,904486800,968982693,875054001,578248523,925025550,271818664,509541523,500499768,929802162,849466163,523746388,268604730,311862148,211074478,804711044,373341033,683607517,262864254,899397125,903574757,408123903,570163026,387548298,136310560,757193515,492373922,16092666,218256882,33612616,184219001,645249935,348551228,835533217,302307407,641587141,70007868,840714962,797190974,744571430,180557608,554082240,483244331,924205037,933027896,760946120,890154909,803775227,605185517,868712494,835769462,401208474,689354486,226621123,96687561,38631563,501927483,483249587,593944616,998231222,23528366,842172435,357335185,725982025,398516968,269658881,797725335,59352911,184061655,193546739,303152497,61883255,98078622,195866691,996728981,446353446,796024455,885097692,915829452,732760877,97457057,251606742,829937743,367147609,907175897,989448554,748640136,168580487,42590154,482935433,768160042,31342156,39326209,654029131,72020724,47519485,542991096,876162665,577428803,188685455,233510797,422423143,544780457,613635275,137823240,55715373,97062836,437207675,578565389,794462456,122688768,964014598,148890003,428128959,278232786,996120899,45596018,7163323,387102481,258039391,515773886,830696837,604845763,539553101,384403210,949063076,849317807,630752268,210722610,773591150,869634880,109500248,32144134,224896996,642008315,169507794,283287674,219473392,422410040,174823408,288798151,140807520,497583578,863575707,355648573,272221122,561110485,253470028,580834681,587770974,112220015,850532094,33475427,498807687,317772333,409146882,596316874,331449290,335429501,670238024,900627351,14996190,733198052,307321953,844834750,829096729,400767242,769588955,98032360,560788564,292816061,468314755,983912094,328059458,549942096,45373125,417528165,901294757,895122295,151159745,297548894,203255878,752797429,911093840,496689395,629769991,78939987,459538825,406390137,6879134,257680118,396950159,129807060,715875807,553661506,390811345,191166323,810576750,213045873,942790458,758339094,899444486,309004018,633895784,128589948,937478027,212513874,174345296,62004037,591751261,649329767,366843154,926280101,432150075,354244239,659276328,834980587,136620485,948751335,633318822,299685362,867019421,267600853,697694392,173796099,133939251,167633838,168664055,455355228,509401446,914452079,440577645,29283142,556198383,482874240,923005927,914550501,892014883,550966054,375146890,259320783,391769529,226806694,768163357,300654217,694655521,844638237,661303928,422327106,355635742,489451003,137628974,980318491,361853327,645638169,336599956,688948565,638514939,153383062,889194597,536430068,893849901,923432110,315839722,49382817,516474656,248173708,403609024,833306540,338847731,986694950,790821219,197628535,285108045,285934271,811084650,104964765,243988035,674229619,993956736,147476083,824048109,791673374,111127164,710735456,308066837,815197913,520396119,92412037,174723780,843863210,222304311,70227310,745928328,40367869,201974250,393032085,247592312,302180761,495381981,900779821,42751968,130815209,110950082,445232011,650497384,752109934,369950087,309849396,190399500,497647689,353358328,459852401,546099291,671454973,367352978,623627864,100401244,892602210,941551774,871438080,513287280,28185349,21030930,44275710,449827510,712246343,36889166,383078382,912763782,209588582,66987695,640672435,956971829,371907015,714047850,982424362,437882276,454748600,468777415,226512910,761686008,418711160,679266400,372627958,797779775,242570019,602303606,983737359,585763482,940263818,910024593,182269085,662738675,615426027,638525692,446366139,68263779,710197880,222814184,532876159,24120062,707881939,705340838,809441202,482114351,45768177,722815024,897943079,728188648,339739889,364745005,808452545,151610888,987511783,394592072,407729297,52967962,680043468,502198643,938707127,20993746,222949807,531872391,810935357,892377075,154762272,84787052,486805848,317085134,992754474,195236749,21949307,780187478,413553058,879449557,330880448,81415435,108607930,341779439,784896483,620491631,153641122,534228690,846914883,610414719,232588079,436762323,984600471,75405628,263308959,639543590,265889797,133955315,209305986,554795787,428937595,941877363,184451191,923795936,49525425,312442269,437151206,78919908,325973945,579844487,398204190,422683275,595487166,194914147,918795881,69211505,380683932,530612228,634697067,709623540,897706118,22942978,281839888,735681848,25120123,882619476,174552294,668106640,641839971,777450530,655937896,29612691,76069349,832769992,277055316,877454260,115365802,87835316,262466036,79664056,536236563,425951836,278768863,475769894,90522759,307362605,63204044,648964820,931888706,954449142,938010479,325282066,209053425,396563384,761781696,408508738,591582400,829340326,348639450,905026623,860856448,437296068,435334482,291412970,343673774,828901226,901613695,992541178,920381845,302843711,566172771,736189313,783990843,184030082,33617073,439331499,611136185,574497345,90817591,306143980,945501487,362805859,74284790,641726342,522692857,775884194,549727729,444956677,545075287,892463752,90265520,916637957,178236658,980812214,59569691,932392802,488131279,861287555,954672905,419328334,442819817,357758244,887478702,984290034,939144003,70714661,485961375,177417145,162118962,168070756,174913840,982318186,650727215,846359719,984640166,823933073,243009290,152990121,535790194,842333964,57092875,671223531,933222015,271959156,288003384,421390300,835225795,394537809,243155841,856810726,671154973,919875491,265924126,79436106,994247829,183378915,532312977,641156343,576069340,704676636,14554181,6523850,393621207,962151282,554820476,606567566,540585991,269714976,420527242,902506476,79339328,938346178,906937168,714916297,950663746,924948492,93383124,742471102,96868329,289622464,511596111,892814818,404369049,409642870,925142075,388844266,695178051,924307790,769870823,258352801,37319493,656535362,942160874,643592487,159647979,459668470,339174706,60288630,749230429,137386012,142128101,741523026,932249458,133685955,848166191,971938720,690816329,693509216,256408885,839738215,939641949,589638571,25469448,932714644,275884954,440367728,901736665,872587068,897787042,837977995,499710224,189498332,636546695,512005440,220288536,368285012,522130486,112567128,173590818,787664831,463296900,963431830,585289222,414700630,530772554,520800955,27834666,632926830,108265239,130127802,406984354,885533900,267599206,846568716,925571632,361045177,455835455,631901425,582383970,397418490,902263780,279768062,684207567,555876879,213169731,993545710,281195933,354016936,417452790,325049825,372247494,913454812,229684453,11625560,557539657,158714984,396403031,362573159,559048195,305476857,280520923,172808824,618589023,957745517,507362338,183892698,536827111,136820615,161184916,581288683,788080221,379731237,970234708,512908572,911557655,693532380,75693974,743612959,293425406,460742607,841929891,478466605,131340979,941426392,96506146,734531144,954715348,258071636,267285258,157361051,634098066,847501174,291172701,823316612,287824262,290717927,321615349,597704882,407060168,100064711,40000658,640920375,910618969,5182489,548235654,969546889,238062370,516021134,147732413,370659533,833655840,649202504,283787677,544385077,533215075,245880234,995321109,504089062,527440767,806954080,237670639,972424792,544700093,154025540,542342152,523089929,946800898,320483244,401371823,78384996,62174429,258433535,553295948,127143445,564154450,413488441,991069498,392441240,824132912,514921452,123644879,692841184,618623956,565158616,58529238,150117976,71490068,699156339,333263606,921371650,217507999,741546202,724472787,964898806,817920986,582096713,559153778,903819609,215291535,534168349,488985182,844145821,935050600,371603787,757869745,268970995,792449869,803557966,235112752,659275014,826634010,351488455,176734098,263260251,785552216,299003958,208080760,569058617,360532390,386399723,398762201,33272509,497218769,522181848,976622995,260131094,982778284,77371871,395349740,390214653,531854347,493975992,678229473,574409531,95826270,992726917,458437396,619632461,205161868,549830743,223515902,178482990,310282069,219230309,602291763,929072996,593463923,527802328,636498474,823705589,83857087,778669244,941456377,73301964,898657754,509912480,938900018,435397704,519619493,735044665,265835960,559201172,239826028,312119351,739353209,103208090,135132726,784824707,232832650,736566311,391931702,394509768,469195547,590383266,897215155,458515558,373585170,158729077,952125022,711761227,868405413,226589812,677030475,648757054,454752913,592350159,754968001,137896269,14566430,858673333,60435539,930609495,947940003,321611846,402349796,352034025,951901408,484084529,740021117,952069554,541638394,357815063,74405887,350552020,776016487,155552075,881994814,90947222,26360681,846511130,346814021,447948726,11819857,378653079,716353332,696316282,56457542,302941700,371036503,124047029,390868579,84411314,33882493,204021054,580753084,652653069,601390003,135041016,492401516,817288138,201876905,449498406,264348632,965482620,138310,207110730,107364155,669232095,139014676,180671118,556369147,199407219,671144270,58468077,73314446,890418474,428534311,925456411,262608571,349636135,295201906 };\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tint N2 = N / 2;\n\tll facN = pre[N / 10000];\n\tint n = N / 10000 * 10000;\n\tfor (int i = n + 1; i <= n + N % 10000; i++) facN = facN * i % mod;\n\tifac[0] = modpow(facN, mod - 2);\n\trep(i, N2) ifac[i + 1] = (ll)ifac[i] * (N - i) % mod;\n\n\n\tll kotae = modpow(3, N);\n\tconst int inv2 = 499122177;\n\n\tll hiku = 0;\n\tll ima = ifac[N2];\n\tll k = modpow(2, N2 - 1);\n\trep(i, N2) {\n\t\tima = ima * (N2 - i) % mod;\n\t\thiku += ima * ifac[N2 - i - 1] % mod * k % mod;\n\t\tk = k * inv2 % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n/*#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")*/\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define vi vector<int>\n\n\n#define ll long long\n#define ld long double\n#define mp make_pair\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\nint p = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\nvector<int> Z(vector<int> s)\n{\n    int n = s.size();\n    vector<int> z(n);\n    int L = 0, R = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > R) {\n            L = R = i;\n            while (R < n && s[R-L] == s[R]) R++;\n            z[i] = R-L; R--;\n        } else {\n            int k = i-L;\n            if (z[k] < R-i+1) z[i] = z[k];\n            else {\n                L = i;\n                while (R < n && s[R-L] == s[R]) R++;\n                z[i] = R-L; R--;\n            }\n        }\n    }\n    return z;\n}\n\nmt19937 rnd(time(0));\n/*\nstruct Line {\n    mutable ll k, m, p;\n    bool operator<(const Line& o) const { return k < o.k; }\n    bool operator<(ll x) const { return p < x; }\n};\n\nstruct CHT : multiset<Line, less<>> {\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\n    const ll inf = LLONG_MAX;\n    ll div(ll a, ll b) { // floored division\n        return a /b - ((a ^ b) < 0 && a % b); }\n    bool isect(iterator x, iterator y) {\n        if (y == end()) { x->p = inf; return false; }\n        if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\n        else x->p = div(y->m - x->m, x->k - y->k);\n        return x->p >= y->p;\n    }\n    void add(ll k, ll m) {\n        auto z = insert({k, m, 0}), y = z++, x = y;\n        while (isect(y, z)) z = erase(z);\n        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));\n        while ((y = x) != begin() && (--x)->p >= y->p)\n        isect(x, erase(y));\n    }\n    ll query(ll x) {\n        assert(!empty());\n        auto l = *lower_bound(x);\n        return l.k * x + l.m;\n    }\n};\n*/\n\n\n\n/*\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1000000000;\n\nstruct MaxFlow {\n  int N;\n  VVI cap, flow;\n  VI dad, Q;\n\n  MaxFlow(int N) :\n    N(N), cap(N, VI(N)), flow(N, VI(N)), dad(N), Q(N) {}\n\n  void AddEdge(int from, int to, int cap) {\n    this->cap[from][to] += cap;\n  }\n\n  int BlockingFlow(int s, int t) {\n    fill(dad.begin(), dad.end(), -1);\n    dad[s] = -2;\n\n    int head = 0, tail = 0;\n    Q[tail++] = s;\n    while (head < tail) {\n      int x = Q[head++];\n      for (int i = 0; i < N; i++) {\n        if (dad[i] == -1 && cap[x][i] - flow[x][i] > 0) {\n          dad[i] = x;\n          Q[tail++] = i;\n        }\n      }\n    }\n\n    if (dad[t] == -1) return 0;\n\n    int totflow = 0;\n    for (int i = 0; i < N; i++) {\n      if (dad[i] == -1) continue;\n      int amt = cap[i][t] - flow[i][t];\n      for (int j = i; amt && j != s; j = dad[j])\n        amt = min(amt, cap[dad[j]][j] - flow[dad[j]][j]);\n      if (amt == 0) continue;\n      flow[i][t] += amt;\n      flow[t][i] -= amt;\n      for (int j = i; j != s; j = dad[j]) {\n        flow[dad[j]][j] += amt;\n        flow[j][dad[j]] -= amt;\n      }\n      totflow += amt;\n    }\n\n    return totflow;\n  }\n\n  int GetMaxFlow(int source, int sink) {\n    int totflow = 0;\n    while (int flow = BlockingFlow(source, sink))\n      totflow += flow;\n    return totflow;\n  }\n};*/\n\n/*\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nconst int N = 1e7 + 5;\n\nvector<int> facs(N);\nvector<int> invfacs(N);\nvector<int> deg(N);\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n    deg[0] = 1;\n    for (int i = 1; i<N; i++) deg[i] = mul(deg[i-1], 2);\n}\n\nint C(int n, int k)\n{\n    if (k<0||k>n) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    init();\n    int n;\n    cin>>n;\n    int total = po(3, n);\n    int m = n/2;\n    int bad = 0;\n    vector<int> pref(m+1);\n    pref[0] = 0;\n    for (int i = 1; i<=m; i++)\n    {\n        pref[i] = add(pref[i-1], mul(C(m, i-1), deg[i-1]));\n    }\n    for (int i = 0; i<=m; i++)\n    {\n        bad = add(bad, mul(pref[i], mul(C(m, i), deg[m-i])));\n    }\n    cout<<sub(total, mul(2, bad));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nconst int maxn = 1e7;\nlong long int pw[maxn+1],fac[maxn+1],inv[maxn+1];\n\nlong long int C(int n,int k){\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tpw[0]=fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=maxn;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=mod-mod/i*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=maxn;i++)\n\t\tinv[i]=inv[i]*inv[i-1]%mod;\n\tint n;\n\tcin>>n;\n\tlong long int ans = 1;\n\tfor(int i=1;i<=n;i++)\n\t\tans=ans*3%mod,pw[i]=pw[i-1]*2%mod;\n\tlong long int tot = 0;\n\tfor(int i=0;i<n/2;i++)\n\t\ttot += pw[i] * C(n,i)%mod;\n\ttot*=2;\n\tans -= tot;\n\tcout<<(ans%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) (a).begin(),(a).end()\ntypedef long long ll;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define lb(s,x) (lower_bound(all(s),x)-s.begin())\n#define ub(s,x) (upper_bound(all(s),x)-s.begin())\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define bit(k) (1LL<<(k))\nconst int INF = 1e9;\n\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n\nclass modint;\nstatic vector<modint> factorial;\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n    modint operator+(const modint &r) const { return modint(num + r.num); }\n    modint operator-(const modint &r) const { return modint(num - r.num); }\n    modint operator*(const modint &r) const { return modint(num * r.num); }\n\n    template<typename T>\n    modint operator^(const T &r) const {\n        if(r == 0) return 1;\n        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);\n    }\n    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }\n\n    modint operator+=(const modint &r) { return *this = *this + r; }\n    modint operator-=(const modint &r) { return *this = *this - r; }\n    modint operator*=(const modint &r) { return *this = *this * r; }\n    modint operator/=(const modint &r) { return *this = *this / r; }\n\n    template<typename T>\n    modint operator^=(const T &r) { return *this = *this ^ r; }\n\n    static modint pow(const modint x, ll r) {\n        return x^r;\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) factorial.resize(n+1);\n        if(factorial[n]) return factorial[n];\n        if(n == 0) return 1;\n        return factorial[n] = modint(n) * fact(n-1);\n    }\n\n    static modint C(ll n,ll r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\n// vector<modint> modint::factorial;\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    ll n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * modint(2);\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, int> i_i;\nll INF = 1e9+10;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\nvector<pair<ll, ll> > pairs;\n\nll n, mod = 998244353;\nconst ll MAX = 1e7 + 1;\nvector<ll> v(MAX);\n\nll inv[MAX];\n\nvoid init() {\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    }\n}\n\nint main()\n{\n    ll N;\n    cin >> N;\n    init();\n    \n    ll sub = 0;\n    ll beki = 1, nCk = 1;\n    for (int i = N; i >= N/2+1; i--){\n        (sub += beki * nCk)%=mod; \n        (nCk *= i) %= mod;\n        (nCk *= inv[N + 1 - i]) %= mod;\n        (beki *= 2) %= mod;\n    }\n    (sub *= 2) %= mod;\n    \n    \n    ll ans = 1;\n    rep(i, N){\n        (ans *= 3) %= mod;\n    }\n    (ans += mod - sub) %= mod;\n    cout << ans << endl;\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e7 + 10, mod = 998244353;\n\nll fact[N], finv[N], p2[N];\n\nll pwr(ll x, ll e);\nll choose(int n, int k);\n\nint main() {\n\tfast_cin();\n\tint n; cin >> n;\n\tfact[0] = finv[0] = p2[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp2[i] = (2 * p2[i - 1]) % mod;\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfinv[i] = pwr(fact[i], mod - 2);\n\t}\n\tll ans = pwr(3, n);\n\tfor (int k = n / 2 + 1; k <= n; ++k) {\n\t\tll temp = choose(n, k) * p2[n - k + 1];\n\t\ttemp %= mod;\n\t\tans += mod - temp;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\nll pwr(ll x, ll e) {\n\tll res = 1;\n\twhile (e) {\n\t\tif (e & 1) {\n\t\t\tres = (res * x) % mod;\n\t\t}\n\t\te /= 2;\n\t\tx = (x * x) % mod;\n\t}\n\treturn res;\n}\n\nll choose(int n, int k) {\n\tll ans = fact[n] * finv[k];\n\tans %= mod;\n\tans *= finv[n - k];\n\treturn ans % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\nconst int N = 1e6+10;\nint n, fac[N], ifac[N], po[N];\nint C(int n, int m) {\n\treturn (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\n\nint main() {\n\tfac[0] = po[0] = 1;\n\tREP(i,1,N-1) fac[i]=(ll)fac[i-1]*i%P,po[i]=(ll)po[i-1]*2%P;\n\tifac[N-1] = inv(fac[N-1]);\n\tPER(i,0,N-2) ifac[i]=(ll)ifac[i+1]*(i+1)%P;\n\tscanf(\"%d\", &n);\n\tint ans = qpow(3,n);\n\tREP(i,n/2+1,n) ans = (ans-2ll*C(n,i)*po[n-i])%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll mod=998244353;\n\nll fac[100000000];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(int n){\n    fac[0]=1;\n    for(ll i=1;i<n;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  ll n;\n  cin >> n;\n  modfac(10000010);\n  ll ans=modpow(3,n);\n  for(ll i=n/2+1;i<=n;i++){\n    ans-=modpow(2,n-i)*modcomb(n,i)*2%mod;\n    ans+=mod; ans%=mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate<typename T> bool operator < (vector<T>& a, vector<T>& b) {\n\trep(i, a.size()) {\n\t\tif (i == b.size())\treturn false;\n\t\tif (a[i] < b[i])\treturn true;\n\t\telse if (a[i] > b[i])\treturn false;\n\t}\n\treturn false;\n}\ntemplate<typename T> bool operator > (vector<T>& a, vector<T>& b) {\n\trep(i, a.size()) {\n\t\tif (i == b.size())\treturn true;\n\t\tif (a[i] < b[i])\treturn false;\n\t\telse if (a[i] > b[i])\treturn true;\n\t}\n\treturn false;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid * mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ld infl = 1e100;\nconst ll mod = 998244353;\nconst ld eps = 1e-9;\nconst ll inf = 1e15;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nll base_mod = 1420622537;\n\nll fact[10000010];\nll inv_fact[10000010];\nll pow2[10000010];\n\nll inv(ll x) {\n\t// x^(mod-2)\n\tll b = mod - 2;\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1)\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tfact[0] = inv_fact[0] = pow2[0] = 1;\n\tSREP(i, 1, n) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\tinv_fact[i] = (inv_fact[i - 1] * inv(i)) % mod;\n\t\tpow2[i] = (pow2[i - 1] * 2) % mod;\n\t}\n\tll res = 1;\n\trep(i, n)\tres = (res * 3) % mod;\n\tll sub = 0;\n\tSREP(i, (n + 2) / 2, n) {\n\t\t// nCi\n\t\tll nCi = (fact[n] * ((inv_fact[i] * inv_fact[n - i]) % mod)) % mod;\n\t\tll select = (nCi * pow2[n - i]) % mod;\n\t\tsub = (sub + select) % mod;\n\t}\n\tcout << (res + 2 * mod - 2 * sub) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ModInt {\n  using M = ModInt;\n  long long v;\n  ModInt(long long _v = 0) : v(_v % MOD + MOD) { norm(); }\n  M& norm() {\n    v = (v < MOD) ? v : v - MOD;\n    return *this;\n  }\n  M operator+(const M& x) const { return M(v + x.v); }\n  M operator-(const M& x) const { return M(v + MOD - x.v); }\n  M operator*(const M& x) const { return M(v * x.v % MOD); }\n  M operator/(const M& x) const { return M(v * x.inv().v); }\n  M& operator+=(const M& x) { return *this = *this + x; }\n  M& operator-=(const M& x) { return *this = *this - x; }\n  M& operator*=(const M& x) { return *this = *this * x; }\n  M& operator/=(const M& x) { return *this = *this / x; }\n  friend istream& operator>>(istream& input, M& x) {\n    return input >> x.v, x.norm(), input;\n  }\n  friend ostream& operator<<(ostream& output, const M& x) {\n    return output << x.v;\n  }\n  M pow(long long n) const {\n    M x(v), res(1);\n    while (n) {\n      if (n & 1) res *= x;\n      x *= x;\n      n >>= 1;\n    }\n    return res;\n  }\n  M inv() const { return this->pow(MOD - 2); }\n\n  static long long MOD;\n  static vector<M> fact, finv;\n  static void build(int n) {\n    fact.assign(n + 1, 1);\n    finv.assign(n + 1, 1);\n    for (int i = 1; i < n + 1; i++) fact[i] = fact[i - 1] * M(i);\n    for (int i = 0; i < n + 1; i++) finv[i] = fact[i].inv();\n  }\n  static M comb(int n, int k) {\n    if (n < k || k < 0) return M(0);\n    return fact[n] * finv[n - k] * finv[k];\n  }\n  static M extgcd(int a, int b, int* x, int* y) {\n    M d(a);\n    if (b) {\n      d = extgcd(b, a % b, y, x);\n      *y -= (a / b) * *x;\n    } else {\n      *x = 1, *y = 0;\n    }\n    return d;\n  }\n};\nvector<ModInt> ModInt::fact = vector<ModInt>();\nvector<ModInt> ModInt::finv = vector<ModInt>();\nlong long ModInt::MOD = 998244353;\n\nint main() {\n  int n;\n  cin >> n;\n  ModInt::build(n);\n  ModInt u = ModInt(3).pow(n);\n  ModInt c = 0;\n  ModInt p = ModInt(2).pow(n - n / 2 - 1);\n  for (int i = n / 2 + 1; i <= n; i++) {\n    c += ModInt::comb(n, i) * p;\n    p /= 2;\n  }\n  cout << u - c * 2 << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst unsigned long mod = 998244353;\nlong n;\nlong f;\nlong g[10000001];\nlong p[10000001];\n\nlong power(long b, long e) {\n  if (e == 0) return 1;\n  if (e % 2 == 1) return power(b, e - 1) * b % mod;\n  long t = power(b, e / 2);\n  return t * t % mod;\n}\n\nlong inv(long n) {\n  return power(n, mod - 2);\n}\n\nvoid pre() {\n  p[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    p[i] = p[i - 1] * 2;\n    if (p[i] >= mod) p[i] -= mod;\n  }\n  f = 1;\n  for (int i = 1; i <= n; ++i) {\n    f = f * i % mod;\n  }\n  g[n] = inv(f);\n  for (int i = n; i >= 1; --i) {\n    g[i - 1] = g[i] * i % mod;\n  }\n}\n\nlong sub(long k) {\n  return p[n - k] * g[k] % mod * g[n - k] % mod;\n}\n\nint main() {\n  cin >> n;\n  pre();\n  long sum = 0;\n  for (int k = n; 2 * k > n; --k) {\n    sum += sub(k);\n    if (sum >= mod) sum -= mod;\n  }\n  cout << (power(3, n) - 2 * f * sum % mod + mod) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\n \n// hloya template v26\n \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n \n#include <bits/stdc++.h>\nusing namespace std;\n \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define sqr(x) ((x) * (x))\n \n#define ull unsigned long long\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n \nvoid bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n \nmt19937_64 mt_rand(\n    chrono::system_clock::now().time_since_epoch().count()\n);\n \ntemplate<typename T1, typename T2> inline bool upmax(T1& a, T2 b) { return (a < b ? (a = b, true) : false); }\ntemplate<typename T1, typename T2> inline bool upmin(T1& a, T2 b) { return (b < a ? (a = b, true) : false); }\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n \ntemplate<typename T>\nT gcd (T a, T b) { while (b) { a %= b; swap (a, b); } return a; }\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = (int)1e7 + 3, base = 998244353;\nconst ll llinf = 2e18 + 5;\n \nint binpow(int a, int s) { \n    int res = 1;\n    while (s) {\n        if (s % 2) {\n            res = 1ll * res * a % base;\n        }\n        a = 1ll * a * a % base;\n        s /= 2;\n    }\n    return res;\n}\n\nll fact[maxn], inv[maxn];\n\nint c(int n, int k) {\n\treturn fact[n] * inv[k] % base * inv[n - k] % base;\n}\n\nint main() {\n\t// files1;\n\tfast_io;\n\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tfor (int i = 1; i < maxn; i++) {\n\t\tfact[i] = fact[i - 1] * i % base;\n\t}\n\tinv[maxn - 1] = binpow(fact[maxn - 1], base - 2);\n\tfor (int i = maxn - 2; i > 0; i--) {\n\t\tinv[i] = inv[i + 1] * (i + 1) % base;\n\t}\n\n\t// cnt0 <= N / 2 && cnt1 <= N / 2\n\tint n;\n\tcin >> n;\n\n\tint ans = binpow(3, n);\n\n\tfor (int c0 = (n / 2) + 1; c0 <= n; c0++) {\n\t\tint re = n - c0;\n\t\tans = (ans - 2ll * binpow(2, re) * c(n, c0) % base + base) % base;\n\t}\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define Maxn 10000000\n#define Mod 998244353\nint n;\nint ksm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1){\n\t\t\tans=1ll*ans*a%Mod;\n\t\t}\n\t\tb>>=1;\n\t\ta=1ll*a*a%Mod;\n\t}\n\treturn ans;\n}\nint frac[Maxn+5],inv[Maxn+5];\nvoid init(){\n\tfrac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfrac[i]=1ll*frac[i-1]*i%Mod;\n\t}\n\tinv[n]=ksm(frac[n],Mod-2);\n\tfor(int i=n-1;i>=0;i--){\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%Mod;\n\t}\n}\nint C(int n,int m){\n\treturn 1ll*frac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tinit();\n\tint ans=ksm(3,n);\n\tfor(int i=(n>>1)+1;i<=n;i++){\n\t\tans-=C(n,i)*2ll%Mod*ksm(2,n-i)%Mod;\n\t\tans=(ans+Mod)%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\n\n\nll modpower(ll a, ll r, ll mod){ //a^r\n    ll x = 1;\n    a %= mod;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a, ll mod){\n    return modpower(a, mod-2, mod);\n}\n\nvector<ll> fact;\nvector<ll> invfact;\n\nvoid set_fact(ll n, ll mod){\n    fact.resize(n+1, 1);\n    invfact.resize(n+1, 1);\n    for (ll i = 2; i <= n; i++) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    invfact[n] = modinv(fact[n], mod);\n    for (ll i = n-1; i >= 2; i--) {\n        invfact[i] = invfact[i+1] * (i+1) % mod;\n    }\n    return;\n}\n\nll comb(ll n, ll k, ll mod) {\n    if (k > n || k < 0) return 0;\n    if (k == n || k == 0) return 1;\n    return fact[n] * invfact[n-k] % mod * invfact[k] % mod;\n}\n\n\nint main() {\n    ll N;\n    cin >> N;\n    ll mod = 998244353;\n    ll all = modpower(3, N, mod);\n    ll ex = 0;\n    set_fact(N+2, mod);\n    \n    vector<ll> pow2(N+1, 1);\n    for (ll i = 1; i <= N; i++) pow2[i] = pow2[i-1]*2%mod;\n    for (ll i = N/2+1; i <= N; i++) {\n        ex += 2LL * comb(N, i, mod) * pow2[N-i] % mod;\n        ex %= mod;\n    }\n    cout << (all+mod-ex)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\nusing lint = long long;\nconstexpr int MOD = 998244353, INF = 1010101010;\nconstexpr lint LINF = 1LL << 60;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\\n\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\ntemplate<int Modulo = MOD> struct Mint {\n\n\tlint val;\n\tconstexpr Mint(lint v = 0) noexcept : val(v % Modulo) { if (val < 0) v += Modulo; }\n\n\tconstexpr Mint& operator += (const Mint &r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= Modulo) val -= Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -= (const Mint &r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *= (const Mint &r) noexcept {\n\t\tval = val * r.val % Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator /= (const Mint &r) noexcept {\n\t\tlint a = r.val, b = Modulo, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlint t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % Modulo;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint operator + (const Mint &r) const noexcept { return Mint(*this) += r; }\n\tconstexpr Mint operator - (const Mint &r) const noexcept { return Mint(*this) -= r; }\n\tconstexpr Mint operator * (const Mint &r) const noexcept { return Mint(*this) *= r; }\n\tconstexpr Mint operator / (const Mint &r) const noexcept { return Mint(*this) /= r; }\n\n\tconstexpr int getmod() { return Modulo; }\n\tconstexpr Mint operator - () const noexcept { return val ? Modulo - val : 0; }\n\n\tconstexpr bool operator == (const Mint &r) const noexcept { return val == r.val; }\n\tconstexpr bool operator != (const Mint &r) const noexcept { return val != r.val; }\n\n\tfriend ostream &operator << (ostream &os, const Mint<Modulo> &x) noexcept { return os << x.val; }\n\tfriend istream &operator >> (istream &is, Mint<Modulo> &x) noexcept {\n\t\tlint tmp; is >> tmp;\n\t\tx = Mint<Modulo>(tmp);\n\t\treturn is;\n\t}\n\tfriend constexpr Mint<Modulo> modpow(const Mint<Modulo> &a, lint n) noexcept {\n\t\tMint res(1), tmp = a;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nusing mint = Mint<>;\n\ntemplate<class T>\nvector<T> make_vec(size_t s, T val) { return vector<T>(s, val); }\ntemplate<class... Size>\nauto make_vec(size_t s, Size... tail) {\n\treturn vector<decltype(make_vec(tail...))>(s, make_vec(tail...));\n}\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tauto dp = make_vec(N / 2 + 1, 9, mint(0));\n\tdp[1] = { 1,0,1,0,1,1,1,1,1 }; // AA AB AC BA BB BC CA CB CC\n\n\tfor (int i = 1; i < N / 2; i++) {\n\n\t\tmint sum = 0;\n\t\tfor (int j = 0; j < 9; j++) sum += dp[i][j]; // AB BA 以外を後ろにつける\n\t\tfor (int j = 0; j < 9; j++) dp[i + 1][j] += sum;\n\n\t\t// 間に入れてAB BA ができる場合、それはそこまでで後ろにつける操作では実現不可能な並び\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tfor (int k = 0; k < 9; k++) {\n\n\t\t\t\tif (k == 1 || k == 3) continue;\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 || j / 3 * 3 + k / 3 == 3) && (j % 3 + k % 3 * 3 == 1 || j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif ((j / 3 * 3 + k / 3 == 1 && j % 3 * 3 + k % 3 == 3) || (j % 3 + k % 3 * 3 == 1 && j % 3 + k % 3 * 3 == 3)) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] -= dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//DMP(dp);\n\n\tmint ans = 0;\n\tfor (int i = 0; i < 9; i++) ans += dp[N / 2][i];\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst ll mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nconst int IMAX = 10000001;\nll fac[IMAX + 1], ifac[IMAX + 1];\ninline ll comb(int A, int B) {\n\treturn fac[A] * ifac[B] % mod * ifac[A - B] % mod;\n}\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\n\tint N;\n\tscanf_s(\"%d\", &N);\n\n\tfac[0] = 1;\n\trep1(i, IMAX) fac[i] = fac[i - 1] * i % mod;\n\tifac[IMAX] = modpow(fac[IMAX], mod - 2);\n\tfor (int i = IMAX; i > 0; i--) ifac[i - 1] = ifac[i] * i % mod;\n\n\tll kotae = 1;\n\trep(i, N) {\n\t\tkotae *= 3;\n\t\tif (!(i & 15)) kotae %= mod;\n\t}\n\tkotae %= mod;\n\n\tll k = 1;\n\trep(i, N / 2) {\n\t\tkotae -= 2 * fac[N] * ifac[i] % mod * ifac[N - i] % mod * k % mod;\n\t\tk = k * 2 % mod;\n\t}\n\tprintf(\"%lld\", (kotae % mod + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    // operator ll() const { return (num+MOD)%MOD; }\n    operator ll() const { return num; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { return modint(num + (ll)r); }\n    template <typename T>\n    modint operator-(const T &r) const { return modint(num - (ll)r); }\n    template <typename T>\n    modint operator*(const T &r) const { return modint(num * (ll)r); }\n    template <typename T>\n    modint operator/(const T &r) const { return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vvvvll = vector<vector<vector<vector<ll>>>>;\nusing pl4 = pair<ll,ll>;\nusing str = string;\nusing vpl4 = vector<pair<ll,ll>>;\n\n#define sz size()\n#define be begin()\n#define en end()\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\n#define llin(x) ll (x);cin >>(x);\n#define stin(x) str (x);cin >>(x);\n#define vllin(x,n) vll (x)(n);FOR(i,0,n-1){cin >>(x)[i];}\n#define vllin2(a,b,n) vll (a)(n);vll (b)(n);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i];}\n#define vllin3(a,b,c,n) vll (a)(n);vll (b)(n);vll (c)(n);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i]>>(c)[i];}\n#define vlling(x,n) (x).assign(n,0);FOR(i,0,n-1){cin >>(x)[i];}\n#define vlling2(a,b,n) (a).assign(n,0);(b).assign(n,0);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i];}\n#define vlling3(a,b,c,n) (a).assign(n,0);(b).assign(n,0);(c).assign(n,0);FOR(i,0,n-1){cin >>(a)[i]>>(b)[i]>>(c)[i];}\n#define vpl4in(x,n) vpl4 (x)((n),mp(0,0));FOR(i,0,n-1){cin >>x[i].fi>>x[i].se;}\n#define FOR(i,a,b) for(ll i = a ; i <= b ; i++)\n#define rFOR(i,b,a) for(ll i = a; i >= b ; i--)\n#define SORT(x) sort(x.be, x.en)\n#define rSORT(x) sort(x.rbegin(), x.rend())\n#define say(x) cout<<(x);\n#define sal(x) cout<<(x)<<endl;\n#define says(x) cout<<(x)<<(' ');\n#define sas cout<<(' ');\n#define sayR(x) cout<<fixed<<setprecision(10)<<(x);\n#define salR(x) cout<<fixed<<setprecision(10)<<(x)<<endl;\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<endl;\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<endl;\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<endl;\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<endl;\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;\n#define pow(a,b) ll(pow(a,b))\n\nll MOD=998244353;\nll MAX = 5000000;\n\nvll fac(MAX);\nvll finv(MAX);\nvll inv(MAX);\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long com(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nsigned main(){\n    COMinit();\n    llin(n);\n    n=n/2;\n    ll k=1;\n    FOR(i,0,n-1){\n        k=(k*9)%MOD;\n    }\n    vll f(n*2+1,1);\n    FOR(i,1,n*2){\n        f[i]=(f[i-1]*2)%MOD;\n    }\n    vll g(n/2+1,0);\n    g[n/2]=f[n/2]-1;\n    rFOR(i,2,n/2-1){\n        g[i]=(g[i+1]*2-com(n-i-1,i)*2-com(n-i-1,i-1))%MOD;\n    }\n    sal(g[2])\n    FOR(i,1,n){\n        if(i-1<n-i){\n            k=(k+MOD-(com(n,i)*f[(n-i)*2]*g[i-1])%MOD)%MOD;\n        }else{\n            k=(k+MOD-(com(n,i)*f[(n-i)*2]*f[n-i])%MOD)%MOD;\n        }\n    }\n    FOR(i,1,n){\n        k=(k+MOD-(com(n,i)*f[(n-i)*2]*f[min(i-1,n-i)])%MOD)%MOD;\n    }\n    sal(k)\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n \nconst int N=10000010;\nint n;\nint fac[N],inv[N],ci[N];\nconst long long mod=998244353;\n \nlong long ksm(long long x,long long t){\n\tlong long tot=1;\n\twhile(t){\n\t\tif(t&1) (tot*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t\tt/=2;\n\t}\n\treturn tot;\n}\n \nlong long C(int x,int y){\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n \nint main(){\n\tscanf(\"%d\",&n);\n\tlong long tot=0;\n\tfac[0]=ci[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod,ci[i]=ci[i-1]*2%mod;\n\tinv[n]=ksm(fac[n],mod-2);for(int i=n-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tfor(int i=n/2+1;i<=n;i++) tot+=C(n,i)*ci[n-i]%mod;\n\tprintf(\"%lld\\n\",(ksm(3,n)-tot*2%mod+mod)%mod);\n}\n/*\n————————————————\n版权声明：本文为CSDN博主「Deep_Kevin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Deep_Kevin/java/article/details/102900391\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nll MOD = 998244353;\nconst ll N = 1e7+10;\nll f[N], rf[N];\nll inv(ll x) {\n    ll res = 1;\n    ll k = MOD - 2;\n    ll y = x;\n    while (k) {\n        if (k & 1) res = (res * y) % MOD;\n        y = (y * y) % MOD;\n        k /= 2;\n    }\n    return res;\n}\nvoid init() {\n    f[0] = 1;\n    for(int i = 1; i < N; i++) f[i] = (f[i - 1] * i) % MOD;\n    for(int i = 0; i < N; i++) rf[i] = inv(f[i]);\n}\nll C(int n, int k) {\n    if(n < k) return 0;\n    ll a = f[n]; // = n!\n    ll b = rf[n-k]; // = (n-k)!\n    ll c = rf[k]; // = k!\n    ll bc = (b * c) % MOD;\n    return (a * bc) % MOD;\n}\n\nll mod_pow(ll x, ll n)\n{\n    ll res = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n        {\n            res = res * x % MOD;\n        }\n        x = x * x % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    init();\n    int n;\n    cin >> n;\n    ll ans = mod_pow(3, n);\n    ll tmp = 0;\n    for(int a = n/2 + 1; a <= n; a++)\n    {\n        tmp += C(n, a) * mod_pow(2, n-a) % MOD;\n        tmp %= MOD;\n    }\n    tmp = tmp * 2 % MOD;\n    ans = (ans - tmp + MOD) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 11000000; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(fact.size());\n\tifact.back() = 1 / fact.back();\n\tfor(int i = (int)fact.size() - 1; i >= 1; i--){\n\t\tifact[i-1] = i * ifact[i];\n\t}\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tp2[i] = 2 * p2[i-1];\n\t}\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * p2[i] * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static const int MOD = 998244353;\n\n    ll v;\n    modint(const int _v = 0): v(_v % MOD) {\n        if (v < 0) v += MOD;\n    }\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = 1LL * v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint(v) += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint(v) -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint(v) *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint(v) /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res = 1;\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(3, n);\n    modint cur = 0;\n    modint term = 1;\n    modint p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= (n - k + 1);\n        term *= k;\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n)\n{\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\nint main()\n{\n\tM = 998244353;\n\tll n, i, res = 1;\n\tcin >> n;\n\tll ans = mpow(3, n);\n\tfor (i = 0; i < n / 2; i++){\n\t\tans += M - res * mpow(2, i + 1) % M;\n\t\tans %= M;\n\t\tres *= n - i;\n\t\tres %= M;\n\t\tres *= modinv(i + 1);\n\t\tres %= M;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static const int MOD = 998244353;\n\n    int v;\n    modint(const int _v = 0): v(_v % MOD) {\n        if (v < 0) v += MOD;\n    }\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = 1LL * v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint(v) += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint(v) -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint(v) *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint(v) /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res = 1;\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nconstexpr int MAXN = 1e5;\nmodint fact[MAXN], tcaf[MAXN];\n\nvoid gen_fact() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    tcaf[MAXN - 1] = modint(1) / fact[MAXN - 1];\n    for (int i = MAXN - 2; i >= 0; --i) {\n        tcaf[i] = tcaf[i + 1] * (i + 1);\n    }\n}\n\nmodint choose(int n, int k) {\n    assert(n >= 0);\n    if (k < 0 or n < k)\n        return 0;\n\n    return fact[n] * tcaf[k] * tcaf[n - k];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(3, n);\n    modint cur = 0;\n    modint term = 1;\n    modint p = 2;\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= (n - k + 1);\n        term *= k;\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar_unlocked()\n#define pc(x) putchar_unlocked(x)\ntemplate<typename T> void scan(T &x){x = 0;bool _=0;T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\n\n\nint main(){\n    \n    puts(\"test\");\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\nll MOD = 998244353;\n\n// g = eGCD(a, b, s, t)  --->  sa + tb = g\nconstexpr ll eGCD(ll a, ll b, ll& s, ll& t) {\n  if (a == 0) {\n    s = 0;\n    t = 1;\n    return b;\n  }\n  ll u = 0;\n  ll g = eGCD(b % a, a, t, u);\n  s = u - (b / a) * t;\n  return g;\n}\n\nconstexpr ll gcd(ll a, ll b) {\n  ll dummy1 = 0;\n  ll dummy2 = 0;\n  return eGCD(a, b, dummy1, dummy2);\n}\n\nstruct Fp {\n  ll val;\n\n  Fp(ll t = 0) :\n    val(t < 0 ? MOD + t % MOD : t >= MOD ? t % MOD : t) {}\n\n  Fp& operator +=(const Fp& t) {\n    val += t.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n\n  Fp& operator -=(const Fp& t) {\n    val -= t.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n\n  Fp& operator *=(const Fp& t) {\n    val = (val * t.val) % MOD;\n    return *this;\n  }\n\n  Fp inv() const {\n    if (val == 0) {\n      cerr << \"inv() is called for zero.\" << endl;\n      exit(1);\n    }\n    ll u = 0;\n    ll v = 0;\n    eGCD(val, MOD, u, v);\n    return Fp(u);\n  }\n\n  Fp& operator /=(const Fp& t) {\n    return (*this) *= t.inv();\n  }\n\n  Fp operator +(const Fp& t) const { return Fp(val) += t; }\n  Fp operator -(const Fp& t) const { return Fp(val) -= t; }\n  Fp operator *(const Fp& t) const { return Fp(val) *= t; }\n  Fp operator /(const Fp& t) const { return Fp(val) /= t; }\n  Fp operator -() const { return Fp(-val); }\n\n  bool operator ==(const Fp& t) const { return val == t.val; }\n  bool operator !=(const Fp& t) const { return val != t.val; }\n  \n  operator ll() const { return val; }\n\n};\n\nclass Comb {\n  int nMax;\n  vector<Fp> vFact;\n  vector<Fp> vInvFact;\npublic:\n  Comb(int nm) : nMax(nm), vFact(nm+1), vInvFact(nm+1) {\n    vFact.at(0) = 1;\n    for (int i = 1; i <= nMax; i++) vFact.at(i) = i * vFact.at(i-1);\n    vInvFact.at(nMax) = vFact.at(nMax).inv();\n    for (int i = nMax; i >= 1; i--) vInvFact.at(i-1) = i * vInvFact.at(i);\n  }\n  Fp fact(int n) { return vFact.at(n); }\n  Fp comb(int n, int r) {\n    return vFact.at(n) * vInvFact.at(r) * vInvFact.at(n-r);\n  }\n  // The number of permutation extracting r from n.\n  Fp perm(int n, int r) {\n    return vFact.at(n) * vInvFact.at(n-r);\n  }\n};\n\n/* \n   Power function    power(a, b) == a^b\n   Speed is O(log b).\n   The same source code can be used for integers by replacing\n   Fp with int etc.  Unfortunately, replacing Fp with auto does not\n   make the function generic for int and Fp.\n */\nFp power(Fp a, int b) {\n  Fp twoPow = a;\n  Fp rv = 1;\n  while (b > 0) {\n    if (b & 1) rv *= twoPow;\n    twoPow *= twoPow;\n    b >>= 1;\n  }\n  return rv;\n}\n\n\nint main(int argc, char *argv[]) {\n  // C-style stdio functions should not be used.\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  ll N; cin >> N;\n  Comb cmb(N);\n  Fp cnt = Fp(0);\n  for (ll n = N/2 + 1; n <= N; n++) {\n    cnt += cmb.comb(N, n) * power(2, N-n);\n  }\n  Fp ans = power(3, N) - Fp(2) * cnt;\n  cout << ll(ans) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nconst int maxn = 1e7 + 10;\nll n;\n \nll fac[maxn];\nll inv[maxn];\nll ci[maxn];\n \nll quickpow(ll a, ll b){\n  ll ans = 1 % mod;\n  while(b){\n    if(b & 1)\n      ans = ans * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\n \n \nvoid init(){\n \n  fac[0] = ci[0] = 1;\n  for(ll i = 1; i <= n; i ++){\n    fac[i] = 1ll * fac[i - 1] * i % mod;\n    ci[i] = ci[i - 1] * 2 % mod;\n  }\n  inv[n] = quickpow(fac[n], mod - 2);\n  for(ll i = n - 1; i >= 0; i --)\n    inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n \n \n}\n \n \nll C(ll x, ll y){\n  return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n \n \nint main()\n{\n  scanf(\"%lld\",&n);\n  init();\n  ll ans = quickpow(3ll ,n) % mod;\n  ll x = 0;\n  for(ll i = n / 2 + 1; i <= n; i ++)\n    x += C(n, i) * ci[n - i] % mod;\n  printf(\"%lld\\n\",(ans - x * 2 % mod + mod) % mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <cstdio>\n\nconst int64_t MOD = 998244353;\nconst int N = 1e7 + 10;\nint n;\nint64_t fac[N], inv[N], pow2[N];\n\nint64_t pow(int64_t a, int exp) {\n    int64_t ret = 1;\n    while (exp) {\n        if (exp & 1) (ret *= a) %= MOD;\n        (a *= a) %= MOD;\n        exp >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int64_t a = pow(3, n), b = 0;\n    fac[0] = inv[0] = inv[1] = pow2[0] = 1;\n    for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD;\n    for (int i = 2; i < N; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    for (int i = 2; i < N; i++) (inv[i] *= inv[i - 1]) %= MOD;\n    for (int i = 1; i < N; i++) pow2[i] = (pow2[i - 1] << 1) % MOD;\n    for (int i = n / 2 + 1; i <= n; i++) (b += fac[n] * inv[i] % MOD * inv[n - i] % MOD * pow2[n - i]) %= MOD;\n    int64_t ans = ((a - 2 * b) % MOD + MOD) % MOD;\n    printf(\"%ld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\t\n#define WHATS(var)cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\nint xx;\n\nusing ll =long long ;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 10240000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tMod sum=mod_pow(3,N);\n\tMod kk=0;\n\tinit();\n\tMod x=1;\n\tfor(int i=0;i<=N/2-1;++i){\n\n\t\tkk+=comb(N,i)*x;\n\t\tx*=Mod(2);\n\t\t//WHATS(kk)\n\t}\n\t//WHATS(kk)\n\tsum=sum-kk*Mod(2);\n\tcout<<sum<<endl;\n\treturn 0;\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep(i,s,t )for(register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\nint gi() {\n    char cc = getchar() ; int cn = 0, flus = 1 ;\n    while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n    while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n    return cn * flus ;\n}\nconst int P = 998244353 ; \nconst int N = 1e7 + 5 ;\nint n, inv[N], fac[N], fp[N], Ans ;\nint fpow( int x, int k ) {\n    int ans = 1, base = x ;\n    while( k ) {\n        if( k & 1 ) ans = ans * base % P ;\n        base = base * base % P, k >>= 1 ;\n    } return ans ; \n}\nvoid inc( int &x, int y ) {\n    ( ( x += y ) >= P ) && ( x -= P ) ;\n}\nint C( int x, int y ) {\n    if( y > x ) return 0 ;\n    return fac[x] * inv[y] % P * inv[x - y] % P ;\n}\nsigned main()\n{\n    n = gi(), fp[0] = inv[0] = fac[0] = 1 ;\n    rep( i, 1, n ) fac[i] = fac[i - 1] * i % P, fp[i] = fp[i - 1] * 2 % P ; \n    inv[n] = fpow( fac[n], P - 2 ) ;\n    for( re int i = n; i >= 1; -- i ) inv[i - 1] = inv[i] * i % P ;\n    int m = ( n / 2 ) + 1, num = 0 ;\n    Ans = fpow( 3, n ) ;\n    for( re int i = m; i <= n; ++ i ) {\n        int dec = C( n, i ) ;\n        dec = dec * fp[n - i] % P ;\n        inc( num, dec ) ;\n    }\n    Ans = ( Ans - num * 2ll % P + P ) % P ;\n    printf(\"%lld\\n\", Ans ) ;\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int mod=998244353,N=1e7+5;\nint fac[N],inv[N],pw[N],n,tot;\n\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n\treturn res;\n}\n\nint C(int n,int m){\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nsigned main(){\n\tread(n);\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tpw[0]=1;for(int i=1;i<=n;i++) pw[i]=(pw[i-1]+pw[i-1])%mod;\n\tinv[n]=fpow(fac[n],mod-2);for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\tfor(int i=n/2+1;i<=n;i++) tot=(tot+pw[n-i]*C(n,i)%mod)%mod;\n\twrite((fpow(3,n)-tot-tot+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353,maxn=1e7;\nint n,injc[maxn+5],jc[maxn+5],pw[maxn+5],ans;\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;\n\t}\n\treturn res;\n}\nint C(int n,int k)\n{\n\treturn (1ll*jc[n]*injc[k]%mod)*injc[n-k]%mod;\n}\nvoid Init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<=maxn;i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tinjc[maxn]=binpow(jc[maxn],mod-2);\n\tfor (int i=maxn-1;i>=0;i--) injc[i]=1ll*injc[i+1]*(i+1)%mod;\n\tpw[0]=1;\n\tfor (int i=1;i<=maxn;i++) pw[i]=pw[i-1]*2%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tInit();\n\tfor (int i=n/2+1;i<=n;i++)\n\t{\n\t\tans=(1ll*C(n,i)*pw[n-i+1]+ans)%mod;\n\t}\n\tans=(binpow(3,n)-ans)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define ll long long\nusing namespace std;\n\nconst ll M = 998244353;\nconst ll N = (ll)(1e7+5);\n\nll fac[N];\nll ifac[N];\n\nll pow(ll b, ll p) {\n  if (!p) return 1;\n  if (p%2) return (b*pow(b,p-1))% M;\n  ll a = pow(b, p/2);\n  return (a*a)%M;\n}\n\nvoid work() {\n  fac[0] = 1;\n  for (ll i = 1; i < N; i++) {\n    fac[i] = (fac[i-1] * i) % M;\n  }\n  ifac[N-1] = pow(fac[N-1], M-2);\n  for (ll i = N-2; i >= 0; i--) {\n    ifac[i] = (ifac[i+1] * (i+1)) % M;\n  }\n}\n\nll nCk(ll n, ll k) {\n  return (((fac[n]*ifac[k]) % M) * ifac[n-k]) % M;\n}\n\n\nint main() {\n  work();\n  ll n;\n  cin >> n;\n\n  ll ret = 0;\n  for (ll i = n/2 + 1; i <= n; i++) {\n    ret = (ret + 2*nCk(n, i) * pow(2, n-i)) % M;\n  }\n  ret = (pow(3, n) - ret + M) % M;\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nvector<mint> frac, ifrac;\nvoid finit(ll X) {\n\tfrac.assign(X + 1, 1);\n\tifrac.assign(X + 1, 1);\n\n\trepn(i, X) {\n\t\tfrac[i] = frac[i - 1] * i;\n\t\tifrac[i] = ifrac[i - 1] / i;\n\t}\n\n}\n\nmint com(ll n, ll m) {\n\tif (n < 0 || m < 0 || n < m) { return 0; }\n\treturn frac[n] * ifrac[m] * ifrac[n - m];\n}\n\nint main() {\n\n\tll N;\n\tcin >> N;\n\n\tfinit(N);\n\tll M = N / 2;\n\n\tvector<mint> t(N + 1, 1);\n\trepn(i, N) t[i] = t[i - 1] * 2 - com(i-1, i-1 - M) - com(i-1, M);\n\n\t//rep(i, N + 1) cout << t[i] << endl;\n\n\tmint ans = 0;\n\trep(i, N + 1) ans += com(N, i)*t[i];\n\tcout << ans;\n\t\n\t\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst ll mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nconst int IMAX = 10000001;\nll fac[IMAX + 1], ifac[IMAX + 1], inv[IMAX + 1];\ninline ll comb(int A, int B) {\n\treturn fac[A] * ifac[B] % mod * ifac[A - B] % mod;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\n\tfac[0] = 1;\n\trep1(i, IMAX) fac[i] = fac[i - 1] * i % mod;\n\tifac[IMAX] = modpow(fac[IMAX], mod - 2);\n\tfor (int i = IMAX; i > 0; i--) ifac[i - 1] = ifac[i] * i % mod;\n\tinv[0] = 1;\n\trep1(i, IMAX) inv[i] = ifac[i] * fac[i - 1] % mod;\n\n\n\tll kotae = 1;\n\tll k = 1;\n\trep1(i, N) {\n\t\tll tmp = comb(N, i);\n\t\tk = k * 2 % mod;\n\t\tif (i > N / 2) {\n\t\t\tk = (k - comb(i - 1, i - 1 - N / 2) * 2 + mod * 2) % mod;\n\t\t}\n\t\tkotae += tmp * k % mod;\n\t\tkotae %= mod;\n\t}\n\tco(kotae% mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INCANT cin.tie(0), cout.tie(0), ios::sync_with_stdio(false), cout << fixed << setprecision(20);\n#define int long long\n#define gcd __gcd\n#define all(x) (x).begin(), (x).end()\ntemplate<class T>\nbool chmax(T& a, T b){return (a = max(a, b)) == b;}\ntemplate<class T>\nbool chmin(T& a, T b){return (a = min(a, b)) == b;}\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(...) _overload(__VA_ARGS__, repi, _rep)(__VA_ARGS__)\n#define _rev(i, n) revi(i, n, 0)\n#define revi(i, a, b) for(int i = (int)(a - 1); i >= (int)(b); i--)\n#define rev(...) _overload(__VA_ARGS__, revi, _rev)(__VA_ARGS__)\n#define each(i, n) for(auto&& i: n)\nconst int INF = 1e18, MOD = 998244353;\nint modpow(int a, int n){\n    if(n < 1) return 1;\n    if(n == 1) return a;\n    int m = modpow(a, n / 2), res;\n    res = (n % 2) ? a : 1;\n    return m * m % MOD * res % MOD;\n}\nint modinv(int a){\n    return modpow(a, MOD - 2);\n}\nint modfact(int a){\n    if(a < 2) return 1;\n    return a * modfact(a - 1) % MOD;\n}\nsigned main() {\n    INCANT;\n    int n, v[11111111] = {1}, fac, inv[11111111], res, tmp;\n    cin>>n;\n    res = modpow(3, n);\n    rep(i, n){\n        v[i + 1] = v[i] * 2;\n        v[i + 1] %= MOD;\n    }\n    fac = modfact(n);\n    inv[n] = modinv(fac);\n    rev(i, n){\n        inv[i] = inv[i + 1] * (i + 1);\n        inv[i] %= MOD;\n    }\n    tmp = 2 * fac % MOD * (n / 2) % MOD;\n    rep(i, n / 2){\n        tmp += inv[i] * inv[n - i] % MOD * v[i] % MOD;\n    }\n    cout<<(res - tmp + MOD) % MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*((invFact[a-b]*invFact[b])%MOD)%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += tempPow2*ncr(N, i)%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e7+5,mod=998244353;\ntypedef long long ll;\nll f[N],invf[N],sum[N];\nint n;\nll C(ll n,ll m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nll qpow(ll a,ll n)\n{\n    ll ans=1;\n    while(n)\n    {\n        if(n&1) ans=ans*a%mod;\n        a=a*a%mod;\n        n>>=1;\n    }\n    return ans;\n}\nint main()\n{\n    f[0]=f[1]=invf[0]=invf[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        f[i]=f[i-1]*i%mod;\n        invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    }\n    for(int i=2;i<N;i++) invf[i]=invf[i]*invf[i-1]%mod;\n    for(int i=1;i<N;i++) sum[i]=(sum[i-1]+C(n,i))%mod;\n    int n;scanf(\"%d\",&n);\n    ll ans=qpow(3,n);\n    for(int i=n/2+1;i<=n;i++)\n        ans=(ans-C(n,i)*qpow(2,n-i)%mod*2)%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\n//繰り返し二乗法\nll power(ll a,ll b){\n\tll res=1;\n\twhile(b>0){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=power(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(1<<20);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tll ans=power(3,n);\n\tll res=0;\n\tfor(int i=0;i<n/2;i++){\n\t\tll k=p.comb(n,i);\n\t\t(k*=power(2,i))%=mod;\n\t\t(res+=k)%=mod;\n\t}\n\tcout << (ans-2*res+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 10000012\n#define mod 998244353\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nint n,fac[N],inv[N],ans,ans1,P[N];\nint main(){\n\tP[0]=1;for(int i=1;i<N;i++)P[i]=M(P[i-1]<<1);\n\tfac[0]=1;for(int i=1;i<N;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[N-1]=ksm(fac[N-1],mod-2);for(int i=N-2;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tscanf(\"%d\",&n);ans=ksm(3,n);int i;\n\tfor(i=(n>>1)+1;i<=n;i++)ans1=(ans1+1ll*inv[i]*inv[n-i]%mod*P[n-i])%mod;\n\tans1=1ll*ans1*fac[n]%mod;ans=M1(ans-M(ans1<<1));printf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename M>\nclass Enumeration{\nprivate:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    init(k);\n    M res(0);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res*=finv[k];\n  }\n\n  static vector< vector<M> > D(int n,int m){\n    vector< vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);\n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);\n    M res(0);\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];\n    return res;\n  }\n\n  static M montmort(int n){\n    init(n);\n    M res(0);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;\n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    vector<M> dp(n+1,1),pd(n+1,1);\n    for(int i=0;i<n;i++) dp[i+1]=dp[i]*(t-M(i));\n    for(int i=n;i>0;i--) pd[i-1]=pd[i]*(t-M(i));\n    M res(0);\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*dp[i]*pd[i]*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs=vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n  n/=2;\n  using M = Mint<int, 998244353>;\n  using E = Enumeration<M>;\n  E::init(n*2+10);\n\n  M res=E::C(n*2,n);\n  M ans=res;\n\n  for(int c=1;c<n;c++){\n    res=E::C(n*2-c,n-c)+res/M(2);\n    ans+=E::C(n*2,c)*res;\n  }\n\n  for(int c=n;c<=n*2;c++)\n    ans+=E::C(n*2,c)*M(2).pow(n*2-c);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <climits>\n#include <iomanip>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nlong long mod = 998244353;\nlong long modpow(long long m,long long n){\n    long long res = 1;\n    if(n > 0){\n        res = modpow(m,n / 2);\n        if(n % 2 == 0){\n            res = (res * res) % mod;\n        }\n        else{\n            res = (((res * res) % mod) * m) % mod;\n        }\n    }\n    return res;\n}\nint main(){\n  ll n = 0;\n  cin >> n;\n  ll res = 0;\n  //res = modpow(3,n),res %= mod;\n  vector<ll> fac(n + 1);\n  fac[0] = 1;\n  for(int i = 1;i < n + 1;i++)fac[i] = fac[i - 1] * i,fac[i] %= mod;\n  //cout << fac[\n  for(int i = n / 2 + 1;i <= n;i++){\n    //cout << i << endl;\n    ll now = 1;\n    now *= fac[n];\n    now *= modpow(fac[i],mod - 2),now %= mod;\n    now *= modpow(fac[n - i],mod - 2),now %= mod;\n    now *= modpow(2,n - i),now %= mod;\n    //now *= 2,now %= mod;\n    res += now;\n    //while(res < 0)res += mod;\n    res %= mod;\n  }\n  res *= 2,res %= mod;\n  res = modpow(3,n) - res;\n  if(res < 0)res += mod;\n  res %= mod;\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define reps(i, m, n) for (int i = m; i < n; i++)\n#define repr(i, m, n) for (int i = m; i >= n; i--)\n#define db(x) cout << #x << \"=\" << x << endl;\ntemplate <class T>\nbool maxi(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool mini(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n#define INF2 1000000000000000037\n#define INF 1000000007\n#define PI (acos(-1))\n#define MOD 998244353\n#define EPS 1e(-9);\nusing namespace std;\ntypedef long long ll;\n//--GLOBAL---------------------------------\nconst int MAX = 10000010;\nll fac[MAX], finv[MAX], inv[MAX];\nvoid cinit() { // O(nlogn)\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  reps(i, 2, MAX){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nll c(int n, int k){ // 二項係数計算\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll modpow(ll a, ll n, ll mod=MOD){ // a^n % MOD の計算\n  ll res = 1;\n  while (n > 0){\n      if(n & 1) res = res * a % mod;\n      a = a * a  % mod;\n      n >>= 1;\n  }\n  return res;\n}\n\n//--MAIN-----------------------------------\nvoid Main() {\n\n    ll N; cin>>N;\n    cinit();\n\n    ll res=modpow(3LL,N);\n\n    ll hu=1;\n\n    for(ll i=N;i>N/2;i--){\n        res-=2*hu*c(N,i);\n\n        res=res+(2LL*MOD*MOD);\n        res%=MOD;\n        hu*=2;\n        hu%=MOD;\n    }\n\n    cout<< res<<\"\\n\";\n\n\n}\n\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n//-----------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc040/tasks/agc040_c\n\n#include \"algorithm\"\n#include \"iostream\"\n#include \"numeric\"\n#include \"queue\"\n#include \"set\"\n#include \"vector\"\n#define rep(i, to) for (ll i = 0; i < (to); ++i)\n#define repf(i, from, to) for (ll i = from; i < (to); ++i)\n#define repr(i, from) for (ll i = from - 1; i >= 0; --i)\n#define all(vec) vec.begin(), vec.end()\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\nusing V = vector<T>;\nusing VL = V<ll>;\nusing VVL = V<VL>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\nusing PL = P<ll, ll>;\nusing VPL = V<PL>;\ntemplate <typename T>\ninline bool chmax(T& a, T b);\ntemplate <typename T>\ninline bool chmin(T& a, T b);\nvoid print_ints(vector<ll> v);\ntemplate <typename T>\nvoid drop(T a);\n\ntemplate <int MOD>\nclass Fp {\n public:\n  long long val;\n  constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n    if (val < 0) v += MOD;\n  }\n  constexpr int getmod() { return MOD; }\n  constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n  constexpr Fp operator+(const Fp& r) const noexcept { return Fp(*this) += r; }\n  constexpr Fp operator-(const Fp& r) const noexcept { return Fp(*this) -= r; }\n  constexpr Fp operator*(const Fp& r) const noexcept { return Fp(*this) *= r; }\n  constexpr Fp operator/(const Fp& r) const noexcept { return Fp(*this) /= r; }\n  constexpr Fp& operator+=(const Fp& r) noexcept {\n    val += r.val;\n    if (val >= MOD) val -= MOD;\n    return *this;\n  }\n  constexpr Fp& operator-=(const Fp& r) noexcept {\n    val -= r.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  constexpr Fp& operator*=(const Fp& r) noexcept {\n    val = val * r.val % MOD;\n    return *this;\n  }\n  constexpr Fp& operator/=(const Fp& r) noexcept {\n    long long a = r.val, b = MOD, u = 1, v = 0;\n    while (b) {\n      long long t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    val = val * u % MOD;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  constexpr bool operator==(const Fp& r) const noexcept {\n    return this->val == r.val;\n  }\n  constexpr bool operator!=(const Fp& r) const noexcept {\n    return this->val != r.val;\n  }\n  friend constexpr ostream& operator<<(ostream& os, const Fp<MOD>& x) noexcept {\n    return os << x.val;\n  }\n  friend constexpr istream& operator>>(istream& is, Fp<MOD>& x) noexcept {\n    return is >> x.val;\n  }\n  friend constexpr Fp<MOD> modpow(const Fp<MOD>& a, long long n) noexcept {\n    if (n == 0) return 1;\n    auto t = modpow(a, n / 2);\n    t = t * t;\n    if (n & 1) t = t * a;\n    return t;\n  }\n};\n\nconst ll MOD = 998244353;\n// const ll MOD = 1000000007;\nusing mint = Fp<MOD>;\n\nstruct combination_table {\n  // i! % MOD M\n  V<ll> fact;\n  // (i!)^(-1) MOD M\n  V<ll> finv;\n  // i^(-1) MOD M\n  V<ll> inv;\n\n  ll mod;\n};\n\n// ref: http://drken1215.hatenablog.com/entry/2018/06/08/210000\ncombination_table prepare_combination(ll max, ll mod) {\n  V<ll> fact(max + 1);\n  V<ll> finv(max + 1);\n  V<ll> inv(max + 1);\n\n  fact[0] = 1;\n  fact[1] = 1;\n  finv[0] = 1;\n  finv[1] = 1;\n  inv[1] = 1;\n\n  for (ll i = 2; i <= max; i++) {\n    fact[i] = fact[i - 1] * i % mod;\n    inv[i] = mod - inv[mod % i] * (mod / i) %\n                       mod;  // a^(-1) ≡ -(p % a)^(-1) * (p/a) MOD p\n    finv[i] = finv[i - 1] * inv[i] % mod;\n  }\n\n  combination_table res = {\n      fact,\n      finv,\n      inv,\n      mod,\n  };\n\n  return res;\n}\n\nll c_m(ll n, ll k, combination_table& ct) {\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return ct.fact[n] * (ct.finv[k] * ct.finv[n - k] % ct.mod) % ct.mod;\n}\n\nll p_m(ll n, ll k, combination_table& ct) {\n  return c_m(n, k, ct) * ct.fact[k] % ct.mod;\n}\n\nvoid solve() {\n  ll N;\n  cin >> N;\n\n  mint a_over_half = 0;\n  auto ct = prepare_combination(N, MOD);\n\n  for (ll i = N / 2 + 1; i <= N; i++) {\n    a_over_half += mint(c_m(N, i, ct)) * modpow(mint(2), N - i);\n  }\n\n  mint res = modpow(mint(3), N) - mint(2) * a_over_half;\n  cout << res << endl;\n}\n\nstruct exit_exception : public std::exception {\n  const char* what() const throw() { return \"Exited\"; }\n};\n\n#ifndef TEST\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  try {\n    solve();\n  } catch (exit_exception& e) {\n  }\n\n  return 0;\n}\n#endif\n\ntemplate <typename T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\nvoid print_ints(vector<ll> v) {\n  rep(i, v.size()) {\n    if (i > 0) {\n      cout << \" \";\n    }\n\n    cout << v[i];\n  }\n\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid drop(T res) {\n  cout << res << endl;\n  throw exit_exception();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    long long int N,can=7,n=2,bcan=7;\n    cin >> N;\n    if(N==2){\n        cout << 7 << endl;\n    }else{\n        for(int i=0;i<N/2-1;i++){\n            can = can*9 + n*(2+i);\n            n = n*2 + i-1;\n            can %= 998244353;\n            n %= 998244353;\n        }\n        cout << can << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n#include<vector>\n\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\nclass CNeitherABNorBA {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      if (n%2 == 1) {\n        cout << 0 << endl;\n      }\n      mod = mod9;\n\n      combination comb = combination(n);\n      vector<mint> vec(n+1);\n      vector<mint> vec2(n+1);\n      vec[0] = 1;\n      vec2[0] = 1;\n      rep(i, n) {\n        vec[i+1] = vec[i] * 3;\n        vec2[i+1] = vec2[i] * 2;\n      }\n\n      mint ng = 0;\n      int k = n/2-1;\n      for(int i=0; i<=k; i++) {\n        ng += comb.get(n, i)*vec2[i];\n      }\n\n      mint all = vec[n];\n\n      cout << (all - ng*2).x << endl;\n\n    }\n};\n\nsigned main() {\n  CNeitherABNorBA solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>::value || is_same<T, modint>::value);\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//#include \"math/modulo.h\"\n\ntemplate<class T, T M>\nstruct modulo {\n\tT n;\n\tmodulo(T n): n(n<0? n%M+M: n%M)   { }\n\toperator T() const                { return n;             }\n\tmodulo operator-() const          { return modulo(-n);    }\n\tmodulo operator+(const modulo &o) const { return modulo(n+o.n); }\n\tmodulo operator-(const modulo &o) const { return modulo(n-o.n); }\n\tmodulo operator*(const modulo &o) const { return modulo(n*o.n); }\n\tbool  operator< (const modulo &o) const { return n< o.n; }\n\tbool  operator<=(const modulo &o) const { return n<=o.n; }\n\tbool  operator> (const modulo &o) const { return n> o.n; }\n\tbool  operator>=(const modulo &o) const { return n>=o.n; }\n\tbool  operator==(const modulo &o) const { return n==o.n; }\n\tbool  operator!=(const modulo &o) const { return n!=o.n; }\n\n\tmodulo pow(T n) const {\n\t\tmodulo y = 1, x = *this;\n\t\twhile (n) {\n\t\t\tif (n%2) y = y * x;\n\t\t\tn /= 2;\n\t\t\tx = x * x;\n\t\t}\n\t\t/*\n\t\tif (n==0) return 1;\n\t\tmodulo y = pow(n/2);\n\t\ty = y*y;\n\t\tif (n%2) y = y * (*this);\n\t\t*/\n\t\treturn y;\n\t}\n\tmodulo inv() const {\n\t\treturn pow(M-2);\n\t}\n\tmodulo operator/(const modulo &o) const {\n\t\treturn (*this) * o.inv();\n\t}\n\n\tT gcd_ext(T a, T b, T *x, T *y) {\n\t\tif (a == 0) {\n\t\t\t*x = 0;\n\t\t\t*y = 1;\n\t\t\treturn b;\n\t\t}\n\t\tT x1, y1;\n\t\tT gcd = gcd_ext(b%a, a, &x1, &y1);\n\t\t*x = y1 - (b/a) * x1;\n\t\t*y = x1;\n\t\treturn gcd;\n\t}\n\tmodulo div(const modulo &o) const {\n\t\tT x, y;\n\t\tT g = gcd_ext(o.n, M, &x, &y);\n\t\tif (g != 1) return 0;\n\t\telse return modulo(n * (x % M));\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const modulo &x) {\n\t\treturn os << x.n;\n\t}\n};\n\ntypedef modulo<long,998244353> T;\n//#include \"math/comb.h\"\n\nvoid comb_inc_k(T &r, int n, int &k) {\n        //C(n,k+1) = C(n,k) * (n-k) / (k+1)\n\tr = r * T(n-k) / T(k+1);\n\tk++;\n}\n\nvoid comb_dec_k(T &r, int n, int &k) {\n        //C(n,k-1) = C(n,k) * k / (n-k+1)\n\tr = r * T(k) / T(n-k+1);\n\tk--;\n}\n\nvoid comb_inc_n(T &r, int &n, int k) {\n        //C(n+1,k) = C(n,k) * (n+1) / (n+1-k)\n\tr = r * T(n+1) / T(n+1-k);\n\tn++;\n}\n\nvoid comb_dec_n(T &r, int &n, int k) {\n        //C(n-1,k) = C(n,k) * (n-k) / n\n\tr = r * T(n-k) / T(n);\n\tn--;\n}\n\nT comb(int n, int k) {\n    if (k*2 > n) k = n-k;\n    if (n==0) return 0;\n    T r = 1; //C(n,0)\n    int i = 0;\n    while (i<k) comb_inc_k(r, n, i);\n    return r;\n}\n\n\n#define MAXN 100000\n\nint n;\n\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\treturn 1;\n}\n\nvoid init() {\n}\n\nint solve() {\n\tT r = T(3).pow(n);\n\tint k = n/2;\n\tT e = comb(n, k);\n\twhile (k+1<=n) {\n\t\tcomb_inc_k(e, n, k);\n\t\tr = r - e*T(2).pow(n-k)*T(2);\n\t}\n\treturn r;\n}\n\nvoid output(int ans) {\n\tprintf(\"%d\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ntypedef long long int ll;\nconst int maxn=1E7+5; \nconst int limit=10000000;\nll fac[maxn],inv[maxn],P2[maxn];\ninline ll qpow(ll x,ll y)\n{\n\tll ans=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\ninline void init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=limit;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[limit]=qpow(fac[limit],mod-2);\n\tfor(int i=limit-1;i>=0;--i)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\tP2[0]=1;\n\tfor(int i=1;i<=limit;++i)\n\t\tP2[i]=P2[i-1]*2%mod;\n}\ninline ll C(int x,int y)\n{\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tinit();\n\tint n;\n\tcin>>n;\n\tll ans=qpow(3,n),s=0;\n\tfor(int i=n/2+1;i<=n;++i)\n\t\ts=(s+P2[n-i]*C(n,i))%mod;\n\tcout<<((ans-s*2)%mod+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int MOD = 998244353;\nconst int MAXN = 10000000;\nint sub(int x, int y) {return x - y < 0 ? x - y + MOD : x - y;}\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint pw2[MAXN + 5], fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tpw2[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tpw2[i] = 2LL*pw2[i-1]%MOD;\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\nint comb(int n, int m) {\n\treturn 1LL*fct[n]*ifct[m]%MOD*ifct[n-m]%MOD;\n}\nint main() {\n\tinit();\tint N;\n\tscanf(\"%d\", &N);\n\tint ans = pow_mod(3, N);\n\tfor(int i=N/2+1;i<=N;i++)\n\t\tans = sub(ans, 2LL*comb(N, i)*pw2[N-i]%MOD);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define int long long\n\nconst int MOD = 998244353;\nconst int N = 1e7 + 12;\n\nlong long ans;\nlong long deg2[N], fact[N], ufact[N], r[N];\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    deg2[0] = 1, fact[0] = 1, ufact[0] = 1, r[1] = 1;\n    for (int i = 2; i < N; i++) r[i] = MOD - (MOD / i) * r[MOD % i] % MOD;\n    for (int i = 1; i < N; i++) deg2[i] = deg2[i - 1] * 2 % MOD, fact[i] = fact[i - 1] * i % MOD, ufact[i] = ufact[i - 1] * r[i] % MOD;\n    ans = 1;\n    for (int i = 0; i < n; i++) ans = ans * 3 % MOD;\n    for (int c = n / 2 + 1; c <= n; c++)\n    {\n        ans = (ans - cnk(n, c) * deg2[n - c + 1] + MOD * MOD) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nusing Int = long long;\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<Int, Int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},  // 自身\n};\nInt get_msb(long long x) {\n    assert(x != 0);\n    return 63 - __builtin_clzll(x);\n}\nInt get_lsb(long long x) {\n    assert(x != 0);\n    return __builtin_ctzll(x);\n}\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, const vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const set<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T> ostream& operator<<(ostream& s, const multiset<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, const unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n    #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n    #define dump(...)\n    #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct FastIO { FastIO() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); } } fast_io;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr Int MOD = 998244353;\n// **********************************************************************************************\n// **********************************************************************************************\n// **********************************************************************************************\n// **************************************** TEMPLATE END ****************************************\n// **********************************************************************************************\n// **********************************************************************************************\n// **********************************************************************************************\n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n\nsigned main() {\n    Int n; cin >> n;\n    init_factorial(n);\n    mint ans = pow(mint(3), n);\n    mint cur = 1;\n    REP (x, n / 2) {\n        cur *= 2;\n        ans -= comb(n, x) * cur;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename S, typename T>\nvoid incr_m(M<S, T> &m, S k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   (998244353LL)\n\nstatic ll perms[10000005];\nstatic ll perm_invs[10000005];\n\nvoid make_perms(void)\n{\n    perms[0] = 1LL;\n    rep (i, 10000005LL) {\n        perms[i+1LL] = perms[i] * (i+1LL);\n        perms[i+1LL] %= MOD;\n    }\n\n    rep (i, 10000005) perm_invs[i] = mod_inv(perms[i], MOD);\n\n    debug_printf(\"---- perms\\n\");\n    debug_print(perms, 10);\n}\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n\n    make_perms();\n\n    ll ng_cnt = 0LL;\n    srep (acnt, n/2LL+1LL, n+1LL) {\n        // n_C_acnt\n        ll partition = 1LL;\n        partition *= perms[n];\n        partition %= MOD;\n        partition *= perm_invs[acnt];\n        partition %= MOD;\n        partition *= perm_invs[n-acnt];\n        partition %= MOD;\n\n        // b or c\n        ll bc_cnt = mod_pow(2LL, n - acnt, MOD);\n\n        ll incr = partition * bc_cnt;\n        incr %= MOD;\n\n        ng_cnt += incr;\n        ng_cnt %= MOD;\n    }\n\n    ng_cnt *= 2LL;\n    ng_cnt %= MOD;\n\n    ll ans = mod_pow(3LL, n, MOD);\n    ans -= ng_cnt;\n    while (ans < 0LL) ans += MOD;\n\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Header files, namespaces,\n// macros as defined above\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n\n#define f first\n#define s second\n#define db long double\n#define pb push_back\n#define sz(c) (c).size()\n#define all(c) (c).begin(),(c).end()\n\ntypedef long long ll;\ntypedef pair <int , int> ii;\ntypedef pair <ii , int> iii;\ntypedef vector <ll> vi;\ntypedef vector <ii> vii;\ntypedef vector <vi> vvi;\ntypedef vector <vii> vvii;\n\nconst ll mod = 998244353;\nconst int MAX = 1e7+7;\nconst db eps = 1e-13;\n\n\nll f[MAX];\nll invf[MAX];\nll ans;\n\nll exp( ll a , ll b ) {\n    ll res = 1;\n    while( b ) {\n\n        if( b%2 ) {\n            res = ( res * a ) % mod;\n        }\n        a = ( a * a ) % mod;\n        b /= 2ll;\n\n    }\n\n    return res;\n}\n\nvoid initFact() {\n    f[0] = 1;\n    for( int i = 1 ; i < MAX ; i++ )\n        f[i] = f[i-1] * i % mod;\n\n    invf[MAX-1] = exp( f[MAX-1] , mod-2 );\n    for( int i = MAX-2 ; i >= 0 ; i-- ) {\n\n        invf[i] = invf[i+1] * (i+1) % mod;\n\n    }\n}\n\nll combination( ll a , ll b ) {\n    return f[a] * invf[a-b] % mod * invf[b] % mod;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n    cout<<setprecision(0)<<fixed;\n\n    initFact();\n\n    int n;cin>>n;\n\n    ans = exp(3 , n);\n\n    vi p2(n+1,1);\n    for( int i = 1 ; i <= n ; i++ )\n        p2[i] = p2[i-1] * 2 % mod;\n\n    for( int i = (n/2+1) ; i <= n ; i++ ) {\n        ans -= ( combination(n , i) * p2[n-i] * 2 ) % mod;\n        ans += mod;\n        ans %= mod;\n    }\n\n    cout<<ans<<\"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n\nlong long modpow(int n, int r) {\n    long long ret = 1; long long tmp = (long long) n;\n    while (r != 0) {\n        if (r % 2) ret *= tmp;\n        tmp *= tmp; tmp %= mod; ret %= mod;\n        r /= 2;\n    }\n    return ret;\n}\n\nlong long inv(int n) {\n    return modpow(n, mod-2);\n}\n\nint main() {\n    int n; cin >> n;\n    long long all = modpow(3, n);\n    long long sub = 0;\n    long long comb = 1;\n    long long pow2 = 1;\n    for (int i = 0; i < n/2; i++) {\n        sub = (sub + (comb * pow2 % mod)) % mod;\n        comb = comb * (n-i) % mod * inv(i+1) % mod;\n        pow2 = pow2 * 2 % mod;\n        //cout << comb << \" \" << sub << endl;\n    }\n    cout << (all + mod - sub * 2 % mod) % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define ll long long \nusing namespace std;\n\nconst int maxn=2e5+10;\nconst int mod=998244353;\nint n;\nll poww(ll x,ll k) {\n\tll ans=1;\n\twhile(k) {\n\t\tif(k&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nll mul[maxn],inv[maxn],er[maxn],ans;\nll C(int a,int b) {\n\treturn mul[a]*inv[b]%mod*inv[a-b]%mod;\n}\nll QwQ;\nint main() \n{\n\tscanf(\"%d\",&n);\n\tmul[0]=1,er[0]=1;\n\tfor(int i=1;i<=n;++i) mul[i]=mul[i-1]*i%mod,er[i]=er[i-1]*2%mod;\n\tinv[n]=poww(mul[n],mod-2);\n\tfor(int i=n;i;i--) inv[i-1]=inv[i]*i%mod;\n\tinv[0]=1;\n\tfor(int i=n/2+1;i<=n;++i) {\n\t\tQwQ=(QwQ+C(n,i)*er[n-i]%mod)%mod;\n\t}\n\tcout<<(poww(3,n)-QwQ*2%mod+mod)%mod<<\"\\n\";\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cin, cout, cerr\n#include <algorithm> // minmax, sort, swap\n#include <numeric> // iota\n#include <cstdio> // printf, scanf\n#include <string> // string, stoi, to_string\n#include <vector> // vector\n#include <queue> // queue, priority_queue\n#include <deque> // deque\n#include <map> // key-value pairs sorted by keys\n#include <set> // set\n#include <iomanip> // cout<<setprecision(n)\n#include <functional> // function<void(int)>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ENDL '\\n'\n#define print(i) std::cout << (i) << '\\n'\n\n#define int long long // at least int64 > 9*10^18\n#define all(v) (v).begin(), (v).end()\n/* libraries */\n\nconstexpr int MOD = 998244353;\nstruct mint\n{\n\tint v;\n\tmint():v(0){}\n\tmint(int v):v((v+MOD)%MOD){}\n\tmint operator-()const{ return mint(0) - *this; }\n\tmint& operator+=(const mint& a){ if((v+=a.v)>=MOD) v-=MOD; return *this; }\n\tmint& operator-=(const mint& a){ if((v+=MOD-a.v)>=MOD) v-=MOD; return *this; }\n\tmint& operator*=(const mint& a){ (v*=a.v)%=MOD; return *this; }\n\tmint& operator/=(const mint& a){ (*this) *= a.inv(); return *this; }\n\tmint operator+(const mint& a)const{ return mint(*this) += a; }\n\tmint operator-(const mint& a)const{ return mint(*this) -= a; }\n\tmint operator*(const mint& a)const{ return mint(*this) *= a; }\n\tmint operator/(const mint& a)const{ return mint(*this) /= a; }\n\tbool operator<(const mint& a)const{ return v < a.v; }\n\tbool operator==(const mint& a)const{ return v == a.v; }\n\tmint pow(int k)const{ mint r(1),t(v); while(k){ if(k&1) r*=t; t*=t; k>>=1; } return r; }\n\tmint inv()const{ return pow(MOD-2); }\n\tstatic mint comb(int n, int k) {\n\t\tif(n-k<k) k=n-k;\n\t\tmint num(1), dom(1);\n\t\tfor(int i=0;i<k;i++) { num*=n-i; dom*=i+1; }\n\t\treturn num/dom;\n\t}\n};\nstd::istream& operator>>(std::istream&i,mint&a){ int t; i>>t; a=mint(t); return i; }\nstd::ostream& operator<<(std::ostream&o,const mint&a){ o<<a.v; return o; }\n\n\nsigned main() {\n\tint n;\n\tstd::cin >> n;\n\tmint ans = mint(3).pow(n);\n\tfor(int i=0;i<n/2;i++) {\n\t\tmint x = mint::comb(n,n-i);\n\t\tx*=mint(2).pow(i);\n\t\tans-=mint(2)*x;\n\t}\n\tprint(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = (int)1e7 + 50;\nconst ll mod = 998244353;\n\nint n;\nll fac[N], facinv[N];\nll inv[N], pw[N];\n\nll fp(ll x, ll k){\n    if(k == 0) return 1;\n    ll hf = fp(x, k/2);\n    return k % 2 ? hf * hf % mod * x % mod: hf * hf % mod;\n}\n\nll comb(int n, int k){\n    return fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nvoid init_fac() {\n    inv[1] = 1;\n    for(int i = 2; i < N; i++) inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n    fac[0] = 1;\n    for(int i = 1; i <= N-1; i++) fac[i] = fac[i-1] * i % mod;\n    facinv[N-1] = fp(fac[N-1], mod - 2);\n    for(int i = N-1 - 1; i >= 0; i--) facinv[i] = facinv[i+1] * (i+1) % mod;\n    pw[0] = 1;\n    for(int i = 1; i < N; i++) pw[i] = pw[i-1] * 2 % mod;\n}\n\nll ssum[N];\n\n\nint main(){\n    init_fac();\n    cin >> n;\n    n /= 2;\n    for(int i = n; i >= 1; i--) {\n        ssum[i] = (comb(n, i) * pw[n - i] + ssum[i+1]) % mod;\n    }\n    ll comp = 0;\n    for(int i = 0; i <= n; i++) {\n        comp += comb(n, i) * pw[i] % mod * ssum[i+1] % mod;\n        comp %= mod;\n    }\n    ll res = 1;\n    for(int i = 0; i < n; i++) res = (res * 9) % mod;\n    cout << ((res - comp * 2) % mod + mod) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-12L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n#define int ll\nmodint<MOD> mae[2000000];\nmodint<MOD> gyaku[2000000];\nmodint<MOD> comb(int a, int b) {\n    modint<MOD> ans = mae[a];\n    ans *= gyaku[b];\n    ans *= gyaku[a - b];\n    return ans;\n}\nvoid solve(){\n    int n;\n    cin >> n;\n    mae[0] = 1;\n    gyaku[0] = 1;\n    for (int q = 1; q <= n; ++q) {\n        mae[q] = mae[q - 1] * q;\n        gyaku[q] = modint<MOD>(1) / mae[q];\n    }\n    modint<MOD> mul = 2;\n    modint<MOD> ans = 0;\n    for (int q = n; q > n / 2; --q) {\n        ans += comb(n, q) * mul;\n        mul *= 2;\n    }\n    ans = pows<modint<MOD>>(3, n) - ans;\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC optimize(\"unroll-loops\")    \n#include <bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define len(a) int(a.size())\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n        \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n        \ntypedef long long base; \ntypedef pair<int, int> point;      \ntypedef complex<double> comp;\n\nconst int N = 1e7 + 5;\nconst int p = 998244353;\n\nint sum(int a, int b) {\n    a += b;\n    return a >= p ? a - p : a;\n}\n\nint mul(long long a, int b) {\n    return a * b % p;\n}\n\nint powx(int a, int b) {\n    int ans = 1;\n    while (b) {\n        if (b & 1) ans = mul(ans, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return ans;\n}\n\nint n;\n\nint px[N];\nint f[2][N];\n\nint cnk(int n, int k) {\n    return mul(f[0][n], mul(f[1][n - k], f[1][k]));\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    srand(time(0));\n#ifdef ONPC\n    freopen(\"input\", \"r\", stdin);\n#endif\n    cin >> n;\n    px[0] = 1;\n    f[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        f[0][i] = mul(f[0][i - 1], i);\n        px[i] = sum(px[i - 1], px[i - 1]);\n    }\n    f[1][n] = powx(f[0][n], p - 2);\n    for (int i = n - 1; i >= 0; --i) {\n        f[1][i] = mul(f[1][i + 1], i + 1);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (i <= n - i) continue;\n        ans = sum(ans, mul(cnk(n, i), px[n - i]));\n    }\n    ans = sum(ans, ans);\n    ans = sum(powx(3, n), p - ans);\n    cout << ans << '\\n';\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n#define int int64_t\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvector<int64_t> ncr_arr;\nvoid calc_nCr(int n, int64_t rem) {\n\tncr_arr = vector<int64_t>(n / 2 + 1);\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n / 2) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\n#undef int\nint main()\n{\n#define int int64_t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tcalc_nCr(n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint i = n - k;\n\t\tint64_t val = ncr_arr[i];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nlong long inf=(long long)1E17;\n//#define i_7 (long long)(1E9+7)\n#define i_7 998'244'353\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nusing namespace std;\n\n//typedef long long ll;\nlong long po(long a, long b){\n    if(b==0){\n        return 1;\n    }\n    \n    long long z = po(a,b/2);\n    z = mod(z*z);\n    if(b%2!=0){\n        z = mod(a*z);\n    }\n    return z;\n}\n\n//配列のSIZEは問題ごとに定義する必要がある。\nconst int SIZE=10'000'010;\nlong long inv[SIZE+1];//各iの逆元を格納する配列。\nlong long kai[SIZE+1];//i!のmodを格納する配列。\nlong long invkai[SIZE+1];//各i!の逆元を格納する配列。\nconst int MOD=i_7;\nvoid invinit(){//上の配列を初期化する関数。\n    inv[1]=1;\n    for(int i=2;i<=SIZE;i++){\n        inv[i] = MOD - ((MOD/i)*inv[MOD%i])%MOD;\n    }\n    \n    kai[0]=invkai[0]=1;\n    for(int i=1;i<=SIZE;i++){\n        kai[i]=(kai[i-1]*i)%MOD;\n        invkai[i]=(invkai[i-1]*inv[i])%MOD;\n    }\n}\n\nlong long comb(long long a, long long b){\n    if(b<0 || a<b){\n        return 0;\n    }\n    return mod(kai[a]*mod(invkai[b]*invkai[a-b]));\n}\n\nint main(){\n  invinit();\n  long long n;\n  cin>>n;\n  long long ans = po(3LL, n);\n  for(long long k = n/2 + 1; k<=n; k++){\n    long long temp = comb(n,k);\n    temp *= po(2LL, n-k);\n    temp = mod(temp);\n    ans -= 2*temp;\n    ans = mod(ans);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>() || is_same<T,modint>(), \"T is not integral\");\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 998244353;\n\nll Power(ll x, int n) {\n  ll result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      n--;\n      result *= x;\n      result %= mod;\n    } else {\n      n /= 2;\n      x *= x;\n      x %= mod;\n    }\n  }\n  return result;\n}\n\nll Inverse(ll x) {\n  ll result = Power(x, mod - 2);\n  assert(result * x % mod == 1);\n  return result;\n}\n\nll GetC(int n, int k, const vector<ll>& fact) {\n  ll result = fact[n];\n  result *= Inverse(fact[k]);\n  result %= mod;\n  result *= Inverse(fact[n - k]);\n  result %= mod;\n  return result;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  ll result = 1;\n  for (int i = 0; i < n; ++i) {\n    result *= 3;\n    result %= mod;\n  }\n  vector<ll> pow2(n);\n  pow2[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    pow2[i] = pow2[i - 1] * 2 % mod;\n  }\n\n  vector<ll> fact(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = fact[i - 1] * i % mod;\n  }\n\n  for (int a = n / 2 + 1; a <= n; ++a) {\n    ll cur = GetC(n, a, fact);\n    cur *= pow2[n - a] * 2;\n    cur %= mod;\n    result -= cur;\n    result %= mod;\n    result += mod;\n    result %= mod;\n  }\n  cout << result << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 10000005;\nconst ll MOD = 998244353;\n\nint n;\n\nll ans;\nll fac[MAXN];\nll inv[MAXN];\n\nll power(ll a,ll b)\n{\n\tll res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(res *= a) %= MOD;\n\t\t(a *= a) %= MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(int x,int y)\n{\n\treturn fac[x] * inv[y] % MOD * inv[x - y] % MOD;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfac[0] = 1;\n\tfor (int i = 1;i <= n;i++)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinv[n] = power(fac[n],MOD - 2);\n\tfor (int i = n;i >= 1;i--)\n\t\tinv[i - 1] = inv[i] * i % MOD;\n\tans = power(3,n);\n\tll pw2 = 1;\n\tfor (int i = n;i >= n / 2 + 1;i--)\n\t{\n\t\t(ans -= 2 * C(n,i) * pw2) %= MOD;\n\t\t(pw2 <<= 1) %= MOD;\n\t}\n\tprintf(\"%lld\\n\",(ans + MOD) % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<24);\n \nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    ll ans=mod_pow(3,n);\n    vector<ll> p2(n+1,1);\n    for(int i=0;i<n;i++){\n        p2[i+1]=p2[i]*2%mod;\n    }\n    for(int i=n/2+1;i<=n;i++){\n        ans-=p.comb(n,i)*p2[n-i]*2;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n#define int int64_t\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvector<int64_t> ncr_arr;\nvoid calc_nCr(int n, int64_t rem) {\n\tncr_arr = vector<int64_t>(n + 1);\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\n#undef int\nint main()\n{\n#define int int64_t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tcalc_nCr(n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = ncr_arr[k];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 998244353\n#define maxn 10000010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll fac[maxn],inv[maxn],p2[maxn],p3[maxn];\nint n;\nll C(int n,int m){return (n<0||m<0||m>n)?0:fac[n]*inv[m]%mod*inv[n-m]%mod;}\nll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nint main()\n{\n\tn=read();\n\tinv[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tinv[0]=fac[0]=p2[0]=p3[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\t\tp2[i]=p2[i-1]*2%mod; p3[i]=p3[i-1]*3%mod;\n\t}\n\tll ans=p3[n];\n\tfor(int i=n/2+1;i<=n;i++)\n\t\tans=(ans-2*C(n,i)*p2[n-i]%mod+mod)%mod;\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 998244353;\n\nlong long pow(long long a, long long r) {\n    if (r == 0) return 1LL;\n    long long y = pow(a, r/2);\n    long long z = (y * y) % prime;\n    if (r % 2 == 1) {\n        return (a * z) % prime;\n    }\n    return z;\n}\n\nlong long inv(long long a) {\n    return pow(a, prime-2);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<long long> xs(n+1);\n    xs[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        xs[i] = ((n-i+1) * xs[i-1]) % prime;\n    }\n    vector<long long> twos(n+1);\n    twos[0] = 1;\n    for (int i = 1;i <= n; ++i) {\n        twos[i] = (twos[i-1] * 2) % prime;\n    }\n    long long sum = 0;\n    for (int k = n/2 + 1; k <= n; ++k) {\n        sum += xs[k] * xs[n-k] % prime * twos[n-k+1];\n        sum %= prime;\n    }\n    sum = (sum * inv(xs[n])) % prime;\n    long long result = (pow(3LL, (long long) n) - sum + prime) % prime;\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 998244353;\n\nll powmod(ll a, ll b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = int(res * 1ll * a % mod), --b;\n        } else {\n            a = int(a * 1ll * a % mod), b >>= 1;\n        }\n    }\n    return res;\n}\n\nll reverse(ll a) {\n    return powmod(a, mod - 2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<ll> two(n + 1);\n    vector<ll> three(n + 1);\n    vector<ll> fact(n + 1);\n    vector<ll> finv(n + 1);\n    two[0] = three[0] = fact[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        three[i] = (3ll * three[i - 1]) % mod;\n        two[i] = (2ll * two[i - 1]) % mod;\n        fact[i] = (1ll * i * fact[i - 1]) % mod;\n    }\n    finv[n] = reverse(fact[n]);\n    for (int i = n - 1; i >= 0; --i) {\n        finv[i] = ((i + 1) * finv[i + 1]) % mod;\n    }\n    auto C = [fact, finv](int n, int k) {\n      return (((fact[n] * finv[k]) % mod) * finv[n - k]) % mod;\n    };\n    ll ans = three[n];\n    for (int i = n / 2 + 1; i <= n; ++i) {\n        ans = (mod + ans - 2 * C(n, i) * two[n - i]) % mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define X first\n#define Y second\n\ntemplate<typename T> // order_of_key(), *find_by_order()\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nmt19937_64 gen(time(nullptr));\n\nll const mod = 998244353;\n\nnamespace {\n    ll mul(ll a, ll b) {\n        ll val = a * b - (ll) ((ld) a * b / mod) * mod;\n        if (val < 0) val += mod;\n        if (val >= mod) val -= mod;\n        return val;\n    }\n\n    ll poww(ll a, ll b) {\n        ll val = 1;\n        a %= mod;\n        while (b > 0) {\n            if (b % 2) val = mul(a, val);\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return val % mod;\n    }\n\n    ll inv(ll a) {\n        return poww(a, mod - 2);\n    }\n}\nll const maxn = 1e7+7;\nll fact[maxn];\n\nll C(ll n, ll k) {\n    return mul(fact[n], inv(mul(fact[n - k], fact[k])));\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        fact[i] = fact[i - 1] * i;\n        fact[i] %= mod;\n    }\n    ll n;\n    cin >> n;\n    ll ans = poww(3, n);\n    ll kek = 0;\n    for (ll i = n / 2 + 1; i <= n; i++) {\n        (kek += mul(C(n, i), poww(2, n - i))) %= mod;\n    }\n    kek = mul(kek, 2);\n    cout << ((ans - kek) % mod + mod) % mod << endl;\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "//＊最初に、入力のNを1/2倍しておく。以降では1≦N≦6*10^5として考える。\n//AB, BA -> AA, BBと置き換えて良い. （偶数番目のAをBに, BをAにした文字列Tを考えると分かる）\n//置き換え後、A,BだけならAB,BAを消せるので、AとBが同数が必要条件。\n//逆にAとBが同数(1個以上)なら, AB, BAがどこかに存在するので、帰納的に十分性が成立。\n//Cは(AまたはB)として使えるので、長さ2NのABC列であって「A,BがN個以下」を数えれば良い。\n//否定を取ると「AがN+1個以上」または「BがN+1個以上」となりこれは排反かつ対称な条件なので嬉しい。\n//「AがN+1個以上」はAの個数を全探索すれば容易に計算可能。\n//1～Nのmod P (P=998244353)での逆元の計算にO(NlogP)かけると厳しいが、これはO(N)にできるので大丈夫。\n\n#include <iostream>\n#define int long long\nusing namespace std;\n\nconst int MAX = 10000010;\nconst int mod = 998244353;\nint fact[MAX], finv[MAX], inv[MAX];\nint pow2[MAX];\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\nint n;\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tn /= 2;\n\t\n\t//参考：http://drken1215.hatenablog.com/entry/2018/06/08/210000\n\tfact[0] = fact[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (i = 2; i < MAX; i++) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n\t\n\tpow2[0] = 1;\n\tfor (i = 1; i < MAX; i++) {\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\t}\n\t\n\tint ngCnt = 0;\n\tfor (i = n + 1; i <= 2 * n; i++) {\n\t\tngCnt += comb(2 * n, i) * pow2[2 * n - i] % mod;\n\t\tngCnt %= mod;\n\t}\n\t\n\tint all = 1;\n\tfor (i = 0; i < 2 * n; i++) (all *= 3) %= mod;\n\t\n\tint ans = (all - 2 * ngCnt + 2 * mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n//#define int long long\n#define F first\n#define S second\n#define pii pair<int,int>\n#define mpr make_pair\n\nconst int maxn = 1e7+10;\nconst int mod = 998244353;\nconst ll inf = 1e9+10;\n\nint n;\n\nint pw(int a, int b)\n{\n    if(b == 0) return 1;\n    int x = pw(a,b/2); x = (x * 1ll * x) % mod;\n    if(b & 1) x = (x * 1ll * a) % mod;\n    return x;\n}\n\nint fac[maxn], repo[maxn];\nint C(int n, int k)\n{\n    return (fac[n] * 1ll * ((repo[k] * 1ll * repo[n-k]) % mod)) % mod;\n}\n\nsigned main()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> n;\n    fac[0] = repo[0] = 1;\n    for(int i = 1; i <= n; i++)\n        fac[i] = (fac[i-1] * 1ll * i) % mod;\n    repo[n] = pw(fac[n], mod-2);\n    for(int i = n-1; i >= 1; i--)\n        repo[i] = (repo[i+1] * 1ll * (i+1)) % mod;\n\n    int ans = pw(3,n);\n    int power = 1;\n    for(int k = 0; k <= n/2-1; k++)\n    {\n        (ans -= (2ll * ((C(n,k) * 1ll * power) % mod)) % mod) %= mod;\n        (power *= 2) %= mod;\n    }\n    cout<< (ans + mod) % mod;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 10555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = 1;\n  for (ll i = 1; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n  }\n  rfact[n] = mod_inverse(fact[n], M);\n  for (ll i = n - 1; i >= 0; i--) {\n      rfact[i] = (i + 1) * rfact[i + 1] % M;\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    ll mul = 1;\n    for (int i = n; i > n / 2; i--) {\n    // for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mul % MOD;\n        mul = mul * 2 % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll m = 998244353;\n\nint main() {\n  int n; cin >> n;\n  \n  // aa, bb, ac, bc, ca, cb, cc\n  // aa + bb, bb + aa\n  // ac + bb, ca + bb\n  // bc + aa, cb + aa, ac + bc, ca + bc\n  // 文字挿入(lastあるよ)\n  \n  ll dp[2][3][3]; // 直前2つの状態 c, a, b\n  for(int i=0; i<3; i++)for(int j=0; j<3; j++) dp[0][i][j] = 0; dp[0][0][0] = 1;\n  \n  for(int i=1; i<=n/2; i++) {\n    for(int j=0; j<3; j++) for(int k=0; k<3; k++) {\n      dp[1][j][k] = 0;\n    }\n    \n    ll sm = 0;\n    for(int j=0; j<3; j++) for(int k=0; k<3; k++) {\n      sm += dp[0][j][k];\n    }\n    \n    dp[1][0][0] = dp[0][1][0] + dp[0][2][0] + sm; // bc + ac, ac + bc\n    \n    dp[1][1][0] = dp[0][2][0] + sm; // ac... bc+aa\n    dp[1][2][0] = dp[0][1][0] + sm; // bc... ac+bb\n    dp[1][0][1] = dp[0][2][1] + dp[0][1][1] + sm; // ca... ba + ac, aa + bc\n    dp[1][0][2] = dp[0][1][2] + dp[0][1][1] + sm; // cb... ab + bc, bb + ac\n    dp[1][1][1] = sm; // aa... cc + aa, ba + aa\n    dp[1][2][2] = sm; // bb... cc + bb, ab + bb\n    \n    dp[1][2][1] = 2*(\n      dp[0][1][1] + dp[0][2][1] + dp[0][0][1]);\n    // ba... aa + bb, aa + cb, ba + bb, ... (aa, ba, ca)(bb, cb)\n    \n    dp[1][1][2] = 2*(\n      dp[0][2][2] + dp[0][0][2] + dp[0][1][2]);\n    // ab... bb + aa, cb + aa, ab + aa, ... (ab, bb, cb)(aa, ca)\n    \n    for(int j=0; j<3; j++)for(int k=0; k<3; k++) dp[1][j][k]%=m;\n    for(int j=0; j<3; j++)for(int k=0; k<3; k++) dp[0][j][k]=dp[1][j][k];\n  }\n  \n  ll an = 0;\n  for(int j=0; j<3; j++){\n    for(int k=0; k<3; k++) {an = (an + dp[1][j][k])%m; cout << dp[1][j][k] << \" \";} cout << endl;\n  }\n  cout << an << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:256000000\")\n#pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <assert.h>\n#include <set>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <random>\n#include <map>\n#include <bitset>\n\n#define sz(a) (int)((a).size())\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nmt19937 rng(time(NULL));\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\nusing vb = vector<bool>;\n\nconst ll MOD = 998244353;\n\nll sqr(ll a) {\n\treturn a * a;\n}\n\nll powmod(ll a, ll x, ll p = MOD) {\n\tif (x <= 0) return 1;\n\tif (x % 2 == 0) return sqr(powmod(a, x >> 1, p)) % p;\n\telse return (a * powmod(a, x - 1, p)) % p;\n}\n\nll gcd(ll a, ll b) {\n\tif (a < b) return gcd(b, a);\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\tint N;\n\tcin >> N;\n\n\tvector<ll> fact(1, 1);\n\tfor (int i = 1; i <= N; i++) fact.pb((fact.back() * i) % MOD);\n\n\tvector<ll> ofact(N + 1);\n\tofact[N] = powmod(fact[N], MOD - 2, MOD);\n\tfor (int i = N - 1; i >= 0; i--) ofact[i] = (ofact[i + 1] * (i + 1)) % MOD;\n\n\tll ans = 0;\n\tll pw2 = 2;\n\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tans += ((pw2 * fact[N]) % MOD) * ((ofact[i] * ofact[N - i]) % MOD);\n\t\tans %= MOD;\n\t\tpw2 *= 2;\n\t\tif (pw2 >= MOD) pw2 -= MOD;\n\t}\n\n\tcout << (powmod(3, N) - ans + MOD) % MOD << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>                                           \n \n//#define int long long\n//#pragma GCC optimize(\"Ofast\")\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n \n \n#define file(s) freopen(s\".in\",\"r\",stdin); freopen(s\".out\",\"w\",stdout);\n#define forev(i, b, a) for(int i = (b); i >= (a); --i)\n#define forn(i, a, b) for(int i = (a); i <= (b); ++i)\n#define all(x) x.begin(), x.end()\n#define sz(s) (int)s.size()\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define s second\n#define f first\n \n \nusing namespace std;\n \n \ntypedef pair < long long, long long > pll;    \ntypedef pair < int, int > pii;\ntypedef unsigned long long ull;         \ntypedef vector < pii > vpii;\ntypedef vector < int > vi;\ntypedef long double ldb;  \ntypedef long long ll;  \ntypedef double db;                             \n \n \nconst int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1}, block = 555;\nconst pii base = mp(1171, 3307), Mod = mp(1e9 + 7, 1e9 + 9);\nconst int inf = 1e9, maxn = 4e5 + 148, mod = 998244353, N = 1e7 + 5;\nconst db eps = 1e-12, pi = 3.14159265359;\nconst ll INF = 1e18;\n\nint n, ans, p[N], f[N], rf[N];\n\nint binpow (int a, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1)\n\t\t\tres = res * 1ll * a % mod;\n\t\ta = a * 1ll * a % mod;\n\t\tn >>= 1;\n\t}\n\n\treturn res;\n}\n\nint rev (int x) {\n\treturn binpow(x, mod - 2);\n}\n\nvoid precalc () {\n\tf[0] = 1;\n\tforn (i, 1, N - 1)\n\t\tf[i] = f[i - 1] * 1ll * i % mod;\n\n\trf[N - 1] = rev(f[N - 1]);\n\tforev (i, N - 2, 0)\n\t\trf[i] = rf[i + 1] * 1ll * (i + 1) % mod;\n\n\tp[0] = 1;\n\tforn (i, 1, N - 1)\n\t\tp[i] = p[i - 1] * 2ll % mod;\n}\n\nint cnk (int n, int k) {\n//\tcerr << f[n] << ' ' << rf[k] << ' ' << rf[n - k] << endl;\n\treturn f[n] * 1ll * rf[k] % mod * 1ll * rf[n - k] % mod;\n}\n\n\nvoid add (int &x, int y) {\n\tx += y;\n\tif (x < 0)\n\t\tx += mod;\n\tif (x >= mod)\n\t\tx -= mod;\n}\n\n\nmain () {\n\tprecalc();\n\tcin >> n;\n\tans = 1;\n\tforn (i, 1, n)\n\t\tans = ans * 3ll % mod;\t\n\n\tforn (i, n / 2 + 1, n)\t{\t\n\t\tadd(ans, -cnk(n, i) * 2ll * p[n - i] % mod); \n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define itn int\n#define For(i, a, b) for (int i = (a); i <= static_cast<int>(b); i++)\n#define Forr(i, a, b) for (int i = (a); i >= static_cast<int>(b); i--)\n#define rep(i, n) For(i, 0, n - 1)\n#define repall(i, arr) for (auto& i : (arr))\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << '\\n'\n#define dump2(x, y) \\\n    cerr << #x << \" = \" << (x) << \" \" << #y << \" = \" << (y) << '\\n'\n#define SZ(x) ((int)(x).size())\n#define bit(n) (1LL << (n))\nconstexpr int MOD = 998244353;\n\ntemplate <typename T>\nusing pq = priority_queue<T>;\ntemplate <typename T>\nusing pqr = priority_queue<T, vector<T>, greater<T>>;\nconst int INF = LLONG_MAX / 2;\nusing P = pair<int, int>;\nusing vec = vector<int>;\ntemplate <typename T>\nusing mat = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& stream, const pair<T1, T2>& p) { return stream << p.first << \",\" << p.second; }\ntemplate <typename T>\nvoid print(const vector<T> vec) { rep (i, vec.size() - 1) cout << vec[i] << ' '; cout << vec[vec.size() - 1] << '\\n'; }\ntemplate <typename Arg>\nvoid print(const Arg arg) { cout << arg << '\\n'; }\ntemplate <typename Head, typename... Args>\nvoid print(const Head head, const Args... args) { cout << head << \" \"; print(args...); }\ntemplate <typename T, typename U>\nvoid init(vector<T>& v, vector<U>& w) { rep (i, v.size()) cin >> v[i] >> w[i]; }\ntemplate <typename T>\nvoid init(vector<T>& v) { rep (i, v.size()) cin >> v[i]; }\ntemplate <typename T>\nT sum_(vector<T> vec, T init = 0) { return std::accumulate(all(vec), T(init)); }\ntemplate<typename T>\nbool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T>\nbool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T>\nint index(const T& vec, const typename T::iterator it) { return distance(vec.begin(), it); }\ntemplate <typename T = int>\nmat<T> mmat(int n, int m=0) { return mat<T>(n, vector<T>(m)); }\ntemplate <typename T = int>\nvector<T> ivec(int n) { vector<T> v(n); init(v); return v; }\n// clang-format on\n\nvoid yn(bool tf) { print(tf ? \"Yes\" : \"No\"); }\nvoid YN(bool tf) { print(tf ? \"YES\" : \"NO\"); }\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n// -------------------------------------------------------------------\n// sort 1 2 3 4\n// pqr 1 2 3 must impl >\n// need to define MOD\nclass mint {\n    using ll = long long;\n    ll num;\n\npublic:\n    mint(ll x = 0) : num(x % MOD) {}\n    mint operator+=(const mint& x) noexcept {\n        this->num += x.num;\n        if (this->num >= MOD) this->num %= MOD;\n        return *this;\n    }\n    mint operator-=(const mint& x) noexcept {\n        if (this->num < x.num) this->num += MOD;\n        this->num -= x.num;\n        return *this;\n    }\n    mint operator*=(const mint& x) noexcept {\n        this->num = (this->num * x.num) % MOD;\n        return *this;\n    }\n    mint operator/=(mint x) noexcept {\n        ll exp = MOD - 2;\n        while (exp) {\n            if (exp % 2) *this *= x;\n            x *= x;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint operator%=(const mint& x) noexcept {\n        this->num %= x.num;\n        return *this;\n    }\n    mint operator+(const mint& x) const noexcept { return mint(*this) += x; }\n    mint operator-(const mint& x) const noexcept { return mint(*this) -= x; }\n    mint operator*(const mint& x) const noexcept { return mint(*this) *= x; }\n    mint operator/(const mint& x) const noexcept { return mint(*this) /= x; }\n    mint operator%(const mint& x) const noexcept { return mint(*this) %= x; }\n    mint operator&(const mint& x) const noexcept { return this->num & x.num; }\n    bool operator==(const mint& x) const noexcept { return this->num == x.num; }\n    bool operator!=(const mint& x) const noexcept { return not((*this) == x); }\n    explicit operator bool() const noexcept { return this->num != 0; }\n    explicit operator int() const noexcept { return this->num; }\n\n    friend ostream& operator<<(ostream&, const mint&);\n};\n\nostream& operator<<(ostream& stream, const mint& x) { return stream << x.num; }\n\nmint mpow(mint r, mint _n) {\n    mint re = 1;\n    int n = (int)_n;\n    for (; n; n /= 2) {\n        if (n & 1) re *= r;\n        r *= r;\n    }\n    return re;\n}\n\nclass ModuloCombination {\n    using ll = long long;\n    ll mod, len;\n    std::vector<ll> f, rf;\n\n    ll inv(ll x) {\n        ll res = 1;\n        ll k = mod - 2;\n        ll y = x;\n        while (k) {\n            if (k & 1) res = (res * y) % mod;\n            y = y * y % mod;\n            k /= 2;\n        }\n        return res;\n    }\n\npublic:\n    ModuloCombination(ll mod_, ll max_len = 101010)\n        : mod(mod_),\n          len(max_len + 1),\n          f(std::vector<ll>(len)),\n          rf(std::vector<ll>(len)) {\n        f[0] = 1;\n        for (int i = 0; i < len - 1; i++) f[i + 1] = f[i] * (i + 1) % mod;\n        for (int i = 0; i < len; i++) rf[i] = inv(f[i]);\n    }\n    ll c(int n, int k) {\n        if (n < 0 or k < 0 or n - k < 0) {\n            std::cerr << \"(n,k) = \" << n << \" \" << k << std::endl;\n            exit(0);\n        }\n        ll a = f[n];\n        ll b = rf[n - k];\n        ll c = rf[k];\n        ll bc = (b * c) % mod;\n        return (a * bc) % mod;\n    }\n    ll getMod() { return mod; }\n};\n\nsigned main() {\n    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<mint> po(n + 1);\n    po[0] = 1;\n    For(i, 1, n) po[i] = po[i - 1] * 2;\n\n    ModuloCombination comb(MOD, n + 10);\n\n    mint kahan = 0;\n    int over = n / 2 + 1;\n    For(i, over, n) kahan += po[n - i] * comb.c(n, i);\n\n    print(mpow(3, n) - kahan * 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define lowbit(x) ((x) & -(x))\n#define lson l,mid,id<<1\n#define rson mid+1,r,id<<1|1\n#define MID(l, r) (((l)+(r))>>1)\n#define fi first\n#define se second\n\ntypedef pair<int, int> pii;\n\nconst int maxn = (int) 1e7 + 20;\n//const int MOD = 1e9 + 7;\nconst int MOD = 998244353;\nconst double eps = 1e-8;\n\n\ntemplate < typename T > inline void read(T &x)\n{\n    static bool f;\n    static char ch;\n\n    f = 0;\n    x = 0;\n    ch = getchar();\n\n    while(ch < '0' || '9' < ch) {if(ch == '-') f = 1; ch = getchar();}\n    while('0' <= ch && ch <= '9') {x = (x << 3) + (x << 1) + (ch & 15); ch = getchar();}\n\n    if(f) x = -x;\n}\n\nLL gcd(LL a, LL b) {if(!b) return a; return gcd(b, a % b);}\nLL fp(LL a, LL n, LL m = MOD) {LL res; for(res = 1; n; a = a * a % m, n >>= 1) if(n & 1) res = res * a % m; return res;}\n\ntemplate <typename T> inline T minx(T a, T b) {if(a < b) return a; return b;}\ntemplate <typename T> inline T maxx(T a, T b) {if(a < b) return b; return a;}\n\nint n;\nLL pow2[maxn];\nLL fac[maxn], ifac[maxn];\n\nLL comb(int n, int m)\n{\n    return fac[n] * ifac[n - m] % MOD * ifac[m] % MOD;\n}\n\nvoid work()\n{\n    cin >>n;\n    pow2[0] = 1;\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++)\n    {\n        pow2[i] = pow2[i - 1] << 1;\n        if(pow2[i] >= MOD) pow2[i] -= MOD;\n\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    ifac[n] = fp(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--)\n    {\n        ifac[i] = ifac[i + 1] * (i + 1) % MOD;\n    }\n\n    LL tmp = 0;\n    for(int i = n / 2 + 1; i <= n; i++)\n    {\n        tmp += comb(n, i) * pow2[n - i] % MOD;\n        if(tmp >= MOD) tmp -= MOD;\n    }\n\n    LL ans = fp(3, n, MOD) - tmp * 2;\n    cout <<(ans % MOD + MOD) % MOD <<endl;\n}\n\n\nint main()\n{\n#ifdef yukihana0416\nfreopen(\"in.txt\", \"r\", stdin);\n#endif // yukihana0416\n\n    int tc = 1;\n//    read(tc);\n\n    for(int ca = 1; ca <= tc; ca++)\n    {\n//        printf(\"Case #%d: \", ca);\n        work();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst int MAXN = 1.1e7;\n\nint N;\nll fac[MAXN];\nll finv[MAXN];\n\nll cpow (ll b, int e)\n{\n    if (e == 0) return 1;\n    ll v = cpow (b, e / 2);\n    v = (v * v) % MOD;\n    if (e % 2)\n        v = (v * b) % MOD;\n    return v;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    fac[0] = 1;\n    for (int i = 1; i <= N; i++)\n        fac[i] = (fac[i-1] * i) % MOD;\n    finv[N] = cpow (fac[N], MOD - 2);\n    for (int i = N - 1; i >= 0; i--)\n        finv[i] = (finv[i+1] * (i + 1)) % MOD;\n\n    ll p2 = 1;\n    ll ans = 0;\n    for (int i = 0; i < N / 2; i++)\n    {\n        // N choose i * 2 ^ i\n        ll nadd = (fac[N] * ((finv[i] * finv[N-i]) % MOD)) % MOD;\n        ans = (ans + (nadd * p2)) % MOD;\n\n        p2 = (2 * p2) % MOD;\n    }\n    ans = (2 * ans) % MOD;\n\n    ll p3 = 1;\n    for (int i = 0; i < N; i++)\n        p3 = (3 * p3) % MOD;\n    ans = (p3 - ans + MOD) % MOD;\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\ntypedef pair<ll,ll> P;\ntypedef pair<P,long double> Pi;\ntypedef pair <long double,int> Pd;\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=1000000007;\nconst ll mod=998244353;\n//ios_base::sync_with_stdio(false);\n//cin.tie(NULL);\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nconst ll MAX = 10000001;//設定して\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;//＊１\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n//階乗\nlong long factor(ll n,ll k){\n  if (n<k) return 0;\n  if (n<0 || k<0) return 0;\n  return (fac[n]*finv[k])%mod;\n}\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n//aの逆元求めるならn=mod-2\nlong long modpow(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nll n;\ncin>>n;\n COMinit();\n ll ans=0;\n ans=modpow(3ll,n);\n ll now=2;\n for(int i=0;i<n/2;i++){\n     ans-=COM(n,i)*now;\n     if(ans<0)ans+=mod;\n     now*=2;\n }\n cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nlong long *fact, *inv;\n\ntemplate <typename T, typename U, typename V>\nconstexpr auto pow(T x_, U n_, V mod_) {\n    std::common_type_t<T, U, V> ret = 1, x = x_, n = n_, mod = mod_;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nconstexpr auto inverse(T x, U p) { return pow(x, p - 2, p); }\n\nvoid init_factorial(int n, long long mod) {\n    fact = new long long[n + 1];\n    inv = new long long[n + 1];\n    fact[0] = 1;\n    for (long long i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (long long i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nint main() {\n    constexpr i64 mod = 998244353;\n    i64 n;\n    std::cin >> n;\n    i64 m = n / 2;\n    init_factorial(m + 1, mod);\n\n    i64 t = 0, ret = 0, two = 1, itwo = pow(2, m - 1, mod);\n    constexpr i64 k = inverse(2, mod);\n    for (int i = 1; i <= m; i++) {\n        t = (t + fact[m] * inv[i - 1] % mod * inv[m - i + 1] % mod * two % mod) % mod;\n        ret = (ret + fact[m] * inv[i] % mod * inv[m - i] % mod * itwo % mod * t % mod) % mod;\n        two = two * 2 % mod;\n        itwo = itwo * k % mod;\n    }\n\n    ret = (pow(3, n, mod) + mod - ret * 2 % mod) % mod;\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<char,char> PCC;\ntypedef pair<ll,ll> PLL;\ntypedef pair<char,int> PCI;\ntypedef pair<int,char> PIC;\ntypedef pair<ll,int> PLI;\ntypedef pair<int,ll> PIL; \ntypedef pair<ll,char> PLC; \ntypedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\ntemplate<int MOD> struct Fp {\n    ll val;\n    constexpr Fp(ll v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\n//const int MOD = 1e6 + 3;\n//const int MOD = 1e9 + 7;\nconst int N_MAX = 1e7+5;\n//mint:mod演算のための型\nusing mint = Fp<MOD>;\n//型変換\n#define MINT (mint)\n\n//mod MOD上での階乗\nmint fact[N_MAX];\nmint finv[N_MAX];\nvoid init(){\n  fact[0] = fact[1] = MINT 1;\n  for(int i = 2; i < N_MAX; i++){\n    fact[i] = fact[i-1] * i;\n  }\n  finv[N_MAX-1] = MINT 1/fact[N_MAX-1];\n  for(int i = N_MAX-1; i>0; --i){\n    finv[i-1] = finv[i] * i;\n  }\n}\n\n//mod MOD上での逆元\ninline mint inv(mint n){\n  return MINT 1/n;\n}\n\n//二項係数の計算(mod MOD上)\ninline mint COM(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[k]*finv[n-k];\n}\n\n//順列計算\ninline mint PER(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[n-k];\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  init();\n  int N;cin >> N;\n  mint ans = modpow(MINT 3, N);\n  mint mpow[N+1];\n  mpow[0] = 1;\n  rep(i,N) mpow[i+1] = MINT 2 * mpow[i];\n  repp(k,N/2+1,N+1){\n    ans -= MINT 2 * COM(N,k)*mpow[N-k];\n  }\n  cout << ans << endl;\n  return 0;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_N 10000000\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int MOD = 998244353;\n\nint n;\n\nlint putere(int a, int b)\n{\n    lint rez = 1;\n    lint ca = a;\n    for(int i = 0; (1 << i) <= b; i ++)\n    {\n        if(((1 << i) & b) != 0)\n        {\n            rez *= ca;\n            rez %= MOD;\n        }\n\n        ca *= ca;\n        ca %= MOD;\n    }\n\n    return rez;\n}\n\nlint p2[MAX_N + 1];\nlint fact[MAX_N + 1];\nlint inv[MAX_N + 1];\n\nvoid euclid(lint a, lint b, lint &x, lint &y, lint &d)\n{\n    if(b == 0)\n    {\n        x = 1;\n        y = 0;\n\n        d = a;\n        return;\n    }\n\n    lint xx, yy, q = a / b;\n    euclid(b, a % b, xx, yy, d);\n    x = yy;\n    y = xx - yy * q;\n}\n\nlint comb(int n, int k)\n{\n    return (fact[n] * inv[k] % MOD * inv[n - k] % MOD);\n}\n\nint main()\n{\n    cin >> n;\n\n    p2[0] = 1;\n    fact[0] = 1;\n    for(int i = 1; i <= n; i ++)\n    {\n        p2[i] = (p2[i - 1] << 1) % MOD;\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n\n    lint x, y, d;\n    euclid(fact[n], MOD, x, y, d);\n    if(x < 0)\n        x = MOD + x % MOD;\n\n    //cout << fact[n] << \" \" << x << \"\\n\";\n    //cout << fact[n] * x % MOD << \"\\n\";\n\n    inv[0] = 1;\n    inv[n] = x;\n    for(int i = n - 1; i >= 1; i --)\n        inv[i] = inv[i + 1] * (i + 1) % MOD;\n\n       // cout << inv[1] << \"\\n\";\n\n    lint rez = putere(3, n);\n    lint sum = 0;\n    for(int i = (n >> 1) + 1; i <= n; i ++)\n    {\n      //  cout << n << \" \" << i << \" \" << comb(n, i) << \" \" << p2[n - i] << \"\\n\";\n        sum += comb(n, i) * p2[n - i] % MOD;\n        if(sum >= MOD)\n            sum -= MOD;\n    }\n\n    rez = rez - (sum << 1);\n    while(rez < 0)\n        rez += MOD;\n\n    cout << rez << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800000;\ndouble Pi = 3.1415926535897932384626;\n \nvector<ll> G[550010];\n//vector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n\nll mod = 998244353;\n//ll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k,idx,ans;\nll x[500005],y[500005],z[500005];\nbool flag[500005];\nchar s[500005];\nll dp[500005];\nll dpsum[500005];\n\nint main(){\n    cin >> n;\n    c3_init();\n    for(int i=0;i<=n / 2;i++){\n        dp[i] = c3(n / 2, i);\n        dpsum[i] = dp[i];\n    }\n    for(int i=0;i<=n / 2;i++){\n        dpsum[i] *= rui(2, n / 2 - i);\n        dpsum[i] %= mod;\n    }\n    for(int i=n / 2;i>=1;i--){\n        dpsum[i-1] += dpsum[i]; \n        dpsum[i-1] %= mod;\n    }\n\n    for(int i=0;i<=n / 2;i++){\n        num = dp[i] * dpsum[n / 2 - i + 1];\n        num %= mod;\n        num *= rui(2, n / 2 - i);\n        num %= mod;\n        ans += num;\n        ans %= mod;\n        //p(ans);\n    }\n    ans *= 2;\n    ans %= mod;\n    ans = rui(3ll, n) - ans + mod;\n    ans %= mod;\n    p(ans);\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vl;\ntypedef vector<ii> vii;\n\nconst int mod = 998244353;\nll res, n;\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n;\n\n\tres = 1;\n\tn /= 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tres = 2 * (2 * i + 1) % mod * res % mod * pot(i + 2, mod - 2);\n\t\tres %= mod;\n\t}\n\n\tres *= pot(6, n + 1) - 1;\n\tres %= mod;\n\tres *= pot(5, mod - 2);\n\tcout << MOD(res, mod) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse2,avx,avx2,fma\")\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        //ans += tempPow2*ncr(N, i)%MOD;\n        ans += (((tempPow2*invFact[N-i])%MOD) * invFact[i])%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    ans = ans*fact[N]%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(5e6),Finverse(5e6);\nvoid Cinit(){// limit is 5e6 /// write Cinit&pw /// this takes 792ms at AtCoder\n  Factorial[0]=1;\n  for(int i=1;i<5e6;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<5e6;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n\nsigned main(){\n  Cinit();\n  int n;cin>>n;\n  int ans=pw(3,n);\n  for(int i=n/2+1;i<=n;i++){\n    ans-=2*nCk(n,i)*pw(2,n-i)%MOD;\n    ans+=MOD;ans%=MOD;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst ll mod = 998244353LL;\n\n// aのb乗を求める.\nll modpow(ll a, ll b) {\n\tif (a > mod) a %= mod;\n\tif (b == 0LL) return 1LL;\n\tll tmp = modpow(a, b / 2);\n\tif (b & 1LL)\n\t\treturn tmp * tmp % mod * a % mod;\n\treturn tmp * tmp % mod;\n}\n\n// aの逆元を求める.\nll inverse(ll a) {\n\treturn modpow(a, mod - 2);\n}\n\n// kの階乗を計算する.(sgnを0以外に設定すると逆元を返す)\nll fact(ll k, int sgn = 0) {\n\tstatic vector<ll> fac(1, 1LL); // fac[i] := i!\n\tstatic vector<ll> inv(1, 1LL); // inv[i] := i!の逆元\n\tstatic ll nx = 1LL;\n\twhile (nx <= k) {\n\t\tfac.push_back(fac[nx - 1] * nx % mod);\n\t\tinv.push_back(inv[nx - 1] * inverse(nx) % mod);\n\t\t++nx;\n\t}\n\tif (sgn == 0)\n\t\treturn fac[k];\n\treturn inv[k];\n}\n\n// aCbを計算する.\nll comb(ll a, ll b) {\n\tif (b < 0 || b > a) return 0;\n\treturn fact(a) * fact(b, 1) % mod * fact(a - b, 1) % mod;\n}\n\nsigned main() {\n\tll n; cin >> n;\n\tll ans = modpow(3, n);\n\tfor (ll i = (n / 2) + 1; i <= n; ++i) {\n\t\tans -= modpow(2, n - i) * comb(n, i) % mod * 2 % mod;\n\t\tans += mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#define nmax_def 110000\n#define Cmax_def 2200\n#define mod 998244353\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nvl pow_;\nvector<vl> pow_23;\nvoid pow_ini(ll n) {\n\tpow_.push_back(n);\n\trep(j, 62) {\n\t\tll nxt = pow_[j] * pow_[j];\n\t\tnxt %= mod;\n\t\tpow_.push_back(nxt);\n\t}\n\tfor (ll i = 2; i <= 3; i++) {\n\t\tvl powtmp;\n\t\tpowtmp.push_back(i);\n\t\trep(j, 62) {\n\t\t\tll nxt = powtmp[j] * powtmp[j];\n\t\t\tnxt %= mod;\n\t\t\tpowtmp.push_back(nxt);\n\t\t}\n\t\tpow_23.push_back(powtmp);\n\t}\n\treturn;\n}\n\nll pow1(ll k) {\n\tll ans = 1;\n\trep(ntmp, 62) {\n\t\tif ((k >> ntmp) % 2 == 1) {\n\t\t\tans *= pow_[ntmp];\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}\n\nll pow1_23(ll i, ll k) {\n\tll ans = 1;\n\trep(ntmp, 62) {\n\t\tif ((k >> ntmp) % 2 == 1) {\n\t\t\tans *= pow_23[i - 2][ntmp];\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvl fact;\nvl fact_inv;\n\nvoid fact_ini(ll n) {\n\tfact.push_back(1);\n\tfact.push_back(1);\n\tfor (ll i = 2; i <= n; i++) {\n\t\tll fact_tmp = fact[i - 1] * i;\n\t\tfact_tmp %= mod;\n\t\tfact.push_back(fact_tmp);\n\t}\n\tfact_inv.resize(n + 1);\n\tpow_ini(fact[n]);\n\tfact_inv[n] = pow1(mod - 2);\n\tfor (ll i = n - 1; i >= 0; i--) {\n\t\tfact_inv[i] = fact_inv[i + 1] * (i + 1);\n\t\tfact_inv[i] %= mod;\n\t}\n}\n\nll nCm(ll n, ll m) {\n\tll ans = fact[n] * fact_inv[m];\n\tans %= mod;\n\tans *= fact_inv[n - m];\n\tans %= mod;\n\treturn ans;\n}\n\nint main() {\n\tfact_ini(2 * pow(10, 7));\n\tll N;\n\tcin >> N;\n\tll ans1 = pow1_23(3, N);\n\tll ans2 = 0;\n\tll M = N / 2 + 1;\n\tfor (ll i = M; i <= N; i++) {\n\t\tll anstmp = nCm(N, i);\n\t\tanstmp *= pow1_23(2, N - i);\n\t\tanstmp %= mod;\n\t\tans2 += anstmp;\n\t}\n\tans2 *= 2;\n\tans2 %= mod;\n\tll ans = ans1 - ans2 + mod;\n\tans %= mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * c.cc: C - Neither AB nor BA\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 10000000;\nconst int MOD = 998244353;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* global variables */\n\nint e2s[MAX_N + 1], cns[MAX_N + 1];\n\n/* subroutines */\n\ninline void addmod(int &a, int b) { a = (a + b) % MOD; }\n\nint powmod(int a, int n) {  // a^n % MOD\n  int pm = 1;\n  while (n > 0) {\n    if (n & 1) pm = (ll)pm * a % MOD;\n    a = (ll)a * a % MOD;\n    n >>= 1;\n  }\n  return pm;\n}\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  int e3 = powmod(3, n);\n\n  e2s[0] = 1;\n  for (int i = 1; i <= n; i++) e2s[i] = (ll)e2s[i - 1] * 2 % MOD;\n\n  cns[0] = 1;\n  for (int i = 1; i <= n / 2; i++)\n    cns[i] = (ll)cns[i - 1] * (n + 1 - i) % MOD * powmod(i, MOD - 2) % MOD;\n\n  int sum = 0;\n  for (int i = n / 2 + 1; i <= n; i++) {\n    int d = (ll)cns[n - i] * e2s[n - i] % MOD;\n    addmod(sum, d);\n  }\n\n  int ans = (e3 + MOD - (ll)sum * 2 % MOD) % MOD;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[5000001], invf[5000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n;\n    cin>>n;\n    fac(n/2);\n    ll p2[5000050];\n    p2[0]=1;\n    for(int i=1; i<=n/2; i++) p2[i]=p2[i-1]*2%MOD;\n    ll s[5000050];\n    s[0]=0;\n    for(int i=0; i<=n/2; i++){\n        s[i+1]=(s[i]+comb(n/2, i)*p2[n/2-i])%MOD;\n    }\n    ll ans=0;\n    for(int i=0; i<=n/2; i++){\n        (ans+=comb(n/2, i)*p2[n/2-i]%MOD*(s[n/2+1]-s[n/2-i+1]+MOD))%=MOD;\n    }\n    ans=ans*2%MOD;\n    ll p3=1;\n    for(int i=0; i<n; i++) p3=p3*3%MOD;\n    ans=(p3-ans+MOD)%MOD;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define rnt re int\n#define re register\n#define I inline int\n#define V inline void\n#define ll long long int\n#define FOR(i,a,b) for(rnt i=a;i<=b;i++)\n#define ROF(i,a,b) for(rnt i=a;i>=b;i--)\nconst int N=1e7+1,mod=998244353;\nint n,ans,fac[N],inv[N],pw[N];\nI Pow(ll t,rnt x){\n\tll s=1;\n\tfor(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;\n\treturn s;\n}\nV check(int&x){x-=mod,x+=x>>31&mod;}\nI C(rnt x,rnt y){return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;}\nint main(){\n\tcin>>n,fac[0]=inv[0]=pw[0]=1;\n\tFOR(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=Pow(fac[n],mod-2);\n\tROF(i,n-1,1)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tFOR(i,1,n)check(pw[i]=pw[i-1]<<1);\n\tFOR(i,n/2+1,n)check(ans+=1ll*pw[n-i]*C(n,i)%mod);\n\tcheck(ans<<=1),check(ans=Pow(3,n)+mod-ans);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst ll mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nconst int IMAX = 10000001;\nll fac[IMAX + 1], ifac[IMAX + 1], inv[IMAX + 1];\ninline ll comb(int A, int B) {\n\treturn fac[A] * ifac[B] % mod * ifac[A - B] % mod;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N;\n\tcin >> N;\n\n\tfac[0] = 1;\n\trep1(i, IMAX) fac[i] = fac[i - 1] * i % mod;\n\tifac[IMAX] = modpow(fac[IMAX], mod - 2);\n\tfor (int i = IMAX; i > 0; i--) ifac[i - 1] = ifac[i] * i % mod;\n\tinv[0] = 1;\n\trep1(i, IMAX) inv[i] = ifac[i] * fac[i - 1] % mod;\n\n\n\tll kotae = 1;\n\tll k = 1;\n\trep1(i, N) {\n\t\tll tmp = comb(N, i);\n\t\tk = k * 2;\n\t\tif (i > N / 2) {\n\t\t\tk += -comb(i - 1, i - 1 - N / 2) * 2 + mod * 2;\n\t\t}\n\t\tkotae += tmp * k % mod;\n\t}\n\tco(kotae% mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1e7 + 100;\nint mod = 998244353;\n\n\nnamespace Combi {\n    int fact[N], inv[N];\n\n    int bm(int b, int p, int m) {\n        if(p == 0) return 1%m;\n        int t = bm(b,p/2,m);\n        t = (1ll*t*t)%m;\n        if(p&1) return 1ll*t*b%m;\n        return t;\n    }\n\n    int C(int n, int r) {\n        if(n < 0 or r < 0 or r > n) return 0;\n        int ret = 1ll*fact[n]*inv[r]%mod;\n        ret = 1ll*ret*inv[n-r]%mod;\n        return ret;\n    }\n    // X1 + X2 + ... + Xvar = Sum\n    int no_of_eqns(int var, int sum) {\n        return C(sum+var-1,var-1); // Xi >= 0\n        // return C(sum-1,var-1); // Xi > 0\n    }\n    void init() {\n        fact[0] = 1;\n        for(int i = 1; i < N; i++) {\n            fact[i] = 1ll*fact[i-1]*i%mod;\n        }\n        inv[N-1] = bm(fact[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--) {\n            inv[i] = 1ll*inv[i+1]*(i+1)%mod;\n        }\n    }\n}\n\nint pw2[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    Combi::init();\n    int n;\n    cin >> n;\n    int ways = 1;\n    pw2[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        ways = 1ll*3*ways%mod;\n        pw2[i] = 1ll*2*pw2[i-1]%mod;\n    }\n    for(int i = n/2 + 1; i <= n; i++) {\n        int bad_ways = 1ll*Combi::C(n, i)*pw2[n-i+1]%mod;\n        ways = (ways - bad_ways + mod)%mod;\n    }\n    cout << ways << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef double DOUBLE;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll LL_INF = 1e17 + 10;\nconst int INF = 1e9 + 10;\nconst ll MOD = 998244353;\n\nconst int MAXN = 1e7 + 5;\n\nll f[MAXN], f_inv[MAXN], st2[MAXN];\n\nll pow_mod(ll a, ll st) {\n\tll ans = 1ll;\n\tfor(; st; st >>= 1ll) {\n\t\tif (st & 1) {\n\t\t\tans = (ans * a) % MOD;\n\t\t}\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\nll get_inv(ll v) {\n\treturn pow_mod(v, MOD - 2);\n}\n\nvoid gen_f() {\n\tf[0] = 1;\n\tREP(i, 1, MAXN) {\n\t\tf[i] = (f[i - 1] * i) % MOD;\n\t}\n\tf_inv[MAXN - 1] = get_inv(f[MAXN - 1]);\n\tfor(int i = MAXN - 2; i >= 0; i--) {\n\t\tf_inv[i] = (f_inv[i + 1] * (i + 1)) % MOD;\n\t}\n}\n\nll get_c(int i, int j) {\n\tif (j > i || j < 0) {\n\t\treturn 0ll;\n\t}\n\treturn (((f[i] * f_inv[j]) % MOD) * f_inv[i - j]) % MOD;\n}\n\nvoid solve(){\n\tgen_f();\n\tst2[0] = 1;\n\tREP(i, 1, MAXN) {\n\t\tst2[i] = (st2[i - 1] * 2) % MOD;\n\t}\n\tint n;\n\tscanf(\"%d\", &n);\n\tll ans = 0ll;\n\tREPN(i, n / 2 + 1, n) {\n\t\tans = (ans + get_c(n, i) * st2[n - i]) % MOD;\n\t}\n\tans = (ans * 2) % MOD;\n\tans = (pow_mod(3, n) + MOD - ans) % MOD;\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modPow(long long a, long long p){\n    if(p == 0) return 1;\n    auto res = modPow(a, p/2);\n    res = (res*res)%MOD;\n    if(p%2) res = (res*a)%MOD;\n    return res;\n}\n\nlong long calcInv(long long a){\n    return modPow(a, MOD-2);\n}\n\nint main(){\n    const int maxSize = 1000001;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    int N;\n    while(cin >> N){\n        long long res = modPow(3, N);\n        for(int i=N/2+1;i<=N;i++){\n            long long sub = comb(N, i) * modPow(2, N-i);\n            res = (res + MOD - 2 * sub % MOD) % MOD;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 10000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n\n\n\nll N;\nmint memo[10000010];\nvoid make_2(){\n  memo[0] = 1;\n  for(ll i = 1; i <= N; i++){\n    memo[i] = memo[i-1] * 2;\n  }\n}\nvoid solve(){\n  mint ans = pow_mod(3, N);\n  make_2();\n  for(ll i = N/2+1; i <= N; i++){\n    mint add = comb(N, i) * memo[N-i];\n    ans -= add;\n  }\n  for(ll i = N/2+1; i <= N; i++){\n    mint add = comb(N, i) * memo[N-i];\n    ans -= add;\n  }\n  ans.get();\n}\nint main(){\n  COMinit();\n  cin >> N;\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int inf=0x3f3f3f3f,N=1e7+4,mod=998244353;\nint n,inv[N],fac[N],fic[N],bin[N],bi[N];\nint C(int x,int y)\n{if(y>x)return 0;if(0==y)return 1;//cout<<x<<\" \"<<y<<\" \"<<fac[x]*fic[y]%mod*fic[x-y]%mod<<endl;\n\treturn fac[x]*fic[y]%mod*fic[x-y]%mod;\n}\nmain()\n{inv[1]=fac[1]=fic[1]=1;bin[0]=bi[0]=fic[0]=1;\nfor(int i=2;i<=1e7;i++)inv[i]=mod-inv[mod%i]*(mod/i)%mod,fac[i]=fac[i-1]*i%mod,fic[i]=fic[i-1]*inv[i]%mod;\n//for(int i=1;i<=3;i++)cout<<inv[i]<<\" \"<<fic[i]<<endl;\nfor(int i=1;i<=1e7;i++)bi[i]=bi[i-1]*3%mod,bin[i]=(bin[i-1]*2%mod);\n\tcin>>n;int ans=bi[n];//cout<<ans<<endl;\n\tfor(int i=n/2+1;i<=n;i++)\n\t{\n\t\tint ret=C(n,i)*bin[n-i+1]%mod;ans=(ans-ret)%mod;\n\t\t//cout<<ans<<endl;\n\t}cout<<(ans+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nlong long tmp[5110000];\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tlong long ret=pw(3,a);\n\tinit_C(a/2+2);\n\tfor(int i=0;i<=a/2;i++){\n\t\ttmp[i]=Comb(a/2,i)*pw(2,a/2-i)%mod;\n\t\t// printf(\"%d: %lld\\n\",i,tmp[i]);\n\t}\n\tlong long ks=0;\n\tlong long cur=0;\n\tint at=a/2;\n\tfor(int i=1;i<=a/2;i++){\n\t\tcur=(cur+tmp[a/2-i+1])%mod;\n\t\tks=(ks+cur*tmp[i])%mod;\n\t}\n\n\tret=(ret+mod-ks*2%mod)%mod;\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nclass inverse {\n    public:\n    inverse(int n, int mod);\n    ~inverse();\n    long long get_inv(int x);\n    long long get_fact(int x);\n    long long get_invfact(int x);\n    long long get_comb(int x, int y);\n    \n    private:\n    int mod;\n    long long* inv;\n    long long* fact;\n    long long* invfact;\n};\n\ninverse::inverse(int n, int mod) : mod(mod) {\n    inv = (long long *)malloc(sizeof(long long) * (n + 1));\n    fact = (long long *)malloc(sizeof(long long) * (n + 1));\n    invfact = (long long *)malloc(sizeof(long long) * (n + 1));\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\ninverse::~inverse() {\n    free(inv);\n    free(fact);\n    free(invfact);\n}\n\nlong long inverse::get_inv(int x) {\n    return inv[x];\n}\n\nlong long inverse::get_fact(int x) {\n    return fact[x];\n}\n\nlong long inverse::get_invfact(int x) {\n    return invfact[x];\n}\n\nlong long inverse::get_comb(int x, int y) {\n    return fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\n\nlong long powmod(long long x, long long y) {\n    long long ans = 1;\n    \n    while (y > 0) {\n        if (y & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n, i;\n    long long ans;\n    \n    scanf(\"%d\", &n);\n    \n    inverse inv(n, mod);\n    \n    ans = powmod(3, n);\n    \n    for (i = n; i > n / 2; i--) {\n        long long x = inv.get_comb(n, i) * powmod(2, n - i) % mod;\n        ans -= x * 2;\n        while (ans < 0) ans += mod;\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\n\n\nll modpower(ll a, ll r, ll mod){ //a^r\n    ll x = 1;\n    a %= mod;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a, ll mod){\n    return modpower(a, mod-2, mod);\n}\n\nvector<ll> fact;\nvector<ll> invfact;\n\nvoid set_fact(ll n, ll mod){\n    fact.resize(n+1, 1);\n    invfact.resize(n+1, 1);\n    for (ll i = 2; i <= n; i++) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    invfact[n] = modinv(fact[n], mod);\n    for (ll i = n-1; i >= 2; i--) {\n        invfact[i] = invfact[i+1] * (i+1) % mod;\n    }\n    return;\n}\n\nll comb(ll n, ll k, ll mod) {\n    if (k > n || k < 0) return 0;\n    if (k == n || k == 0) return 1;\n    return fact[n] * invfact[n-k] % mod * invfact[k] % mod;\n}\n\n\nint main() {\n    ll N;\n    cin >> N;\n    ll mod = 998244353;\n    ll all = modpower(3, N, mod);\n    ll ex = 0;\n    set_fact(N+2, mod);\n    for (ll i = N/2+1; i <= N; i++) {\n        ex += 2LL * comb(N, i, mod) * modpower(2, N-i, mod) % mod;\n        ex %= mod;\n    }\n    cout << (all+mod-ex)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\nvoid print(vec v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\nll MOD=998244353;\n#define N 11000000\n\nll int inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n    }\n    return;\n}\nvoid calc_comb(ll int n){\n    comb[0]=1;\n    rep2(i,1,n){\n        comb[i]=comb[i-1]*(n+1-i)*inv[i]%MOD;\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=i*prd[i-1]%MOD;\n        invprd[i]=inv[i]*invprd[i-1]%MOD;\n    }\n    return ;\n}\nll cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return prd[a]*invprd[b]%MOD*invprd[a-b]%MOD;\n}\nll modpow(ll x,ll n){\n    if(n==0) return 1;\n    ll res=modpow(x*x%MOD,n/2);\n    if(n&1) res=res*x%MOD;\n    return res;\n}\nll p[N+100],a[N],b[N];\nmain(){\n    calc_inv();\n    calc_product();\n    p[0]=1;\n    rep(i,N){\n      p[i+1]=p[i]*2ll%MOD;\n    }\n    ll n=in();\n    rep(i,n/2+1){\n      a[i]=p[i]*cmb(n/2,i)%MOD;\n      //cout<<a[i]<<endl;\n    }\n    ll t=0;\n    ll ans=1;\n    rep(i,n)ans=ans*3ll%MOD;\n    rep(i,n/2){\n      t=(t+a[i])%MOD;\n      ans=(ans+MOD-t*a[n/2-1-i]%MOD*2ll%MOD)%MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=10000005,mod=998244353;\nint fac[N],rev[N],n,ans,res;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1) res=(ll)res*x%mod;\n\treturn res;\n}\nint mul(int x,int y){\n\treturn (ll)x*y%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint C(int n,int m){\n\treturn m<0||n<m?0:mul(fac[n],mul(rev[m],rev[n-m]));\n}\nvoid init(int n){\n\tfac[0]=1;\n\trep(i,1,n) fac[i]=mul(fac[i-1],i);\n\trev[n]=power(fac[n],mod-2);\n\tper(i,n,1) rev[i-1]=mul(rev[i],i);\n}\n\nint main(){\n\tread(n);\n\tinit(n);\n\n\tans=res=1;\n\tper(c,n-1,0){\n\t\tres=mul(res,2);\n\t\tif(c<n/2){\n\t\t\tadd(res,mod-mul(2,C(n-c-1,(n-2*c)/2-1)));\n\t\t\t//cout<<n<<\" \"<<c<<\"  \"<<n-c<<\"   \"<<res<<endl;\n\t\t}\n\t\tadd(ans,mul(C(n,c),res));\n\t}\n\tcout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 11000000; i++) fact.push_back(i * fact[i-1]);\n\tfor(num x : fact) ifact.push_back(1 / x);\t\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tp2[i] = 2 * p2[i-1];\n\t}\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * p2[i] * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T, class U>\nvoid ckmin(T &a, U b)\n{\n\tif (a > b) a = b;\n}\ntemplate<class T, class U>\nvoid ckmax(T &a, U b)\n{\n\tif (a < b) a = b;\n}\n\n#define MP make_pair\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define FOR(i, a, b) for (auto i = (a); i < (b); i++)\n#define FORD(i, a, b) for (auto i = (a) - 1; i >= (b); i--)\n#define SZ(x) ((int) ((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n#define INF 998244353\n#define MAXN 5000013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\n\nint N;\nll ans;\nll fact[MAXN], ifact[MAXN], pw2[MAXN];\n\nll expo(ll a, ll e)\n{\n\tif (e == 0) return 1;\n\tif (e & 1)\n\t{\n\t\treturn expo(a * a % INF, e >> 1) * a % INF;\n\t}\n\treturn expo(a * a % INF, e >> 1);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tcin >> N;\n\tfact[0] = 1;\n\tFOR(i, 1, N + 10)\n\t{\n\t\tfact[i] = fact[i - 1] * i % INF;\n\t}\n\tifact[N + 9] = expo(fact[N + 9], INF - 2);\n\tFORD(i, N + 9, 0)\n\t{\n\t\tifact[i] = ifact[i + 1] * (i + 1) % INF;\n\t}\n\tpw2[0] = 1;\n\tFOR(i, 1, N + 10)\n\t{\n\t\tpw2[i] = pw2[i - 1] + pw2[i - 1]; if (pw2[i] >= INF) pw2[i] -= INF;\n\t}\n\tN /= 2;\n\tans = 1;\n\tFOR(i, 0, 2 * N)\n\t{\n\t\tans *= 3; ans %= INF;\n\t}\n\tFOR(i, N + 1, 2 * N + 1)\n\t{\n\t\tans -= 2 * fact[2 * N] * ifact[2 * N - i] % INF * ifact[i] % INF * pw2[2 * N - i];\n\t\tans %= INF;\n\t}\n\tif (ans < 0) ans += INF;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define minus djsf\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint pw(int x, int y) {\n\tif (y==0) return 1;\n\tif (y==1) return x%mod;\n\tif (y%2) return ((ll) pw(x, y-1) * x) % mod;\n\tint q = pw(x, y/2);\n\treturn ((ll) q * q) % mod;\n}\n\nconst int N = 10000007;\n\nint fact[N], rev[N];\n\nint C(int n, int k) {\n\tint A = fact[n];\n\tint B = ((ll) rev[k] * rev[n-k]) % mod;\n\treturn ((ll) A * B) % mod;\n}\n \nsigned main()\n{\n#ifdef LOCAL\n\tfreopen(\"N_input.txt\", \"r\", stdin);\n\t//freopen(\"P_output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    fact[0] = 1;\n    for (int i=1; i < N; ++i) fact[i] = ((ll) fact[i-1] * i) % mod;\n    for (int i=0; i < N; ++i) rev[i] = pw(fact[i], mod-2);\n\n    int n;\n    cin >> n;\n\n    int ans = pw(3, n);\n\n    for (int i=n/2+1; i <= n; ++i) {\n    \tint T = (2*C(n, i)) % mod;\n    \tT = ((ll) T * pw(2, n - i)) % mod;\n    \tans = (ans - T + mod) % mod;\n    }\n\n    cout << ans;\n\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=998244353;\nint n,ans,i,fac[10000005],inv[10000005],fi[10000005];\nint qp(int x,int y){\n\tint z=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\tz=1ll*z*x%mod;\n\t\t}\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}return z;\n}\nint c(int x,int y){\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint main(){\n\tfac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;\n\tfor(i=2;i<=10000000;i++){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfi[i]=1ll*fi[i-1]*inv[i]%mod;\n\t}\n\tcin>>n;\n\tans=qp(3,n);\n\tfor(i=n/2+1;i<=n;i++){\n\t\tans=(ans+2ll*(mod-c(n,i))*qp(2,n-i))%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nconst int MAX = 11000000;\nconst ll MOD = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long FINV(int n){\n    if (n < 0) return 0;\n    return finv[n];\n}\n\nint main() {\n    // 前処理\n    COMinit();\n\n\n    int n; cin >> n;\n    ll ans = 1;\n    rep(i,n){\n        ans *= 3;\n        ans %= MOD;\n    }\n\n    ll tmp = 0;\n    ll two = 2;\n    rep(i,n/2){\n        tmp += COM(n, i) * two;\n        tmp %= MOD;\n        two *= 2;\n        two %= MOD;\n    }\n\n    ans += MOD - tmp;\n    ans %= MOD;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\n//繰り返し二乗法\nll power(ll a,ll b){\n\tll res=1;\n\twhile(b>0){\n\t\tif(b&1)res=res%mod*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=power(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(1<<22);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tll ans=power(3,n);\n\tll res=0;\n\tfor(int i=0;i<n/2;i++){\n\t\tll k=p.comb(n,i);\n\t\t(k*=power(2,i))%=mod;\n\t\t(res+=k)%=mod;\n\t}\n\tcout << (ans-2*res+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n#include <unordered_map>\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n//#define MOD 1000000007\n#define MOD 998244353\n#define P pair<ll, ll>\n\nll powmod(ll a, ll b) {\n\ta %= MOD;\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1)res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\nll f[11100000];\nvoid cominit() {\n\tf[0] = 1;\n\tREP(i, 11000000)f[i + 1] = f[i] * (i + 1) % MOD;\n}\n\nll com(ll n, ll r) {\n\tif (n < r)return 0;\n\tif (n < 0 or r < 0)return 0;\n\treturn f[n] * powmod(f[r] * f[n - r], MOD - 2) % MOD;\n}\n\nll perm(ll n, ll r) {\n\tif (n < r)return 0;\n\tif (n < 0 or r < 0)return 0;\n\treturn f[n] * powmod(f[n - r], MOD - 2) % MOD;\n}\nint main() {\n\tcominit();\n\tll n, k;\n\tcin >> n;\n\tll ans = powmod(3, n);\n\tFOR(i, n / 2 + 1, n + 1) {\n\t\tll now = com(n, i) * powmod(2, n - i) % MOD * 2 % MOD;\n\t\tans = (ans - now + MOD) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 998244353;\nll N;\nvector<ll> Inv, Pow2, Fact, InvFact;\nll Res;\n\nint main() {\n  cin >> N;\n  Res = 1;\n  for (ll i = 0; i < N; ++i) (Res *= 3) %= MOD;\n  Inv.resize(N + 1);\n  Inv[1] = 1;\n  for (ll i = 2; i <= N; ++i) {\n    Inv[i] = MOD - MOD / i * Inv[MOD % i] % MOD;\n  }\n  Pow2.resize(N + 1);\n  Fact.resize(N + 1);\n  InvFact.resize(N + 1);\n  Pow2[0] = Fact[0] = InvFact[0] = 1;\n  for (ll i = 1; i <= N; ++i) {\n    Pow2[i] = 2 * Pow2[i - 1] % MOD;\n    Fact[i] = i * Fact[i - 1] % MOD;\n    InvFact[i] = Inv[i] * InvFact[i - 1] % MOD;\n  }\n  for (ll k = N / 2 + 1; k <= N; ++k) {\n    (Res += MOD - 2 * Pow2[N - k] * Fact[N] % MOD * InvFact[k] % MOD *\n                      InvFact[N - k] % MOD) %= MOD;\n  }\n  cout << Res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 1e7 + 2;\nconst int mod = 998244353;\nint fac[maxN + 2], ifac[maxN + 2], pw2[maxN + 2];\nint qpow(int a, int b)\n{\n    int ans = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % mod)\n        if (b & 1)\n            ans = 1ll * ans * a % mod;\n    return ans;\n}\ninline void Inc(int &x)\n{\n    x < 0 ? x += mod : 0;\n}\nvoid init(int N = 1e7)\n{\n    fac[0] = 1;\n    for (int i = 1; i <= N; ++i)\n        fac[i] = (LL) fac[i - 1] * i % mod;\n    ifac[N] = qpow(fac[N], mod - 2);\n    for (int i = N - 1; i >= 0; --i)\n        ifac[i] = (LL) ifac[i + 1] * (i + 1) % mod;\n    pw2[0] = 1;\n    for (int i = 1; i <= N; ++i)\n        pw2[i] = pw2[i - 1] * 2ll % mod;\n}\nint C(int n, int m)\n{\n    if (n < m)\n        return 0;\n    return (LL) fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    init();\n    int ans = qpow(3, n);\n    for (int i = n / 2 + 1; i <= n; ++i)\n        Inc(ans -= 2ll * C(n, i) * pw2[n - i] % mod);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nconstexpr long long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>a(N / 2 + 1);\n\tvector<long long int>by(N + 1, 1);\n\tvector<long long int>rev(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tfor (int i = 0; i <= N / 2; i++) {\n\t\ta[i] = by[N / 2] * rev[N / 2 - i];\n\t\ta[i] %= MOD;\n\t\ta[i] *= rev[i];\n\t\ta[i] %= MOD;\n\t\ta[i] *= power(2, N / 2 - i, MOD);\n\t\ta[i] %= MOD;\n\t}\n\tauto asum = a;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tasum[i] += asum[i - 1];\n\t\tasum[i] %= MOD;\n\t}\n\tlong long int ans = power(3, N, MOD);\n\tlong long int minus = 0;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tlong long int box = asum[N / 2] - asum[N / 2 - i];\n\t\tbox += MOD;\n\t\tbox %= MOD;\n\t\tbox *= a[i];\n\t\tbox *= 2;\n\t\tbox %= MOD;\n\t\tminus += box;\n\t\tminus %= MOD;\n\t}\n\tans -= minus;\n\tans += MOD;\n\tans %= MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1e7 + 5;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid iadd(int &dp, int val) {\n    dp += val;\n    if (dp >= MOD) {\n        dp -= MOD;\n    }\n}\n\nvoid ladd(int &dp, LL val) {\n    dp = (dp + val) % MOD;\n}\n\nint n;\nint fac[N], inv[N];\n\nvoid prep() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = (LL) fac[i - 1] * i % MOD;\n    }\n    inv[n] = qpow(fac[n], MOD - 2);\n    for (unsigned i = n; i; --i) {\n        inv[i - 1] = (LL) inv[i] * i % MOD;\n    }\n}\n\nint main() {\n    n = read();\n    prep();\n    int ans = qpow(3, n);\n    int pw2 = 2;\n    for (int i = n; i > n / 2; --i) {\n        ladd(ans, -1LL * pw2 * fac[n] % MOD * inv[i] % MOD * inv[n - i]);\n        iadd(pw2, pw2);\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e7+7,mo=998244353;\ninline int fk(int x) { return x>=mo ? x-mo : x; }\nint n,fac[N],facinv[N];\nint ksm(int x,int y)\n{\n    int res=1;\n    while(y) { if(y&1) res=1ll*res*x%mo; x=1ll*x*x%mo; y>>=1; }\n    return res;\n}\ninline int C(int x,int y) { return 1ll*fac[x]*facinv[y]%mo*facinv[x-y]%mo; }\nint main()\n{\n    cin>>n;\n    fac[0]=1;\n    for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mo;\n    facinv[n]=ksm(fac[n],mo-2);\n    for(int i=n-1;i>=0;i--) facinv[i]=1ll*facinv[i+1]*(i+1)%mo;\n    int ans=ksm(3,n);\n    for(int k=n/2+1;k<=n;k++)\n        ans=fk(ans-2ll*C(n,k)*ksm(2,n-k)%mo+mo);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 03.11.2019 18:07:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  Mint cur = 1;\n  Mint ans = 0;\n  for (int k = 0; k <= n; k++) {\n    if (k >= n / 2) {\n      ans += cur;\n    }\n    cur *= 2 * (n - k);\n    cur /= (k + 1);\n  }\n  cout << -power(Mint(3), n) + 2 * ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nvector<mod_int> inv = {0, 1}, factorial = {1, 1}, inv_factorial = {1, 1};\nint prepared_size = 2;\n\nvoid prepare_factorials(int maximum) {\n    static int prepare_calls = 0;\n\n    if (prepare_calls++ == 0) {\n        // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n        for (int p = 2; p * p <= MOD; p++)\n            assert(MOD % p != 0);\n    }\n\n    if (maximum >= prepared_size) {\n        inv.resize(maximum + 1);\n        factorial.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int i = prepared_size; i <= maximum; i++) {\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            factorial[i] = i * factorial[i - 1];\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n\n        prepared_size = maximum + 1;\n    }\n}\n\nmod_int choose(long long n, long long r) {\n    if (r < 0 || r > n) return 0;\n    if (n >= prepared_size) prepare_factorials(n);\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(long long n, long long r) {\n    assert(0 <= r && r <= n);\n    if (n >= prepared_size) prepare_factorials(n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(long long n, long long k) {\n    if (k < 0 || k > n) return 0;\n    if (n >= prepared_size) prepare_factorials(n);\n    return factorial[n] * inv_factorial[n - k];\n}\n\nmod_int inv_permute(long long n, long long k) {\n    assert(0 <= k && k <= n);\n    if (n >= prepared_size) prepare_factorials(n);\n    return inv_factorial[n] * factorial[n - k];\n}\n\n\nint main() {\n    int N;\n    cin >> N;\n    mod_int answer = mod_int(3).pow(N);\n    mod_int power = 1;\n\n    for (int i = N; i > N / 2; i--) {\n        power *= 2;\n        answer -= power * choose(N, i);\n    }\n\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 10000000;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n\n\n\nll N;\nmint memo[10000010];\nvoid make_2(){\n  memo[0] = 1;\n  for(ll i = 1; i <= N; i++){\n    memo[i] = memo[i-1] * 2;\n  }\n}\nvoid solve(){\n  mint ans = pow_mod(3, N);\n  make_2();\n  for(ll i = N/2+1; i <= N; i++){\n    mint add = comb(N, i) * memo[N-i];\n    ans -= add;\n  }\n  for(ll i = N/2+1; i <= N; i++){\n    mint add = comb(N, i) * memo[N-i];\n    ans -= add;\n  }\n  ans.get();\n}\nint main(){\n  COMinit();\n  cin >> N;\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n\n\tfriend modnum pow() {}\n};\n\nusing num = modnum<998244353>;\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 11000000; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(fact.size());\n\tifact.back() = 1 / fact.back();\n\tfor(int i = (int)ifact.size() - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * pow(num(2), i) * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n\n\tfriend modnum pow() {}\n};\n\nusing num = modnum<998244353>;\n\nnum pow(num a, ll b){\n\tassert(b >= 0);\n\tif(b & 1) return a * pow(a, b-1);\n\tif(!b) return 1;\n\treturn pow(a * a, b / 2);\n}\n\nvector<num> fact;\nvector<num> ifact;\n\nvoid init(){\n\tfact = {1};\n\tfor(int i = 1; i < 11000000; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(fact.size());\n\tifact.back() = 1 / fact.back();\n\tfor(int i = (int)ifact.size() - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tnum ans = 1;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) ans *= 3;\n\tvector<num> p2(n+1, 0);\n\tp2[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tp2[i] = 2 * p2[i-1];\n\t}\n\tfor(int i = 0; i < n/2; i++){\n\t\tans -= 2 * p2[i] * ncr(n, i);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=998244353;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this*=x.inv();}\n    bool operator==(const Mint& x) const{return val==x.val;}\n    bool operator!=(const Mint& x) const{return val!=x.val;}\n    bool operator<(const Mint& x) const{return val<x.val;}\n    bool operator<=(const Mint& x) const{return val<=x.val;}\n    bool operator>(const Mint& x) const{return val>x.val;}\n    bool operator>=(const Mint& x) const{return val>=x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    factorial fact(10000010);\n    Mint ans=Mint(3).pow(n),mul=Mint(2).pow(n/2-1);\n    rep(i,n/2+1,n+1)ans-=fact.nCr(n,i)*mul*2; mul/=2;\n    printf(\"%d\\n\",ans.val);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=998244353;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this*=x.inv();}\n    bool operator==(const Mint& x) const{return val==x.val;}\n    bool operator!=(const Mint& x) const{return val!=x.val;}\n    bool operator<(const Mint& x) const{return val<x.val;}\n    bool operator<=(const Mint& x) const{return val<=x.val;}\n    bool operator>(const Mint& x) const{return val>x.val;}\n    bool operator>=(const Mint& x) const{return val>=x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    factorial fact(10000010);\n    Mint ans=Mint(3).pow(n),mul=Mint(2).pow(n/2-1);\n    rep(i,n/2+1,n+1)ans-=fact.nCr(n,i)*mul*2,mul/=2;\n    printf(\"%d\\n\",ans.val);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint  operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint  operator--(int) { mint this_=*this; --*this; return this_; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) { return pow(*this, y); }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\n    template <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x)\n{\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\n    template <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x)\n{\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i32, 998244353>>;\n// fact{{{\nstruct factorials {\n    std::vector<mint> fact, finv;\n\n    factorials(usize n)\n        : fact(n, 1), finv(n)\n    {\n        for(usize i=1;i<n;i++){\n            fact.at(i) = fact.at(i-1) * i;\n        }\n\n        finv.at(n-1) = fact.at(n-1).inv();\n        for(usize i=n-1; i; i--){\n            finv.at(i-1) = finv.at(i) * i;\n        }\n    }\n\n    std::size_t size() const { return fact.size(); }\n    std::size_t max() const { return fact.size() - 1; }\n\n    mint at(std::size_t i) const { return fact.at(i); }\n    mint inv(std::size_t i) const { return finv.at(i); }\n\n    template <\n        class T, class U,\n        std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0\n    >\n    mint binom(T n, U k) {\n        assert(0<=n);\n        if (k<0||n<k) return 0;\n        assert(k<=n && static_cast<usize>(n)<size());\n        return fact.at(n) * finv.at(k) * finv.at(n-k);\n    }\n\n    template <\n        class T, class U,\n        std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0\n    >\n    mint deal(T n, U k) {\n        if (n==0 && k==0) return 1;\n        return binom(n+k-1, k-1);\n    }\n};\n/*}}}*/\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    i32 n;\n    std::cin >> n;\n    factorials fact(n+1);\n\n    mint ans = mint{3}.pow(n);\n    for (i32 i=n/2+1; i<=n; i++) {\n        ans -= 2 * fact.binom(n, i) * mint::pow(2, n - i);\n    }\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 10555550;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n  rfact[n] = mod_inverse(fact[n], M);\n  for (ll i = n - 1; i >= 2; i--) {\n      rfact[i] = (i + 1) * rfact[i + 1] % M;\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nsigned main() {\n    ll n;\n    cin >> n;\n    set_fact(n + 10);\n    \n    ll zen = mod_pow(3, n);\n    ll sub = 0;\n    ll mul = 1;\n    for (int i = n; i > n / 2; i--) {\n    // for (int i = n / 2 + 1; i <= n; i++) {\n        sub += nCr(n, i) * mul % MOD;\n        mul = mul * 2 % MOD;\n    }\n    sub %= MOD;\n    zen -= 2 * sub;\n    zen = (zen % MOD + MOD) % MOD;\n\n    cout << zen << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n1000000\n\n\n*/\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \n\n#define rep(i,j,n) for(i=j;i<n;i++)\n#define repi(i,j,n) for(i=j;i>n;i--)\n#define inf 100001\n#define M 998244353\n#define ll long long\n#define vll vector<long long>\n#define vi vector<int>\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define vpii vector<pair<int,int> >\n#define vpll vector<pair<long long,long long> >\n#define pb push_back\n#define pf pop_front\n#define mp make_pair\n#define F first\n#define S second\n\nusing namespace std;\nusing namespace __gnu_pbds; \n\ntemplate<typename T>\nusing ordered_set=tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n\nll power(ll a,ll m,ll mod){\n\tll ans=1;\n\twhile(m){\n\t\tif(m%2){\n\t\t\tans*=a;\n\t\t\tans%=(mod);\n\t\t}\n\t\ta=(a*a)%(mod);\n\t\tm>>=1;\n\t}\n\treturn ans;\n}\n\n\nvoid init(long long* a,long long n,long long val){\n\tfor(long long i=0;i<n;i++)\n\t\ta[i]=val;\n}\n\nll fact[10000001],inv[10000001];\n\nll func(ll n,ll r){\n\treturn (((fact[n]*inv[r])%M)*inv[n-r])%M;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\t\n\tll t=1,i,j;\n\tll n;\n\tcin>>n;\n\tll ans=power(3,n,M);\n\tll k=n/2+1;\n\tt=0;\n\tfact[0]=1,inv[0]=1;\n\trep(i,1,10000001){\n\t\tfact[i]=i*fact[i-1];\n\t\tfact[i]%=M;\n\t\tinv[i]=power(fact[i],M-2,M);\n\t}\n\trep(i,k,n+1){\n\t\tt+=(func(n,i)*(power(2,n-i,M)))%M;\n\t\tt%=M;\n\t}\n\tt*=2;\n\tt%=M;\n\tans-=t;\n\tans+=M;\n\tans%=M;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nint n;\n/*\nstring compr(string s) {\n    string t;\n\n    char cc = s[0];\n    int cur = 1;\n    for (int i = 1; i < n; ++i) {\n        if (s[i] != cc) {\n\n            if (cc == 'C') {\n                for (int i = 0; i < cur; ++i)\n                    t += cc;\n            }   \n            else {\n                for (int i = 0; i < (cur & 1); ++i)\n                    t += cc;\n            }   \n\n            cc = s[i];\n            cur = 1;\n        }   \n        else {\n            ++cur;\n        }   \n    }   \n    if (cc == 'C') {\n        for (int i = 0; i < cur; ++i)\n            t += cc;\n    }   \n    else {\n        for (int i = 0; i < (cur & 1); ++i)\n            t += cc;\n    }   \n\n    return t;\n}\n*/\nstring compr(string s) {\n    string ans;\n    for (char c : s) {\n        if (ans.size() && ans.back() == c && c != 'C') {\n            ans.pop_back();\n        }   \n        else {\n            ans.app(c);\n        }   \n    }   \n    return ans;\n}     \n\nconst int N = 21;\nbool dp[N][N];\nbool check(string s) {\n    if (s.empty())\n        return 1;\n    n = s.size();\n    memset(dp, 0, sizeof dp);\n    for (int i = 0; i < n; ++i) {\n        dp[i + 1][i] = 1;\n    }   \n    for (int l = n - 1; l >= 0; --l) {\n        for (int r = l + 1; r < n; r += 2) {\n            if ((s[l] == s[r] || s[l] == 'C' || s[r] == 'C') && dp[l + 1][r - 1]) {\n                dp[l][r] = 1;\n                continue;\n            }   \n            for (int k = l + 1; k < r; k += 2) {\n                dp[l][r] |= dp[l][k] && dp[k + 1][r];\n            }   \n        }   \n    }   \n    return dp[0][n - 1];\n}   \n\nint ans = 0;\nvoid gen(string cur) {\n    if (cur.size() == n) {\n\n        if (check(cur) != check(compr(cur))) {\n            cout << cur << endl;\n            cout << compr(cur) << endl;\n            exit(0);\n        }   \n\n        ans += check(cur);\n        return;\n    }   \n    for (char c = 'A'; c <= 'C'; ++c) {\n        gen(cur + c);\n    }   \n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n;\n    gen(\"\");\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 998244353;\n\nll modInv(ll a, ll b = MOD - 2) {\n\tif (b & 1) return a * modInv(a, b ^ 1) % MOD;\n\tif (b == 0) return 1;\n\treturn modInv(a*a % MOD, b >> 1);\n}\n\nconst int N = 1e7;\nll fact[N+1];\n\nll choose(ll a, ll b) {\n\tif (a < b) return 0;\n\tll dv = fact[b] * fact[a - b] % MOD;\n\treturn fact[a] * modInv(dv) % MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fact[i] = i * fact[i-1] % MOD;\n\n\tll res = modInv(3, n);\n\tfor (int k = n/2 + 1; k <= n; ++k) {\n\t\tll add = choose(n, k) * modInv(2, n - k) % MOD;\n\t\tres -= 2*add;\n\t}\n\tres %= MOD;\n\tif (res < 0) res += MOD;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing uint = unsigned int;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ndefault_random_engine generator;\n// mt19937 rnd(1);\n\nconst int P = 998244353;\n\nvoid add(int &a, int b, int p = P) {\n    a += b;\n    if (a >= p) {\n        a -= p;\n    }\n}\n\nvoid sub(int &a, int b, int p = P) {\n    a -= b;\n    if (a < 0) {\n        a += p;\n    }\n}\n\n\nvoid mul(int &a, int b, int p = P) {\n    a = ll(a) * b % p;\n}\n\nint binPow(int a, int b, int p = P) {\n    int res = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) {\n            mul(res, a, p);\n        }\n        mul(a, a, p);\n    }\n    return res;\n}\n\nint reverse(int a, int p = P) {\n    return binPow(a, p - 2, p);\n}\n\nint main() {\n#ifdef LOCAL\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);  \n#endif \n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0); \n    cout << setprecision(12) << fixed;\n    cerr << setprecision(12) << fixed;      \n\n    int n;\n    cin >> n;\n\n    vector<int> r(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        r[i] = reverse(i);\n    }\n\n    int sum = 1;\n    int cur = 1;\n\n    for (int i = 1; i < n / 2; ++i) {\n        mul(cur, n - i + 1);\n        mul(cur, r[i]);\n        mul(cur, 2);\n        add(sum, cur);\n    } \n\n    mul(sum, 2);\n\n    int res = binPow(3, n);\n\n    sub(res, sum);\n\n    cout << res << endl;\n\n#ifdef LOCAL\n    cerr << \"Time: \" << double(clock()) / CLOCKS_PER_SEC << endl;\n#endif\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct modint{\n    using i64=int_fast64_t;\n    i64 a;\n    static constexpr i64 MOD=998244353;\n    modint(){a=0;}\n    modint(i64 a_){\n        a=a_%MOD;\n        if(a<0) a+=MOD;\n    }\n    modint inv()const{\n        i64 n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y(n);\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y;\n        y.a=a+x.a;\n        if(y.a>MOD) y.a-=MOD;\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y;\n        y.a=a-x.a;\n        if(y.a<0) y.a+=MOD;\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y;\n        y.a=(a*x.a)%MOD;\n        return y;\n    }\n    modint operator/(const modint& x){\n        modint y;\n        y.a=(a*x.inv().a)%MOD;\n        return y;\n    }\n    modint& operator+=(const modint& x){\n        a+=x.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        a-=x.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        (a*=x.a)%=MOD;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        (a*=x.inv().a)%=MOD;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    int_fast64_t a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(int_fast64_t a,int_fast64_t b){\n    modint _;\n    int_fast64_t n=1,A=a;\n    while(b){\n        if(b&1) (n*=A)%=modint::MOD;\n        (A*=A)%=modint::MOD;\n        b>>=1;\n    }\n    _.a=n;\n    return _;\n}\n\ntemplate <int n> struct COMB{\n    vector<int_fast64_t> fc,ifc;\n    COMB():fc(n),ifc(n){\n        fc[0]=1;\n        for(int i=1;i<n;++i) fc[i]=fc[i-1]*i%modint::MOD;\n        int_fast64_t N=1,A=fc[n-1],b=modint::MOD-2;\n        while(b){\n            if(b&1) (N*=A)%=modint::MOD;\n            (A*=A)%=modint::MOD;\n            b>>=1;\n        }\n        ifc[n-1]=N;\n        for(int i=n-1;i>=1;--i) ifc[i-1]=ifc[i]*i%modint::MOD;\n    };\n    modint operator()(int N,int R)const{\n        if(N<0||R<0||N<R) return 0;\n        return fc[N]*ifc[R]%modint::MOD*ifc[N-R];\n    }\n    modint operator[](int N)const{\n        modint _;\n        _.a=fc[N];\n        return _;\n    }\n    modint operator()(int N)const{\n        modint _;\n        _.a=ifc[N];\n        return _;\n    }\n};\nCOMB<10000010> comb;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    istream& in(cin);\n    ostream& out(cout);\n    int n;\n    in>>n;\n    modint ans=pwr(3,n);\n    fr(i,n/2) ans-=comb(n,i)*pwr(2,i+1);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[10000010], finv[10000010], inv[10000010]; \nlong long P = 998244353;\nlong long Pow(long long int a, long long n) {\n\tlong long tmp = a; \n\tlong long pow = n;\n\tlong long Q = 1;  \n  \twhile(pow > 0){\n\t\tif(pow & 1){\n\t\t\tQ *= tmp; Q %= P; \n\t\t}\n\t\ttmp = tmp * tmp % P; \n     \t\tpow >>= 1; \n  \t}\n\treturn Q;\n} \nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < 10000005; i++) {\n        fac[i] = fac[i - 1] * i % P;\n        inv[i] = P - inv[P % i] * (P / i) % P;\n        finv[i] = finv[i - 1] * inv[i] % P;\n    }\n}\nlong long COM(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % P) % P;\n}\nint main(){\n\tint N; cin >> N; \n\tCOMinit(); \n\tlong long ans = Pow(3, N); \n\tfor(int i = 0; i < N/2; i++){\n\t\tlong long tmp = 2 * COM(N, i) * Pow(2, i) % P; \n\t\tans += P - tmp; \n\t\tif(ans >= P) ans -= P; \n\t}\n\tcout << ans << endl;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<22);\n \nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    ll ans=mod_pow(3,n);\n    vector<ll> p2(n+1,1);\n    for(int i=0;i<n;i++){\n        p2[i+1]=p2[i]*2%mod;\n    }\n    for(int i=n/2+1;i<=n;i++){\n        ans-=p.comb(n,i)*p2[n-i]*2;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T1, typename T2> bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct ModInt {\n    int val;\n    ModInt(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n    bool operator!=(const ModInt &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    ModInt &operator+=(const ModInt &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n    ModInt operator++(signed) {\n        const ModInt ret(*this);\n        ++*this;\n        return ret;\n    }\n    ModInt operator--(signed) {\n        const ModInt ret(*this);\n        --*this;\n        return ret;\n    }\n    ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        int a = MOD, b = val, u = 0, v = 1;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        ModInt ret = 1, mul = *this;\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, ModInt &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &rhs) { return os << rhs.val; }\n    struct Combination {\n        std::vector<ModInt> fact{1, 1}, fInv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                fInv.push_back(fInv[i - 1] * inv[i]);\n            }\n        }\n        ModInt P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * fInv[n - r]); }\n        ModInt C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * fInv[r] * fInv[n - r]); }\n        ModInt H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\nusing Mint=ModInt<998244353>;\nint N;\nsigned main() {\n    cin >> N;\n    Mint ans = Mint(3).pow(N);\n    Mint::Combination comb;\n    for (int i = N / 2 + 1; i <= N; i++) {\n        ans -= comb.C(N, i) * Mint(2).pow(N - i) * 2;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* じょえチャンネル\n* 高評価・チャンネル登録よろしくおねがいします！\n* https://www.youtube.com/channel/UCRXsI3FL_kvaVL9zoolBfbQ\n*/\n\n#include <bits/stdc++.h>\n\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#define f(i,n) for(int i=0;i<(n);i++)\n\n\n//#define inf (int)(3e18)\n#define inf 998244353ll\n\n//here!!!\n// define int long long !!!!!\n\n#define int long long\n\n// define int long long !!!!!\n\n\n#define mod (int)((1e9)+7)\n//constexpr int mod=998244353ll;\n\n#define intt long long\n#define itn long long\n#define P pair<int,int>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\n//Library\n//モッドパウ\ninline int modpow(int x, int y, int m = mod) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n            res %= m;\n        }\n        x = x * x % m;\n        y /= 2;\n    }\n    return res;\n}\n\nint mypow(int x, int y) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n        }\n        x = x * x;\n        y /= 2;\n    }\n    return res;\n}\n//is the number (x) a prime number?\nbool prime(int x) {\n    if(x == 1 || x == 0) {\n        return false;\n    }\n    for (int i = 2; i * i <= x; i++) {\n        if (!(x % i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//saidai-kouyakusuu\ninline int gcd(int x, int y) {\n    if (!y) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\n\n//number of keta\nint keta(int x) {\n    int ans = 0;\n    while (x) {\n        x /= 10;\n        ans++;\n    }\n    return ans;\n}\n\n//sum of keta\nint ketasum(int x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ninline int lcm(int x, int y) {\n    int ans = x / gcd(x, y) * y;\n    return ans;\n}\nint twobeki(int x) {\n    int ans = 0;\n    while (1) {\n        if (!(x & 1)) {\n            ans++;\n            x /= 2;\n        }\n        else {\n            break;\n        }\n    }\n    return ans;\n}\n\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n    if (lhs < rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n    if (lhs > rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\nvoid Yes(){\n    cout<<\"Yes\"<<endl;\n}\nvoid No(){\n    cout<<\"No\"<<endl;\n}\nvoid YES(){\n    cout<<\"YES\"<<endl;\n}\nvoid NO(){\n    cout<<\"NO\"<<endl;\n}\n\nint kai(int x, int y) {\n    int res = 1;\n    for (int i = x - y + 1; i <= x; i++) {\n        res *= i; res %= mod;\n    }\n    return res;\n}\n\nint comb(int x, int y) {\n    if (y > x)return 0;\n    return kai(x, y) * modpow(kai(y, y), mod - 2) % mod;\n}\n\n#define fin(i) scanf(\"%lld\",&i)\n#define fout(i) printf(\"%lld\",i)\n#define fendl printf(\"\\n\")\n//Library-End\n\n#define vecin(v) for(int i=0;i<v.size();i++)scanf(\"%lld\",&v[i]);\n#define vecout(v) {for(int i=0;i<v.size();i++)cout<<v[i]<<' ';cout<<endl;}\n#define endl \"\\n\" //interactive の時に注意！！！\n//SegTree\ntemplate <class T>\nclass SegTree {\n    int n;                       // 葉の数\n    vector<T> data;              // データを格納するvector\n    T def;                       // 初期値かつ単位元\n    function<T(T, T)> operation; // 区間クエリで使う処理\n    function<T(T, T)> update;    // 点更新で使う処理\n    \n    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n    T _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return def; // 交差しない\n        if (a <= l && r <= b)\n            return data[k]; // a,l,r,bの順で完全に含まれる\n        else {\n            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n            return operation(c1, c2);\n        }\n    }\n    \npublic:\n    // _n:必要サイズ, _def:初期値かつ単位元, _operation:クエリ関数,\n    // _update:更新関数\n    SegTree(size_t _n, T _def, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    : def(_def), operation(_operation), update(_update) {\n        n = 1;\n        while (n < _n) {\n            n *= 2;\n        }\n        data = vector<T>(2 * n - 1, def);\n    }\n    \n    // 場所i(0-indexed)の値をxで更新\n    void change(int i, T x) {\n        i += n - 1;\n        data[i] = update(data[i], x);\n        while (i > 0) {\n            i = (i - 1) / 2;\n            data[i] = operation(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n    \n    // [a, b)の区間クエリを実行\n    T query(int a, int b) {\n        return _query(a, b, 0, 0, n);\n    }\n    \n    // 添字でアクセス\n    T operator[](int i) {\n        return data[i + n - 1];\n    }\n};\n\n#define R_MIN ([](long long a, long long b) { return min(a, b); })\n#define R_MAX ([](long long a, long long b) { return max(a, b); })\n#define R_SUM ([](long long a, long long b) { return a + b; })\n\n#define NORMAL_UPDATE ([](long long a, long long b) { return b; })\n#define ADD_UPDATE ([](long long a, long long b) { return a + b; })\n#define MINUS_UPDATE ([](long long a, long long b) { return a - b; }\n\nclass Union_Find {\n    vector<int> par;\n    vector<int> rankmy;\n    vector<int> ookisa;\n    \npublic:\n    Union_Find(int size) {\n        par = vector<int>(size);\n        rankmy = vector<int>(size);\n        ookisa=vector<int>(size);\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n            ookisa[i]=1;\n        }\n    }\n    \n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (rankmy[x] < rankmy[y]) {\n            par[x] = y;\n            ookisa[y]+=ookisa[x];\n            ookisa[x]=0;\n        }\n        else {\n            par[y] = x;\n            ookisa[x]+=ookisa[y];\n            ookisa[y]=0;\n            if (rankmy[x] == rankmy[y]) {\n                rankmy[x]++;\n            }\n        }\n    }\n    int size(int i){\n        i=find(i);\n        return ookisa[i];\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n};\n\n//Union-Find-End\nint perm[1000005];\nvoid init_perm() {\n    perm[0] = 1;\n    REP(i, 1000000) {\n        perm[i] = perm[i - 1] * i % mod;\n    }\n}\n\nint nCk(int x, int y) {\n    return perm[x] * modpow(perm[x - y], mod - 2) % mod * modpow(perm[y], mod - 2) % mod;\n}\n\nint n,ans,now;\nsigned main(){\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    init_perm();\n    cin>>n;\n    now=7;\n    for(int i=1;i<=n/2;i++){\n        ans+=modpow(7, n/2-i)*(i?(n/2-i+1):1)*now%mod;\n        now*=2;\n        now%=mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define N 10000000 + 5\n#define Mod 998244353\n\nint n, ans, Fac[N], Inv[N], Pow3[N], Pow2[N];\n\nvoid Prepare()\n{\n\tFac[0] = Inv[0] = Inv[1] = Pow3[0] = Pow2[0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tFac[i] = 1LL * Fac[i - 1] * i % Mod;\n\t\tPow3[i] = 3LL * Pow3[i - 1] % Mod;\n\t\tPow2[i] = 2LL * Pow2[i - 1] % Mod;\n\t}\n\tfor (int i = 2; i <= n; i ++)\n\t\tInv[i] = Mod - (1LL * Inv[Mod % i] * (Mod / i) % Mod);\n\tfor (int i = 2; i <= n; i ++)\n\t\tInv[i] = 1LL * Inv[i - 1] * Inv[i] % Mod;\n}\n\ninline int C(int u, int v)\n{\n\tif (u < 0 || v < 0 || u < v)\n\t\treturn 0;\n\treturn 1LL * Fac[u] * Inv[v] % Mod * Inv[u - v] % Mod;\n}\n\ninline int Inc(int u, int v)\n{\n\treturn u + v - (u + v >= Mod ? Mod : 0);\n}\n\nint Calc()\n{\n\tint res = 0;\n\tfor (int t = n / 2 + 1; t <= n; t ++)\n\t\tres = (2LL * C(n, t) * Pow2[n - t] + res) % Mod;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tPrepare();\n\tans = Inc(Pow3[n], Mod - Calc());\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n#define gc getchar()\n#define pc(x) putchar(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing namespace std;\nusing ll = long long;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 2;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        bi = divmod(bi, i, mod);\n        ans -= bi; //A or B\n        if(ans < 0)\n            ans += mod;\n    }\n    print(ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 1e7 + 10;\nconst ll mod = 998244353;\n\nll powmod(ll a, ll b) {\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll a) {\n\treturn powmod(a, mod-2);\n}\n\nint n;\nll fact[maxn];\nll invfact[maxn];\nll pow2[maxn];\n\nll choose(ll a, ll b) {\n\tif (a < b) return 0;\n\tll res = fact[a];\n\tres = (res * invfact[b]) % mod;\n\tres = (res * invfact[a-b]) % mod;\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfact[0] = invfact[0] = 1;\n\tpow2[0] = 1;\n\tll pow3 = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfact[i] = (fact[i-1] * i) % mod;\n\t\tinvfact[i] = inv(fact[i]);\n\t\tpow2[i] = (pow2[i-1] * 2) % mod;\n\t\tpow3 = (pow3 * 3) % mod;\n\t}\n\tll ans = pow3;\n\tfor (int i = n/2 + 1; i <= n; ++i) {\n\t\tll res = 2;\n\t\tres = (res * choose(n, i)) % mod;\n\t\tres = (res * pow2[n - i]) % mod;\n\t\tans = (ans - res + mod) % mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define X first\n#define Y second\n\ntemplate<typename T> // order_of_key(), *find_by_order()\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nmt19937_64 gen(time(nullptr));\n\nll const mod = 998244353;\n\nnamespace {\n    ll mul(ll a, ll b) {\n        ll val = a * b - (ll) ((ld) a * b / mod) * mod;\n        if (val < 0) val += mod;\n        if (val >= mod) val -= mod;\n        return val;\n    }\n\n    ll poww(ll a, ll b) {\n        ll val = 1;\n        a %= mod;\n        while (b > 0) {\n            if (b % 2) val = mul(a, val);\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return val % mod;\n    }\n\n    ll inv(ll a) {\n        return poww(a, mod - 2);\n    }\n}\nll const maxn = 3e5 + 5;\nll fact[maxn];\n\nll C(ll n, ll k) {\n    return mul(fact[n], inv(mul(fact[n - k], fact[k])));\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        fact[i] = fact[i - 1] * i;\n        fact[i] %= mod;\n    }\n    ll n;\n    cin >> n;\n    ll ans = poww(3, n);\n    ll kek = 0;\n    for (ll i = n / 2 + 1; i <= n; i++) {\n        (kek += mul(C(n, i), poww(2, n - i))) %= mod;\n    }\n    kek = mul(kek, 2);\n    cout << ((ans - kek) % mod + mod) % mod << endl;\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define EPS ((ld)(1e-9))\n \n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define all(x) (x).begin(), (x).end()\n#define rep(i, e) for (int i = 0, _##i = (e); i < _##i; i++)\n#define repp(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n#define repr(i, s, e) for (int i = (s)-1, _##i = (e); i >= _##i; i--)\n#define repi(i, x) for (auto &i : (x))\n#define ARR(...) vector<int>({__VA_ARGS__})\n#define ARS(...) vector<string>({__VA_ARGS__})\n \n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef complex<double> base;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << '(' << pai.first << ' ' << pai.second << ')';\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    cout << '[';\n    for (auto p : v) cout << p << \",\";\n    cout << \"]\";\n    return os;\n}\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const set<T, V> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \n#ifdef ONLINE_JUDGE\n#define debug(...) 0\n#define endl '\\n'\n#else\n#define debug(...) cout << \" [-] \", _dbg(#__VA_ARGS__, __VA_ARGS__)\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cout << sdbg << '=' << h << endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n    while(*sdbg != ',') cout << *sdbg++;\n    cout << '=' << (h) << ','; \n    _dbg(sdbg+1, a...);\n}\n#endif\n \ntemplate<typename T> void get_max(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void get_min(T &a, T b) {a = min(a, b);}\n\nconstexpr ll MOD = 998244353;\n\nint N;\nll fact[5000001] = {1};\nll invf[5000001] = {1};\nll ccom[5000002];\nll csum[5000002];\n\nll comb(ll a, ll b) {return fact[a]*invf[b]%MOD*invf[a-b]%MOD;}\nll mpow(ll a, ll b){\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b&1) res = res*a%MOD;\n        a = a*a%MOD;\n    }\n    return res;\n}\nll inv(ll v) {return mpow(v, MOD-2);}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    cin >> N;\n    repp(i, 1, N/2+1) fact[i] = fact[i-1]*i%MOD;\n    invf[N/2] = inv(fact[N/2]);\n    repr(i, N/2, 1) invf[i] = invf[i+1]*(i+1)%MOD;\n    rep(i, N/2+1) ccom[i] = comb(N/2, i);\n    repr(i, N/2+1, 0) csum[i] = (csum[i+1]+ccom[i]*mpow(2, N/2-i))%MOD;\n\n    ll res = mpow(3, N);\n    repp(i, 1, N/2+1) {\n        res -= ccom[i]*csum[N/2+1-i]%MOD*mpow(2, N/2-i+1);\n        res = (res%MOD+MOD)%MOD;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sync ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define F first\n#define S second\n#define eb emplace_back\n#define pb emplace_back\n#define mt make_tuple\n#define gcd __gcd\n#define PI 3.141592653589\n// Input\n#define in(a) scanf(\"%d\",&a)\n#define in2(a,b) scanf(\"%d%d\",&a,&b)\n#define in3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define llin(a) cin >> a\n#define inl(a) scanf(\"%lld\",&a)\n#define read(v,i,n) for(i=0;i<n;i++)in(v[i])\n#define twod(mat,i,j,n,m) rep(i,n){rep(j,m)in(mat[i][j]);}\n#define sc(ch) scanf(\"%c\",&ch)\n#define sstr(str) scanf(\"%s\",str)\n// Output\n#define pr(a) printf(\"%d \",a)\n#define pr2(a,b) printf(\"%d %d\\n\",a,b)\n#define pr3(a,b,c) printf(\"%d %d %d\\n\",a,b,c)\n#define out(a) printf(\"%d\\n\",a)\n#define outl(a) printf(\"%lld\\n\",a)\n#define llpr(a) cout << a << \" \"\n#define llout(a) cout << a << \"\\n\"\n#define yes printf(\"YES\\n\")\n#define no printf(\"NO\\n\")\n#define lin printf(\"\\n\")\n// Iterator\n#define lp(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) for(i=0;i<n;i++)\n#define all(vec) vec.begin(),vec.end()\n#define lower(v,k) lower_bound(v.begin(),v.end(),k)-v.begin()\n#define upper(v,k) upper_bound(v.begin(),v.end(),k)-v.begin()\n#define tf(mytuple) get<0>(mytuple)\n#define ts(mytuple) get<1>(mytuple)\n#define tt(mytuple) get<2>(mytuple)\n// Debug\n#define dbg(v,i,n) for(i=0;i<n;i++)pr(v[i]); lin\n#define what(x) cerr << #x << \" : \" << x << \"\\n\"\n#define ck printf(\"continue\\n\")\n#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n\tcerr << *it << \" = \" << a << \"\\n\";\n\terr(++it, args...);\n}\n// Data Type\n#define ll long long int\n#define ii pair<int,int>\n#define pli pair<ll,int>\n#define state tuple<int,int,int>\n#define vi vector<int>\n#define vii vector<pair<int,int> >\n#define vvi vector<vector<int> >\n#define viii vector<pair<pair<int,int>,int> >\n#define vvii vector<vector<pair<int,int> > >\n#define M 998244353\n#define B 300  //check the limits, man\n#define N 5000003\nconst ll INF = 1e18;\nll inv[N];\nll pro(ll a,ll b)\n{\n    return (a*b)%M;\n}\nvoid buildfact()\n{\n    int i,q,r;\n    fill(inv,inv+N,1);\n    for(i=2;i<N;i++)\n    {\n        q=M/i,r=M%i;\n        inv[i]=M-pro(q,inv[r]);\n    }\n    return ;\n}\nint main()\n{\n    buildfact();\n    int i,n,m;\n    ll ans,p2,p3,temp;\n    in(n);\n    ans=0,p2=1,p3=1;\n    m=(n>>1),temp=1;\n    rep(i,m)\n    {\n        ans+=pro(temp,p2);\n        p2+=p2;\n        if(p2>M)p2-=M;\n        temp=pro(temp,pro(n-i,inv[i+1]));\n    }\n    rep(i,n)\n        p3=pro(p3,3);\n    ans+=ans;\n    ans%=M;\n    p3=(p3+M-ans)%M;\n    llout(p3);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nlong long pw[5000005],fact[5000005],inv[5000005];\nlong long pow_log(long long x,int y)\n{\n\tif (!y)\n\treturn 1;\n\tlong long ret=pow_log(x,y/2);\n\tret=(ret*ret)%mod;\n\tif (y%2)\n\tret=(ret*x)%mod;\n\treturn ret;\n}\nint ncr(int n,int r)\n{\n\treturn ((fact[n]*inv[r])%mod*inv[n-r])%mod;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tn/=2;\n\tfact[0]=1;\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfact[i]=(i*fact[i-1])%mod;\n\t\tpw[i]=(2*pw[i-1])%mod;\n\t}\n\tinv[n]=pow_log(fact[n],mod-2);\n\tfor (int i=n-1;i>=0;i--)\n\tinv[i]=((i+1)*inv[i+1])%mod;\n\tint ans=0,sum=pw[n];\n\tfor (int a=0;a<=n;a++)\n\t{\n\t\tlong long tmp=(ncr(n,a)*pw[n-a])%mod;\n\t\tans=(ans+2*tmp*sum-tmp*tmp%mod+mod)%mod;\n\t\tif (a!=n)\n\t\t{\n\t\t\tsum=(sum+ncr(n,a+1)*pw[n-a-1])%mod;\n\t\t\tsum=(sum-ncr(n,a)*pw[a]%mod+mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll mod = 998244353;\n\nll todeg(ll k, ll deg) {\n    ll deg0 = deg;\n    if (deg == 0) {\n        return 0;\n    }\n    if (deg == -1) {\n        deg = mod - 2;\n    }\n    ll ans = 1;\n    for (int i = 30; i >= 0; --i) {\n        ans *= ans;\n        if (ans > 100000000000LL) {\n            ans %= mod;\n        }\n        if ((deg >> i) & 1) {\n            ans *= k;\n        }\n        if (ans > mod) {\n            ans %= mod;\n        }\n    }\n    /*while (deg > 1) {\n        ans *= ans;\n        ans %= mod;\n        if (deg % 2 == 1) {\n            ans *= k;\n            ans %= mod;\n        }\n        deg /= 2;\n    }*/\n    //cout << k << \"^\" << deg0 << \"=\" << ans << '\\n';\n    return ans;\n}\n\n\n\nint main()\n{\n    /*for (int i = 32; i >= 0; --i) {\n        if (((mod - 2) >> i) & 1) {\n            cout << '1';\n        } else {\n            cout << '0';\n        }\n    }*/\n    ll n;\n    cin >> n;\n    ll f = 1;\n    ll mind = 1, curc = 1;\n    if (n >= 6666666) {\n        mind = 3333333;\n        f = 547828731LL;\n        curc = 602219756LL;\n    } else if (n >= 3333334) {\n        mind = 1666667;\n        f = 666284590LL;\n        curc = 87423526LL;\n    }\n    for (int k = mind; k * 2 < n; ++k) {\n        /*if ((k + 1) * 2 >= n) {\n            cout << \"lastk = \" << k << '\\n';\n        }*/\n        /*cur2 *= 2;\n        while (cur2 > mod) {\n            cur2 -= mod;\n        }*/\n        curc = curc * 2 * (n - k + 1);\n        /*if (curc % k == 0) {\n            curc /= k;\n        } else {\n            curc = (curc % mod) * todeg(k, -1);\n        }\n        curc %= mod;*/\n        curc = ((curc % mod) * todeg(k, -1)) % mod;\n        //cout << k << \": \" << cur2 << \", \" << curc << '\\n';\n        f += /*cur2 * */curc;\n        //f %= mod;\n        if (f > mod) {\n            f -= mod;\n        }\n    }\n    //cout << f << '\\n' << curc << '\\n';\n    ll ans = todeg(3, n);\n    ans -= 2 * f;\n    while(ans < 0) {\n        ans += mod;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define ll long long\n#define mod 998244353\nusing namespace std;\nint n;\nll p2[10000010],p3[10000010],inv[10000010],ifac[10000010],fac[10000010];\ninline ll calc(int n,int m){\n\treturn fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline ll solve(){\n\tll res=0;\n\tfor(register int i=(n>>1)+1;i<=n;i++){\n\t\tres=(res+calc(n,i)*p2[n-i]%mod)%mod;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tinv[1]=1;\n\tfor(register int i=2;i<=n;i++)inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\tp2[0]=p3[0]=fac[0]=ifac[0]=1;\n\tfor(register int i=1;i<=n;i++){\n\t\tp2[i]=p2[i-1]*2%mod;\n\t\tp3[i]=p3[i-1]*3%mod;\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tifac[i]=ifac[i-1]*inv[i]%mod;\n\t}\n\tprintf(\"%lld\",(p3[n]-2ll*solve()%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nconst int MOD = 998244353;\nconst int MX = 10000005;\nint n;\nll ans = 1, k;\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nll fact[MX] = {1}, invf[MX];\nvoid setcomb(int n){\n\tfor(int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % MOD;\n\tinvf[n] =  exp(fact[n] ,MOD-2);\n\tfor(int i = n; i > 0; i--) invf[i-1] = (invf[i] * i) % MOD;\n}\ninline ll comb(int a, int b){return fact[a] * invf[a-b] % MOD * invf[b] % MOD;}\nint main(){\n\tscanf(\"%d\", &n);\n\tsetcomb(n);\n\tans = exp(3,n);\n\trep(i,n/2) ans -= comb(n,i) * exp(2,i) * 2 % MOD;\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=10000010;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\t\n\tmint ans=mint(3).pow(n);\n\tcerr<<n<<endl;\n\tvc<mint> p2(n+1,1);\n\trep(i,n)p2[i+1]=p2[i]*2;\n\trng(i,n/2+1,n+1)\n\t\tans-=choose(n,i)*p2[n-i]*2;\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph & g, Matrix & scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\ntemplate<typename T>\ninline void bit_reverse(vector<T> & a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n & -n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod - 2, mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long> & input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long> & input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto& x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long> & a, const vector<long long> & b) {\nint result_size = a.size() + b.size() - 1;\nint n = 1; while (n < result_size) n <<= 1;\n\nvector<long long> _a = a, _b = b;\n_a.resize(n, 0);\n_b.resize(n, 0);\n\nntt(_a);\nntt(_b);\nfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\nintt(_a);\n\n_a.resize(result_size);\nreturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\n\t\tret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nint popcount3(int x) {\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0F0F0F0F) + (x >> 4 & 0x0F0F0F0F);\n\tx = (x & 0x00FF00FF) + (x >> 8 & 0x00FF00FF);\n\tx = (x & 0x0000FFFF) + (x >> 16 & 0x0000FFFF);\n\n\treturn x;\n}\n\nll const mod = 998244353;\nll two[10000010];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\n\tll n;\n\tcin >> n;\n\tCombination comb(n+1, mod);\n\ttwo[0] = 1;\n\tREP(i, n) {\n\t\ttwo[i + 1] = (two[i] * 2) % mod;\n\t}\n\tll ans = mod_pow(3, n, mod);\n\tll temp = 0;\n\trep(i,n/2+1,n+1) {\n\t\t(temp += comb.nCr(n, i) * two[n - i] % mod) %= mod;\n\t}\n\t(temp *= 2) %= mod;\n\t(ans += mod - temp) %= mod;\n\n\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=10000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n;\n\nint main(){\n\tInit();\n\tcin>>n;\n\tll res=Pow(3,n);\n\tfor(int i=n/2+1;i<=n;i++) res=(res-2*nCk(n,i)*Pow(2,n-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 5000000;\ndouble Pi = 3.1415926535897932384626;\n \nvector<ll> G[550010];\n//vector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n\nll mod = 998244353;\n//ll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k,idx,ans;\nll x[500005],y[500005],z[500005];\nchar s[500005];\nll dp[5000005];\nll dpsum[5000005];\n\nint main(){\n    cin >> n;\n    c3_init();\n    for(int i=0;i<=n / 2;i++){\n        dp[i] = c3(n / 2, i);\n        dpsum[i] = dp[i];\n    }\n    for(int i=0;i<=n / 2;i++){\n        dpsum[i] *= rui(2, n / 2 - i);\n        dpsum[i] %= mod;\n    }\n    for(int i=n / 2;i>=1;i--){\n        dpsum[i-1] += dpsum[i]; \n        dpsum[i-1] %= mod;\n    }\n\n    for(int i=0;i<=n / 2;i++){\n        num = dp[i] * dpsum[n / 2 - i + 1];\n        num %= mod;\n        num *= rui(2ll, n / 2 - i);\n        num %= mod;\n        ans += num;\n        ans %= mod;\n        //p(ans);\n    }\n    ans *= 2;\n    ans %= mod;\n    ans = rui(3ll, n) - ans + mod;\n    ans %= mod;\n    p(ans);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate<class T> ostream& prnt(ostream& out, T v) { out << v.size() << '\\n'; for(auto e : v) out << e << ' '; return out;}\ntemplate<class T> ostream& operator<<(ostream& out, vector <T> v) { return prnt(out, v); }\ntemplate<class T> ostream& operator<<(ostream& out, set <T> v) { return prnt(out, v); }\ntemplate<class T1, class T2> ostream& operator<<(ostream& out, map <T1, T2> v) { return prnt(out, v); }\ntemplate<class T1, class T2> ostream& operator<<(ostream& out, pair<T1, T2> p) { return out << '(' << p.st << ' ' << p.nd << ')'; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << \" \" << H; debug_out(T...);}\n#define dbg(...) cerr << #__VA_ARGS__ << \" ->\", debug_out(__VA_ARGS__)\n#define dbg_v(x, n) do{cerr<<#x\"[]: \";for(int _=0;_<n;++_)cerr<<x[_]<<\" \";cerr<<'\\n';}while(0)\n#define dbg_ok cerr<<\"OK!\\n\"\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define pii pair<int,int>\n#define MOD 998244353\n#define zeros(x) x&(x-1)^x\n#define fi first\n#define se second\n#define Nmax 10000005\nconst long double PI = acos(-1);\n\nint n,x;\nint A[Nmax],S[Nmax],B[Nmax],S2[Nmax], P2[Nmax];\n\ntemplate<typename T = long long>\nT _pow(T a, T b){\n    T ans = 1;\n    for (; b; b >>= 1){\n        if (b % 2) ans = ans * a % MOD;\n        a = a * a % MOD;\n    }\n    return ans;\n}\n\nlong long P[Nmax], inv[Nmax];\ntemplate<typename T = long long>\nT comb(T n, T m){\n    if (P[1] == 0) cerr << \"Apeleaza functia prec!\\n\";\n    return P[n] * inv[m] % MOD * inv[n-m] % MOD;\n}\n\ntemplate<typename T = long long>\ninline void add(T &a, T b){\n    a += b;\n    if (a >= MOD) a -= MOD;\n    if (a < 0) a += MOD;\n}\n\nvoid prec(int n = Nmax-1){\n    P[0] = inv[0] = 1;\n    for (int i=1;i<=n;i++){\n        P[i] = P[i-1] * i % MOD;\n        inv[i] = _pow(P[i], MOD - 2LL);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    prec();\n\n    cin >> n;\n    int x = n / 2;\n\n    P2[0] = 1;\n    for (int i=1;i<=n;i++){\n        P2[i] = 1LL * P2[i-1] * 2 % MOD;\n    }\n\n    for (int i=1;i<=x;i++){\n        A[i] = comb(x,i);\n    }\n    for (int i=x;i>=1;i--){\n        add(S[i], S[i+1]);\n        add(S[i], A[i]);\n        S2[i] = (S2[i+1] + 1LL * A[i] * P2[x-i]) % MOD;\n    }\n\n    int ans = 0;\n    for (int i=1;i<=x;i++){\n        int y = (x+1) - i;\n        // dbg(i,A[i],P2[x-i],S2[y]);\n        ans = (ans + 1LL * A[i] * P2[x-i] % MOD * S2[y]) % MOD;\n    }\n\n        // dbg(ans);\n    ans = ans * 2 % MOD;\n    ans = (1LL * _pow(3LL,1LL*n) - ans + MOD) % MOD;\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e7 + 10;\nconst int M = 998244353;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint fact[N], rfact[N];\n\nint ncr(int n, int k) {\n    if (k < 0 || k > n)\n        return 0;\n    return (ll) fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (ll) i * fact[i - 1] % M;\n    }\n    rfact[N - 1] = pw(fact[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        rfact[i] = (ll) (i + 1) * rfact[i + 1] % M;\n    }\n}\n\nint naive(int n) {\n    n >>= 1;\n\n    int ans = 0;\n    fori (a0, n + 1) {\n        fori (b0, n - a0 + 1) {\n            int c0 = n - a0 - b0;\n            fori (a1, n + 1) {\n                fori (b1, n + 1 - a1) {\n                    int c1 = n - a1 - b1;\n                    bool ok = 1;\n                    ok &= max(0, a0 - a1) + max(0, b0 - b1) <= c1;\n                    ok &= max(0, a1 - a0) + max(0, b1 - b0) <= c0;\n                    if (ok) {\n                        int cur = (ll) fact[n] * rfact[a0] % M * rfact[b0] % M * rfact[c0] % M;\n                        cur = (ll) cur * fact[n] % M * rfact[a1] % M * rfact[b1] % M * rfact[c1] % M;\n                        ans = (ans + cur) % M;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nvoid insum(int & a, int b) {\n    a = (a + b) % M;\n}\n\nint solve(int n) {\n    n >>= 1;\n\n    int ans = 0;\n    fori (x, n + 1) {\n        fori (y, n + 1) {\n            insum(ans, (ll)ncr(2 * n, x) * ncr(2 * n - x, y) % M);\n        }\n    }\n    return ans;\n}\n\nvoid smain() {\n    init();\n    int n;\n    cin >> n;\n\n\n//    cout << naive(n) << endl;\n    cout << solve(n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1e7 + 5, mod = 998244353;\n\nint silnia[max_n];\n\nint pot(int x, int y){\n    int wynik = 1;\n    while (y){\n        if (y % 2)\n            wynik = (long long)wynik * x % mod;\n        x = (long long) x * x % mod;\n        y /= 2;\n    }\n    return wynik;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    silnia[0] = 1;\n    for (int i = 1; i <= n; i++)\n        silnia[i] = (long long)silnia[i - 1] * i % mod;\n    int wynik = pot(3, n);\n    for (int i = n / 2 + 1; i <= n; i++)\n        wynik = (long long)wynik - (long long)((long long)pot(2, n - i) * 2 * silnia[n] % mod) * (long long)pot((long long)silnia[i] * silnia[n - i] % mod, mod - 2) % mod;\n    if (wynik < 0)\n        wynik += mod;\n    cout << wynik << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(unsigned _v, int) : v(_v) {}\n  template<class Z> ModInt(const Z& a) : v((a < 0 ? P - -a % P : a) % P) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  friend M operator*(M l, M r) { return M(l) *= r; }\n  friend M operator/(M l, M r) { return M(l) /= r; }\n  friend M operator+(M l, M r) { return M(l) += r; }\n  friend M operator-(M l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend bool operator==(M l, M r) { return l.v == r.v; }\n  friend bool operator!=(M l, M r) { return !(l == r); }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Z> M pow(Z n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n};\nusing Mint = ModInt<998244353>;\nconstexpr int N = 1 << 24;\nstruct Fact {\n  V<Mint> v;\n  Fact(int n) : v(n + 1, 1) {\n    for (int i = 1; i <= n; ++i) v[i] = i * v[i - 1];\n  }\n  Mint operator[](int i) const { return v[i]; }\n} fact(N);\nstruct Finv {\n  V<Mint> v;\n  Finv(int n) : v(n + 1, 1 / fact[n]) {\n    for (int i = n; i; --i) v[i - 1] = i * v[i];\n  }\n  Mint operator[](int i) const { return v[i]; }\n} finv(N);\nstruct Minv {\n  V<Mint> v;\n  Minv(int n) : v(n) {\n    for (int i = 1; i <= n; ++i) v[i - 1] = fact[i - 1] * finv[i];\n  }\n  Mint operator[](int i) const { return v[i - 1]; }\n} minv(N);\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * finv[r] * finv[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  n >>= 1;\n  Mint res = comb(2 * n, n);\n  for (int k = 0; k <= 2 * n; ++k) {\n    Mint sum;\n    for (int i = 0; i <= k; ++i) {\n      sum += (i & 1 ? -1 : 1) * comb(k + 1 - i, i) * comb(2 * n - 2 * i, n - i);\n    }\n    res += comb(2 * n, k + 1) * sum;\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define REP(i,a,n) for(ll i=a;i<n;i++)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tiii;\n\nconst int INF = 100000000;\nconst ll LINF = 1e18+5;\n\nconst ll M = 998244353; // modの値\n\nvector<ll> fac(12000000); // n! mod M\nvector<ll> ifac(12000000); // k^{M-2} mod M\n\nll mpow(ll x, ll n){ // x^n(modM)\n    ll ans = 1;\n    while (n!=0) {\n        if(n&1) ans = ans*x % M;\n        x = x*x % M;\n        n= n>>1;\n    }\n    return ans;\n}\n\nll comb(ll a, ll b) { // aCb mod M\n    if (a==0 && b==0) return 1;\n    if (a<b || a<0) return 0;\n    ll tmp = ifac[a-b] * ifac[b] % M;\n    return tmp * fac[a] % M;\n}\n\nvoid init_comb() {\n    fac[0] = 1;\n    ifac[0] = 1;\n    for (ll i=0;i<12000000;i++) {\n        fac[i+1] = fac[i]*(i+1) % M; // n!(mod M)\n        ifac[i+1] = ifac[i] * mpow(i+1, M-2) % M; // k^{M-2} mod M\n    }\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    init_comb();\n    ll Anum = 0LL;\n    REP(k,N/2+1,N+1) {\n        Anum += (mpow(2, N-k) * comb(N, k)) % M;\n        Anum %= M;\n    }\n    ll ans = (mpow(3, N) - 2 * Anum + 3*M) % M;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 998244353;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\nconst int N = 1e7+10;\nint n, fac[N], ifac[N], po[N];\nint C(int n, int m) {\n\treturn (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\n\nint main() {\n\tfac[0] = po[0] = 1;\n\tREP(i,1,N-1) fac[i]=(ll)fac[i-1]*i%P,po[i]=(ll)po[i-1]*2%P;\n\tifac[N-1] = inv(fac[N-1]);\n\tPER(i,0,N-2) ifac[i]=(ll)ifac[i+1]*(i+1)%P;\n\tscanf(\"%d\", &n);\n\tint ans = qpow(3,n);\n\tREP(i,n/2+1,n) ans = (ans-2ll*C(n,i)*po[n-i])%P;\n\tif (ans<0) ans += P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nlong long F[10100000], InvF[10100000], Mod = 998244353, po[10100000];\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(int a, int b) {\n\treturn F[a] * InvF[b] % Mod*InvF[a - b] % Mod;\n}\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tF[0] = 1;\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tF[i] = F[i - 1] * i%Mod;\n\t\tpo[i] = po[i - 1] * 2 % Mod;\n\t}\n\tInvF[n] = Pow(F[n], Mod - 2);\n\tfor (i = n; i >= 0; i--)InvF[i - 1] = InvF[i] * i%Mod;\n\n\tlong long res = 0;\n\tfor (i = n / 2 + 1; i <= n; i++) {\n\t\tres = (res + Comb(n, i) * po[n - i]) % Mod;\n\t}\n\tres = res * 2 % Mod;\n\tlong long rr = 1;\n\tfor (i = 1; i <= n; i++)rr = rr * 3 % Mod;\n\tprintf(\"%lld\\n\", (rr - res + Mod) % Mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\nvector<long long> F, RF;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1];\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tRF[i] = Calc(F[i], MOD - 2);\n\t}\n\tfor (int X = N / 2 + 1; X <= N; X++) {\n\t\tint Y = N - X;\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= Calc(2, Y);\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n};\n\nvoid solve() {\n    int n; cin >> n;\n    int m = n/2;\n    Comb c(n);\n    vector<mint> pw(n+1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        pw[i] = pw[i-1] * 2;\n    }\n\n    mint res = 0;\n    for (int i = m+1; i <= n; i++) {\n        res += c.c(n, i) * pw[n-i+1];\n    }\n    res = mint(3).exp(n) - res;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 998244353\nusing mod = ModInt<MOD>;\n\n#define MAX_N 10000010\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\n\nmod p[MAX_N];\n\nint main(){\n    make();\n    int n;\n    cin >> n;\n    mod res = 1;\n    p[0] = 1;\n    for(int i=1;i<MAX_N;i++){\n        p[i] = p[i-1]*2;\n    }\n    rep(i,n){\n        res *= 3;\n    }\n    //(x+2)^nの n/2+1以降の値\n    for(int i=n/2+1;i<=n;i++){\n        res -= comb(n,i)*p[n-i]*2;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=10000002;\nconst int p=998244353;\nint n;\n\nvoid read(int &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid Add(ll &x,ll y){\n\tx+=y;\n\twhile(x>=p) x-=p;\n\twhile(x<0) x+=p;\n}\n\nll qpow(ll a,ll n){\n\tll ans=1;\n\tfor(;n;n>>=1,a=a*a%p) if (n&1) ans=ans*a%p;\n\treturn ans;\n}\n\nll fac[N],inv[N];\nvoid init(){\n\tfac[0]=1;\n\tfrl(i,1,N) fac[i]=fac[i-1]*i%p;\n\tinv[N-1]=qpow(fac[N-1],p-2);\n\trf(i,N-2,0) inv[i]=inv[i+1]*(i+1)%p;\n}\n\nll C(int n,int m){ return fac[n]*inv[m]%p*inv[n-m]%p; }\n\nint main(){\n\tcin>>n;\n\tinit();\n\tll ans=qpow(3,n);\n\tll pw=2;\n\trf(i,n,n/2+1){\n\t\tAdd(ans,-C(n,i)*pw%p);\n\t\tpw=pw*2%p;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// FUCKED UP FUCKED UP FUCKED UP FUCKED UP FUCKED UP\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=1e7+10, maxm=5e4+10, lg=21, mod=998244353, inf=1e18;\n\nll pwm(ll a,ll b){ll ret=1;for(;b;b>>=1,(a*=a)%=mod)if(b&1)(ret*=a)%=mod;return ret;}\nll fac[maxn],inv[maxn];\nll C(ll n,ll r){return fac[n]*inv[r]%mod*inv[n-r]%mod;}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tfac[0]=inv[0]=1; for(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i%mod, inv[i]=pwm(fac[i],mod-2);\n\tll n,c=0; cin>>n;\n\tfor(int i=n/2+1;i<=n;i++) (c+=C(n,i)*pwm(2,n-i)%mod)%=mod;\n\tcout<<(pwm(3,n)-2*c%mod+mod)%mod;\n\t\n\treturn 0;\n}\n\n\n\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353LL\n\nll fac[10000010],ifac[10000010],bin[10000010];\nint n;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll pls(const ll &x,const ll &y) { return (x+y<mod)?x+y:x+y-mod; }\ninline ll mns(const ll &x,const ll &y) { return (x-y<0)?x-y+mod:x-y; }\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\ninline void pre_gao()\n{\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=ksm(fac[n],mod-2);\n\tfor (int i=n-1;~i;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tbin[0]=1;\n\tfor (int i=1;i<=n;i++) bin[i]=bin[i-1]*2%mod;\n}\n\nint main()\n{\n\tn=rd();pre_gao();\n\tll ans=0;\n\tfor (int i=n/2+1;i<=n;i++) ans=pls(ans,ifac[i]*ifac[n-i]%mod*bin[n-i+1]%mod);\n\tprintf(\"%lld\\n\",mns(ksm(3,n),ans*fac[n]%mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define itn int\n#define For(i, a, b) for (int i = (a); i <= static_cast<int>(b); i++)\n#define Forr(i, a, b) for (int i = (a); i >= static_cast<int>(b); i--)\n#define rep(i, n) For(i, 0, n - 1)\n#define repall(i, arr) for (auto& i : (arr))\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define dump(x) cerr << #x << \" = \" << (x) << '\\n'\n#define dump2(x, y) \\\n    cerr << #x << \" = \" << (x) << \" \" << #y << \" = \" << (y) << '\\n'\n#define SZ(x) ((int)(x).size())\n#define bit(n) (1LL << (n))\nconstexpr int MOD = 998244353;\n\ntemplate <typename T>\nusing pq = priority_queue<T>;\ntemplate <typename T>\nusing pqr = priority_queue<T, vector<T>, greater<T>>;\nconst int INF = LLONG_MAX / 2;\nusing P = pair<int, int>;\nusing vec = vector<int>;\ntemplate <typename T>\nusing mat = vector<vector<T>>;\n\n// clang-format off\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& stream, const pair<T1, T2>& p) { return stream << p.first << \",\" << p.second; }\ntemplate <typename T>\nvoid print(const vector<T> vec) { rep (i, vec.size() - 1) cout << vec[i] << ' '; cout << vec[vec.size() - 1] << '\\n'; }\ntemplate <typename Arg>\nvoid print(const Arg arg) { cout << arg << '\\n'; }\ntemplate <typename Head, typename... Args>\nvoid print(const Head head, const Args... args) { cout << head << \" \"; print(args...); }\ntemplate <typename T, typename U>\nvoid init(vector<T>& v, vector<U>& w) { rep (i, v.size()) cin >> v[i] >> w[i]; }\ntemplate <typename T>\nvoid init(vector<T>& v) { rep (i, v.size()) cin >> v[i]; }\ntemplate <typename T>\nT sum_(vector<T> vec, T init = 0) { return std::accumulate(all(vec), T(init)); }\ntemplate<typename T>\nbool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T>\nbool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T>\nint index(const T& vec, const typename T::iterator it) { return distance(vec.begin(), it); }\ntemplate <typename T = int>\nmat<T> mmat(int n, int m=0) { return mat<T>(n, vector<T>(m)); }\ntemplate <typename T = int>\nvector<T> ivec(int n) { vector<T> v(n); init(v); return v; }\n// clang-format on\n\nvoid yn(bool tf) { print(tf ? \"Yes\" : \"No\"); }\nvoid YN(bool tf) { print(tf ? \"YES\" : \"NO\"); }\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n// -------------------------------------------------------------------\n// sort 1 2 3 4\n// pqr 1 2 3 must impl >\n// need to define MOD\nclass mint {\n    using ll = long long;\n    ll num;\n\npublic:\n    mint(ll x = 0) : num(x % MOD) {}\n    mint operator+=(const mint& x) noexcept {\n        this->num += x.num;\n        if (this->num >= MOD) this->num %= MOD;\n        return *this;\n    }\n    mint operator-=(const mint& x) noexcept {\n        if (this->num < x.num) this->num += MOD;\n        this->num -= x.num;\n        return *this;\n    }\n    mint operator*=(const mint& x) noexcept {\n        this->num = (this->num * x.num) % MOD;\n        return *this;\n    }\n    mint operator/=(mint x) noexcept {\n        ll exp = MOD - 2;\n        while (exp) {\n            if (exp % 2) *this *= x;\n            x *= x;\n            exp /= 2;\n        }\n        return *this;\n    }\n    mint operator%=(const mint& x) noexcept {\n        this->num %= x.num;\n        return *this;\n    }\n    mint operator+(const mint& x) const noexcept { return mint(*this) += x; }\n    mint operator-(const mint& x) const noexcept { return mint(*this) -= x; }\n    mint operator*(const mint& x) const noexcept { return mint(*this) *= x; }\n    mint operator/(const mint& x) const noexcept { return mint(*this) /= x; }\n    mint operator%(const mint& x) const noexcept { return mint(*this) %= x; }\n    mint operator&(const mint& x) const noexcept { return this->num & x.num; }\n    bool operator==(const mint& x) const noexcept { return this->num == x.num; }\n    bool operator!=(const mint& x) const noexcept { return not((*this) == x); }\n    explicit operator bool() const noexcept { return this->num != 0; }\n    explicit operator int() const noexcept { return this->num; }\n\n    mint pow(mint _n) {\n        mint r = mint(*this);\n        mint re = 1;\n        int n = (int)_n;\n        for (; n; n /= 2) {\n            if (n & 1) re *= r;\n            r *= r;\n        }\n        return re;\n    }\n\n    mint inv() { return this->pow(MOD - 2); }\n\n    friend ostream& operator<<(ostream&, const mint&);\n};\n\nostream& operator<<(ostream& stream, const mint& x) { return stream << x.num; }\n\nclass ModuloCombination {\n    using ll = long long;\n    ll len;\n    std::vector<mint> f, rf;\n\npublic:\n    ModuloCombination(ll max_len = 10000010)\n        : len(max_len + 1),\n          f(std::vector<mint>(len)),\n          rf(std::vector<mint>(len)) {\n        f[0] = 1;\n        for (int i = 0; i < len - 1; i++) f[i + 1] = f[i] * (i + 1);\n        rf[len - 1] = f[len - 1].inv();\n        for (int i = len - 2; i >= 0; i--) rf[i] = rf[i + 1] * (i + 1);\n    }\n    mint c(ll n, ll k) {\n        if (n < 0 or k < 0 or n - k < 0) {\n            std::cerr << \"(n,k) = \" << n << \" \" << k << std::endl;\n            exit(0);\n        }\n        return f[n] * rf[n - k] * rf[k];\n    }\n};\n\nsigned main() {\n    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<mint> po(n + 1);\n    po[0] = 1;\n    For(i, 1, n) po[i] = po[i - 1] * 2;\n\n    ModuloCombination comb(n + 1);\n\n    mint kahan = 0;\n    int over = n / 2 + 1;\n    For(i, over, n) kahan += po[n - i] * comb.c(n, i);\n\n    print(mint(3).pow(n) - kahan * 2);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef DEBUG\n#include \"inc/debug.hpp\"\n#else\n#define debug(...) 42\n#endif\n\nconst int mod = 998244353;\nconst int MAX = 1e7+1;\nlong long fc[MAX];\nlong long fci[MAX];\nlong long p2[MAX];\n\nlong long modpow(long long a, long long b) {\n    if (a == 2 && b < MAX && p2[b]) return p2[b];\n    if (b == 0) {\n        return 1;\n    } else if (b % 2 == 0) {\n        long long t = modpow(a, b/2);\n        return (t * t) % mod;\n    }\n    return (a * modpow(a, b-1)) % mod;\n}\n\nvoid init() {\n    p2[0] = 1;\n    for (int i=1; i<MAX; ++i) {\n        p2[i] = (p2[i-1] * 2) % mod;\n    }\n    fc[0] = fc[1] = 1;\n    for (int i=2; i<MAX; ++i) {\n        fc[i] = (fc[i-1] * i) % mod;\n    }\n    fci[1] = 1;\n    for (int i=2; i<MAX; ++i) {\n        fci[i] = (fci[i-1] * modpow(i, mod-2)) % mod;\n    }\n}\n\nlong long comb(long long n, long long k) {\n    if (k == 0 || n == k) return 1;\n    return (fc[n] * fci[k] % mod) * fci[n-k] % mod;\n}\n\nint main() {\n    init();\n\n    long long N;\n    cin >> N;\n\n    long long res = modpow(3, N);\n    \n    for (int i=N/2+1; i<=N; ++i) {\n        long long t = (comb(N, i) * modpow(2, N-i)) % mod;\n        t = (t * 2) % mod;\n        res = (res - t + mod) % mod;\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T, class F = multiplies<T>>\nT power(T a, long long n, F op = multiplies<T>(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n  friend string to_string(m a) { return to_string(a.v); }\n};\n\nconstexpr long long mod = 998244353;\nusing mint = modular<mod>;\n\nvector<mint> fact, inv_fact, minv;\nvoid prepare(int n) {\n  fact.resize(n + 1), inv_fact.resize(n + 1), minv.resize(n + 1);\n  for (int i = 0; i <= n; ++i) fact[i] = i ? i * fact[i - 1] : 1;\n  inv_fact[n] = power(fact[n], mod - 2);\n  for (int i = n; i; --i) inv_fact[i - 1] = i * inv_fact[i];\n  for (int i = 1; i <= n; ++i) minv[i] = inv_fact[i] * fact[i - 1];\n}\nmint binom(int n, int k) {\n  if (k < 0 or k > n) return 0;\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\ntemplate<> mint& mint::operator/=(mint r) {\n  return *this *= r.v < minv.size() ? minv[r.v] : power(r, mod - 2);\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  prepare(n);\n  mint res = 0, sum = 0;\n  for (int j = 0; j <= n / 2; ++j) {\n    sum += binom(n, j);\n  }\n  for (int i = 0; i <= n / 2; ++i) {\n    res += binom(n, i) * sum;\n    sum = (sum + binom(n - i - 1, n / 2)) * minv[2];\n  }\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll mpower(ll a,ll b,ll c){\n  int z;\n  if(b==0){\n    z=1;\n    z%=c;\n    return z;\n  }\n  if(b==1){\n    z=a;\n    z%=c;\n    return z;\n  }\n  else{\n    return (((mpower(a,b/2,c))*(mpower(a,b/2,c))%c)*mpower(a,b%2,c)%c);\n  }\n}\n\nconst int MAX = 10000500;\nconst int MOD = 998244353;\nll fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<MAX;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n \n// 二項係数計算\nll COM(int n,int k){\n    if(n<k) return 0;\n    if(n<0||k<0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n \nint main(){\n  COMinit();\n  ll mod=998244353;\n  ll x;\n  cin>>x;\n  ll ans=mpower(3,x,mod);\n  ll p=0,q=1;\n  ll mpow[x+1];//mpow[i]=2^x\n  mpow[0]=1;\n  for(int i=1;i<=x;i++){\n    mpow[i]=mpow[i-1]*2;\n    mpow[i]%=mod;\n  }\n  for(int i=x/2+1;i<=x;i++){\n    q=COM(x,i);\n    q*=mpow[x-i];\n    q%=mod;\n    p+=q;\n    p%=mod;\n  }\n  ans-=2*p;\n  while(ans<0){\n    ans+=mod;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=998244353;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvector<int>kaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    //if(!kaijo[0])init_fact(2000010);\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    init_fact(20000010);\n    int Comb=comb(n,n/2);\n    int ans=modpow(3,n);\n    int beki[2000002];\n    beki[0]=1;\n    for(int i=1;i<=n+1;i++){\n        beki[i]=beki[i-1]*2%mod;\n    }\n    for(int i=n/2+1;i<=n;i++){\n        ans-=comb(n,i)*beki[n-i+1]%mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 10000100\nconst int mod=998244353;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint fac[N],inv[N],n,ans,pw2[N];\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tinv[n]=qpow(fac[n],mod-2)%mod;\n\tfor(int i=n-1;i>=0;--i){\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main(){\n\tn=read();\n\tinit(n);\n\tans=qpow(3,n);\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tpw2[i]=(pw2[i-1]<<1)%mod;\n\t}\n\tfor(int i=n/2+1;i<=n;++i){\n\t\tans=(ans-2LL*C(n,i)*pw2[n-i]%mod+mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 998244353;\nconst int N = 11000000;\nconst int maxn = 10000000;\n\nint mul[N], inv[N];\n\nint Pow(int x, int y) {\n\tint ans = 1;\n\tfor (int i = 1; i <= y; i *= 2, x = 1LL * x * x % P)\n\t\tif (i & y)\n\t\t\tans = 1LL * ans * x % P;\n\treturn ans;\n}\n\nint C(int x, int y) {\n\tif (y > x)\n\t\treturn 0;\n\tif (y < 0)\n\t\treturn 0;\n\treturn 1LL * mul[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint main() {\n\tmul[0] = 1;\n\tfor (int i = 1; i <= maxn; i++) {\n\t\tmul[i] = 1LL * mul[i - 1] * i % P;\n\t}\n\tinv[maxn] = Pow(mul[maxn], P - 2);\n\tfor (int i = maxn - 1; i >= 0; i--)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % P;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint ans = 0;\n\tint ss = C(n, n / 2);\n\n\tfor (int c = 0; c <= n; c++) {\n\t\tif (c >= n / 2) {\n\t\t\tans = (ans + 1LL * C(n, c) * Pow(2, n - c)) % P;\n\t\t}else {\n\t\t\tif (c == 0)\n\t\t\t\tss = C(n, n / 2);\n\t\t\telse {\n\t\t\t\tss = (ss + C(n - c, n / 2 - c)) % P;\n\t\t\t\tss = (ss + C(n - c, n / 2)) % P;\n\t\t\t\tss = 1LL * ss * (P + 1) / 2 % P;\n\t\t\t\t// printf(\"?? %d\\n\", ss);\n\t\t\t}\n\t\t\tans = (ans + 1LL * C(n, c) * ss) % P;\n\t\t}\n\t\t// int mi = max(0, n / 2 - c);\n\t\t// int ma = min(n - c, n / 2);\n\t\t// for (int i = mi; i <= ma; i++)\n\t\t// \tans = (ans + 1LL * C(n, c) * C(n - c, i)) % P;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n#define int int64_t\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvoid calc_nCr(vector<int64_t> ncr_arr, int n, int64_t rem) {\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\n#undef int\nint main()\n{\n#define int int64_t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tvector<int64_t> ncr_arr;\n\tcalc_nCr(ncr_arr, n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = ncr_arr[k];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int MAXN = 1e7;\nconst ll MOD = 998244353;\n\nint N;\nll ans=1, fact[MAXN+10], invfact[MAXN+10], twopow[MAXN+10], A;\n\nll mypow(ll x, ll y)\n{\n    if(y==0) return 1;\n    if(y%2) return mypow(x, y-1)*x%MOD;\n    ll t=mypow(x, y/2);\n    return t*t%MOD;\n}\n\nll inv(ll x) { return mypow(x, MOD-2); }\n\nll comb(ll n, ll r) { return fact[n]*invfact[r]%MOD*invfact[n-r]%MOD; }\n\nint main()\n{\n    int i, j;\n\n    scanf(\"%lld\", &N);\n    for(i=1; i<=N; i++) ans=ans*3%MOD;\n\n    twopow[0]=1;\n    for(i=1; i<=N; i++) twopow[i]=twopow[i-1]*2%MOD;\n\n    fact[0]=1;\n    for(i=1; i<=N; i++) fact[i]=fact[i-1]*i%MOD;\n    invfact[N]=inv(fact[N]);\n    for(i=N; i>=1; i--) invfact[i-1]=invfact[i]*i%MOD;\n\n    for(i=N/2+1; i<=N; i++) A=(A+comb(N, i)*twopow[N-i]%MOD)%MOD;\n    ans-=2*A;\n    ans=(ans%MOD+MOD)%MOD;\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n \n#define X first\n#define Y second\n \n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n \n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n \nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\n//using i128 = i64;\n//using u128 = u64;\n \nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n \nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n\nll gcd(ll a, ll b)\n{\n\treturn b ? gcd(b, a%b) : a;\n}\n \ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n \ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n\ntemplate<class T>\nvoid print(const T &a)\n{\n\tfor (auto x : a) printf(\"%d \", x); puts(\"\");\n}\n\nconst int MAXN = 500010;\n//const int MAXM = 100010;\nconst int MAXK = 30;\n//const i64 INF = 1000000000000000000LL;\nconst int INF = 1000000000;\n//const int MOD = 998244353;\nconst int B = 31;\n//const int MOD = 1000000007;\n//const int INV2 = (MOD+1)/2;\nconst ld pi = 3.1415926535897932384626433;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n#define rep(i,a,b) for (int i = (a), I = (b); i <= I; ++ i)\n\nint days[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nbool leap(int y)\n{\n\treturn y%4 == 0 && y%100 != 0 || y%400 == 0;\n}\n\nconst int MOD = 998244353;\n \nstruct mod_int {\n    int val;\n \n    mod_int(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n \n        if (v >= MOD)\n            v %= MOD;\n \n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n \n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n \n        return x < 0 ? x + m : x;\n    }\n \n    explicit operator int() const {\n        return val;\n    }\n \n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n \n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n \n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n \n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n \n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n \n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n \n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n \n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n \n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n \n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n \n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n \n    mod_int inv() const {\n        return mod_inv(val);\n    }\n \n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n \n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n \n        return result;\n    }\n \n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n \nnamespace NTT {\n    vector<mod_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    mod_int root;\n \n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n \n    int round_up_power_two(int n) {\n        assert(n > 0);\n \n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n \n        return n;\n    }\n \n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n \n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<mod_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n \n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n \n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n \n    void find_root() {\n        int order = MOD - 1;\n        max_size = 1;\n \n        while (order % 2 == 0) {\n            order /= 2;\n            max_size *= 2;\n        }\n \n        root = 2;\n \n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n \n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n \n        assert(n <= max_size);\n \n        if ((int) roots.size() >= n)\n            return;\n \n        int length = get_length(roots.size());\n        roots.resize(n);\n \n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            mod_int z = root.pow(max_size >> (length + 1));\n \n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n \n            length++;\n        }\n    }\n \n    void fft_iterative(int N, vector<mod_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n \n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    mod_int even = values[start + i];\n                    mod_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n \n    const int FFT_CUTOFF = 150;\n \n    vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n        int n = left.size();\n        int m = right.size();\n \n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1);\n \n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n \n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n \n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n \n            return vector<mod_int>(result.begin(), result.end());\n        }\n \n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n \n        bool equal = left == right;\n        fft_iterative(N, left);\n \n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n \n        mod_int inv_N = mod_int(N).inv();\n \n        for (int i = 0; i < N; i++)\n            left[i] *= right[i] * inv_N;\n \n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n \n    vector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<mod_int> result = {1};\n \n        if (exponent == 0)\n            return result;\n \n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n \n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n \n        return result;\n    }\n}\n\nvector<mod_int> inv, factorial, inv_factorial;\n \nvoid prepare_factorials(int maximum) {\n    inv.assign(maximum + 1, 1);\n \n    // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n    for (int p = 2; p * p <= MOD; p++)\n        assert(MOD % p != 0);\n \n    for (int i = 2; i <= maximum; i++)\n        inv[i] = inv[MOD % i] * (MOD - MOD / i);\n \n    factorial.resize(maximum + 1);\n    inv_factorial.resize(maximum + 1);\n    factorial[0] = inv_factorial[0] = 1;\n \n    for (int i = 1; i <= maximum; i++) {\n        factorial[i] = i * factorial[i - 1];\n        inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n    }\n}\n \nmod_int choose(long long n, long long r) {\n    if (r < 0 || r > n)\n        return 0;\n \n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n \nmod_int inv_choose(long long n, long long r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n \nmod_int permute(long long n, long long k) {\n    if (k < 0 || k > n)\n        return 0;\n \n    return factorial[n] * inv_factorial[n - k];\n}\n \nmod_int inv_permute(long long n, long long k) {\n    assert(0 <= k && k <= n);\n    return inv_factorial[n] * factorial[n - k];\n}\n \n\nvoid solve()\n{\n\tint n;\n\tscanf(\"%d\", &n);prepare_factorials(n+1); \n\tint ans = 0;\n\tfor (int i = 0; i < n/2; ++ i)\n\t\tans = (ans+int(choose(n, i))*power(2, i, MOD))%MOD;\n\t//dfs(1);\n\t/* \n\tf[0][0] = 1;\n\tfor (int i = 0; i < 20; ++ i)\n\t\tfor (int j = 0; j <= i; ++ j)\n\t\t{\n\t\t\tf[i+1][j] += 7*f[i][j];\n\t\t\tf[i][j]\n\t\t}\n\t\t*/\n\t//cout << ans << endl;\n\t/*\n\tauto v = NTT::mod_power({1, 2}, n);\n\tint ans = 0;\n\t*/\n\tans = (power(3, n, MOD)-ans-ans+MOD+MOD)%MOD;\n\tcout << ans << endl;\n}\n\nint main()\n{\n\t\n\tint T;\n\tT = 1;\n\t//scanf(\"%d\", &T);\n\twhile (T --)\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\nconst int MOD = 998244353;\ntemplate <typename Int, Int MOD, int N>\nstruct comb_util {\n\tstd::array<Int, N + 1> fc, ifc;\n\n\tcomb_util() {\n\t\tfc[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) fc[i] = fc[i - 1] * i % MOD;\n\t\tifc[N] = inv(fc[N]);\n\t\tfor (int i = N - 1; i >= 0; i--) ifc[i] = ifc[i + 1] * (i + 1) % MOD;\n\t}\n\n\tInt fact(Int n) { return fc[n]; }\n\n\tInt inv_fact(Int n) { return ifc[n]; }\n\n\tInt inv(Int n) { return pow(n, MOD - 2); }\n\n\tInt pow(Int n, Int a) {\n\t\tInt res = 1, exp = n;\n\t\tfor (; a; a /= 2) {\n\t\t\tif (a & 1) res = res * exp % MOD;\n\t\t\texp = exp * exp % MOD;\n\t\t}\n\t\treturn res;\n\t}\n\n\tInt perm(Int n, Int r) {\n\t\tif (r < 0 || n < r)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn fc[n] * ifc[n - r] % MOD;\n\t}\n\n\tInt binom(Int n, Int r) {\n\t\tif (n < 0 || r < 0 || n < r) return 0;\n\t\treturn fc[n] * ifc[r] % MOD * ifc[n - r] % MOD;\n\t}\n\n\tInt homo(Int n, Int r) {\n\t\tif (n < 0 || r < 0) return 0;\n\t\treturn r == 0 ? 1 : binom(n + r - 1, r);\n\t}\n};\n\n\n#define int long long\nusing comb = comb_util<long long, 998244353, 10000010>;\ncomb C;\nvoid add(int &a, const int &b) {\n\ta += b;\n\tif (a >= MOD)a -= MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tint sum = 0;\n\tint res = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tres = (res * 3) % MOD;\n\t}\n\tint t = 0;\n\tfor (int i = (N / 2) + 1; i <= N; i++) {\n\t\tadd(t, C.binom(N, i) * C.pow(2, N - i) % MOD);\n\t}\n\tt = (t * 2) % MOD;\n\tres = (res - t + 2 * MOD) % MOD;\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fac[10000010], finv[10000010], inv[10000010]; \nlong long P = 998244353;\nlong long Pow(long long int a, long long n) {\n\tlong long tmp = a; \n\tlong long pow = n;\n\tlong long Q = 1;  \n  \twhile(pow > 0){\n\t\tif(pow & 1){\n\t\t\tQ *= tmp; Q %= P; \n\t\t}\n\t\ttmp = tmp * tmp % P; \n     \t\tpow >>= 1; \n  \t}\n\treturn Q;\n} \nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < 10000005; i++) {\n        fac[i] = fac[i - 1] * i % P;\n        inv[i] = P - inv[P % i] * (P / i) % P;\n        finv[i] = finv[i - 1] * inv[i] % P;\n    }\n}\nlong long COM(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % P) % P;\n}\nint main(){\n\tint N; cin >> N; \n\tCOMinit(); \n\tlong long pow[5000010] = {}; \n\tpow[0] = 1; \n\tfor(int i = 1; i <= N/2; i++){\n\t\tpow[i] = pow[i-1] * 2 % P; \n\t}\n\tlong long ans = Pow(3, N); \n\tfor(int i = 0; i < N/2; i++){\n\t\tlong long tmp = 2 * COM(N, i) * pow[i] % P; \n\t\tans += P - tmp; \n\t\tif(ans >= P) ans -= P; \n\t}\n\tcout << ans << endl;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1e7 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\nint Fac[N];\nint Inv[N];\nint Pow[N];\n\nint Ckn(int n,int k)    {\n    if (n < k)  return  0;\n    if (k < 0)  return  0;\n\n    return  mul(Fac[n],mul(Inv[k],Inv[n - k]));\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    Fac[0] = Inv[0] = 1;\n\n    for(int i = 1 ; i < N ; ++i)    Fac[i] = mul(Fac[i - 1],i);     Inv[N - 1] = inv(Fac[N - 1],mod);\n    for(int i = N - 2 ; i ; --i)    Inv[i] = mul(Inv[i + 1],i + 1);\n\n    int n;  cin >> n;\n\n    int ans = Pow[0] = 1;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ans = mul(ans,3);\n        Pow[i] = mul(Pow[i - 1],2);\n    }\n\n    for(int i = n / 2 + 1 ; i <= n ; ++i)\n        sub(ans,mul(Ckn(n,i),Pow[n - i + 1]));\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<stdio.h>\n#include<bitset>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<deque>\nusing namespace std;\n#define int long long\n#define rep(s,i,n) for(int i=s;i<n;i++)\n#define c(n) cout<<n<<endl;\n#define ic(n) int n;cin>>n;\n#define sc(s) string s;cin>>s;\n#define mod 998244353\n#define inf 1000000000000000007\n#define f first\n#define s second\n#define mini(c,a,b) *min_element(c+a,c+b)\n#define maxi(c,a,b) *max_element(c+a,c+b)\n#define pi 3.141592653589793238462643383279\n#define e_ 2.718281828459045235360287471352\n#define P pair<int,int>\n#define upp(a,n,x) upper_bound(a,a+n,x)-a;\n#define low(a,n,x) lower_bound(a,a+n,x)-a;\n#define UF UnionFind \n#define pb push_back\n//printf(\"%.12Lf\\n\",);\nint keta(int x) {\n\trep(0, i, 30) {\n\t\tif (x < 10) {\n\t\t\treturn i + 1;\n\t\t}\n\t\tx = x / 10;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x == 0 || y == 0)return x + y;\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn bb;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn aa;\n\t\t}\n\t}\n}\nint lcm(int x, int y) {\n\tint aa = x, bb = y;\n\trep(0, i, 1000) {\n\t\taa = aa % bb;\n\t\tif (aa == 0) {\n\t\t\treturn x / bb * y;\n\t\t}\n\t\tbb = bb % aa;\n\t\tif (bb == 0) {\n\t\t\treturn x / aa * y;\n\t\t}\n\t}\n}\nbool prime(int x) {\n\tif (x == 1)return false;\n\trep(2, i, sqrt(x) + 1) {\n\t\tif (x % i == 0 && x != i) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint max(int a, int b) {\n\tif (a >= b)return a;\n\telse return b;\n}\nstring maxst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n > m)return s;\n\telse if (n < m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] > t[i])return s;\n\t\t\tif (s[i] < t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring minst(string s, string t) {\n\tint n = s.size();\n\tint m = t.size();\n\tif (n < m)return s;\n\telse if (n > m)return t;\n\telse {\n\t\trep(0, i, n) {\n\t\t\tif (s[i] < t[i])return s;\n\t\t\tif (s[i] > t[i])return t;\n\t\t}\n\t\treturn s;\n\t}\n}\nstring string_reverse(string s){\n\tint n=s.size();\n\tstring t;\n\trep(0,i,n)t+=s[n-i-1];\n\treturn t;\n}\t\nint min(int a, int b) {\n\tif (a >= b)return b;\n\telse return a;\n}\nint n2[41];\nint nis[41];\nint nia[41];\nint mody[41];\nint nn;\nint com(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint bunsi = 1, bunbo = 1;\n\trep(0, i, y)bunsi = (bunsi * (n - i)) % mod;\n\trep(0, i, y)bunbo = (bunbo * (i + 1)) % mod;\n\tmody[0] = bunbo;\n\trep(1, i, 41) {\n\t\tbunbo = (bunbo * bunbo) % mod;\n\t\tmody[i] = bunbo;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tbunsi = (bunsi * mody[i]) % mod;\n\t\t}\n\t}\n\treturn bunsi;\n}\nint gyakugen(int n, int y) {\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tmody[0] = y;\n\trep(1, i, 41) {\n\t\ty = (y * y) % mod;\n\t\tmody[i] = y;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = mod - 2;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn > n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\tnis[0]++;\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\tn = (n * mody[i]) % mod;\n\t\t}\n\t}\n\treturn n;\n}\nint yakuwa(int n) {\n\tint sum = 0;\n\trep(1, i, sqrt(n + 1)) {\n\t\tif (n % i == 0)sum += i + n / i;\n\t\tif (i * i == n)sum -= i;\n\t}\n\treturn sum;\n}\nint poow(int y, int n) {\n\tif (n == 0)return 1;\n\tn -= 1;\n\tint ni = 1;\n\tfor (int i = 0;i < 41;i++) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\tint yy = y;\n\tmody[0] = yy;\n\trep(1, i, 41) {\n\t\tyy = (yy * yy) % mod;\n\t\tmody[i] = yy;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tnn = n;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (nn >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tnn -= n2[i];\n\t\t}\n\t}\n\trep(0, i, 41) {\n\t\tif (nis[i] == 1) {\n\t\t\ty = (y * mody[i]) % mod;\n\t\t}\n\t}\n\treturn y;\n}\nint minpow(int x, int y) {\n\tint sum = 1;\n\trep(0, i, y)sum *= x;\n\treturn sum;\n}\nint ketawa(int x, int sinsuu) {\n\tint sum = 0;\n\trep(0, i, 80){\n\t\tif(minpow(sinsuu,i)>x){\n          return sum;\n        } \n\t\tsum += (x % minpow(sinsuu, i + 1)) / (minpow(sinsuu, i));\n\t}\t\n\treturn sum;\n}\ndouble distance(double a,double b,double c,double d){\n\treturn sqrt((b-a)*(b-a)+(c-d)*(c-d));\n}\t\nint sankaku(int a) {\n\treturn a * (a + 1) / 2;\n}\nint sames(int a[1111111], int n) {\n\tint ans = 0;\n\trep(0, i, n) {\n\t\tif (a[i] == a[i + 1]) {\n\t\t\tint j = i;\n\t\t\twhile (a[j + 1] == a[i] && j <= n - 2)j++;\n\t\t\tans += sankaku(j - i);\n\t\t\ti = j;\n\t\t}\n\t}\n\treturn ans;\n}\nusing Graph = vector<vector<int>>;\nint oya[114514];\nint depth[114514];\nvoid dfs(const Graph& G, int v, int p, int d) {\n\tdepth[v] = d;\n\toya[v] = p;\n\tfor (auto nv : G[v]) {\n\t\tif (nv == p) continue; // nv が親 p だったらダメ\n\t\tdfs(G, nv, v, d + 1); // d を 1 増やして子ノードへ\n\t}\n}\n/*int H=10,W=10;\nchar field[10][10];\nchar memo[10][10];\nvoid dfs(int h, int w) {\n\tmemo[h][w] = 'x';\n\n\t// 八方向を探索\n\tfor (int dh = -1; dh <= 1; ++dh) {\n\t\tfor (int dw = -1; dw <= 1; ++dw) {\n\t\t\tif(abs(0-dh)+abs(0-dw)==2)continue;\n\t\t\tint nh = h + dh, nw = w + dw;\n\n\t\t\t// 場外アウトしたり、0 だったりはスルー\n\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\tif (memo[nh][nw] == 'x') continue;\n\n\t\t\t// 再帰的に探索\n\t\t\tdfs(nh, nw);\n\t\t}\n\t}\n}*/\nint XOR(int a, int b) {\n\tif (a == 0 || b == 0) {\n\t\treturn a + b;\n\t}\n\tint ni = 1;\n\trep(0, i, 41) {\n\t\tn2[i] = ni;\n\t\tni *= 2;\n\t}\n\trep(0, i, 41)nis[i] = 0;\n\tfor (int i = 40;i >= 0;i -= 1) {\n\t\tif (a >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\ta -= n2[i];\n\t\t}\n\t\tif (b >= n2[i]) {\n\t\t\tnis[i]++;\n\t\t\tb -= n2[i];\n\t\t}\n\t}\n\tint sum = 0;\n\trep(0, i, 41)sum += (nis[i] % 2 * n2[i]);\n\treturn sum;\n}\n//int ma[1024577][21];\n//for(int bit=0;bit<(1<<n);bit++)rep(0,i,n)if(bit&(1<<i))ma[bit][i]=1;\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n \n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n \n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n \n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n \n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\nint kat[5514514];\nint dp[5514514][4];\nint ans[5514514];\nsigned main(){\n\tic(n)\n\tkat[0]=0;\n\tkat[1]=1;\n\trep(2,i,n/2){\n\t\tkat[i]=(gyakugen(kat[i-1],(i*(i+1))%mod)*(((i*2)*(i*2-1))%mod))%mod;\n\t}\n\tdp[0][0]=1;\n\tdp[0][1]=0;\n\tdp[0][2]=1;\n\tdp[0][3]=1;\n\tans[0]=7;\n\tint t=1;\n\trep(1,i,n/2){\n\t\tdp[i][0]=ans[i-1];\n\t\tdp[i][1]=(ans[i-1]-((t*kat[i])%mod*(i+2))%mod+mod)%mod;\n\t\tdp[i][2]=(ans[i-1]+((t*kat[i])%mod)*i%mod)%mod;\n\t\tdp[i][3]=(ans[i-1]+((t*kat[i]%mod)*i*2)%mod)%mod;\n\t\tans[i]=(dp[i][0]*2+dp[i][1]*2+dp[i][2]*4+dp[i][3])%mod;\n\t\tt=(t*2)%mod;\n\t}\n\tc(ans[n/2-1])\n}\t"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i=(a); i<(int)(b); i++)\n#define pb push_back\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\n \nconst int maxN = 1 << 24, mod = 998244353;\n\nlong long fact[maxN], tcaf[maxN];\n\ninline void addMod(long long& a, long long b)\t{   a = (a + b) % mod;  }\ninline void multMod(long long& a, long long b)\t{   a = a * b % mod;    }\n\nlong long qpow(long long a, long long b)\n{\n    long long res0 = 1;\n    for (; b!=0; b>>=1)\n    {\n        if (b & 1)  multMod(res0, a);\n        multMod(a, a);\n    }\n    return res0;\n}\n\nlong long cf(int n, int k)\n{\n\tbool static initd = false;\n\tif (!initd)\n\t{\n\t\tfact[0] = 1;\n\t\tFOR(i, 1, maxN)\n\t\t\tfact[i] = fact[i - 1] * i % mod;\n\t\ttcaf[maxN - 1] = qpow(fact[maxN - 1], mod - 2);\n\t\tfor (int i=maxN-1; i>0; i--)\n\t\t\ttcaf[i - 1] = tcaf[i] * i % mod;\n\t\tinitd = true;\n\t}\n\tif (k < 0 or k > n)\n\t\treturn 0;\n\tlong long res0 = fact[n];\n\tmultMod(res0, tcaf[k]);\n\tmultMod(res0, tcaf[n-k]);\n\treturn res0;\n}\n\nvoid solve()\n{\n\tint n;\n\tscanf (\"%d\", &n);\n\tcf(0, 0);\n\tlong long res = 0, p2 = 1;\n\tFOR(i, 0, n/2)\n\t{\n\t\taddMod(res, cf(n, i) * p2);\n\t\tmultMod(p2, 2);\n\t}\n\t\n\tmultMod(res, 2);\n\tmultMod(res, mod-1);\n\taddMod(res, qpow(3, n));\n\t\t\n\tprintf(\"%lld\\n\", res);\n}\n \nint main()\n{\n\tint t;\n\tt = 1;//scanf (\"%d\", &t);\n\twhile (t--)\n\t\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1e7 + 10, mod = 998244353;\nint fact[N], invfact[N];\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (((ll) x) * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\nint p2[N];\nvoid pre(){\n\tfact[0] = invfact[0] = p2[0] = 1;\n\tfor(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]), p2[i] = add(p2[i - 1], p2[i - 1]);\n\tinvfact[N - 1] = inv(fact[N - 1]);\n\tfor(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);\n\tassert(invfact[1] == 1);\n}\n\ninline int C(int n, int k){\n\tif(n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint f(int n){\n\tint ret = powr(3, n);\n\tfor(int i = n / 2 + 1; i <= n; i++){\n\t\t// trace(p2[n - i + 1], C(n, i), i);\n\t\tret = sub(ret, mul(p2[n - i + 1], C(n, i)));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tpre();\n\tint n; sd(n); printf(\"%d\\n\", f(n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nstruct modint {\n    static constexpr int MOD = 998244353;\n    ll v;\n\n    bool operator==(const modint& other) const {\n        return v == other.v;\n    }\n\n    modint& operator+=(const modint& other) {\n        v += other.v;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        v -= other.v;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        v = v * other.v % MOD;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n        *this *= other.inv();\n        return *this;\n    }\n\n    modint operator+(const modint& other) const {\n        return modint { v } += other;\n    }\n\n    modint operator-(const modint& other) const {\n        return modint { v } -= other;\n    }\n\n    modint operator*(const modint& other) const {\n        return modint { v } *= other;\n    }\n\n    modint operator/(const modint& other) const {\n        return modint { v } /= other;\n    }\n\n    static modint pow(modint b, ll e) {\n        modint res { 1 };\n        for (ll p = 1; p <= e; p <<= 1) {\n            if (p & e)\n                res *= b;\n            b *= b;\n        }\n\n        return res;\n    }\n\n    modint pow(ll e) const {\n        return pow(*this, e);\n    }\n\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n\n    friend ostream& operator<<(ostream& os, modint m) {\n        return os << m.v;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n\n    modint ans = modint::pow(modint { 3 }, n);\n    modint cur = { 0 };\n    modint term = { 1 };\n    modint p = { 2 };\n    // n choose k * 2^k for k in range()\n    for (int k = n; k > n / 2; --k) {\n        cur += term * p;\n        // going from n!/k!(n-k)! to n!/(k-1)!(n-k+1)!\n        // multiply by k/(n-k+1)\n        term /= modint { n - k + 1 };\n        term *= modint { k };\n        p += p;\n    }\n\n    cout << ans - cur << '\\n';\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define Rep(i,a,b) for (int i=a;i<b;i++)\n#define maxn 10000005\nint n;\n#define mod 998244353\nvoid add(int&x,int y){\n\tx=(x+y)%mod;\n}\nint pw2[maxn],fac[maxn],inv[maxn];\nint power(int a,int b,int p){\n\tint s=1,w=a;while (b){\n\t\tif (b&1)s=1ll*s*w%p;\n\t\tw=1ll*w*w%p;b>>=1;\n\t}\n\treturn s;\n}\nint C(int a,int b){\n\treturn 1ll*fac[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main(){\n\tscanf(\"%d\",&n);int res=0;\n\tpw2[0]=1;rep(i,1,n)pw2[i]=2*pw2[i-1]%mod;\n\tfac[0]=1;rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=power(fac[n],mod-2,mod);\n\tper(i,n,1)inv[i-1]=1ll*inv[i]*i%mod;\n\trep(i,n/2+1,n)\n\t\tadd(res,2ll*C(n,i)*pw2[n-i]%mod);\n\tres = (power(3,n,mod-2)-res+mod)%mod;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/range/adaptor/reversed.hpp>\n\nusing namespace std;\ntypedef long long int ll;\n\n#define PI (acos(-1))\n#define REP(i,n) for(ll (i)=0;(i)<(n);(i)++)\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define dumparr(x) cerr << #x ; for(auto elem: x){cerr << \" \" << elem;} cerr << endl;\n#define dumppairs(x) cerr << #x ; for(auto elem: x){cerr << \"(\" << elem.first << \" \" << elem.second << \") \";} cerr << endl;\n#define dumpline cerr << \"**********************\" << endl;\n#define dumpwline(x) cerr << \"******** \" << #x << \"=\" << (x) << \" ********\" << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define ARRAY_LENGTH(array) (sizeof(array) / sizeof(array[0]))\n\nint d = 998244353;\n\nvector <long> gyakus(5e6+10, 0);\nint gyaku(long num){\n    int e = d - 2;\n    long ret = 1;\n    long keta = num;\n    while (e > 0){\n        if (e%2 == 1){\n            ret = keta*ret % d;\n        }\n        e /= 2;\n        keta = keta*keta % d;\n    }\n    return ret;\n}\n\nint main(void){\n    int n; cin >> n;\n\n    REP(i, n/2 + 10){\n        gyakus[i+1] = gyaku(i+1);\n    }\n    long ans = 1;\n    long keta = 3;\n    int m = n;\n    while (m > 0){\n        if (m%2 == 1){\n            ans = keta*ans % d;\n        }\n        m /= 2;\n        keta = keta*keta % d;\n    }\n    ll nozoku = 0;\n    ll comb = 1;\n    ll two = 1;\n    REP(i, n/2){\n        nozoku += comb * two;\n        nozoku %= d;\n\n        two *= 2;\n        two %= d;\n\n        comb *= n-i;\n        comb %= d;\n        comb *= gyakus[i+1];\n        comb %= d;\n    }\n    ans = ans + d * 2 - nozoku * 2;\n    cout << ans % d << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e7+5,Mod=998244353;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n,Fac[MAXN],iFac[MAXN],Fpow[MAXN];\ninline int Fp(int x,int k){int ans=1;for(;k;k>>=1,x=1ll*x*x%Mod)if(k&1)ans=1ll*ans*x%Mod;return ans;}\ninline int C(int n,int m){return n<0||m<0||n<m?0:1ll*Fac[n]*iFac[m]%Mod*iFac[n-m]%Mod;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();\n\tFac[0]=Fpow[0]=1;Rep(i,1,n)Fac[i]=1ll*Fac[i-1]*i%Mod,Fpow[i]=(Fpow[i-1]<<1)%Mod;\n\tiFac[n]=Fp(Fac[n],Mod-2);Red(i,n,1)iFac[i-1]=1ll*iFac[i]*i%Mod;\n\tint ans=0;Rep(i,n/2+1,n)ans=(ans+1ll*C(n,i)*Fpow[n-i])%Mod;ans=ans*2%Mod;\n\tans=(Fp(3,n)-ans+Mod)%Mod,cout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=998244353;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\tvector<modint> a(n / 2 + 1);\n\ta[0] = 1;\n\tfor(int i = 1;i <= n / 2;i++){\n\t\ta[i] = a[i - 1] / modint(i);\n\t}\n\tArbitraryModConvolution<modint> fft;\n\tvector<modint> c = fft.multiply(a,a);\n\tmodint tmp = 1,ans = 0,nfact;\n\tfor(int i = 1;i <= n;i++) tmp = tmp / modint(i);\n\tnfact = modint(1) / modint(tmp);\n\tfor(int i = 0;i <= n;i++){\n\t\tans += c[i] * tmp;\n\t\tif(i != n) tmp *= (n - i);\n\t}\n\tcout << ans * nfact << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n#define MAX 10000006\nusing namespace std;\nlong long factorial[MAX] = {0}, finverse[MAX] = {0},\n          inverse[MAX] = {0};\n\nvoid smodfact() {\n  factorial[0] = factorial[1] = 1;\n  finverse[0] = finverse[1] = 1;\n  inverse[1] = 1;\n  for(int i = 2; i < MAX; ++i) {\n    factorial[i] = factorial[i - 1] * i % MOD;\n    inverse[i] = MOD - (inverse[MOD % i] * (MOD / i)) % MOD;\n    finverse[i] = finverse[i - 1] * inverse[i] % MOD;\n  }\n}\n\nlong long calccomb(long long n, long long k) {\n  if(n == k && n == 0) return 1;\n  if(n < 0 || k < 0 || n < k) return 0;\n  return factorial[n] * finverse[k] % MOD *\n         finverse[n - k] % MOD;\n}\n\nlong long cpow(long long base, long long x) {\n  long long ans = 1;\n  while(x) {\n    if(x & 1) (ans *= base) %= MOD;\n    (base *= base) %= MOD;\n    x >>= 1;\n  }\n  return ans;\n}\n\nlong long n;\n\nlong long solve();\n\nint main() {\n  smodfact();\n  cin >> n;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = cpow(3, n);\n  for(int i = n / 2 + 1; i <= n; ++i) {\n    long long now = calccomb(n, i) * 2 % MOD;\n    (now *= cpow(2, n - i)) %= MOD;\n    ans -= now;\n    (ans += MOD) %= MOD;\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "//daca nr de A pe poz impare + nr de B poz pare>n/2 nu se poate, altfel se poate\n// la fel B,A\n#include<iostream>\n#define MOD 998244353\n\nusing namespace std;\n\nint Fact[10000005],Inv[10000005],P2[10000005];\n\nint put(int a, int b)\n{\n    int rez=1;\n    for(int i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint comb(int n, int k)\n{\n    return (1LL*((1LL*Fact[n]*Inv[k])%MOD)*Inv[n-k])%MOD;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n    int n;\n    cin>>n;\n    int rez=put(3,n);\n\n    Fact[0]=1;\n    for(int i=1; i<=n; i++)\n        Fact[i]=(1LL*Fact[i-1]*i)%MOD;\n\n    Inv[n]=put(Fact[n],MOD-2);\n    for(int i=n-1; i>=0; i--)\n        Inv[i]=(1LL*Inv[i+1]*(i+1))%MOD;\n\n    P2[0]=1;\n    for(int i=1; i<=n/2; i++)\n        P2[i]=(2LL*P2[i-1])%MOD;\n\n    for(int i=n/2+1; i<=n; i++)\n    {\n        int act=0;\n        act=(act+(2LL*comb(n,i)*P2[n-i]%MOD))%MOD;\n        rez=(rez-act+MOD)%MOD;\n    }\n\n    cout<<rez<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////////////////\n//                          Give me AC!!!                                     //\n////////////////////////////////////////////////////////////////////////////////\n#include <iostream>\n#include <random>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <bits/stdc++.h>\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace std;\nnamespace mp = boost::multiprecision;\nusing namespace mp;\nusing ull = __int128;\nusing ll = long long;\nusing cll = cpp_int;\nusing Graph = vector<vector<int>>; \n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define REPD(i,n) for(ll i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)\n#define FORD(i,a,b) for(ll i=a;i>=(ll)(b);i--)\n//xにはvectorなどのコンテナ\n#define ALL(x) (x).begin(),(x).end() //sortなどの引数を省略したい\n#define SIZE(x) ((ll)(x).size()) //sizeをsize_tからllに直しておく\n#define MAX(x) *max_element(ALL(x)) //最大値を求める\n#define MIN(x) *min_element(ALL(x)) //最小値を求める\n#define PQ priority_queue<vector<ll>,vector<vector<ll>>,greater<vector<ll>>>\n#define INF 1000000000000 //10^12:極めて大きい値,∞\n#define PB push_back //vectorヘの挿入\n#define MP make_pair //pairのコンストラクタ\n#define F first //pairの一つ目の要素\n#define S second //pairの二つ目の要素\n#define coutY cout<<\"YES\"<<endl\n#define couty cout<<\"Yes\"<<endl\n#define coutN cout<<\"NO\"<<endl\n#define coutn cout<<\"No\"<<endl\n#define coutdouble(a,b) cout << fixed << setprecision(a) << double(b) ;\n#define vi(a,b) vector<int> a(b)\n#define vl(a,b) vector<ll> a(b)\n#define vs(a,b) vector<string> a(b)\n#define vll(a,b,c)  vector<vector<ll>> a(b, vector<ll>(c));\n#define intque(a) queue<int> a;\n#define llque(a) queue<ll> a;\n#define intque2(a) priority_queue<int, vector<int>, greater<int>> a;\n#define llque2(a) priority_queue<ll, vector<ll>, greater<ll>> a;\n#define pushback(a,b) a.push_back(b)\n#define mapii(M1) map<int, int> M1;\n#define cou(v,x) count(v.begin(), v.end(), x)\n#define mapll(M1) map<ll,ll> M1;\n#define mapls(M1) map<ll, string> M1;\n#define mapsl(M1) map<string, ll> M1;\n#define twolook(a,l,r,x) lower_bound(a+l, a+r, x) - a\n#define sor(a) sort(a.begin(), a.end())\n#define rever(a) reverse(a.begin(),a.end())\n#define rep(i,a) for(ll i=0;i<a;i++)\n#define vcin(n) for(ll i=0;i<ll(n.size());i++) cin>>n[i]\n#define vcout(n) for(ll i=0;i<ll(n.size());i++) cout<<n[i]\n#define vcin2(n) rep(i,ll(n.size())) rep(j,ll(n.at(0).size())) cin>>n[i][j]\n//const ll mod = 998244353;\n//const ll MOD = 998244353;\nconst ll MOD = 998244353;\nconst ll mod = 998244353;\nconstexpr ll MAX = 10000010;\n//const ll _max = 9223372036854775807;\nconst ll _max = 1223372036854775807;\n  \nll fac[MAX],finv[MAX],inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\nint modPow(long long a, long long n, long long p) {\n  if (n == 0) return 1; // 0乗にも対応する場合\n  if (n == 1) return a % p;\n  if (n % 2 == 1) return (a * modPow(a, n - 1, p)) % p;\n  long long t = modPow(a, n / 2, p);\n  return (t * t) % p;\n}\n\nll clocks(ll a,ll b,ll c){\n  return a*3600+b*60+c;\n}\nll divup(ll b,ll d){\n   if(b%d==0){\n    return b/d;\n  }\n  else{\n    return b/d+1;\n  }\n}\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n    UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n};\n\nstruct Edge {\n    int to;     // 辺の行き先\n    int weight; // 辺の重み\n    Edge(int t, int w) : to(t), weight(w) { }\n};\n\nusing Graphw = vector<vector<Edge>>;\nll zero(ll a){\n  return max(ll(0),a);\n}\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\n//aはbの何乗以下かを満たす数の内最大の物,(a,10)はaの桁数\nll expless(ll a,ll b){\n  ll k=0;\n  ll o=1;\n  while(a>=o){\n    k++;\n    o=o*b;\n  }\n  return k;\n}\n//aをb進法で表す\n\n//b進法のaを10進法に直す\nll tenbase(ll a,ll b){\n  ll c=expless(a,10);\n  ll ans=0;\n  ll k=1;\n  for(int i=0;i<c;i++){\n    ans+=(a%10)*k;\n    k=k*b;\n    a=a/10;\n  }\n  return ans;\n}\nvector<pair<long long, long long> > prime_factorize(long long N) {\n    vector<pair<long long, long long> > res;\n    for (long long a = 2; a * a <= N; ++a) {\n        if (N % a != 0) continue;\n        long long ex = 0; // 指数\n\n        // 割れる限り割り続ける\n        while (N % a == 0) {\n            ++ex;\n            N /= a;\n        }\n\n        // その結果を push\n        res.push_back({a, ex});\n    }\n\n    // 最後に残った数について\n    if (N != 1) res.push_back({N, 1});\n    return res;\n}\nll atll(ll a,ll b){\n  b++;\n  ll c=expless(a,10);\n  ll d=c-b;\n  ll f=1;\n  for(int i=0;i<d;i++){\n    f=f*10;\n  }\n  a=(a/f);\n  return a%10;\n}\n//aがbで何回割り切るか\nll exp(ll a,ll b){\n  ll ans=0;\n  while(a%b==0){\n    a=a/b;\n    ans++;\n  }\n  return ans;\n}\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int X[6]={1,1,0,-1,-1,0};\nconst int Y[6]={0,1,1,0,-1,-1};\n\ntemplate<typename T>\nvector<T> smallest_prime_factors(T n) {\n\n    vector<T> spf(n + 1);\n    for (int i = 0; i <= n; i++) spf[i] = i;\n\n\n    for (T i = 2; i * i <= n; i++) {\n\n        // 素数だったら\n        if (spf[i] == i) {\n\n            for (T j = i * i; j <= n; j += i) {\n\n                // iを持つ整数かつまだ素数が決まっていないなら\n                if (spf[j] == j) {\n                    spf[j] = i;\n                }\n            }\n        }\n    }\n\n    return spf;\n}\n\nvector<pair<ll,ll>> factolization(ll x, vector<ll> &spf) {\n  vector<pair<ll,ll>> ret;\n  ll p;\n  ll z;\n    while (x != 1) {\n     p=(spf[x]);\n      z=0;\n      while(x%p==0){\n        z++;\n        x /= p;\n      }\n      ret.push_back({p, z});\n    }\n    return ret;\n}\nvector<bool> is;\nvector<long long int> prime_(ll n){\n    is.resize(n+1, true);\n    is[0] = false; \n    is[1] = false;\n \n    vector<long long int> primes;\n    for (int i=2; i<=n; i++) {\n        if (is[i] == true){\n            primes.push_back(i);\n            for (int j=i*2; j<=n; j+=i){\n                is[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n vector<ll> dijkstra(ll f,ll n,vector<vector<vector<ll>>>& edge){\n    //最短経路としてどの頂点が確定済みかをチェックする配列\n    vector<ll> confirm(n,false);\n    //それぞれの頂点への最短距離を保存する配列\n    //始点は0,始点以外はINFで最短距離を初期化する\n    vector<ll> mincost(n,INF);mincost[f]=0;\n    //確定済みの頂点の集合から伸びる辺を伝ってたどり着く頂点の始点からの距離を短い順に保存するPriority queue\n    PQ mincand;mincand.push({mincost[f],f});\n\n    //mincandの要素がゼロの時、最短距離を更新できる頂点がないことを示す\n    while(!mincand.empty()){\n        //最短距離でたどり着くと思われる頂点を取り出す\n        vector<ll> next=mincand.top();mincand.pop();\n        //すでにその頂点への最短距離が確定済みの場合は飛ばす\n        if(confirm[next[1]]) continue;\n        //確定済みではない場合は確定済みにする\n        confirm[next[1]]=true;\n        //その確定済みの頂点から伸びる辺の情報をとってくる(参照の方が速い)、lは辺の本数\n        vector<vector<ll>>& v=edge[next[1]];ll l=SIZE(v);\n        REP(i,l){\n            //辺の先が確定済みなら更新する必要がない((✳︎2)があれば十分なので(✳︎1)は実はいらない)\n            if(confirm[v[i][0]]) continue; //(✳︎1)\n            //辺の先のmincost以上の場合は更新する必要がない(辺の先が確定済みの時は満たす)\n            if(mincost[v[i][0]]<=next[0]+v[i][1]) continue; //(✳︎2)\n            //更新\n            mincost[v[i][0]]=next[0]+v[i][1];\n            //更新した場合はその頂点が(確定済みでない頂点の中で)最短距離になる可能性があるのでmincandに挿入\n            mincand.push({mincost[v[i][0]],v[i][0]});\n        }\n    }\n    return mincost;\n}\nll so(ll a){\n  ll ans=0;\n  if(a==0){\n    return 0;\n  }\n   while(a%2==0){\n    a/=2;\n    ans++;\n  }\n  return ans;\n}\nll HOM(ll n,ll r){\n  return COM(n+r-1,r);\n}\nll binary(ll bina){\n    ll ans = 0;\n    for (ll i = 0; bina>0 ; i++)\n    {\n        ans = ans+(bina%2)*pow(10,i);\n        bina = bina/2;\n    }\n    return ans;\n}\nint main(){\nios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    cout << fixed << setprecision(10);\nCOMinit();\n  ll n;\n  cin>>n;\n  ll tmp=0;\n  ll ans=modPow(3,n,mod);\n  for(ll i=(n/2)+1;i<=n;i++){\n    tmp=COM(n,i)*modPow(2,n-i,mod);\n    tmp%=mod;\n    tmp*=2;\n    tmp%=mod;\n    ans-=tmp;\n    ans%=mod;\n    while(ans<0){\n      ans+=mod;\n    }\n  }\n  ans%=mod;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e7 + 7;\nconst int MX = 998244353;\nconst LL INF = 1LL * MX * MX;\n\nint n;\nint rv[N];\nint sil[N];\n\nint fast(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\tret = (1LL * ret * a) % MX;\n\t\t\n\t\tb >>= 1;\n\t\ta = (1LL * a * a) % MX;\n\t}\n\t\n\treturn ret;\n}\n\ninline int newton(int a, int b){\n\treturn (((1LL * sil[a] * rv[b]) % MX) * rv[a - b]) % MX;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tsil[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tsil[i] = 1LL * i * sil[i - 1] % MX;\n\t\n\trv[n] = fast(sil[n], MX - 2);\n\tfor(int i = n; i >= 1; --i)\n\t\trv[i - 1] = 1LL * i * rv[i] % MX;\n\t\n\tint cur = 1, ans = 0;\n\tfor(int i = n; i + i > n; --i){\n\t\tans = (ans + 1LL * cur * newton(n, i)) % MX;\n\t\tcur = (cur + cur) % MX;\n\t}\n\n\tans = (ans + ans) % MX;\n\tans = (fast(3, n) + MX - ans) % MX;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=998244353;\ninline int dec(int x){return x<0?x+mod:x;}\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\nint fac[10000010],inv[10000010];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tfac[0]=1;\n\tint n=read(),ans=power(3,n);\n\tfor(int i=1;i<=n;i++)fac[i]=1LL*fac[i-1]*i%mod;inv[n]=power(fac[n],mod-2);\n\tfor(int i=n;i>=1;i--)inv[i-1]=1LL*inv[i]*i%mod;\n\tfor(int i=n/2+1;i<=n;i++)ans=dec(ans-2LL*inv[i]*power(2,n-i)%mod*inv[n-i]%mod*fac[n]%mod);\n\tpr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\t\n#define WHATS(var)cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\nint xx;\n\nusing ll =long long ;\n\n\n\nconst int mod =998244353;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 10240000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tint N;cin>>N;\n\tMod sum=mod_pow(3,N);\n\tMod kk=0;\n\tMod xx=1;\n\tMod x=1;\n\tfor(int i=0;i<=N/2-1;++i){\n\n\t\tkk+=xx*x;\n\t\tx*=Mod(2);\n\t\txx*=N-i;\n\t\txx/=(i+1);\n\t\t//WHATS(kk)\n\t}\n\t//WHATS(kk)\n\tsum=sum-kk*Mod(2);\n\tcout<<sum<<endl;\n\treturn 0;\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef long long ll;\n\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int MAX_N = 10000005;\n\nll pot(ll a, ll b) {\n    ll w = 1;\n\n    while(b > 0) {\n        if(b & 1) {\n            w = (w * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b /= 2;\n    }\n\n    return w;\n}\n\nll sil[MAX_N], odw[MAX_N];\n\nll newton(int n, int k) {\n    ll w = (sil[n] * odw[n - k]) % MOD;\n    w = (w * odw[k]) % MOD;\n    return w;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    sil[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        sil[i] = (sil[i - 1] * ll(i)) % MOD;\n    }\n\n//     for(int i = 0; i <= n; i++) cout << sil[i] << \" \";\n//     cout << endl << \" ---------- \\n\";\n    \n    odw[n] = pot(sil[n], MOD - 2);\n    for(int i = n - 1; i >= 0; i--) {\n        odw[i] = (odw[i + 1] * ll(i + 1)) % MOD;\n    }\n    \n//     for(int i = 0; i <= n; i++) cout << odw[i] << \" \";\n//     cout << endl << \" ---------- \\n\";\n    \n    ll w = pot(3, n);\n    \n    for(int k = 1 + n / 2; k <= n; k++) {\n        w = (w - 2LL * newton(n, k) * pot(2, n - k) + MOD * MOD) % MOD;\n    }\n    \n    cout << w;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 998244353;\n\nll F[10101010], FI[10101010];\nll n, ans;\n\nll inv(ll x) { return x > 1? mod / x * (mod - inv(mod % x)) % mod : 1; }\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tll i, t;\n\t\n\tcin >> n;\n\t\n\tfor(i = 1, F[0] = 1; i <= n; i ++){\n\t\tF[i] = F[i - 1] * i % mod;\n    }\n\t\n\tFI[n] = inv(F[n]);\n\t\n\tfor(i = n, ans = 1; i; i --){\n\t\tF[i - 1] = F[i] * i % mod;\n\t\tans = ans * 3 % mod;\n    }\n\t\n\tfor(i = n, t = 2 * F[n] % mod; i + i > n; i --){\n\t\tans = ans - t * FI[n - i] % mod * FI[i] % mod;\n    }\n\t\n\tcout << ans << \"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n#define int int64_t\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvoid calc_nCr(vector<int64_t> ncr_arr, int n, int64_t rem) {\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\n#undef int\nint main()\n{\n#define int int64_t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tvector<int64_t> ncr_arr;\n\tcalc_nCr(ncr_arr, n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = ncr_arr[k];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=998244353;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint mod_inv(int X){\n\tint a = X, b = MOD, u = 1, v = 0;\n\twhile(b) {\n\t\tint t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tif(u < 0) u += MOD;\n\treturn u;\n}\n\ntemplate<int mod>\nstruct NTT {\n\n\tvector< int > rev, rts;\n\tint base, max_base, root;\n\n\tNTT() : base(1), rev{0, 1}, rts{0, 1} {\n\t\tassert(mod >= 3 && mod % 2 == 1);\n\t\tauto tmp = mod - 1;\n\t\tmax_base = 0;\n\t\twhile(tmp % 2 == 0) tmp >>= 1, max_base++;\n\t\troot = 2;\n\t\twhile(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n\t\tassert(mod_pow(root, mod - 1) == 1);\n\t\troot = mod_pow(root, (mod - 1) >> max_base);\n\t}\n\n\tinline int mod_pow(int x, int n) {\n\t\tint ret = 1;\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret = mul(ret, x);\n\t\t\tx = mul(x, x);\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinline int inverse(int x) {\n\t\treturn mod_pow(x, mod - 2);\n\t}\n\n\tinline unsigned add(unsigned x, unsigned y) {\n\t\tx += y;\n\t\tif(x >= mod) x -= mod;\n\t\treturn x;\n\t}\n\n\tinline unsigned mul(unsigned a, unsigned b) {\n\t\treturn 1ull * a * b % (unsigned long long) mod;\n\t}\n\n\tvoid ensure_base(int nbase) {\n\t\tif(nbase <= base) return;\n\t\trev.resize(1 << nbase);\n\t\trts.resize(1 << nbase);\n\t\tfor(int i = 0; i < (1 << nbase); i++) {\n\t\t\trev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n\t\t}\n\t\tassert(nbase <= max_base);\n\t\twhile(base < nbase) {\n\t\t\tint z = mod_pow(root, 1 << (max_base - 1 - base));\n\t\t\tfor(int i = 1 << (base - 1); i < (1 << base); i++) {\n\t\t\t\trts[i << 1] = rts[i];\n\t\t\t\trts[(i << 1) + 1] = mul(rts[i], z);\n\t\t\t}\n\t\t\t++base;\n\t\t}\n\t}\n\n\n\tvoid ntt(vector< int > &a) {\n\t\tconst int n = (int) a.size();\n\t\tassert((n & (n - 1)) == 0);\n\t\tint zeros = __builtin_ctz(n);\n\t\tensure_base(zeros);\n\t\tint shift = base - zeros;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i < (rev[i] >> shift)) {\n\t\t\t\tswap(a[i], a[rev[i] >> shift]);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1; k < n; k <<= 1) {\n\t\t\tfor(int i = 0; i < n; i += 2 * k) {\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\tint z = mul(a[i + j + k], rts[j + k]);\n\t\t\t\t\ta[i + j + k] = add(a[i + j], mod - z);\n\t\t\t\t\ta[i + j] = add(a[i + j], z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector< int > multiply(vector< int > a, vector< int > b) {\n\t\tint need = a.size() + b.size() - 1;\n\t\tint nbase = 1;\n\t\twhile((1 << nbase) < need) nbase++;\n\t\tensure_base(nbase);\n\t\tint sz = 1 << nbase;\n\t\ta.resize(sz, 0);\n\t\tb.resize(sz, 0);\n\t\tntt(a);\n\t\tntt(b);\n\t\tint inv_sz = inverse(sz);\n\t\tfor(int i = 0; i < sz; i++) {\n\t\t\ta[i] = mul(a[i], mul(b[i], inv_sz));\n\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tntt(a);\n\t\ta.resize(need);\n\t\treturn a;\n\t}\n};\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\tNTT<MOD> ntt;\n\tvector<int> a(n / 2 + 1,1);\n\tfor(int i = 1;i <= n / 2;i++){\n\t\ta[i] = a[i - 1] * mod_inv(i) % MOD;\n\t}\n\tvector<int> c = ntt.multiply(a,a);\n\tint tmp = 1,ans = 0,nfact;\n\tfor(int i = 1;i <= n;i++) tmp = tmp * mod_inv(i) % MOD;\n\tnfact = mod_inv(tmp);\n\tfor(int i = 0;i <= n;i++){\n\t\tans = (ans + c[i] * tmp % MOD * nfact) % MOD;\n\t\tif(i != n) tmp = tmp * (n - i) % MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    create_mod_tables(N);\n    int64_t ans = power_mod(3, N);\n    for(int k=N/2+1; k<=N; k++){\n        int64_t res = 2 * comb_mod(N, k) * power_mod(2, N-k) % MOD;\n        add(ans, MOD - res);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"debug.h\"\n#include <string.h>\n#include <limits.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//#include \"math/modulo.h\"\n\ntemplate<class T, T M>\nstruct modulo {\n\tT n;\n\tmodulo(T n): n(n<0? n%M+M: n%M)   { }\n\toperator T() const                { return n;             }\n\tmodulo operator-() const          { return modulo(-n);    }\n\tmodulo operator+(const modulo &o) const { return modulo(n+o.n); }\n\tmodulo operator-(const modulo &o) const { return modulo(n-o.n); }\n\tmodulo operator*(const modulo &o) const { return modulo(n*o.n); }\n\tbool  operator< (const modulo &o) const { return n< o.n; }\n\tbool  operator<=(const modulo &o) const { return n<=o.n; }\n\tbool  operator> (const modulo &o) const { return n> o.n; }\n\tbool  operator>=(const modulo &o) const { return n>=o.n; }\n\tbool  operator==(const modulo &o) const { return n==o.n; }\n\tbool  operator!=(const modulo &o) const { return n!=o.n; }\n\n\tmodulo pow(T n) const {\n\t\tmodulo y = 1, x = *this;\n\t\twhile (n) {\n\t\t\tif (n%2) y = y * x;\n\t\t\tn /= 2;\n\t\t\tx = x * x;\n\t\t}\n\t\t/*\n\t\tif (n==0) return 1;\n\t\tmodulo y = pow(n/2);\n\t\ty = y*y;\n\t\tif (n%2) y = y * (*this);\n\t\t*/\n\t\treturn y;\n\t}\n\tmodulo inv() const {\n\t\treturn pow(M-2);\n\t}\n\tmodulo operator/(const modulo &o) const {\n\t\treturn (*this) * o.inv();\n\t}\n\n\tT gcd_ext(T a, T b, T *x, T *y) {\n\t\tif (a == 0) {\n\t\t\t*x = 0;\n\t\t\t*y = 1;\n\t\t\treturn b;\n\t\t}\n\t\tT x1, y1;\n\t\tT gcd = gcd_ext(b%a, a, &x1, &y1);\n\t\t*x = y1 - (b/a) * x1;\n\t\t*y = x1;\n\t\treturn gcd;\n\t}\n\tmodulo div(const modulo &o) const {\n\t\tT x, y;\n\t\tT g = gcd_ext(o.n, M, &x, &y);\n\t\tif (g != 1) return 0;\n\t\telse return modulo(n * (x % M));\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const modulo &x) {\n\t\treturn os << x.n;\n\t}\n};\n\ntypedef modulo<long,998244353> T;\n//#include \"math/comb.h\"\n\nvoid comb_inc_k(T &r, int n, int &k) {\n        //C(n,k+1) = C(n,k) * (n-k) / (k+1)\n\tr = r * T(n-k) / T(k+1);\n\tk++;\n}\n\nvoid comb_dec_k(T &r, int n, int &k) {\n        //C(n,k-1) = C(n,k) * k / (n-k+1)\n\tr = r * T(k) / T(n-k+1);\n\tk--;\n}\n\nvoid comb_inc_n(T &r, int &n, int k) {\n        //C(n+1,k) = C(n,k) * (n+1) / (n+1-k)\n\tr = r * T(n+1) / T(n+1-k);\n\tn++;\n}\n\nvoid comb_dec_n(T &r, int &n, int k) {\n        //C(n-1,k) = C(n,k) * (n-k) / n\n\tr = r * T(n-k) / T(n);\n\tn--;\n}\n\nT comb(int n, int k) {\n    if (k*2 > n) k = n-k;\n    if (n==0) return 0;\n    T r = 1; //C(n,0)\n    int i = 0;\n    while (i<k) comb_inc_k(r, n, i);\n    return r;\n}\n\n\n#define MAXN 100000\n\nint n;\n\n\nint input() {\n\tif (scanf(\"%d\", &n) < 0) return 0;\n\treturn 1;\n}\n\nvoid init() {\n}\n\nint solve() {\n\tT r = T(3).pow(n);\n\tint k = n/2;\n\tT e = comb(n, k);\n\twhile (k+1<=n) {\n\t\tcomb_inc_k(e, n, k);\n\t\tr = r - e*T(2).pow(n-k+1);\n\t}\n\treturn r;\n}\n\nvoid output(int ans) {\n\tprintf(\"%d\\n\", ans);\n}\n\nvoid cleanup() {\n}\n\nint main() {\n\t//int ca; scanf(\"%d\", &ca);\n\twhile (input()) {\n\t\tinit();\n\t\toutput(solve());\n\t\tcleanup();\n\t\t//break;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int, int >\n#define F first\n#define S second\n#define int  long long int\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n/// age ye mosh dp ro baze dashti dp tedad baz shodeye baste nashode yadet nare !!\nconst int N=1e7+10;\nll mod=998244353;\n\nll fac[N];\nll power(ll n, ll k){\n    if (k==0){\n        return 1;\n    }\n    else{\n        if (k%2==0){\n            ll x=power(n,k/2);\n            return x*x%mod;\n        }\n        else{\n            ll x=power(n,k/2);\n            x=x*x%mod;\n            return x*n%mod;\n        }\n    }\n}\nll fm[N];\nll ent(ll k, ll n){\n\tif (k==0 || k==n){\n        return 1;\n\t}\n\n\treturn (((fac[n]*fm[k])%mod)*fm[n-k])%mod;\n}\n\nint32_t main(){\n    fac[0] = 1;\n\n\tfor(int i=1;i<N;i++) {\n        fac[i]=(fac[i-1]*i)%mod;\n\t}\n\tfor(int i=0;i<N;i++) {\n        fm[i]=power(fac[i],mod-2);\n\t}\n\tll n;\n\tcin >> n;\n\tll ans=power(3,n);\n\tfor (int i=n/2+1;i<=n;i++){\n        ans-=ent(i,n)*power(2,n-i)*2%mod;\n        ans+=mod;\n        ans%=mod;\n\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG 1\nusing namespace std;\n\nnamespace output{\n    void __(short x){cout<<x;}\n    void __(unsigned x){cout<<x;}\n    void __(int x){cout<<x;}\n    void __(long long x){cout<<x;}\n    void __(unsigned long long x){cout<<x;}\n    void __(double x){cout<<x;}\n    void __(long double x){cout<<x;}\n    void __(char x){cout<<x;}\n    void __(const char*x){cout<<x;}\n    void __(const string&x){cout<<x;}\n    void __(bool x){cout<<(x?\"true\":\"false\");}\n    template<class S,class T>\n    void __(const pair<S,T>&x){__(DEBUG?\"(\":\"\"),__(x.first),__(DEBUG?\", \":\" \"),__(x.second),__(DEBUG?\")\":\"\");}\n    template<class T>\n    void __(const vector<T>&x){__(DEBUG?\"{\":\"\");bool _=0;for(const auto&v:x)__(_?DEBUG?\", \":\" \":\"\"),__(v),_=1;__(DEBUG?\"}\":\"\");}\n    template<class T>\n    void __(const set<T>&x){__(DEBUG?\"{\":\"\");bool _=0;for(const auto&v:x)__(_?DEBUG?\", \":\" \":\"\"),__(v),_=1;__(DEBUG?\"}\":\"\");}\n    template<class T>\n    void __(const multiset<T>&x){__(DEBUG?\"{\":\"\");bool _=0;for(const auto&v:x)__(_?DEBUG?\", \":\" \":\"\"),__(v),_=1;__(DEBUG?\"}\":\"\");}\n    template<class S,class T>\n    void __(const map<S,T>&x){__(DEBUG?\"{\":\"\");bool _=0;for(const auto&v:x)__(_?DEBUG?\", \":\" \":\"\"),__(v),_=1;__(DEBUG?\"}\":\"\");}\n    void pr(){cout<<\"\\n\";}\n    template<class S,class... T>\n    void pr(const S&a,const T&...b){__(a);if(sizeof...(b))__(' ');pr(b...);}\n}\n\nusing namespace output;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,char> pic;\ntypedef pair<double,double> pdd;\ntypedef pair<ld,ld> pld;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define pb push_back\n#define fox(i,x,y) for(int i=(x);i<=(y);i++)\n#define foxr(i,x,y) for(int i=(y);i>=(x);i--)\n#define F first\n#define S second\n\nconst int MN = 1e7+5, mod = 998244353;\nint N, i, j, fac[MN]={1}, inv[MN]={1}, f[MN], ans;\nint qpow(int b,int exp){\n    if(exp<=0) return 1;\n    else if(exp&1) return 1LL*b*qpow(b,exp-1)%mod;\n    else{int r=qpow(b,exp>>1); return 1LL*r*r%mod;}\n}\nint C(int n,int k){return 1LL*fac[n]*inv[k]%mod*inv[n-k]%mod;}\n\nint main(){\n    scanf(\"%d\",&N);\n    for(i=1;i<=N;i++)\n        fac[i]=1LL*fac[i-1]*i%mod;\n    inv[N]=qpow(fac[N],mod-2);\n    for(i=N-1;i>=1;i--)\n        inv[i]=1LL*inv[i+1]*(i+1)%mod;\n    ans=qpow(3,N);\n    f[0]=1;\n    for(i=1;i<=N/2;i++)\n        f[i]=2LL*f[i-1]%mod;\n    for(i=N/2+1;i<=N;i++){\n        ans=(ans-2LL*f[N-i]*C(N,i))%mod;\n        if(ans<0) ans+=mod;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(1e7)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\n// binom mod MOD\nll binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\n\nint main() {\n  binom_init();\n  ll n; cin >> n;\n  n /= 2;\n  \n  mint ans = 0;\n  mint z = 1;\n  rep(k, 2*n+1) {\n    ans += z * binom(2*n, k);\n    z *= 2;\n    z -= binom(k, n) * 2;\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tchar ch; bool flag = false; res = 0;\n\twhile (ch = getchar(), !isdigit(ch) && ch != '-');\n\tch == '-' ? flag = true : res = ch ^ 48;\n\twhile (ch = getchar(), isdigit(ch))\n\t\tres = res * 10 + ch - 48;\n\tflag ? res = -res : 0;\n}\n\nconst int N = 1e7 + 5;\nconst int mod = 998244353;\nint fra[N], inv[N], ex[N], n;\n\ninline int quick_pow(int x, int k)\n{\n\tint res = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tres = 1ll * res * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int &x, int y)\n{\n\tx += y;\n\tx >= mod ? x -= mod : 0;\n}\n\ninline void dec(int &x, int y)\n{\n\tx -= y;\n\tx < 0 ? x += mod : 0;\n}\n\ninline int C(int n, int m)\n{\n\treturn 1ll * fra[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n\tread(n);\n\tfra[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfra[i] = 1ll * fra[i - 1] * i % mod;\n\tinv[n] = quick_pow(fra[n], mod - 2);\n\tfor (int i = n; i >= 1; --i)\n\t\tinv[i - 1] = 1ll * inv[i] * i % mod;\n\tex[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tadd(ex[i] = ex[i - 1], ex[i - 1]);\n\n\tint half = n >> 1, ans = quick_pow(3, n);\n\tfor (int i = half + 1; i <= n; ++i)\n\t\tdec(ans, 2ll * C(n, i) * ex[n - i] % mod);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n\tInit();\n\tcin>>n;\n\tll res=Pow(3,n);\n\tfor(int i=n/2+1;i<=n;i++) res=(res-2*nCk(n,i)*Pow(2,n-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=10000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n;\n\nint main(){\n\tInit();\n\tcin>>n;\n\tll res=Pow(3,n);\n\tfor(int i=n/2+1;i<=n;i++) res=(res-2*nCk(n,i)*Pow(2,n-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int, T mod = 1'000'000'007, typename U = long long>\nstruct umod{\n        T val;\n        umod(): val(0){}\n        umod(U x){ x %= mod; if(x < 0) x += mod; val = x;}\n        umod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\tumod& operator *= (umod oth){ val = ((U)val) * oth.val % mod; return *this; }\n\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n        umod& operator ^= (U oth){ return *this = pwr(*this, oth); }\n\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n        umod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\tbool operator < (umod oth) const { return val < oth.val; }\n\tbool operator > (umod oth) const { return val > oth.val; }\n\tbool operator <= (umod oth) const { return val <= oth.val; }\n\tbool operator >= (umod oth) const { return val >= oth.val; }\n\tbool operator == (umod oth) const { return val == oth.val; }\n\tbool operator != (umod oth) const { return val != oth.val; }\n        umod pwr(umod a, U b) const { umod r = 1; for(; b; a *= a, b >>= 1) if(b&1) r *= a; return r; }\n        umod inverse() const {\n\t\tU a = val, b = mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tU t = a/b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tif(u < 0)\n\t\t\tu += mod;\n\t\treturn u;\n        }\n};\n\ntemplate<typename U>\nstruct NCR {\n        vector<U> fact, ifact;\n        NCR(int size){\n                fact.resize(size + 1); ifact.resize(size + 1);\n                fact[0] = 1;\n                for(int i = 1; i <= size; i++) fact[i] = fact[i - 1] * i;\n                ifact[size] = fact[size].inverse();\n                for(int i = size - 1; i >= 0; i--) ifact[i] = ifact[i + 1] * (i + 1);\n        }\n        U ncr(int n, int r){\n                if(n < r) return 0;\n                return fact[n] * ifact[r] * ifact[n - r];\n        }\n};\n\nusing U = umod<int,998244353>;\nusing N = NCR<U>;\nint main(){\n\tN k(10'000'100);\n\tvector<U> p2(10'000'100); p2[0] = 1;\n\tint n; cin >> n;\n\tfor(int i = 1; i <= n; i++) p2[i] = p2[i - 1] * 2;\n\tU ans = U(3) ^ n;\n\tfor(int i = n / 2 + 1; i <= n; i++) ans -= k.ncr(n, i) * p2[n - i + 1];\n\tcout << ans.val << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int P = 998244353 ; \nconst int N = 1e7 + 5 ;\nint n, inv[N], fac[N], fp[N], Ans ;\nint fpow( int x, int k ) {\n\tint ans = 1, base = x ;\n\twhile( k ) {\n\t\tif( k & 1 ) ans = ans * base % P ;\n\t\tbase = base * base % P, k >>= 1 ;\n\t} return ans ; \n}\nvoid inc( int &x, int y ) {\n\t( ( x += y ) >= P ) && ( x -= P ) ;\n}\nint C( int x, int y ) {\n\tif( y > x ) return 0 ;\n\treturn fac[x] * inv[y] % P * inv[x - y] % P ;\n}\nsigned main()\n{\n\tn = gi(), fp[0] = inv[0] = fac[0] = 1 ;\n\trep( i, 1, n ) fac[i] = fac[i - 1] * i % P, fp[i] = fp[i - 1] * 2 % P ; \n\tinv[n] = fpow( fac[n], P - 2 ) ;\n\tfor( re int i = n; i >= 1; -- i ) inv[i - 1] = inv[i] * i % P ;\n\tint m = ( n / 2 ) + 1, num = 0 ;\n\tAns = fpow( 3, n ) ;\n\tfor( re int i = m; i <= n; ++ i ) {\n\t\tint dec = C( n, i ) ;\n\t\tdec = dec * fp[n - i] % P ;\n\t\tinc( num, dec ) ;\n\t}\n\tAns = ( Ans - num * 2ll % P + P ) % P ;\n\tprintf(\"%lld\\n\", Ans ) ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nll MOD = 998244353;\nconst ll N = 1e7+10;\nll f[N], rf[N];\nll inv(ll x) {\n    ll res = 1;\n    ll k = MOD - 2;\n    ll y = x;\n    while (k) {\n        if (k & 1) res = (res * y) % MOD;\n        y = (y * y) % MOD;\n        k /= 2;\n    }\n    return res;\n}\nvoid init() {\n    f[0] = 1;\n    for(int i = 1; i < N; i++) f[i] = (f[i - 1] * i) % MOD;\n    for(int i = 0; i < N; i++) rf[i] = inv(f[i]);\n}\nll C(int n, int k) {\n    if(n < k) return 0;\n    ll a = f[n]; // = n!\n    ll b = rf[n-k]; // = (n-k)!\n    ll c = rf[k]; // = k!\n    ll bc = (b * c) % MOD;\n    return (a * bc) % MOD;\n}\n\nll mod_pow(ll x, ll n)\n{\n    ll res = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n        {\n            res = res * x % MOD;\n        }\n        x = x * x % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main()\n{\n    init();\n    int n;\n    cin >> n;\n    ll ans = mod_pow(3, n);\n    ll tmp = 0;\n    vector<ll> mod2(n/2+1);\n    mod2[0] = 1;\n    for(int i = 1; i < n/2+1; i++)\n    {\n        mod2[i] = mod2[i-1] * 2 % MOD;\n    }\n    for(int a = n/2 + 1; a <= n; a++)\n    {\n        tmp += C(n, a) * mod2[n-a] % MOD;\n        tmp %= MOD;\n    }\n    tmp = tmp * 2 % MOD;\n    ans = (ans - tmp + MOD) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  constexpr ModInt() : v(0) {}\n  constexpr ModInt(unsigned _v, int) : v(_v) {}\n  template<class Z> ModInt(const Z& a) : v((a < 0 ? P - -a % P : a) % P) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  friend M operator*(M l, M r) { return M(l) *= r; }\n  friend M operator/(M l, M r) { return M(l) /= r; }\n  friend M operator+(M l, M r) { return M(l) += r; }\n  friend M operator-(M l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend bool operator==(M l, M r) { return l.v == r.v; }\n  friend bool operator!=(M l, M r) { return !(l == r); }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Z> M pow(Z n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n};\nusing Mint = ModInt<998244353>;\nconstexpr int N = 1 << 10;\nstruct Fact {\n  V<Mint> v;\n  Fact(int n) : v(n + 1, 1) {\n    for (int i = 1; i <= n; ++i) v[i] = i * v[i - 1];\n  }\n  Mint operator[](int i) const { return v[i]; }\n} fact(N);\nstruct Finv {\n  V<Mint> v;\n  Finv(int n) : v(n + 1, 1 / fact[n]) {\n    for (int i = n; i; --i) v[i - 1] = i * v[i];\n  }\n  Mint operator[](int i) const { return v[i]; }\n} finv(N);\nstruct Minv {\n  V<Mint> v;\n  Minv(int n) : v(n) {\n    for (int i = 1; i <= n; ++i) v[i - 1] = fact[i - 1] * finv[i];\n  }\n  Mint operator[](int i) const { return v[i - 1]; }\n} minv(N);\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * finv[r] * finv[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  n >>= 1;\n  Mint res = comb(2 * n, n);\n  for (int k = 0; k <= 2 * n; ++k) {\n    Mint sum;\n    for (int i = 0; i <= k; ++i) {\n      sum += (i & 1 ? -1 : 1) * comb(k + 1 - i, i) * comb(2 * n - 2 * i, n - i);\n    }\n    res += comb(2 * n, k + 1) * sum;\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//by Judge\n#pragma GCC optimize(\"Ofast\")\n#define HGS_AK_IOI true\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define Rg register\n#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)\n#define ll long long\nusing namespace std;\nconst int mod=998244353;\nconst int M=1e7+3;\ntypedef int arr[M];\nchar buf[1<<21],*p1=buf,*p2=buf;\nint n,ans; arr pw2,fac,inv;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\ninline void Pls(int& x,int y){if((x+=y)>=mod)x-=mod;}\ninline int qpow(int x,int p=mod-2){ Rg int s=1;\n\tfor(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;\n}\ninline int C(int n,int m){ return mul(fac[n],mul(inv[m],inv[n-m])); }\nint main(){ cin>>n,pw2[0]=fac[0]=1,ans=qpow(3,n);\n\tfp(i,1,n) pw2[i]=mul(pw2[i-1],2),fac[i]=mul(fac[i-1],i);\n\tinv[n]=qpow(fac[n]); fd(i,n,1) inv[i-1]=mul(inv[i],i);\n\tfp(i,0,(n-1)>>1) Pls(ans,mod-mul(pw2[i+1],C(n,n-i))); return !printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>a(N / 2 + 1);\n\tvector<long long int>by(N + 1, 1);\n\tvector<long long int>rev(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tfor (int i = 0; i <= N / 2; i++) {\n\t\ta[i] = by[N / 2] * rev[N / 2 - i];\n\t\ta[i] %= MOD;\n\t\ta[i] *= rev[i];\n\t\ta[i] %= MOD;\n\t\ta[i] *= power(2, N / 2 - i, MOD);\n\t\ta[i] %= MOD;\n\t\t//cout << i << \" \" << a[i] << endl;\n\t}\n\tauto asum = a;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tasum[i] += asum[i - 1];\n\t\tasum[i] %= MOD;\n\t\t//cout << i << \" \" << asum[i] << endl;\n\t}\n\tlong long int ans = power(3, N, MOD);\n\tlong long int minus = 0;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tlong long int box = asum[N / 2] - asum[N / 2 - i];\n\t//\tcout << box << endl;\n\t\tbox += MOD;\n\t\tbox %= MOD;\n\t\tbox *= a[i];\n\t\tbox *= 2;\n\t\tbox %= MOD;\n\t\tminus += box;\n\t\tminus %= MOD;\n\t\t//cout << i << \" \" << minus << endl;\n\t}\n\tans -= minus;\n\tans += MOD;\n\tans %= MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n//TEMPLATE START---------------8<---------------8<---------------8<---------------8<---------------//\ntypedef long long ll;       typedef long double ld;  typedef pair<int,int> pii; typedef pair<ll,ll> pll;  typedef vector<int> vi;   typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb; typedef vector<ld> vld;    typedef vector<pii> vpii; typedef vector<pll> vpll; typedef vector<vector<int> > vvi;\nconst int INF = (0x7FFFFFFFL); const ll INFF = (0x7FFFFFFFFFFFFFFFL); const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 1e9 + 7;       const int MODD = 998244353;            const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double PI = acos(-1.0);  const double EPS = 1e-9;               const string Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nint dx[9] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nint dy[9] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n#define ln '\\n'\n#define scnaf scanf\n#define sacnf scanf\n#define sancf scanf\n#define SS(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t){cin >> t;}template<typename First, typename...Rest> void MACRO_VAR_Scan(First& first, Rest&...rest){cin >> first;MACRO_VAR_Scan(rest...);}\n#define SV(type,c,n) vector<type> c(n);for(auto& i:c)cin >> i;\n#define SVV(type,c,n,m) vector<vector<type>> c(n,vector<type>(m));for(auto& r:c)for(auto& i:r)cin >> i;\ntemplate<class T,class U>ostream &operator<<(ostream &o,const pair<T,U>&j){o<<\"{\"<<j.first<<\", \"<<j.second<<\"}\";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const map<T,U>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const set<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const multiset<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const vector<T>&j){o<<\"{\";for(int i=0;i<(int)j.size();++i)o<<(i>0?\", \":\"\")<<j[i];o<<\"}\";return o;}\ninline int print(void){cout << endl; return 0;}\ntemplate<class Head> int print(Head&& head){cout << head;print();return 0;} template<class Head,class... Tail> int print(Head&& head,Tail&&... tail){cout<<head<<\" \";print(forward<Tail>(tail)...);return 0;}\ninline int debug(void){cerr << endl; return 0;}\ntemplate<class Head> int debug(Head&& head){cerr << head;debug();return 0;} template<class Head,class... Tail> int debug(Head&& head,Tail&&... tail){cerr<<head<<\" \";debug(forward<Tail>(tail)...);return 0;}\ntemplate<typename T> void PA(T &a){int ASIZE=sizeof(a)/sizeof(a[0]);for(int ii=0;ii<ASIZE;++ii){cout<<a[ii]<<\" \\n\"[ii==ASIZE-1];}}\ntemplate<typename T> void PV(T &v){int VSIZE=v.size();for(int ii=0;ii<VSIZE;++ii){cout<<v[ii]<<\" \\n\"[ii==VSIZE-1];}}\n#define ER(x)  cerr << #x << \" = \" << (x) << endl;\n#define ERV(v) {cerr << #v << \" : \";for(const auto& xxx : v){cerr << xxx << \" \";}cerr << \"\\n\";}\ninline int YES(bool x){cout<<((x)?\"YES\":\"NO\")<<endl;return 0;} inline int Yes(bool x){cout<<((x)?\"Yes\":\"No\")<<endl;return 0;}  inline int yes(bool x){cout<<((x)?\"yes\":\"no\")<<endl;return 0;}\ninline int yES(bool x){cout<<((x)?\"yES\":\"nO\")<<endl;return 0;} inline int Yay(bool x){cout<<((x)?\"Yay!\":\":(\")<<endl;return 0;}\ntemplate<typename A,typename B> void sankou(bool x,A a,B b){cout<<((x)?(a):(b))<<endl;}\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REPI(i,0,n)\n#define REPI(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REPI,_REP,)(__VA_ARGS__)\n#define _RREP(i,n) RREPI(i,n,0)\n#define RREPI(i,a,b) for(ll i=ll(a);i>=ll(b);--i)\n#define RREP(...) _overload3(__VA_ARGS__,RREPI,_RREP,)(__VA_ARGS__)\n#define EACH(e,v) for(auto& e : v)\n#define PERM(v) sort((v).begin(),(v).end());for(bool c##p=1;c##p;c##p=next_permutation((v).begin(),(v).end()))\n#define ADD(a,b) a=(a+ll(b))%MOD\n#define MUL(a,b) a=(a*ll(b))%MOD\ninline ll MOP(ll x,ll n,ll m=MOD){ll r=1;while(n>0){if(n&1)(r*=x)%=m;(x*=x)%=m;n>>=1;}return r;}\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}inline ll POW(ll a,ll b){ll c=1ll;do{if(b&1)c*=1ll*a;a*=1ll*a;}while(b>>=1);return c;}\ntemplate<typename T,typename A,typename B> inline bool between(T x,A a,B b) {return ((a<=x)&&(x<b));}template<class T> inline T sqr(T x){return x*x;}\ntemplate<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}\n#define tmax(x,y,z) max((x),max((y),(z)))\n#define tmin(x,y,z) min((x),min((y),(z)))\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define SORT(v) sort((v).begin(),(v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define EXIST(s,e) (find((s).begin(),(s).end(),(e))!=(s).end())\n#define EXISTST(s,c) (((s).find(c))!=string::npos)\n#define POSL(x,val) (lower_bound(x.begin(),x.end(),val)-x.begin())\n#define POSU(x,val) (upper_bound(x.begin(),x.end(),val)-x.begin())\n#define GEQ(x,val) (int)(x).size() - POSL((x),(val))\n#define GREATER(x,val) (int)(x).size() - POSU((x),(val))\n#define LEQ(x,val) POSU((x),(val))\n#define LESS(x,val) POSL((x),(val))\n#define SZV(a) int((a).size())\n#define SZA(a) sizeof(a)/sizeof(a[0])\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MEMINF(a) memset(a,0x3f,sizeof(a))\n#define FILL(a,b) memset(a,b,sizeof(a))\n#define UNIQUE(v) sort((v).begin(),(v).end());(v).erase(unique((v).begin(),(v).end()),(v).end())\nstruct abracadabra{\n    abracadabra(){\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n        cerr << fixed << setprecision(5);\n    };\n} ABRACADABRA;\n\n//TEMPLATE END---------------8<---------------8<---------------8<---------------8<---------------//\n\n/*\n・ModInt\n[備考] Mod演算のための構造体\n[使用例]\nmodint M;           // 剰余系MOD(1e9+7)における演算ができる\nModInt<mod> N;      // 剰余系modにおける演算ができる\n*/\n\ntemplate< int MODULO > struct ModInt {\n    using int64 = int_fast64_t;\n    using uint32 = uint_fast32_t;\n    using uint64 = uint_fast64_t;\n    uint64 x; ModInt() : x(0) {}\n    ModInt(uint64 y) : x(set(y % MODULO + MODULO)) {}\n    static uint64 set(const uint64 &y) { return (y < MODULO) ? y : y - MODULO; }\n    static ModInt make(const uint64 &y) { ModInt ret = y; return ret; }\n    ModInt operator+(const ModInt &m) const { return make(set(x + m.x)); }\n    ModInt operator-(const ModInt &m) const { return make(set(x + MODULO - m.x)); }\n    ModInt operator*(const ModInt &m) const { return make(x * m.x % MODULO); }\n    ModInt operator/(const ModInt &m) const { return make(x) * ~make(m.x); }\n    ModInt &operator+=(const ModInt &m) { return *this = *this + m; }\n    ModInt &operator-=(const ModInt &m) { return *this = *this - m; }\n    ModInt &operator*=(const ModInt &m) { return *this = *this * m; }\n    ModInt &operator/=(const ModInt &m) { return *this = *this / m; }\n    ModInt &operator^=(const uint64 &y) { return *this = *this ^ y; }\n    ModInt operator~ () const { return *this ^ (MODULO - 2); }\n    ModInt operator- () const { return make(set(MODULO - x)); }\n    ModInt operator! () const { init(uint32(*this)); return fact[uint32(*this)]; }\n    ModInt operator& () const { init(uint32(*this)); return finv[uint32(*this)]; }\n    ModInt operator++() { return *this = make(set(x + 1)); }\n    ModInt operator--() { return *this = make(set(x + MODULO - 1)); }\n    bool operator==(const ModInt &m) const { return x == m.x; }\n    bool operator!=(const ModInt &m) const { return x != m.x; }\n    bool operator< (const ModInt &m) const { return x <  m.x; }\n    bool operator<=(const ModInt &m) const { return x <= m.x; }\n    bool operator> (const ModInt &m) const { return x >  m.x; }\n    bool operator>=(const ModInt &m) const { return x >= m.x; }\n    explicit operator   bool() const { return x; }\n    explicit operator uint64() const { return x; }\n    ModInt operator^(uint64 y) const {\n        uint64 t = x, u = 1;\n        while (y) { if (y & 1) (u *= t) %= MODULO; (t *= t) %= MODULO; y >>= 1; }\n        return make(u);\n    }\n    friend ostream &operator<<(ostream &os, const ModInt< MODULO > &m) { return os << m.x; }\n    friend istream &operator>>(istream &is, ModInt< MODULO > &m) { uint64 y; is >> y; m = make(y); return is; }\n    static vector< ModInt > fact, finv, invs;\n    static void init(uint32 n) {\n        uint32 m = fact.size();\n        if (n < m) return;\n        fact.resize(n + 1, 1);\n        finv.resize(n + 1, 1);\n        invs.resize(n + 1, 1);\n        if (m == 0) m = 1;\n        for (uint32 i = m; i <= n; ++i) fact[i] = fact[i - 1] * ModInt(i);\n        finv[n] = ModInt(1) / fact[n];\n        for (uint32 i = n; i >= m; --i) finv[i - 1] = finv[i] * make(i);\n        for (uint32 i = m; i <= n; ++i) invs[i] = finv[i] * fact[i - 1];\n    }\n    static ModInt C(int64 n, int64 r) {\n        if (r == 0) return make(1);\n        if (r <  0) return make(0);\n        if (n <  0) return make(r & 1 ? MODULO - 1 : 1) * C(-n + r - 1, r);\n        if (n == 0 || n < r) return make(0);\n        init(n);\n        return fact[n] * finv[n - r] * finv[r];\n    }\n    static ModInt P(int64 n, int64 r) {\n        if (n < r || r < 0) return make(0);\n        init(n);\n        return fact[n] * finv[n - r];\n    }\n    static ModInt H(int64 n, int64 r) {\n        if (n < 0 || r < 0) return make(0);\n        if (!n && !r) return make(1);\n        init(n + r - 1);\n        return C(n + r - 1, r);\n    }\n    static ModInt montmort(uint32 n) {\n        ModInt res;\n        init(n);\n        for (uint32 k = 2; k <= n; ++k) {\n            if (k & 1) res -= finv[k];\n            else res += finv[k];\n        }\n        return res *= fact[n];\n    }\n    static ModInt LagrangePolynomial(vector<ModInt> &y, ModInt t) {\n        uint32 n = y.size() - 1;\n        if (t.x <= n) return y[t.x];\n        init(n + 1);\n        ModInt res, num(1);\n        for (uint32 i = 0; i <= n; ++i) num *= t - make(i);\n        for (uint32 i = 0; i <= n; ++i) {\n            ModInt tmp = y[i] * num / (t - make(i)) * finv[i] * finv[n - i];\n            if ((n - i) & 1) res -= tmp;\n            else res += tmp;\n        }\n        return res;\n    }\n};\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::fact = vector<ModInt< MODULO >>();\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::finv = vector<ModInt< MODULO >>();\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::invs = vector<ModInt< MODULO >>();\nusing modint = ModInt< MODD >;\n\nsigned main() {\n\n    SS(int, N);\n\n    modint res = 3;\n    res ^= N;\n\n    REP(i, (N + 1) / 2) {\n        modint tmp = modint::C(N, i);\n        modint pw = 2;\n        pw ^= i + 1;\n        res -= tmp * pw;\n    }\n\n    print(res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 998244353;\n\n// [l,r]\nint dp_rec(string& s, int l, int r, vector<vector<int>>& dp){\n  if(l>r) return 0;\n  if(dp[l][r] != -1) return dp[l][r];\n  if(l==r) return dp[l][r] = 0;\n  if(l+1==r){\n    return dp[l][r] = s[l] == s[r] || s[l] == 'C' || s[r] == 'C';\n  }\n\n  if(s[l] == s[r] || s[l] == 'C' || s[r] == 'C'){\n    if(dp_rec(s, l+1, r-1, dp)){\n      return dp[l][r] = 1;\n    }\n  }\n\n  for(int c=0; c<r; c++){\n    if(dp_rec(s, l, c, dp) && dp_rec(s, c+1, r, dp)){\n      return dp[l][r] = 1;\n    }\n  }\n\n  return dp[l][r] = 0;\n}\n\nbool check(string s){\n  vector<vector<int>> dp(s.size(), vector<int>(s.size(), -1));\n  bool ok = dp_rec(s, 0, s.size()-1, dp);\n  // eprintln(ok);\n\n  // eprintln(s);\n  // for(int l=0; l<s.size(); l++){\n  //   string tmp_ok(s.size(), '_');\n  //   for(int r=l; r<s.size(); r++){\n  //     tmp_ok[r] = s[r];\n  //     if(dp[l][r] == 1){\n  //       eprintln(tmp_ok);\n  //     }\n  //   }\n  // }\n  return ok;\n}\n\nint rec(string& s, int n, int k){\n  if(k == n){\n    if(check(s)){\n      // eprintln(s);\n      return 1;\n    }else{\n      eprintln(s);\n      return 0;\n    }\n  }\n\n  int res = 0;\n  s[k] = 'A';\n  res += rec(s, n, k+1);\n  s[k] = 'B';\n  res += rec(s, n, k+1);\n  // s[k] = 'C';\n  // res += rec(s, n, k+1);\n  return res;\n}\n\n\n// precomputation O(size)\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(n<0 || k<0) return 0;\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\nint main(){\n  // string s;\n  // cin >> s;\n  // check(s);\n  // int len;\n  // cin >> len;\n  // string s(len, '.');\n  // int ans = rec(s, len, 0);\n  // eprintln(ans);\n\n  int n;\n  cin >> n;\n  combination_mod c(mod, n+1);\n\n  long long s = 0;\n  for(int k=n/2+1; k<=n; k++){\n    int r = n-k;\n    s += c(n, k) * my_pow_mod(2, r, mod) % mod;\n    if(s >= mod) s -= mod;\n  }\n\n  s += s;\n  if(s >= mod) s %= mod;\n\n  long long ans = my_pow_mod(3, n, mod);\n  ans = (ans - s + mod) % mod;\n  println(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\nusing namespace std;\nconst int N=10000005;\nconst int mo=998244353;\nint fac[N],inv[N],P2[N],n;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nvoid init(){\n\tfac[0]=inv[0]=inv[1]=P2[0]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) inv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n\tFor(i,1,N-1) P2[i]=2ll*P2[i-1]%mo;\n}\nint C(int x,int y){\n\tif (x<0||y<0||y>x) return 0;\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\tint ans=power(3,n);\n\tFor(i,n/2+1,n) ans=(ans+mo-2ll*P2[n-i]*C(n,i)%mo)%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n#define rep1(i,n) for (int i = 1; i <= int(n); i++)\n#define repR(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = int(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#ifdef LOCAL\n#define dump(...) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \", my_dmp(#__VA_ARGS__, __VA_ARGS__)\nvoid my_dmp(const char*) { cerr << endl; }\ntemplate <class T, class... U> void my_dmp(const char *s, T const& x, U const& ...y) { const char *o = \"({[\", *e = \"]})\"; for (int i = 0; *s != '\\0'; cerr << *s++) { if (count(o,o+3,*s)) i++; if (count(e,e+3,*s)) i--; if (!i && *s == ',') break; } cerr << \" = \" << x; if (*s == ',') cerr << \", \", s++; my_dmp(s, y...); }\n#else\n#define dump(...)\n#endif\nusing ll = long long;\nusing ld = long double;\n#define int ll\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { os << \"{\"; for (auto const& x : v) os << \" \" << x; return os << \" }\"; }\ntemplate <class T> istream& operator>>(istream& is, vector<T>& v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct my_Init { my_Init() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } my_init;\n\ntemplate <class T, size_t d, class = typename enable_if<(d == 0)>::type> constexpr auto make_v(T const& x = {}) { return x; }\ntemplate <class T, size_t d, class... U, class = typename enable_if<(d > 0)>::type> constexpr auto make_v(size_t n, U... x) { auto val = make_v<T,d-1>(x...); return vector<decltype(val)>(n, move(val)); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T> constexpr bool chmin(T& x, T const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T> constexpr bool chmax(T& x, T const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\nconst ll INF = (1LL<<62)-1; // ~ 4.6e18\n////////////////////////////////\n//\nusing ll = long long;\ntemplate <int M> // m : prime\nclass modint {\n    ll x;\n    struct Table {\n        // static const int Size = 1e6 + 10;\n        static const int Size = 1e7 + 10;\n        static_assert(Size <= M, \"\");\n        ll fac[Size], finv[Size], inv[Size];\n        Table() {\n            fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n            for (int i = 2; i < Size; i++) {\n                fac[i] = fac[i-1]*i % M;\n                inv[i] = M - inv[M%i]*(M/i) % M;\n                finv[i] = finv[i-1]*inv[i] % M;\n            }\n        }\n    };\n    static const Table tab;\npublic:\n    static modint fact(int n) { assert(0 <= n && n < Table::Size); return tab.fac[n]; }\n    static modint finv(int n) { assert(0 <= n && n < Table::Size); return tab.finv[n]; }\n    static modint C(int n, int k) {\n        if (n < 0 || k < 0 || n < k) return 0;\n        return fact(n)*finv(k)*finv(n-k);\n    }\n    static modint P(int n, int k) {\n        assert(n >= 0 && k >= 0 && n >= k);\n        return fact(n)*finv(n-k);\n    }\npublic:\n    modint(ll x = 0) : x((x%=M) < 0 ? x+M : x) { }\n    ll val() const { return x; }\n    bool operator==(modint rhs) const { return x == rhs.x; }\n    bool operator!=(modint rhs) const { return x != rhs.x; }\n    modint operator+() const { return *this; }\n    modint operator-() const { return {M-x}; }\n    modint& operator+=(modint rhs) { if ((x += rhs.x) >= M) x -= M; return *this; }\n    modint& operator-=(modint rhs) { if ((x += M-rhs.x) >= M) x -= M; return *this; }\n    modint& operator*=(modint rhs) { (x *= rhs.x) %= M; return *this; }\n    modint operator+(modint rhs) const { return modint(*this) += rhs; }\n    modint operator-(modint rhs) const { return modint(*this) -= rhs; }\n    modint operator*(modint rhs) const { return modint(*this) *= rhs; }\n    modint& operator/=(modint rhs) { return *this *= rhs.inv(); }\n    modint operator/(modint rhs) const { return *this * rhs.inv(); }\n    modint pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        modint v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n    modint inv() const {\n        assert(x != 0);\n        ll t = 1, v = x, q, r;\n        while (v >= Table::Size) {\n            q = M / v; r = M % v;\n            if (r * 2 < v) {\n                t *= -q; t %= M; v = r;\n            } else {\n                t *= q + 1; t %= M; v -= r;\n            }\n        }\n        return t * tab.inv[v] % M;\n    }\n};\ntemplate <int M> typename modint<M>::Table const modint<M>::tab;\ntemplate <int M> ostream& operator<<(ostream& os, modint<M> rhs) { return os << rhs.val(); }\ntemplate <int M> istream& operator>>(istream& is, modint<M> &rhs) { ll x; is >> x; rhs = x; return is; }\n\nconstexpr int MOD = 998244353;\nusing mint = modint<MOD>;\n//\n\n\nint32_t main() {\n    int n; cin >> n;\n    mint ans = mint(3).pow(n), p = 1;\n//    loop (k,n/2+1,<=n) ans -= mint::C(n,k)*mint(2).pow(n-k+1);\n    rep (k,n/2) p *= 2, ans -= mint::C(n,k)*p;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<FiniteField> factorials(n + 1);\n  vector<FiniteField> inverse_factorials(n + 1);\n\n  factorials[0] = inverse_factorials[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    factorials[i] = factorials[i - 1] * i;\n    inverse_factorials[i] = FiniteField(1) / factorials[i];\n  }\n\n  vector<FiniteField> two_powers(n + 1);\n  two_powers[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    two_powers[i] = two_powers[i - 1] * 2;\n  }\n\n  FiniteField z = 0;\n  for (int k = n / 2 + 1; k <= n; k++) {\n    z += factorials[n] * inverse_factorials[k] * inverse_factorials[n - k]\n        * two_powers[n - k];\n  }\n  \n  FiniteField ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans *= 3;\n  }\n  ans -= z * 2;\n  cout << ans.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\nll mod_pow(ll a,ll b){\n    a%=mod;\n    if(b==0)return 1;\n    if(b==1)return a;\n    ll res=mod_pow(a,b/2)%mod;\n    res*=res; res%=mod;\n    if(b%2)res*=a;\n    return res%mod;\n}\n\nstruct perm{\nprivate:\n    int sz;\n    vector<ll> p,invp;\npublic:\n    perm(int n){\n        sz=n+1;\n        p.resize(sz),invp.resize(sz);\n        p[0]=1;\n        for(int i=1;i<=sz-1;i++){\n            p[i]=p[i-1]*i%mod;\n        }\n        invp[sz-1]=mod_pow(p[sz-1],mod-2);\n        for(int i=sz-2;i>=0;i--){\n            invp[i]=invp[i+1]*(i+1)%mod;\n        }\n    }\n    ll comb(ll x,ll y){\n        if(x<y||y<0)return 0;\n        return (p[x]*invp[x-y]%mod)*invp[y]%mod;\n    }\n};\nperm p(1<<20);\n \nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    ll ans=mod_pow(3,n);\n    vector<ll> p2(n+1,1);\n    for(int i=0;i<n;i++){\n        p2[i+1]=p2[i]*2%mod;\n    }\n    for(int i=n/2+1;i<=n;i++){\n        ans-=p.comb(n,i)*p2[n-i]*2;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll MOD = 998244353;\n\nll calc_pow(ll x, ll pow) {\n    if (pow == 0) return 1;\n    ll a = calc_pow(x, pow / 2);\n    a = a * a % MOD;\n    if (pow % 2 == 1) a *= x;\n    return a % MOD;\n}\n\nll calc_div(ll a, ll b) {\n    return (a % MOD) * calc_pow(b, MOD - 2) % MOD;\n}\n\nvector<ll> fact;\n\nvoid init_fact(int n) {\n    fact = vector<ll>(n);\n    fact[0] = 1;\n    for (int i = 1; i < n; i++) fact[i] = fact[i - 1] * i % MOD;\n}\n\nll calc_comb(ll n, ll r) {\n    if (n < r)return 0;\n    return calc_div(fact[n], fact[r] * fact[n - r] % MOD);\n}\n\nint main() {\n    init_fact(1e7 + 1);\n\n    int n;\n    cin >> n;\n    ll ret = calc_pow(3, n);\n    for (int i = n; i > n / 2; i--) {\n        ll now = 2 * calc_comb(n, i) % MOD;\n        now *= calc_pow(2, n - i), now %= MOD;\n        ret += MOD - now, ret %= MOD;\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll inv[10000100];\nll FactorialInv[10000100];\nll Factorial[10000100];\nll beki(ll a, ll b){\n    a %= mod;\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    const int MAX = 10000002;\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nint main() {\n    init_combination();\n    ll N;\n    cin >> N;\n    ll Total = beki(3, N);\n    ll BAN = 0;\n    for(ll i = N / 2 + 1; i <= N; i++) {\n        ll now = combination(N, i);\n        now *= beki(2, N - i);\n        now %= mod;\n        BAN += now;\n    }\n    BAN *= 2;\n    ll ans = Total - BAN;\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=1e7+5;\nint fac[N],ifac[N],bin[N],n,res;\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=ifac[0]=1;fp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);fd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n\tbin[0]=1;fp(i,1,n+1)bin[i]=mul(bin[i-1],2);\n\tres=ksm(3,n);\n\tfp(i,(n>>1)+1,n)upd(res,P-mul(C(n,i),bin[n-i+1]));\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<Mod>;\n\n// 組み合わせ、階乗逆元\nvector<modint> fact, fact_inv;\n\nvoid COMinit(const ll MAX) {\n    fact.resize(MAX + 1);\n    fact_inv.resize(MAX + 1);\n    fact[0] = 1;\n    rep(i, MAX) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[MAX] = fact[MAX].inverse();\n    for(int i = MAX; i; i--)\n        fact_inv[i - 1] = fact_inv[i] * i;\n}\n\nmodint COM(const ll n, const ll k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n}\n\nmodint HCOM(const int &P, const int &Q) {\n    return (P == 0 && Q == 0) ? 1 : COM(P + Q - 1, Q);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N;\n\n    COMinit(N);\n\n    modint ans = modint(3).pow(N);\n    FOR(i, N / 2 + 1, N + 1)\n    ans -= modint(2).pow(N - i + 1) * COM(N, i);\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\n#define error(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconst int N = 1e7 + 20, mod = 998244353;\nint n, fac[N], inv[N];\n\ninline int pw (int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\n\treturn res;\n}\n\ninline int C (int n, int k)\n{\n\treturn 1ll * fac[n] * inv[k] % mod * inv[n - k] %mod;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = pw(fac[i], mod - 2);\n\t}\n\n\tcin >> n;\n\n\tans = pw(3, 2 * n);\n\n\tfor (int i = n; i <= 2 * n; i++)\n\t{\n\t\tint res = C(2 * n, i);\n\t\tres = 2 * res % mod;\n\n\t\tres = 1ll * res * pw(2, 2 * n - i) % mod;\n\n\t\tans = (ans + mod - res) % mod;\n\n\t}\n\t\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2020-02-18 19:26:26\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst int N=5e6+7;\nconst ll mod=998244353;\nint an[N];\nint main(){\n    int n; scanf(\"%d\",&n);\n    int m=n/2;\n    an[0]=1;\n    rep(i,1,m+1){\n        an[i] = an[i-1] * (m-i+1ll) % mod * powmod(i,mod-2,mod) % mod;\n    }\n    ll pw=1;\n    per(i,m+1,1){\n        an[i]=an[i]*pw%mod;\n        pw=pw*2%mod;\n    }\n    an[m+1]=0;\n    per(i,m+1,1){\n        an[i]=(an[i]+an[i+1])%mod;\n    }\n    ll c=1,p2=1,sum=0;\n    sum=an[1];\n    rep(i,1,m){\n        c = c * (m-i+1ll) % mod * powmod(i,mod-2,mod) % mod;\n        p2 = p2 * 2 % mod;\n        sum+=c * p2 % mod * an[i+1] % mod;\n        sum%=mod;\n    }\n    sum = sum * 2 % mod;\n    int ans=(powmod(3,n,mod) + mod - sum) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long MAX = 12000000;\nconst long MOD = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (long i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(long n, long k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nlong long powmod(long x,long p){\n  if(p==0)return 1;\n  if(p%2)return powmod(x,p-1)*x%MOD;\n  long long a=powmod(x,p/2);return a*a%MOD;\n}\nint main() {\n  COMinit();\n  long N;cin>>N;\n  long X=0;\n  for(long k=N/2+1;k<=N;k++){\n    X=(X+COM(N,k)*powmod(2,N-k))%MOD;\n  }\n  long ans=(powmod(3,N)-2*X+2*MOD)%MOD;\n  cout<<ans<<endl;\n}\n\n\n\n/*\n消去によって偶奇は変化しない\n偶A or 奇B -> X\n偶B or 奇A -> Y\nと変換すると\nXXとYYが消せないものになる\nどのような消し方をしてもXXが余ってしまうのは, X>N/2の時\n\nXがk個になる場合の数は\nnCk * 2^(N-k)\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define minus djsf\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint pw(int x, int y) {\n    \n    ll ans = 0;\n    int deg = 1;\n    for (int i=0; i < 30; ++i){\n        int ba = (1LL<<i)&y;\n        if (ba != 0){\n            ans += deg;\n        }\n        deg *= 2;\n        if (deg >= mod) deg -= mod;\n    }\n    \n\treturn ans%mod;\n}\n\nconst int N = 10000007;\n\nint fact[N], rev[N];\n\nint C(int n, int k) {\n\tint A = fact[n];\n\tint B = ((ll) rev[k] * rev[n-k]) % mod;\n\treturn ((ll) A * B) % mod;\n}\n \nsigned main()\n{\n#ifdef LOCAL\n\tfreopen(\"N_input.txt\", \"r\", stdin);\n\t//freopen(\"P_output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    fact[0] = 1;\n    for (int i=1; i < N; ++i) fact[i] = ((ll) fact[i-1] * i) % mod;\n    for (int i=0; i < N; ++i) rev[i] = pw(fact[i], mod-2);\n    \n\n    int n;\n    cin >> n;\n\n    int ans = pw(3, n);\n\n    for (int i=n/2+1; i <= n; ++i) {\n    \tint T = (2*C(n, i)) % mod;\n    \tT = ((ll) T * pw(2, n - i)) % mod;\n    \tans = (ans - T + mod) % mod;\n    }\n\n    cout << ans;\n\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=10000000+7;\nconst int mod=998244353;\nint inv[maxn];\nint finv[maxn];\nint fpow[maxn];\nint fthe[maxn];\nint ftwo[maxn];\nint n;\n\nint comb(int a,int b){\n    return (1ll*fpow[a]*finv[a-b]%mod*finv[b]%mod)%mod;\n}\n\nint main(){\n    fpow[0]=fpow[1]=1;\n    inv[1]=finv[1]=1;\n    inv[0]=finv[0]=1;\n    fthe[0]=1;fthe[1]=3;\n    ftwo[0]=1,ftwo[1]=2;\n    for(int i=2;i<maxn;i++){\n        inv[i]=(1ll*(mod-mod/i)*inv[mod%i])%mod;\n        finv[i]=(1ll*finv[i-1]*inv[i])%mod;\n        fpow[i]=(1ll*fpow[i-1]*i)%mod;\n        fthe[i]=(1ll*fthe[i-1]*3)%mod;\n        ftwo[i]=(1ll*ftwo[i-1]*2)%mod;\n    }\n    scanf(\"%d\",&n);\n    int p=n>>1;\n    int ans=0;\n    for(int i=p+1;i<=n;i++){\n        ans=(1ll*ans+1ll*2*comb(n,i)*ftwo[n-i]%mod)%mod;\n        //cout<<comb(n,i)<<\" \"<<ftwo[n-i]<<endl;\n    }\n    ans=(1ll*fthe[n]-1ll*ans+1ll*mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"O3\")\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <random>\n#include <cmath>\n\n#define sz(a) (int)((a).size())\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing namespace std; using ll = long long; using pii = pair<int, int>; using vi = vector<int>; using ld = long double;\n\nconst int mod = 998244353;\n\nll binpow(ll a, int p = mod - 2) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            (res *= a) %= mod;\n        }\n        p >>= 1;\n        (a *= a) %= mod;\n    }\n    return res;\n}\n\nconst int N = 1e7 + 1;\n\nll f[N], fr[N];\nll pw[N];\n\nll cnk(int n, int k) {\n    return f[n] * fr[k] % mod * fr[n - k] % mod;\n}\n\nint32_t main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n;\n    cin >> n;\n    f[0] = fr[0] = 1;\n    pw[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = f[i - 1] * i % mod;\n        fr[i] = binpow(f[i]);\n        pw[i] = pw[i - 1] * 2 % mod;\n    }\n    ll ans = binpow(3, n);\n    for (int i = n / 2 + 1; i <= n; i++) {\n        ll keks = cnk(n, i) * pw[n - i + 1] % mod;\n        ans = (ans - keks + mod) % mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = 998244353;\nconst int MX = TEN(7) + 10;\nll inv[MX], fact[MX], ifact[MX];\nll p2[MX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t}\n\tfact[0] = ifact[0] = p2[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tp2[i] = p2[i-1] * 2 % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tifact[i] = ifact[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int n, int r) {\n\tif (n < 0 || r < 0 || r > n) return 0;\n\treturn fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint main() {\n\tinit();\n\n\tint N; cin >> N;\n\tll all = 1;\n\trep(i, N) all = all * 3 % MOD;\n\tll ng = 0;\n\n\tfor (int i = N / 2 + 1; i <= N; ++i) {\n\t\tll a = comb(N, i) * p2[N-i] % MOD;\n\t\tng += a;\n\t\tif (ng >= MOD) ng -= MOD;\n\t}\n\n\tng = ng * 2 % MOD;\n\tall -= ng;\n\tif (all < 0) all += MOD;\n\tcout << all << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=10000000;\nconst int MOD=998244353;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\n\nint n;\n\nint inv[MAXN+1];\nint fac[MAXN+1];\nint ifac[MAXN+1];\nint p2[MAXN+1];\n\nint twoexact[MAXN/2+1];\nint oneexact[MAXN/2+1];\nint twoatleast[MAXN/2+1];\nint oneatleast[MAXN/2+1];\n\nint choose(int n,int k) { if(k<0||k>n) return 0; return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD; }\n\n\nint solvestupid() {\n\tint ret=0;\n\tREPE(x,n/2) REPE(y,n/2) {\n\t\tif(x<y) {\n\t\t\tFORE(z,y-x,n/2-x) {\n\t\t\t\tint cur=choose(n/2,x)*choose(n/2,y)*choose(n/2-x,z)*p2[n/2-y];\n\t\t\t\tprintf(\"x=%d y=%d z=%d -> %d\\n\",x,y,z,cur);\n\t\t\t\tret+=cur;\n\t\t\t}\n\t\t}\n\t\tif(y<x) {\n\t\t\tFORE(z,x-y,n/2-y) {\n\t\t\t\tint cur=choose(n/2,x)*choose(n/2,y)*choose(n/2-y,z)*p2[n/2-x];\n\t\t\t\tprintf(\"x=%d y=%d z=%d -> %d\\n\",x,y,z,cur);\n\t\t\t\tret+=cur;\n\t\t\t}\n\t\t}\n\t\tif(x==y) {\n\t\t\tint cur=choose(n/2,x)*choose(n/2,y)*p2[n-x-y];\n\t\t\tprintf(\"x=%d y=%d -> %d\\n\",x,y,cur);\n\t\t\tret+=cur;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint solve() {\n\tinv[1]=1; FORE(i,2,n) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,n) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,n) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\tp2[0]=1; FORE(i,1,n) p2[i]=(ll)p2[i-1]*2%MOD;\n\n\tREPE(i,n/2) twoexact[i]=(ll)p2[i]*choose(n/2,i)%MOD;\n\tREPE(i,n/2) oneexact[i]=(ll)p2[n/2-i]*choose(n/2,i)%MOD;\n\tfor(int i=n/2;i>=0;--i) twoatleast[i]=(twoexact[i]+(i+1<=n/2?twoatleast[i+1]:0))%MOD;\n\tfor(int i=n/2;i>=0;--i) oneatleast[i]=(oneexact[i]+(i+1<=n/2?oneatleast[i+1]:0))%MOD;\n\n\tint ret=0;\n\tREPE(x,n/2) {\n\t\tint yzways=(twoatleast[x]+MOD-oneatleast[x])%MOD;\n\t\t//printf(\"%d: %d (%d-%d)\\n\",x,yzways,twoatleast[x],oneatleast[x]);\n\t\tint cur=(ll)yzways*choose(n/2,x)%MOD*p2[n/2-x]%MOD;\n\t\tinc(ret,cur);\n\t\tinc(ret,cur);\n\t}\n\tREPE(x,n/2) {\n\t\tint cur=(ll)choose(n/2,x)*choose(n/2,x)%MOD*p2[n-2*x]%MOD;\n\t\tinc(ret,cur);\n\t}\n\treturn ret;\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0,i##_max=(N);i<i##_max;++i)\n#define repp(i,l,r) for(int i=(l),i##_max=(r);i<i##_max;++i)\n#define per(i,N) for(int i=(N)-1;i>=0;--i)\n#define perr(i,l,r) for(int i=r-1,i##_min(l);i>=i##_min;--i)\n#define all(arr) (arr).begin(), (arr).end()\n#define SP << \" \" <<\n#define SPF << \" \"\n#define SPEEDUP cin.tie(0);ios::sync_with_stdio(false);\n#define MAX_I INT_MAX //1e9\n#define MIN_I INT_MIN //-1e9\n#define MAX_UI UINT_MAX //1e9\n#define MAX_LL LLONG_MAX //1e18\n#define MIN_LL LLONG_MIN //-1e18\n#define MAX_ULL ULLONG_MAX //1e19\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<char,char> PCC;\ntypedef pair<ll,ll> PLL;\ntypedef pair<char,int> PCI;\ntypedef pair<int,char> PIC;\ntypedef pair<ll,int> PLI;\ntypedef pair<int,ll> PIL; \ntypedef pair<ll,char> PLC; \ntypedef pair<char,ll> PCL; \n\ninline void YesNo(bool b){ cout << (b?\"Yes\" : \"No\") << endl;}\ninline void YESNO(bool b){ cout << (b?\"YES\" : \"NO\") << endl;}\ninline void Yay(bool b){ cout << (b?\"Yay!\" : \":(\") << endl;}\n\ntemplate<int MOD> struct Fp {\n    ll val;\n    constexpr Fp(ll v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\n//const int MOD = 1e6 + 3;\n//const int MOD = 1e9 + 7;\nconst int N_MAX = 1e7+5;\n//mint:mod演算のための型\nusing mint = Fp<MOD>;\n//型変換\n#define MINT (mint)\n\n//mod MOD上での階乗\nmint fact[N_MAX];\nmint finv[N_MAX];\nvoid init(){\n  fact[0] = fact[1] = MINT 1;\n  for(int i = 2; i < N_MAX; i++){\n    fact[i] = fact[i-1] * i;\n  }\n  finv[N_MAX-1] = MINT 1/fact[N_MAX-1];\n  for(int i = N_MAX-1; i>0; --i){\n    finv[i-1] = finv[i] * i;\n  }\n}\n\n//mod MOD上での逆元\ninline mint inv(mint n){\n  return MINT 1/n;\n}\n\n//二項係数の計算(mod MOD上)\ninline mint COM(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[k]*finv[n-k];\n}\n\n//順列計算\ninline mint PER(int n, int k){\n  if(n<k) return 0;\n  if(k<0) return 0;\n  return fact[n]*finv[n-k];\n}\n\nint main(void){\n  SPEEDUP\n  cout << setprecision(15);\n  init();\n  int N;cin >> N;\n  mint ans = modpow(MINT 3, N);\n  repp(k,N/2+1,N+1){\n    ans -= MINT 2 * COM(N,k)*modpow(MINT 2,N-k);\n  }\n  cout << ans << endl;\n  return 0;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <algorithm>\n\nusing namespace std;\nusing lint = long long;\nconstexpr int MOD = 998244353, INF = 1010101010;\nconstexpr lint LINF = 1LL << 60;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\\n\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\ntemplate<int Modulo = MOD> struct Mint {\n\n\tlint val;\n\tconstexpr Mint(lint v = 0) noexcept : val(v % Modulo) { if (val < 0) v += Modulo; }\n\n\tconstexpr Mint& operator += (const Mint &r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= Modulo) val -= Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -= (const Mint &r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *= (const Mint &r) noexcept {\n\t\tval = val * r.val % Modulo;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator /= (const Mint &r) noexcept {\n\t\tlint a = r.val, b = Modulo, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlint t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % Modulo;\n\t\tif (val < 0) val += Modulo;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint operator + (const Mint &r) const noexcept { return Mint(*this) += r; }\n\tconstexpr Mint operator - (const Mint &r) const noexcept { return Mint(*this) -= r; }\n\tconstexpr Mint operator * (const Mint &r) const noexcept { return Mint(*this) *= r; }\n\tconstexpr Mint operator / (const Mint &r) const noexcept { return Mint(*this) /= r; }\n\n\tconstexpr int getmod() { return Modulo; }\n\tconstexpr Mint operator - () const noexcept { return val ? Modulo - val : 0; }\n\n\tconstexpr bool operator == (const Mint &r) const noexcept { return val == r.val; }\n\tconstexpr bool operator != (const Mint &r) const noexcept { return val != r.val; }\n\n\tfriend ostream &operator << (ostream &os, const Mint<Modulo> &x) noexcept { return os << x.val; }\n\tfriend istream &operator >> (istream &is, Mint<Modulo> &x) noexcept {\n\t\tlint tmp; is >> tmp;\n\t\tx = Mint<Modulo>(tmp);\n\t\treturn is;\n\t}\n\tfriend constexpr Mint<Modulo> modpow(const Mint<Modulo> &a, lint n) noexcept {\n\t\tMint res(1), tmp = a;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nusing mint = Mint<>;\n\ntemplate<class T>\nvector<T> make_vec(size_t s, T val) { return vector<T>(s, val); }\ntemplate<class... Size>\nauto make_vec(size_t s, Size... tail) {\n\treturn vector<decltype(make_vec(tail...))>(s, make_vec(tail...));\n}\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tauto dp = make_vec(N / 2 + 1, 9, mint(0));\n\tdp[1] = { 1,0,1,0,1,1,1,1,1 }; // AA AB AC BA BB BC CA CB CC\n\n\tfor (int i = 1; i < N / 2; i++) {\n\n\t\tmint sum = 0;\n\t\tfor (int j = 0; j < 9; j++) sum += dp[i][j]; // AB BA 以外を後ろにつける\n\t\tfor (int j = 0; j < 9; j++) if(j != 1 && j != 3) dp[i + 1][j] += sum;\n\n\t\t// 間に入れてAB BA ができる場合、それはそこまでで後ろにつける操作では実現不可能な並び\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tfor (int k = 0; k < 9; k++) {\n\n\t\t\t\tif (k == 1 || k == 3) continue;\n\t\t\t\tif (j / 3 + k / 3 * 3 == 1 || j / 3 + k / 3 * 3 == 3 ||\n\t\t\t\t\tj % 3 + k % 3 * 3 == 1 || j % 3 + k % 3 * 3 == 3) {\n\t\t\t\t\tdp[i + 1][j % 3 + k % 3 * 3] += dp[i][j];\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//DMP(dp);\n\n\tmint ans = 0;\n\tfor (int i = 0; i < 9; i++) ans += dp[N / 2][i];\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \n#define int long long\n#define ull unsigned long long\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << ' '\n#define print1(a) cout << (a) << '\\n'\n#define print2(a,b) cout << (a) << ' ',print1(b)\n#define print3(a,b,c) cout << (a) << ' ',print2(b,c)\n#define print4(a,b,c,d) cout << (a) << ' ',print3(b,c,d)\n#ifdef i_am_noob\n#define debug(a) print2(#a,a)\n#else\n#define debug(a) \n#endif\n#define ordered_set tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\n \ninline int add(int a, int b){return (a+b>=MOD?a+b-MOD:a+b);}\ninline int sub(int a, int b){return (a+MOD-b>=MOD?a-b:a+MOD-b);}\nint Pow(int a, int b){\n\tif(!b) return 1;\n\tint tmp=Pow(a*a%MOD,b>>1);\n\treturn (b&1?tmp*a%MOD:tmp);\n}\ninline int inverse(int n){return Pow(n,MOD-2);}\n \nconst int maxn=10000005;\n//i_am_noob\nint n,ans=0,fact[maxn],invfact[maxn];\n\nsigned main(){\n\tios_base::sync_with_stdio(0),cin.tie(0);\n\tfact[0]=1;\n\trep(maxn-1) fact[i+1]=fact[i]*(i+1)%MOD;\n\trep(maxn) invfact[i]=inverse(fact[i]);\n\tcin >> n;\n\tans=Pow(3,n);\n\trep2(i,n/2+1,n+1) ans=sub(ans,fact[n]*invfact[i]%MOD*invfact[n-i]%MOD*Pow(2,n-i)%MOD*2%MOD);\n\tprint1(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int LL;\ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n//////////////////////////\n\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 25000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\n\nint main(){fastio\n    calc();\n    ll n;cin>>n;\n    ll ans=po(3,n);\n    ll gen=0;\n    rep(a,n/2+1,n){\n        Add(gen,comb(n,a)*po(2,n-a));\n    }\n    cout<<mod(ans-gen*2)<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst ll MOD = 998244353;\n\nconst int SZ = 11234567;\nll inv[SZ];\nll fact[SZ];\nll fact_inv[SZ];\nll choose(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  return fact[n] * fact_inv[n-r] % MOD * fact_inv[r] % MOD;\n}\n\nll two[SZ];\n\n\nint main2() {\n  int N = nextInt();\n\n  ll ng = 0;\n  for (int i = N/2 + 1; i <= N; i++) {\n    ng += choose(N, i) * two[N - i] % MOD;\n    ng %= MOD;\n  }\n\n  ll ans = 1;\n  REP(i, N) ans = (ans * 3) % MOD;\n\n  ans -= (2 * ng) % MOD;\n  ans %= MOD;\n  ans += MOD;\n  ans %= MOD;\n\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n  inv[1] = 1;\n  for (int i = 2; i < SZ; i++) inv[i] = inv[(int) (MOD % i)] * (MOD - MOD / i) % MOD;\n  fact[0] = 1;\n  for (int i = 1; i < SZ; i++) fact[i] = fact[i-1] * i % MOD;\n  fact_inv[0] = 1;\n  for (int i = 1; i < SZ; i++) fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;\n  two[0] = 1;\n  for (int i = 1; i < SZ; i++) two[i] = two[i-1] * 2 % MOD;\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5e6 + 5, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint fact[N], inv[N];\n\nlong long C(int n, int k) {\n  if (k < 0 || n < k)\n    return 0;\n  return 1LL * (1LL * fact[n] * inv[k] % mod) * inv[n-k] % mod;\n}\n\nint main() {\n  fact[0] = inv[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fact[i] = 1LL * i * fact[i-1] % mod;\n  }\n  inv[N-1] = powmod(fact[N-1], mod-2);\n  for (int i = N-2; i > 0; --i) {\n    inv[i] = inv[i+1] * 1LL * (i + 1) % mod;\n  }\n  int n;\n  scanf(\"%d\", &n);\n  n /= 2;\n  long long ans = powmod(3, 2 * n);\n  long long sum = 0, pw2 = 2, pw = powmod(2, n), inv2 = inv[2];\n  for (int a = 1; a <= n; ++a) {\n    pw = (pw * inv2) % mod;\n    sum = (sum + 1LL * C(n, n+1-a) * pw2) % mod;\n    ans = (ans - sum * (C(n, a) * pw % mod)) % mod;\n    pw2 = (pw2 * 2) % mod;\n  }\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define INF 0x3f3f3f3f\n#define MOD 998244353\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n \n#define FOR(i, a, b) for (int i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (int i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 10000005\nll n;\nll dp[MN];\nll fac[MN];\n\nvoid modInvs(int n){\n    dp[0] = dp[1] = 1; \n    for (int i=2; i<=n; i++){\n        dp[i]=dp[MOD % i]*(MOD - MOD / i) % MOD;\n    }\n}\n\nll modExp(ll b, ll ex){\n    ll prod = 1;\n    while(ex > 0){\n        if(ex % 2 == 0){\n            b = (b * b) % MOD;\n            ex /= 2;\n        } else{\n            prod = (prod*b) % MOD;\n            ex--;\n        }\n    }\n    \n    return prod;\n}\n\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n    \n    modInvs(n);\n\n    ll sm = 0;\n    ll p2 = 1;\n    ll ch = 1;\n    FOR(i, 0, n/2-1){\n        sm += (p2*ch)%MOD;\n        sm %= MOD;\n        p2 = (p2*2)%MOD;\n        ch = ((ch*(n-i))%MOD)*dp[i+1];\n        ch %= MOD;\n    }\n\n    sm = (sm*2)%MOD;\n    ll pw = modExp(3, n);\n    cout << (pw-sm+MOD)%MOD << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=10000000,mod=998244353;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nvoid into(){\n  scanf(\"%d\",&n);\n}\n\nint inv[N+9],fac[N+9],ifac[N+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint ans;\n\nvoid Get_ans(){\n  ans=1;\n  for (int i=1;i<=n;++i) smul(ans,3);\n  int pw=2;\n  for (int i=n;i>=n+2>>1;--i) ssub(ans,mul(pw,Get_c(n,i))),smul(pw,2);\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll MOD = 998244353;\n\nll calc_pow(ll x, ll pow) {\n    if (pow == 0) return 1;\n    ll a = calc_pow(x, pow / 2);\n    a = a * a % MOD;\n    if (pow % 2 == 1) a *= x;\n    return a % MOD;\n}\n\nll calc_div(ll a, ll b) {\n    return (a % MOD) * calc_pow(b, MOD - 2) % MOD;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    ll ret = calc_pow(3, n), comb = 1;\n    for (int i = n; i > n / 2; i--) {\n        if (i < n)comb = calc_div(comb * (i + 1), n - i);\n        ll now = 2 * comb % MOD;\n        now *= calc_pow(2, n - i), now %= MOD;\n        ret += MOD - now, ret %= MOD;\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\n#define debug(x) cout << #x << \": \" << x << endl;\n#define ll long long\n#define mod 998244353\n\nll inv[10000099]; // ith index will store (1/i)%mod\nll finv[10000099]; // ith index will store (1/i!)%mod\nll fact[10000099]; // ith index will store (i!)%mod\nll pow2[10000099];\nint N;\nll Npow3 = 1;\n\nvoid populate(int n) {\n    fact[0] = fact[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    pow2[0] = 1;\n    pow2[1] = 2;\n    Npow3 = 3;\n\n    for(int i = 2;i <= n;i++) {\n        fact[i] = (i*fact[i-1])%mod;\n        inv[i] = mod-((inv[mod%i]*(mod/i))%mod);\n        finv[i] = (finv[i-1]*inv[i])%mod;\n        pow2[i] = (2*pow2[i-1])%mod;\n        Npow3 = (3*Npow3)%mod;\n    }\n}\n\nll prod(ll x, ll y) {\n  return (x*y)%mod;\n}\n\nll add(ll x, ll y) {\n  return (x+y)%mod;\n}\n\nint main() {\n  //freopen(\"input.in\",\"r\",stdin);\n  //freopen(\"output.out\",\"w\",stdout);\n  cin >> N;\n  populate(N);\n\n  N /= 2;\n\n  ll ans = 0;\n  for(int i = 1;i <= N;i++) {\n      ans = add(ans, prod(prod(fact[2*N], finv[N+i]), prod(finv[N-i], pow2[N-i])));\n  }\n\n  ans = (Npow3-2*ans)%mod;\n  ans = add(ans, mod);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n//\n// Created by kulikov on 10/17/2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_INPUT_H\n#define JHELPER_EXAMPLE_PROJECT_INPUT_H\n\n//\n// Created by egor on 30.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_GENERAL_H\n#define JHELPER_EXAMPLE_PROJECT_GENERAL_H\n\n\n\nusing namespace std;\n\ntypedef long long longint;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int MAX_INT = 2147483647;\n\nconst double PI = atan(1) * 4;\n\nconst int DX_KNIGHT[] = {2, 1, -1, -2, -2, -1, 1, 2};\nconst int DY_KNIGHT[] = {1, 2, 2, 1, -1, -2, -2, -1};\nconst int DX4[] = {1, 0, -1, 0};\nconst int DY4[] = {0, 1, 0, -1};\n\nbool isValidCell(int x, int y, int rows, int cols) {\n    return x >= 0 && y >= 0 && x < rows && y < cols;\n}\n\nvoid decreaseByOne() {\n}\n\ntemplate <typename T, class...Vargs>\nvoid decreaseByOne(vector<T>& arr, Vargs...arrs) {\n    for (int& i : arr) {\n        i--;\n    }\n    decreaseByOne(arrs...);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_GENERAL_H\n\n\nclass Input {\npublic:\n    enum ErrorType {\n        OK,\n        END_OF_FILE,\n        UNEXPECTED_SYMBOL,\n        INVALID_CALL\n    };\n\nprivate:\n    istream& in;\n    bool exhausted = false;\n    ErrorType error = OK;\n    int get();\n    template<typename T> T readInteger();\n    int skipWhitespace();\n\npublic:\n    Input(istream& in);\n    int readInt();\n    longint readLong();\n    string readString();\n    vector<int> readIntArray(int size);\n    template<typename T> T readType();\n    template<typename T> vector<T> readArray(int size);\n    template<typename T1, typename T2> tuple<vector<T1>, vector<T2> > readArrays(int size);\n    template<typename T1, typename T2, typename T3> tuple<vector<T1>, vector<T2>, vector<T3> > readArrays(int size);\n    template<typename T1, typename T2, typename T3, typename T4>\n        tuple<vector<T1>, vector<T2>, vector<T3>, vector<T4> > readArrays(int size);\n    template<typename T1, typename T2, typename T3, typename T4, typename T5>\n        tuple<vector<T1>, vector<T2>, vector<T3>, vector<T4>, vector<T5> > readArrays(int size);\n    template<typename T> vector<vector<T> > readTable(int rows, int cols);\n\n    string readLine();\n};\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nint Input::skipWhitespace() {\n    int c;\n    do {\n        c = get();\n        if (exhausted) {\n            error = END_OF_FILE;\n            return c;\n        }\n    } while (isWhitespace(c));\n    return c;\n}\n\nInput::Input(std::istream &in) : in(in) {\n}\n\ninline int Input::get() {\n    int result = in.get();\n    if (result == EOF) {\n        exhausted = true;\n    }\n    return result;\n}\n\ntemplate<typename T>\nT Input::readType() {\n    error = INVALID_CALL;\n    return nullptr;\n}\n\ntemplate<typename T>\nT Input::readInteger() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return 0;\n    }\n    int sgn = 1;\n    if (c == '-') {\n        sgn = -1;\n        c = get();\n    }\n    T res = 0;\n    do {\n        if (!isdigit(c)) {\n            error = UNEXPECTED_SYMBOL;\n            return 0;\n        }\n        res *= 10;\n        res += c - '0';\n        c = get();\n    } while (!isWhitespace(c));\n    return res * sgn;\n}\n\ntemplate<>\nint Input::readType() {\n    return readInteger<int>();\n}\n\ntemplate<>\nlongint Input::readType() {\n    return readInteger<longint>();\n}\n\ntemplate<>\nchar Input::readType() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return 0;\n    }\n    return c;\n}\n\ntemplate<>\nstring Input::readType() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return \"\";\n    }\n    vector<char> res;\n    do {\n        if (error != OK) {\n            return \"\";\n        }\n        res.push_back(c);\n    } while (!isWhitespace(c = get()));\n    return string(res.begin(), res.end());\n}\n\ninline int Input::readInt() {\n    return readType<int>();\n}\n\ninline longint Input::readLong() {\n    return readType<longint>();\n}\n\ntemplate<typename T>\nvector<T> Input::readArray(int size) {\n    vector<T> res;\n    res.reserve(size);\n    for (int i = 0; i < size; i++) {\n        res.push_back(readType<T>());\n        if (error != OK) {\n            res.clear();\n            return res;\n        }\n    }\n    return res;\n}\n\nvector<int> Input::readIntArray(int size) {\n    return readArray<int>(size);\n}\n\ntemplate<typename T1, typename T2>\ntuple<vector<T1>, vector<T2> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    v1.reserve(size);\n    v2.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n    }\n    return make_tuple(v1, v2);\n}\n\nstring Input::readString() {\n    return readType<string>();\n}\n\ntemplate<typename T>\nvector<vector<T>> Input::readTable(int rows, int cols) {\n    vector<vector<T> > result;\n    result.reserve(rows);\n    for (int i = 0; i < rows; ++i) {\n        result.push_back(readArray<T>(cols));\n    }\n    return result;\n}\n\nstring Input::readLine() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return \"\";\n    }\n    int length = 0;\n    vector<char> res;\n    do {\n        if (error != OK) {\n            return \"\";\n        }\n        res.push_back(c);\n        if (!isWhitespace(c)) {\n            length = res.size();\n        }\n        c = get();\n    } while (c != '\\n' && c != '\\r' && c != EOF);\n    return string(res.begin(), res.begin() + length);\n}\n\ntemplate<typename T1, typename T2, typename T3>\ntuple<vector<T1>, vector<T2>, vector<T3> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n    }\n    return make_tuple(v1, v2, v3);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename T4>\ntuple<vector<T1>, vector<T2>, vector<T3>, vector<T4> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    vector<T4> v4;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    v4.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n        v4.push_back(readType<T4>());\n    }\n    return make_tuple(v1, v2, v3, v4);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename T4, typename T5>\ntuple<vector<T1>, vector<T2>, vector<T3>, vector<T4>, vector<T5> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    vector<T4> v4;\n    vector<T5> v5;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    v4.reserve(size);\n    v5.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n        v4.push_back(readType<T4>());\n        v5.push_back(readType<T5>());\n    }\n    return make_tuple(v1, v2, v3, v4, v5);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_INPUT_H\n\n//\n// Created by egor on 31.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n#define JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n\n\n\nclass Output {\nprivate:\n    ostream& out;\n    template<typename T> void printSingle(const T& value);\n    template<typename T> void printSingle(const vector<T>& value);\n    template<typename T, typename U> void printSingle(const pair<T, U>& value);\n\npublic:\n    Output(ostream& out);\n    void print();\n    template<typename T, typename...Targs>void print(const T& first, const Targs... args);\n    template<typename...Targs>void printLine(const Targs... args);\n    void flush();\n};\n\nOutput::Output(ostream &out) : out(out) {\n    out << setprecision(12);\n}\n\nvoid Output::print() {\n}\n\ntemplate<typename T, typename... Targs>\nvoid Output::print(const T& first, const Targs... args) {\n    printSingle(first);\n    if (sizeof...(args) != 0) {\n        out << ' ';\n        print(args...);\n    }\n}\n\ntemplate<typename T>\nvoid Output::printSingle(const T& value) {\n    out << value;\n}\n\ntemplate<typename... Targs>\nvoid Output::printLine(const Targs... args) {\n    print(args...);\n    out << '\\n';\n}\n\nvoid Output::flush() {\n    out.flush();\n}\n\ntemplate<typename T>\nvoid Output::printSingle(const vector<T>& array) {\n    unsigned int size = array.size();\n    for (int i = 0; i < size; ++i) {\n        out << array[i];\n        if (i + 1 != size) {\n            out << ' ';\n        }\n    }\n}\n\ntemplate<typename T, typename U>\nvoid Output::printSingle(const pair<T, U>& value) {\n    out << value.first << ' ' << value.second;\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n\n//\n// Created by egor on 31.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_MODULO_H\n#define JHELPER_EXAMPLE_PROJECT_MODULO_H\n\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\nclass ModuloInt {\nprivate:\n    longint n;\n\npublic:\n    ModuloInt() : n(0) {}\n    ModuloInt(int n) {\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n    ModuloInt(const ModuloInt& n) = default;\n    ModuloInt& operator +=(const ModuloInt& other);\n    ModuloInt& operator -=(const ModuloInt& other);\n    ModuloInt& operator *=(const ModuloInt& other);\n    ModuloInt operator -();\n    friend ostream&operator <<(ostream& out, const ModuloInt& val);\n};\n\nModuloInt &ModuloInt::operator+=(const ModuloInt& other) {\n    n += other.n;\n    if (n >= mod) {\n        n -= mod;\n    }\n    return *this;\n}\n\nModuloInt &ModuloInt::operator-=(const ModuloInt& other) {\n    n -= other.n;\n    if (n < 0) {\n        n += mod;\n    }\n    return *this;\n}\n\nModuloInt &ModuloInt::operator*=(const ModuloInt& other) {\n    n *= other.n;\n    n %= mod;\n    return *this;\n}\n\nModuloInt operator +(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) += b;\n}\n\nModuloInt operator -(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) -= b;\n}\n\nModuloInt operator *(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) *= b;\n}\n\nostream& operator <<(ostream& out, const ModuloInt& val) {\n    return out << val.n;\n}\n\nModuloInt ModuloInt::operator-() {\n    if (n == 0) {\n        return 0;\n    }\n    return ModuloInt(mod - n);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_MODULO_H\n\n//\n// Created by egor on 01.11.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n#define JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n\n\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT power(const T& a, longint b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nvector<T> generateFactorial(int length) {\n    vector<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generateReverse(int length) {\n    vector<T> result(length);\n    if (length > 1) {\n        result[1] = 1;\n    }\n    for (int i = 2; i < length; i++) {\n        result[i] = -(mod / i) * result[mod % i];\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generatePowers(T base, int length) {\n    vector<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generateReverseFactorial(int length) {\n    auto result = generateReverse<T>(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] *= result[i - 1];\n    }\n    return result;\n}\n\ntemplate <typename T>\nclass Combinations {\nprivate:\n    vector<T> fact;\n    vector<T> revFactorial;\n\npublic:\n    Combinations(int length) {\n        fact = generateFactorial<T>(length);\n        revFactorial = generateReverseFactorial<T>(length);\n    }\n\npublic:\n    T c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return fact[n] * revFactorial[k] * revFactorial[n - k];\n    }\n\n    T factorial(int n) {\n        return fact[n];\n    }\n\n    T reverseFactorial(int n) {\n        return revFactorial[n];\n    }\n};\n\n#endif //JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n\n\nusing namespace std;\n\nclass CNeitherABNorBA {\npublic:\n\tvoid solve(std::istream& inp, std::ostream& outp) {\n        Input in(inp);\n        Output out(outp);\n\n        int n = in.readInt();\n\n        mod = MODF;\n        ModuloInt answer = power(ModuloInt(3), n);\n        Combinations<ModuloInt> c(n + 1);\n        auto pow = generatePowers(ModuloInt(2), n + 1);\n        n = n / 2;\n        vector<ModuloInt> qty(n + 1);\n        for (int i = 0; i <= n; i++) {\n            qty[i] = c.c(n, i) * pow[n - i];\n        }\n        vector<ModuloInt> sumQty(n + 1);\n        sumQty[n] = qty[n];\n        for (int i = n - 1; i >= 0; i--) {\n            sumQty[i] = qty[i] + sumQty[i + 1];\n        }\n        for (int i = 1; i <= n; i++) {\n            answer -= 2 * qty[i] * sumQty[n - i + 1];\n        }\n        out.printLine(answer);\n\t}\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\tCNeitherABNorBA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod=988244353;\n\nll n;\nll jiecheng[10000010];\n\nll power(ll a,ll b)\n{\n\tll res=1ll;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t{\n\t\t\tres*=a;\n\t\t\tres%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nvoid init()\n{\n\tjiecheng[0]=1ll;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tjiecheng[i]=jiecheng[i-1]*i%mod;\n\t}\n}\n\nll C(ll x,ll y)\n{\n\treturn (jiecheng[x]/(jiecheng[x-y]*jiecheng[y]));\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tinit();\n\tll ans=power(3ll,n);\n\tll tot=0;\n\tfor(ll i=n/2+1;i<=n;i++)\n\t{\n\t\ttot+=2ll*C(n,i)%mod*power(2ll,n-i)%mod;\n\t\ttot%=mod;\n\t}\n\tprintf(\"%lld\",ans-tot);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-15;\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n\nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\n#define MAX_N 10000001\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n\nusing mi = modint;\n\nmi mod_pow(ll a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int k = n / 2;\n    vector<ll> tmp(k + 1);\n    REP(i, k + 1) {\n        tmp[i] = mod_comb(k, i);\n        tmp[i] %= mod;\n    }\n    ll c = 1;\n    for(int i = k; i >= 0; i--) {\n        tmp[i] *= c;\n        tmp[i] %= mod;\n        c *= 2;\n        c %= mod;\n    }\n    vector<ll> acm(k + 1, 0);\n    acm[0] = tmp[0];\n    FOR(i, 1, k + 1) {\n        acm[i] += tmp[i] + acm[i - 1];\n        acm[i] %= mod;\n    }\n    mi ans = 1, sum = 0;\n    REP(i, n) ans *= 3;\n    for(int i = 0; i <= k; i++) {\n        ll t = tmp[i];\n        t *= (acm[k] - acm[k - i]);\n        sum += t;\n    }\n    cout << ans - 2 * sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n#define MOD 998244353\n\nint main()\n{\n  long long n;cin>>n;\n  long long i;\n  vector<long long> rev(n/2,1);\n  vector<long long> num(n/2,0);\n  long long left=MOD-2;\n  for(i=1;i<n/2;i++)\n  {\n    num.at(i)=i;\n  }\n  while(left!=0)\n  {    \n    if(left%2==1)\n    {\n      for(i=1;i<n/2;i++)\n      {\n        rev.at(i)=(rev.at(i)*num.at(i))%MOD;\n      }\n    }\n    left/=2;\n    for(i=1;i<n/2;i++)\n    {\n      num.at(i)=(num.at(i)*num.at(i))%MOD;\n    }\n  }\n  long long ans=1;\n  long long n3=3;\n  left=n;\n  while(left!=0)\n  {\n    if(left%2==1)\n    {\n      ans=(n3*ans)%MOD;\n    }\n    left/=2;\n    n3=(n3*n3)%MOD;\n  }\n  long long mina = 1;\n  long long minsum = 1;\n  for(i=1;i<n/2;i++)\n  {\n    mina =(mina*((n-i+1)*(rev.at(i)*2)%MOD)%MOD)%MOD;\n    minsum=(mina+minsum)%MOD;\n  }\n  ans=(ans+(MOD-minsum)*2)%MOD;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353, N = 1E7 + 5;\n\nint n;\nlong long ans = 1, pw[N], inv[N], fct[N], ifc[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n;\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\n    }\n    fct[0] = ifc[0] = pw[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fct[i] = fct[i - 1] * i % MOD;\n        ifc[i] = ifc[i - 1] * inv[i] % MOD;\n        pw[i] = pw[i - 1] * 2 % MOD;\n        (ans *= 3) %= MOD;\n    }\n    for (int i = n / 2 + 1; i <= n; i++) {\n        long long cur = fct[n] * ifc[i] % MOD * ifc[n - i] % MOD;\n        (cur *= pw[n - i] * 2) %= MOD;\n        (ans += MOD - cur) %= MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(v) ((int)(v).size())\nconst int MAXN = 10000005;\nconst int mod = 998244353;\nusing lint = long long;\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nlint fact[MAXN], invf[MAXN], pwr[MAXN];\n\nlint binom(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x-y] % mod) % mod;\n}\n\nint main() { \n\tint n; cin >> n;\n\tfact[0] = pwr[0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tpwr[i] = (pwr[i-1] << 1) % mod;\n\t\tfact[i] = fact[i-1] * i % mod;\n\t}\n\tinvf[n] = ipow(fact[n], mod - 2);\n\tfor(int i=n-1; i>=0; i--){\n\t\tinvf[i] = invf[i + 1] * (i + 1) % mod;\n\t}\n\tlint ans = 0;\n\tfor(int i=0; i<n/2; i++){\n\t\tans += pwr[i+1] * binom(n, i) % mod;\n\t}\n\tans %= mod;\n\tans = ipow(3, n) - ans + mod;\n\tcout << ans % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long ipow(long long a, long long b)\n{\n    if(b==0) return 1;\n    long long ans = ipow(a, b/2);\n    ans = ans*ans%MOD;\n    if(b%2==1) ans=ans*a%MOD;\n    return ans;\n}\nlong long fact(int N)\n{\n    long long ret = 1;\n    for(int i=1; i<=N; ++i) ret=ret*i%MOD;\n    return ret;\n}\nint solve(int N)\n{\n    long long ans = ipow(3, N);\n\n    long long nCk = fact(N)*ipow(fact(N/2), 2*(MOD-2))%MOD;;\n    for(int k=N/2+1; k<=N; ++k)\n    {\n        nCk = nCk * ipow(k, MOD-2)%MOD*(N-k+1)%MOD;\n        ans -= 2*nCk*ipow(2, N-k);\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    int N; scanf(\"%d\", &N);\n    printf(\"%d\\n\", solve(N));\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 998244353;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 1e7 + 5;\n\nint F[N], I[N];\n\nint Power(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1LL * a * a % MOD) if (b & 1) res = 1LL * res * a % MOD;\n\treturn res;\n}\nint C(int n, int r) { \n\tif (n < 0 || n < r) return 0;\n\treturn 1LL * I[r] * I[n - r] % MOD * F[n] % MOD;\n}\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tF[0] = 1;\n\tfor (int i = 1; i < N; i++) F[i] = 1LL * i * F[i - 1] % MOD;\n\tI[N - 1] = Power(F[N - 1], MOD - 2);\n\tfor (int i = N - 1; i > 0; i--) I[i - 1] = 1LL * i * I[i] % MOD;\n\n\tint n; cin >> n;\n\tint ans = Power(3, n);\n\tfor (int i = n / 2 + 1; i <= n; i++) ans = (ans - 2LL * C(n, i) * Power(2, n - i) % MOD + MOD) % MOD;\n\tcout << ans << endl;\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n\nusing namespace std;\n\nconst int N=1e7+10,mod=998244353;\nint n,fac[N],inv[N],pw[N],ans;\n\nint C(int n,int m){\n\treturn (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nvoid upd(int &x,int y){x+=y; x-=x>=mod?mod:0;}\n\nint ksm(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=(ll)x*x%mod) if (y&1) s=(ll)s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tfac[0]=1;\n\trep (i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor (int i=n;i;i--) inv[i-1]=(ll)inv[i]*i%mod;\n\tpw[0]=1;\n\trep (i,1,n) pw[i]=(ll)pw[i-1]*2%mod;\n}\n\nint main(){\n\tscanf(\"%d\",&n); init(n);\n\trep (i,n/2+1,n) upd(ans,(ll)C(n,i)*pw[n-i]%mod);\n\tprintf(\"%lld\\n\",(ksm(3,n)+mod-ans*2ll%mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int MAXN = 1.01e7;\nvll fact (MAXN);\nvll invfact (MAXN);\nvll pow2(MAXN);\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    fact[0] = 1;\n    FOR(i, 1, N+1) fact[i] = fact[i-1] * i % MOD;\n\n    invfact[0] = 1;\n    FOR(i, 1, N+1) invfact[i] = invfact[i-1] * inverse(i) % MOD;\n\n    pow2[0] = 1;\n    FOR(i, 1, N+1) pow2[i] = 2 * pow2[i-1] % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * pow2[N-i];\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//c++ -std=gnu++14 a.cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\n#include <random>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n#define sz(x) ((int)(x).size())\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\n//int MOD = 1000000007;\ndouble EPS = 1e-10;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 10000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nint power[10000010];\nvoid solve(){\n  ll N;\n  cin >> N;\n  COMinit();\n  power[0] = 1;\n  for(ll i = 1; i <= N; i++) power[i] = power[i-1] * 2 % MOD;\n  int ans = pow_mod(3, N);\n\n  for(ll i = N/2 + 1; i <= N; i++){\n    ans += MOD - comb(N, i) * power[N-i+1] % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbg() cerr << \n#define show(x) (#x) << \": \" << (x) <<\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nvoid Add(int &a, int b) {\n  a += b;\n  while (a >= MOD) a -= MOD;\n  while (a < 0) a += MOD;\n}\n\nvoid Mul(int &a, int b) {\n  a = 1LL * a * b % MOD;\n}\n\nint Pow(int b, int e) {\n  if (e < 0) e += MOD - 1;\n  int ret = 1;\n  while (e) {\n    if (e & 1) ret = 1LL * ret * b % MOD;\n    b = 1LL * b * b % MOD;\n    e >>= 1;\n  }\n  return ret;\n}\n\nnamespace Math {\n  const int NMAX = (int)1e7;\n  int pow2[1 + NMAX];\n  int fact[1 + NMAX], tcaf[1 + NMAX];\n  void Precalc() {\n    fact[0] = pow2[0] = 1;\n    for (int i = 1; i <= NMAX; ++i) {\n      pow2[i] = pow2[i - 1];\n      Add(pow2[i], pow2[i]);\n\n      fact[i] = fact[i - 1];\n      Mul(fact[i], i);\n    }\n    tcaf[NMAX] = Pow(fact[NMAX], -1);\n    for (int i = NMAX - 1; i >= 0; --i) {\n      tcaf[i] = tcaf[i + 1];\n      Mul(tcaf[i], i + 1);\n      assert(1LL * fact[i] * tcaf[i] % MOD == 1);\n    }\n  }\n  int Choose(int n, int k) {\n    if (k > n || n < 0) return 0;\n    return 1LL * fact[n] * tcaf[n - k] % MOD * tcaf[k] % MOD;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n\n  Math::Precalc();\n  int n; cin >> n;\n  int ans = Pow(3, n);\n  for (int freq = n / 2 + 1; freq <= n; ++freq) {\n    Add(ans, -2LL * Math::Choose(n, freq) * Math::pow2[n - freq] % MOD);\n  }\n  cout << ans << endl;\n\n  cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate<class T> ostream& prnt(ostream& out, T v) { out << v.size() << '\\n'; for(auto e : v) out << e << ' '; return out;}\ntemplate<class T> ostream& operator<<(ostream& out, vector <T> v) { return prnt(out, v); }\ntemplate<class T> ostream& operator<<(ostream& out, set <T> v) { return prnt(out, v); }\ntemplate<class T1, class T2> ostream& operator<<(ostream& out, map <T1, T2> v) { return prnt(out, v); }\ntemplate<class T1, class T2> ostream& operator<<(ostream& out, pair<T1, T2> p) { return out << '(' << p.st << ' ' << p.nd << ')'; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << \" \" << H; debug_out(T...);}\n#define dbg(...) cerr << #__VA_ARGS__ << \" ->\", debug_out(__VA_ARGS__)\n#define dbg_v(x, n) do{cerr<<#x\"[]: \";for(int _=0;_<n;++_)cerr<<x[_]<<\" \";cerr<<'\\n';}while(0)\n#define dbg_ok cerr<<\"OK!\\n\"\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define pii pair<int,int>\n#define MOD 998244353\n#define zeros(x) x&(x-1)^x\n#define fi first\n#define se second\n#define Nmax 1000005\nconst long double PI = acos(-1);\n\nint n,x;\nint A[Nmax],S[Nmax],B[Nmax],S2[Nmax], P2[Nmax];\n\ntemplate<typename T = long long>\nT _pow(T a, T b){\n    T ans = 1;\n    for (; b; b >>= 1){\n        if (b % 2) ans = ans * a % MOD;\n        a = a * a % MOD;\n    }\n    return ans;\n}\n\nlong long P[Nmax], inv[Nmax];\ntemplate<typename T = long long>\nT comb(T n, T m){\n    if (P[1] == 0) cerr << \"Apeleaza functia prec!\\n\";\n    return P[n] * inv[m] % MOD * inv[n-m] % MOD;\n}\n\ntemplate<typename T = long long>\ninline void add(T &a, T b){\n    a += b;\n    if (a >= MOD) a -= MOD;\n    if (a < 0) a += MOD;\n}\n\nvoid prec(int n = Nmax-1){\n    P[0] = inv[0] = 1;\n    for (int i=1;i<=n;i++){\n        P[i] = P[i-1] * i % MOD;\n        inv[i] = _pow(P[i], MOD - 2LL);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    prec();\n\n    cin >> n;\n    int x = n / 2;\n\n    P2[0] = 1;\n    for (int i=1;i<=n;i++){\n        P2[i] = 1LL * P2[i-1] * 2 % MOD;\n    }\n\n    for (int i=1;i<=x;i++){\n        A[i] = comb(x,i);\n    }\n    for (int i=x;i>=1;i--){\n        add(S[i], S[i+1]);\n        add(S[i], A[i]);\n        S2[i] = (S2[i+1] + 1LL * A[i] * P2[x-i]) % MOD;\n    }\n\n    int ans = 0;\n    for (int i=1;i<=x;i++){\n        int y = (x+1) - i;\n        // dbg(i,A[i],P2[x-i],S2[y]);\n        ans = (ans + 1LL * A[i] * P2[x-i] % MOD * S2[y]) % MOD;\n    }\n\n        // dbg(ans);\n    ans = ans * 2 % MOD;\n    ans = (1LL * _pow(3LL,1LL*n) - ans + MOD) % MOD;\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n\n#include<cmath>\n#include<functional>\n#include<algorithm>\n\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<set>\n#include<unordered_set>\n#include<map>\n#include<unordered_map>\n#include<bitset>\n#include<tuple>\n\n#define TEST {IS_TEST=true;}\n\nusing namespace std;\nusing ll = int_fast64_t;\nusing v_bool = vector <bool>;\nusing v_ll = vector <ll>;\nusing v_std = vector <string>;\nusing p_ll = pair <ll,ll>;\nusing vv_ll = vector <vector <ll> >;\nusing vp_ll = vector < p_ll >;\n\nusing ld = long double;\nusing v_ld = vector <ld>;\nusing vv_ld = vector<v_ld>;\n\nbool IS_TEST=false;\nll ll_min=1LL<<63;\nll ll_max=~ll_min;\nll int_min=1LL<<31;\nll int_max=~ll_max;\nll MOD = 1000000007;\n\ntemplate<class T>\nvoid show(const T &x){\n  if (!IS_TEST) return;\n  cout << x << endl;\n}\ntemplate<class T1,class T2>\nvoid show(const pair<T1,T2> &x){\n  if (!IS_TEST) return;\n  cout << \"{\" << x.first << \",\" << x.second << \"}\" << endl;\n}\n\ntemplate<class T>\nvoid show_sub(const T &x){if (!IS_TEST) return; cout << x;}\nvoid show_sub(const string &x){if (!IS_TEST) return; cout << x << endl;}\ntemplate<class T1,class T2>\nvoid show_sub(const pair<T1,T2> &x){\n  if (!IS_TEST) return;\n  cout << \"{\" << show_sub(x.first) << \",\" << show_sub(x.second) << \"}\";\n}\ntemplate<class T>\nvoid v_show(const T &v){\n  if (!IS_TEST) return;\n  auto itr=v.begin();\n  while(itr!=v.end()){ show_sub(*itr); itr++;}\n  cout << endl;\n}\n\ntemplate<class T>\nvoid vv_show(const T &v){\n  if (!IS_TEST) return;\n  cout << \"--------------------------------\\n\";\n  auto itr=v.begin();\n  while(itr!=v.end()){ v_show(*itr); itr++;}\n  cout << \"--------------------------------\" << endl;\n}\n\n\n\nll max(ll x,ll y){return x>y?x:y;}\nll max(ll x,ll y, ll z){return max(max(x,y),z);}\nll max(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=max(ans,*b);b++;}\n    return ans;\n}\nll min(ll x,ll y){return x<y?x:y;}\nll min(ll x,ll y, ll z){return min(min(x,y),z);}\nll min(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=min(ans,*b);b++;}\n    return ans;\n}\nll mid(ll x,ll y,ll z){\n    if (y>=x && x>=z) return x;\n    if (z>=x && x>=y) return x;\n    if (x>=y && y>=z) return y;\n    if (z>=y && y>=x) return y;\n    if (x>=z && z>=y) return z;\n    if (y>=z && z>=x) return z;\n    return x;\n}\nll gcd(ll x,ll y){\n    if(x<0)x=-x; if(y<0)y=-y;\n    while(y>0){ x%=y; swap(x,y); }\n    return y;\n}\nll gcd(ll x,ll y, ll z){return gcd(gcd(x,y),z);}\nll gcd(v_ll::iterator b,v_ll::iterator e){\n    ll ans=0;\n    while (b<e) ans=gcd(ans,*b);\n    return ans;\n}\nll lcm(ll x,ll y){\n    ll z=x*y; if(x<0)x=-x; if(y<0)y=-y;\n    while(y>0){ x%=y; swap(x,y); }\n    return z/y;\n}\nll lcm(ll x,ll y, ll z){return lcm(lcm(x,y),z);}\nll lcm(v_ll::iterator b,v_ll::iterator e){\n    ll ans=1;\n    while (b<e) ans=lcm(ans,*b);\n    return ans;\n}\n\nv_ll arange(ll n){\n    v_ll v(n+1,0);\n    for(ll i=0;i<=n;i++)v[i]=i;\n    return v;\n}\n\nll vec_sum(const v_ll& v,ll b,ll e){\n    ll ans=0;\n    for(ll i=b;i<e;i++)ans+=v[i];\n    return ans;\n}\nll v_sum(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans+=*b; b++;}\n    return ans;\n}\nll v_xor(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans^=*b; b++;}\n    return ans;\n}\nll v_eq(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) { ans^=~*b; b++;}\n    return ans;\n}\n\n\ntemplate<class T> void refl_max(T& x,const T& y){ if (x>=y) return; x=y; }\ntemplate<class T> void refl_min(T& x,const T& y){ if (x<=y) return; x=y; }\n\ntemplate<class T,class S> void refl_max(T& x,S& xx,const T& y,const S& yy){\n  if (x>=y) return; x=y; xx=yy;\n}\ntemplate<class T,class S> void refl_min(T& x,S& xx,const T& y,const S& yy){\n  if (x<=y) return; x=y; xx=yy;\n}\n\ntemplate<class T> void quit(T x){cout << x << endl; exit(0);}\n\n/*O(logN)*/\nll sqrt_ll(ll n){\n  assert(n>=0);\n  ll ok = 0,ng = n+1;\n  while(ok-ng>1||ng-ok>1){ ll m=(ok+ng)/2; if (m*m<=n) ok=m; else ng=m;}\n  return ok;\n}\n\nclass ModInt{\n  public:\n  static ll modulus;\n  ll val;\n  ModInt(ll n=0){ val=n%modulus; if (val<0) val+=modulus;}\n  ModInt operator +(const ModInt& rhs)const{ return val+rhs.val;}\n  ModInt operator -(const ModInt& rhs)const{ return val-rhs.val;}\n  ModInt operator *(const ModInt& rhs)const{ return val*rhs.val;}\n  ModInt& operator +=(const ModInt& rhs){val+=rhs.val; if (val>=modulus)val-=modulus; return *this;}\n  ModInt& operator -=(const ModInt& rhs){val-=rhs.val; if (val<modulus)val+=modulus; return *this;}\n  ModInt& operator *=(const ModInt& rhs){val*=rhs.val; val%=modulus; return *this;}\n  ModInt pow(ll a)const{\n    a%=(modulus-1); if (a<0)a+=(modulus-1);\n    ModInt ret(1); ModInt vv(val);\n    while (a!=0){ if (a&1) ret*=vv; a>>=1; vv*=vv;}\n    return ret;\n  }\n  ModInt inv()const{return pow(-1);}\n  ModInt operator /(const ModInt& rhs)const{ return *this*rhs.pow(-1);}\n  ModInt& operator /=(const ModInt& rhs){ *this*=rhs.pow(-1); return *this;}\n};\nistream& operator >> (istream& istr, ModInt &rhs){istr >> (rhs.val); return istr;};\nostream& operator << (ostream& ostr, const ModInt &rhs){ostr << (rhs.val); return ostr;};\nvector<ModInt> mod_nck(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*(n+1-i)/i;\n  return v;\n}\nvector<ModInt> mod_pow(ModInt base, ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*base;\n  return v;\n}\nvector<ModInt> mod_npk(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*(n+1-i);\n  return v;\n}\nvector<ModInt> mod_fact(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=1;i<=n;i++) v[i]=v[i-1]*i;\n  return v;\n}\nvector<ModInt> mod_nck_2(ll n,ll k){\n  vector<ModInt> v(n+1,1);\n  for (ll i=k+1;i<=n;i++) v[i]=v[i-1]*i/(i-k);\n  return v;\n}\nvector<ModInt> mod_calc(ll n){\n  vector<ModInt> v(n+1,1);\n  for (ll i=n-1;i>=0;i--) v[i]=v[i+1]*(i+1);\n  return v;\n}\n\nll ModInt::modulus=998244353;\n\nll N;\n\nint main(){\n  cin >> N;\n  vector<ModInt> calc=mod_calc(N);\n  vector<ModInt> pow2=mod_pow(2,N);\n  ModInt exc=1;\n  for(ll b=1;b<=N;b++){\n    exc*=b;\n  }\n  ModInt ans=0;\n  ModInt ans2=ModInt(3).pow(N);\n  //ModInt p=ModInt(1);\n  for(ll b=0;b<N/2;b++){\n    ans+=calc[b]*calc[N-b]*pow2[b];\n  }\n  ans*=exc.inv();\n  ans*=ModInt(2);\n\n  cout << ans2-ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD (ll)(1e9 + 7)\n#define MAX (ll)(2e5 + 4)\n#define INF (ll)(1e9)\nusing namespace std;\nusing ll =  long long;\nusing ld = long double;\n\nint la = 0, ra = MOD;\n\nbool ch (pair<int, int> p1, pair<int, int> p2) {\n\tif (max (p1.second - la, 0) != max (p2.second - la, 0)) {\n\t\treturn max (p1.second - la + 1, 0) < max (p2.second - la + 1, 0);\n\t}\n\treturn max (ra - p1.first + 1, 0) > max (ra - p2.first + 1, 0);\n}\n\nint main () {\n\tint n;\n\tcin >> n;\n\tint mal = 0, mir = 0;\n\tvector<pair<int, int>> vp;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tla = max (l, la);\n\t\tra = min (r, ra);\n\t\tvp.push_back (make_pair (l, r));\n\t\tans = max (ans, r - l + 1);\n\t\tif (i && l > vp[i].first) {\n\t\t\tmal = i;\n\t\t}\n\t\tif (i && r < vp[i].second) {\n\t\t\tmir = i;\n\t\t}\n\t}\n\tsort (vp.begin (), vp.end (), ch);\n\tint ar[n] = {}, br[n] = {}, l = 1, r = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tl = max (vp[i].first, l), r = min (vp[i].second, r);\n\t\tar[i] = r - l + 1;\n\t\tif (ar[i] <= 0) {\n\t\t\tar[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tl = 1, r = INF;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tl = max (vp[i].first, l), r = min (vp[i].second, r);\n\t\tbr[i] = r - l + 1;\n\t\tif (br[i] <= 0) {\n\t\t\tbr[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tans = max (ans, ar[i] + br[i + 1]);\n\t}\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll mpower(ll a,ll b,ll c){\n  int z;\n  if(b==0){\n    z=1;\n    z%=c;\n    return z;\n  }\n  if(b==1){\n    z=a;\n    z%=c;\n    return z;\n  }\n  else{\n    return (((mpower(a,b/2,c))*(mpower(a,b/2,c))%c)*mpower(a,b%2,c)%c);\n  }\n}\n\nconst int MAX = 10000500;\nconst int MOD = 998244353;\nll fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<MAX;i++){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n \n// 二項係数計算\nll COM(int n,int k){\n    if(n<k) return 0;\n    if(n<0||k<0) return 0;\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n \nint main(){\n  COMinit();\n  ll mod=998244353;\n  ll x;\n  cin>>x;\n  ll ans=mpower(3,x,mod);\n  ll p=0,q=1;\n  for(int i=x/2+1;i<=x;i++){\n    q=COM(x,i);\n    q*=mpower(2,x-i,mod);\n    q%=mod;\n    p+=q;\n    p%=mod;\n  }\n  ans-=2*p;\n  while(ans<0){\n    ans+=mod;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 998244353;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\nconst mint THREE = mint(3);\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\tconst mint total = THREE.power(n);\n\n\tmint cur = ZERO, coef = ONE;\n\n\tfor(int i = n; i > n / 2; --i){\n\t\tcur += coef;\n\t\tcoef *= mint(i);\n\t\tcoef /= mint(n + 1 - i);\n\t\tcoef *= TWO;\n\t}\n\n\tconst mint ans = total - TWO * cur;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {\n        assert(num >= 0 && num < MOD);\n    }\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>() || is_same<T,modint>(), \"T is not integral.\");\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=998244353;\nconst int N=10000050;\nint F[N],I[N],po2[N],po3[N];\nint binom(int n, int k){ return (ll)F[n]*I[k]%mod*I[n-k]%mod;}\nint main()\n{\n\tint n;\n\tscanf(\"%i\",&n);\n\tF[0]=1;for(int i=1;i<=n;i++) F[i]=(ll)F[i-1]*i%mod;\n\tI[0]=I[1]=1;for(int i=2;i<=n;i++) I[i]=mod-(ll)(mod/i)*I[mod%i]%mod;\n\tfor(int i=1;i<=n;i++) I[i]=(ll)I[i]*I[i-1]%mod;\n\tpo2[0]=po3[0]=1;for(int i=1;i<=n;i++) po2[i]=(ll)po2[i-1]*2%mod,po3[i]=(ll)po3[i-1]*3%mod;\n\tint ans=po3[n];\n\tfor(int i=n/2+1;i<=n;i++)\n\t{\n\t\tint tmp=(ll)binom(n,i)*po2[n-i]%mod;\n\t\tans-=tmp*2%mod;\n\t\tif(ans<0) ans+=mod;\n\t}\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long i64;\ninline int rd(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e7+5, P = 998244353;\nint n, ans, pw[N]; i64 iv[N]; void fix(int &x) { x<P?0:x-=P; }\nint main()\n{\n    n = rd(); pw[0] = iv[1] = 1, pw[1] = 2, ans = 3; \n    for(int i = 2; i <= n; ++i) ans = ans*3ll%P, iv[i] = P-(P/i)*iv[P%i]%P, fix(pw[i]=pw[i-1]<<1);\n    ans = P-ans; for(int i = 0, m = n>>1, v = 1, w = 0; i <= m; ++i) \n        fix(w += (i64)v*pw[m-i]%P), fix(ans += (i64)v*w%P*pw[i+1]%P), v = v*iv[i+1]%P*(m-i)%P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e7 + 9;\nconst int mod = 998244353;\nint fac[maxn];\nint inv[maxn];\nint power[maxn];\n\nint modpow(int base, int exponent) {\n  int var = base;\n  int ans = 1;\n  while(exponent > 0) {\n    if(exponent & 1) {\n      ans = (1LL * ans * var) % mod;\n    }\n    var = (1LL * var * var) % mod;\n    exponent >>= 1;\n  }\n  return ans;\n}\nint nCr(int n, int r) {\n  int num = fac[n];\n  int den = (1LL * inv[r] * inv[n - r]) % mod;\n  return (1LL * num * den) % mod;\n}\nint main() {\n  int n;\n  cin >> n;\n  fac[0] = power[0] = 1;\n  for(int i = 1; i <= n; i++) {\n    fac[i] = (1LL * fac[i - 1] * i) % mod;\n    power[i] = (power[i - 1] * 2LL) % mod;\n  }\n  inv[n] = modpow(fac[n], mod - 2);\n  for(int i = n - 1; i >= 0; i--) {\n    inv[i] = (1LL * inv[i + 1] * (i + 1)) % mod;\n  }\n  int ans = modpow(3, n);\n  for(int i = (n / 2) + 1; i <= n; i++) {\n    ans -= (1LL * power[n - i + 1] * nCr(n, i)) % mod; \n    ans %= mod;\n  }\n  cout << (ans + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\n//mod-int構造体\n//計算量 加減乗算:O(1)、除算:O(log(MOD))、K乗:O(log(K))\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int operator -() const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow (ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse () const{\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e7;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*mint(i);\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N-1, 0){\n        ifac[i] = ifac[i+1]*(i+1);\n    }\n}\n\nmint comb(mint n, mint k){\n    return fac[n.x]*ifac[n.x-k.x]*ifac[k.x];\n}\n\nmint perm(mint n, mint k){\n    return fac[n.x]*ifac[n.x-k.x];\n}\n\nint main(){\n    int N;\n    cin >> N;\n    init();\n    mint tw = 2, th = 3, ans = th.pow(N), now = 1;\n    rep(i, N/2){\n        now *= 2;\n        ans -= comb(N, i)*now;\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define maxn 10000005\n#define tt 998244353\n#define LL long long\nusing namespace std;\nint n,ans,fac[maxn],inv[maxn];\ninline int C(int n,int m){return (LL)fac[n]*inv[m]%tt*inv[n-m]%tt;}\ninline int qsm(int a,int b){\n\tint s=1,w=a%tt;\n\twhile (b){\n\t\tif (b&1) s=(LL)s*w%tt;\n\t\tw=(LL)w*w%tt;\n\t\tb>>=1;\n\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=(LL)fac[i-1]*i%tt;\n\tinv[1]=1;for (int i=2;i<=n;i++) inv[i]=(LL)inv[tt%i]*(tt-tt/i)%tt;\n\tinv[0]=1;for (int i=1;i<=n;i++) inv[i]=(LL)inv[i-1]*inv[i]%tt;\n\tans=qsm(3,n);\n\tfor (int i=n/2+1;i<=n;i++) ans=(ans-(LL)2*C(n,i)*qsm(2,n-i)%tt)%tt;\n\tprintf(\"%d\\n\",(ans+tt)%tt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int fish=998244353;\nint fac[10000007],N,inv[10000007];\nint Pow(int x,int y){int ans=1;for (;y;y>>=1,x=1ll*x*x%fish) if (y&1) ans=1ll*ans*x%fish;return ans;}\nvoid Pre(int ned){\n\tfac[0]=1;\n\tfor (int i=1;i<=ned;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%fish;\n\tinv[ned]=Pow(fac[ned],fish-2);\n\tfor (int i=ned-1;i>=0;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%fish;\n}\nint C(int n,int r){if (n<r) return 0;return 1ll*fac[n]*inv[r]%fish*inv[n-r]%fish;}\nvoid work(){\n\tscanf(\"%d\",&N);\n\tlong long ans=Pow(3,N);\n\tfor (int i=N/2+1;i<=N;i++)\n\t\t((ans-=1ll*C(N,i)*Pow(2,N-i+1))+=fish)%=fish;\n\tcout<<ans;\n\treturn;\n}\nint main(){\n\tPre(10000000);\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing Graph = vector<vector<int>>;\nusing Wgraph = vector<vector<pair<int, long long int>>>;\nconstexpr long long int INF = 1001001001001001LL;\nconstexpr long long int MOD = 998244353LL;\nconstexpr double PI = 3.1415926535897932;\nconstexpr long long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconstexpr long long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define REP(i,n) for(int i = 0; i < (n); i++)\n#define RREP(i,n) for(int i = 1; i <= (n); i++)\n#define DREP(i,n) for(int i = (n)-1; i >= 0; i--)\n#define SREP(i,s,t) for(int i = s; i < t; i++)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define PB push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\nlint dfs(vector<lint> vec) {\n  // 0 1, 1 0 は消せない\n  if(vec.size() == 2) {\n    if(vec[0] == 0 and vec[1] == 1) return 0;\n    else if(vec[1] == 0 and vec[0] == 1) return 0;\n    else return 1;\n  }\n\n  // 消すところを全探索\n  for(int i = 0; i < vec.size() - 1; i++) {\n    if(vec[i] == 0 and vec[i + 1] == 1) continue;\n    if(vec[i] == 1 and vec[i + 1] == 0) continue;\n    vector<lint> hoge;\n    for(int j = 0; j < vec.size(); j++) {\n      if(j == i or j == i + 1) continue;\n      hoge.push_back(vec[j]);\n    }\n    if(dfs(hoge)) return 1;\n  }\n  return 0;\n}\n\nlint naive(lint n) {\n  // 3 ^ n 通りの文字列を生成\n  lint ret = 0;\n  for(lint bit = 0; ; bit++) {\n    lint val = bit;\n    vector<lint> vec(n, -1);\n    for(int i = 0; i < n; i++) {\n      vec[i] = val % 3;\n      val /= 3;\n    }\n    if(val > 0) break;\n    \n    if(dfs(vec)) {\n      ret += 1;\n    }\n    \n  }\n\n  return ret;\n}\n\nint main(){\n  \n  lint n; cin >> n;\n  if(n > 10) assert(false);\n  cout << naive(n) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat pow(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pow(a, e/2, mod);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tcat ans = 1, mod = 998244353;\n\tfor(int i = 0; i < N; i++) {\n\t\tans += 2*ans;\n\t\tif(ans >= mod) ans -= mod;\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tvector<cat> pow2(N+2, 1);\n\tfor(int i = 1; i <= N+1; i++) {\n\t\tpow2[i] = 2 * pow2[i-1];\n\t\tif(pow2[i] >= mod) pow2[i] -= mod;\n\t}\n\tvector<cat> binom(N/2+1, 1), inv(N/2+1);\n\tfor(int i = 1; i <= N/2; i++) {\n\t\tif(N/2-i < i) break;\n\t\tif(i > 2 && i%2 == 0) inv[i] = inv[2] * inv[i/2] % mod;\n\t\telse inv[i] = pow(i, mod-2, mod);\n\t}\n\tfor(int i = 1; i <= N/2; i++) {\n\t\tif(N/2-i < i) binom[i] = binom[N/2-i];\n\t\telse binom[i] = binom[i-1] * (N/2-i+1) % mod * inv[i] % mod;\n\t}\n\tcat sum = 0;\n\tfor(int nAL = 0; nAL <= N/2; nAL++) {\n\t\tans = (ans - binom[nAL] * pow2[N/2-nAL+1] % mod * sum) % mod;\n\t\tsum = (sum + pow2[nAL] * binom[nAL]) % mod;\n\t}\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define trav(x, v) for(auto &x : v)\n#define all(v) v.begin(),v.end()\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll mod = 998244353;\n\nll modpow(ll a, ll e){\n        ll res = 1;\n        do {\n                if(e % 2) res = res * a % mod;\n                a = a * a % mod;\n        } while(e >>= 1);\n        return res;\n}\n\nint main(){\n        cin.tie(0);\n        cin.sync_with_stdio(0);\n        cin.exceptions(cin.failbit);\n\n        int n;\n        cin >> n;\n\n        vector<ll> fs(n+1,1);\n        rep(i,0,n) fs[i+1] = fs[i] * (i+1) % mod;\n\n        auto bin = [&](int n, int k){\n                return fs[n] * modpow(fs[k] * fs[n-k] % mod, mod-2) % mod;\n        };\n\n        ll sub = 0;\n\n        rep(i,n/2+1,n+1) sub += bin(n, i) * modpow(2, n-i) % mod;\n\n        ll ans = modpow(3, n) - 2*sub;\n        ans %= mod;\n\n        if(ans < 0) ans += mod;\n\n        cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#ifndef  _TB\n#define _TB\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define RFOR(i, b, a) for(int i = b - 1; i >= a; --i)\n#define REP(i, N) FOR(i, 0, N)\n#define RREP(i, N) RFOR(i, N, 0)\n\n#define MIN(A, B) ((A) < (B) ? (A) : (B))\n#define MAX(A, B) ((A) > (B) ? (A) : (B))\n#define ABS(A) ((A) < 0 ? (-(A)) : (A))\n#define ALL(V) V.begin(), V.end()\n#define SIZE(V) (int)V.size()\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-7\n#define Pi 3.14159265358979\n#define FILL(a,v) memset(a,v,sizeof(a))\n\nusing namespace std;\n\ntypedef long long Long;\ntypedef unsigned long long ULong;\ntypedef unsigned int Uint;\ntypedef unsigned char Uchar;\ntypedef vector <int> VI;\ntypedef pair <int, int> PII;\n\n#define X first\n#define Y second\n\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.X >> p.Y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.X << ' ' << p.Y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return (ui)(8*sizeof(int)-__builtin_clz(x)); }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\nvoid fastIO(){ios::sync_with_stdio(false); }\n\n#endif\n\ntypedef pair<Long, Long> pll;\n\n\npll intersect(pll a, pll b) {\n    if (a.Y < b.X || b.Y < a.X)\n        return {0,0};\n\n    return {\n        max(a.X, b.X),\n        min(a.Y, b.Y)\n    };\n}\n\n\nset<pll> vx;\nset<pll, greater<> > vy;\n\nvoid erase(pll p) {\n    vx.erase(p);\n    vy.erase({p.Y, p.X});\n}\n\n\npll findo(pll a) {\n    if (!vx.empty()) {\n        auto it = vx.upper_bound({a.Y, 1e10});\n        if (it != vx.end())\n            return *it;\n    }\n\n    if (!vy.empty()) {\n        auto it = vy.upper_bound({a.X , 0});\n        if (it != vy.end())\n            return {it->second, it->first};\n    }\n    return {0,0};\n}\n\n\nLong sss(pll p) {\n    if (p.X == 0)\n        return 0;\n    return p.Y - p.X + 1;\n}\n\nclass BTwoContests {\npublic:\n    void solve(std::istream& in, std::ostream& out) {\n        fastIO();\n        int n;\n        in >> n;\n        vector<pll> v(n);\n        in >> v;\n\n        Long ans = 0;\n        Long miny = 1e12;\n        Long maxx = 0;\n\n        vx.clear();\n        vy.clear();\n\n        for(auto p: v) {\n            ans = max(ans, sss(p));\n            maxx = max(maxx, p.X);\n            miny = min(miny, p.Y);\n\n            vx.insert(p);\n            vy.insert({p.Y, p.X});\n        }\n\n        sort(ALL(v));\n        if (vx.size() <= 2) {\n            out << sss(v[0]) + sss(v.back()) << endl;\n            return;\n        }\n\n        // two distinct\n        if (maxx > miny) {\n            pll a, b;\n            for(auto p: v) {\n                if (p.X == maxx)\n                    a = p;\n                if (p.Y == miny)\n                    b = p;\n            }\n\n            erase(a);\n            erase(b);\n\n            bool changed = true;\n\n            while (changed) {\n                changed = false;\n                auto oa = findo(a);\n                if (oa.X != 0) {\n                    b = intersect(oa, b);\n                    erase(oa);\n                    changed = true;\n                }\n\n                auto ob = findo(b);\n                if (ob.X != 0) {\n                    a = intersect(a, ob);\n                    erase(ob);\n                    changed = true;\n                }\n\n            }\n\n            if (sss(a) == 0 || sss(b) == 0) {\n                out << ans << endl;\n                return;\n            }\n\n            vector<pll> v;\n\n            v.pb({sss(a), 0});\n            v.pb({0, -sss(b)});\n            for(auto p: vx) {\n                v.pb({\n                    sss(intersect(p, a)),\n                    -sss(intersect(p, b))\n                });\n            }\n\n            Long best = 0;\n\n            sort(ALL(v));\n\n            Long mn = -sss(b);\n            FOR(i, 0, v.size()) {\n                best = max(best, mn+v[i].X);\n                mn = min(mn, -v[i].Y);\n            }\n\n            ans = max(ans, best);\n            out << ans << endl;\n            return;\n        }\n\n        if (vx.count({maxx, miny})) {\n            out << ans + sss({maxx, miny}) << endl;\n            return;\n        }\n\n\n        auto firstl = *vy.rbegin();\n        firstl = {\n            firstl.Y, firstl.X\n        };\n\n        erase(firstl);\n\n        vector<pll> tod;\n        for(auto p: vx) {\n            if (intersect(p, firstl) == firstl)\n                tod.pb(p);\n        }\n\n        Long mxsize = 0;\n\n        for (auto p: tod) {\n            erase(p);\n            mxsize = max(mxsize, sss(p));\n        }\n\n\n        auto d2 = *vx.rbegin();\n\n        erase(d2);\n        for(auto p: vx) {\n            mxsize = max(mxsize, sss(p));\n        }\n\n        ans = max(mxsize + sss(intersect(d2, firstl)), ans);\n\n        while (!vx.empty()) {\n            auto cand = *vx.rbegin();\n            ans = max(ans, sss(d2) + sss(intersect(firstl, cand)));\n            d2 = intersect(d2, cand);\n            erase(cand);\n        }\n\n        ans = max(ans, sss(d2) + sss(firstl));\n\n        out << ans << endl;\n\n    }\n};\n\n\nint main() {\n\tBTwoContests solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\n#define error(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconst int N = 1e7 + 20, mod = 998244353;\nint n, fac[N], inv[N], ans;\n\ninline int pw (int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\n\treturn res;\n}\n\ninline int C (int n, int k)\n{\n\treturn 1ll * fac[n] * inv[k] % mod * inv[n - k] %mod;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = pw(fac[i], mod - 2);\n\t}\n\n\tcin >> n;\n\n\tn /= 2;\n\n\tans = pw(3, 2 * n);\n\n\tfor (int i = n + 1; i <= 2 * n; i++)\n\t{\n\t\tint res = C(2 * n, i);\n\t\tres = 2 * res % mod;\n\n\t\tres = 1ll * res * pw(2, 2 * n - i) % mod;\n\n\t\tans = (ans + mod - res) % mod;\n\n\t}\n\t\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int mod=998244353;\nconst int N=10000010;\ntypedef long long LL;\nint n;\nint ft[N+1],Ft[N+1],mi2[N+1];\nint C(int n,int m){\n\treturn (LL)ft[n]*Ft[m]%mod*Ft[n-m]%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tft[0]=1;\n\tref(i,1,n)ft[i]=(LL)ft[i-1]*i%mod;\n\tFt[n]=mi(ft[n],mod-2);\n\tdef(i,n,1)Ft[i-1]=(LL)Ft[i]*i%mod;\n\tmi2[0]=1;\n\tref(i,1,n)mi2[i]=(LL)mi2[i-1]*2%mod;\n\tint ans=mi(3,n);\n\tint s=0,nn=n/2;\n\tref(i,nn+1,n)s=((LL)C(n,i)*mi2[n-i+1]+s)%mod;\n\tans=(ans+mod-s)%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\ntypedef Field<998244353> FF;\n\nclass CNeitherABNorBA {\npublic:\n//    int gen(string s, int c) {\n//        if (c == 0) {\n//            bool odd = true, even = true, noc = true;\n//\n//            for (int i = 0; i < s.size(); ++i) {\n//                noc &= i == 0 || s[i] != 'C' || s[i-1] != 'C';\n//                if (i%2) {\n//                    odd &= s[i]!='A';\n//                    even &= s[i]!='B';\n//                } else {\n//\n//                    odd &= s[i]!='B';\n//                    even &= s[i]!='A';\n//                }\n//            }\n////            cerr << s << ' ' << noc << ' ' << even << ' ' << odd << endl;\n//            return (noc && (even || odd));\n//        } else {\n//            return gen(s + 'A', c-1) + gen(s + 'B', c-1) + gen(s + 'C', c-1);\n//        }\n//    }\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n//        cout << gen(\"\", N);\n        auto F = FF::fact(N);\n        auto I = FF::invfact(N);\n\n        vector<FF> P(N+1, 1);\n        for (int i = 1; i <= N; ++i) {\n            P[i] = P[i-1] * 2;\n        }\n        FF ans = FF{3}.pow(N);\n        for (int i = N/2+1; i <= N; ++i) {\n            ans -= 2 * F[N] * I[i] * I[N-i] * P[N-i]; //FF{2}.pow(N-i);\n        }\n\n        cout << ans << '\\n';\n\n//        FF ans = 0;\n//        for (int i = 1; i < N; i += 2) {\n//            cout <<\n//        }\n\n//        vector2<FF> X(N+1, N+1, 0);\n//        X[0][0] = 1;\n//        for (int i = 0; i < N; ++i) {\n//            for (int j = 0; j < N; ++j) {\n//                if (X[i][j] != 0) {\n//\n//                    if (j != 0) {\n//                        X[i+1][j+1] += X[i][j];\n//                        X[i+1][j-1] += 2*X[i][j];\n//                    } else {\n//                        X[i+2][0] += 3;\n//                        X[i+1][j+1] += 2 * X[i][j];\n//                    }\n//                }\n//            }\n//        }\n//\n//        for (int i = 2; i <= N; i+=2) {\n//            cout << X[i][0] << ' ';\n//        }\n//        cout << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCNeitherABNorBA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it = v.begin(); it != v.end(); it++)\n#define vrepr(v,it) for(auto it = v.rbegin(); it != v.rend(); it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\nusing P = pair<int,int>; using vp = vector<P>;\nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n////////////////\n\nvector<ll> fac,finv,inv;\nvoid COMinit(int MAX) {\n  MAX++;\n  fac.resize(MAX , 0);\n  finv.resize(MAX , 0);\n  inv.resize(MAX , 0);\n  fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n// nCk combination \ninline long long COM(int n,int k){\n  if(n < k || k < 0 || n < 0) return 0;\n  else return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n// nPk permutation\ninline long long PER(int n,int k){\n  if (n < k || k < 0 || n < 0) return 0;\n  else return (fac[n] * finv[n - k]) % MOD;\n}\n// nHk homogeneous polynomial\ninline long long HGP(int n,int k){\n  if(n == 0 && k == 0) return 1; //問題依存?\n  else if(n < 1 || k < 0) return 0;\n  else return fac[n + k - 1] * (finv[k] * finv[n - 1] % MOD) % MOD;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\n// 累積演算ライブラリ Accumulated Operation Library\ntemplate<typename T>\nstruct ACC{\n  private:\n    vector<T> Head,Tail;\n    function<T(T,T)> f = [](T a,T b){return a + b;};\n    function<T(T,T)> f_inv = [](T a,T b){return a - b;};\n    T UNIT = 0;\n  public:\n    // Head[i]には[0 , i)の結果を代入する\n    // Tail[i]には[i , N)の結果を代入する\n    ACC(const vector<T> &v){\n      int N = int(v.size());\n      Head.resize(N + 1);\n      Tail.resize(N + 1);\n      Head[0] = Tail[N] = UNIT;\n      for(int i = 0, j = N; i < N ; i++,j--){\n        Head[i + 1] = f( Head[i] , v[i]);\n        Tail[j - 1] = f( Tail[j] , v[j - 1]);\n      }\n    };\n    // 半開区間[0 , k)の演算結果を返す\n    T head(int k){ return Head[k]; }\n    // 半開区間[k , N)の演算結果を返す\n    T tail(int k){ return Tail[k]; }\n    // 逆演算の存在するとき半開区間[l , r)の演算結果を返す\n    T query(int l,int r){\n      return f_inv(Head[r] , Head[l]);\n    }\n};\n\nvoid solve(){\n  inl(N);\n  vl beki(N/2 + 10);\n  COMinit(N / 2 + 10);\n  beki[0] = 1;\n  rep1(i , N / 2 + 2){\n    beki[i] = beki[i - 1] * 2;\n    if(beki[i] >= MOD) beki[i] -= MOD;\n  }\n  vector<modint> a(N / 2 + 1);\n  rep(k , N / 2 + 1){\n    a[k] = 1LL * beki[N/2 - k] * COM(N/2 , k) % MOD;\n  }\n  ACC<modint> ruiseki(a);\n  \n  modint dame = 0;\n  //\n  rep(x , N / 2 + 1){\n    int y = N / 2 + 1 - x; // これ以上がダメ\n    dame += a[x] * ruiseki.tail(y);\n  }\n  modint ans = modint(3).pow(N);\n  ans -= dame; ans -= dame;\n  out(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef DEBUG\n#include \"inc/debug.hpp\"\n#else\n#define debug(...) 42\n#endif\n\nconst int mod = 998244353;\nconst int MAX = 1e7+1;\nlong long fc[MAX];\nlong long fci[MAX];\n\nlong long modpow(long long a, long long b) {\n    if (b == 0) {\n        return 1;\n    } else if (b % 2 == 0) {\n        long long t = modpow(a, b/2);\n        return (t * t) % mod;\n    }\n    return (a * modpow(a, b-1)) % mod;\n}\n\nvoid init() {\n    fc[0] = fc[1] = 1;\n    for (int i=2; i<MAX; ++i) {\n        fc[i] = (fc[i-1] * i) % mod;\n    }\n    fci[1] = 1;\n    for (int i=2; i<MAX; ++i) {\n        fci[i] = (fci[i-1] * modpow(i, mod-2)) % mod;\n    }\n}\n\nlong long comb(long long n, long long k) {\n    if (k == 0 || n == k) return 1;\n    return (fc[n] * fci[k] % mod) * fci[n-k] % mod;\n}\n\nint main() {\n    init();\n\n    long long N;\n    cin >> N;\n\n    long long res = modpow(3, N);\n    \n    for (int i=N/2+1; i<=N; ++i) {\n        long long t = (comb(N, i) * modpow(2, N-i)) % mod;\n        t = (t * 2) % mod;\n        res = (res - t + mod) % mod;\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 1e7;\nconst int P = 998244353;\nllong fact[mxN+3],facti[mxN+3];\nint n;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nvoid initfact(int n)\n{\n\tfact[0] = 1ll; for(int i=1; i<=n; i++) {fact[i] = fact[i-1]*i%P;}\n\tfacti[n] = quickpow(fact[n],P-2); for(int i=n-1; i>=0; i--) {facti[i] = facti[i+1]*(i+1ll)%P;}\n}\nllong comb(llong x,llong y) {return x<0||y<0||x<y?0ll:fact[x]*facti[y]%P*facti[x-y]%P;}\n\nint main()\n{\n\tinitfact(mxN);\n\tn = read();\n\tllong ans = quickpow(3ll,n);\n\tfor(int i=n/2+1; i<=n; i++)\n\t{\n\t\tllong tmp = comb(n,i)%P*quickpow(2ll,n-i+1)%P;\n\t\tans = (ans-tmp+P)%P;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define minus djsf\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint pw(int x, int y) {\n\tif (y==0) return 1;\n\tif (y%2) return ((ll) pw(x, y-1) * x) % mod;\n\tint q = pw(x, y/2);\n\treturn ((ll) q * q) % mod;\n}\n\nconst int N = 10000007;\n\nint fact[N], rev[N];\n\nint C(int n, int k) {\n\tint A = fact[n];\n\tint B = ((ll) rev[k] * rev[n-k]) % mod;\n\treturn ((ll) A * B) % mod;\n}\n \nsigned main()\n{\n#ifdef LOCAL\n\tfreopen(\"N_input.txt\", \"r\", stdin);\n\t//freopen(\"P_output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    fact[0] = 1;\n    for (int i=1; i < N; ++i) fact[i] = ((ll) fact[i-1] * i) % mod;\n    for (int i=0; i < N; ++i) rev[i] = pw(fact[i], mod-2);\n\n    int n;\n    cin >> n;\n\n    int ans = pw(3, n);\n\n    for (int i=n/2+1; i <= n; ++i) {\n    \tint T = (2*C(n, i)) % mod;\n    \tT = ((ll) T * pw(2, n - i)) % mod;\n    \tans = (ans - T + mod) % mod;\n    }\n\n    cout << ans;\n\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 2019/11/6 13:22:59\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\nusing ll = long long;\nconstexpr ll MOD{998244353LL};\nconstexpr ll MAX_SIZE{20000010LL};\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x(0) {}\n  Mint(ll x) : x(x % MOD) {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nint main()\n{\n  ll N;\n  cin >> N;\n  Mint ans{Mint{3}.power(N)};\n  Mint X{0};\n  Combination C;\n  for (auto k = N / 2 + 1; k <= N; k++)\n  {\n    X += C(N, k) * Mint{2}.power(N - k);\n  }\n  ans -= X * 2;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int mod=998244353;\nint n;\nlong long ans,ji[10000007];\nlong long qpow(long long a,long long b) {\n\tlong long res=1;\n\tlong long now=a%mod;\n\twhile (b) {\n\t\tif (b&1) res=res*now%mod;\n\t\tnow=now*now%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid init(){\n\tji[0]=1;\n\tfor (int i=1; i<=n; i++) ji[i]=ji[i-1]*i%mod;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tinit();\n\tans=qpow(3,n);\n\tfor (int i=(n/2)+1; i<=n; i++) {\n\t\tans=(ans-2*(((((ji[n]*qpow(ji[i],mod-2))%mod)*qpow(ji[n-i],mod-2))%mod)*qpow(2,n-i)%mod))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph & g, Matrix & scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\ntemplate<typename T>\ninline void bit_reverse(vector<T> & a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n & -n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod - 2, mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long> & input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long> & input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto& x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long> & a, const vector<long long> & b) {\nint result_size = a.size() + b.size() - 1;\nint n = 1; while (n < result_size) n <<= 1;\n\nvector<long long> _a = a, _b = b;\n_a.resize(n, 0);\n_b.resize(n, 0);\n\nntt(_a);\nntt(_b);\nfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\nintt(_a);\n\n_a.resize(result_size);\nreturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\n\t\tret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nint popcount3(int x) {\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0F0F0F0F) + (x >> 4 & 0x0F0F0F0F);\n\tx = (x & 0x00FF00FF) + (x >> 8 & 0x00FF00FF);\n\tx = (x & 0x0000FFFF) + (x >> 16 & 0x0000FFFF);\n\n\treturn x;\n}\n\nll const mod = 998244353;\nint two[10000010];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\n\n\tll n;\n\tcin >> n;\n\tCombination comb(n+1, mod);\n\ttwo[0] = 1;\n\tREP(i, n) {\n\t\ttwo[i + 1] = (two[i] * 2) % mod;\n\t}\n\tint ans = mod_pow(3, n, mod);\n\tint temp = 0;\n\trep(i,n/2+1,n+1) {\n\t\t(temp += comb.nCr(n, i) * two[n - i] % mod) %= mod;\n\t}\n\t(temp *= 2) %= mod;\n\t(ans += mod - temp) %= mod;\n\n\n\tcout << ans << endl;\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e7+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 998244353;\n\nint n,fac[maxn],ifac[maxn],inv[maxn];\n\nint c(int a,int b) {return 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\n\nint qpow(int a,int x) {\n    int res=1;\n    for(;x;x>>=1,a=1ll*a*a%mod) if(x&1) res=1ll*res*a%mod;\n    return res;\n}\n\nint main() {\n    read(n);fac[0]=ifac[0]=inv[0]=inv[1]=1;\n    for(int i=2;i<=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n    int ans=qpow(3,n);\n    for(int i=n/2+1;i<=n;i++) ans=(ans-2ll*qpow(2,n-i)*c(n,i)%mod+mod)%mod;\n    write(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T, class U>\nvoid ckmin(T &a, U b)\n{\n\tif (a > b) a = b;\n}\ntemplate<class T, class U>\nvoid ckmax(T &a, U b)\n{\n\tif (a < b) a = b;\n}\n\n#define MP make_pair\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define FOR(i, a, b) for (auto i = (a); i < (b); i++)\n#define FORD(i, a, b) for (auto i = (a) - 1; i >= (b); i--)\n#define SZ(x) ((int) ((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n#define INF 998244353\n#define MAXN 10000013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\n\nint N;\nll ans;\nll fact[MAXN], ifact[MAXN], pw2[MAXN];\n\nll expo(ll a, ll e)\n{\n\tif (e == 0) return 1;\n\tif (e & 1)\n\t{\n\t\treturn expo(a * a % INF, e >> 1) * a % INF;\n\t}\n\treturn expo(a * a % INF, e >> 1);\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tcin >> N;\n\tfact[0] = 1;\n\tFOR(i, 1, N + 10)\n\t{\n\t\tfact[i] = fact[i - 1] * i % INF;\n\t}\n\tifact[N + 9] = expo(fact[N + 9], INF - 2);\n\tFORD(i, N + 9, 0)\n\t{\n\t\tifact[i] = ifact[i + 1] * (i + 1) % INF;\n\t}\n\tpw2[0] = 1;\n\tFOR(i, 1, N + 10)\n\t{\n\t\tpw2[i] = pw2[i - 1] + pw2[i - 1]; if (pw2[i] >= INF) pw2[i] -= INF;\n\t}\n\tN /= 2;\n\tans = 1;\n\tFOR(i, 0, 2 * N)\n\t{\n\t\tans *= 3; ans %= INF;\n\t}\n\tFOR(i, N + 1, 2 * N + 1)\n\t{\n\t\tans -= 2 * fact[2 * N] * ifact[2 * N - i] % INF * ifact[i] % INF * pw2[2 * N - i];\n\t\tans %= INF;\n\t}\n\tif (ans < 0) ans += INF;\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nconst int maxn = 1e7 + 10;\nll n;\n\nll fac[maxn];\nll inv[maxn];\nll ci[maxn];\n\nll quickpow(ll a, ll b){\n  ll ans = 1 % mod;\n  while(b){\n    if(b & 1)\n      ans = ans * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\n\n\nvoid init(){\n\n  fac[0] = inv[0] = ci[0] = 1;\n  for(ll i = 1; i <= n; i ++){\n    fac[i] = 1ll * fac[i - 1] * i % mod;\n    ci[i] = ci[i - 1] * 2 % mod;\n    inv[i] = 1ll * inv[i - 1] *  quickpow(i, mod - 2) % mod;\n  }\n\n\n}\n\n\nll C(ll x, ll y){\n  return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\n\nint main()\n{\n  scanf(\"%lld\",&n);\n  init();\n  ll ans = quickpow(3ll ,n) % mod;\n  ll x = 0;\n  for(ll i = n / 2 + 1; i <= n; i ++)\n    x += C(n, i) * ci[n - i] % mod;\n  printf(\"%lld\\n\",(ans - x * 2 % mod + mod) % mod);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define rrep(i,n) RREP(i,n-1,0)\n#define REPL(i,m,n) for(ll i=(ll)(m); i<(ll)(n); i++)\n#define repl(i,n) REPL(i,0,n)\n#define all(v) v.begin(), v.end()\nconst int inf = 1e9+7;\nconst ll longinf = 1LL<<60;\nconst ll mod = 998244353;\n\n#define MAX_N 10000005\nll inv[MAX_N], fac[MAX_N], finv[MAX_N];\nvoid make() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for(int i=2; i<MAX_N; i++) {\n    inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n    fac[i] = fac[i-1] * (ll)i % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\nll perm(ll n, ll r) {\n  if(n < 0)       return 0;\n  else if(n < r)  return 0;\n  else            return (fac[n] * finv[n-r]) % mod;\n}\nll comb(ll n, ll r) {\n  ll ans = 1;\n  ans = perm(n, r);\n  ans = (ans * finv[r]) % mod;\n  return ans;\n}\nll binary_pow(ll a, ll N) {\n  ll ans = 1;\n  ll tmp = a;\n  while(N > 0) {\n    if(N % 2 == 1) {\n      ans *= tmp;\n      ans %= mod;\n    }\n    N /= 2;\n    tmp *= tmp;\n    tmp %= mod;\n  }\n  return ans;\n}\n\nint main() {\n  ll N;\n  cin >> N;\n  make();\n  ll cnt = 0;\n  REP(i, N/2+1, N+1) {\n    cnt += comb(N, i) * binary_pow(2, N-i);\n    cnt %= mod;\n  }\n  cout << (binary_pow(3, N) - cnt * 2 + mod) % mod << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int MOD = 998244353;\nll fastPow (ll a, ll b){\n  ll res = 1;\n  a %= MOD;\n  while (b) \n  {\n    if (b & 1) res = (res * a) % MOD;\n    a = (a * a) % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  ll cur = 1, res = 0;\n  for (int i = 0; i <= n; ++i)\n  {\n    if (i >= n/2) res+= cur;\n    cur *= 1LL * 2 * (n-i);\n    cur /= (i+1);\n  }\n  cout << (-1LL)*fastPow(3, n) + 1LL * 2 * res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_) {\n        if (num_ < 0) num = num_ + MOD;\n        else if (num_ >= MOD) num = num_ % MOD;\n        else num = num_;\n    }\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long i64;\ninline int rd(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e7+5, P = 998244353;\nint n, ans, pw[N]; i64 iv[N]; void fix(int &x) { x<P?0:x-=P; }\nint main()\n{\n    n = rd(); pw[0] = iv[1] = 1, pw[1] = 2, ans = 3; \n    for(int i = 2; i <= n; ++i) ans = ans*3ll%P, iv[i] = P-(P/i)*iv[P%i]%P, fix(pw[i]=pw[i-1]<<1);\n    ans = P-ans; for(int i = 0, m = n>>1, v = 1, w = 0; i <= m; ++i) \n        fix(w += (i64)v*pw[m-i]%P), fix(ans += (i64)v*w%P*pw[i+1]%P), v = v*iv[i+1]%P*(m-i)%P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int nMax=1e7+1, MOD=998244353;\nULL inv[nMax], Fact[nMax], invF[nMax];\nULL pw(ULL a, ULL n){ ULL b=1; while(n){ if(n&1){ b=(b*a)%MOD; } a=(a*a)%MOD; n>>=1; } return b; }\nULL Comb(int n, int r){ return (((Fact[n]*invF[r])%MOD)*invF[n-r])%MOD; }\n\nint main(){\nULL N, ans, d=0; cin >> N;\ninv[1]=Fact[0]=Fact[1]=invF[0]=invF[1]=1;\nfor(int i=2; i<nMax; i++){ \n  inv[i]=((MOD-MOD/i)*inv[MOD%i])%MOD;\n  Fact[i]=(Fact[i-1]*i)%MOD; invF[i]=(invF[i-1]*inv[i])%MOD;\n}\nfor(int i=N/2+1; i<=N; i++){ d=(d+(Comb(N, i)*pw(2, N-i))%MOD)%MOD; }\nd=(2*d)%MOD; ans=(pw(3, N)+MOD-d)%MOD;\ncout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) (a).begin(),(a).end()\ntypedef long long ll;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define lb(s,x) (lower_bound(all(s),x)-s.begin())\n#define ub(s,x) (upper_bound(all(s),x)-s.begin())\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define bit(k) (1LL<<(k))\nconst int INF = 1e9;\n\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n\nclass modint;\nstatic vector<modint> factorial(10000010);\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n    modint operator+(const modint &r) const { return modint(num + r.num); }\n    modint operator-(const modint &r) const { return modint(num - r.num); }\n    modint operator*(const modint &r) const { return modint(num * r.num); }\n\n    template<typename T>\n    modint operator^(const T &r) const {\n        if(r == 0) return 1;\n        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);\n    }\n    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }\n\n    modint operator+=(const modint &r) { return *this = *this + r; }\n    modint operator-=(const modint &r) { return *this = *this - r; }\n    modint operator*=(const modint &r) { return *this = *this * r; }\n    modint operator/=(const modint &r) { return *this = *this / r; }\n\n    template<typename T>\n    modint operator^=(const T &r) { return *this = *this ^ r; }\n\n    static modint pow(const modint x, ll r) {\n        return x^r;\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) factorial.resize(n+1);\n        if(factorial[n]) return factorial[n];\n        if(n == 0) return 1;\n        return factorial[n] = modint(n) * fact(n-1);\n    }\n\n    static modint C(ll n,ll r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\n// vector<modint> modint::factorial;\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    ll n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * modint(2);\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n}\n\nint inv(int a, int n) {\n\tint x, y;\n\texgcd(a, n, x, y);\n\treturn (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 998244353;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n\tpublic:\n\t\tint v;\n\n\t\tZ() : v(0) {\t}\n\t\tZ(int x) : v(x){\t}\n\t\tZ(ll x) : v(x % Mod) {\t}\n\n\t\tfriend Z operator + (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n\t\t}\n\t\tfriend Z operator - (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n\t\t}\n\t\tfriend Z operator * (const Z& a, const Z& b) {\n\t\t\treturn Z(a.v * 1ll * b.v);\n\t\t}\n\t\tfriend Z operator ~(const Z& a) {\n\t\t\treturn inv(a.v, Mod);\n\t\t}\n\t\tfriend Z operator - (const Z& a) {\n\t\t\treturn Z(0) - a;\n\t\t}\n\t\tZ& operator += (Z b) {\n\t\t\treturn *this = *this + b;\n\t\t}\n\t\tZ& operator -= (Z b) {\n\t\t\treturn *this = *this - b;\n\t\t}\n\t\tZ& operator *= (Z b) {\n\t\t\treturn *this = *this * b;\n\t\t}\n\t\tfriend boolean operator == (const Z& a, const Z& b) {\n\t\t\treturn a.v == b.v;\n\t\t} \n};\n\nZ<> qpow(Z<> a, int p) {\n\tZ<> rt = Z<>(1), pa = a;\n\tfor ( ; p; p >>= 1, pa = pa * pa) {\n\t\tif (p & 1) {\n\t\t\trt = rt * pa;\n\t\t}\n\t}\n\treturn rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 1e7 + 7;\n\nint n;\nZi fac[N], _fac[N], pw2[N];\n\nZi comb(int n, int m) {\n\treturn (n < m) ? (0) : (fac[n] * _fac[m] * _fac[n - m]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i;\n\t_fac[n] = ~fac[n];\n\tfor (int i = n; i; i--)\n\t\t_fac[i - 1] = _fac[i] * i;\n\tpw2[0] = 1;\n\tfor (int i = 1; i <= n + 1; i++)\n\t\tpw2[i] = pw2[i - 1] + pw2[i - 1];\n\tZi ans = qpow(3, n);\n\tfor (int i = (n >> 1) + 1; i <= n; i++)\n\t\tans -= comb(n, i) * pw2[n - i + 1];\n\tprintf(\"%d\\n\", ans.v);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint quickpow(int x,int y)\n{\n\tlong long res=1,base=x;\n\twhile(y)\n\t{\n\t\tif(y&1) res*=base,res%=mod;\n\t\ty>>=1;\n\t\tbase*=base,base%=mod;\n\t}\n\treturn res;\n}\nint inv(int x){return quickpow(x,mod-2);}\nint prod[10000001];\nint invp[10000001];\nint c(int n,int m){return 1ll*prod[n]*invp[m]%mod*invp[n-m]%mod;}\nsigned main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint ans=0;\n\tprod[0]=1,invp[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tprod[i]=1ll*prod[i-1]*i%mod,invp[i]=inv(prod[i]);\n\tfor(int i=n/2+((n%2==0)?1:0);i<=n;i++)\n\t\tans+=1ll*c(n,i)*2*quickpow(2,n-i)%mod,ans%=mod;\n\tprintf(\"%d\",((quickpow(3,n)-ans)%mod+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int LL;\ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n//////////////////////////\n\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 2000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\n\nint main(){fastio\n    calc();\n    ll n;cin>>n;\n    ll ans=po(3,n);\n    ll gen=0;\n    rep(a,n/2+1,n){\n        Add(gen,comb(n,a)*po(2,n-a));\n    }\n    cout<<mod(ans-gen*2)<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nconst ll MOD = (ll)998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing vvvvector = vector<vvector<vector<t>>>;\ntemplate<class t>\nusing vvvvvector = vector<vvvvector<t>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nll factorial(ll x){\n\tstatic vector<ll> memo;\n\tif(memo.empty()){\n\t\tint n = 1e7;\n\t\tmemo.resize(n+1);\n\t\tmemo[1]=1;\n\t\trepa(i, n){\n\t\t\tmemo[i+1] = (i+1) * memo[i] % MOD;\n\t\t}\n\t}\n\tif(x<=1)return 1;\n\treturn memo[x];\n}\n\nll C(ll a, ll b){\n\treturn factorial(a) * modinv(factorial(b)) % MOD * modinv(factorial(a-b)) % MOD;\n}\n\nint main(){\n\tll n;\n\tcin >> n;\n\tll ans = modpow(3, n);\n\tfor(int i=n/2-1;i>=0;--i){\n\t\tans -= 2 * C(n, i) * modpow(2, i) % MOD;\n\t\tans = (ans % MOD + MOD) % MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N; cin>>N;\n\n  constexpr long MOD = 998244353;\n  constexpr int MAX = 1e7;\n  vector<long> fact(MAX+1);\n  fact[0] = 1;\n  for (long i = 1; i <= MAX; i++) {\n    fact[i] = fact[i-1]*i%MOD;\n  }\n  auto mod_pow = [](long x, long y) {\n    long t = 1;\n    long u = x;\n    while (y) {\n      if (y & 1) {\n        t *= u;\n        t %= MOD;\n      }\n      u *= u;\n      u %= MOD;\n      y >>=1;\n    }\n    return t;\n  };\n  auto mod_inv = [&](long x) {\n    return mod_pow(x, MOD-2);\n  };\n  vector<long> ifact(MAX+1);\n  ifact[MAX] = mod_inv(fact[MAX]);\n  for (long i = MAX-1; i >= 0; i--) {\n    ifact[i] = ifact[i+1] * (i+1) % MOD;\n  }\n  auto comb = [&](long x, long y) {\n    return fact[x] * ifact[y] % MOD * ifact[x-y] % MOD;\n  };\n\n  auto U = mod_pow(3, N);\n\n  long ans = U;\n  for (int i = N; i > N/2; i--) {\n    auto pat = comb(N, i) * mod_pow(2, N-i) % MOD;\n    ans = ans + MOD - pat + MOD - pat;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\nconst int maxn=1e7+5;\nint n;\nint f[maxn];\nint invf[maxn];\nint power[maxn];\ninline int ksm(int x,int y){\n\tif(!y) return 1;\n\tif(y==1) return x;\n\tint tmp=ksm(x,y/2);\n\ttmp=(1ll*tmp*tmp)%MOD;\n\tif(y&1) return (1ll*tmp*x)%MOD;\n\telse return tmp;\n}\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn 1ll*f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tf[0]=invf[0]=1;\n\tfor(int i=1;i<maxn;i++) f[i]=(1ll*f[i-1]*i)%MOD;\n\tinvf[maxn-1]=ksm(f[maxn-1],MOD-2);\n\tfor(int i=maxn-2;i>=1;i--) invf[i]=(1ll*invf[i+1]*(i+1))%MOD;\n\tpower[0]=1;\n\tfor(int i=1;i<maxn;i++) power[i]=(1ll*power[i-1]*2)%MOD;\n\tint ans=ksm(3,n);\n\tint res=0;\n\tfor(int i=n/2+1;i<=n;i++) res=(res+2ll*power[n-i]%MOD*C(n,i))%MOD;\n\tans=(ans-res)%MOD+MOD%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\nusing ll = long long;\nll INF = LLONG_MAX;\nll MOD = 998244353;\n \nusing vc = vector<char>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nconst int MAXN = 1.01e7;\nvll fact (MAXN);\nvll invfact (MAXN);\n\nll binpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1)\n            res = res * a;\n        res %= MOD;\n        a = a * a;\n        a %= MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll n) {\n    return binpow(n, MOD-2);\n}\n\nll choose(ll n, ll k) {\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    ll N; cin >> N;\n\n    fact[0] = 1;\n    FOR(i, 1, N+1) fact[i] = fact[i-1] * i % MOD;\n\n    invfact[0] = 1;\n    FOR(i, 1, N+1) invfact[i] = invfact[i-1] * inverse(i) % MOD;\n\n    ll ans = binpow(3, N);\n    FOR(i, N/2+1, N+1) {\n        ans -= 2 * choose(N, i) * binpow(2, N-i);\n        ans = ((ans % MOD) + MOD) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define trav(x, v) for(auto &x : v)\n#define all(v) v.begin(),v.end()\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll mod = 998244353;\n\nll modpow(ll a, ll e){\n\tll res = 1;\n\tdo {\trep(i,0,n) fs[i+1] = fs[i] * (i+1) % md;\n\trep(i,0,n) fs[i+1] = fs[i] * modpow(i+1, mod) % md;\n\n\t\tif(e % 2) res = res * a % mod;\n\t\ta = a * a % mod;\n\t} while(e >>= 1);\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tcin.sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n;\n\tcin >> n;\n\n\tvector<ll> fs(n+1,1);\n\trep(i,0,n) fs[i+1] = fs[i] * (i+1) % mod;\n\n\tauto bin = [&](int n, int k){\n\t\treturn fs[n] * modpow(fs[k] * fs[n-k] % mod, mod-2) % mod;\n\t};\n\n\tll sub = 0;\n\n\trep(i,n/2+1,n+1) sub += bin(n, i) * modpow(2, n-i) % mod;\n\n\tll ans = modpow(3, n) - 2*sub;\n\tans %= mod;\n\n\tif(ans < 0) ans += mod;\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*powmod((fact[a-b]*fact[b])%MOD, MOD-2)%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    fact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += tempPow2*ncr(N, i)%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=10000005;\nconst int mod=998244353;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nint pre[MAXN],inv[MAXN],n,bin[MAXN];\nint C(int n,int m){return 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tbin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=(bin[i-1]<<1)%mod;\n\tn=read();int ans=pow_mod(3,n);\n\tfor(int i=n/2+1;i<=n;i++)dl(ans,2LL*C(n,i)*bin[n-i]%mod);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nlong long const mod = 998244353;\nlong long mod_fact(int x){\n    static vector<long long> fact = {1, 1};\n    if(x < 0)return 0; //\n    if(x < fact.size())return fact[x];\n    for(int i = fact.size(); i <= x; i++){\n        fact.push_back((fact[i-1] * i) % mod);\n    }\n    return fact[x];\n}\n\nlong long mod_pow(long long a, long long b){\n    long long res = 1;\n    a %= mod;\n    while(b > 0){\n        if(b%2 == 1) res = (res * a) % mod;\n        a = (a * a) % mod;\n        b /= 2;\n    }\n    return res;\n}\n\nlong long mod_div(long long a){\n    return mod_pow(a, mod-2);\n}\n\nlong long mod_comb(int a, int b){\n    if(b < 0 || a < b)return 0;\n    if(b > a/2)return mod_comb(a, a-b);\n    return (((mod_fact(a) * mod_div(mod_fact(a-b))) % mod) * mod_div(mod_fact(b))) % mod;\n}\n\nint main(void){\n    long long n, al, ng = 0;\n    cin >> n;\n    al = mod_pow(3, n);\n    for(int i=0;i<n/2;i++){\n        ng += mod_comb(n, i) * mod_pow(2, i);\n        ng %= mod;\n    }\n    cout << (al - ng*2 + mod*2) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=998244353;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=1e7+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N; cin >> N;\n    int n=N/2;\n    vector<mint> dp(n+1),sum(n+1,0);\n    for (int i=0;i<=n;++i) dp[i]=COM(n,i)*pow((mint)2,n-i);\n    sum[n]=dp[n];\n    for (int i=n-1;i>=0;--i) sum[i]=sum[i+1]+dp[i];\n    mint ans=pow((mint)3,N);\n    for (int i=1;i<=n;++i) ans-=dp[i]*sum[n+1-i]*2;\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=m.inverse(); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\n\tmint inverse()const{\n\t\tint a=x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint pow(mint m,long long k){\n\tmint res=1;\n\tfor(;k>0;k>>=1,m*=m) if(k&1) res*=m;\n\treturn res;\n}\n\nint main(){\n\tint n; cin>>n;\n\n\tmint cnt,choose=1;\n\tfor(int i=n;i>n/2;i--){\n\t\tcnt+=choose*pow(mint(2),n-i);\n\t\tchoose*=mint(i)/(n-i+1);\n\t}\n\tcout<<pow(mint(3),n)-cnt*2<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define X first\n#define Y second\n\ntemplate<typename T> // order_of_key(), *find_by_order()\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nmt19937_64 gen(time(nullptr));\n\nll const mod = 998244353;\n\nnamespace {\n    ll mul(ll a, ll b) {\n        ll val = a * b - (ll) ((ld) a * b / mod) * mod;\n        if (val < 0) val += mod;\n        if (val >= mod) val -= mod;\n        return val;\n    }\n\n    ll poww(ll a, ll b) {\n        ll val = 1;\n        a %= mod;\n        while (b > 0) {\n            if (b % 2) val = mul(a, val);\n            a = mul(a, a);\n            b >>= 1;\n        }\n        return val % mod;\n    }\n\n    ll inv(ll a) {\n        return poww(a, mod - 2);\n    }\n}\nll const maxn = 1e7 + 7;\nll fact[maxn];\nll pw[maxn];\n\nll C(ll n, ll k) {\n    return mul(fact[n], inv(mul(fact[n - k], fact[k])));\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    fact[0] = 1;\n    pw[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        fact[i] = fact[i - 1] * i;\n        pw[i] = pw[i - 1] * 2;\n        pw[i] %= mod;\n        fact[i] %= mod;\n    }\n    ll n;\n    cin >> n;\n    ll ans = poww(3, n);\n    ll kek = 0;\n    for (ll i = n / 2 + 1; i <= n; i++) {\n        (kek += mul(C(n, i), pw[n - i])) %= mod;\n    }\n    kek = mul(kek, 2);\n    cout << ((ans - kek) % mod + mod) % mod << endl;\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define fr first\n# define sc second\n# define pb push_back\n# define int long long\n# define mk make_pair\n# define sz(s) (int)s.size()\n# define all(s) s.begin(), s.end()\nusing namespace std;\nconst int N = 1e6+12,INF = 1000000007;\nint a[N];\nmap <string,bool> m;\n\nmain(){\n    int n;\n    cin>>n;\n    cout <<61;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = 998244353;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint powMod(int x, int p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) {\n      res = mul(res, x);\n    }\n    p >>= 1;\n    x = mul(x, x);\n  }\n  return res;\n}\n\nconst int maxn = (int) 1e7 + 5;\nint p2[maxn];\nint f[maxn], inv[maxn], finv[maxn];\n\nvoid precalc() {\n  p2[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    p2[i] = mul(p2[i - 1], 2);\n  }\n  f[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    f[i] = mul(f[i - 1], i);\n  }\n  inv[1] = 1;\n  for (int i = 2; i < maxn; i++) {\n    inv[i] = (mod - (long long) (mod / i) * inv[mod % i] % mod) % mod;\n  }\n  finv[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    finv[i] = mul(finv[i - 1], inv[i]);\n  }\n}\n\nint c(int n, int k) {\n  return mul(f[n], mul(finv[k], finv[n - k]));\n}\n\nint n;\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  int res = powMod(3, n);\n  for (int a = n / 2 + 1; a <= n; a++) {\n    add(res, mod - mul(c(n, a), p2[n - a + 1]));\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 998244353;\n\nstruct mint {\n    lint v;\n    lint _mod;\n    mint() : v(0) {}\n    mint(signed v, lint _mod = mod) : v(v), _mod(_mod) {}\n    mint(lint t, lint _mod = mod) : _mod(_mod) {\n        v = t % _mod;\n        if (v < 0)\n            v += _mod;\n    }\n\n    mint pow(lint k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n    mint inv() { return pow(_mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += _mod - a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = v * a.v % _mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(_mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n};\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nstruct Combination {\n    vector<lint> fac, finv, inv;\n    Combination(lint maxN) : fac(maxN + 100), finv(maxN + 100), inv(maxN + 100) {\n        maxN += 100; // for safety\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1]            = 1;\n        for (lint i = 2; i <= maxN; ++i) {\n            fac[i]  = fac[i - 1] * i % mod;\n            inv[i]  = mod - inv[mod % i] * (mod / i) % mod;\n            finv[i] = finv[i - 1] * inv[i] % mod;\n        }\n    }\n    lint operator()(lint n, lint k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    lint n;\n    cin >> n;\n    Combination nCk(n);\n    mint ng = 0;\n    for (int i = n / 2 + 1; i <= n; ++i) {\n        ng += mint(2).pow(n - i) * nCk(n, i);\n    }\n    cout << mint(3).pow(n) - ng * 2 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#define nmax_def 110000\n#define Cmax_def 2200\n#define mod 998244353\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tll ans = 0;\n\tvi An(N, 0);\n\trep(i, pow(3, N)) {\n\t\tvector<char> S(N);\n\t\tll div = i;\n\t\trep(j, N) {\n\t\t\tll rem = div % 3;\n\t\t\tswitch (rem)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tS[N - 1 - j] = 'A';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tS[N - 1 - j] = 'B';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tS[N - 1 - j] = 'C';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdiv -= rem;\n\t\t\tdiv /= 3;\n\t\t}\n\t\tvector<char> Stmp;\n\t\tll count = 1;\n\t\trep(j, N / 2) {\n\t\t\tcount *= j * 2 + 1;\n\t\t}\n\t\tbool canall = false;\n\t\trep(j, count) {\n\t\t\tStmp = S;\n\t\t\tll div1 = j;\n\t\t\tbool can = true;\n\t\t\trep(k, N / 2) {\n\t\t\t\tll rem1 = div1 % ((N / 2 - 1 - k) * 2 + 1);\n\t\t\t\tif (Stmp[rem1] == 'A' && Stmp[rem1 + 1] == 'B') {\n\t\t\t\t\tcan = false;\n\t\t\t\t}\n\t\t\t\tif (Stmp[rem1] == 'B' && Stmp[rem1 + 1] == 'A') {\n\t\t\t\t\tcan = false;\n\t\t\t\t}\n\t\t\t\tStmp.erase(Stmp.begin() + rem1, Stmp.begin() + rem1 + 2);\n\t\t\t\tdiv1 -= rem1;\n\t\t\t\tdiv1 /= (N / 2 - 1 - k) * 2 + 1;\n\t\t\t}\n\t\t\tif (can)\n\t\t\t{\n\t\t\t\tcanall = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (canall) {\n\t\t\tans++;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint add(int a, int b) {\n  return a + b - mod * (a + b >= mod);\n}\n\nint mul(int a, int b) {\n  return int(1ll * a * b % mod);\n}\n\nint power(int a, int x) {\n  if (x == 0) {\n    return 1;\n  }\n  return mul(power(mul(a, a), x >> 1), (x & 1 ? a : 1));\n}\n\nint divide(int a, int b) {\n  return mul(a, power(b, mod - 2));\n}\n\nint sub(int a, int b) {\n  return a - b + mod * (a < b);\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n\n  int n;\n  cin >> n;\n  int ans = power(3, n), p = 2, c = 1;\n  for (int i = n; i > n / 2; --i) {\n    ans = sub(ans, mul(p, c));\n    c = mul(c, i);\n    c = divide(c, n - i + 1);\n    p = add(p, p);\n  }\n  cout << ans;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// May this submission get accepted!\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define STEP(i, is, ie, step) for (long long i=(is), i##_end=(ie), i##_step = (step); i<=i##_end; i+=i##_step)\n#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return true;} return false; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return true;} return false; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) ((q) ? \"Yes\" : \"No\")\n#define YES(q) ((q) ? \"YES\" : \"NO\")\n#define Possible(q) ((q) ? \"Possible\" : \"Impossible\")\n#define POSSIBLE(q) ((q) ? \"POSSIBLE\" : \"IMPOSSIBLE\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) do { cerr << \"[DEBUG] \" #q \": [\"; REP(i, (q).size()) { cerr << (q)[i] << (i == i_len-1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl; } while (false)\ntemplate<class T> T gcd(T a, T b) { if (a < b) std::swap(a, b); while (b) std::swap(a %= b, b); return a; }\ntemplate<class T> T lcm(const T a, const T b) { return a / gcd(a, b) * b; }\n\n// gcc拡張マクロ\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\n#define DANCE_ long\n#define ROBOT_ unsigned\n#define HUMAN_ signed\n#define CHOKUDAI_ const\nusing  ll = DANCE_ HUMAN_ DANCE_;\nusing ull = DANCE_ ROBOT_ DANCE_;\nusing cll = DANCE_ DANCE_ CHOKUDAI_;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n// 剰余演算\nconstexpr ll pdiv = 998244353LL; // 10^9+7\nll powll(ll a, ll n) {\n    ll result = 1;\n    ll base = a;\n    ll mask = 1;\n    while (mask <= n) {\n        if (n & mask) (result *= base) %= pdiv;\n        mask <<= 1;\n        (base *= base) %= pdiv;\n    }\n    return result;\n}\n\ninline ll invll(ll a) { return powll(a, pdiv-2); }\n\nvector<ll> fac_cache = {1}, invfac_cache = {1};\nvoid make_fac_cache(ll a) {\n    ll old_max = fac_cache.size() - 1;\n    if (a > old_max) {\n        fac_cache   .resize(a+1);\n        invfac_cache.resize(a+1);\n        for (ll i = old_max + 1; i <= a; i++) {\n            fac_cache[i] = fac_cache[i-1] * i % pdiv;\n        }\n        invfac_cache[a] = invll(fac_cache[a]);\n        for (ll i = a-1; i > old_max; i--) {\n            invfac_cache[i] = invfac_cache[i+1] * (i + 1) % pdiv;\n        }\n    }\n}\n\ninline ll    facll(ll a) { make_fac_cache(a); return fac_cache[a]; }\ninline ll invfacll(ll a) { make_fac_cache(a); return invfac_cache[a]; }\ninline bool isoutll(ll n, ll r) { return n < 0 || r < 0 || n < r; }\ninline ll nPr(ll n, ll r) { return isoutll(n, r) ? 0 : facll(n) * invfacll(n-r) % pdiv; }\ninline ll nCr(ll n, ll r) { return isoutll(n, r) ? 0 : facll(n) * invfacll(n-r) % pdiv * invfacll(r) % pdiv; }\ninline ll nHr(ll n, ll r) { return nCr(n+r-1, r); }\n\n// 処理内容\nint main() {\n    \n    // インタラクティブ問題では除去した方がいいかも\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    ll n; cin >> n;\n\n    ll coans = 0;\n    RANGE(i, n/2+1, n) {\n        (coans += nCr(n, i) * powll(2, n-i) % pdiv * 2 % pdiv) %= pdiv;\n    }\n\n    ll ans = (powll(3, n) + pdiv - coans) % pdiv;\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = int_fast64_t;\n\ntemplate<Int Mod = 998244353> class modint{\npublic:\n\tInt val;\n\tconstexpr modint(const Int x = 0) : val(x % Mod) {if(val < 0) val += Mod;}\n\tconstexpr modint operator+(const modint rhs) const {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint operator-() const {\n\t\treturn modint(Mod - val);\n\t}\n\tconstexpr modint &operator+=(const modint rhs){\n\t\tval += rhs.val;\n\t\tif(val >= Mod) val -= Mod;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator-=(const modint rhs){\n\t\tif(val < rhs.val) val += Mod;\n\t\tval -= rhs.val;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator*=(const modint rhs){\n\t\tval *= rhs.val;\n\t\tval %= Mod;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator/=(const modint rhs){\n\t\treturn *this *= inv(rhs);\n\t}\n\tconstexpr modint &operator++(){\n\t\t++val;\n\t\tif(val == Mod) val = 0;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator--(){\n\t\t--val;\n\t\tif(val == -1) val = Mod - 1;\n\t\treturn *this;\n\t}\n\tconstexpr modint operator<<(const Int rhs) const {\n\t\treturn modint(*this) << rhs;\n\t}\n\tconstexpr modint operator>>(const Int rhs) const {\n\t\treturn modint(*this) >> rhs;\n\t}\n\tconstexpr modint &operator<<=(const Int rhs){\n\t\tval <<= rhs;\n\t\tval %= Mod;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator>>=(const Int rhs){\n\t\tval >>= rhs;\n\t\tval %= Mod;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator==(const modint rhs) const {\n\t\treturn val == rhs.val;\n\t}\n\tconstexpr bool operator!=(const modint rhs) const {\n\t\treturn val != rhs.val;\n\t}\n\tconstexpr bool operator<(const modint rhs) const {\n\t\treturn val < rhs.val;\n\t}\n\tconstexpr bool operator>(const modint rhs) const {\n\t\treturn val > rhs.val;\n\t}\n\tconstexpr bool operator<=(const modint rhs) const {\n\t\treturn val <= rhs.val;\n\t}\n\tconstexpr bool operator>=(const modint rhs) const {\n\t\treturn val >= rhs.val;\n\t}\n\tfriend ostream& operator<<(ostream& os, const modint<Mod>& m){\n\t\treturn os << m.val;\n\t}\n\tfriend istream& operator>>(istream& is, modint<Mod>& m){\n\t\treturn is >> m.val;\n\t}\n\tstatic constexpr modint inv(modint m){\n\t\tInt a = m.val, b = Mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tInt t = a / b;\n\t\t\ta -= t * b;\n\t\t\tswap(a, b);\n\t\t\tu -= t * v;\n\t\t\tswap(u, v);\n\t\t}\n\t\tu %= Mod;\n\t\tif(u < 0) u += Mod;\n\t\treturn modint(u);\n\t}\n\tconstexpr operator Int() const {\n\t\treturn val;\n\t}\n};\nusing mint = modint<>;\nvector<mint> fact(1, 1);\nmint comb(Int n, Int r){\n\tif(n < 0 || r < 0 || n - r < 0) return 0;\n\twhile(Int(fact.size()) <= n)\n\t\tfact.push_back(fact.back() * mint(fact.size()));\n\treturn fact[n] / fact[r] / fact[n-r];\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tInt n; cin >> n;\n\tn /= 2;\n\tmint ans(1);\n\tfor(Int i=0; i<n; ++i)\n\t\tans *= mint(9);\n\tmint s(0);\n\tfor(Int i=1; i<=n; ++i){\n\t\tmint tmp(0);\n\t\tfor(Int j=0; j<i; ++j){\n\t\t\ttmp += comb(n-i, j);\n\t\t}\n\t\ttmp *= comb(n, i);\n\t\tfor(Int j=0; j<n-i; ++j)\n\t\t\ttmp *= mint(4);\n\t\ts += tmp;\n\t}\n\ts *= mint(2);\n\tans -= s;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\tlong long NOW = 1;\n\tfor (int X = N; X > N / 2; X--) {\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= NOW;\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t\tNOW = (NOW * 2) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Q=998244353;\ninline int inv(int x){\n\tint r=1,y=Q-2;\n\twhile(y){\n\t\tif(y&1) r=1LL*r*x%Q;\n\t\tx=1LL*x*x%Q;\n\t\ty>>=1;\n\t}\n\treturn r;\n}\nint main(){\n\tint n,p3=1,cur=2;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tp3=p3*3LL%Q;\n\t}\n\tfor(int i=0;i<n/2;i++){\n\t\tp3=(p3+Q-cur)%Q;\n\t\tcur=2LL*cur*(n-i)%Q*inv(i+1)%Q;\n\t}\n\tprintf(\"%d\\n\",p3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 1e7 + 5;\nconst int P = 998244353;\nint fac[N], ifac[N];\n\nint Pow(int x, int t)\n{\n\tint res = 1;\n\tfor (; t; t >>= 1, x = 1LL * x * x % P)\n\t\tif (t & 1) res = 1LL * res * x % P;\n\treturn res;\n}\n\nint C(int n, int m)\n{\n\tif (n < m || m < 0) return 0;\n\treturn 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;\n}\n\nint main()\n{\n\tint n = read();\n\t\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) fac[i] = 1LL * i * fac[i - 1] % P;\n\tifac[n] = Pow(fac[n], P - 2);\n\tfor (int i = n; i >= 1; --i) ifac[i - 1] = 1LL * i * ifac[i] % P;\n\t\n\tint ans = Pow(3, n); \n\tfor (int i = n / 2 + 1; i <= n; ++i) \n\t\tans = (ans - 2LL * C(n, i) * Pow(2, n - i) % P + P) % P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<string>\n#include<stack>\n#include<set>\n#include<map>\n#include<time.h>\n#include<cstdlib>\ntypedef long long ll;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define mm(a) memset(a,0,sizeof(a))\n#define lr rt<<1\n#define rr rt<<1|1\n#define sync std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define inf 0x3f3f3f3f\n#define eqs 1e-8\n#define lb(x) (x&(-x))\n#define ch(a) (int(a-'a')+1)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef pair<int,int> pii;\nconst double pi=acos(-1);\nconst int maxn=10000005;\n//const ll Mod=1000000007;\nconst ll Mod=998244353;\nusing namespace std;\n \nll p[maxn],inv[maxn];\n//inv[0]=inv[1]=1;\n//inv[i]=1LL*(Mod-Mod/i)*inv[Mod%i]%Mod;\n//S(n,m)=S(n,m−1)+C(​​n m​​),S(n,m)=2S(n−1,m)−C(​​n−1 m​​)\nll ksm(ll x,ll y)\n{\n    ll res=1;\n    while(y)\n    {\n        if(y&1)\n        {\n            res=res*x%Mod;\n        }\n        x=x*x%Mod;\n        y/=2;\n    }\n    return res%Mod;\n}\n \nll C(int n,int m)\n{\n    return p[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main()\n{\n    sync;\n    int n;\n    cin>>n;\n    p[0]=inv[0]=1;\n    for(int i=1;i<=maxn-2;i++)\n    {\n        p[i]=p[i-1]*i%Mod;\n//        inv[i]=ksm(p[i],Mod-2);\n    }\n    inv[maxn-2]=ksm(p[maxn-2],Mod-2);     //阶乘的逆元\n    for(int i=maxn-3;i>=0;i--)\n        inv[i]=inv[i+1]*(i+1)%Mod;\n    ll ans=0;\n    for(int i=n/2+1;i<=n;i++)\n        ans=(ans+1ll*C(n,i)*ksm(2,n-i)%Mod)%Mod;\n    ans=(ksm(3,n)-ans*2%Mod+Mod)%Mod;\n    cout<<ans<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MOD=998244353;\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(1e7+2),Finverse(1e7+2);\nvoid Cinit(){// limit is 5e6 /// write Cinit&pw /// this takes 792ms at AtCoder\n  Factorial[0]=1;\n  for(int i=1;i<1e7+2;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<1e7+2;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n\nsigned main(){\n  Cinit();\n  int n;cin>>n;\n  int ans=pw(3,n);\n  for(int i=n/2+1;i<=n;i++){\n    ans-=2*nCk(n,i)*pw(2,n-i)%MOD;\n    ans+=MOD;ans%=MOD;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=10000003,INF=1<<30;\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\n\nint main(){\n    \n    make();\n    \n    int N;cin>>N;\n    \n    ll ans=rui(3,N);\n    \n    for(int i=N/2+1;i<=N;i++){\n        ans+=2*(mod-(comb(N,i)*rui(2,N-i))%mod);\n        ans%=mod;\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define p 998244353\nusing namespace std;\nint jc[10000010],njc[10000010],inv[10000010],n,mi[10000010];\nint C(int x,int y){\n\treturn 1ll*jc[x]*njc[y]%p*njc[x-y]%p;\n}\nint main(){\n\tfor(int i=0;i<2;i++)jc[i]=njc[i]=inv[i]=1;\n\tint n;cin>>n;\n\tmi[0]=1;mi[1]=2;\n\tfor(int i=2;i<=n;i++){\n\t\tjc[i]=1ll*jc[i-1]*i%p;\n\t\tinv[i]=1ll*inv[p%i]*(p-p/i)%p;\n\t\tnjc[i]=1ll*njc[i-1]*inv[i]%p;\n\t\tmi[i]=1ll*mi[i-1]*2%p;\n\t}\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)ans=1ll*ans*3%p;\n\tfor(int i=n/2+1;i<=n;i++){\n\t\t(ans-=2ll*C(n,i)*mi[n-i]%p)%=p;\n\t}\n\tcout<<(ans+p)%p;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=998244353;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvector<int>kaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nint comb(int a,int b){\n    //if(!kaijo[0])init_fact(2000010);\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\n\nsigned main(){\n    int n;\n    cin>>n;\n    init_fact(20000010);\n    int Comb=comb(n,n/2);\n    int ans=modpow(3,n);\n    int beki[20000002];\n    beki[0]=1;\n    for(int i=1;i<=n+1;i++){\n        beki[i]=beki[i-1]*2%mod;\n    }\n    for(int i=n/2+1;i<=n;i++){\n        ans-=comb(n,i)*beki[n-i+1]%mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst long long mod = 998244353LL;\n\nint n;\n\nlong long pw(long long a, long long b) {\n  if (b == 0LL) return 1LL;\n  long long r = pw(a, b >> 1);\n  r = (r * r) % mod;\n  if (b & 1LL) r = (a * r) % mod;\n  return r;\n}\n\nlong long inv(long long x) {\n  return pw(x, mod-2LL);\n}\n\nint main() {\n  cin >> n;\n\n  long long ans = 1LL;\n  for (int i = 0; i < n; ++i) ans = (3 * ans) % mod;\n\n  long long val = 1LL, sum = 0LL;\n  for (int i = n; i > n/2; --i) {\n    sum = (sum + 2 * val) % mod;\n    val = (val * i % mod * inv(n-i+1)) % mod;\n    val = (val * 2) % mod;\n  }\n\n  ans = (ans - sum) % mod;\n  ans = (ans % mod + mod) % mod;\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define yes { cout << \"YES\" << endl; exit(0); }\n#define no { cout << \"NO\" << endl; exit(0); }\n#define impossible { cout << \"Impossible\" << endl; exit(0); }\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> Pair;\n\nconst int Nmax = 1e7 + 5, Mod = 998244353;\n\nint n;\nint doi[Nmax], fact[Nmax], ifact[Nmax];\n\nstatic int inm(int x, int y)\n{\n    return (ll) x * y % Mod;\n}\n\nvoid add_to(int &x, int y)\n{\n    x += y; if(x >= Mod) x -= Mod;\n}\n\nvoid inm_to(int &x, int y)\n{\n    x = (ll) x * y % Mod;\n}\n\nstatic int comb(int n, int k)\n{\n    return inm( fact[n], inm(ifact[k], ifact[n-k]) );\n}\n\nint power(int a, int b)\n{\n    int ans = 1;\n    while(b)\n    {\n        if(b&1) inm_to(ans, a);\n        b >>= 1;\n        inm_to(a, a);\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"inputC\", \"r\", stdin);\n    // freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    cin >> n;\n\n    int i;\n    int ans = 1;\n    \n    doi[0] = 1; fact[0] = 1; ifact[0] = 1;\n    for(i=1; i<=n; ++i) inm_to(ans, 3), doi[i] = inm(doi[i-1], 2), fact[i] = inm(fact[i-1], i);\n\n    ifact[n] = power(fact[n], Mod-2);\n    for(i=n-1; i; --i) ifact[i] = inm(ifact[i+1], i+1);\n\n    int wrong = 0;\n    for(i=n/2+1; i<=n; ++i)\n        add_to( wrong, inm (comb(n, i), doi[n-i] ) );\n    \n    inm_to(wrong, 2);\n    add_to(ans, Mod - wrong);\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//さすが解説は天才的ですねー\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n//#include<bits/stdc++.h>\n#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst int mod = 998244353;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nconst int IMAX = 10000001;\nint ifac[IMAX + 1];\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tll facN = 1;\n\trep1(i, N) facN = facN * i % mod;\n\tifac[N] = modpow(facN, mod - 2);\n\tfor (int i = N; i > 0; i--) ifac[i - 1] = (ll)ifac[i] * i % mod;\n\n\tll kotae = modpow(3, N);\n\n\tll hiku = 0;\n\tint k = 1;\n\trep(i, N / 2) {\n\t\thiku += (ll)ifac[i] * ifac[N - i] % mod * k % mod;\n\t\tk = k * 2 % mod;\n\t}\n\thiku = hiku % mod * facN * 2 % mod;\n\tprintf(\"%lld\", (kotae - hiku + mod) % mod);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=10000005;\nconst int MOD=998244353;\nint n;\nlong long pw2[N],pw3[N];\nlong long fac[N],inv[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=10000000)\n{\n\tpw2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpw2[i]=pw2[i-1]*2%MOD;\n\tpw3[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpw3[i]=pw3[i-1]*3%MOD;\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d\",&n);\n\tlong long ans=pw3[n];\n\tlong long res=0;\n\tfor(int i=n/2+1;i<=n;i++)\n\t\tres=(res+C(n,i)*pw2[n-i]%MOD)%MOD;\n\tfor(int i=n/2+1;i<=n;i++)\n\t\tres=(res+C(n,i)*pw2[n-i]%MOD)%MOD;\n\tans=(ans-res+MOD)%MOD;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF, R;\n\nlong long Comb(long long A, long long B) {\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nint main() {\n\tlong long N, NG = 0;\n\tcin >> N;\n\tF.resize(N + 1), RF.resize(N + 1), R.resize(N + 1);\n\tF[0] = F[1] = RF[0] = RF[1] = R[0] = R[1] = 1;\n\tfor (int i = 2; i <= N; i++) {\n\t\tF[i] = (F[i - 1] * i) % MOD;\n\t\tR[i] = MOD - (R[MOD % i] * (MOD / i)) % MOD;\n\t\tRF[i] = (RF[i - 1] * R[i]) % MOD;\n\t}\n\tlong long NOW = 1;\n\tfor (int X = N; X > N / 2; X--) {\n\t\tlong long COUNT = Comb(N, X);\n\t\tCOUNT *= NOW;\n\t\tCOUNT %= MOD;\n\t\tNG = (NG + COUNT) % MOD;\n\t\tNOW = (NOW * 2) % MOD;\n\t}\n\tcout << (Calc(3, N) - NG * 2 + MOD * 2) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// scott_wu氏\n// https://atcoder.jp/contests/agc040/submissions/8281419\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst LL MOD = 998244353;\nconst int MAXN = 1.1e7;\n\nLL fac[MAXN];\nLL finv[MAXN];\n\nLL cpow(LL b, int e){\n    if(e == 0) return 1;\n    LL v = cpow(b, e / 2);\n    v = (v * v) % MOD;\n    if(e % 2) v = (v * b) % MOD;\n    return v;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n    fac[0] = 1;\n    for(int i = 1; i <= N; i++) fac[i] = (fac[i - 1] * i) % MOD;\n    finv[N] = cpow(fac[N], MOD - 2);\n    for(int i = N - 1; i >= 0; i--) finv[i] = (finv[i + 1] * (i + 1)) % MOD;\n    LL p2 = 1;\n    LL ans = 0;\n    for(int i = 0; i < N / 2; i++){\n        // N choose i * 2 ^ i\n        LL nadd = (fac[N] * ((finv[i] * finv[N - i]) % MOD)) % MOD;\n        ans = (ans + (nadd * p2)) % MOD;\n        p2 = (2 * p2) % MOD;\n    }\n    ans = (2 * ans) % MOD;\n    LL p3 = 1;\n    for(int i = 0; i < N; i++) p3 = (3 * p3) % MOD;\n    ans = (p3 - ans + MOD) % MOD;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<unordered_map>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n#define MOD 998244353\n\n\n//逆元で二項係数を計算(MODは素数)　前処理O(n),本計算O(1)\n#define MAXN 10000000\nlong long inv[MAXN + 1];//MODを法とする乗法の逆元\nlong long fact[MAXN + 1];//階乗\nlong long ifact[MAXN + 1];//階乗の逆元\nvoid init(int n) {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = i * fact[i - 1] % MOD;\n\t\tifact[i] = ifact[i - 1] * inv[i] % MOD;\n\t}\n}\nlong long C(int n, int r) {\n\tif (n < 0 || r < 0 || r > n)return 0;\n\tif (r > n / 2)r = n - r;\n\treturn fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\n//x^y%MOD\nlong long pow_mod(long long x, long long y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1)res = (res * x) % MOD;\n\t\ty >>= 1;\n\t\tx = (x * x) % MOD;\n\t}\n\treturn res;\n}\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t\n\n\tint n;\n\tcin >> n;\n\tinit(n);\n\tlong long ans = pow_mod(3, n);\n\n\tfor (int i = n / 2 + 1; i <= n; i++) {\n\t\tlong long c = C(n, i) * 2;\n\t\tc *= pow_mod(2, n - i);\n\t\tans -= c % MOD;\n\t}\n\tans %= MOD;\n\tans += MOD;\n\tans %= MOD;\n\n\tcout << ans << endl;\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod=998244353;\n\nll n;\nll jc[10000010];\n\nll power(ll a,ll b)\n{\n\tll res=1ll;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t{\n\t\t\tres*=a;\n\t\t\tres%=mod;\n\t\t}\n\t\ta*=a;\n\t\ta%=mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nvoid init()\n{\n\tjc[0]=1ll;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tjc[i]=jc[i-1]*i%mod;\n\t}\n}\n\nll C(ll x,ll y)\n{\n\treturn jc[x]*power(jc[x-y],mod-2)%mod*power(jc[y],mod-2)%mod;\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tinit();\n\tll ans=power(3ll,n);\n\tll tot=0;\n\tfor(ll i=n/2+1;i<=n;i++)\n\t{\n//\t\tcout<<\"qaq\"<<endl;\n\t\ttot=(tot+C(n,i)*power(2ll,n-i)%mod+mod)%mod;\n\t}\n\tprintf(\"%lld\",((ans-2*tot)%mod+mod)%mod);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate <typename T> T mod_pow(T n, T r, T m) {\n\tT ret = 1;\n\tT tmp = n;\n\twhile (r != 0) {\n\t\tif (r % 2) {\n\t\t\tret *= tmp;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= m;\n\t\tret %= m;\n\t\tr /= 2;\n\t}\n\treturn ret;\n}\n\ntemplate <typename T> T mod_inv (T a, T m) {\n\treturn mod_pow(a, m - 2, m);\n}\n\n template <typename T> T mod_div (T a, T b, T m) {\n\treturn a * mod_inv(b, m) % m;\n}\n\nint main() {\n\tull mod = 998244353;\n\t\n\tuint N;\n\tcin >> N;\n\t\n\tull a_comb = 1;\n\tull bc_comb = 1;\n\tull major = 1;\n\t\n\tfor(uint i=1; i<N/2; i++) {\n\t\ta_comb = mod_div(a_comb * (N - i + 1) % mod, (ull)i, mod);\n\t\t//a_comb = a_comb * (N - i + 1) / i;\n\t\t//cout << N << \"C\" << i << \":\" << a_comb << endl;\n\t\tbc_comb = bc_comb * 2 % mod;\n\t\tull comb = a_comb * bc_comb % mod;\n\t\tmajor = (major + comb) % mod;\n\t}\n\t\n\tmajor = major * 2 % mod;\n\tull whole = mod_pow((ull)3, (ull)N, mod);\n\t\n\tull ans = (whole > major) ? (whole - major) % mod : mod + whole - major;\n\t\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse2,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n\nconst long long MOD = 998244353;\n\nlong long inv[10000005];\nlong long invFact[10000005];\nlong long fact[10000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*((invFact[a-b]*invFact[b])%MOD)%MOD;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n\n    inv[1] = 1;\n    for(int i = 2; i <= N; i ++){\n        inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD;\n    }\n\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n        invFact[i] = (invFact[i-1]*inv[i])%MOD;\n    }\n\n    long long tempPow2 = 1;\n    long long ans = 0;\n    for(int i = N; i > (N>>1); i --){\n        ans += tempPow2*ncr(N, i)%MOD;\n\n        tempPow2 += tempPow2;\n        if(tempPow2 >= MOD){tempPow2 -= MOD;}\n    }\n    //printf(\"ans(%d)=%lld\\n\", N, ans);\n    ans = (ans+ans)%MOD;\n    long long finalAns = (powmod(3, N)-ans+MOD)%MOD;\n\n    printf(\"%lld\", finalAns);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 998244353;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll num_): num((num_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return num; }\n\n    template <typename T>\n    void check_type(const T &num_) const {\n        assert(num_ >= 0 && num_ < MOD);\n        static_assert(is_integral<T>::value == true || is_same<T,modint>::value == true);\n    }\n\n    template <typename T>\n    modint operator+(const T &r) const { check_type(r); return modint(num + r); }\n    template <typename T>\n    modint operator-(const T &r) const { check_type(r); return modint(num - r); }\n    template <typename T>\n    modint operator*(const T &r) const { check_type(r); return modint(num * r); }\n    template <typename T>\n    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }\n\n    template <typename T>\n    modint operator+=(const T &r) { return *this = *this + r; }\n    template <typename T>\n    modint operator-=(const T &r) { return *this = *this - r; }\n    template <typename T>\n    modint operator*=(const T &r) { return *this = *this * r; }\n    template <typename T>\n    modint operator/=(const T &r) { return *this = *this / r; }\n\n    static modint pow(const modint &x, const ll &r) {\n        if(r == 0) return 1;\n        return pow(x*x, r/2) * modint(r&1 ? x : modint(1));\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) {\n            int size = factorial.size();\n            factorial.resize(n+1);\n            for (int k = size; k <= n; k++) {\n                factorial[k] = factorial[k-1] * k;\n            }\n        }\n        return factorial[n];\n    }\n\n    static modint C(int n, int r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n};\nvector<modint> modint::factorial = {1};\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    int n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * 2;\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long MAX = 10000000;\nconst long MOD = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (long i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(long n, long k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nlong long powmod(long x,long p){\n  if(p==0)return 1;\n  if(p%2)return powmod(x,p-1)*x%MOD;\n  long long a=powmod(x,p/2);return a*a%MOD;\n}\nint main() {\n  COMinit();\n  long N;cin>>N;\n  long X=0;\n  for(long k=N/2+1;k<=N;k++){\n    X=(X+COM(N,k)*powmod(2,N-k))%MOD;\n  }\n  long ans=(powmod(3,N)-2*X+2*MOD)%MOD;\n  cout<<ans<<endl;\n}\n\n\n\n/*\n消去によって偶奇は変化しない\n偶A or 奇B -> X\n偶B or 奇A -> Y\nと変換すると\nXXとYYが消せないものになる\nどのような消し方をしてもXXが余ってしまうのは, X>N/2の時\n\nXがk個になる場合の数は\nnCk * 2^(N-k)\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse4,popcnt,abm,mmx,tune=native\")\n#include <bits/stdc++.h>\n#define gc getchar()\n#define pc(x) putchar(x)\ntemplate<typename T> void scan(T &x){x = 0;register bool _=0;register T c=gc;_=c==45;c=_?gc:c;while(c<48||c>57)c=gc;for(;c<48||c>57;c=gc);for(;c>47&&c<58;c=gc)x=(x<<3)+(x<<1)+(c&15);x=_?-x:x;}\ntemplate<typename T> void printn(T n){register bool _=0;_=n<0;n=_?-n:n;char snum[65];int i=0;do{snum[i++]=n%10+48;n/= 10;}while(n);--i;if (_)pc(45);while(i>=0)pc(snum[i--]);}\ntemplate<typename First, typename ... Ints> void scan(First &arg, Ints&... rest){scan(arg);scan(rest...);}\ntemplate<typename T> void print(T n){printn(n);pc(10);}\ntemplate<typename First, typename ... Ints> void print(First arg, Ints... rest){printn(arg);pc(32);print(rest...);}\n\nusing ll = long long;\nusing T = ll;\nll mod = 998244353;\n\nll gcd(ll gcd_a, ll gcd_b){return gcd_b == 0 ? gcd_a : gcd(gcd_b, gcd_a % gcd_b);}\nll fpow(ll fpow_b, ll fpow_exp, ll fpow_mod){if(fpow_exp == 0) return 1;ll t = fpow(fpow_b,fpow_exp/2,fpow_mod);if(fpow_exp&1) return t*t%fpow_mod*fpow_b%fpow_mod;return t*t%fpow_mod;}\nll divmod(ll divmod_i, ll divmod_j, ll divmod_mod){divmod_i%=divmod_mod,divmod_j%=divmod_mod;return divmod_i*fpow(divmod_j,divmod_mod-2,divmod_mod)%divmod_mod;}\n\nint n;\n\nT exgcd(T a, T b, T &x, T &y){\n    if(a == 0){\n        x = 0, y = 1;\n        return b;\n    }\n    T x1, y1;\n    T d = exgcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\nint main(){\n    \n    scan(n);\n    ll ans = fpow(3, n, mod)-2, bi = 2;\n    for(int i = 1; i < n/2; i++){\n        bi = bi*2*(n-i+1)%mod;\n        //x2, others have two options\n        ll inv, z;\n        exgcd(i, mod, inv, z);\n        if(inv < mod) inv += mod;\n        bi = bi*inv%mod;\n        \n        ans -= bi; //A or B\n        if(ans < 0)\n            ans += mod;\n    }\n    print(ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e7 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nconst int N = 1e7 + 7;\nint n;\nmodint a[N], now;\n\nint main() {\n\trd(n), init(n);\n\ta[0] = 1;\n\tfor (int i = 1; i <= n; i++) a[i] = a[i-1] * 2;\n\tfor (int i = n / 2 + 1; i <= n; i++) now += binom(n, i) * a[n-i];\n\tprint(((modint)3 ^ n) - 2 * now);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\n#define ss(x) (int) x.size()\n#define pb push_back\n#define ll long long\n#define cat(x) cerr << #x << \" = \" << x << endl\n#define FOR(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nconst int mod = 998244353;\nconst int nax = 1e7 + 11;\n\nint pt(int a, int b) {\n\tint c = 1;\n\twhile(b) {\n\t\tif(b & 1)\n\t\t\tc = 1ll * c * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb /= 2;\n\t}\n\treturn c;\n}\n\nint n;\nint fac[nax];\nint rev[nax];\nint two[nax];\n\nint nt(int N, int K) {\n\treturn 1ll * fac[N] * rev[K] % mod * rev[N - K] % mod;\n}\n\nint main() {\n\tfac[0] = 1;\n\trev[0] = 1;\n\ttwo[0] = 1;\n\tfor(int i = 1; i < nax; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\trev[i] = pt(fac[i], mod - 2);\n\t\ttwo[i] = 1ll * two[i - 1] * 2 % mod;\n\t}\n\tscanf(\"%d\", &n);\n\tint ans = pt(3, n);\n\t\n\tfor(int i = n / 2 + 1; i <= n; ++i) \n\t\tans = (ans - 1ll * nt(n, i) * two[n - i] % mod * 2 % mod + mod) % mod;\n\tprintf(\"%d\\n\", ans);\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) (a).begin(),(a).end()\ntypedef long long ll;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define lb(s,x) (lower_bound(all(s),x)-s.begin())\n#define ub(s,x) (upper_bound(all(s),x)-s.begin())\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define bit(k) (1LL<<(k))\nconst int INF = 1e9;\n\n#define debug(x) cerr<<(#x)<<\": \"<<(x)<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n\nclass modint {\n  public:\n    using ll = long long;\n    ll num;\n    static const ll MOD = 1e9+7;\n    static vector<modint> factorial;\n\n    modint(): num(0) {};\n    modint(ll n_): num((n_ + MOD) % MOD) {}\n    modint(const modint &r): num(r.num) {}\n    operator ll() const { return (num+MOD)%MOD; }\n    friend istream& operator>>(istream& is, modint &r){\n        ll num_;\n        is >> num_;\n        r = num_;\n        return is;\n    }\n    modint operator+(const modint &r) const { return modint(num + r.num); }\n    modint operator-(const modint &r) const { return modint(num - r.num); }\n    modint operator*(const modint &r) const { return modint(num * r.num); }\n\n    template<typename T>\n    modint operator^(const T &r) const {\n        if(r == 0) return 1;\n        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);\n    }\n    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }\n\n    modint operator+=(const modint &r) { return *this = *this + r; }\n    modint operator-=(const modint &r) { return *this = *this - r; }\n    modint operator*=(const modint &r) { return *this = *this * r; }\n    modint operator/=(const modint &r) { return *this = *this / r; }\n\n    template<typename T>\n    modint operator^=(const T &r) { return *this = *this ^ r; }\n\n    static modint pow(const modint x, ll r) {\n        return x^r;\n    }\n\n    static modint fact(int n){\n        if((int)factorial.size() <= n) factorial.resize(n+1);\n        if(factorial[n]) return factorial[n];\n        if(n == 0) return 1;\n        return factorial[n] = modint(n) * fact(n-1);\n    }\n\n    static modint C(ll n,ll r){\n        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);\n    }\n};\nvector<modint> modint::factorial;\n#define fact(n) modint::fact(n)\n#define C(n,r) modint::C(n,r)\n#define H(a,b) C(a+b, a)\n\n\nint main(void){\n    ll n;\n    cin >> n;\n    modint sum = 0;\n    for (int i = n/2+1; i <= n; i++) {\n        sum += C(n,i) * modint::pow(2,n-i) * modint(2);\n    }\n    cout << modint::pow(3,n) - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ull * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^= (T arg) {\n\t\treturn *this = *this ^ arg;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 998244353;\ntypedef modint<MOD> mint;\n\nconst int HI = 10'000'005;\nmint f[HI], finv[HI];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tint n;\n\tcin >> n;\n\n\tf[0] = finv[0] = 1;\n\tfor (int i=1; i<HI; i++) {\n\t\tf[i] = f[i-1] * i;\n\t\tfinv[i] = f[i].inv();\n\t}\n\n\tmint sol = mint(3) ^ n;\n\tfor (int i=n/2+1; i<=n; i++) {\n\t\tsol -= f[n] * finv[i] * finv[n-i] * (mint(2) ^(n-i)) * 2;\n\t}\n\tcout << (int)sol << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e7 + 7;\nconst int MX = 998244353;\nconst LL INF = 1LL * MX * MX;\n\nint n;\nint rv[N];\nint sil[N];\n\nint fast(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1)\n\t\t\tret = (1LL * ret * a) % MX;\n\t\t\n\t\tb >>= 1;\n\t\ta = (1LL * a * a) % MX;\n\t}\n\t\n\treturn ret;\n}\n\ninline int newton(int a, int b){\n\treturn (((1LL * sil[a] * rv[b]) % MX) * rv[a - b]) % MX;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tsil[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tsil[i] = 1LL * i * sil[i - 1] % MX;\n\t\n\trv[n] = fast(sil[n], MX - 2);\n\tfor(int i = n; i >= 1; --i)\n\t\trv[i - 1] = 1LL * i * rv[i] % MX;\n\t\n\tint cur = 1, ans = 0;\n\tfor(int i = n; i + i > n; --i){\n\t\tans = (ans + 1LL * cur * newton(n, i)) % MX;\n\t\tcur = (cur + cur) % MX;\n\t}\n\n\tans = (ans + ans) % MX;\n\tans = (fast(3, n) + MX - ans) % MX;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 998244353;\nint n;\nint dp[10000011][5];\t//a, b, c, aa, bb\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n;\n\t\n\tdp[1][0] = 1;\n\tdp[1][1] = 1;\n\tdp[1][2] = 1;\n\tdp[2][3] = 1;\n\tdp[2][4] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\trep(k, 3) {\n\t\t\t\tif (j == 0 && k == 0) continue;\n\t\t\t\tif (j == 1 && k == 1) continue;\n\t\t\t\tdp[i + 1][k] += dp[i][j];\n\t\t\t\tdp[i + 1][k] %= mod;\n\t\t\t}\n\t\t\tdp[i + 2][3] += dp[i][j];\n\t\t\tdp[i + 2][3] %= mod;\n\t\t\tdp[i + 2][4] += dp[i][j];\n\t\t\tdp[i + 2][4] %= mod;\n\t\t}\n\t\t\n\t\tfor (j = 3; j < 4; j++) {\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tdp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][2] += dp[i][j];\n\t\t\tdp[i + 1][2] %= mod;\n\t\t}\n\t}\n\t\n\tint res = dp[n][0] + dp[n][1] + dp[n][2];\n\tres %= mod;\n\t//cout << \"res = \" << res << endl;\n\t\n\tint p3 = 1;\n\trep(i, n) { p3 *= 3; p3 %= mod; }\n\t\n\tint ans = (p3 - res + mod) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int mod=998244353;\nint n;\nlong long ans,ji[10000007];\nlong long qpow(long long a,long long b) {\n\tlong long res=1;\n\tlong long now=a%mod;\n\twhile (b) {\n\t\tif (b&1) res=res*now%mod;\n\t\tnow=now*now%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid init(){\n\tji[0]=1;\n\tfor (int i=1; i<=n; i++) ji[i]=ji[i-1]*i%mod;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tinit();\n\tans=qpow(3,n);\n\tfor (int i=(n/2)+1; i<=n; i++) {\n\t\tans=(ans-(((((ji[n]*qpow(ji[i],mod-2))%mod)*qpow(ji[n-i],mod-2))%mod)*qpow(2,n-i)%mod))%mod;\n\t\tans=(ans-(((((ji[n]*qpow(ji[i],mod-2))%mod)*qpow(ji[n-i],mod-2))%mod)*qpow(2,n-i)%mod))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define rrep(i,n) RREP(i,n-1,0)\n#define REPL(i,m,n) for(ll i=(ll)(m); i<(ll)(n); i++)\n#define repl(i,n) REPL(i,0,n)\n#define all(v) v.begin(), v.end()\nconst int inf = 1e9+7;\nconst ll longinf = 1LL<<60;\nconst ll mod = 998244353;\n\n#define MAX_N 10000005\nll inv[MAX_N], fac[MAX_N], finv[MAX_N];\nvoid make() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for(int i=2; i<MAX_N; i++) {\n    inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n    fac[i] = fac[i-1] * (ll)i % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\nll perm(ll n, ll r) {\n  if(n < 0)       return 0;\n  else if(n < r)  return 0;\n  else            return (fac[n] * finv[n-r]) % mod;\n}\nll comb(ll n, ll r) {\n  ll ans = 1;\n  ans = perm(n, r);\n  ans = (ans * finv[r]) % mod;\n  return ans;\n}\nll binary_pow(ll a, ll N) {\n  ll ans = 1;\n  ll tmp = a;\n  while(N > 0) {\n    if(N % 2 == 1) {\n      ans *= tmp;\n      ans %= mod;\n    }\n    N /= 2;\n    tmp *= tmp;\n    tmp %= mod;\n  }\n  return ans;\n}\n\nint main() {\n  ll N;\n  cin >> N;\n  make();\n  ll cnt = 0;\n  REP(i, N/2+1, N+1) {\n    cnt += comb(N, i) * binary_pow(2, N-i);\n    cnt %= mod;\n  }\n  cout << (binary_pow(3, N) - cnt * 2 + mod * 2) % mod << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define trav(x, v) for(auto &x : v)\n#define all(v) v.begin(),v.end()\n#define sz(v) int(v.size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst ll mod = 998244353;\n\nll modpow(ll a, ll e){\n\tll res = 1;\n\tdo {\n\t\tif(e % 2) res = res * a % mod;\n\t\ta = a * a % mod;\n\t} while(e >>= 1);\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tcin.sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n;\n\tcin >> n;\trep(i,0,n) fs[i+1] = fs[i] * (i+1) % md;\n\trep(i,0,n) fs[i+1] = fs[i] * modpow(i+1, mod) % md;\n\n\n\tvector<ll> fs(n+1,1);\n\trep(i,0,n) fs[i+1] = fs[i] * (i+1) % mod;\n\n\tauto bin = [&](int n, int k){\n\t\treturn fs[n] * modpow(fs[k] * fs[n-k] % mod, mod-2) % mod;\n\t};\n\n\tll sub = 0;\n\n\trep(i,n/2+1,n+1) sub += bin(n, i) * modpow(2, n-i) % mod;\n\n\tll ans = modpow(3, n) - 2*sub;\n\tans %= mod;\n\n\tif(ans < 0) ans += mod;\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n// #include<ext/pb_ds/assoc_container.hpp>\n// #include<ext/pb_ds/tree_policy.hpp>\n// #include<ext/pb_ds/tag_and_trait.hpp>\n// using namespace __gnu_pbds;\n// #include<boost/multiprecision/cpp_int.hpp>\n// namespace multiprecisioninteger = boost::multiprecision;\n// using cint=multiprecisioninteger::cpp_int;\nusing namespace std;\nusing ll=long long;\n#define double long double\nusing datas=pair<ll,ll>;\nusing ddatas=pair<double,double>;\nusing tdata=pair<ll,datas>;\nusing vec=vector<ll>;\nusing mat=vector<vec>;\nusing pvec=vector<datas>;\nusing pmat=vector<pvec>;\n// using llset=tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>;\n#define For(i,a,b) for(i=a;i<(ll)b;++i)\n#define bFor(i,b,a) for(i=b,--i;i>=(ll)a;--i)\n#define rep(i,N) For(i,0,N)\n#define rep1(i,N) For(i,1,N)\n#define brep(i,N) bFor(i,N,0)\n#define brep1(i,N) bFor(i,N,1)\n#define all(v) (v).begin(),(v).end()\n#define allr(v) (v).rbegin(),(v).rend()\n#define vsort(v) sort(all(v))\n#define vrsort(v) sort(allr(v))\n#define endl \"\\n\"\n#define eb emplace_back\n#define print(v) cout<<v<<endl\n#define printyes cout<<\"Yes\"<<endl\n#define printno cout<<\"No\"<<endl\n#define printYES cout<<\"YES\"<<endl\n#define printNO cout<<\"NO\"<<endl\n#define output(v) do{bool f=0;for(auto outi:v){cout<<(f?\" \":\"\")<<outi;f=1;}cout<<endl;}while(0)\n#define matoutput(v) do{for(auto outimat:v)output(outimat);}while(0)\n// const ll mod=1000000007;\nconst ll mod=998244353;\nconst ll inf=1LL<<60;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\ntemplate<class T> inline bool chmax(T& a,T b){bool x=a<b;if(x)a=b;return x;} \ntemplate<class T> inline bool chmin(T& a,T b){bool x=a>b;if(x)a=b;return x;} \n\nvoid startupcpp(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(15);\n}\n\ndouble distance(ddatas x,ddatas y){\n  double a=x.first-y.first,b=x.second-y.second;\n  return sqrt(a*a+b*b);\n}\n\nll modinv(ll a) {\n  ll b=mod,u=1,v=0,t;\n  while(b){\n    t=a/b;\n    a-=t*b; swap(a,b);\n    u-=t*v; swap(u,v);\n  }\n  return (u+mod)%mod;\n}\n\nll moddevide(ll a,ll b){return (a*modinv(b))%mod;}\n\nvec modncrlistp,modncrlistm;\n\nll modncr(ll n,ll r){\n  if(n<r)return 0;\n  ll i,size=modncrlistp.size();\n  if(size<=n){\n    modncrlistp.resize(n+1);\n    modncrlistm.resize(n+1);\n    if(!size){\n      modncrlistp[0]=modncrlistm[0]=1;\n      size++;\n    }\n    For(i,size,n+1){\n      modncrlistp[i]=modncrlistp[i-1]*i%mod;\n      modncrlistm[i]=modinv(modncrlistp[i]);\n    }\n  }\n  return modncrlistp[n]*modncrlistm[r]%mod*modncrlistm[n-r]%mod;\n}\n\nll modpow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll gcd(ll a,ll b){if(!b)return abs(a);return (a%b==0)?abs(b):gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nll countdigits(ll n){\n  ll ans=0;\n  while(n){n/=10;ans++;}\n  return ans;\n}\n\nll sumdigits(ll n){\n  ll ans=0;\n  while(n){ans+=n%10;n/=10;}\n  return ans;\n}\n\nvector<int> topcoder(){\n  vector<int> v;\n  string s;\n  while(1){\n    cin>>s;\n    int i=s[0]=='{',x=0;\n    while(s[i]>='0'&&s[i]<='9'){\n      x=x*10+s[i]-'0';\n      ++i;\n    }\n    v.eb(x);\n    if(s[i]=='}')break;\n  }\n  return v;\n}\n\nint main(){\n  // startupcpp();\n  // int codeforces;cin>>codeforces;while(codeforces--){\n  ll i,j,N,ans=0;\n  cin>>N;\n  N>>=1;\n  For(i,N+1,N*2+1){\n    (ans+=modncr(N*2,i)*modpow(2,N*2-i+1))%=mod;\n  }\n  ans=modpow(3,N*2)-ans+mod;\n  print(ans%mod);\n  // }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long mod = 998244353ll;\n\n\nlong long modInverse(long long a, long long m)\n{\n    long long m0 = m;\n    long long y = 0, x = 1;\n\n    if (m == 1)\n      return 0;\n\n    while (a > 1)\n    {\n        // q is quotient\n        long long q = a / m;\n        long long t = m;\n\n        // m is remainder now, process same as\n        // Euclid's algo\n        m = a % m, a = t;\n        t = y;\n\n        // Update y and x\n        y = x - q * y;\n        x = t;\n    }\n\n    // Make x positive\n    if (x < 0)\n       x += m0;\n\n    return x;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tlong long ans = 1;\n\tfor(int i = 0;i < n;i++){\n\t\tans *= 3;\n\t\tans %= mod;\n\t}\n\t\n\tlong long v = 1;\n\tfor(int i = n;i > n/2;i--){\n\t\tans -= 2 * v;\n\t\t\n\t\tv *= 2;\n\t\tv *= i;\n\t\tv %= mod;\n\t\tv *= modInverse(n-i+1,mod);\n\t\tv %= mod;\n\t}\n\tans += mod*mod;\n\tans %= mod;\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n// #define inf  1000000007\n #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[10000100];\n                int inv[10000010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\nint dp[10002000];\n\nvoid solve(){\n\tint n;\n\tcin>>n;\nmod=998244353;\n\tgya(10000003);\n\tn/=2;\n//\tint ans=0;\n\t\n\tdp[n+1]=0;\n\tint g=1;\n\tfor(int i=n;i>=0;i--){\n\t\tdp[i]=dp[i+1]+comb(n,i)*g;\n\t\tdp[i]%=inf;\n\t\tg*=2;\n\t\tg%=inf;\n\t}\n\n\t\n\tint zen=beki(9,n,inf);\n\tg=1;\n\tfor(int a=n;a>=0;a--){\n\t\tint t=dp[n-a+1]*comb(n,a)%inf*g%inf*2%inf;\n\t\tzen+=inf-t;\n\t\tg*=2;\n\t\tg%=inf;\n\t}\n\t\n\tcout<<zen%inf<<endl;\n}\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nint n=1;\n\tfor(int i=0;i<n;i++)solve();\n\t\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 10000005;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n} c(MX);\n//\n\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  mint ans = 1;\n  rep(i,n) ans *= 3;\n  vm two(n+1);\n  two[0] = 1;\n  rep(i,n) two[i+1] = two[i]*2;\n  srep(i,n/2+1,n+1) {\n    ans -= c.c(n,i)*two[n-i]*2;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(ll i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(ll i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(1e7)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\n// binom mod MOD\nll binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;\n}\n\nint main() {\n  binom_init();\n  ll n; cin >> n;\n  n /= 2;\n\n  // vector<set<string>> S(n+1);\n  // S[0].insert(\"\");\n\n  // // vector<string> rf = {\"00\", \"11\", \"02\", \"12\", \"20\", \"21\", \"22\"};\n  // // vector<string> rf = {\"00\", \"11\"};\n  // vector<string> rf = {\"01\", \"10\", \"02\", \"12\", \"20\", \"21\", \"22\"};\n  // // vector<string> rf = {\"01\", \"10\"};\n  // // vector<string> rf = {\"00\", \"01\"};\n\n  // rep(i, n) {\n  //   for (auto &s : S[i]) rep(j, i+1) for (auto &r : rf) {\n  //     string t = s.substr(0, j) + r + s.substr(j);\n  //     S[i+1].insert(t);\n  //   }\n  //   cout << (i+1) << \" \" << S[i+1].size() << \"\\n\";\n  //   for (auto &s : S[i+1]) cout << s << \"\\n\";\n  // }\n\n  mint ans = 1;\n  mint z = 1;\n  rep(k, 2*n) {\n    z *= 2;\n    z -= binom(k, n) * 2;\n    ans += z * binom(2*n, k+1);\n  }\n\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 5000000, md = 998244353;\nint p2[N + 1], fc[N + 1], inv[N + 1], fcin[N + 1];\n\nvoid ad(int &x, int y) { if ((x += y) >= md)x-= md; }\nint ch(int n, int r) { return (ll)fc[n] * fcin[r] % md * fcin[n - r] % md; }\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tn >>= 1;\n\t\n\tfc[0] = 1;\n\tf(i, 1, n + 1)fc[i] = (ll)fc[i - 1] * i % md;\n\tinv[1] = 1;\n\tf(i, 2, n + 1)inv[i] = md - md / i * (ll)inv[md % i] % md;\n\tfcin[0] = 1;\n\tf(i, 1, n + 1)fcin[i] = (ll)fcin[i - 1] * inv[i] % md;\n\tp2[0] = 1;\n\tf(i, 1, n + 1)ad(p2[i] = p2[i - 1], p2[i - 1]);\n\t\n\tint an = 0, s = 0;\n\tf(i, 1, n + 1){\n\t\tad(s, (ll)ch(n, i - 1) * p2[i - 1] % md);\n\t\tad(an, (ll)p2[n - i] * ch(n, i) % md * s % md);\n\t}\n\tad(an, an);\n\tint z = 1;\n\tf(i, 0, n << 1)z = (ll)z * 3 % md;\n\tad(z, md - an);\n\tprintf(\"%d\\n\", z);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 11000000;\nconst i64 P = 998244353;\ni64 fact[maxn], tcaf[maxn];\n\ni64 deg(i64 x, i64 d) {\n    if (d < 0) d += P - 1;\n    i64 y = 1;\n    while (d) {\n        if (d & 1) (y *= x) %= P;\n        d /= 2;\n        (x *= x) %= P;\n    }\n    return y;\n}\n\ni64 cnk(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * tcaf[k] % P * tcaf[n - k] % P;\n}\n\nmap<string, int> memo;\n\nbool can(string s) {\n    if (s == \"\") return true;\n    if (memo.count(s)) return memo[s];\n    forn(i, s.size() - 1) {\n        if (s[i] == 'A' && s[i + 1] == 'B') continue;\n        if (s[i] == 'B' && s[i + 1] == 'A') continue;\n        string t;\n        forn(j, s.size()) if (j != i && j != i + 1) t += s[j];\n        if (can(t)) return memo[s] = 1;\n    }\n    return memo[s] = 0;\n}\n\nint n;\ni64 cnt[2];\n\nvoid rec(string &s) {\n    if (s.size() == n) {\n        ++cnt[can(s)];\n        if (!can(s)) cerr << s << '\\n';\n        return;\n    }\n    forn(i, 3) {\n        s += (char)('A' + i);\n        rec(s);\n        s.resize(s.size() - 1);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    cin >> n;\n    fact[0] = 1;\n    for1(i, n) fact[i] = fact[i - 1] * i % P;\n    forn(i, n + 1) tcaf[i] = deg(fact[i], -1);\n\n    i64 ans = 0;\n    fore(i, n / 2 + 1, n) (ans += cnk(n, i) * deg(2, n - i)) %= P;\n    (ans *= 2) %= P;\n    cout << (deg(3, n) - ans + P) % P << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pp pair<int,int>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define ll long long\n#define ld long double\n#define all(a) (a).begin(),(a).end()\n#define mk make_pair\nll MOD=1000000007;\nll mod=998244353;\nint inf=1000001000;\nll INF=100000000000000000;\n\nint main() {\n    vector<vector<ll>> a(1e7,vector<ll>(9));\n    a[0][0]=1;a[0][1]=0;a[0][2]=1;a[0][3]=0;a[0][4]=1;\n    a[0][5]=1;a[0][6]=1;a[0][7]=1;a[0][8]=1;\n    rep(i,1e7-1){\n        (a[i+1][0]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][1]+=a[i][3]+a[i][5]+a[i][6]+a[i][8])%=mod;\n        (a[i+1][2]+=a[i][0]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][3]+=+a[i][1]+a[i][2]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][4]+=a[i][0]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][5]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][6]+=a[i][0]+a[i][1]+a[i][2]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][7]+=a[i][0]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n        (a[i+1][8]+=a[i][0]+a[i][1]+a[i][2]+a[i][3]+a[i][4]+a[i][5]+a[i][6]+a[i][7]+a[i][8])%=mod;\n    }\n    int n;\n    cin >> n;\n    n=n/2-1;\n    cout << (a[n][0]+a[n][1]+a[n][2]+a[n][3]+a[n][4]+a[n][5]+a[n][6]+a[n][7]+a[n][8])%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10000005\n#define ll long long\n#define MOD 1000000007\nll po[MAX];\nll C[MAX];\nll sum[MAX];\n\nll bigMod(ll a, ll p)\n{\n    if(p == 0) return 1LL;\n    if(p == 1) return a;\n    ll ret = bigMod(a, p/2);\n    ret = (ret*ret)%MOD;\n    if(p & 1) ret = (ret*a)%MOD;\n    return ret;\n}\n\nll dv(ll a, ll b)\n{\n    b = bigMod(b, MOD-2);\n    ll ret = (a*b)%MOD;\n    return ret;\n}\n\nint main()\n{\n    po[0] = 1;\n    for(int i=1; i<MAX; i++){\n        po[i] = (po[i-1]*2)%MOD;\n    }\n    ll n;\n    scanf(\"%lld\", &n);\n    ll m = n/2;\n    C[0] = 1;\n    C[1] = m;\n    for(int i=2; i<=m; i++){\n        C[i] = (C[i-1]*(m-i+1))%MOD;\n        C[i] = dv(C[i], i);\n    }\n    ll tot = 0;\n    for(int i=0; i<=m; i++){\n        tot += (C[i]*po[m-i])%MOD;\n        tot = tot%MOD;\n        sum[i] = tot;\n    }\n    ll ans = 0;\n    for(int i=0; i<=m; i++){\n        ll cur1 = (C[i]*po[m-i])%MOD;\n        ll cur2 = (sum[m]-sum[m-i])%MOD;\n        if(cur2 < 0) cur2 += MOD;\n        ans += (cur1*cur2)%MOD;\n        ans = ans%MOD;\n    }\n    ans = (ans*2)%MOD;\n    ll all = 1;\n    for(int i=1; i<=n; i++){\n        all = (all*3)%MOD;\n    }\n    ans = (all-ans)%MOD;\n    if(ans < 0) ans += MOD;\n    cout << ans;\n}"
  },
  {
    "language": "Haskell",
    "code": "main :: IO ()\nmain = do\n  l1 <- getLine\n  let n = read l1 :: Integer\n  print $ h $ pow' 3 n 1 - (sum (map (f n) [1,3..n])`mod`998244353)\n\nf n m = fact' n 1`div`(fact' m 1 * fact' (n - m) 1)\n\npow' x 0 acc = acc\npow' x n acc = pow' x (n-1) $ x*acc`mod`998244353\n\nfact' 0 acc = acc\nfact' n acc = fact' (n-1) $ n*acc`mod`998244353\n\nh x = if x < 0 then x + 998244353 else x"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable #-}\n{-# OPTIONS_GHC -O2 #-}\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport Control.Arrow\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#)\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  let dups = countDups n\n  print $ fromMon $ monRep 3 ^ n - dups - dups\n  return ()\n\n\ncountDups :: Int -> Montgomery\ncountDups n = go (0::Int) zeroM zeroM oneM oneM\n  where\n    !nM = fromIntegral n\n    !zeroM = monRep 0\n    !oneM = monRep 1\n    !twoM = monRep 2\n    go k !acc !kM !comb !pow2\n      | k >= shiftR n 1 = acc\n      | otherwise = go (k+1) (acc + comb * pow2) kp1M combNext pow2Next\n      where\n        kp1M = kM + oneM\n        combNext = comb * (nM - kM) / kp1M\n        pow2Next = pow2 * twoM\n\n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger . (`mod` modulus)\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\ninstance Fractional Montgomery where\n  fromRational x = fromInteger (numerator x) / fromInteger (denominator x)\n  recip x | x == 0 = undefined\n          | otherwise = x ^ (modulus -2 :: Int)\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y - if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32)\n          $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\n\n#define IL(f) {-# INLINE f #-}; f\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  showAsBuilder = BSB.string8 . show\n\n#define INS(t,f) instance ShowAsBuilder t where \\\n  { {-# INLINE showAsBuilder #-}; showAsBuilder=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  showAsBuilder = v2BSpcSep\n\n{-# INLINE putBuilder #-}\nputBuilder = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\n{-# INLINE printVecInLines #-}\nprintVecInLines = putBuilder . v2BLines\n{-# INLINE printVecInSpcSepLn #-}\nprintVecInSpcSepLn = putBuilder . v2BSpcSepLn\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\n{-# INLINE v2BSpcSepLn #-}\nv2BSpcSepLn = v2BSpcSepLnWith showAsBuilder\n{-# INLINE v2BSpcSep #-}\nv2BSpcSep = v2BSpcSepWith showAsBuilder\n{-# INLINE v2BConcat #-}\nv2BConcat = v2BConcatWith showAsBuilder\n{-# INLINE v2BLines #-}\nv2BLines = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepLnWith #-}\nv2BSpcSepLnWith = v2BSpcSepPostfWith \"\\n\"\n{-# INLINE v2BSpcSepWith #-}\nv2BSpcSepWith = v2BSpcSepPostfWith \"\"\n{-# INLINE v2BConcatWith #-}\nv2BConcatWith showFct = VG.foldr ((<>) . showFct) mempty\n{-# INLINE v2BLinesWith #-}\nv2BLinesWith showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostf #-}\nv2BSpcSepPostf = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostfWith #-}\nv2BSpcSepPostfWith = vecToBuilder \"\" \" \"\n\n{-# INLINE vecToBuilder #-}\nvecToBuilder :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\n{-# INLINE vecToBuilder_ #-}\nvecToBuilder_ :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct vec\n  = prefix <> VG.foldr\n    (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n    (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\ngetVecGLn :: (VG.Vector v a) =>\n           Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\n{-# INLINE getVecGLn #-}\ngetVecGRest :: (VG.Vector v a) =>\n            Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\n{-# INLINE getVecGRest #-}\ngetVecLn :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\n{-# INLINE getVecLn #-}\ngetVecRest :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\n{-# INLINE getVecRest #-}\ngetVecULn :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\n{-# INLINE getVecULn #-}\ngetVecURest :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n{-# INLINE getVecURest #-}\n\nrInt :: StateT BSL.ByteString Maybe Int\nIL(rInt) = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nIL(rIntS) = StateT $ BS.readInt . BS.dropWhile (<'!')\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define N(f,g,h,a,m)\\\n  IL(f) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e);\\\n  f=A.newArray;\\\n  IL(g) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e);\\\n  g=A.newArray_;\\\n  IL(h) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> [e] -> m (a i e);\\\n  h=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport Control.Arrow\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#)\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  let dups = countDups n\n  print $ Rem 3 ^ n - dups - dups\n  return ()\n\n\ncountDups :: Int -> Rem\ncountDups n = VU.sum $ VU.zipWith (*) combinats power2s\n  where\n    oneM = Rem 1\n    !factoN = VU.foldl' (*) oneM $ VU.iterateN n (+oneM) oneM\n    !invFactos = VU.scanl' (*) (recip factoN)\n                $ VU.iterateN n (subtract oneM) (fromIntegral n)\n    !combinats = VU.zipWith (\\x y -> factoN*x*y) invFactos\n                 (VU.reverse invFactos)\n    !power2s = VU.iterateN (n `shiftR` 1) (\\x -> x+x) oneM\n    \n#define MODULUS 998244353\ntype RemRep = Int\n\nmodulus :: RemRep\nmodulus = MODULUS\n-- SEE BELOW for the parameter factMax\n\n\nnewtype Rem = Rem {unRem :: RemRep} deriving Eq\ninstance Num Rem where\n  Rem x - Rem y = Rem $ x-y + if x >= y then 0 else modulus\n  negate (Rem x) = Rem $ modulus - x\n  x + y = x - (-y)\n  fromInteger x = Rem $ fromInteger (x `mod` MODULUS)\n  Rem x * Rem y = Rem $ (x * y) `rem` modulus\n  abs = id\n  signum (Rem 0) = Rem 0\n  signum _ = Rem 1\n\ninstance Show Rem where\n  showsPrec = coerce (showsPrec :: Int -> RemRep -> ShowS)\n\n\nnewtype instance VU.Vector Rem\n  = VRem { unVRem :: VU.Vector Int }\nnewtype instance VUM.MVector s Rem\n  = VMRem { unVMRem :: VUM.MVector s Int }\ninstance VUM.Unbox Rem\n\ninstance VGM.MVector VUM.MVector Rem where\n  {-# INLINE basicLength #-}\n  basicLength = coerce `asTypeOf` (. unVMRem) $ VGM.basicLength\n  {-# INLINE basicUnsafeSlice #-}\n  basicUnsafeSlice\n    = coerce `asTypeOf` (\\f x y (VMRem v) -> VMRem $ f x y v)\n      $ VGM.basicUnsafeSlice\n  {-# INLINE basicOverlaps #-}\n  basicOverlaps = coerce `asTypeOf` (`on` unVMRem) $ VGM.basicOverlaps\n  {-# INLINE basicUnsafeNew #-}\n  basicUnsafeNew = fmap (coerce `asTypeOf` VMRem) . VGM.basicUnsafeNew\n  {-# INLINE basicInitialize #-}\n  basicInitialize = coerce `asTypeOf` (. unVMRem) $ VGM.basicInitialize\n  {-# INLINE basicUnsafeReplicate #-}\n  basicUnsafeReplicate !n\n    = fmap (coerce `asTypeOf` VMRem) . VGM.basicUnsafeReplicate n\n    . unRem\n  {-# INLINE basicUnsafeRead #-}\n  basicUnsafeRead (VMRem v) !i = VGM.basicUnsafeRead v i >>=\n    (return $!) . Rem\n  {-# INLINE basicUnsafeWrite #-}\n  basicUnsafeWrite (VMRem v) !n = VGM.basicUnsafeWrite v n . unRem\n  {-# INLINE basicClear #-}\n  basicClear = coerce `asTypeOf` (. unVMRem) $ VGM.basicClear\n  {-# INLINE basicSet #-}\n  basicSet (VMRem v) = VGM.basicSet v . unRem\n  {-# INLINE basicUnsafeCopy #-}\n  basicUnsafeCopy = coerce `asTypeOf` (`on` unVMRem) $ VGM.basicUnsafeCopy\n  {-# INLINE basicUnsafeMove #-}\n  basicUnsafeMove = coerce `asTypeOf` (`on` unVMRem) $ VGM.basicUnsafeMove\n  {-# INLINE basicUnsafeGrow #-}\n  basicUnsafeGrow (VMRem v) !n\n    = fmap (coerce `asTypeOf` VMRem) $ VGM.basicUnsafeGrow v n\n\ninstance VG.Vector VU.Vector Rem where\n  {-# INLINE basicUnsafeFreeze #-}\n  basicUnsafeFreeze (VMRem v)\n    = fmap (coerce `asTypeOf` VRem) $ VG.basicUnsafeFreeze v\n  {-# INLINE basicUnsafeThaw #-}\n  basicUnsafeThaw (VRem v)\n    = fmap (coerce `asTypeOf` VMRem) $ VG.basicUnsafeThaw v\n  {-# INLINE basicLength #-}\n  basicLength = coerce `asTypeOf` (. unVRem) $ VG.basicLength\n  {-# INLINE basicUnsafeSlice #-}\n  basicUnsafeSlice\n    = coerce `asTypeOf` (\\f i l (VRem v) -> VRem $ f i l v)\n      $ VG.basicUnsafeSlice\n  {-# INLINE basicUnsafeIndexM #-}\n  basicUnsafeIndexM (VRem v) !i =\n    VG.basicUnsafeIndexM v i >>= (return $!) . Rem\n  {-# INLINE basicUnsafeCopy #-}\n  basicUnsafeCopy\n    = coerce `asTypeOf` (\\f (VMRem mv) (VRem v) -> f mv v)\n      $ VG.basicUnsafeCopy\n  {-# INLINE elemseq #-}\n  elemseq = const seq\n\n{-# SPECIALIZE extEuc :: RemRep -> RemRep -> (RemRep,RemRep,RemRep) #-}\n{-# INLINE extEuc #-}\nextEuc :: (Integral a) => a -> a -> (a,a,a)\nextEuc x0 y0\n  = loop (signum x0) 0 (abs x0) 0 (signum y0) (abs y0)\n  where\n    loop !a !b !x !c !d 0 = (a,b,x)\n    loop !a !b !x !c !d !y\n      = loop c d y (a - q*c) (b - q*d) z\n      where\n        (q,z) = x `quotRem` y\n\n{-# SPECIALIZE invMod :: RemRep -> RemRep -> Maybe RemRep #-}\n{-# INLINE invMod #-}\ninvMod :: (Integral a) => a -> a -> Maybe a\ninvMod x m\n  | g == 1 = Just r'\n  | otherwise = Nothing\n  where\n    (_,r,g) = extEuc m x\n    r' = r `mod` m\n\ninstance Fractional Rem where\n  recip (Rem x) = Rem $ fromJust $ invMod x modulus\n  fromRational p = fromInteger (numerator p) / fromInteger (denominator p)\n\n\n#define IL(f) {-# INLINE f #-}; f\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  showAsBuilder = BSB.string8 . show\n\n#define INS(t,f) instance ShowAsBuilder t where \\\n  { {-# INLINE showAsBuilder #-}; showAsBuilder=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  showAsBuilder = v2BSpcSep\n\n{-# INLINE putBuilder #-}\nputBuilder = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\n{-# INLINE printVecInLines #-}\nprintVecInLines = putBuilder . v2BLines\n{-# INLINE printVecInSpcSepLn #-}\nprintVecInSpcSepLn = putBuilder . v2BSpcSepLn\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\n{-# INLINE v2BSpcSepLn #-}\nv2BSpcSepLn = v2BSpcSepLnWith showAsBuilder\n{-# INLINE v2BSpcSep #-}\nv2BSpcSep = v2BSpcSepWith showAsBuilder\n{-# INLINE v2BConcat #-}\nv2BConcat = v2BConcatWith showAsBuilder\n{-# INLINE v2BLines #-}\nv2BLines = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepLnWith #-}\nv2BSpcSepLnWith = v2BSpcSepPostfWith \"\\n\"\n{-# INLINE v2BSpcSepWith #-}\nv2BSpcSepWith = v2BSpcSepPostfWith \"\"\n{-# INLINE v2BConcatWith #-}\nv2BConcatWith showFct = VG.foldr ((<>) . showFct) mempty\n{-# INLINE v2BLinesWith #-}\nv2BLinesWith showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostf #-}\nv2BSpcSepPostf = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostfWith #-}\nv2BSpcSepPostfWith = vecToBuilder \"\" \" \"\n\n{-# INLINE vecToBuilder #-}\nvecToBuilder :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\n{-# INLINE vecToBuilder_ #-}\nvecToBuilder_ :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct vec\n  = prefix <> VG.foldr\n    (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n    (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\ngetVecGLn :: (VG.Vector v a) =>\n           Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\n{-# INLINE getVecGLn #-}\ngetVecGRest :: (VG.Vector v a) =>\n            Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\n{-# INLINE getVecGRest #-}\ngetVecLn :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\n{-# INLINE getVecLn #-}\ngetVecRest :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\n{-# INLINE getVecRest #-}\ngetVecULn :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\n{-# INLINE getVecULn #-}\ngetVecURest :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n{-# INLINE getVecURest #-}\n\nrInt :: StateT BSL.ByteString Maybe Int\nIL(rInt) = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nIL(rIntS) = StateT $ BS.readInt . BS.dropWhile (<'!')\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define N(f,g,h,a,m)\\\n  IL(f) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e);\\\n  f=A.newArray;\\\n  IL(g) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e);\\\n  g=A.newArray_;\\\n  IL(h) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> [e] -> m (a i e);\\\n  h=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport Control.Arrow\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#)\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  let dups = countDups n\n  print $ fromMon $ monRep 3 ^ n - dups - dups\n  return ()\n\n\ncountDups :: Int -> Montgomery\ncountDups n = VU.sum $ VU.zipWith (*) combinats power2s\n  where\n    oneM = monRep 1\n    !factoN = VU.foldl' (*) oneM $ VU.iterateN n (+oneM) oneM\n    !invFactos = VU.reverse $ VU.scanl' (*) (recip factoN)\n                $ VU.iterateN n (subtract oneM) (monRep $ fromIntegral n)\n    !combinats = VU.zipWith (\\x y -> factoN*x*y) invFactos\n                 (VU.reverse invFactos)\n    !power2s = VU.iterateN (n `shiftR` 1) (\\x -> x+x) oneM\n    \n      \nnewtype instance VU.Vector Montgomery\n  = VMon { unVMon :: VU.Vector Word32 }\nnewtype instance VUM.MVector s Montgomery\n  = VMMon { unVMMon :: VUM.MVector s Word32 }\ninstance VUM.Unbox Montgomery\n\ninstance VGM.MVector VUM.MVector Montgomery where\n  {-# INLINE basicLength #-}\n  basicLength = coerce `asTypeOf` (. unVMMon) $ VGM.basicLength\n  {-# INLINE basicUnsafeSlice #-}\n  basicUnsafeSlice\n    = coerce `asTypeOf` (\\f x y (VMMon v) -> VMMon $ f x y v)\n      $ VGM.basicUnsafeSlice\n  {-# INLINE basicOverlaps #-}\n  basicOverlaps = coerce `asTypeOf` (`on` unVMMon) $ VGM.basicOverlaps\n  {-# INLINE basicUnsafeNew #-}\n  basicUnsafeNew = fmap (coerce `asTypeOf` VMMon) . VGM.basicUnsafeNew\n  {-# INLINE basicInitialize #-}\n  basicInitialize = coerce `asTypeOf` (. unVMMon) $ VGM.basicInitialize\n  {-# INLINE basicUnsafeReplicate #-}\n  basicUnsafeReplicate !n\n    = fmap (coerce `asTypeOf` VMMon) . VGM.basicUnsafeReplicate n\n    . unMon\n  {-# INLINE basicUnsafeRead #-}\n  basicUnsafeRead (VMMon v) !i = VGM.basicUnsafeRead v i >>=\n    (return $!) . Mon\n  {-# INLINE basicUnsafeWrite #-}\n  basicUnsafeWrite (VMMon v) !n = VGM.basicUnsafeWrite v n . unMon\n  {-# INLINE basicClear #-}\n  basicClear = coerce `asTypeOf` (. unVMMon) $ VGM.basicClear\n  {-# INLINE basicSet #-}\n  basicSet (VMMon v) = VGM.basicSet v . unMon\n  {-# INLINE basicUnsafeCopy #-}\n  basicUnsafeCopy = coerce `asTypeOf` (`on` unVMMon) $ VGM.basicUnsafeCopy\n  {-# INLINE basicUnsafeMove #-}\n  basicUnsafeMove = coerce `asTypeOf` (`on` unVMMon) $ VGM.basicUnsafeMove\n  {-# INLINE basicUnsafeGrow #-}\n  basicUnsafeGrow (VMMon v) !n\n    = fmap (coerce `asTypeOf` VMMon) $ VGM.basicUnsafeGrow v n\n\ninstance VG.Vector VU.Vector Montgomery where\n  {-# INLINE basicUnsafeFreeze #-}\n  basicUnsafeFreeze (VMMon v)\n    = fmap (coerce `asTypeOf` VMon) $ VG.basicUnsafeFreeze v\n  {-# INLINE basicUnsafeThaw #-}\n  basicUnsafeThaw (VMon v)\n    = fmap (coerce `asTypeOf` VMMon) $ VG.basicUnsafeThaw v\n  {-# INLINE basicLength #-}\n  basicLength = coerce `asTypeOf` (. unVMon) $ VG.basicLength\n  {-# INLINE basicUnsafeSlice #-}\n  basicUnsafeSlice\n    = coerce `asTypeOf` (\\f i l (VMon v) -> VMon $ f i l v)\n      $ VG.basicUnsafeSlice\n  {-# INLINE basicUnsafeIndexM #-}\n  basicUnsafeIndexM (VMon v) !i =\n    VG.basicUnsafeIndexM v i >>= (return $!) . Mon\n  {-# INLINE basicUnsafeCopy #-}\n  basicUnsafeCopy\n    = coerce `asTypeOf` (\\f (VMMon mv) (VMon v) -> f mv v)\n      $ VG.basicUnsafeCopy\n  {-# INLINE elemseq #-}\n  elemseq = const seq\n\n{-# INLINE modulus #-}\nmodulus :: (Integral i) => i\nmodulus = 998244353\n\n{-# INLINE nprime #-}\nnprime :: Word64\nnprime = 998244351\n\n{-# INLINE rsq #-}\nrsq :: Word64\nrsq = 932051910\n\nnewtype Montgomery = Mon {unMon :: Word32}\n  deriving (Eq, Show)\n\ninstance Num Montgomery where\n  {-# INLINE (+) #-}\n  (+) = monAdd\n  {-# INLINE (*) #-}\n  (*) = monMult\n  {-# INLINE (-) #-}\n  (-) = monSub\n  {-# INLINE negate #-}\n  negate (Mon x) = Mon (modulus - x)\n  {-# INLINE fromInteger #-}\n  fromInteger = monRep . fromInteger . (`mod` modulus)\n  {-# INLINE signum #-}\n  signum x | x == Mon 0 = Mon 0\n           | otherwise  = monRep 1\n  {-# INLINE abs #-}\n  abs = id\n\ninstance Fractional Montgomery where\n  fromRational x = fromInteger (numerator x) / fromInteger (denominator x)\n  recip x | x == 0 = undefined\n          | otherwise = x ^ (modulus -2 :: Int)\n\n{-# INLINE monMult #-}\nmonMult :: Montgomery -> Montgomery -> Montgomery\nmonMult (Mon x) (Mon y) = Mon $ monRed $ fromIntegral x * fromIntegral y\n\n{-# INLINE monAdd #-}\nmonAdd :: Montgomery -> Montgomery -> Montgomery\nmonAdd (Mon x) (Mon y) = Mon $ x+y - if x >= modulus-y then modulus else 0\n    \n{-# INLINE monSub #-}\nmonSub :: Montgomery -> Montgomery -> Montgomery\nmonSub (Mon x) (Mon y) = Mon $ x-y + if x < y then modulus else 0\n\n{-# INLINE monRep #-}\nmonRep :: Word32 -> Montgomery\nmonRep x = Mon $ monRed $ rsq * fromIntegral x\n\n{-# INLINE fromMon #-}\nfromMon :: Montgomery -> Word32\nfromMon (Mon x) = monRed $ fromIntegral x\n\n{-# INLINE monRed #-}\nmonRed :: Word64 -> Word32\nmonRed x = t - if t >= modulus then modulus else 0\n  where t = fromIntegral $ (`shiftR` 32)\n          $ x + x*nprime .&.mask32 *modulus\n\nmask32 :: Word64\nmask32 = bit 32 - 1\n\n\n\n#define IL(f) {-# INLINE f #-}; f\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  showAsBuilder = BSB.string8 . show\n\n#define INS(t,f) instance ShowAsBuilder t where \\\n  { {-# INLINE showAsBuilder #-}; showAsBuilder=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  showAsBuilder = v2BSpcSep\n\n{-# INLINE putBuilder #-}\nputBuilder = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\n{-# INLINE printVecInLines #-}\nprintVecInLines = putBuilder . v2BLines\n{-# INLINE printVecInSpcSepLn #-}\nprintVecInSpcSepLn = putBuilder . v2BSpcSepLn\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\n{-# INLINE v2BSpcSepLn #-}\nv2BSpcSepLn = v2BSpcSepLnWith showAsBuilder\n{-# INLINE v2BSpcSep #-}\nv2BSpcSep = v2BSpcSepWith showAsBuilder\n{-# INLINE v2BConcat #-}\nv2BConcat = v2BConcatWith showAsBuilder\n{-# INLINE v2BLines #-}\nv2BLines = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepLnWith #-}\nv2BSpcSepLnWith = v2BSpcSepPostfWith \"\\n\"\n{-# INLINE v2BSpcSepWith #-}\nv2BSpcSepWith = v2BSpcSepPostfWith \"\"\n{-# INLINE v2BConcatWith #-}\nv2BConcatWith showFct = VG.foldr ((<>) . showFct) mempty\n{-# INLINE v2BLinesWith #-}\nv2BLinesWith showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostf #-}\nv2BSpcSepPostf = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\n{-# INLINE v2BSpcSepPostfWith #-}\nv2BSpcSepPostfWith = vecToBuilder \"\" \" \"\n\n{-# INLINE vecToBuilder #-}\nvecToBuilder :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\n{-# INLINE vecToBuilder_ #-}\nvecToBuilder_ :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct vec\n  = prefix <> VG.foldr\n    (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n    (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\ngetVecGLn :: (VG.Vector v a) =>\n           Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\n{-# INLINE getVecGLn #-}\ngetVecGRest :: (VG.Vector v a) =>\n            Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\n{-# INLINE getVecGRest #-}\ngetVecLn :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\n{-# INLINE getVecLn #-}\ngetVecRest :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\n{-# INLINE getVecRest #-}\ngetVecULn :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\n{-# INLINE getVecULn #-}\ngetVecURest :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n{-# INLINE getVecURest #-}\n\nrInt :: StateT BSL.ByteString Maybe Int\nIL(rInt) = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nIL(rIntS) = StateT $ BS.readInt . BS.dropWhile (<'!')\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define N(f,g,h,a,m)\\\n  IL(f) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e);\\\n  f=A.newArray;\\\n  IL(g) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e);\\\n  g=A.newArray_;\\\n  IL(h) :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> [e] -> m (a i e);\\\n  h=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n\n#undef IL\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[10000005];\nlong long invfact[10000005];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<10000005;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[10000004]=modular_inverse(factorial[10000004]);\n  for(i=10000003;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nint main(void){\n  cfact();\n  long long i,j,n,m,k,a,b,c,h,w,r,l,t;\n  scanf(\"%lld\",&n);\n  r=power(3,n);\n  k=2;\n  for(i=n;i>(n/2);i--){\n    w=calcnCr(n,i);\n    r=(r+mod-((w*k)%mod))%mod;\n    k*=2;\n    k%=mod;\n  }\n  printf(\"%lld\\n\",r);\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSolver solver = new Solver();\n\t\tsolver.solve();\n\t\tsolver.exit();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t}else{\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Solver {\n\t\tFastScanner sc = new FastScanner();\n\t\tpublic Solver() { }\n\n\t\tString ns() { return sc.next(); }\n\t\tString[] ns(int n) {\n\t\t\tString a[] = new String[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(); }\n\t\t\treturn a;\n\t\t}\n\t\tString[][] ns(int n, int m) {\n\t\t\tString a[][] = new String[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(m); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[] nc(int n) {\n\t\t\tString str = ns();\n\t\t\tchar a[] = new char[str.length()];\n\t\t\tfor(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[][] nc(int n, int m) {\n\t\t\tchar a[][] = new char[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nc(m); }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[] nb(int n, char t) {\n\t\t\tboolean a[] = new boolean[n];\n\t\t\tchar c[] = nc(n);\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = c[i] == t; }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[][] nb(int n, int m, char t) {\n\t\t\tboolean a[][] = new boolean[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nb(m, t); }\n\t\t\treturn a;\n\t\t}\n\t\tint ni() { return (int)sc.nextLong(); }\n\t\tint[] ni(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(); }\n\t\t\treturn a;\n\t\t}\n\t\tint[][] ni(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(m); }\n\t\t\treturn a;\n\t\t}\n\t\tlong nl() { return sc.nextLong(); }\n\t\tlong[] nl(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(); }\n\t\t\treturn a;\n\t\t}\n\t\tlong[][] nl(int n, int m) {\n\t\t\tlong a[][] = new long[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(m); }\n\t\t\treturn a;\n\t\t}\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tPrintWriter err = new PrintWriter(System.err);\n\t\tvoid prt() { out.print(\"\"); }\n\t\tvoid prt(int a) { out.print(a); }\n\t\tvoid prt(long a) { out.print(a); }\n\t\tvoid prt(double a) { out.print(a); }\n\t\tvoid prt(String a) { out.print(a); }\n\t\tvoid prt(char a) { out.print(a); }\n\t\tvoid prtln() { out.println(\"\"); }\n\t\tvoid prtln(int a) { out.println(a); }\n\t\tvoid prtln(long a) { out.println(a); }\n\t\tvoid prtln(double a) { out.println(a); }\n\t\tvoid prtln(String a) { out.println(a); }\n\t\tvoid prtln(char a) { out.println(a); }\n\t\tvoid prtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(int[][] a) { for(int[] element : a){ prtln(element); } }\n\t\tvoid prtln(long[][] a) { for(long[] element : a){ prtln(element); } }\n\t\tvoid prtln(double[][] a) { for(double[] element : a){ prtln(element); } }\n\t\tvoid prtln(String[][] a) { for(String[] element : a){ prtln(element); } }\n\t\tvoid prtln(char[][] a) { for(char[] element : a){ prtln(element); } }\n\t\tvoid errprt() { err.print(\"\"); }\n\t\tvoid errprt(int a) { err.print(a); }\n\t\tvoid errprt(long a) { err.print(a); }\n\t\tvoid errprt(double a) { err.print(a); }\n\t\tvoid errprt(String a) { err.print(a); }\n\t\tvoid errprt(char a) { err.print(a); }\n\t\tvoid errprt(boolean a) { errprt(a ? \"#\" : \".\"); }\n\t\tvoid errprtln() { err.println(\"\"); }\n\t\tvoid errprtln(int a) { err.println(a); }\n\t\tvoid errprtln(long a) { err.println(a); }\n\t\tvoid errprtln(double a) { err.println(a); }\n\t\tvoid errprtln(String a) { err.println(a); }\n\t\tvoid errprtln(char a) { err.println(a); }\n\t\tvoid errprtln(boolean a) { errprtln(a ? \"#\" : \".\"); }\n\t\tvoid errprtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(boolean... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(boolean element : a){ sb.append((element ? \"#\" : \".\")+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(int[][] a) { for(int[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(long[][] a) { for(long[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(double[][] a) { for(double[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(String[][] a) { for(String[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(char[][] a) { for(char[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(boolean[][] a) { for(boolean[] element : a){ errprtln(element); } }\n\n\t\tvoid reply(boolean b) { prtln(b ? \"Yes\" : \"No\"); }\n\t\tvoid REPLY(boolean b) { prtln(b ? \"YES\" : \"NO\"); }\n\n\t\tvoid exit() { out.flush(); err.flush(); System.exit(0); }\n\n\t\tint min(int a, int b) { return Math.min(a, b); }\n\t\tlong min(long a, long b) { return Math.min(a, b); }\n\t\tdouble min(double a, double b) { return Math.min(a, b); }\n\t\tint min(int... x) {\n\t\t\tint min = x[0];\n\t\t\tfor(int val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tlong min(long... x) {\n\t\t\tlong min = x[0];\n\t\t\tfor(long val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tdouble min(double... x) {\n\t\t\tdouble min = x[0];\n\t\t\tfor(double val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tint max(int a, int b) { return Math.max(a, b); }\n\t\tlong max(long a, long b) { return Math.max(a, b); }\n\t\tdouble max(double a, double b) { return Math.max(a, b); }\n\t\tint max(int... x) {\n\t\t\tint max = x[0];\n\t\t\tfor(int val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long... x) {\n\t\t\tlong max = x[0];\n\t\t\tfor(long val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double... x) {\n\t\t\tdouble max = x[0];\n\t\t\tfor(double val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong sum(int... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(int element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(long... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(long element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble sum(double... a) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(double element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\n\t\tlong abs(double x) { return (long)Math.abs(x); }\n\t\tlong round(double x) { return Math.round(x); }\n\t\tlong floor(double x) { return (long)Math.floor(x); }\n\t\tlong ceil(double x) { return (long)Math.ceil(x); }\n\t\tdouble sqrt(double x) { return Math.sqrt(x); }\n\t\tdouble pow(double x, double y) { return Math.pow(x, y); }\n\t\tlong pow(long x, long y) { return (long)Math.pow(x, y); }\n\t\tint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong lcm(long a, long b) { return a * b / gcd(a, b); }\n\n\t\tlong[] div(long a) {\n\t\t\tList<Long> divList = new ArrayList<Long>();\n\t\t\tfor(long i = 1; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tdivList.add(i);\n\t\t\t\t\tif(i * i != a) { divList.add(a / i); };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong div[] = new long[divList.size()];\n\t\t\tfor(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }\n\t\t\treturn div;\n\t\t}\n\n\t\tlong[][] factor(long a) {\n\t\t\tList<Long> factorList = new ArrayList<Long>();\n\t\t\tList<Long> degreeList = new ArrayList<Long>();\n\t\t\tfor(long i = 2; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tlong count = 0;\n\t\t\t\t\twhile(a % i == 0) {\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tfactorList.add(i);\n\t\t\t\t\tdegreeList.add(count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a > 1) {\n\t\t\t\tfactorList.add(a);\n\t\t\t\tdegreeList.add(1L);\n\t\t\t}\n\t\t\tlong factor[][] = new long[factorList.size()][2];\n\t\t\tfor(int i = 0; i < factorList.size(); i ++) {\n\t\t\t\tfactor[i][0] = factorList.get(i);\n\t\t\t\tfactor[i][1] = degreeList.get(i);\n\t\t\t}\n\t\t\treturn factor;\n\t\t}\n\n\t\tlong[][] countElements(long[] a, boolean sort) {\n\t\t\tint len = a.length;\n\t\t\tlong array[] = new long[len];\n\t\t\tfor(int i = 0; i < len; i ++) {\n\t\t\t\tarray[i] = a[i];\n\t\t\t}\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add(array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\t\tlong[][] countElements(String str, boolean sort) {\n\t\t\tint len = str.length();\n\t\t\tchar array[] = str.toCharArray();\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add((long)array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\n\t\tint numDigits(long a) { return Long.toString(a).length(); }\n\t\tlong bitFlag(int a) { return 1L << (long)a; }\n\t\tboolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }\n\n\t\tlong countString(String str, String a) { return (str.length() - str.replace(a, \"\").length()) / a.length(); }\n\t\tlong countStringAll(String str, String a) { return str.length() - str.replaceAll(a, \"\").length(); }\n\n\t\tvoid reverse(String array[]) {\n\t\t\tString reversed[] = new String[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(int array[]) {\n\t\t\tint reversed[] = new int[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(long array[]) {\n\t\t\tlong reversed[] = new long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(double array[]) {\n\t\t\tdouble reversed[] = new double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(boolean array[]) {\n\t\t\tboolean reversed[] = new boolean[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid fill(int array[], int x) { Arrays.fill(array, x); }\n\t\tvoid fill(long array[], long x) { Arrays.fill(array, x); }\n\t\tvoid fill(double array[], double x) { Arrays.fill(array, x); }\n\t\tvoid fill(boolean array[], boolean x) { Arrays.fill(array, x); }\n\t\tvoid fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }\n\t\tvoid fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }\n\t\tvoid fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }\n\t\tvoid fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }\n\n\t\tlong INF = (long)1e+15;\n\t\tboolean isINF(long a) { return abs(a) > INF / 1000; }\n\t\tboolean isPlusINF(long a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(long a) { return isPlusINF(- a); }\n\n\n\t\t// mods\n\t\tlong MOD = 998244353;\n\t\tpublic long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }\n\n\t\tlong pow_m(long x, long y) {\n\t\t\tif (y == 0) { return 1;\n\t\t\t}else {\n\t\t\t\tlong tmp = pow_m(x, y / 2);\n\t\t\t\treturn mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));\n\t\t\t}\n\t\t}\n\n\t\tlong inv(long x) { return pow_m(x, MOD - 2); }\n\n\t\tint MAX_FACT = 10_000_100;\n\t\tlong fact[];\n\t\tlong invFact[];\n\t\tvoid prepareFact() {\n\t\t\tfact = new long[MAX_FACT];\n\t\t\tArrays.fill(fact, 0);\n\t\t\tinvFact = new long[MAX_FACT];\n\t\t\tArrays.fill(invFact, 0);\n\t\t\tfact[0] = 1;\n\t\t\tint maxIndex = min(MAX_FACT, (int)MOD);\n\t\t\tfor(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }\n\t\t\tinvFact[maxIndex - 1] = inv(fact[maxIndex - 1]);\n\t\t\tfor(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }\n\t\t}\n\n\t\tlong P(int n, int r) {\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\treturn mod(fact[n] * invFact[n - r]);\n\t\t}\n\t\tlong C(int n, int r) {\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\treturn mod(P(n, r) * invFact[r]);\n\t\t}\n\t\tlong H(int n, int r) { return C((n - 1) + r, r); }\n\n\n\t\t// grid\n\t\tclass Grid implements Comparable<Grid> {\n\t\t\tint h;\n\t\t\tint w;\n\t\t\tlong val;\n\n\t\t\tGrid() {  }\n\t\t\tGrid(int h, int w) {\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t}\n\t\t\tGrid(int h, int w, long val) {\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.val = val;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Grid g) {\n\t\t\t\treturn Long.compare(this.val, g.val);\n\t\t\t}\n\t\t}\n\n\n\t\t// graph\n\t\tclass Graph {\n\t\t\tint numNode;\n\t\t\tint numEdge;\n\t\t\tboolean directed;\n\t\t\tEdge edges[];\n\t\t\tNode nodes[];\n\t\t\tNode reversedNodes[];\n\n\t\t\tGraph(int numNode, int numEdge, Edge edges[], boolean directed) {\n\t\t\t\tthis.numNode = numNode;\n\t\t\t\tthis.numEdge = numEdge;\n\t\t\t\tthis.directed = directed;\n\t\t\t\tthis.edges = edges;\n\t\t\t\tnodes = new Node[numNode];\n\t\t\t\treversedNodes = new Node[numNode];\n\t\t\t\tfor(int i = 0; i < numNode; i ++) {\n\t\t\t\t\tnodes[i] = new Node(i);\n\t\t\t\t\treversedNodes[i] = new Node(i);\n\t\t\t\t}\n\n\t\t\t\tfor(Edge edge : edges) {\n\t\t\t\t\tnodes[edge.source].add(edge.target, edge.cost);\n\t\t\t\t\tif(directed) {\n\t\t\t\t\t\treversedNodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid clearNodes() {\n\t\t\t\tfor(Node n : nodes) { n.clear(); }\n\t\t\t\tfor(Node n : reversedNodes) { n.clear(); }\n\t\t\t}\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tArrayList<Edge> edges = new ArrayList<Edge>();\n\n\t\t\tNode(int id) {\n\t\t\t\tthis.id = id;\n\t\t\t}\n\t\t\tvoid add(int target, long cost) {\n\t\t\t\tedges.add(new Edge(id, target, cost));\n\t\t\t}\n\t\t\tvoid clear() {\n\t\t\t\tedges.clear();\n\t\t\t}\n\t\t}\n\n\t\tclass Edge implements Comparable<Edge> {\n\t\t\tint source;\n\t\t\tint target;\n\t\t\tlong cost;\n\t\t\tEdge(int source, int target, long cost) {\n\t\t\t\tthis.source = source;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Edge e) {\n\t\t\t\treturn Long.compare(this.cost, e.cost);\n\t\t\t}\n\t\t}\n\npublic void solve() {\n\tprepareFact();\n\tint num = ni();\n\tlong ans = pow_m(3, num);\n\tfor(int i = num; i > num / 2; i --) {\n\t\tans = mod(ans - mod(C(num, i) * pow_m(2, num - i)) * 2);\n\t}\n\tprtln(ans);\n}\n\n\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n) {\n    ModCalculator mc = new ModCalculator(998244353L);\n    long[] pow2cache = new long[n + 1];\n    pow2cache[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      pow2cache[i] = mc.mul(pow2cache[i - 1], 2);\n    }\n    long answer = mc.pow(3, n);\n    for (int k = n / 2 + 1; k <= n; k++) {\n      long v1 = mc.getC(n, k);\n      long v2 = pow2cache[n - k + 1];\n      long v3 = mc.mul(v1, v2);\n      answer = mc.sub(answer, v3);\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    out.println(solve(n));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModInverseCache modInverseCache;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modInverseCache = new ModInverseCache();\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    long nogmalized = v % mod;\n    if (nogmalized < 0) {\n      nogmalized += mod;\n    }\n    return nogmalized;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n\n  // Verify ttpc2019 J\n  // https://atcoder.jp/contests/ttpc2019/tasks/ttpc2019_j\n  class PrimitiveLongList {\n    long[] values;\n    int size;\n\n    public PrimitiveLongList() {\n      values = new long[10];\n    }\n\n    private void resize() {\n      long[] newValues = new long[values.length * 2];\n      System.arraycopy(values, 0, newValues, 0, values.length);\n      values = newValues;\n    }\n\n    public void add(long value) {\n      if (size >= values.length) {\n        resize();\n      }\n      values[size] = value;\n      size++;\n    }\n\n    private void validateIndex(int index) {\n      if (index < 0 || size <= index) {\n        throw new IndexOutOfBoundsException(String.format(\"size: %d, index: %d\", size, index));\n      }\n    }\n\n    public long get(int index) {\n      validateIndex(index);\n      return values[index];\n    }\n\n    public void set(int index, long value) {\n      validateIndex(index);\n      values[index] = value;\n    }\n\n    public int size() {\n      return size;\n    }\n  }\n\n  class ModInverseCache {\n    private final PrimitiveLongList inverseCache;\n\n    public ModInverseCache() {\n      inverseCache = new PrimitiveLongList();\n      inverseCache.add(0L);\n      inverseCache.add(1L);\n    }\n\n    private void resize(int n) {\n      for (int i = inverseCache.size(); i <= n; i++) {\n        long k = mod / i;\n        int r = (int)(mod % i);\n        long inverse = mul(-k, inverseCache.get(r));\n        inverseCache.add(inverse);\n      }\n    }\n\n    long get(int n) {\n      resize(n);\n      return inverseCache.get(n);\n    }\n  }\n  \n  class ModCombinationCache {\n    private final PrimitiveLongList factorialCache;\n    private final PrimitiveLongList factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new PrimitiveLongList();\n      factorialCache.add(1L);\n      factorialInverseCache = new PrimitiveLongList();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        factorialCache.add(mul(factorialCache.get(i), i + 1));\n        factorialInverseCache.add(mul(factorialInverseCache.get(i), modInverseCache.get(i + 1)));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nimport static java.lang.System.in;\n\npublic final class Main {\n\tstatic Scanner sc = new Scanner(in);\n\tstatic final long MOD = 998244353;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tlong[] comb = new long[N / 2 + 1];\n\t\tlong[] cs = new long[comb.length];\n\t\tlong[] css = new long[comb.length];\n\t\tcomb[0] = 1;\n\t\tcss[0] = cs[0] = comb[0];\n\t\tlong pow2 = 1;\n\t\tfor (int i = 1; i < comb.length; i++) {\n\t\t\tpow2 *= 2;\n\t\t\tpow2 %= MOD;\n\t\t\tcomb[i] = comb[i - 1] * (N / 2 + 1 - i) % MOD;\n\t\t\tcomb[i] *= inv(i);\n\t\t\tcomb[i] %= MOD;\n\t\t\tcs[i] = comb[i] * pow2;\n\t\t\tcs[i] %= MOD;\n\t\t\tcss[i] = (css[i - 1] + cs[i]) % MOD;\n\t\t}\n\t\tlong invalid = 0;\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tinvalid += cs[i] * css[N / 2 - 1 - i];\n\t\t\tinvalid %= MOD;\n\t\t}\n\t\tinvalid *= 2;\n\t\tinvalid %= MOD;\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans *= 3;\n\t\t\tans %= MOD;\n\t\t}\n\t\tans += MOD - invalid;\n\t\tSystem.out.println(ans % MOD);\n\t}\n\n\tstatic long inv(long v) {\n\t\treturn pow(v, MOD - 2);\n\t}\n\n\tstatic long pow(long b, long p) {\n\t\tif (p == 0) return 1;\n\t\tif (p == 1) return b;\n\t\tlong ret = pow(b, p / 2);\n\t\tret *= ret;\n\t\tret %= MOD;\n\t\tif (p % 2 == 1) {\n\t\t\tret *= b;\n\t\t\tret %= MOD;\n\t\t}\n\t\treturn ret;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSolver solver = new Solver();\n\t\tsolver.solve();\n\t\tsolver.exit();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t}else{\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Solver {\n\t\tFastScanner sc = new FastScanner();\n\t\tpublic Solver() { }\n\n\t\tString ns() { return sc.next(); }\n\t\tString[] ns(int n) {\n\t\t\tString a[] = new String[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(); }\n\t\t\treturn a;\n\t\t}\n\t\tString[][] ns(int n, int m) {\n\t\t\tString a[][] = new String[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(m); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[] nc(int n) {\n\t\t\tString str = ns();\n\t\t\tchar a[] = new char[str.length()];\n\t\t\tfor(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[][] nc(int n, int m) {\n\t\t\tchar a[][] = new char[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nc(m); }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[] nb(int n, char t) {\n\t\t\tboolean a[] = new boolean[n];\n\t\t\tchar c[] = nc(n);\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = c[i] == t; }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[][] nb(int n, int m, char t) {\n\t\t\tboolean a[][] = new boolean[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nb(m, t); }\n\t\t\treturn a;\n\t\t}\n\t\tint ni() { return (int)sc.nextLong(); }\n\t\tint[] ni(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(); }\n\t\t\treturn a;\n\t\t}\n\t\tint[][] ni(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(m); }\n\t\t\treturn a;\n\t\t}\n\t\tlong nl() { return sc.nextLong(); }\n\t\tlong[] nl(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(); }\n\t\t\treturn a;\n\t\t}\n\t\tlong[][] nl(int n, int m) {\n\t\t\tlong a[][] = new long[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(m); }\n\t\t\treturn a;\n\t\t}\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tPrintWriter err = new PrintWriter(System.err);\n\t\tvoid prt() { out.print(\"\"); }\n\t\tvoid prt(int a) { out.print(a); }\n\t\tvoid prt(long a) { out.print(a); }\n\t\tvoid prt(double a) { out.print(a); }\n\t\tvoid prt(String a) { out.print(a); }\n\t\tvoid prt(char a) { out.print(a); }\n\t\tvoid prtln() { out.println(\"\"); }\n\t\tvoid prtln(int a) { out.println(a); }\n\t\tvoid prtln(long a) { out.println(a); }\n\t\tvoid prtln(double a) { out.println(a); }\n\t\tvoid prtln(String a) { out.println(a); }\n\t\tvoid prtln(char a) { out.println(a); }\n\t\tvoid prtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(int[][] a) { for(int[] element : a){ prtln(element); } }\n\t\tvoid prtln(long[][] a) { for(long[] element : a){ prtln(element); } }\n\t\tvoid prtln(double[][] a) { for(double[] element : a){ prtln(element); } }\n\t\tvoid prtln(String[][] a) { for(String[] element : a){ prtln(element); } }\n\t\tvoid prtln(char[][] a) { for(char[] element : a){ prtln(element); } }\n\t\tvoid errprt() { err.print(\"\"); }\n\t\tvoid errprt(int a) { err.print(a); }\n\t\tvoid errprt(long a) { err.print(a); }\n\t\tvoid errprt(double a) { err.print(a); }\n\t\tvoid errprt(String a) { err.print(a); }\n\t\tvoid errprt(char a) { err.print(a); }\n\t\tvoid errprt(boolean a) { errprt(a ? \"#\" : \".\"); }\n\t\tvoid errprtln() { err.println(\"\"); }\n\t\tvoid errprtln(int a) { err.println(a); }\n\t\tvoid errprtln(long a) { err.println(a); }\n\t\tvoid errprtln(double a) { err.println(a); }\n\t\tvoid errprtln(String a) { err.println(a); }\n\t\tvoid errprtln(char a) { err.println(a); }\n\t\tvoid errprtln(boolean a) { errprtln(a ? \"#\" : \".\"); }\n\t\tvoid errprtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(boolean... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(boolean element : a){ sb.append((element ? \"#\" : \".\")+\" \"); }\n\t\t\terrprtln(sb.toString().trim());\n\t\t}\n\t\tvoid errprtln(int[][] a) { for(int[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(long[][] a) { for(long[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(double[][] a) { for(double[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(String[][] a) { for(String[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(char[][] a) { for(char[] element : a){ errprtln(element); } }\n\t\tvoid errprtln(boolean[][] a) { for(boolean[] element : a){ errprtln(element); } }\n\n\t\tvoid reply(boolean b) { prtln(b ? \"Yes\" : \"No\"); }\n\t\tvoid REPLY(boolean b) { prtln(b ? \"YES\" : \"NO\"); }\n\n\t\tvoid exit() { out.flush(); err.flush(); System.exit(0); }\n\n\t\tint min(int a, int b) { return Math.min(a, b); }\n\t\tlong min(long a, long b) { return Math.min(a, b); }\n\t\tdouble min(double a, double b) { return Math.min(a, b); }\n\t\tint min(int... x) {\n\t\t\tint min = x[0];\n\t\t\tfor(int val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tlong min(long... x) {\n\t\t\tlong min = x[0];\n\t\t\tfor(long val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tdouble min(double... x) {\n\t\t\tdouble min = x[0];\n\t\t\tfor(double val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tint max(int a, int b) { return Math.max(a, b); }\n\t\tlong max(long a, long b) { return Math.max(a, b); }\n\t\tdouble max(double a, double b) { return Math.max(a, b); }\n\t\tint max(int... x) {\n\t\t\tint max = x[0];\n\t\t\tfor(int val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long... x) {\n\t\t\tlong max = x[0];\n\t\t\tfor(long val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double... x) {\n\t\t\tdouble max = x[0];\n\t\t\tfor(double val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong sum(int... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(int element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(long... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(long element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble sum(double... a) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(double element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\n\t\tlong abs(double x) { return (long)Math.abs(x); }\n\t\tlong round(double x) { return Math.round(x); }\n\t\tlong floor(double x) { return (long)Math.floor(x); }\n\t\tlong ceil(double x) { return (long)Math.ceil(x); }\n\t\tdouble sqrt(double x) { return Math.sqrt(x); }\n\t\tdouble pow(double x, double y) { return Math.pow(x, y); }\n\t\tlong pow(long x, long y) { return (long)Math.pow(x, y); }\n\t\tint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n\t\tlong lcm(long a, long b) { return a * b / gcd(a, b); }\n\n\t\tlong[] div(long a) {\n\t\t\tList<Long> divList = new ArrayList<Long>();\n\t\t\tfor(long i = 1; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tdivList.add(i);\n\t\t\t\t\tif(i * i != a) { divList.add(a / i); };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong div[] = new long[divList.size()];\n\t\t\tfor(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }\n\t\t\treturn div;\n\t\t}\n\n\t\tlong[][] factor(long a) {\n\t\t\tList<Long> factorList = new ArrayList<Long>();\n\t\t\tList<Long> degreeList = new ArrayList<Long>();\n\t\t\tfor(long i = 2; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tlong count = 0;\n\t\t\t\t\twhile(a % i == 0) {\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tfactorList.add(i);\n\t\t\t\t\tdegreeList.add(count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a > 1) {\n\t\t\t\tfactorList.add(a);\n\t\t\t\tdegreeList.add(1L);\n\t\t\t}\n\t\t\tlong factor[][] = new long[factorList.size()][2];\n\t\t\tfor(int i = 0; i < factorList.size(); i ++) {\n\t\t\t\tfactor[i][0] = factorList.get(i);\n\t\t\t\tfactor[i][1] = degreeList.get(i);\n\t\t\t}\n\t\t\treturn factor;\n\t\t}\n\n\t\tlong[][] countElements(long[] a, boolean sort) {\n\t\t\tint len = a.length;\n\t\t\tlong array[] = new long[len];\n\t\t\tfor(int i = 0; i < len; i ++) {\n\t\t\t\tarray[i] = a[i];\n\t\t\t}\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add(array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\t\tlong[][] countElements(String str, boolean sort) {\n\t\t\tint len = str.length();\n\t\t\tchar array[] = str.toCharArray();\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add((long)array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\n\t\tint numDigits(long a) { return Long.toString(a).length(); }\n\t\tlong bitFlag(int a) { return 1L << (long)a; }\n\t\tboolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }\n\n\t\tlong countString(String str, String a) { return (str.length() - str.replace(a, \"\").length()) / a.length(); }\n\t\tlong countStringAll(String str, String a) { return str.length() - str.replaceAll(a, \"\").length(); }\n\n\t\tvoid reverse(String array[]) {\n\t\t\tString reversed[] = new String[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(int array[]) {\n\t\t\tint reversed[] = new int[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(long array[]) {\n\t\t\tlong reversed[] = new long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(double array[]) {\n\t\t\tdouble reversed[] = new double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid reverse(boolean array[]) {\n\t\t\tboolean reversed[] = new boolean[array.length];\n\t\t\tfor(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }\n\t\t\tfor(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }\n\t\t}\n\t\tvoid fill(int array[], int x) { Arrays.fill(array, x); }\n\t\tvoid fill(long array[], long x) { Arrays.fill(array, x); }\n\t\tvoid fill(double array[], double x) { Arrays.fill(array, x); }\n\t\tvoid fill(boolean array[], boolean x) { Arrays.fill(array, x); }\n\t\tvoid fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }\n\t\tvoid fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }\n\t\tvoid fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }\n\t\tvoid fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }\n\n\t\tlong INF = (long)1e+15;\n\t\tboolean isINF(long a) { return abs(a) > INF / 1000; }\n\t\tboolean isPlusINF(long a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(long a) { return isPlusINF(- a); }\n\n\n\t\t// mods\n\t\tlong MOD = 998244353;\n\t\tpublic long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }\n\n\t\tlong pow_m(long x, long y) {\n\t\t\tif (y == 0) { return 1;\n\t\t\t}else {\n\t\t\t\tlong tmp = pow_m(x, y / 2);\n\t\t\t\treturn mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));\n\t\t\t}\n\t\t}\n\n\t\tlong inv(long x) { return pow_m(x, MOD - 2); }\n\n\t\tint MAX_FACT = 10_000_100;\n\t\tlong fact[];\n\t\tlong invFact[];\n\t\tvoid prepareFact() {\n\t\t\tfact = new long[MAX_FACT];\n\t\t\tArrays.fill(fact, 0);\n\t\t\tinvFact = new long[MAX_FACT];\n\t\t\tArrays.fill(invFact, 0);\n\t\t\tfact[0] = 1;\n\t\t\tint maxIndex = min(MAX_FACT, (int)MOD);\n\t\t\tfor(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }\n\t\t\tinvFact[maxIndex - 1] = inv(fact[maxIndex - 1]);\n\t\t\tfor(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }\n\t\t}\n\n\t\tlong P(int n, int r) {\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\treturn mod(fact[n] * invFact[n - r]);\n\t\t}\n\t\tlong C(int n, int r) {\n\t\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\t\treturn mod(P(n, r) * invFact[r]);\n\t\t}\n\t\tlong H(int n, int r) { return C((n - 1) + r, r); }\n\n\n\t\t// grid\n\t\tclass Grid implements Comparable<Grid> {\n\t\t\tint h;\n\t\t\tint w;\n\t\t\tlong val;\n\n\t\t\tGrid() {  }\n\t\t\tGrid(int h, int w) {\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t}\n\t\t\tGrid(int h, int w, long val) {\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.val = val;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Grid g) {\n\t\t\t\treturn Long.compare(this.val, g.val);\n\t\t\t}\n\t\t}\n\n\n\t\t// graph\n\t\tclass Graph {\n\t\t\tint numNode;\n\t\t\tint numEdge;\n\t\t\tboolean directed;\n\t\t\tEdge edges[];\n\t\t\tNode nodes[];\n\t\t\tNode reversedNodes[];\n\n\t\t\tGraph(int numNode, int numEdge, Edge edges[], boolean directed) {\n\t\t\t\tthis.numNode = numNode;\n\t\t\t\tthis.numEdge = numEdge;\n\t\t\t\tthis.directed = directed;\n\t\t\t\tthis.edges = edges;\n\t\t\t\tnodes = new Node[numNode];\n\t\t\t\treversedNodes = new Node[numNode];\n\t\t\t\tfor(int i = 0; i < numNode; i ++) {\n\t\t\t\t\tnodes[i] = new Node(i);\n\t\t\t\t\treversedNodes[i] = new Node(i);\n\t\t\t\t}\n\n\t\t\t\tfor(Edge edge : edges) {\n\t\t\t\t\tnodes[edge.source].add(edge.target, edge.cost);\n\t\t\t\t\tif(directed) {\n\t\t\t\t\t\treversedNodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid clearNodes() {\n\t\t\t\tfor(Node n : nodes) { n.clear(); }\n\t\t\t\tfor(Node n : reversedNodes) { n.clear(); }\n\t\t\t}\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tArrayList<Edge> edges = new ArrayList<Edge>();\n\n\t\t\tNode(int id) {\n\t\t\t\tthis.id = id;\n\t\t\t}\n\t\t\tvoid add(int target, long cost) {\n\t\t\t\tedges.add(new Edge(id, target, cost));\n\t\t\t}\n\t\t\tvoid clear() {\n\t\t\t\tedges.clear();\n\t\t\t}\n\t\t}\n\n\t\tclass Edge implements Comparable<Edge> {\n\t\t\tint source;\n\t\t\tint target;\n\t\t\tlong cost;\n\t\t\tEdge(int source, int target, long cost) {\n\t\t\t\tthis.source = source;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Edge e) {\n\t\t\t\treturn Long.compare(this.cost, e.cost);\n\t\t\t}\n\t\t}\n\npublic void solve() {\n\tprepareFact();\n\tint num = ni();\n\tlong ans = pow_m(3, num);\n\tlong pow_2[] = new long[num + 10];\n\tpow_2[0] = 1;\n\tfor(int i = 1; i <= num; i ++) {\n\t\tpow_2[i] = mod(pow_2[i - 1] * 2);\n\t}\n\tfor(int i = num; i > num / 2; i --) {\n\t\tans = mod(ans - mod(C(num, i) * pow_2[num - i]) * 2);\n\t}\n\tprtln(ans);\n}\n\n\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int mod = 998244353;\n\n    int[][] fif = enumFIF(n, mod);\n    long ret = pow(3, n, mod);\n\n    for (int i = n / 2 + 1; i <= n; i++) {\n      long x = C(n, i, mod, fif) * pow(2, n - i, mod) % mod;\n      x = x * 2 % mod;\n      ret = (ret - x + mod) % mod;\n    }\n\n    System.out.println(ret);\n\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n) {\n    ModCalculator mc = new ModCalculator(998244353L);\n    long answer = mc.pow(3, n);\n    for (int k = n / 2 + 1; k <= n; k++) {\n      long v1 = mc.getC(n, k);\n      long v2 = mc.pow(2, n - k + 1);\n      long v3 = mc.mul(v1, v2);\n      answer = mc.sub(answer, v3);\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    out.println(solve(n));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    return v % mod;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n\n  // Verify ttpc2019 J\n  // https://atcoder.jp/contests/ttpc2019/tasks/ttpc2019_j\n  class PrimitiveLongList {\n    long[] values;\n    int size;\n\n    public PrimitiveLongList() {\n      values = new long[10];\n    }\n\n    private void resize() {\n      long[] newValues = new long[values.length * 2];\n      System.arraycopy(values, 0, newValues, 0, values.length);\n      values = newValues;\n    }\n\n    public void add(long value) {\n      if (size >= values.length) {\n        resize();\n      }\n      values[size] = value;\n      size++;\n    }\n\n    private void validateIndex(int index) {\n      if (index < 0 || size <= index) {\n        throw new IndexOutOfBoundsException(String.format(\"size: %d, index: %d\", size, index));\n      }\n    }\n\n    public long get(int index) {\n      validateIndex(index);\n      return values[index];\n    }\n\n    public void set(int index, long value) {\n      validateIndex(index);\n      values[index] = value;\n    }\n\n    public int size() {\n      return size;\n    }\n  }\n  \n  class ModCombinationCache {\n    private final PrimitiveLongList factorialCache;\n    private final PrimitiveLongList factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new PrimitiveLongList();\n      factorialCache.add(1L);\n      factorialInverseCache = new PrimitiveLongList();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskC solver = new TaskC();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskC {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(998244353);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n            NumberTheory.Composite comp = new NumberTheory.Composite(n, mod);\n\n            int all = pow.pow(3, n);\n            int invalidCnt = 0;\n            int p2 = pow.pow(2, n / 2);\n            int inv2 = pow.inverse(2);\n            for (int i = n / 2 + 1; i <= n; i++) {\n                p2 = mod.mul(p2, inv2);\n                invalidCnt = mod.plus(invalidCnt, mod.mul(comp.composite(n, i), p2));\n            }\n\n            invalidCnt = mod.mul(invalidCnt, 2);\n            out.println(mod.subtract(all, invalidCnt));\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n        }\n\n        public static class Composite {\n            final NumberTheory.Factorial factorial;\n            final NumberTheory.Modular modular;\n\n            public Composite(NumberTheory.Factorial factorial) {\n                this.factorial = factorial;\n                this.modular = factorial.modular;\n            }\n\n            public Composite(int limit, NumberTheory.Modular modular) {\n                this(new NumberTheory.Factorial(limit, modular));\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 998244353;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int inv(int a) {\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint facts[] = new int[n + 1];\n\t\tfacts[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfacts[i] = mul(facts[i - 1], i);\n\t\t}\n\t\tint factsInv[] = new int[n + 1];\n\t\tfactsInv[n] = inv(facts[n]);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfactsInv[i] = mul(factsInv[i + 1], i + 1);\n\t\t}\n\t\tint ans = pow(3, n);\n\t\tint p2 = 2;\n\t\tfor (int i = n; i > n / 2; i--) {\n\t\t\tans = sub(ans, mul(mul(facts[n], mul(factsInv[i], factsInv[n - i])), p2));\n\t\t\tp2 = add(p2, p2);\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Objects;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        CNeitherABNorBA solver = new CNeitherABNorBA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CNeitherABNorBA {\n        private static final int MOD = 998244353;\n        private static final ModMath mod = new ModMath(MOD);\n        private static final Factorial fact = mod.getFactorial(10_000_001);\n        private static final Exponentiation exp = mod.getExponentiation(2, 10_000_001);\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int n = in.ints();\n            long ans = 0;\n            for (int a = n / 2 + 1; a <= n; a++) {\n                ans += fact.ncr(n, a) * exp.pow(n - a) % MOD;\n                ans %= MOD;\n            }\n            out.ans((mod.pow(3, n) + MOD - ans + MOD - ans) % MOD).ln();\n        }\n\n    }\n\n    static class Vec3i implements Comparable<Vec3i> {\n        public int x;\n        public int y;\n        public int z;\n\n        public Vec3i(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3i o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Integer.compare(z, o.z);\n                }\n                return Integer.compare(y, o.z);\n            }\n            return Integer.compare(x, o.x);\n        }\n\n    }\n\n    static class ModMath {\n        private static final int DEFAULT_MOD = 1_000_000_007;\n        private final long mod;\n\n        public ModMath(long mod, boolean unsafe) {\n        /*if (!unsafe && !IntMath.isPrime(mod)) {\n            throw new RuntimeException(\"This class is designed for primes!\");\n        }*/\n            this.mod = mod;\n        }\n\n        public ModMath(long mod) {\n            this(mod, false);\n        }\n\n        public ModMath() {\n            this(DEFAULT_MOD, true);\n        }\n\n        public long mod(long x) {\n            x %= mod;\n            return x < 0 ? x + mod : x;\n        }\n\n        public long inv(long x) {\n            //return pow(x, mod - 2);\n            return mod(LongEuclidSolver.solve(x, mod).x);\n        }\n\n        public long pow(long x, long y) {\n            y %= (mod - 1);\n            if (y < 0) {\n                return pow(inv(x), -y);\n            } else if (y == 0) {\n                return 1;\n            } else if (y % 2 == 0) {\n                long z = pow(x, y / 2);\n                return (z * z) % mod;\n            } else {\n                return (x % mod) * pow(x, y - 1) % mod;\n            }\n        }\n\n        public Factorial getFactorial(int n) {\n            return new Factorial(this, n);\n        }\n\n        public Exponentiation getExponentiation(long base, int max) {\n            return new Exponentiation(this, base, max);\n        }\n\n    }\n\n    static class Factorial {\n        private final ModMath mod;\n        private final long[] natural;\n        private final long[] reverse;\n\n        public Factorial(ModMath mod, int max) {\n            this.mod = mod;\n            this.natural = new long[max];\n            this.reverse = new long[max];\n            natural[0] = 1;\n            for (int i = 1; i < max; i++) {\n                natural[i] = mod.mod(natural[i - 1] * i);\n            }\n            reverse[max - 1] = mod.inv(natural[max - 1]);\n            for (int i = max - 1; i > 0; i--) {\n                reverse[i - 1] = mod.mod(reverse[i] * i);\n            }\n        }\n\n        public long fact(long x) {\n            return natural[(int) x];\n        }\n\n        public long factinv(long x) {\n            return reverse[(int) x];\n        }\n\n        public long npr(long n, long r) {\n            return n < r ? 0 : mod.mod(fact(n) * factinv(n - r));\n        }\n\n        public long ncr(long n, long r) {\n            return mod.mod(npr(n, r) * factinv(r));\n        }\n\n        public String toString() {\n            return \"Factorial{\" +\n                    \"natural=\" + Arrays.toString(natural) +\n                    \", reverse=\" + Arrays.toString(reverse) +\n                    '}';\n        }\n\n    }\n\n    static interface Verified {\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n\n    static class Vec3l implements Comparable<Vec3l> {\n        public long x;\n        public long y;\n        public long z;\n\n        public Vec3l(long x, long y, long z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3l o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Long.compare(z, o.z);\n                }\n                return Long.compare(y, o.z);\n            }\n            return Long.compare(x, o.x);\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LongEuclidSolver {\n        private LongEuclidSolver() {\n        }\n\n        public static Vec3l solve(long a, long b) {\n            LongEuclidSolver.ReferenceLong p = new LongEuclidSolver.ReferenceLong(), q = new LongEuclidSolver.ReferenceLong();\n            long d = solve(a, b, p, q);\n            return new Vec3l(p.val, q.val, d);\n        }\n\n        private static long solve(long a, long b, LongEuclidSolver.ReferenceLong p, LongEuclidSolver.ReferenceLong q) {\n            if (b == 0) {\n                p.val = 1;\n                q.val = 0;\n                return a;\n            } else {\n                long d = solve(b, a % b, q, p);\n                q.val -= (a / b) * p.val;\n                return d;\n            }\n        }\n\n        private static class ReferenceLong {\n            private long val;\n\n        }\n\n    }\n\n    static class Exponentiation {\n        private final ModMath mod;\n        private final long base;\n        private final int max;\n        private final long[] natural;\n        private final long[] reverse;\n\n        public Exponentiation(ModMath mod, long base, int max) {\n            this.mod = mod;\n            this.base = base;\n            this.max = max;\n            this.natural = new long[max];\n            this.reverse = new long[max];\n            natural[0] = 1;\n            for (int i = 1; i < max; i++) {\n                natural[i] = mod.mod(natural[i - 1] * base);\n            }\n            reverse[max - 1] = mod.inv(natural[max - 1]);\n            for (int i = max - 1; i > 0; i--) {\n                reverse[i - 1] = mod.mod(reverse[i] * base);\n            }\n        }\n\n        public long pow(int x) {\n            if (x >= 0) {\n                return natural[x];\n            } else {\n                return reverse[-x];\n            }\n        }\n\n        public String toString() {\n            return \"Exponentiation{\" +\n                    \"natural=\" + Arrays.toString(natural) +\n                    \", reverse=\" + Arrays.toString(reverse) +\n                    '}';\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n//\n// Created by kulikov on 10/17/2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_INPUT_H\n#define JHELPER_EXAMPLE_PROJECT_INPUT_H\n\n//\n// Created by egor on 30.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_GENERAL_H\n#define JHELPER_EXAMPLE_PROJECT_GENERAL_H\n\n\n\nusing namespace std;\n\ntypedef long long longint;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int MAX_INT = 2147483647;\n\nconst double PI = atan(1) * 4;\n\nconst int DX_KNIGHT[] = {2, 1, -1, -2, -2, -1, 1, 2};\nconst int DY_KNIGHT[] = {1, 2, 2, 1, -1, -2, -2, -1};\nconst int DX4[] = {1, 0, -1, 0};\nconst int DY4[] = {0, 1, 0, -1};\n\nbool isValidCell(int x, int y, int rows, int cols) {\n    return x >= 0 && y >= 0 && x < rows && y < cols;\n}\n\nvoid decreaseByOne() {\n}\n\ntemplate <typename T, class...Vargs>\nvoid decreaseByOne(vector<T>& arr, Vargs...arrs) {\n    for (int& i : arr) {\n        i--;\n    }\n    decreaseByOne(arrs...);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_GENERAL_H\n\n\nclass Input {\npublic:\n    enum ErrorType {\n        OK,\n        END_OF_FILE,\n        UNEXPECTED_SYMBOL,\n        INVALID_CALL\n    };\n\nprivate:\n    istream& in;\n    bool exhausted = false;\n    ErrorType error = OK;\n    int get();\n    template<typename T> T readInteger();\n    int skipWhitespace();\n\npublic:\n    Input(istream& in);\n    int readInt();\n    longint readLong();\n    string readString();\n    vector<int> readIntArray(int size);\n    template<typename T> T readType();\n    template<typename T> vector<T> readArray(int size);\n    template<typename T1, typename T2> tuple<vector<T1>, vector<T2> > readArrays(int size);\n    template<typename T1, typename T2, typename T3> tuple<vector<T1>, vector<T2>, vector<T3> > readArrays(int size);\n    template<typename T1, typename T2, typename T3, typename T4>\n        tuple<vector<T1>, vector<T2>, vector<T3>, vector<T4> > readArrays(int size);\n    template<typename T1, typename T2, typename T3, typename T4, typename T5>\n        tuple<vector<T1>, vector<T2>, vector<T3>, vector<T4>, vector<T5> > readArrays(int size);\n    template<typename T> vector<vector<T> > readTable(int rows, int cols);\n\n    string readLine();\n};\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nint Input::skipWhitespace() {\n    int c;\n    do {\n        c = get();\n        if (exhausted) {\n            error = END_OF_FILE;\n            return c;\n        }\n    } while (isWhitespace(c));\n    return c;\n}\n\nInput::Input(std::istream &in) : in(in) {\n}\n\ninline int Input::get() {\n    int result = in.get();\n    if (result == EOF) {\n        exhausted = true;\n    }\n    return result;\n}\n\ntemplate<typename T>\nT Input::readType() {\n    error = INVALID_CALL;\n    return nullptr;\n}\n\ntemplate<typename T>\nT Input::readInteger() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return 0;\n    }\n    int sgn = 1;\n    if (c == '-') {\n        sgn = -1;\n        c = get();\n    }\n    T res = 0;\n    do {\n        if (!isdigit(c)) {\n            error = UNEXPECTED_SYMBOL;\n            return 0;\n        }\n        res *= 10;\n        res += c - '0';\n        c = get();\n    } while (!isWhitespace(c));\n    return res * sgn;\n}\n\ntemplate<>\nint Input::readType() {\n    return readInteger<int>();\n}\n\ntemplate<>\nlongint Input::readType() {\n    return readInteger<longint>();\n}\n\ntemplate<>\nchar Input::readType() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return 0;\n    }\n    return c;\n}\n\ntemplate<>\nstring Input::readType() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return \"\";\n    }\n    vector<char> res;\n    do {\n        if (error != OK) {\n            return \"\";\n        }\n        res.push_back(c);\n    } while (!isWhitespace(c = get()));\n    return string(res.begin(), res.end());\n}\n\ninline int Input::readInt() {\n    return readType<int>();\n}\n\ninline longint Input::readLong() {\n    return readType<longint>();\n}\n\ntemplate<typename T>\nvector<T> Input::readArray(int size) {\n    vector<T> res;\n    res.reserve(size);\n    for (int i = 0; i < size; i++) {\n        res.push_back(readType<T>());\n        if (error != OK) {\n            res.clear();\n            return res;\n        }\n    }\n    return res;\n}\n\nvector<int> Input::readIntArray(int size) {\n    return readArray<int>(size);\n}\n\ntemplate<typename T1, typename T2>\ntuple<vector<T1>, vector<T2> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    v1.reserve(size);\n    v2.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n    }\n    return make_tuple(v1, v2);\n}\n\nstring Input::readString() {\n    return readType<string>();\n}\n\ntemplate<typename T>\nvector<vector<T>> Input::readTable(int rows, int cols) {\n    vector<vector<T> > result;\n    result.reserve(rows);\n    for (int i = 0; i < rows; ++i) {\n        result.push_back(readArray<T>(cols));\n    }\n    return result;\n}\n\nstring Input::readLine() {\n    error = OK;\n    int c = skipWhitespace();\n    if (error != OK) {\n        return \"\";\n    }\n    int length = 0;\n    vector<char> res;\n    do {\n        if (error != OK) {\n            return \"\";\n        }\n        res.push_back(c);\n        if (!isWhitespace(c)) {\n            length = res.size();\n        }\n        c = get();\n    } while (c != '\\n' && c != '\\r' && c != EOF);\n    return string(res.begin(), res.begin() + length);\n}\n\ntemplate<typename T1, typename T2, typename T3>\ntuple<vector<T1>, vector<T2>, vector<T3> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n    }\n    return make_tuple(v1, v2, v3);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename T4>\ntuple<vector<T1>, vector<T2>, vector<T3>, vector<T4> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    vector<T4> v4;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    v4.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n        v4.push_back(readType<T4>());\n    }\n    return make_tuple(v1, v2, v3, v4);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename T4, typename T5>\ntuple<vector<T1>, vector<T2>, vector<T3>, vector<T4>, vector<T5> > Input::readArrays(int size) {\n    vector<T1> v1;\n    vector<T2> v2;\n    vector<T3> v3;\n    vector<T4> v4;\n    vector<T5> v5;\n    v1.reserve(size);\n    v2.reserve(size);\n    v3.reserve(size);\n    v4.reserve(size);\n    v5.reserve(size);\n    for (int i = 0; i < size; ++i) {\n        v1.push_back(readType<T1>());\n        v2.push_back(readType<T2>());\n        v3.push_back(readType<T3>());\n        v4.push_back(readType<T4>());\n        v5.push_back(readType<T5>());\n    }\n    return make_tuple(v1, v2, v3, v4, v5);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_INPUT_H\n\n//\n// Created by egor on 31.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n#define JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n\n\n\nclass Output {\nprivate:\n    ostream& out;\n    template<typename T> void printSingle(const T& value);\n    template<typename T> void printSingle(const vector<T>& value);\n    template<typename T, typename U> void printSingle(const pair<T, U>& value);\n\npublic:\n    Output(ostream& out);\n    void print();\n    template<typename T, typename...Targs>void print(const T& first, const Targs... args);\n    template<typename...Targs>void printLine(const Targs... args);\n    void flush();\n};\n\nOutput::Output(ostream &out) : out(out) {\n    out << setprecision(12);\n}\n\nvoid Output::print() {\n}\n\ntemplate<typename T, typename... Targs>\nvoid Output::print(const T& first, const Targs... args) {\n    printSingle(first);\n    if (sizeof...(args) != 0) {\n        out << ' ';\n        print(args...);\n    }\n}\n\ntemplate<typename T>\nvoid Output::printSingle(const T& value) {\n    out << value;\n}\n\ntemplate<typename... Targs>\nvoid Output::printLine(const Targs... args) {\n    print(args...);\n    out << '\\n';\n}\n\nvoid Output::flush() {\n    out.flush();\n}\n\ntemplate<typename T>\nvoid Output::printSingle(const vector<T>& array) {\n    unsigned int size = array.size();\n    for (int i = 0; i < size; ++i) {\n        out << array[i];\n        if (i + 1 != size) {\n            out << ' ';\n        }\n    }\n}\n\ntemplate<typename T, typename U>\nvoid Output::printSingle(const pair<T, U>& value) {\n    out << value.first << ' ' << value.second;\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_OUTPUT_H\n\n//\n// Created by egor on 31.10.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_MODULO_H\n#define JHELPER_EXAMPLE_PROJECT_MODULO_H\n\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\nclass ModuloInt {\nprivate:\n    longint n;\n\npublic:\n    ModuloInt() : n(0) {}\n    ModuloInt(int n) {\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n    ModuloInt(const ModuloInt& n) = default;\n    ModuloInt& operator +=(const ModuloInt& other);\n    ModuloInt& operator -=(const ModuloInt& other);\n    ModuloInt& operator *=(const ModuloInt& other);\n    ModuloInt operator -();\n    friend ostream&operator <<(ostream& out, const ModuloInt& val);\n};\n\nModuloInt &ModuloInt::operator+=(const ModuloInt& other) {\n    n += other.n;\n    if (n >= mod) {\n        n -= mod;\n    }\n    return *this;\n}\n\nModuloInt &ModuloInt::operator-=(const ModuloInt& other) {\n    n -= other.n;\n    if (n < 0) {\n        n += mod;\n    }\n    return *this;\n}\n\nModuloInt &ModuloInt::operator*=(const ModuloInt& other) {\n    n *= other.n;\n    n %= mod;\n    return *this;\n}\n\nModuloInt operator +(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) += b;\n}\n\nModuloInt operator -(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) -= b;\n}\n\nModuloInt operator *(const ModuloInt& a, const ModuloInt& b) {\n    return ModuloInt(a) *= b;\n}\n\nostream& operator <<(ostream& out, const ModuloInt& val) {\n    return out << val.n;\n}\n\nModuloInt ModuloInt::operator-() {\n    if (n == 0) {\n        return 0;\n    }\n    return ModuloInt(mod - n);\n}\n\n#endif //JHELPER_EXAMPLE_PROJECT_MODULO_H\n\n//\n// Created by egor on 01.11.2019.\n//\n\n#ifndef JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n#define JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n\n\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT power(const T& a, longint b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nvector<T> generateFactorial(int length) {\n    vector<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generateReverse(int length) {\n    vector<T> result(length);\n    if (length > 1) {\n        result[1] = 1;\n    }\n    for (int i = 2; i < length; i++) {\n        result[i] = -(mod / i) * result[mod % i];\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generatePowers(T base, int length) {\n    vector<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\ntemplate <typename T>\nvector<T> generateReverseFactorial(int length) {\n    auto result = generateReverse<T>(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] *= result[i - 1];\n    }\n    return result;\n}\n\ntemplate <typename T>\nclass Combinations {\nprivate:\n    vector<T> fact;\n    vector<T> revFactorial;\n\npublic:\n    Combinations(int length) {\n        fact = generateFactorial<T>(length);\n        revFactorial = generateReverseFactorial<T>(length);\n    }\n\npublic:\n    T c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return fact[n] * revFactorial[k] * revFactorial[n - k];\n    }\n\n    T factorial(int n) {\n        return fact[n];\n    }\n\n    T reverseFactorial(int n) {\n        return revFactorial[n];\n    }\n};\n\n#endif //JHELPER_EXAMPLE_PROJECT_NUMBERS_H\n\n\nusing namespace std;\n\nclass CNeitherABNorBA {\npublic:\n\tvoid solve(std::istream& inp, std::ostream& outp) {\n        Input in(inp);\n        Output out(outp);\n\n        int n = in.readInt();\n\n        mod = MODF;\n        ModuloInt answer = power(ModuloInt(3), n);\n        Combinations<ModuloInt> c(n + 1);\n        auto pow = generatePowers(ModuloInt(2), n + 1);\n        n = n / 2;\n        vector<ModuloInt> qty(n + 1);\n        for (int i = 0; i <= n; i++) {\n            qty[i] = c.c(n, i) * pow[n - i];\n        }\n        vector<ModuloInt> sumQty(n + 1);\n        sumQty[n] = qty[n];\n        for (int i = n - 1; i >= 0; i--) {\n            sumQty[i] = qty[i] + sumQty[i + 1];\n        }\n        for (int i = 1; i <= n; i++) {\n            answer -= 2 * qty[i] * sumQty[n - i + 1];\n        }\n        out.printLine(answer);\n\t}\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\tCNeitherABNorBA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[] a = new long[n/2+1];\n\t\tint mod = 998244353;\n\t\tint[][] fif = enumFIF(5000005, mod);\n\t\tlong[] p2 = enumPows(2, 5000005, mod);\n\t\t\n\t\tfor(int i = 0;i <= n/2;i++){\n\t\t\ta[i] = C(n/2, i, mod, fif) * p2[n/2-i] % mod;\n\t\t}\n\t\tlong ans = 0;\n\t\tlong s = 0;\n\t\tfor(int i = 1;i <= n/2;i++){\n\t\t\ts += a[n/2+1-i];\n\t\t\tif(s >= mod)s -= mod;\n\t\t\tans += s * a[i];\n\t\t\tans %= mod;\n\t\t}\n\t\t\n\t\tans = pow(3, n, mod) - ans*2 + 2L*mod;\n\t\tans %= mod;\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static long[] enumPows(int a, int n, int mod)\n\t{\n\t\ta %= mod;\n\t\tlong[] pows = new long[n+1];\n\t\tpows[0] = 1;\n\t\tfor(int i = 1;i <= n;i++)pows[i] = pows[i-1] * a % mod;\n\t\treturn pows;\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static boolean inc(int[] a, int base) {\n\t\tint n = a.length;\n\t\tint i;\n\t\tfor (i = n - 1; i >= 0 && a[i] == base - 1; i--)\n\t\t\t;\n\t\tif (i == -1)\n\t\t\treturn false;\n\n\t\ta[i]++;\n\t\tArrays.fill(a, i + 1, n, 0);\n\t\treturn true;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n) {\n    ModCalculator mc = new ModCalculator(998244353L);\n    long[] pow2cache = new long[n + 1];\n    pow2cache[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      pow2cache[i] = mc.mul(pow2cache[i - 1], 2);\n    }\n    long answer = mc.pow(3, n);\n    for (int k = n / 2 + 1; k <= n; k++) {\n      long v1 = mc.getC(n, k);\n      long v2 = pow2cache[n - k + 1];\n      long v3 = mc.mul(v1, v2);\n      answer = mc.sub(answer, v3);\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    out.println(solve(n));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModInverseCache modInverseCache;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modInverseCache = new ModInverseCache();\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    long nogmalized = v % mod;\n    if (nogmalized < 0) {\n      nogmalized += mod;\n    }\n    return nogmalized;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n\n  // Verify ttpc2019 J\n  // https://atcoder.jp/contests/ttpc2019/tasks/ttpc2019_j\n  class PrimitiveLongList {\n    long[] values;\n    int size;\n\n    public PrimitiveLongList() {\n      values = new long[10];\n    }\n\n    private void resize() {\n      long[] newValues = new long[values.length * 2];\n      System.arraycopy(values, 0, newValues, 0, values.length);\n      values = newValues;\n    }\n\n    public void add(long value) {\n      if (size >= values.length) {\n        resize();\n      }\n      values[size] = value;\n      size++;\n    }\n\n    private void validateIndex(int index) {\n      if (index < 0 || size <= index) {\n        throw new IndexOutOfBoundsException(String.format(\"size: %d, index: %d\", size, index));\n      }\n    }\n\n    public long get(int index) {\n      validateIndex(index);\n      return values[index];\n    }\n\n    public void set(int index, long value) {\n      validateIndex(index);\n      values[index] = value;\n    }\n\n    public int size() {\n      return size;\n    }\n  }\n\n  // Verify AGC 040 C\n  // https://atcoder.jp/contests/agc040/tasks/agc040_c\n  class ModInverseCache {\n    private final PrimitiveLongList inverseCache;\n\n    public ModInverseCache() {\n      inverseCache = new PrimitiveLongList();\n      inverseCache.add(0L);\n      inverseCache.add(1L);\n    }\n\n    private void resize(int n) {\n      for (int i = inverseCache.size(); i <= n; i++) {\n        long k = mod / i;\n        int r = (int)(mod % i);\n        long inverse = mul(-k, inverseCache.get(r));\n        inverseCache.add(inverse);\n      }\n    }\n\n    long get(int n) {\n      resize(n);\n      return inverseCache.get(n);\n    }\n  }\n  \n  class ModCombinationCache {\n    private final PrimitiveLongList factorialCache;\n    private final PrimitiveLongList factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new PrimitiveLongList();\n      factorialCache.add(1L);\n      factorialInverseCache = new PrimitiveLongList();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        factorialCache.add(mul(factorialCache.get(i), i + 1));\n        factorialInverseCache.add(mul(factorialInverseCache.get(i), modInverseCache.get(i + 1)));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    static final int mod = 998244353;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      // d = new HashMap<>();\n      // {\n      //     int p3 = 1;\n      //     for (int n = 1; n <= 5; ++n) {\n      //         p3 *= 9;\n      //         a = new char[2 * n];\n      //         int cur = calc(0, 2 * n);\n      //         out.printLine(n + \" \" + cur + \" \" + (p3 - cur) / 2);\n      //     }\n      // }\n      int n = in.nextInt() / 2;\n      long res = 7;\n      int p2 = 8;\n      long num = 1;\n      long den = 2;\n      for (int i = 1; i < n; ++i) {\n        res *= 9L;\n        if (i > 1) {\n          long inc = p2;\n          inc *= num;\n          inc %= mod;\n          inc *= IntegerUtils.pow((int) den, mod - 2, mod);\n          inc %= mod;\n          res += inc;\n        }\n        res %= mod;\n        p2 = (p2 * 2) % mod;\n        {\n          int k = i;\n          num *= 2 * k;\n          num %= mod;\n          num *= 2 * k + 1;\n          num %= mod;\n          if (k > 1) {\n            den *= k - 1;\n          }\n          den %= mod;\n          den *= k + 2;\n          den %= mod;\n        }\n      }\n      out.printLine(res);\n    }\n\n  }\n\n  static class IntegerUtils {\n\n    public static int pow(long x, long y, int mod) {\n      x %= mod;\n      long res = 1;\n      while (y > 0) {\n        if (y % 2 == 1) {\n          --y;\n          res = (res * x) % mod;\n        } else {\n          y /= 2;\n          x = (x * x) % mod;\n        }\n      }\n      return (int) (res % mod);\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        static final long MODULO = 998244353;\n        static int[] invs;\n        static int[] facts;\n        static int[] invfacts;\n\n        static {\n            int k = (int) 1.1e7;\n            invs = new int[k + 2];\n            invs[1] = 1;\n            for (int i = 2; i <= k + 1; ++i) {\n                invs[i] = (int) ((MODULO - (MODULO / i) * (long) invs[(int) (MODULO % i)] % MODULO) % MODULO);\n            }\n            facts = new int[k + 2];\n            invfacts = new int[k + 2];\n            facts[0] = 1;\n            invfacts[0] = 1;\n            for (int i = 1; i <= k + 1; ++i) {\n                facts[i] = (int) (facts[i - 1] * (long) i % MODULO);\n                invfacts[i] = (int) (invfacts[i - 1] * (long) invs[i] % MODULO);\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long res = 1;\n            for (int i = 0; i < n; ++i) {\n                res = res * 3 % MODULO;\n            }\n\n            long p2 = 2;\n            for (int na = 0; na < n / 2; ++na) {\n                res = (res - facts[n] * (long) invfacts[na] % MODULO * invfacts[n - na] % MODULO * p2) % MODULO;\n                p2 = p2 * 2 % MODULO;\n            }\n            if (res < 0) res += MODULO;\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ProblemC_NoAbNoBa solver = new ProblemC_NoAbNoBa();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ProblemC_NoAbNoBa {\n        final int N = (int) (1e7 + 100);\n        final int MOD = 998244353;\n        int[] fact = new int[N];\n        int[] inv = new int[N];\n        int[] invFact = new int[N];\n        int[] table = new int[7];\n        Map<String, Boolean> cache = new HashMap<>();\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            if (false) {\n                gen(\"\");\n                for (int i = 0; i < table.length; i++) {\n                    int total = (int) Math.pow(3.0, 2 * i);\n//            System.out.printf(\"%d\\t%d\\t%d\\t%.2f\\n\", table[i], total - table[i], total, 100.0*table[i]/total);\n                    System.out.printf(\"%d \\n\", table[i]);\n                }\n                System.out.println(Arrays.toString(table));\n            }\n\n            int n = in.nextInt();\n            precalc();\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                ans = 3 * ans % MOD;\n            }\n\n            int[] p2 = new int[n + 1];\n            p2[0] = 1;\n            for (int i = 1; i < p2.length; i++) {\n                p2[i] = 2 * p2[i - 1] % MOD;\n            }\n\n            for (int i = n / 2 + 1; i <= n; i++) {\n                ans = (ans - 2L * p2[n - i] * C(n, i)) % MOD;\n            }\n            if (ans < 0) {\n                ans += MOD;\n            }\n            out.println(ans);\n        }\n\n        private void precalc() {\n            inv[1] = 1;\n            for (int i = 2; i < N; i++) {\n                inv[i] = (int) ((MOD - (MOD / i) * (long) inv[MOD % i] % MOD) % MOD);\n            }\n            fact[0] = 1;\n            invFact[0] = 1;\n            for (int i = 1; i < N; i++) {\n                fact[i] = (int) (i * (long) fact[i - 1] % MOD);\n                invFact[i] = (int) (inv[i] * (long) invFact[i - 1] % MOD);\n            }\n        }\n\n        private int C(int n, int k) {\n            if (k < 0 || k > n) {\n                return 0;\n            }\n            long a = fact[n];\n            long b = invFact[k] * (long) invFact[n - k] % MOD;\n            return (int) (a * b % MOD);\n        }\n\n        private void gen(String s) {\n            if (s.length() >= 14) {\n                return;\n            }\n            if (s.length() == 6 && !isGood(s)) {\n                System.out.println(s);\n            }\n            if (isGood(s)) {\n                ++table[s.length() / 2];\n            }\n            for (char c0 = 'a'; c0 <= 'c'; c0++) {\n                for (char c1 = 'a'; c1 <= 'c'; c1++) {\n                    gen(s + c0 + c1);\n                }\n            }\n        }\n\n        private boolean isGood(String s) {\n            if (cache.containsKey(s)) {\n                return cache.get(s);\n            }\n            boolean res = s.isEmpty();\n            for (int i = 0; i + 1 < s.length(); i++) {\n                char c0 = s.charAt(i);\n                char c1 = s.charAt(i + 1);\n//            if (Math.min(c0, c1) == 'a' && Math.max(c0, c1) == 'b') {\n//            if (c0 == 'a' && c1 == 'b') {\n//                continue;\n//            }\n                if (c0 == 'a' && c1 == 'a' || c0 == 'b' && c1 == 'b') {\n                    continue;\n                }\n                if (isGood(s.substring(0, i) + s.substring(i + 2))) {\n                    res = true;\n                    break;\n                }\n            }\n            cache.put(s, res);\n            return res;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n) {\n    ModCalculator mc = new ModCalculator(998244353L);\n    long[] pow2cache = new long[n + 1];\n    pow2cache[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      pow2cache[i] = mc.mul(pow2cache[i - 1], 2);\n    }\n    long answer = mc.pow(3, n);\n    for (int k = n / 2 + 1; k <= n; k++) {\n      long v1 = mc.getC(n, k);\n      long v2 = pow2cache[n - k + 1];\n      long v3 = mc.mul(v1, v2);\n      answer = mc.sub(answer, v3);\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    out.println(solve(n));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    return v % mod;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n\n  // Verify ttpc2019 J\n  // https://atcoder.jp/contests/ttpc2019/tasks/ttpc2019_j\n  class PrimitiveLongList {\n    long[] values;\n    int size;\n\n    public PrimitiveLongList() {\n      values = new long[10];\n    }\n\n    private void resize() {\n      long[] newValues = new long[values.length * 2];\n      System.arraycopy(values, 0, newValues, 0, values.length);\n      values = newValues;\n    }\n\n    public void add(long value) {\n      if (size >= values.length) {\n        resize();\n      }\n      values[size] = value;\n      size++;\n    }\n\n    private void validateIndex(int index) {\n      if (index < 0 || size <= index) {\n        throw new IndexOutOfBoundsException(String.format(\"size: %d, index: %d\", size, index));\n      }\n    }\n\n    public long get(int index) {\n      validateIndex(index);\n      return values[index];\n    }\n\n    public void set(int index, long value) {\n      validateIndex(index);\n      values[index] = value;\n    }\n\n    public int size() {\n      return size;\n    }\n  }\n  \n  class ModCombinationCache {\n    private final PrimitiveLongList factorialCache;\n    private final PrimitiveLongList factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new PrimitiveLongList();\n      factorialCache.add(1L);\n      factorialInverseCache = new PrimitiveLongList();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printStream) {\n    super(printStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CNeitherABNorBA solver = new CNeitherABNorBA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CNeitherABNorBA {\n        int mod = 998244353;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            long ans = MathUtils.modPow(3, n, mod);\n            Combinations comb = new Combinations(n + 1, mod);\n            int[] powers = new int[n / 2 + 1];\n            powers[0] = 1;\n            for (int i = 1; i < powers.length; i++) {\n                powers[i] = (powers[i - 1] * 2) % mod;\n            }\n            for (int i = 0; i < n / 2; i++) {\n                long sub = (long) comb.choose(n, i) * powers[i] * 2 % mod;\n                ans = (ans + mod - sub) % mod;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public FastScanner(String fileName) {\n            try {\n                br = new BufferedReader(new FileReader(fileName));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n\n    static class Combinations {\n        public final int max;\n        public final int mod;\n        public int[] inv;\n        public int[] fact;\n        public int[] invFact;\n\n        public Combinations(int max, int mod) {\n            this.max = max;\n            this.mod = mod;\n            inv = MathUtils.inverses(max, mod);\n            fact = new int[max];\n            invFact = new int[max];\n            fact[0] = invFact[0] = 1;\n            for (int i = 1; i < max; i++) {\n                fact[i] = (int) ((long) fact[i - 1] * i % mod);\n                invFact[i] = (int) ((long) invFact[i - 1] * inv[i] % mod);\n            }\n        }\n\n        public int choose(int n, int k) {\n            if (k < 0 || k > n) {\n                return 0;\n            }\n            return (int) ((long) fact[n] * invFact[k] % mod * invFact[n - k] % mod);\n        }\n\n    }\n\n    static class MathUtils {\n        public static int modPow(int a, long b, int mod) {\n            while (a < 0) {\n                a += mod;\n            }\n            int res = 1;\n            while (b > 0) {\n                if ((b & 1) != 0) {\n                    res = (int) ((long) res * a % mod);\n                }\n                a = (int) ((long) a * a % mod);\n                b >>>= 1;\n            }\n            return res;\n        }\n\n        public static int[] inverses(int size, int mod) {\n            int[] inv = new int[size];\n            inv[1] = 1;\n            for (int i = 2; i < inv.length; i++) {\n                inv[i] = (int) ((long) (mod - mod / i) * inv[mod % i] % mod);\n            }\n            return inv;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.awt.Point;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\nimport java.util.RandomAccess;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\tprivate void solve(FastIO io) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AGC040 C問題\n\t\t * 考察メモ\n\t\t * よく考えたらこれで解けるので\n\t\t */\n\t\tint N = io.nextInt();\n\t\tModUtility mod = new ModUtility(new Prime(998244353), N + 2);\n\t\tModInteger ans = mod.create(mod.pow(3, N));\n\t\tModInteger pow = mod.create(mod.pow(2, N / 2));\n\t\tfor (int i = N / 2 + 1;i <= N;++ i) {\n\t\t\tans.subtractEqual(pow.multiply(mod.combination(N, N - i)));\n\t\t\tpow.divideEqual(2);\n\t\t}\n\t\tio.println(ans);\n\n\t}\n\n\t/** デバッグ用コードのお供に */\n\tprivate static boolean DEBUG = false;\n\t/** 確保するメモリの大きさ(単位: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());\n\t        new Thread(null, new Main(), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main() {\n\t\tthis(new FastIO());\n\t}\n\n\tpublic Main(FastIO io) {\n\t\tthis.io = io;\n\t\tif (DEBUG) {\n\t\t\tio.setAutoFlush(true);\n\t\t\tio.println(\"debug mode\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tsolve(io);\n\t\tio.flush();\n\t}\n\n\t// 以下、ライブラリ\n\n\tpublic static class FastIO {\n\t\tprivate final InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tpublic final PrintWriter out;\n\t\tpublic final PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic char[][] nextChar(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile(!isPrintableChar(b = readByte()));\n\t\t\tdo sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic Object print(Object obj) {\n\t\t\tif (obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t}\n\n\t\tpublic boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * この区間が空集合か判定します。\n\t\t * @return 空集合ならばtrue\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t\t * 接する場合は区間の左側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の左側に位置するならtrue\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t\t * 接する場合は区間の右側ではないと判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間の右側に位置するならtrue\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる引数\n\t\t * @return 区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t\t * 接する場合も区間内に位置すると判定します。\n\t\t * @param value 調べる要素\n\t\t * @return 全ての要素が区間内に位置するならtrue\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t\t *\n\t\t * @param other\n\t\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t\t * 接する場合は公差するものとします。\n\t\t * @param value 調べる引数\n\t\t * @return 区間が交差するならtrue\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * この区間との積集合を返します。\n\t\t * @param connectedRange 積集合を求める区間\n\t\t * @return 積集合\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * この区間との和集合を返します。\n\t\t * @param other 和集合を求める区間\n\t\t * @return 和集合\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が結合法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、1以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* この演算が逆元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * 演算が交換法則を満たすことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * 演算が単位元を持つことを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Unit<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * 単位元を返します。\n\t\t * @return 単位元\n\t\t */\n\t\tpublic T unit();\n\t}\n\n\t/**\n\t * 演算が群であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = unit();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算がモノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Unit<T> {\n\t\t/**\n\t\t * repeat個のelementを順次演算した値を返します。\n\t\t * @param element 演算する値\n\t\t * @param repeat 繰り返す回数、0以上であること\n\t\t * @return 演算を+として、element + element + ... + elementと演算をrepeat-1回行った値\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = unit();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 演算が可換モノイドであることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * 演算がアーベル群(可換群)であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * 演算が半環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t}\n\n\t/**\n\t * 演算が環であることを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * 演算が可換環に属することを示すために使用するマーカー・インターフェースです。\n\t * @author 31536000\n\t *\n\t * @param <T> 二項演算の型\n\t * @param <A> 和に関する演算\n\t * @param <M> 積に関する演算\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\tpublic static class ModInteger extends Number implements CommutativeRing<ModInteger, Abelian<ModInteger>, CommutativeMonoid<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger unit() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger unit() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // 偶数\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn new ModInteger(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn new ModInteger(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn new ModInteger(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn new ModInteger(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn new ModInteger(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn new ModInteger(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn new ModInteger(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn new ModInteger(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn new ModInteger(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn new ModInteger(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn new ModInteger(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn new ModInteger(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn new ModInteger(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn new ModInteger(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn new ModInteger(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を法とする演算上で、組み合わせの計算を高速に行います。\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * modを法として、演算を行います。\n\t\t * @param mod 法とする素数\n\t\t * @param calc 予め前計算しておく大きさ\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calcの大きさだけ、前計算を行います。\n\t\t * @param calc 前計算をする大きさ\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @return modを法とする整数、初期値は0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * modを法とする剰余環上で振舞う整数を返します。\n\t\t * @param n 初期値\n\t\t * @return modを法とする整数\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * modを法として、nの逆元を返します。<br>\n\t\t * 計算量はO(log n)です。\n\t\t * @param n 逆元を求めたい値\n\t\t * @return 逆元\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!を、modを法として求めた値を返します。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 階乗を求めたい値\n\t\t * @return nの階乗をmodで割った余り\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nPkをmodで割った余り\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (k < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n-k)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nCkをmodで割った余り\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (k < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tif (invfact.length > k) ret = invfact[k];\n\t\t\telse ret = inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * 他項係数をmodで割った余りを求めます。<br>]\n\t\t * 計算量はO(n)です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺、合計がn以下である必要がある\n\t\t * @return 他項係数\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n個からk個を選ぶ重複組み合わせnHkをmodで割った余りを求めます。<br>\n\t\t * 計算量はO(min(n, k))です。\n\t\t * @param n 左辺\n\t\t * @param k 右辺\n\t\t * @return nHkをmodで割った余り\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * カタラン数C(n)をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(n)です。\n\t\t * @param n 求めたいカタラン数の番号\n\t\t * @return カタラン数\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * nのm乗をmodで割った余りを求めます。<br>\n\t\t * 計算量はO(log m)です。\n\t\t * @param n 床\n\t\t * @param m 冪指数\n\t\t * @return n^mをmodで割った余り\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * 現在のmod値のトーシェント数を返します。<br>\n\t\t * なお、これはmod-1に等しいです。\n\t\t * @return トーシェント数\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * nのトーシェント数を返します。<br>\n\t\t * 計算量はO(sqrt n)です。\n\t\t * @param n トーシェント数を求めたい値\n\t\t * @return nのトーシェント数\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * nをmodで割った余りを返します。\n\t\t * @param n 演算する値\n\t\t * @return nをmodで割った余り\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * n+mをmodで割った余りを返します。\n\t\t * @param n 足される値\n\t\t * @param m 足す値\n\t\t * @return n+mをmodで割った余り\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-mをmodで割った余りを返します。\n\t\t * @param n 引かれる値\n\t\t * @param m 引く値\n\t\t * @return n-mをmodで割った余り\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*mをmodで割った余りを返します。\n\t\t * @param n 掛けられる値\n\t\t * @param m 掛ける値\n\t\t * @return n*mをmodで割った余り\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/mをmodで割った余りを返します。\n\t\t * @param n 割られる値\n\t\t * @param m 割る値\n\t\t * @return n/mをmodで割った余り\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * fを通ることが分かっているfの要素数-1次の関数について、xの位置における値をmodで割った余りを返します。<br>\n\t\t * 計算量はO(f)です。\n\t\t * @param f 関数の形\n\t\t * @param x 求める位置\n\t\t * @return 求めたい値をmodで割った余り\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * 素数を渡すためのクラスです。<br>\n\t * 中身が確実に素数であることを保証するときに使ってください。\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * 素数を設定します。\n\t\t *\n\t\t * @param prime 素数\n\t\t * @throws IllegalArgumentException 素数以外を渡した時\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\n\t\tprivate static boolean isSPRP(int n, int a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\twhile (pw != 0) {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = (int)(((long)a * a) % n);\n\t\t\t\tpw >>= 1;\n\t\t\t}\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0; r < s; r++ ) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * 与えられた値が素数か否かを判定します。<br>\n\t\t * この実装はhttp://ceur-ws.org/Vol-1326/020-Forisek.pdfに基づきます。\n\t\t * @param x 判定したい値\n\t\t * @return xが素数ならtrue\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tlong N = long.Parse(Console.ReadLine());\n\t\tlong mod = 998244353;\n\t\tlong ans = Mpow(3,N,mod);\n\t\tlong n1 = 1;\n\t\tlong an1 = 1;\n\t\tfor(var i=N;i*2>=N+1;i--){\n\t\t\tlong a1 = an1;\n\t\t\ta1 = a1 * n1 % mod;\n\t\t\tans = (ans + mod * 2- a1 * 2) % mod;\n\t\t\tn1 = n1 * 2 % mod;\n\t\t\tan1 = an1 * i % mod;\n\t\t\tan1 = an1 * Mpow(N-i+1,mod-2,mod) % mod;\n\t\t}\n\t\tConsole.WriteLine(ans);\n\t}\n\tpublic static long Mpow(long x,long n,long m)\n\t{\n\t\tlong ans = 1;\n\t\twhile(n > 0){\n\t\t\tif(n % 2 == 1){\n\t\t\t\tans = ans * x % m;\n\t\t\t\tn -= 1;\n\t\t\t}\n\t\t\tx = x * x % m;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static long Ncr(long n,long r,long m)\n\t{\n\t\tlong ans = 1;\n\t\tfor(var i=n-r+1;i<=n;i++){\n\t\t\tans = ans * i % m;\n\t\t}\n\t\tfor(var i=2;i<=r;i++){\n\t\t\tans = ans * Mpow(i,m-2,m) % m;\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n = sc.Int;\n        MyMath.setfacts(n + 9);\n        long ans = 0;\n        long p2 = 1;\n        for (int i = 0; i < n / 2; i++)\n        {\n            ans = (ans + MyMath.comb(n, i) * p2 * 2) % M;\n            p2 = p2 * 2 % M;\n        }\n        ans = (MyMath.pow(3, n) - ans + M) % M;\n        Prt(ans);\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    // public static readonly int M = 1000000007;\n    public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n\nstatic class MyMath {\n    public static long Mod = util.M;\n    // public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static bool[] segmentSieve(long l, long r) {\n        int sqn = (int)Math.Sqrt(r + 9);\n        var ps = getprimes(sqn);\n        return segmentSieve(l, r,ps);\n    }\n    public static bool[] segmentSieve(long l, long r, List<int> ps) {\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps) {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b, long mod) {\n        a %= mod;\n        // if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2, mod);\n        if ((b & 1) == 0) return t * t % mod;\n        return t * t % mod * a % mod;\n    }\n    public static long pow(long a, long b) {\n        a %= Mod;\n        // if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) {\n            var t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // return (r, m): x = r (mod. m)\n    // return (0, -1) if no answer\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    // return k: x^k = y (mod. mod) O(sqrt(mod))\n    public static long modlog(long x, long y, long mod) {\n        if (y == 1) return 0;\n        long H = (long)Math.Sqrt(mod) + 1;\n        var baby = new Dictionary<long, long>();\n        for (long b = 0, xby = y; b < H; b++, xby = (xby * x) % mod)\n            if (!baby.ContainsKey(xby))\n                baby.Add(xby, b);\n\n        long xH = 1;\n        for (int i = 0; i < H; ++i) xH = xH * x % mod;\n        for (long a = 1, xaH = xH; a <= H; a++, xaH = (xaH * xH) % mod)\n            if (baby.ContainsKey(xaH))\n                return a * H - baby[xaH];\n\n        return -1;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long fact(long n) {\n        if (n < 0) return 0;\n        if (facts != null && facts.Length > n) return facts[n];\n        long numer = 1;\n        for (long i = 1; i <= n; i++) numer = numer * (i % Mod) % Mod;\n        return numer;\n    }\n    public static long perm(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[n - r] % Mod;\n        long numer = 1;\n        for (long i = 0; i < r; i++) numer = numer * ((n - i) % Mod) % Mod;\n        return numer;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long multi_choose(long n, long r) => comb(n + r - 1, r);\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n    public static class ModMatrix {\n        public static long[][] E(int n) {\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n            return ret;\n        }\n        public static long[][] pow(long[][] A, long n) {\n            if (n == 0) return E(A.Length);\n            var t = pow(A, n / 2);\n            if ((n & 1) == 0) return mul(t, t);\n            return mul(mul(t, t), A);\n        }\n        public static long dot(long[] x, long[] y) {\n            int n = x.Length;\n            long ret = 0;\n            for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n            return ret;\n        }\n        public static long[][] trans(long[][] A) {\n            int n = A[0].Length, m = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n            return ret;\n        }\n        public static long[] mul(long a, long[] x) {\n            int n = x.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n            return ret;\n        }\n        public static long[] mul(long[][] A, long[] x) {\n            int n = A.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long a, long[][] A) {\n            int n = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long[][] A, long[][] B) {\n            int n = A.Length;\n            var Bt = trans(B);\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing E = System.Linq.Enumerable;\n\ninternal partial class Solver {\n\n    public static long ModPow(long x, long n, long mod) {\n        long t = x, ret = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n                ret = (t * ret) % mod;\n            }\n            t = t * t % mod;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    public void Run() {\n        var n = ni();\n        int mod = 998244353;\n\n        var B = new Binomial(n + 1, mod);\n\n        long ans = 0;\n\n        var two = new long[n + 1];\n        two[0] = 1;\n        for (int i = 1; i < two.Length; i++) {\n            two[i] = (two[i - 1] * 2) % mod;\n        }\n\n        for (int i = n / 2 + 1; i <= n; i++) { // i is the number of A\n            long sub = 0;\n            sub += B[n, i] * two[n - i];\n            ans += sub;\n            ans %= mod;\n        }\n\n        ans *= 2;\n        ans %= mod;\n\n        ans = ModPow(3, n, mod) - ans + mod;\n        ans %= mod;\n\n        cout.WriteLine(ans);\n    }\n}\n\npublic class Binomial {\n    private readonly long[] factorial;\n    private readonly long[] inverseFactorial;\n    private readonly long[] inverse;\n    private readonly int mod;\n\n    public Binomial(int size, int primeMod) {\n        size++;\n        factorial = new long[size];\n        inverseFactorial = new long[size];\n        inverse = new long[size];\n        mod = primeMod;\n        Setup(size);\n    }\n\n    private void Setup(int size) {\n        factorial[0] = factorial[1] = 1;\n        inverseFactorial[0] = inverseFactorial[1] = 1;\n        inverse[1] = 1;\n        for (int i = 2; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i % mod;\n            inverse[i] = (mod - (mod / i) * inverse[mod % i] % mod);\n            inverseFactorial[i] = inverseFactorial[i - 1] * inverse[i] % mod;\n        }\n    }\n\n    private long C(int s, int t) {\n        if (s < 0 || t < 0 || s < t) {\n            return 0;\n        }\n\n        if (t == 0 || s == t) {\n            return 1;\n        }\n\n        if (s >= mod) {\n            return C(s % mod, t % mod) * C(s / mod, t / mod) % mod; // Lucas' theorem\n        }\n\n        return factorial[s] * inverseFactorial[t] % mod * inverseFactorial[s - t] % mod;\n    }\n\n    public long this[int s, int t] {\n        get {\n            return C(s, t);\n        }\n    }\n\n    public long P(int s, int t) {\n        if (s < 0 || t < 0 || s < t) return 0;\n        return factorial[s] * inverseFactorial[s - t] % mod;\n    }\n\n    public long H(int s, int t) {\n        if (s < 0 || t < 0) return 0;\n        if (s == 0 && t == 0) return 1;\n        return C(s + t - 1, s);\n    }\n\n    public long H1(int s, int t) {\n        return H(s - t, t);\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\ninternal partial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        byte[] inputBuffer = new byte[1000000];\n        var inputStream = Console.OpenStandardInput(inputBuffer.Length);\n        Console.SetIn(new StreamReader(inputStream, Console.InputEncoding, false, inputBuffer.Length));\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        cin = reader;\n        cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\ninternal static class LinqPadExtension {\n    public static T Dump<T>(this T obj) {\n#if LOCAL\n        return LINQPad.Extensions.Dump(obj);\n#else\n        return obj;\n#endif\n    }\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        string[] array = new string[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = Next();\n        }\n\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextInt();\n        }\n\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextLong();\n        }\n\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        double[] array = new double[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextDouble();\n        }\n\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) {\n                throw new InvalidOperationException();\n            }\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0) {\n            return true;\n        }\n\n        return StockTokens();\n    }\n\n    private static readonly char[] _separator = new[] { ' ', '\\t' };\n    private bool StockTokens() {\n        while (true) {\n            string line = Reader.ReadLine();\n            if (line == null) {\n                return false;\n            }\n\n            string[] tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) {\n                continue;\n            }\n\n            foreach (string token in tokens) {\n                TokenQueue.Enqueue(token);\n            }\n\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\nvar GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\n\nvar mod = 998244353;\nfunction mul(a,b){return ((a>>16)*b%mod*65536+(a&65535)*b)%mod;}\nfunction pow(a,n){for(var r=1;n;a=mul(a,a),n>>=1)if(n&1)r=mul(a,r);return r;}\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var ans = pow(3,n);\n  var fac = 2, m = n/2;\n  var inv = [];\n  inv.length = m+2;\n  inv[0] = inv[1] = 1;\n  for(var i = 0; i < m;){\n    ans -= fac;\n    fac = mul(mul(fac,(n-i)*2),inv[++i]);\n    inv[i+1] = mod-mul(inv[mod%(i+1)|0],(mod/(i+1)|0));\n  }\n  ans%=mod;\n  return ans<0?ans+mod:ans;\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\nvar GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\n\nvar mod = 998244353;\nfunction mul(){for(var a=arguments,r=a[0],i=a.length;--i;)r=((r>>16)*a[i]%mod*65536+(r&65535)*a[i])%mod;return r;}\nvar facn=1,finv=[];\nfunction fset(n){\n  if(n<8500000){\n    for(var i=2;i<=n;i++)facn=facn*i%mod;\n    finv.length=n+1,finv[0]=finv[1]=1;\n    finv[n]=inv(facn);\n    for(i=n;2<i;i--)finv[i-1]=finv[i]*i%mod;\n  }\n  else{\n    facn=488985182;\n    for(var i=8500001;i<=n;i++)facn=mul(facn,i);\n    finv.length=n+1,finv[0]=finv[1]=1;\n    finv[n]=inv(facn);\n    for(i=n;2<i;i--)finv[i-1]=mul(finv[i],i);\n  }\n}\nfunction inv(a){for(var b=mod,u=1,v=0,t;b;v=t)t=a/b|0,a-=t*b,u-=t*v,t=a,a=b,b=t,t=u,u=v;u%=mod;return u<0?u+mod:u;}\nfunction pow(a,n){for(var r=1;n;a=mul(a,a),n>>=1)if(n&1)r=mul(a,r);return r;}\nfunction ncr(n,r){return mul(facn,finv[r],finv[n-r]);}\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var ans = pow(3,n);\n  fset(n);\n  var p2 = 1;\n  for(var i = n, m = n>>1; m < i; i--){\n    p2 += p2;\n    if(mod <= p2)p2 -= mod;\n    ans -= mul(ncr(n,i),p2);\n  }\n  ans%=mod\n  return ans<0?ans+mod:ans;\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\nvar GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\n\nvar mod = 998244353;\nfunction mul(a,b){return ((a>>16)*b%mod*65536+(a&65535)*b)%mod;}\nfunction inv(a){for(var b=mod,u=1,v=0,t;b;v=t)t=a/b|0,a-=t*b,u-=t*v,t=a,a=b,b=t,t=u,u=v;u%=mod;return u<0?u+mod:u;}\nfunction pow(a,n){for(var r=1;n;a=mul(a,a),n>>=1)if(n&1)r=mul(a,r);return r;}\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var ans = pow(3,n);\n  var fac = 1;\n  for(var i = 0, m = n>>1, p2 = 1; i < m; i++){\n    p2 = p2 * 2 % mod;\n    ans -= mul(fac,p2);\n    fac = mul(mul(fac,n-i),inv(i+1));\n  }\n  ans%=mod\n  return ans<0?ans+mod:ans;\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\nvar GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\n\nvar mod = 998244353;\nfunction mul(){for(var a=arguments,r=a[0],i=a.length;--i;)r=((r>>16)*a[i]%mod*65536+(r&65535)*a[i])%mod;return r;}\nvar facn=1,finv=[];\nfunction fset(n){\n  if(n<8e6)for(var i=2;i<=n;i++)facn=facn*i%mod;\n  else{facn=833655840;for(var i=8000001;i<=n;i++)facn=mul(facn,i);}\n  finv.length=n+1,finv[0]=finv[1]=1,finv[n]=inv(facn);\n  for(i=n;2<i;)finv[i-1]=mul(finv[i],i--);\n}\nfunction inv(a){for(var b=mod,u=1,v=0,t;b;v=t)t=a/b|0,a-=t*b,u-=t*v,t=a,a=b,b=t,t=u,u=v;u%=mod;return u<0?u+mod:u;}\nfunction pow(a,n){for(var r=1;n;a=mul(a,a),n>>=1)if(n&1)r=mul(a,r);return r;}\nfunction ncr(n,r){return mul(facn,finv[r],finv[n-r]);}\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var ans = pow(3,n);\n  fset(n);\n  var p2 = 1;\n  for(var i = n, m = n>>1; m < i; i--){\n    p2 += p2;\n    if(mod <= p2)p2 -= mod;\n    ans -= mul(ncr(n,i),p2);\n  }\n  ans%=mod\n  return ans<0?ans+mod:ans;\n}"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nM = 998244353\n\ndef mpow(x, n)\n  ret = 1\n  while n > 0\n    if n.even?\n      x = x * x % M\n      n >>= 1\n    else\n      ret = ret * x % M\n      n -= 1\n    end\n  end\n  ret\nend\n\n@f = [1, 1]\n(2 .. N).each{|i| @f[i] = @f[i - 1] * i % M}\n@rf = []; @rf[N] = mpow(@f[N], M - 2)\n(N - 1).downto(0){|i| @rf[i] = @rf[i + 1] * (i + 1) % M}\n@fn = @f[N]\nbnom = ->(k){@fn * @rf[N - k] * @rf[k] % M}\nx, t = 0, 1\nN.downto(N/2 + 1) do |k|\n  x = (x + bnom[k]*t) % M\n  t = 2*t % M\nend\nputs mpow(3, N) - (2*x) % M"
  },
  {
    "language": "OCaml",
    "code": "Scanf.scanf \"%d\" (fun n ->\n    let extgcd x y =\n        let rec eg r0 r1 a0 a1 b0 b1 =\n            if r1 = 0 then a0 else\n                let q1 = r0 / r1 in\n                eg r1 (r0 mod r1) a1 (a0 - q1 * a1) b1 (b0 - q1 * b1)\n        in\n        eg x y 1 0 0 1\n    in\n    let inv x y = (* 1/x in mod y *)\n        let c = extgcd x y in\n        if c < 0 then c + y else c\n    in\n    let z = 998244353 in\n    let ( +@) a b = (a + b) mod z in\n    let ( -@) a b = (((a - b) mod z) + z) mod z in\n    let ( *@) a b = (a * b) mod z in\n    let ( /@) a b = a *@ inv b z in\n\n    let modpow a b =\n        let rec loop r i acc =\n            if i = 0 then acc else loop (r *@ r) (i lsr 1) (if i land 1 = 1 then r *@ acc else acc)\n        in\n        loop a b 1\n    in\n\n    let rec loop a b cur acc =\n        let acc = acc +@ cur in\n        if b * 2 = n then acc else\n            loop (a - 1) (b + 1) (cur *@ 2 *@ a /@ b) acc\n    in\n    let ans = loop n 1 2 0 in\n    Printf.printf \"%d\\n\" @@ modpow 3 n -@ ans\n)"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\nenum LIM = 10^^7 + 10;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      const N = readInt();\n      \n      debug {\n        bool checkDP(string s) {\n          auto dp = new bool[][](N + 1, N + 1);\n          foreach (i; 0 .. N + 1) {\n            dp[i][i] = true;\n          }\n          foreach (w; 1 .. N + 1) {\n            foreach (i; 0 .. N - w + 1) {\n              const j = i + w;\n              if (!((s[i] == 'A' && s[j - 1] == 'B') || (s[i] == 'B' && s[j - 1] == 'A'))) {\n                if (dp[i + 1][j - 1]) {\n                  dp[i][j] = true;\n                }\n              }\n              foreach (k; i + 1 .. j) {\n                if (dp[i][k] && dp[k][j]) {\n                  dp[i][j] = true;\n                }\n              }\n            }\n          }\n          return dp[0][N];\n        }\n        bool checkGreedy(string s) {\n          int a, b, c;\n          foreach (i; 0 .. N) {\n            switch (s[i]) {\n              case 'A': (i % 2 == 0) ? ++a : ++b; break;\n              case 'B': (i % 2 == 0) ? ++b : ++a; break;\n              case 'C': ++c; break;\n              default: assert(false);\n            }\n          }\n          return (a <= N / 2 && b <= N / 2);\n        }\n        \n        if (N <= 10) {\n          int cnt;\n          auto cnts = new int[N + 1];\n          foreach (p; 0 .. 3^^N) {\n            string s;\n            foreach (i; 0 .. N) {\n              s ~= \"ABC\"[p / 3^^i % 3];\n            }\n            const resDP = checkDP(s);\n            const resGreedy = checkGreedy(s);\n            if (resDP) {\n              ++cnt;\n              ++cnts[s.count('C')];\n            }\n            if (resDP != resGreedy) {\n              writeln(s, \": \", resDP, \" \", resGreedy);\n              assert(false);\n            }\n          }\n          writeln(\"cnt = \", cnt, \", cnts = \", cnts);\n        }\n      }\n      \n      Mint ans = Mint(3)^^N;\n      foreach (a; N / 2 + 1 .. N + 1) {\n        ans -= 2 * binom(N, a) * Mint(2)^^(N - a);\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\nenum LIM = 10^^7 + 10;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      const N = readInt();\n      \n      debug {\n        bool checkDP(string s) {\n          auto dp = new bool[][](N + 1, N + 1);\n          foreach (i; 0 .. N + 1) {\n            dp[i][i] = true;\n          }\n          foreach (w; 1 .. N + 1) {\n            foreach (i; 0 .. N - w + 1) {\n              const j = i + w;\n              if (!((s[i] == 'A' && s[j - 1] == 'B') || (s[i] == 'B' && s[j - 1] == 'A'))) {\n                if (dp[i + 1][j - 1]) {\n                  dp[i][j] = true;\n                }\n              }\n              foreach (k; i + 1 .. j) {\n                if (dp[i][k] && dp[k][j]) {\n                  dp[i][j] = true;\n                }\n              }\n            }\n          }\n          return dp[0][N];\n        }\n        bool checkGreedy(string s) {\n          int a, b, c;\n          foreach (i; 0 .. N) {\n            switch (s[i]) {\n              case 'A': (i % 2 == 0) ? ++a : ++b; break;\n              case 'B': (i % 2 == 0) ? ++b : ++a; break;\n              case 'C': ++c; break;\n              default: assert(false);\n            }\n          }\n          return (a <= N / 2 && b <= N / 2);\n        }\n        \n        if (N <= 10) {\n          int cnt;\n          auto cnts = new int[N + 1];\n          foreach (p; 0 .. 3^^N) {\n            string s;\n            foreach (i; 0 .. N) {\n              s ~= \"ABC\"[p / 3^^i % 3];\n            }\n            const resDP = checkDP(s);\n            const resGreedy = checkGreedy(s);\n            if (resDP) {\n              ++cnt;\n              ++cnts[s.count('C')];\n            }\n            if (resDP != resGreedy) {\n              writeln(s, \": \", resDP, \" \", resGreedy);\n              assert(false);\n            }\n          }\n          writeln(\"cnt = \", cnt, \", cnts = \", cnts);\n        }\n      }\n      \n      Mint ans = Mint(3)^^N;\n      foreach (a; N / 2 + 1 .. N + 1) {\n        ans -= 2 * binom(N, a) * Mint(2)^^(N - a);\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\nenum LIM = 10^^7 + 10;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      const N = readInt();\n      \n      debug {\n        bool checkDP(string s) {\n          auto dp = new bool[][](N + 1, N + 1);\n          foreach (i; 0 .. N + 1) {\n            dp[i][i] = true;\n          }\n          foreach (w; 1 .. N + 1) {\n            foreach (i; 0 .. N - w + 1) {\n              const j = i + w;\n              if (!((s[i] == 'A' && s[j - 1] == 'B') || (s[i] == 'B' && s[j - 1] == 'A'))) {\n                if (dp[i + 1][j - 1]) {\n                  dp[i][j] = true;\n                }\n              }\n              foreach (k; i + 1 .. j) {\n                if (dp[i][k] && dp[k][j]) {\n                  dp[i][j] = true;\n                }\n              }\n            }\n          }\n          return dp[0][N];\n        }\n        bool checkGreedy(string s) {\n          int a, b, c;\n          foreach (i; 0 .. N) {\n            switch (s[i]) {\n              case 'A': (i % 2 == 0) ? ++a : ++b; break;\n              case 'B': (i % 2 == 0) ? ++b : ++a; break;\n              case 'C': ++c; break;\n              default: assert(false);\n            }\n          }\n          return (a <= N / 2 && b <= N / 2);\n        }\n        \n        if (N <= 10) {\n          int cnt;\n          auto cnts = new int[N + 1];\n          foreach (p; 0 .. 3^^N) {\n            string s;\n            foreach (i; 0 .. N) {\n              s ~= \"ABC\"[p / 3^^i % 3];\n            }\n            const resDP = checkDP(s);\n            const resGreedy = checkGreedy(s);\n            if (resDP) {\n              ++cnt;\n              ++cnts[s.count('C')];\n            }\n            if (resDP != resGreedy) {\n              writeln(s, \": \", resDP, \" \", resGreedy);\n              assert(false);\n            }\n          }\n          writeln(\"cnt = \", cnt, \", cnts = \", cnts);\n        }\n      }\n      \n      Mint ans = Mint(3)^^N;\n      foreach (a; N / 2 + 1 .. N + 1) {\n        ans -= 2 * binom(N, a) * Mint(2)^^(N - a);\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Nim",
    "code": "{.push hints:off.}\nimport algorithm, hashes, macros, math, sequtils, sets, strutils, tables, times, unicode, queues\nwhen NimMinor <= 17: import future else: import sugar\n\nmacro unpack(rhs: seq, cnt: static[int]): auto =\n  let t = genSym(); result = quote do:(let `t` = `rhs`;())\n  when NimMinor <= 17:\n    for i in 0..<cnt: result[0][1].add(quote do:`t`[`i`])\n  else:\n    for i in 0..<cnt: result[1].add(quote do:`t`[`i`])\n \ntemplate input(T: typedesc, cnt: Natural = 1): untyped =\n  let line = stdin.readLine.split(\" \")\n  when T is int:         line.map(parseInt).unpack(cnt)\n  elif T is float:       line.map(parseFloat).unpack(cnt)\n  elif T is string:      line.unpack(cnt)\n  elif T is char:        line.mapIt(it[0]).unpack(cnt)\n  elif T is seq[int]:    line.map(parseInt)\n  elif T is seq[float]:  line.map(parseFloat)\n  elif T is seq[string]: line\n  elif T is seq[char]:   line.mapIt(it[0])\n\nproc floorMod*[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if (result > 0 and y < 0) or (result < 0 and y > 0): result += y\n\nproc `%`(n,m:int):int = floorMod(n,m)\nproc `%=`(n: var int, m: int)  = n = floorMod(n,m)\nproc `//=`(n: var int, m: int) = n = n div m\nproc `<<=`(n: var int, m: int) = n = n shl m\nproc `>>=`(n: var int, m: int) = n = n shr m\nproc `:<=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n > m\n  if result:\n    n = m\nproc `:>=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n < m\n  if result:\n    n = m\nproc newSeq2[T](n1, n2: Natural): seq[seq[T]] = newSeqWith(n1, newSeq[T](n2))\nproc newSeq3[T](n1, n2, n3: Natural): seq[seq[seq[T]]] = newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\nproc spacingStr(things: varargs[string,`$`]):string =\n  result = \"\"\n  for thing in things:\n    result &= thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStr(thing)\nproc spacingStrPlusOne(things: varargs[int]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStrPlusOne(thing)\nproc spacingEcho(things: varargs[string,`$`]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[T]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[seq[T]]) = stdout.write(spacingStr(things))\nproc spacingEchoPlusOne(things: varargs[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[seq[int]]) = stdout.write(spacingStrPlusOne(things))\ntemplate myDump*(things: varargs[string,`$`]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[T]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[seq[T]]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...v\\n\"\n    stdout.write(lineName & sr)\niterator items(n:int):int = \n  for i in 0..<n:\n    yield i\n{.pop.}\n\n# -------------------------------------------------- #\n\n# ModInt : Z/1000000007Z\n# Remember as an int in 0..<1000000007\n# However $ModInt(-3)==\"-3\". So if arg may be negative, use $newModInt(-3)==1000000004\n# tested in ARC 190330\n\nconst MOD = int(998244353)\ntype ModInt* = distinct int\n\nproc newModInt(x:int): ModInt = ModInt(floorMod(x, MOD))\nproc `-`(x: ModInt): ModInt = ModInt(floorMod(-int(x), MOD))\n\nproc `+`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)+int(y), MOD))\nproc `+`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)+y, MOD))\nproc `+`(x:int, y:ModInt): ModInt = ModInt(floorMod(x+int(y), MOD))\nproc `+=`(x: var ModInt, y: ModInt or int)  = x = x + y\nproc `-`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)-int(y), MOD))\nproc `-`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)-y, MOD))\nproc `-`(x:int, y:ModInt): ModInt = ModInt(floorMod(x-int(y), MOD))\nproc `-=`(x: var ModInt, y: ModInt or int)  = x = x - y\n\nproc `==`(x:ModInt, y:ModInt): bool = ((int(x)-int(y)) mod MOD == 0)\nproc `==`(x:ModInt, y:int): bool = ((int(x)-y) mod MOD == 0)\nproc `==`(x:int, y:ModInt): bool = ((x-int(y)) mod MOD == 0)\nproc `!=`(x:ModInt, y:ModInt): bool = not(x==y)\nproc `!=`(x:ModInt, y:int): bool = not(x==y)\nproc `!=`(x:int, y:ModInt): bool = not(x==y)\n\nproc `*`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)*int(y), MOD))\nproc `*`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)*y, MOD))\nproc `*`(x:int, y:ModInt): ModInt = ModInt(floorMod(x*int(y), MOD))\nproc `*=`(x: var ModInt, y: ModInt or int)  = x = x * y\n\nproc `^`(x:ModInt, y:int): ModInt =\n  if x==ModInt(0):\n    if y==0:\n      return ModInt(1)\n    else:\n      return ModInt(0)\n  var x = x\n  var y = floorMod(y, MOD-1) #x^(MOD-1)==1\n  result = ModInt(1)\n  while y>0:\n    if (y and 1) != 0:\n      result *= x\n    y = y shr 1\n    x *= x\nproc inv(x:ModInt): ModInt = x^(-1)\nproc inv(x:int): ModInt = ModInt(x)^(-1)\n\nproc `/`(x:ModInt, y:ModInt):ModInt = x * inv(y)\nproc `/`(x:ModInt, y:int):ModInt = x * inv(ModInt(y))\nproc `/`(x:int, y:ModInt):ModInt = ModInt(x) * inv(y)\nproc `/=`(x: var ModInt, y: ModInt or int)  = x = x / y\nproc `$`(x:ModInt):string = $int(x)\n\nconst FACTMAX = 10_000_002\nvar factOf = newSeq[ModInt](FACTMAX+1)\nvar invFactOf = newSeq[ModInt](FACTMAX+1)\nfactOf[0] = ModInt(1)\ninvFactOf[0] = ModInt(1)\nfor i in 1..FACTMAX:\n  factOf[i] = factOf[i-1]*i\n  invFactOf[i] = invFactOf[i-1]/i\n\nproc perm(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k]\nproc comb(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k] * invFactOf[k]\n\nproc longComb(a:int):ModInt = factOf[a] * invFactOf[a]\nproc longComb(a,b:int):ModInt = factOf[a+b] * invFactOf[a] * invFactOf[b]\nproc longComb(a,b,c:int):ModInt = factOf[a+b+c] * invFactOf[a] * invFactOf[b] * invFactOf[c]\nproc longComb(xs:seq[int]):ModInt =\n  result = factOf[xs.sum()]\n  for x in xs:\n    result *= invFactOf[x]\n\n# -------------------------------------------------- #\n\n\n\nlet N = input(int)\nvar result = ModInt(3)^N\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(3)^(N-k)\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(3)^(N-k)\necho result"
  },
  {
    "language": "Nim",
    "code": "{.push hints:off.}\nimport algorithm, hashes, macros, math, sequtils, sets, strutils, tables, times, unicode, queues\nwhen NimMinor <= 17: import future else: import sugar\n\nmacro unpack(rhs: seq, cnt: static[int]): auto =\n  let t = genSym(); result = quote do:(let `t` = `rhs`;())\n  when NimMinor <= 17:\n    for i in 0..<cnt: result[0][1].add(quote do:`t`[`i`])\n  else:\n    for i in 0..<cnt: result[1].add(quote do:`t`[`i`])\n \ntemplate input(T: typedesc, cnt: Natural = 1): untyped =\n  let line = stdin.readLine.split(\" \")\n  when T is int:         line.map(parseInt).unpack(cnt)\n  elif T is float:       line.map(parseFloat).unpack(cnt)\n  elif T is string:      line.unpack(cnt)\n  elif T is char:        line.mapIt(it[0]).unpack(cnt)\n  elif T is seq[int]:    line.map(parseInt)\n  elif T is seq[float]:  line.map(parseFloat)\n  elif T is seq[string]: line\n  elif T is seq[char]:   line.mapIt(it[0])\n\nproc floorMod*[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if (result > 0 and y < 0) or (result < 0 and y > 0): result += y\n\nproc `%`(n,m:int):int = floorMod(n,m)\nproc `%=`(n: var int, m: int)  = n = floorMod(n,m)\nproc `//=`(n: var int, m: int) = n = n div m\nproc `<<=`(n: var int, m: int) = n = n shl m\nproc `>>=`(n: var int, m: int) = n = n shr m\nproc `:<=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n > m\n  if result:\n    n = m\nproc `:>=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n < m\n  if result:\n    n = m\nproc newSeq2[T](n1, n2: Natural): seq[seq[T]] = newSeqWith(n1, newSeq[T](n2))\nproc newSeq3[T](n1, n2, n3: Natural): seq[seq[seq[T]]] = newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\nproc spacingStr(things: varargs[string,`$`]):string =\n  result = \"\"\n  for thing in things:\n    result &= thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStr(thing)\nproc spacingStrPlusOne(things: varargs[int]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStrPlusOne(thing)\nproc spacingEcho(things: varargs[string,`$`]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[T]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[seq[T]]) = stdout.write(spacingStr(things))\nproc spacingEchoPlusOne(things: varargs[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[seq[int]]) = stdout.write(spacingStrPlusOne(things))\ntemplate myDump*(things: varargs[string,`$`]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[T]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[seq[T]]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...v\\n\"\n    stdout.write(lineName & sr)\niterator items(n:int):int = \n  for i in 0..<n:\n    yield i\n{.pop.}\n\n# -------------------------------------------------- #\n\n# ModInt : Z/1000000007Z\n# Remember as an int in 0..<1000000007\n# However $ModInt(-3)==\"-3\". So if arg may be negative, use $newModInt(-3)==1000000004\n# tested in ARC 190330\n\nconst MOD = int(998244353)\ntype ModInt* = distinct int\n\nproc newModInt(x:int): ModInt = ModInt(floorMod(x, MOD))\nproc `-`(x: ModInt): ModInt = ModInt(floorMod(-int(x), MOD))\n\nproc `+`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)+int(y), MOD))\nproc `+`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)+y, MOD))\nproc `+`(x:int, y:ModInt): ModInt = ModInt(floorMod(x+int(y), MOD))\nproc `+=`(x: var ModInt, y: ModInt or int)  = x = x + y\nproc `-`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)-int(y), MOD))\nproc `-`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)-y, MOD))\nproc `-`(x:int, y:ModInt): ModInt = ModInt(floorMod(x-int(y), MOD))\nproc `-=`(x: var ModInt, y: ModInt or int)  = x = x - y\n\nproc `==`(x:ModInt, y:ModInt): bool = ((int(x)-int(y)) mod MOD == 0)\nproc `==`(x:ModInt, y:int): bool = ((int(x)-y) mod MOD == 0)\nproc `==`(x:int, y:ModInt): bool = ((x-int(y)) mod MOD == 0)\nproc `!=`(x:ModInt, y:ModInt): bool = not(x==y)\nproc `!=`(x:ModInt, y:int): bool = not(x==y)\nproc `!=`(x:int, y:ModInt): bool = not(x==y)\n\nproc `*`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)*int(y), MOD))\nproc `*`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)*y, MOD))\nproc `*`(x:int, y:ModInt): ModInt = ModInt(floorMod(x*int(y), MOD))\nproc `*=`(x: var ModInt, y: ModInt or int)  = x = x * y\n\nproc `^`(x:ModInt, y:int): ModInt =\n  if x==ModInt(0):\n    if y==0:\n      return ModInt(1)\n    else:\n      return ModInt(0)\n  var x = x\n  var y = floorMod(y, MOD-1) #x^(MOD-1)==1\n  result = ModInt(1)\n  while y>0:\n    if (y and 1) != 0:\n      result *= x\n    y = y shr 1\n    x *= x\nproc inv(x:ModInt): ModInt = x^(-1)\nproc inv(x:int): ModInt = ModInt(x)^(-1)\n\nproc `/`(x:ModInt, y:ModInt):ModInt = x * inv(y)\nproc `/`(x:ModInt, y:int):ModInt = x * inv(ModInt(y))\nproc `/`(x:int, y:ModInt):ModInt = ModInt(x) * inv(y)\nproc `/=`(x: var ModInt, y: ModInt or int)  = x = x / y\nproc `$`(x:ModInt):string = $int(x)\n\nconst FACTMAX = 10_000_002\nvar factOf = newSeq[ModInt](FACTMAX+1)\nfactOf[0] = ModInt(1)\nfor i in 1..FACTMAX:\n  factOf[i] = factOf[i-1]*i\nvar invFactOf = newSeq[ModInt](FACTMAX+1)\ninvFactOf[FACTMAX] = factOf[FACTMAX].inv()\nfor i in countdown(FACTMAX,1):\n  invFactOf[i-1] = invFactOf[i]*i\n\nproc perm(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k]\nproc comb(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k] * invFactOf[k]\n\nproc longComb(a:int):ModInt = factOf[a] * invFactOf[a]\nproc longComb(a,b:int):ModInt = factOf[a+b] * invFactOf[a] * invFactOf[b]\nproc longComb(a,b,c:int):ModInt = factOf[a+b+c] * invFactOf[a] * invFactOf[b] * invFactOf[c]\nproc longComb(xs:seq[int]):ModInt =\n  result = factOf[xs.sum()]\n  for x in xs:\n    result *= invFactOf[x]\n\n# -------------------------------------------------- #\n\n\n\nlet N = input(int)\nvar result = ModInt(3)^N\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(2)^(N-k)\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(2)^(N-k)\necho result"
  },
  {
    "language": "Nim",
    "code": "{.push hints:off.}\nimport algorithm, hashes, macros, math, sequtils, sets, strutils, tables, times, unicode, queues\nwhen NimMinor <= 17: import future else: import sugar\n\nmacro unpack(rhs: seq, cnt: static[int]): auto =\n  let t = genSym(); result = quote do:(let `t` = `rhs`;())\n  when NimMinor <= 17:\n    for i in 0..<cnt: result[0][1].add(quote do:`t`[`i`])\n  else:\n    for i in 0..<cnt: result[1].add(quote do:`t`[`i`])\n \ntemplate input(T: typedesc, cnt: Natural = 1): untyped =\n  let line = stdin.readLine.split(\" \")\n  when T is int:         line.map(parseInt).unpack(cnt)\n  elif T is float:       line.map(parseFloat).unpack(cnt)\n  elif T is string:      line.unpack(cnt)\n  elif T is char:        line.mapIt(it[0]).unpack(cnt)\n  elif T is seq[int]:    line.map(parseInt)\n  elif T is seq[float]:  line.map(parseFloat)\n  elif T is seq[string]: line\n  elif T is seq[char]:   line.mapIt(it[0])\n\nproc floorMod*[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if (result > 0 and y < 0) or (result < 0 and y > 0): result += y\n\nproc `%`(n,m:int):int = floorMod(n,m)\nproc `%=`(n: var int, m: int)  = n = floorMod(n,m)\nproc `//=`(n: var int, m: int) = n = n div m\nproc `<<=`(n: var int, m: int) = n = n shl m\nproc `>>=`(n: var int, m: int) = n = n shr m\nproc `:<=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n > m\n  if result:\n    n = m\nproc `:>=`[T](n: var T, m: T):bool {.discardable.}=\n  result = n < m\n  if result:\n    n = m\nproc newSeq2[T](n1, n2: Natural): seq[seq[T]] = newSeqWith(n1, newSeq[T](n2))\nproc newSeq3[T](n1, n2, n3: Natural): seq[seq[seq[T]]] = newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\nproc spacingStr(things: varargs[string,`$`]):string =\n  result = \"\"\n  for thing in things:\n    result &= thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $thing\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStr[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStr(thing)\nproc spacingStrPlusOne(things: varargs[int]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[T]):string =\n  result = \"\"\n  for thing in things:\n    result &= $(thing+1)\n    result &= \" \"\n  result &= \"\\n\"\nproc spacingStrPlusOne[T](things: seq[seq[T]]):string =\n  result = \"\"\n  for thing in things:\n    result &= spacingStrPlusOne(thing)\nproc spacingEcho(things: varargs[string,`$`]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[T]) = stdout.write(spacingStr(things))\nproc spacingEcho[T](things: seq[seq[T]]) = stdout.write(spacingStr(things))\nproc spacingEchoPlusOne(things: varargs[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[int]) = stdout.write(spacingStrPlusOne(things))\nproc spacingEchoPlusOne(things: seq[seq[int]]) = stdout.write(spacingStrPlusOne(things))\ntemplate myDump*(things: varargs[string,`$`]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[T]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...>  \"\n    stdout.write(lineName & sr)\ntemplate myDump*[T](things: seq[seq[T]]) =\n  when NimMinor >= 17:\n    let sr = spacingStr(things)\n    let line = instantiationInfo().line\n    let lineName = \"LINE\" & '0'.repeat(4-($line).len) & ($line) & \"...v\\n\"\n    stdout.write(lineName & sr)\niterator items(n:int):int = \n  for i in 0..<n:\n    yield i\n{.pop.}\n\n# -------------------------------------------------- #\n\n# ModInt : Z/1000000007Z\n# Remember as an int in 0..<1000000007\n# However $ModInt(-3)==\"-3\". So if arg may be negative, use $newModInt(-3)==1000000004\n# tested in ARC 190330\n\nconst MOD = int(998244353)\ntype ModInt* = distinct int\n\nproc newModInt(x:int): ModInt = ModInt(floorMod(x, MOD))\nproc `-`(x: ModInt): ModInt = ModInt(floorMod(-int(x), MOD))\n\nproc `+`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)+int(y), MOD))\nproc `+`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)+y, MOD))\nproc `+`(x:int, y:ModInt): ModInt = ModInt(floorMod(x+int(y), MOD))\nproc `+=`(x: var ModInt, y: ModInt or int)  = x = x + y\nproc `-`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)-int(y), MOD))\nproc `-`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)-y, MOD))\nproc `-`(x:int, y:ModInt): ModInt = ModInt(floorMod(x-int(y), MOD))\nproc `-=`(x: var ModInt, y: ModInt or int)  = x = x - y\n\nproc `==`(x:ModInt, y:ModInt): bool = ((int(x)-int(y)) mod MOD == 0)\nproc `==`(x:ModInt, y:int): bool = ((int(x)-y) mod MOD == 0)\nproc `==`(x:int, y:ModInt): bool = ((x-int(y)) mod MOD == 0)\nproc `!=`(x:ModInt, y:ModInt): bool = not(x==y)\nproc `!=`(x:ModInt, y:int): bool = not(x==y)\nproc `!=`(x:int, y:ModInt): bool = not(x==y)\n\nproc `*`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)*int(y), MOD))\nproc `*`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)*y, MOD))\nproc `*`(x:int, y:ModInt): ModInt = ModInt(floorMod(x*int(y), MOD))\nproc `*=`(x: var ModInt, y: ModInt or int)  = x = x * y\n\nproc `^`(x:ModInt, y:int): ModInt =\n  if x==ModInt(0):\n    if y==0:\n      return ModInt(1)\n    else:\n      return ModInt(0)\n  var x = x\n  var y = floorMod(y, MOD-1) #x^(MOD-1)==1\n  result = ModInt(1)\n  while y>0:\n    if (y and 1) != 0:\n      result *= x\n    y = y shr 1\n    x *= x\nproc inv(x:ModInt): ModInt = x^(-1)\nproc inv(x:int): ModInt = ModInt(x)^(-1)\n\nproc `/`(x:ModInt, y:ModInt):ModInt = x * inv(y)\nproc `/`(x:ModInt, y:int):ModInt = x * inv(ModInt(y))\nproc `/`(x:int, y:ModInt):ModInt = ModInt(x) * inv(y)\nproc `/=`(x: var ModInt, y: ModInt or int)  = x = x / y\nproc `$`(x:ModInt):string = $int(x)\n\nconst FACTMAX = 10_000_002\nvar factOf = newSeq[ModInt](FACTMAX+1)\nvar invFactOf = newSeq[ModInt](FACTMAX+1)\nfactOf[0] = ModInt(1)\ninvFactOf[0] = ModInt(1)\nfor i in 1..FACTMAX:\n  factOf[i] = factOf[i-1]*i\n  invFactOf[i] = invFactOf[i-1]/i\n\nproc perm(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k]\nproc comb(n:int, k:int):ModInt = factOf[n] * invFactOf[n-k] * invFactOf[k]\n\nproc longComb(a:int):ModInt = factOf[a] * invFactOf[a]\nproc longComb(a,b:int):ModInt = factOf[a+b] * invFactOf[a] * invFactOf[b]\nproc longComb(a,b,c:int):ModInt = factOf[a+b+c] * invFactOf[a] * invFactOf[b] * invFactOf[c]\nproc longComb(xs:seq[int]):ModInt =\n  result = factOf[xs.sum()]\n  for x in xs:\n    result *= invFactOf[x]\n\n# -------------------------------------------------- #\n\n\n\nlet N = input(int)\nvar result = ModInt(3)^N\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(2)^(N-k)\nfor k in ((N div 2)+1)..N:\n  result -= comb(N,k) * ModInt(2)^(N-k)\necho result"
  },
  {
    "language": "Python",
    "code": "\nn=int(input())\npre=[1]*(n//2+200)\npp=[1]*(n+1)\nmod=998244353\nfor i in range(1,n//2+100):\n    pre[i]=((pre[i-1]*2)%mod)\n    \np=[1]*(n+1)\nfor i in range(n):\n    p[i+1]=((p[i]*(i+1))%mod)\n    pp[i+1]=pow(p[i+1],mod-2,mod)\ntot=1\nfor i in range(n):\n    tot*=3\n    tot%=mod\n#print(1)\n#print(tot)\ncc=0\nfor i in range(n//2+1,n+1):\n    c=(((((p[n]*pp[i])%mod)*pp[n-i])%mod)*pre[n-i])%mod\n    c%=mod\n    cc+=c\ntot-=cc\ntot-=cc\ntot%=mod\nprint(tot)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):\n l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):\n a+=b*c%p;b+=b%p;c=c*i*l[n+1-i]%p\nprint(pow(3,n,p)-2*a%p)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nmod=998244353\n\nans=pow(3,n,mod)\nrmv=0\nf = [1, 1]  \ninv = [1, 1]  \nfinv=[1,1]\nfor i in range(2, n+1):\n    f.append((f[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    finv.append(finv[-1]*inv[-1]%mod)\n\nk=n//2\nif k*2<=n:\n    k+=1\ntmp=pow(2,n-k+1,mod)\ninv2=pow(2,mod-2,mod)\nfor i in range(k,n+1):\n    ans -= f[n]*finv[n-i]*finv[i]*tmp\n    tmp*=inv2\n    tmp%=mod\nprint(ans%mod)\n    \n\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom functools import lru_cache\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN = int(sys.stdin.readline())\n\n\n@lru_cache(maxsize=None)\n# @debug\ndef is_ok(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 2:\n        return s not in ['AB', 'BA']\n    for i in range(len(s) - 2):\n        if s[i:i + 2] not in ['AB', 'BA'] and is_ok(s[:i] + s[i + 2:]):\n            return True\n    return False\n\n\ndef test(N):\n    ret = 0\n    for s in itertools.product('ABC', repeat=N):\n        s = ''.join(s)\n        ret += is_ok(s)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\n# print(test(N))\n# N = 10 ** 7\n\n# 解説AC\n# 偶数番目のAとBを反転して、AAとBB以外を取り除く\n# AまたはBが半分より多いときダメなので全体から引く\nans = pow(3, N, MOD)\n\ninvs = mod_invs(max=N, mod=MOD)\nncr = 1  # NCr\np2r = 1  # pow(2, N - r, MOD)\nfor r in range(N, N // 2, -1):\n    # ans -= comb.ncr(N, r) * pow(2, N - r, MOD) * 2 % MOD\n    ans -= ncr * p2r * 2 % MOD\n    ans %= MOD\n    ncr *= r * invs[N - r + 1]\n    ncr %= MOD\n    p2r *= 2\n    p2r %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\nCombi=1\nfor i in range(1,N//2+1):\n    Combi=Combi*(N-i+1)*pow(i,mod-2,mod)%mod\nSC=0\nfor i in range(N//2+1,N+1):\n    Combi=Combi*(N-i+1)*pow(i,mod-2,mod)%mod\n    SC=(SC+Combi*pow(2,N-i,mod))%mod  \nprint((pow(3,N,mod)-SC*2)%mod)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    for k in range(n // 2):\n        r += mck * pow(2, k, LARGE)\n        r %= LARGE\n        mck *= n - k\n        mck *= pow(k + 1, LARGE - 2, LARGE)\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):l+=[l[p%i]*(p-p//i)%p]\nfor i in range(n,n//2,-1):a+=b*c%p;b+=b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    factorial_n = 1\n    factorial_inv = [0] * (n + 1)\n    factorial_inv[0] = 1\n    for i in range(1, n + 1):\n        factorial_n *= i\n        factorial_n %= LARGE\n    factorial_inv[-1] = pow(factorial_n, LARGE - 2, LARGE)\n    for i in range(n):\n        factorial_inv[n - i - 1] = (factorial_inv[n - i] * (n - i)) % LARGE\n    pow_2 = 1\n    for k in range(n // 2):\n        r += factorial_n * factorial_inv[n - k] * factorial_inv[k] * pow_2\n        r %= LARGE\n        pow_2 *= 2\n        pow_2 %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 998244353\n\nlist_size = 10000010\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\n\ndef comb(n,r):\n    if r == 0:\n        return 1\n    return (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nans = 0\nfor i in range((N//2)):\n    ans += comb(N,i) * pow(2,i,MOD)\n    ans %= MOD\n\nprint((pow(3,N,MOD)-ans*2)%MOD)\n"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    f = 1\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n    fn = f\n\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return fn, invs\n\n\nn = int(input())\nMOD = 998244353\nfn, invs = prepare(n, MOD)\nans = pow(3, n, MOD)\nimpossible = 0\nmul = 2\nfor i in range(n // 2):\n    tmp = fn * invs[i] * invs[n - i] % MOD * mul\n    impossible = (impossible + tmp) % MOD\n    mul = mul * 2 % MOD\nprint((ans - impossible) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    factorial_n = 1\n    factorial_inv = [0] * (n + 1)\n    factorial_inv[0] = 1\n    for i in range(1, n + 1):\n        factorial_n *= i\n        factorial_n %= LARGE\n    factorial_inv[-1] = pow(factorial_n, LARGE - 2, LARGE)\n    for i in range(n):\n        factorial_inv[n - i - 1] = (factorial_inv[n - i] * (n - i)) % LARGE\n    pow_2 = 1\n    for k in range(n // 2):\n        r += factorial_n * factorial_inv[n - k] * factorial_inv[k] * pow_2\n        r %= LARGE\n        pow_2 *= 2\n        pow_2 %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "\nn=int(input())\npre=[1]*(n//2+200)\npp=[1]*(n+1)\nmod=998244353\nfor i in range(1,n//2+100):\n    pre[i]=((pre[i-1]*2)%mod)\n    \np=[1]*(n+1)\nfor i in range(n):\n    p[i+1]=((p[i]*(i+1))%mod)\npp[-1] = pow(p[-1], mod - 2, mod)\n \nfor i in range(2, n + 1):\n\tpp[-i] = int((pp[-i + 1] * (n + 2 - i)) % mod)\ntot=1\nfor i in range(n):\n    tot*=3\n    tot%=mod\n#print(1)\n#print(tot)\ncc=0\nfor i in range(n//2+1,n+1):\n    c=(((((p[n]*pp[i])%mod)*pp[n-i])%mod)*pre[n-i])%mod\n    c%=mod\n    cc+=c\ntot-=cc\ntot-=cc\ntot%=mod\nprint(tot)\n"
  },
  {
    "language": "Python",
    "code": "def cmb(n,r,mod):\n  if r<0 or r>n:\n    return 0\n  r=min(r,n-r)\n  return g1[n]*g2[r]*g2[n-r]%mod\n \nn=int(input())\nmod=998244353\n\ng1=[1,1]\ng2=[1,1]\ninverse=[0,1]\n \nfor i in range(2,n+1):\n  g1.append((g1[-1]*i)%mod)\n  inverse.append((-inverse[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inverse[-1])%mod)\n\na=0\nb=1\nfor i in range(n,n//2,-1):\n  a+=cmb(n,i,mod)*b\n  a%=mod\n  b*=2\n  b%=mod\nans=(pow(3,n,mod)-2*a)%mod\nprint((ans+mod)%mod)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 998244353\n\nN = int(read())\n\nimport numpy as np\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**7 + 10\nfact, fact_inv = make_fact(U,MOD)\n\nx = np.full(U,2,dtype=np.int64); x[0] = 1\npow2 = cumprod(x,MOD)\n\nn = N//2\ncomb = fact_inv[:n] * fact_inv[N:N-n:-1] % MOD * fact[N] % MOD\n\nx = (comb * pow2[:n] % MOD).sum()\nanswer = pow(3,N,MOD) - x - x\nanswer %= MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**7 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * (i) % MOD\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \ndef single_mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    if r > n - r:\n        r = n - r\n    ret = 1\n    for i in range(r):\n        ret *= n - i\n        ret *= pow(i+1, MOD-2, MOD)\n        ret %= MOD\n    return ret\n\nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * pow(2, n - i, MOD)\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):\n l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):\n a+=b*c%p;b+=b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 998244353\n\nN = int(read())\n\nimport numpy as np\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**7 + 10\nfact, fact_inv = make_fact(U,MOD)\n\nx = np.full(U,2,dtype=np.int64); x[0] = 1\npow2 = cumprod(x,MOD)\n\nn = N//2\ncomb = fact_inv[:n] * fact_inv[N:N-n:-1] % MOD * fact[N] % MOD\n\nx = (comb * pow2[:n] % MOD).sum()\nanswer = pow(3,N,MOD) - x - x\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\n\nFACT=[1]\nfor i in range(1,N+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(N,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n\nSC=0\nfor i in range(N//2+1,N+1):\n    SC+=Combi(N,i)*pow(2,N-i,mod)\n\nprint((pow(3,N,mod)-SC*2)%mod)"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):a+=b*c%p;b+=b%p;c=c*i*l[n+1-i]%p\nprint(pow(3,n,p)-2*a%p)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**7 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * i % MOD\n    mod_pow2_n[i] = mod_pow2_n[i-1] * 2 % MOD\n\nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * mod_pow2_n[n-i]\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    for k in range(n // 2):\n        r += mck * pow(2, k, LARGE)\n        r %= LARGE\n        mck *= n - k\n        mck %= LARGE\n        mck *= pow(k + 1, LARGE - 2, LARGE)\n        mck %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom functools import lru_cache\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN = int(sys.stdin.readline())\n\n\n@lru_cache(maxsize=None)\n# @debug\ndef is_ok(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 2:\n        return s not in ['AB', 'BA']\n    for i in range(len(s) - 2):\n        if s[i:i + 2] not in ['AB', 'BA'] and is_ok(s[:i] + s[i + 2:]):\n            return True\n    return False\n\n\ndef test(N):\n    ret = 0\n    for s in itertools.product('ABC', repeat=N):\n        s = ''.join(s)\n        ret += is_ok(s)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\n# print(test(N))\n# N = 10 ** 7\n\n# 解説AC\n# 偶数番目のAとBを反転して、AAとBB以外を取り除く\n# AまたはBが半分より多いときダメなので全体から引く\nans = pow(3, N, MOD)\n\ninvs = mod_invs(max=N, mod=MOD)\nncr = 1  # NCr\np2r = 1  # pow(2, N - r, MOD)\nfor r in range(N, N // 2, -1):\n    # ans -= comb.ncr(N, r) * pow(2, N - r, MOD) * 2 % MOD\n    ans -= ncr * p2r * 2 % MOD\n    ans %= MOD\n    ncr *= r * invs[N - r + 1]\n    ncr %= MOD\n    p2r *= 2\n    p2r %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\nCombi=1\nSC=0\nfor i in range(N,N//2,-1):\n    SC=(SC+Combi*pow(2,N-i,mod))%mod\n    Combi=Combi*(i)*pow(N-i+1,mod-2,mod)%mod\nprint((pow(3,N,mod)-SC*2)%mod)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 998244353\ndef func(x):\n    a = [23,26]\n    out = 1\n    for i in range(30):\n        if not i in a:\n            out = (out*x)%MOD\n        x *= x\n        x %= MOD\n    return out\n\ndef func2(x):\n    x = bin(x)[2:]\n    out = 1\n    b = 3\n    for i in range(len(x)):\n        if x[-1-i] == \"1\":\n            out *= b\n            out %= MOD\n        b *= b\n        b %= MOD\n    return out\n\nans = 0\nd = 1\nb = 1\nfor i in range((N//2)):\n    ans += d * b\n    b *= 2\n    b %= MOD\n    ans %= MOD\n    d = ((N-i)*d)%MOD\n    d = (d*func(i+1))%MOD\n\nprint((func2(N)-ans*2)%MOD)"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):a+=b*c%p;b+=b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    for k in range(n // 2):\n        r += mck * pow(2, k, LARGE)\n        r %= LARGE\n        mck *= n - k\n        mck %= LARGE\n        mck *= pow(k + 1, LARGE - 2, LARGE)\n        mck %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):l+=[l[p%i]*(p-p//i)%p]\nfor i in range(n,n//2,-1):a+=b*c;b+=b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    for k in range(n // 2):\n        r += mck * pow(2, k, LARGE)\n        r %= LARGE\n        mck *= n - k\n        mck *= pow(k + 1, LARGE - 2, LARGE)\n        mck %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\nlist_size = 10000010\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn = int(input())\nsub = 0\nfor i in range(n//2+1, n+1):\n\tsub += comb(n, i) * pow(2, n-i, MOD)\n\tsub %= MOD\nprint((pow(3, n, MOD) - 2 * sub) % MOD)"
  },
  {
    "language": "Python",
    "code": "def calc(n, mod):\n\tf = 1\n\tfac = [1]\n\tfor i in range(1, n + 1):\n\t\tf *= i\n\t\tf %= mod\n\t\tfac.append(f)\n\tinv = pow(f, mod - 2, mod)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor i in range(n, 1, -1):\n\t\tinv *= i\n\t\tinv %= mod\n\t\tinvs[i - 1] = inv\n\treturn fac, invs\n\ndef cnk(n, r, mod, fac, inv):\n\treturn fac[n] * inv[n - r] * inv[r] % mod\n\n\nn = int(input())\n\nmod = 998244353\n\nf, inv = calc(n + 10, mod)\nans = pow(3, n, mod)\np = [1]\n\nfor i in range(n // 2 + 10):\n\tp.append(p[-1] * 2 % mod)\nfor k in range(n // 2 + 1, n + 1):\n\tcur = 2 * cnk(n, k, mod, f, inv) * p[n - k]\n\tans -= cur\n\tans %= mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    factorial_n = 1\n    factorial_inv = [0] * (n + 1)\n    factorial_inv[0] = 1\n    for i in range(1, n + 1):\n        factorial_n *= i\n        factorial_n %= LARGE\n    factorial_inv[-1] = pow(factorial_n, LARGE - 2, LARGE)\n    for i in range(n):\n        factorial_inv[n - i - 1] = (factorial_inv[n - i] * (n - i)) % LARGE\n    pow_2 = 1\n    for k in range(n // 2):\n        r += factorial_n * factorial_inv[n - k] * factorial_inv[k] * pow_2\n        r %= LARGE\n        pow_2 *= 2\n        pow_2 %= LARGE\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n//2+1):\n l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):\n a+=b*c%p;b=2*b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a+p)%p)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nnn = N + 10\nP = 998244353\n\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a-b] % P if 0 <= b <= a else 0\n\nans = pow(3, N, P)\np2 = 2\nfor i in range(N, N // 2, -1):\n    ans = (ans - C(N, i) * p2) % P\n    p2 = p2 * 2 % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**7 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nf = 1\nfinv = 1\np2 = 1\nfor i in range(1, MAX_N+1):\n    # fac[i] = fac[i-1] * i % MOD\n    f *= i\n    f %= MOD\n    fac[i] = f\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    # fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n    finv *= pow(i, MOD-2, MOD)\n    finv %= MOD\n    fac_inv[i] = finv\n    p2 *= 2\n    p2 %= MOD\n    mod_pow2_n[i] = p2\n\nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += fac[n] * fac_inv[n-i] * fac_inv[i] * mod_pow2_n[n-i] % MOD\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "def main():\n    mod=998244353\n    n=int(input())\n    Fact=[1]\n    for i in range(1,n+1):\n        Fact.append(Fact[i-1]*i%mod)\n    Finv=[0]*(n+1)\n    Finv[-1]=pow(Fact[-1],mod-2,mod)\n    for i in range(n-1,-1,-1):\n        Finv[i]=Finv[i+1]*(i+1)%mod\n    def comb(n,r):\n        if n<r:\n            return 0\n        return Fact[n]*Finv[r]*Finv[n-r]%mod\n    \n    impossible=0\n    for k in range(n//2+1,n+1):\n        impossible+=comb(n,k)*pow(2,n-k,mod)\n        impossible%=mod\n    print(pow(3,n,mod)-impossible*2)\n\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 998244353\n\nlist_size = 10000010\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\n\n\ndef conv(n,r):\n    if r == 0:\n        return 1\n    return (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nans = 0\nfor i in range((N//2)):\n    ans += conv(N,i) * pow(2,i,MOD)\n    ans %= MOD\n\nprint((pow(3,N,MOD)-ans*2)%MOD)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 998244353\ndef func(x):\n    a = [23,26]\n    out = 1\n    for i in range(30):\n        if not i in a:\n            out = (out*x)%MOD\n        x *= x\n        x %= MOD\n    return out\n\ndef func2(x):\n    x = bin(x)[2:]\n    out = 1\n    b = 3\n    for i in range(len(x)):\n        if x[-1-i] == \"1\":\n            out *= b\n            out %= MOD\n        b *= b\n        b %= MOD\n    return out\n\nans = 0\nd = 1\nfor i in range((N//2)):\n    ans += d * 2**i\n    ans %= MOD\n    d = ((N-i)*d)%MOD\n    d = (d*func(i+1))%MOD\n\nprint((func2(N)-ans*2)%MOD)"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\nCombi=[1]\nfor i in range(1,N+1):\n    Combi.append(Combi[-1]*(N-i+1)*pow(i,mod-2,mod)%mod)\nSC=0\nfor i in range(N//2+1,N+1):\n    SC=(SC+Combi[i]*pow(2,N-i,mod))%mod\nprint((pow(3,N,mod)-SC*2)%mod)\n"
  },
  {
    "language": "Python",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvector<int64_t> ncr_arr;\nvoid calc_nCr(int n, int64_t rem) {\n\tncr_arr = vector<int64_t>(n + 1);\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tcalc_nCr(n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = ncr_arr[k];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom functools import lru_cache\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN = int(sys.stdin.readline())\n\n\n@lru_cache(maxsize=None)\n# @debug\ndef is_ok(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 2:\n        return s not in ['AB', 'BA']\n    for i in range(len(s) - 2):\n        if s[i:i + 2] not in ['AB', 'BA'] and is_ok(s[:i] + s[i + 2:]):\n            return True\n    return False\n\n\ndef test(N):\n    ret = 0\n    for s in itertools.product('ABC', repeat=N):\n        s = ''.join(s)\n        ret += is_ok(s)\n    return ret\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\ndef factorial_invs(max, mod):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max! の逆元\n    :param int max:\n    :param int mod:\n    \"\"\"\n    ret = []\n    r = 1\n    for inv in mod_invs(max, mod):\n        r = r * inv % mod\n        ret.append(r)\n    return ret\n\n\nclass Combination:\n    def __init__(self, max, mod):\n        \"\"\"\n        :param int max:\n        :param int mod: 3 以上の素数であること\n        \"\"\"\n        self._factorials = get_factorials(max, mod)\n        self._finvs = factorial_invs(max, mod)\n        self._mod = mod\n\n    def ncr(self, n, r):\n        \"\"\"\n        :param int n:\n        :param int r:\n        :rtype: int\n        \"\"\"\n        if n < r:\n            return 0\n        return self._factorials[n] * self._finvs[r] % self._mod * self._finvs[n - r] % self._mod\n\n\n# print(test(N))\n\n# 解説AC\n# 偶数番目のAとBを反転して、AAとBB以外を取り除く\n# AまたはBが半分より多いときダメなので全体から引く\nans = pow(3, N, MOD)\ncomb = Combination(max=N, mod=MOD)\nfor r in range(N // 2 + 1, N + 1):\n    ans -= comb.ncr(N, r) * pow(2, N - r, MOD) * 2 % MOD\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\n\nFACT=[1]\nfor i in range(1,N+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(N,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\nPOW=[1]\nfor i in range(N):\n    POW.append(POW[-1]*2%mod)\n\ndef Combi(a,b):\n    return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n\nSC=0\nfor i in range(N//2+1,N+1):\n    SC+=Combi(N,i)*POW[N-i]\n\nprint((pow(3,N,mod)-SC*2)%mod)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nnn = N + 10\nP = 998244353\n\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a-b] % P if 0 <= b <= a else 0\n\nans = pow(3, N, P)\nfor i in range(N//2 + 1, N + 1):\n    ans = (ans - 2 * C(N, i) * pow(2, N - i, P)) % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DW(i, beg, end) for (int i = beg; end <= i; i--)\n#define int int64_t\n\nusing namespace std;\n\nstatic const int64_t kRem = 998244353;\n\nint64_t pow_rem(int64_t x, int64_t m, int64_t rem)\n{\n\tif (m == 0) {\n\t\treturn 1;\n\t}\n\tif (m == 1) {\n\t\treturn x;\n\t}\n\n\tif (m & 1) {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\tval *= x;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n\telse {\n\t\tint64_t val = pow_rem(x, m / 2, rem);\n\t\tval = val * val;\n\t\tval %= rem;\n\t\treturn val;\n\t}\n}\n\nint64_t pow_remdiv(int64_t val, int64_t rem)\n{\n\treturn pow_rem(val, rem - 2, rem);\n}\n\nint64_t divide_rem(int64_t divident, int64_t dividor, int64_t rem)\n{\n\tint64_t ret = pow_remdiv(dividor, rem);\n\tret *= divident;\n\tret %= rem;\n\n\treturn ret;\n}\n\nint64_t nCr(int64_t n, int64_t r, int64_t rem) {\n\tif (n == 0) return 0;\n\tif (r > n) return 0;\n\n\tif (n - r < r) r = n - r;\n\n\tint64_t ret = 1;\n\tfor (int64_t i = 0; i < r; i++) {\n\t\tret *= (n - i);\n\t\tret %= kRem;\n\t\tret = divide_rem(ret, i + 1, rem);\n\t}\n\n\treturn ret;\n}\n\nvector<int64_t> ncr_arr;\nvoid calc_nCr(int n, int64_t rem) {\n\tncr_arr = vector<int64_t>(n + 1);\n\tint64_t num = 1;\n\tint64_t denom = 1;\n\n\tFOR_LE(i, 0, n) {\n\t\tncr_arr[i] = divide_rem(num, denom, rem);\n\n\t\tnum *= (n - i);\n\t\tnum %= kRem;\n\t\tdenom *= (i + 1);\n\t\tdenom %= kRem;\n\t}\n}\n\n#undef int\nint main()\n{\n#define int int64_t\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint64_t n; cin >> n;\n\n\tcalc_nCr(n, kRem);\n\n\tint64_t ans = 0;\n\tFOR_LE(k, n / 2 + 1, n) {\n\t\tint64_t val = ncr_arr[k];\n\t\tval *= pow_rem(2, n - k, kRem);\n\t\tval %= kRem;\n\t\tans += val;\n\t\tans %= kRem;\n\t}\n\n\tans *= 2;\n\tans %= kRem;\n\n\tans = pow_rem(3, n, kRem) - ans;\n\tif (ans < 0) ans += kRem;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nn = int(input())\n\nMOD = 998244353\nMAX_N = n \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nf = 1\nfinv = 1\np2 = 1\nfor i in range(1, MAX_N+1):\n    # fac[i] = fac[i-1] * i % MOD\n    f *= i\n    f %= MOD\n    fac[i] = f\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    # fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n    finv *= pow(i, MOD-2, MOD)\n    finv %= MOD\n    fac_inv[i] = finv\n    p2 *= 2\n    p2 %= MOD\n    mod_pow2_n[i] = p2\n\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += fac[n] * fac_inv[n-i] * fac_inv[i] * mod_pow2_n[n-i] % MOD\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):\n l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):\n a+=b*c%p;b=2*b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a+p)%p)"
  },
  {
    "language": "Python",
    "code": "LARGE = 998244353\n\n\ndef solve(n):\n    r = 0\n    mck = 1\n    for k in range(n // 2):\n        r += mck * pow(2, k, LARGE)\n        r %= LARGE\n        mck *= n - k\n        mck *= pow(k + 1, LARGE - 2, LARGE)\n    res = (pow(3, n, LARGE) - (2 * r)) % LARGE\n    return res\n\n\ndef main():\n    n = int(input())\n    res = solve(n)\n    print(res)\n\n\ndef test():\n    assert solve(2) == 7\n    assert solve(10) == 50007\n    # assert solve(1000000) == 210055358\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**6 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nf = 1\nfinv = 1\np2 = 1\nfor i in range(1, MAX_N+1):\n    # fac[i] = fac[i-1] * i % MOD\n    f *= i\n    f %= MOD\n    fac[i] = f\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    # fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n    finv *= pow(i, MOD-2, MOD)\n    finv %= MOD\n    fac_inv[i] = finv\n    p2 *= 2\n    p2 %= MOD\n    mod_pow2_n[i] = p2\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \ndef single_mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    if r > n - r:\n        r = n - r\n    ret = 1\n    for i in range(r):\n        ret *= n - i\n        ret *= pow(i+1, MOD-2, MOD)\n        ret %= MOD\n    return ret\n\nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * mod_pow2_n[n-i]\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef prepare(n, MOD):\n    f = 1\n    for m in range(1, n + 1):\n        f = f * m % MOD\n    fn = f\n\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv = invs[m - 1] = inv * m % MOD\n    invs = np.array(invs, dtype=np.int64)\n\n    return fn, invs\n\n\nn = int(input())\nMOD = 998244353\nfn, invs = prepare(n, MOD)\n\nn2 = n // 2\n\n# mul = 1\n# muls = [0] * n2\n# for i in range(n2):\n#     mul = muls[i] = mul * 2 % MOD\n\n# mul = 1\n# muls = np.zeros(n2, dtype=np.int64)\n# for i in range(n2):\n#     mul = muls[i] = mul * 2 % MOD\n\nmuls = np.zeros(1, dtype=np.int64)\nmuls[0] = 2\nwhile muls.size < n2:\n    muls = np.append(muls, muls * muls[-1] % MOD)\nmuls = muls[:n2]\n\nimpossibles = invs[:n2] * invs[n:n2:-1] % MOD\nimpossibles = impossibles * muls % MOD\nimpossible = sum(list(impossibles)) % MOD * fn\n\nprint((pow(3, n, MOD) - impossible) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom functools import lru_cache\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN = int(sys.stdin.readline())\n\n\n@lru_cache(maxsize=None)\n# @debug\ndef is_ok(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 2:\n        return s not in ['AB', 'BA']\n    for i in range(len(s) - 2):\n        if s[i:i + 2] not in ['AB', 'BA'] and is_ok(s[:i] + s[i + 2:]):\n            return True\n    return False\n\n\ndef test(N):\n    ret = 0\n    for s in itertools.product('ABC', repeat=N):\n        s = ''.join(s)\n        ret += is_ok(s)\n    return ret\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param int max:\n    :param int mod:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\ndef factorial_invs(max, mod):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max! の逆元\n    :param int max:\n    :param int mod:\n    \"\"\"\n    ret = []\n    r = 1\n    for inv in mod_invs(max, mod):\n        r = r * inv % mod\n        ret.append(r)\n    return ret\n\n\nclass Combination:\n    def __init__(self, max, mod):\n        \"\"\"\n        :param int max:\n        :param int mod: 3 以上の素数であること\n        \"\"\"\n        self._factorials = get_factorials(max, mod)\n        self._finvs = factorial_invs(max, mod)\n        self._mod = mod\n\n    def ncr(self, n, r):\n        \"\"\"\n        :param int n:\n        :param int r:\n        :rtype: int\n        \"\"\"\n        if n < r:\n            return 0\n        return self._factorials[n] * self._finvs[r] % self._mod * self._finvs[n - r] % self._mod\n\n\n# print(test(N))\n\n# 解説AC\n# 偶数番目のAとBを反転して、AAとBB以外を取り除く\n# AまたはBが半分より多いときダメなので全体から引く\nans = pow(3, N, MOD)\ncomb = Combination(max=N, mod=MOD)\nfor r in range(N // 2 + 1, N + 1):\n    ans -= comb.ncr(N, r) * pow(2, N - r, MOD) * 2 % MOD\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nmod=998244353\nCombi=[1]\nfor i in range(1,N+1):\n    Combi.append(Combi[-1]*(N-i+1)*pow(i,mod-2,mod)%mod)\nSC=0\nfor i in range(N//2+1,N+1):\n    SC+=Combi[i]*pow(2,N-i,mod)\nprint((pow(3,N,mod)-SC*2)%mod)"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):l+=[l[p%i]*(p-p//i)%p]\nfor i in range(n,n//2,-1):a+=b*c;b+=b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n \nMOD = 998244353\nMAX_N = 10**7 \n \nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * i % MOD\n    mod_pow2_n[i] = mod_pow2_n[i-1] * 2 % MOD\n \nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n \ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * mod_pow2_n[n-i]\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\n\nN = int(input())\n\nans = pow(3, N, MOD)\n\ndef getInvs(n, MOD):\n    invs = [1] * (n+1)\n    for x in range(2, n+1):\n        invs[x] = (-(MOD//x) * invs[MOD%x]) % MOD\n    return invs\n\ndef getCombNs(n, invs, MOD):\n    combNs = [1] * (n//2+1)\n    for x in range(1, n//2+1):\n        combNs[x] = (combNs[x-1] * (n-x+1) * invs[x]) % MOD\n    return combNs + combNs[:(n+1)//2][::-1]\n\ninvs = getInvs(N, MOD)\ncombNs = getCombNs(N, invs, MOD)\n\npow2 = 1\nfor i in range((N-1)//2+1):\n    num = combNs[i] * pow2\n    ans -= num*2 % MOD\n    ans %= MOD\n    pow2 *= 2\n    pow2 %= MOD\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**7 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nf = 1\nfinv = 1\np2 = 1\nfor i in range(1, MAX_N+1):\n    # fac[i] = fac[i-1] * i % MOD\n    f *= i\n    f %= MOD\n    fac[i] = f\n    # Fermat's little theorem says\n    # a**(p-1) mod p == 1\n    # then, a * a**(p-2) mod p == 1\n    # it means a**(p-2) is inverse element\n    # fac_inv[i] = fac_inv[i-1] * pow(i, MOD-2, MOD) % MOD\n    finv *= pow(i, MOD-2, MOD)\n    finv %= MOD\n    fac_inv[i] = finv\n    p2 *= 2\n    p2 %= MOD\n    mod_pow2_n[i] = p2\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \ndef single_mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    if r > n - r:\n        r = n - r\n    ret = 1\n    for i in range(r):\n        ret *= n - i\n        ret *= pow(i+1, MOD-2, MOD)\n        ret %= MOD\n    return ret\n\nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * mod_pow2_n[n-i]\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nmod=998244353\n\nans=pow(3,n,mod)\nrmv=0\nf = [1, 1]  \ninv = [1, 1]  \nfinv=[1,1]\nfor i in range(2, n+1):\n    f.append((f[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    finv.append(finv[-1]*inv[-1]%mod)\n\nk=n//2\nif k*2<=n:\n    k+=1\ntmp=pow(2,n-k+1,mod)\ninv2=pow(2,mod-2,mod)\nfor i in range(k,n+1):\n    ans -= f[n]*finv[n-i]*finv[i]*tmp\n    tmp*=inv2\n    tmp%=mod\nprint(ans%mod)\n    \n\n"
  },
  {
    "language": "Python",
    "code": "#解説参照\n#言い換えが困難\n\nn=int(input())\nmod=998244353\n\nans=pow(3,n,mod)\nrmv=0\nf = [1, 1]  \ninv = [1, 1]  \nfinv=[1,1]\nfor i in range(2, n+1):\n    f.append((f[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    finv.append(finv[-1]*inv[-1]%mod)\n\ndef ch(a,b):\n    return f[a]*finv[a-b]*finv[b]\nk=n//2\nif k*2<=n:\n    k+=1\n\nfor i in range(k,n+1):\n    ans -= ch(n,i)*pow(2,n-i+1,mod)\nprint(ans%mod)\n    \n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input());l=[0,1];a=0;b=c=1;p=998244353\nfor i in range(2,n):\n l+=[l[p%i]*(p-int(p/i))%p]\nfor i in range(n,n//2,-1):\n a+=b*c%p;b=2*b%p;c=c*i*l[n+1-i]%p\nprint((pow(3,n,p)-2*a)%p)"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    f = 1\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n    fn = f\n\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return fn, invs\n\n\nn = int(input())\nMOD = 998244353\nfn, invs = prepare(n, MOD)\nans = pow(3, n, MOD)\nimpossible = 0\nfor i in range(n // 2):\n    tmp = fn * invs[i] * invs[n - i] % MOD * pow(2, i, MOD)\n    impossible = (impossible + 2 * tmp) % MOD\nprint((ans - impossible) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "def xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a // b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0\n\ndef modinv(a, m):\n    g, x, y = xgcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\nMOD = 998244353\nN = int(input())\n#N = 10 ** 7\nn = N // 2\nansx = 1\ntmp2 = 1\ntmpc = 1\nfor i in range(1, n):\n    tmp2 = (tmp2 * 2)%MOD\n    tmpc = (tmpc * (2 * n - i + 1) * modinv(i, MOD)) % MOD\n    ansx = (ansx + tmp2 * tmpc)%MOD\n\nans = pow(3, N, MOD)\nans = (ans + 2 * MOD - ansx * 2)%MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc040/tasks/agc040_c\n\n奇数文字目と偶数文字目がセットで消える\n奇数文字目のABを反転すると、AB or BA or AC or BC or CC で消えていいことになる\n\nすなわち、異なる文字の切れ目では必ず消せる\n異なる切れ目は必ず存在するので、Cを適当にABに割り振った時に全て消せるかどうかが問題になる\n\nA,Bのみの時に全て消せる条件は 両者の数が等しい事\nCを適切に割り振った時に両者の数を等しくできる必要十分条件は max(a,b) <= N//2\nあとはこれを数えればよい→どうやって？\n\n全ての並び方は 3**N　ここから補集合を引く？\nAが半数を超える(k個)の時のおき方は、 NCk * (2**(N-k))で求まる\nBの時も同様に。\n\n\"\"\"\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv):\n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nN = int(input())\nmod = 998244353\n\nfac,inv = modfac(N+10,mod)\nans = pow(3,N,mod)\n\ntpow = [1]\nfor i in range(N//2+10):\n    tpow.append(tpow[-1]*2%mod)\n\nfor k in range(N//2+1,N+1):\n\n    now = 2 * modnCr(N,k,mod,fac,inv) * tpow[N-k]\n    ans -= now\n    ans %= mod\n\nprint (ans)\n"
  },
  {
    "language": "Python",
    "code": "#C\ndef main():\n    mod=998244353\n    n=int(input())\n    Fact=[1] #階乗\n    for i in range(1,n+1):\n        Fact.append(Fact[i-1]*i%mod)\n    Finv=[0]*(n+1) #階乗の逆元\n    Finv[-1]=pow(Fact[-1],mod-2,mod)\n    for i in range(n-1,-1,-1):\n        Finv[i]=Finv[i+1]*(i+1)%mod\n    def comb(n,r):\n        if n<r:\n            return 0\n        return Fact[n]*Finv[r]*Finv[n-r]%mod\n    \n    impossible=0\n    m=1\n    for k in range(n//2):\n        impossible+=comb(n,k)*m%mod\n        impossible%=mod\n        m*=2\n        m%=mod\n    print((pow(3,n,mod)-impossible*2)%mod)\n\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def e(a,b,c):\n    if b==0:\n        return 1\n    aa=1\n    if b%2==1:\n        aa=a\n    return (aa*(e(a,b//2,c)**2))%mod\nn=int(input())\npre=[1]\nmod=998244353\nfor i in range(n//2+100):\n    pre.append((pre[-1]*2)%mod)\np=[1]\nfor i in range(n):\n    p.append((p[-1]*(i+1))%mod)\ntot=1\nfor i in range(n):\n    tot*=3\n    tot%=mod\n#print(1)\n#print(tot)\nfor i in range(n//2+1,n+1):\n    c=(p[n]*e(p[i],mod-2,mod)*e(p[n-i],mod-2,mod)*pre[n-i])%mod\n    c%=mod\n    tot-=c\n    tot-=c\n    tot%=mod\nprint(tot)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nn = int(input())\n\nMOD = 998244353\nMAX_N = n \n\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nfn = 1\nfinv = 1\np2 = 1\nfor i in range(1, MAX_N+1):\n    fn *= i\n    fn %= MOD\n\n    finv *= pow(i, MOD-2, MOD)\n    finv %= MOD\n    fac_inv[i] = finv\n    p2 *= 2\n    p2 %= MOD\n    mod_pow2_n[i] = p2\n\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += (fn * fac_inv[n-i]) % MOD * (fac_inv[i] * mod_pow2_n[n-i]) % MOD\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nMOD = 998244353\nMAX_N = 10**7 \n\nfac = [1] + [0] * MAX_N\nfac_inv = [1] + [0] * MAX_N\nmod_pow2_n = [1] + [0] * MAX_N\nfor i in range(1, MAX_N+1):\n    fac[i] = fac[i-1] * i % MOD\n    mod_pow2_n[i] = mod_pow2_n[i-1] * 2 % MOD\n\nfac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)\nfor i in range(MAX_N, 1, -1):\n    fac_inv[i-1] = fac_inv[i] * i % MOD\n\ndef mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    tmp = fac_inv[n-r] * fac_inv[r] % MOD\n    return tmp * fac[n] % MOD \n    \nn = int(input())\nans = 0\nfor i in range(n//2+1, n+1):\n    ans += mod_nCr(n, i) * pow(2, n - i, MOD)\n    ans %= MOD\nprint((pow(3, n, MOD) - ans * 2 + MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nMOD = 998244353\n\nans = 0\nd = 1\nb = 1\nfor i in range((N//2)):\n    ans += d * b\n    b *= 2\n    b %= MOD\n    ans %= MOD\n    d = ((N-i)*d)%MOD\n    d = (d*pow(i+1,MOD-2,MOD))%MOD\n\nprint((pow(3,N,MOD)-ans*2)%MOD)"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nimpl ModP {\n    fn tables() -> ModPTables {\n        ModPTables {\n            facts: vec![modp(1), modp(1)],\n            invs: vec![modp(0), modp(1)],\n            finvs: vec![modp(1), modp(1)],\n            modulus: unsafe { MODULUS }\n        }\n    }\n}\n\npub struct ModPTables {\n    facts: Vec<ModP>,\n    invs: Vec<ModP>,\n    finvs: Vec<ModP>,\n    modulus: ModPBase\n}\n\nimpl ModPTables {\n    pub fn fact(&mut self, n: ModPBase) -> ModP {\n        self.extend_facts(n as usize);\n        self.facts[n as usize]\n    }\n\n    pub fn inv(&mut self, n: ModPBase) -> ModP {\n        assert!(n > 0);\n        self.extend_invs(n as usize);\n        self.invs[n as usize]\n    }\n\n    pub fn choose(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.extend_facts(n as usize);\n        self.extend_invs(n as usize);\n        self.extend_finvs(n as usize);\n        self.facts[n as usize] * self.finvs[m as usize] * self.finvs[(n-m) as usize]\n    }\n\n    pub fn homo(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.choose(n+m-1, m-1)\n    }\n\n    fn extend_facts(&mut self, max: usize) {\n        for i in self.facts.len()..max+1 {\n            let prev = self.facts[i-1];\n            self.facts.push(prev * i as ModPBase);\n        }\n    }\n\n    fn extend_invs(&mut self, max: usize) {\n        for i in self.invs.len()..max+1 {\n            let prev = self.invs[self.modulus as usize % i];\n            self.invs.push(self.modulus / i as ModPBase * (-prev));\n        }\n    }\n\n    fn extend_finvs(&mut self, max: usize) {\n        for i in self.finvs.len()..max+1 {\n            let prev = self.finvs[i-1];\n            self.finvs.push(prev * self.invs[i])\n        }\n    }\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64);\n    let pows: Vec<ModP> = iterate(modp(1), |&x| x*2).take(n as usize+1).collect();\n    let mut tables = ModP::tables();\n    let ans = modp(3).pow(n) - 2 * (n/2+1..n+1).map(|k| {\n        tables.choose(n, k) * pows[(n-k) as usize]\n    }).sum::<ModP>();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\nfn choose(n: u64, k: u64, fs: &[ModP]) -> ModP {\n    fs[n as usize] / (fs[k as usize] * fs[(n-k) as usize])\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64);\n    let fs: Vec<ModP> = (1..n+1).lscan(modp(1), |&acc, i| acc * i).collect();\n    let pows: Vec<ModP> = iterate(modp(1), |&acc| 2*acc).take(n as usize+1).collect();\n    let ans = modp(3).pow(n) - (n/2+1..n+1).map(|k| {\n        2 * choose(n, k, &fs) * pows[(n-k) as usize]\n    }).sum::<ModP>();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// Try AtCoder\n// author: Leonardone @ NEETSDKASU\n\nfn main() {\n    let mut stdin = String::new();\n    std::io::Read::read_to_string(&mut std::io::stdin(), &mut stdin).unwrap();\n    let mut stdin = stdin.split_whitespace();\n    let mut get = || stdin.next().unwrap();\n    macro_rules! get {\n        ($t:ty) => (get().parse::<$t>().unwrap());\n        () => (get!(i64));\n    }\n    \n    let n = get!();\n    const M: i64 = 998244353;\n    let mut ans = modpow(3, n, M);\n    let mb = ModBinomial::new(n+1, M);\n    for k in 1 .. n {\n        ans = (ans - mb.bin(n, k) + M) % M;\n    }\n    println!(\"{}\", ans);\n}\n\nfn modpow(x: i64, p: i64, m: i64) -> i64 {\n    if p == 0 {\n        1\n    } else if p % 2 == 0 {\n        modpow((x * x) % m, p / 2, m)\n    } else {\n        (x * modpow(x, p - 1, m)) % m \n    }\n}\nstruct ModBinomial { m: i64, f: Vec<i64>, p: Vec<i64> }\nimpl ModBinomial {\n    fn new(n: i64, m: i64) -> ModBinomial {\n        let mut f = vec![1; n as usize + 1];\n        let mut p = vec![1; f.len()];\n        for i in 2..f.len() {\n            f[i] = (i as i64 * f[i - 1]) % m;\n            p[i] = modpow(f[i], m - 2, m);\n        }\n        ModBinomial { m: m, f: f, p: p }\n    }\n    fn bin(&self, n: i64, k: i64) -> i64 {\n        (((self.f[n as usize] * self.p[k as usize])\n            % self.m) * self.p[(n - k) as usize]) % self.m\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\n#[allow(unused_imports)]\nuse proconio::marker::{Bytes, Chars, Usize1};\n#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\n#[allow(unused_imports)]\nuse std::ops::*;\n#[derive(Clone, Debug, Default)]\nstruct Struct;\n\n\n\n//\n// ModInt\n//\n\nconst M: i64 = 998244353;\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\nstruct ModInt {\n    val: i64,\n}\nconst M0: ModInt = ModInt{val:0};\nconst M1: ModInt = ModInt{val:1};\nconst M_ERROR: ModInt = ModInt{val:-1};\n\nimpl ModInt {\n    fn new(v: i64) -> ModInt {\n        let t = v % M;\n        ModInt{ val: if t < 0 {t+M} else {t} }\n    }\n\n    fn pow(self, exp: i64) -> ModInt {\n        if exp == 0 {\n            M1\n        }\n        else {\n            let x = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                x * x\n            }\n            else {\n                self * x * x\n            }\n        }\n    }\n\n    fn inv(self) -> ModInt {\n        self.pow(M - 2)\n    }\n}\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> ModInt {\n        let t = self.val + rhs.val;\n        ModInt { val: if t >= M {t-M} else {t} }\n    }\n}\nimpl std::ops::Add<i64> for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: i64) -> ModInt {\n        ModInt::new( self.val+rhs )\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> ModInt {\n        let t = self.val + M - rhs.val;\n        ModInt { val: if t >= M {t-M} else {t} }\n    }\n}\nimpl std::ops::Sub<i64> for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: i64) -> ModInt {\n        self - ModInt::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> ModInt {\n        ModInt { val: if self.val == 0 { 0 } else { M - self.val } }\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> ModInt {\n        ModInt { val: self.val * rhs.val % M }\n    }\n}\nimpl std::ops::Mul<i64> for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: i64) -> ModInt {\n        self * ModInt::new(rhs)\n    }\n}\n\nimpl std::ops::Div for ModInt {\n    type Output = ModInt;\n    fn div(self, rhs: ModInt) -> ModInt {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<i64> for ModInt {\n    type Output = ModInt;\n    fn div(self, rhs: i64) -> ModInt {\n        self / ModInt::new(rhs)\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.val)\n    }\n}\n\n\n\n\n//\n// nCr\n//\n#[derive(Debug, Clone)]\nstruct Comb {\n    fac: Vec<ModInt>,\n    finv: Vec<ModInt>,\n    inv: Vec<ModInt>,\n}\n\nimpl Comb {\n    fn new(size: usize) -> Comb {\n        let mut fac = vec![M1; size];\n        let mut finv = vec![M1; size];\n        let mut inv = vec![M1; size];\n\n        for i in 2..size {\n            fac[i] = fac[i - 1] * (i as i64);\n            inv[i] = -inv[M as usize % i] * (M / (i as i64));\n            finv[i] = finv[i - 1] * inv[i];\n        }\n\n        return Comb {\n            fac: fac,\n            finv: finv,\n            inv: inv,\n        };\n    }\n}\ntrait CombC<T> {\n    fn c(&self, n: T, k: T) -> ModInt;\n    fn p(&self, n: T, k: T) -> ModInt;\n}\n\nimpl CombC<usize> for Comb {\n    fn c(&self, n: usize, k: usize) -> ModInt {\n        if n < k {\n            M0\n        } else {\n            self.fac[n] * self.finv[k] * self.finv[n - k]\n        }\n    }\n    fn p(&self, n: usize, k: usize) -> ModInt {\n        if n < k {\n            M0\n        } else {\n            self.fac[n] * self.finv[n - k]\n        }\n    }\n}\n\n\n\n//#[proconio::fastout]\nfn main() {\n    input! {\n        n:usize,\n    }\n\n    /* 奇数番目のAとBを入れ替える A<->B と、\n       ABとBAは消せない → AAとBBは消せない になる。\n       条件を満たす = (Aの文字数 <= N/2 && Bの文字数 <= N/2)\n    */\n    \n    /* f(a,b,c) = (a+b+c)!/a!b!c! とする\n       ans = Σ f(a,b,c) where 0<=a<=N/2 && 0<=b<=N/2\n           = Σ f(a,b,c) where 1  -  Σ f(a,b,c) where N/2<a  -  Σ f(a,b,c) where N/2<b  \n\n        Σ f(x,y,z) where N/2<x =   Σ ncr(n,x)*2^(n-x) where  N/2<x =   Σ ncr(n,y)*2^y where  y<N/2\n    */\n\n    let comb = Comb::new(n+1);\n    let mut sum = M0;\n    let mut p2 = M1;\n    for y in 0..n/2 {\n        sum = sum + comb.c(n,y)*p2;\n        p2 = p2 + p2;\n    }\n\n    let p3 = ModInt::new(3).pow(n as i64);\n\n    println!(\"{}\", p3 - sum*2);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 998_244_353;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\n/* \nimpl std::fmt::Display for ModInt {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n*/\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let n: usize = s.trim().parse().unwrap();\n    let pc = Precalc::new(n);\n    let mut ans = ModInt(3).pow(n as u32);\n    let mut pow = ModInt(2);\n    for k in 0..(n / 2) {\n        ans -= pow * pc.comb(n, n - k);\n        pow *= ModInt(2);\n    }\n    println!(\"{}\", ans.0);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\nfn choose(n: u64, k: u64, fs: &[ModP]) -> ModP {\n    fs[n as usize] / (fs[k as usize] * fs[(n-k) as usize])\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64);\n    let fs: Vec<ModP> = (1..n+1).lscan(modp(1), |&acc, i| acc * i).collect();\n    let ans = modp(3).pow(n) - (n/2+1..n+1).map(|k| {\n        2 * choose(n, k, &fs) * modp(2).pow(n-k)\n    }).sum::<ModP>();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nimpl ModP {\n    fn tables() -> ModPTables {\n        ModPTables {\n            facts: vec![modp(1), modp(1)],\n            invs: vec![modp(0), modp(1)],\n            finvs: vec![modp(1), modp(1)],\n            modulus: unsafe { MODULUS }\n        }\n    }\n}\n\npub struct ModPTables {\n    facts: Vec<ModP>,\n    invs: Vec<ModP>,\n    finvs: Vec<ModP>,\n    modulus: ModPBase\n}\n\nimpl ModPTables {\n    pub fn fact(&mut self, n: ModPBase) -> ModP {\n        self.extend_facts(n as usize);\n        self.facts[n as usize]\n    }\n\n    pub fn inv(&mut self, n: ModPBase) -> ModP {\n        assert!(n > 0);\n        self.extend_invs(n as usize);\n        self.invs[n as usize]\n    }\n\n    pub fn choose(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        // self.extend_facts(n as usize);\n        // self.extend_invs(n as usize);\n        // self.extend_finvs(n as usize);\n        self.facts[n as usize] * self.finvs[m as usize] * self.finvs[(n-m) as usize]\n    }\n\n    pub fn homo(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.choose(n+m-1, m-1)\n    }\n\n    fn extend_facts(&mut self, max: usize) {\n        for i in self.facts.len()..max+1 {\n            let prev = self.facts[i-1];\n            self.facts.push(prev * i as ModPBase);\n        }\n    }\n\n    fn extend_invs(&mut self, max: usize) {\n        for i in self.invs.len()..max+1 {\n            let prev = self.invs[self.modulus as usize % i];\n            self.invs.push(self.modulus / i as ModPBase * (-prev));\n        }\n    }\n\n    fn extend_finvs(&mut self, max: usize) {\n        for i in self.finvs.len()..max+1 {\n            let prev = self.finvs[i-1];\n            self.finvs.push(prev * self.invs[i])\n        }\n    }\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64);\n    let pows: Vec<ModP> = iterate(modp(1), |&x| x*2).take(n as usize+1).collect();\n    let mut tables = ModP::tables();\n\n    tables.extend_facts(n as usize);\n    tables.extend_invs(n as usize);\n    tables.extend_finvs(n as usize);\n\n    let ans = modp(3).pow(n) - 2 * (n/2+1..n+1).map(|k| {\n        tables.choose(n, k) * pows[(n-k) as usize]\n    }).sum::<ModP>();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nuse std::collections::BTreeMap;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let count: usize = sc.read();\n\n    let mut ans = ModInt(3).pow(count);\n    let c = Combination::new(count + 1, MOD);\n    for k in 0..(count / 2) {\n        ans -= c.get(count, k) * ModInt(2).pow(k) * 2;\n    }\n    println!(\"{}\", ans.0);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> ModInt<usize> {\n        assert!(x >= y);\n        ModInt(self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo)\n    }\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n    use super::MOD;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: Num) -> ModInt<Num> {\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// Try AtCoder\n// author: Leonardone @ NEETSDKASU\n\nfn main() {\n    let mut stdin = String::new();\n    std::io::Read::read_to_string(&mut std::io::stdin(), &mut stdin).unwrap();\n    let mut stdin = stdin.split_whitespace();\n    let mut get = || stdin.next().unwrap();\n    macro_rules! get {\n        ($t:ty) => (get().parse::<$t>().unwrap());\n        () => (get!(i64));\n    }\n    \n    let n = get!();\n    const M: i64 = 998244353;\n    let mut ans = modpow(3, n, M);\n    let mb = ModBinomial::new(n+1, M);\n    for k in 1 .. n {\n        if k % 2 == 1 {\n            ans = (ans - mb.bin(n, k) + M) % M;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn modpow(x: i64, p: i64, m: i64) -> i64 {\n    if p == 0 {\n        1\n    } else if p % 2 == 0 {\n        modpow((x * x) % m, p / 2, m)\n    } else {\n        (x * modpow(x, p - 1, m)) % m \n    }\n}\nstruct ModBinomial { m: i64, f: Vec<i64>, p: Vec<i64> }\nimpl ModBinomial {\n    fn new(n: i64, m: i64) -> ModBinomial {\n        let mut f = vec![1; n as usize + 1];\n        let mut p = vec![1; f.len()];\n        for i in 2..f.len() {\n            f[i] = (i as i64 * f[i - 1]) % m;\n            p[i] = modpow(f[i], m - 2, m);\n        }\n        ModBinomial { m: m, f: f, p: p }\n    }\n    fn bin(&self, n: i64, k: i64) -> i64 {\n        (((self.f[n as usize] * self.p[k as usize])\n            % self.m) * self.p[(n - k) as usize]) % self.m\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nuse std::collections::BTreeMap;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let count: usize = sc.read();\n\n    let mut sum = ModInt(0);\n    let mut cur = ModInt(1);\n\n    let mut z = count;\n    let mut x = ModInt(1);\n    while z > 0 {\n        sum += cur;\n        let next = ModInt(0) - ModInt(2) * (x - (count + 1)) * cur / x;\n        //        eprintln!(\"{} => {}\", cur.0, next.0);\n        cur = next;\n        x += 1;\n        z -= 2\n    }\n    let ans = ModInt(3).pow(count) - sum * 2;\n    println!(\"{}\", ans.0);\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n    use super::MOD;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: Num) -> ModInt<Num> {\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nimpl ModP {\n    fn tables() -> ModPTables {\n        ModPTables {\n            facts: vec![modp(1), modp(1)],\n            invs: vec![modp(0), modp(1)],\n            finvs: vec![modp(1), modp(1)],\n            modulus: unsafe { MODULUS }\n        }\n    }\n}\n\npub struct ModPTables {\n    facts: Vec<ModP>,\n    invs: Vec<ModP>,\n    finvs: Vec<ModP>,\n    modulus: ModPBase\n}\n\nimpl ModPTables {\n    pub fn fact(&mut self, n: ModPBase) -> ModP {\n        self.extend_facts(n as usize);\n        self.facts[n as usize]\n    }\n\n    pub fn inv(&mut self, n: ModPBase) -> ModP {\n        assert!(n > 0);\n        self.extend_invs(n as usize);\n        self.invs[n as usize]\n    }\n\n    pub fn choose(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.extend_facts(n as usize);\n        self.extend_invs(n as usize);\n        self.extend_finvs(n as usize);\n        self.facts[n as usize] * self.finvs[m as usize] * self.finvs[(n-m) as usize]\n    }\n\n    pub fn homo(&mut self, n: ModPBase, m: ModPBase) -> ModP {\n        self.choose(n+m-1, m)\n    }\n\n    fn extend_facts(&mut self, max: usize) {\n        for i in self.facts.len()..max+1 {\n            let prev = self.facts[i-1];\n            self.facts.push(prev * i as ModPBase);\n        }\n    }\n\n    fn extend_invs(&mut self, max: usize) {\n        for i in self.invs.len()..max+1 {\n            let prev = self.invs[self.modulus as usize % i];\n            self.invs.push(self.modulus / i as ModPBase * (-prev));\n        }\n    }\n\n    fn extend_finvs(&mut self, max: usize) {\n        for i in self.finvs.len()..max+1 {\n            let prev = self.finvs[i-1];\n            self.finvs.push(prev * self.invs[i])\n        }\n    }\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64);\n    // let pows: Vec<ModP> = iterate(modp(1), |&x| x*2).take(n as usize+1).collect();\n    let mut tables = ModP::tables();\n\n    tables.facts.reserve(n as usize+1);\n    tables.invs.reserve(n as usize+1);\n    tables.finvs.reserve(n as usize+1);\n\n    let ans = modp(3).pow(n) - 2 * (n/2+1..n+1).map(|k| {\n        // tables.choose(n, k) * pows[(n-k) as usize]\n        tables.choose(n, k) * modp(2).pow(n-k)\n    }).sum::<ModP>();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 998_244_353;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let n: usize = s.trim().parse().unwrap();\n    let pc = Precalc::new(n);\n    let mut ans = ModInt(3).pow(n as u32);\n    for i in (n / 2 + 1)..(n + 1) {\n        ans -= ModInt(2) * pc.comb(n, i) * ModInt(2).pow((n - i) as u32);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nuse std::collections::BTreeMap;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    //\n    //    for n in vec![2, 4, 6, 8, 10].into_iter() {\n    //        let mut map = BTreeMap::new();\n    //        map.insert(0, 1);\n    //        for _ in 0..n {\n    //            let mut next = BTreeMap::new();\n    //            for (count, value) in map.into_iter() {\n    //                *next.entry(count - 1).or_insert(0) += value * 2;\n    //                *next.entry(count + 1).or_insert(0) += value;\n    //            }\n    //            map = next;\n    //        }\n    //\n    //        eprintln!(\"{:?}\", map);\n    //        let sum = map\n    //            .into_iter()\n    //            .filter(|&(count, _)| count > 0)\n    //            .map(|(_, value)| value)\n    //            .sum::<i32>();\n    //        println!(\"n={} sum={}\", n, sum);\n    //    }\n\n    let mut ans = ModInt(0);\n    let mut cur = ModInt(1);\n    let count: usize = sc.read();\n    let mut z = count;\n    let x = ModInt(1);\n    while z > 0 {\n        ans += cur;\n        cur = ModInt(0) - ModInt(2) * (x - (count + 1)) * cur / x;\n        z -= 2\n    }\n    let ans = ModInt(3).pow(count) - ans * 2;\n    println!(\"{}\", ans.0);\n}\n\npub mod mod_int {\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n    use super::MOD;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: Num) -> ModInt<Num> {\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: Num) -> ModInt<Num> {\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: Num) -> ModInt<Num> {\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc040/tasks/agc040_c\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nconst MOD: i64 = 998244353;\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\n//===\n\nfn main() {\n    input! {\n        n: usize\n    };\n\n    let comb = Combination::new(n+10);\n\n    let mut pow2 = dvec![0; n+1];\n    pow2[0] = 1;\n    for i in 1..n+1 {\n        pow2[i] = pow2[i-1] * 2 % MOD;\n    }\n    let mut ans = 1;\n    for i in 0..n {\n        ans *= 3;\n        ans %= MOD;\n    }\n    for s in n/2+1..n+1 {\n        let add = comb.comb(n, s) * pow2[n-s] % MOD * 2 % MOD;\n        ans += MOD-add;\n        ans %= MOD;\n    }\n    println!(\"{}\", ans);\n}\n"
  }
]