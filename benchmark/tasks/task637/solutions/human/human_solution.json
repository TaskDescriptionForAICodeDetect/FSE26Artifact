[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=1e9+7 ;\n\n\nint nxt[202020][20], pre[202020][20];\nll nsum[202020][20], psum[202020][20];\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,k;\n    cin>>n>>k;\n    vector<int> a(n);\n    rep(i,n)cin>>a[i];\n    int j=0;\n    rep(i,n){\n        while(j < n && a[i]+k>a[j])j++;\n        nxt[i][0]=j;\n        nsum[i][0]=j;\n    }\n    j=n-1;\n    for(int i=n-1;i>=0;--i){\n        while(j>=0 && a[j]+k>a[i])j--;\n        pre[i][0]=j;\n        psum[i][0]=j;\n    }\n    rep(j,19)rep(i,n){\n        if(nxt[i][j]!=n){\n            nxt[i][j+1]=nxt[nxt[i][j]][j];\n            nsum[i][j+1]=nsum[i][j]+nsum[nxt[i][j]][j];\n        } else {\n            nxt[i][j+1]=n;\n        }\n        if(pre[i][j]!=-1){\n            pre[i][j+1]=pre[pre[i][j]][j];\n            psum[i][j+1]=psum[i][j]+psum[pre[i][j]][j];\n        } else {\n            pre[i][j+1]=-1;\n        }\n    }\n    int q;\n    cin>>q;\n    while(q--){\n        int l,r;\n        cin>>l>>r;\n        --l;--r;\n        ll lcnt = 1, rcnt = 1, lsum = l, cl = l, rsum = r, cr = r;\n        for(int i=19;i>=0;i--){\n            if(nxt[cl][i]<=r){\n                lcnt += 1<<i;\n                lsum += nsum[cl][i];\n                cl = nxt[cl][i];\n            }\n        }\n        for(int i=19;i>=0;i--){\n            if(pre[cr][i]>=l){\n                rcnt += 1<<i;\n                rsum += psum[cr][i];\n                cr = pre[cr][i];\n            }\n        }\n        //assert(lcnt == rcnt);\n        //cout << lcnt << \" \" <<lsum << \" \" << rsum <<endl;\n        cout << rsum - lsum + lcnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=200005;\nconst int mlog=20;\nint n,k,q;\nint x[maxn];\nint prv[maxn][mlog],nxt[maxn][mlog];\nlong long sprv[maxn][mlog],snxt[maxn][mlog];\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tint ppt=0;\n\tfor(int j=0;j<mlog;j++)prv[0][j]=0;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(ppt+1<i&&x[i]-x[ppt+1]>=k)ppt++;\n\t\tprv[i][0]=ppt;\n\t\tsprv[i][0]=i;\n\t\tfor(int j=1;j<mlog;j++)\n\t\t\tprv[i][j]=prv[prv[i][j-1]][j-1],sprv[i][j]=sprv[i][j-1]+sprv[prv[i][j-1]][j-1];\n\t}\n\tint npt=n+1;\n\tfor(int j=0;j<mlog;j++)nxt[n+1][j]=n+1;\n\tfor(int i=n;i>=1;i--){\n\t\twhile(npt-1>i&&x[npt-1]-x[i]>=k)npt--;\n\t\tnxt[i][0]=npt;\n\t\tsnxt[i][0]=i;\n\t\tfor(int j=1;j<mlog;j++)\n\t\t\tnxt[i][j]=nxt[nxt[i][j-1]][j-1],snxt[i][j]=snxt[i][j-1]+snxt[nxt[i][j-1]][j-1];\n\t}\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tlong long ans=0;\n\t\tint cl=l,cr=r,cd=0;\n\t\tfor(int i=mlog-1;i>=0;i--)if(nxt[cl][i]<=r){\n\t\t\tans+=sprv[cr][i]-snxt[cl][i];\n\t\t\tcl=nxt[cl][i];\n\t\t\tcr=prv[cr][i];\n\t\t\tcd+=(1<<i);\n\t\t}\n\t\tans+=cr-cl+cd+1;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\n\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec X(N); cin >> X;\n    int Q; cin >> Q;\n\n    vector<v_Pii> next(18, v_Pii(N, Pii(N, 0))), prev(18, v_Pii(N, Pii(-1, 0)));\n    REP(i, N){\n        int j = Lower_bound(X, X[i] + K);\n        if(j < N) next[0][i] = Pii(j, j);\n        int k = Upper_bound(X, X[i] - K) - 1;\n        if(k >= 0) prev[0][i] = Pii(k, k);\n    }\n    FOR(t, 1, 18){\n        REP(i, N) if(next[t - 1][i].fi < N){\n            int v = next[t - 1][next[t - 1][i].fi].fi;\n            int cost = next[t - 1][i].se + next[t - 1][next[t - 1][i].fi].se;\n            next[t][i] = Pii(v, cost);\n        }\n        REP(i, N) if(prev[t - 1][i].fi >= 0){\n            int v = prev[t - 1][prev[t - 1][i].fi].fi;\n            int cost = prev[t - 1][i].se + prev[t - 1][prev[t - 1][i].fi].se;\n            prev[t][i] = Pii(v, cost);\n        }\n    }\n    //mdebug(next); mdebug(prev);\n\n    vec ans(Q);\n    REP(q, Q){\n        int L, R; cin >> L >> R;\n        L--; R--;\n\n        int nl = 1, cl = L;\n        int now = L;\n        while(next[0][now].fi <= R){\n            IREP(t, 18) if(next[t][now].fi <= R){\n                nl += bit(t);\n                cl += next[t][now].se;\n                now = next[t][now].fi;\n                break;\n            }\n        }\n        int nr = 1, cr = R;\n        now = R;\n        while(prev[0][now].fi >= L){\n            IREP(t, 18) if(prev[t][now].fi >= L){\n                nr += bit(t);\n                cr += prev[t][now].se;\n                now = prev[t][now].fi;\n                break;\n            }\n        }\n        ans[q] = cr - cl + nl;\n    }\n    REP(i, Q) cout << ans[i] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct BIT {\n\t\tll dt[1 << 18];\n\t\tvoid inline add(int a, int x) {\n\t\t\twhile(a < (1 << 18)) {\n\t\t\t\tdt[a] += x;\n\t\t\t\ta += a & -a;\n\t\t\t}\n\t\t}\n\t\tll inline sum(int a) {\n\t\t\tll res = 0;\n\t\t\twhile(a) {\n\t\t\t\tres += dt[a];\n\t\t\t\ta -= a & -a;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} bit;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18], tag;\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) bit.add(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (tag ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tll inline sum(int a, int b) {\n\t\tll res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += bit.sum(dfn[a]) - bit.sum(dfn[rt] - 1);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0); tl.tag = 1;\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%lld\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "//DUEL\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#pragma GCC optimize(\"unroll-loops\")\n#define shandom_ruffle(a, b) shuffle(a, b, rng)\n#define vi vector<int>\n#define vl vector<ll>\n#define popcnt __builtin_popcount\n#define popcntll __builtin_popcountll\n#define all(a) begin(a),end(a)\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nusing ll=long long;\nusing ull=unsigned long long;\nusing ld=long double;\nint MOD=1000000007;\nint MOD2=998244353;\nvector<int> bases;\nconst ll LLINF=1ll<<60;\nconst char en='\\n';\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid yes() {cout<<\"YES\"<<en; exit(0);}\nvoid no() {cout<<\"NO\"<<en; exit(0);}\ninline int rund() {int x576363482791fuweh=rng();return abs(x576363482791fuweh)%RAND_MAX;}\ntemplate<class T>\nvoid prVec(vector<T> w,bool fl=false)\n{\n\tcout<<w.size()<<en;\n\tfor (int i=0;i<int(w.size())-1;++i) cout<<w[i]<<' ';\n\tif (w.size()) cout<<w[w.size()-1]<<en;\n\tif (fl) cout<<flush;\n}\n\nvoid M998()\n{\n\tswap(MOD,MOD2);\n}\n\nll raand()\n{\n\tll a=rund();\n\ta*=RAND_MAX;\n\ta+=rund();\n    return a;\n}\n\n#define rand raand\n\nll raaand()\n{\n\treturn raand()*(MOD-7)+raand();\n}\n\nvoid compress(vi&v)\n{\n\tset<int> s;\n\tfor (auto a: v) s.insert(a);\n\tvi o(all(s));\n\tfor (auto&a: v) a=lower_bound(all(o),a)-o.begin();\n}\n\nvoid compress(vl&v)\n{\n\tset<ll> s;\n\tfor (auto a: v) s.insert(a);\n\tvl o(all(s));\n\tfor (auto&a: v) a=lower_bound(all(o),a)-o.begin();\n}\n\nstring to_upper(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A';\n\treturn a;\n}\n\nstring to_lower(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A';\n\treturn a;\n}\n\nll sti(string a,int base=10)\n{\n\tll k=0;\n\tfor (int i=0;i<(int)a.size();++i)\n\t{\n\t\tk*=base;\n\t\tk+=a[i]-'0';\n\t}\n\treturn k;\n}\n\ntemplate<class T>\nvoid eras(vector<T>& a,T b)\n{\n\ta.erase(find(a.begin(),a.end(),b));\n}\n\nstring its(ll k,int base=10)\n{\n\tif (k==0) return \"0\";\n\tstring a;\n\twhile (k)\n\t{\n\t\ta.push_back((k%base)+'0');\n\t\tk/=base;\n\t}\n\treverse(a.begin(),a.end());\n\treturn a;\n}\n\nll min(ll a,int b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll min(int a,ll b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll max(ll a,int b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll max(int a,ll b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll gcd(ll a,ll b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b)\n{\n\treturn a/gcd(a,b)*b;\n}\n\ntemplate<class T,class K>\npair<T,K> mp(T a,K b)\n{\n\treturn make_pair(a,b);\n}\n\ninline int mult(ll a,ll b)\n{\n\treturn (a*b)%MOD;\n}\n\ninline int pot(int n,int k)\n{\n\tif (k==0) return 1;\n\tll a=pot(n,k/2);\n\ta=mult(a,a);\n\tif (k%2) return mult(a,n);\n\telse return a;\n}\n\nint divide(int a,int b)\n{\n\treturn mult(a,pot(b,MOD-2));\n}\n\ninline int sub(int a,int b)\n{\n\tif (a-b>=0) return a-b;\n\treturn a-b+MOD;\n}\n\ninline int add(int a,int b)\n{\n\tif (a+b>=MOD) return a+b-MOD;\n\treturn a+b;\n}\n\nbool prime(ll a)\n{\n\tif (a==1) return 0;\n\tfor (int i=2;i<=round(sqrt(a));++i)\n\t{\n\t\tif (a%i==0) return 0;\n\t}\n\treturn 1;\n}\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nconst int N=200010;\nint k,n,q,h[N],par1[20][N],par2[20][N];\nll sd1[20][N],sd2[20][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor (int i=0;i<10;++i) bases.push_back(rand()%(MOD-13893829*2)+13893829);\n\tcin>>n>>k;\n\tfor (int i=1;i<=n;++i) cin>>h[i];\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tauto it=upper_bound(h+1,h+n+1,h[i]-k);\n\t\tint po=it-h-1;\n\t\tpar2[0][i]=sd2[0][i]=po;\n\t}\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tauto it=lower_bound(h+1,h+n+1,h[i]+k);\n\t\tint po=it-h;\n\t\tpar1[0][i]=sd1[0][i]=po;\n\t}\n\tpar1[0][n+1]=sd1[0][n+1]=n+1;\n\tfor (int j=0;j<18;++j)\n\t{\n\t\tfor (int i=0;i<=n+1;++i)\n\t\t{\n\t\t\tpar1[j+1][i]=par1[j][par1[j][i]];\n\t\t\tpar2[j+1][i]=par2[j][par2[j][i]];\n\t\t\tsd1[j+1][i]=sd1[j][i]+sd1[j][par1[j][i]];\n\t\t\tsd2[j+1][i]=sd2[j][i]+sd2[j][par2[j][i]];\n\t\t}\n\t}\n\tcin>>q;\n\twhile (q--)\n\t{\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tll s1=l,s2=r;\n\t\tint cn1=0,cn2=0;\n\t\tint l1=l;\n\t\tfor (int i=18;i>=0;--i) if (par1[i][l]<=r) s1+=sd1[i][l],l=par1[i][l],cn1+=1<<i;\n\t\tl=l1;\n\t\tfor (int i=18;i>=0;--i) if (par2[i][r]>=l) s2+=sd2[i][r],r=par2[i][r],cn2+=1<<i;\n\t\tassert(cn1==cn2);\n\t\tcout<<s2-s1+cn1+1<<en;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll X[202020];\nint Q;\nint L,R;\nint le[21][202020];\nint ri[21][202020];\nint LS[21][202020];\nint RS[21][202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>X[i+1];\n\tX[0]=-1LL<<60;\n\tX[N+1]=1LL<<60;\n\tfor(i=1;i<=N;i++) {\n\t\tri[0][i]=lower_bound(X,X+N+2,X[i]+K)-X;\n\t\tle[0][i]=lower_bound(X,X+N+2,X[i]-K)-X;\n\t\tif(X[le[0][i]]>X[i]-K) le[0][i]--;\n\t\tLS[0][i]=le[0][i];\n\t\tRS[0][i]=ri[0][i];\n\t}\n\t\n\tle[0][0]=0;\n\tri[0][N+1]=N+1;\n\tFOR(j,20) {\n\t\tfor(i=0;i<=N+1;i++) {\n\t\t\tle[j+1][i]=le[j][le[j][i]];\n\t\t\tri[j+1][i]=ri[j][ri[j][i]];\n\t\t\tLS[j+1][i]=LS[j][i]+LS[j][le[j][i]];\n\t\t\tRS[j+1][i]=RS[j][i]+RS[j][ri[j][i]];\n\t\t}\n\t}\n\t\n\t\n\tcin>>Q;\n\tFOR(i,Q) {\n\t\tcin>>L>>R;\n\t\tll dif=R-L+1;\n\t\tx=L,y=R;\n\t\tfor(j=19;j>=0;j--) {\n\t\t\tif(ri[j][x]<=R) {\n\t\t\t\tdif+=LS[j][y]-RS[j][x]+(1<<j);\n\t\t\t\tx=ri[j][x];\n\t\t\t\ty=le[j][y];\n\t\t\t}\n\t\t}\n\t\tcout<<dif<<endl;\n\t}\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// DEBUG BEGIN\n#ifdef LOCAL\ntemplate<typename L, typename R> ostream &operator<<(ostream &out, const pair<L, R> &p){\n\treturn out << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<typename Tuple, size_t N> struct TuplePrinter{\n\tstatic ostream &print(ostream &out, const Tuple &t){ return TuplePrinter<Tuple, N-1>::print(out, t) << \", \" << get<N-1>(t); }\n};\ntemplate<typename Tuple> struct TuplePrinter<Tuple, 1>{\n\tstatic ostream &print(ostream &out, const Tuple& t){ return out << get<0>(t); }\n};\ntemplate<typename... Args> ostream &print_tuple(ostream &out, const tuple<Args...> &t){\n\treturn TuplePrinter<decltype(t), sizeof...(Args)>::print(out << \"(\", t) << \")\";\n}\ntemplate<typename ...Args> ostream &operator<<(ostream &out, const tuple<Args...> &t){\n\treturn print_tuple(out, t);\n}\ntemplate<typename T> ostream &operator<<(enable_if_t<!is_same<T, string>::value, ostream> &out, const T &arr){\n\tout << \"{\"; for(auto &x: arr) out << x << \", \";\n\treturn out << (arr.size() ? \"\\b\\b\" : \"\") << \"}\";\n}\ntemplate<size_t S> ostream &operator<<(ostream &out, const bitset<S> &b){\n\tfor(int i = 0; i < S; ++ i) out << b[i];\n\treturn out;\n}\nvoid debug_out(){ cerr << \"\\b\\b \" << endl; }\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T){ cerr << H << \", \", debug_out(T...); }\nvoid debug2_out(){ cerr << \"-----DEBUG END-----\\n\"; }\ntemplate<typename Head, typename... Tail>\nvoid debug2_out(Head H, Tail... T){ cerr << \"\\n\"; for(auto x: H) cerr << x << \"\\n\"; debug2_out(T...); }\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n#define debug2(...) cerr << \"----DEBUG BEGIN----\\n[\" << #__VA_ARGS__ << \"]:\", debug2_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#define debug2(...) 42\n#endif\n// DEBUG END\n\nint main(){\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> a(n);\n\tfor(auto i = 0; i < n; ++ i){\n\t\tcin >> a[i];\n\t}\n\tvector next(__lg(n) + 1, vector(n, pair{numeric_limits<int>::max(), 0LL}));\n\tvector prev(__lg(n) + 1, vector(n, pair{numeric_limits<int>::min(), 0LL}));\n\tfor(auto u = 0, v = 0; u < n; ++ u){\n\t\twhile(v < n && a[v] < a[u] + k){\n\t\t\t++ v;\n\t\t}\n\t\tif(v < n){\n\t\t\tnext[0][u] = {v, u + v};\n\t\t}\n\t}\n\tfor(auto u = n - 1, v = n - 1; u >= 0; -- u){\n\t\twhile(v >= 0 && a[v] > a[u] - k){\n\t\t\t-- v;\n\t\t}\n\t\tif(v >= 0){\n\t\t\tprev[0][u] = {v, u + v};\n\t\t}\n\t}\n\tfor(auto bit = 1; bit <= __lg(n); ++ bit){\n\t\tfor(auto u = 0; u < n; ++ u){\n\t\t\tint v = next[bit - 1][u].first;\n\t\t\tif(v < n){\n\t\t\t\tnext[bit][u] = {next[bit - 1][v].first, next[bit - 1][u].second + next[bit - 1][v].second - v};\n\t\t\t}\n\t\t\tv = prev[bit - 1][u].first;\n\t\t\tif(v >= 0){\n\t\t\t\tprev[bit][u] = {prev[bit - 1][v].first, prev[bit - 1][u].second + prev[bit - 1][v].second - v};\n\t\t\t}\n\t\t}\n\t}\n\tdebug2(next);\n\tdebug2(prev);\n\tint qn;\n\tcin >> qn;\n\tfor(auto qi = 0; qi < qn; ++ qi){\n\t\tint ul, ur;\n\t\tcin >> ul >> ur, -- ul, -- ur;\n\t\tint rmax = ur, sz = 1;\n\t\tlong long rsum = ul, lsum = ur;\n\t\tfor(int bit = __lg(n); bit >= 0; -- bit){\n\t\t\tif(next[bit][ul].first <= rmax){\n\t\t\t\tsz += 1 << bit;\n\t\t\t\trsum += next[bit][ul].second - ul;\n\t\t\t\tul = next[bit][ul].first;\n\t\t\t\tlsum += prev[bit][ur].second - ur;\n\t\t\t\tur = prev[bit][ur].first;\n\t\t\t}\n\t\t}\n\t\tdebug(lsum, rsum, sz);\n\t\tcout << lsum - rsum + sz << \"\\n\";\n\t}\n\treturn 0;\n}\n\n/*\n\n*/\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n//                                   Coded by Aeren                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int (i)=0;i<(int)(n);i++)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef vector<int> Array;\n\nint l[20][202020];\nint r[20][202020];\nint dp1[20][202020];\nint dp2[20][202020];\n\nint main() {\n\tll n, k;\n\tcin >> n >> k;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tREP(i, n)dp1[0][i] = l[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n\tREP(i, n)dp2[0][i] = r[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\tREP(i, 19)REP(j, n)l[i + 1][j] = l[i][min(n - 1, l[i][j])];\n\tREP(i, 19)REP(j, n)r[i + 1][j] = r[i][max(0LL, r[i][j])];\n\tREP(i, 19)REP(j, n)dp1[i + 1][j] = dp1[i][j] + dp1[i][l[i][j]];\n\tREP(i, 19)REP(j, n)dp2[i + 1][j] = dp2[i][j] + dp2[i][r[i][j]];\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint L, R;\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tint ans = R - L;\n\t\tint x = L, y = R - 1;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (l[i][x] < R)ans += (1LL << i) - dp1[i][x], x = l[i][x];\n\t\t\tif (r[i][y] >= L)ans += dp2[i][y], y = r[i][y];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\n#include <utility>\n\n\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n//ダブリング\n//ACLにないんだけど\nint main(void){\n\tint h,i,j,n,m,K;cin>>n>>K;\n\tvector<llint>X(n+2);\n\tX[0]=-inf;X[n+1]=inf;\n\tfor(i=1;i<=n;i++){cin>>X[i];}\n\tvector<int>lgo[18];\n\tvector<int>rgo[18];\n\tvector<llint>lsum[18];\n\tvector<llint>rsum[18];\n\tfor(h=0;h<18;h++){\n\t\tlgo[h].res(n+2);rgo[h].res(n+2);\n\t\tlsum[h].res(n+2);rsum[h].res(n+2);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tlgo[0][i]=LBI(X,X[i]+K);\n\t\trgo[0][i]=UBI(X,X[i]-K)-1;\n\t\tlsum[0][i]=i;\n\t\trsum[0][i]=i;\n\t}\n\tlgo[0][0]=0;lgo[0][n+1]=n+1;\n\tlsum[0][0]=0;lsum[0][n+1]=n+1;\n\trgo[0][0]=0;rgo[0][n+1]=n+1;\n\trsum[0][0]=0;rsum[0][n+1]=n+1;\n\tfor(h=1;h<18;h++){\n\t\tfor(i=0;i<=n+1;i++){\n\t\t\tlgo[h][i]=lgo[h-1][lgo[h-1][i]];\n\t\t\trgo[h][i]=rgo[h-1][rgo[h-1][i]];\n\t\t\tlsum[h][i]=lsum[h-1][i]+lsum[h-1][lgo[h-1][i]];\n\t\t\trsum[h][i]=rsum[h-1][i]+rsum[h-1][rgo[h-1][i]];\n\t\t}\n\t}\n\tint Q;cin>>Q;\n\twhile(Q--){\n\t\tint L,R,gL,gR,Lcou=0,Rcou=0;cin>>L>>R;\n\t\tgL=L;gR=R;\n\t\tllint ans=0;\n\t\tfor(h=17;h>=0;h--){\n\t\t\tif(lgo[h][gL]<=R){ans-=lsum[h][gL];gL=lgo[h][gL];Lcou+=(1<<h);}\n\t\t\tif(rgo[h][gR]>=L){ans+=rsum[h][gR];gR=rgo[h][gR];Rcou+=(1<<h);}\n\t\t}\n\t\tans-=gL;Lcou++;\n\t\tans+=gR;Rcou++;\n\t\tif(Lcou!=Rcou){cerr<<\"bag\"<<endl;}\n\t\t\n\t\tans+=Lcou;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define REP(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> bool chmax(T& a,T b){ if(a < b){ a = b; return true; }else return false; }\ntemplate<class T> bool chmin(T& a,T b){ if(a > b){ a = b; return true; }else return false; }\n \nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing Pi = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vpi = vector<Pi>;\nusing vpl = vector<Pl>;\n \n#define debug(arr) cout << #arr << \" = \" << arr << '\\n'\n#define debug2(a,b) cout << \"[\" << #a << \",\" << #b << \"] = \" << \"[\" << a << \",\" << b << \"]\" << '\\n'\ntemplate<class T> ostream &operator << (ostream& out, const vector<T>& arr) {\n\tcout << \"{\"; for (int i = 0; i < arr.size(); i++)cout << (!i ? \"\" : \", \") << arr[i]; cout << \"}\";\n\treturn out;\n}\ntemplate<class T> ostream &operator << (ostream& out, const vector<vector<T> >& arr) {\n\tcout << \"{\\n\"; for (auto& vec : arr)cout << \"  \" << vec << \",\\n\"; cout << \"}\";\n\treturn out;\n}\ntemplate<class S,class T> ostream &operator << (ostream& out, const pair<S,T>& p){\n  cout << \"{\" << p.first << \",\" << p.second << \"}\" << '\\n';\n  return out;\n}\ntemplate<class T> istream &operator >> (istream& in, vector<T>& arr) {\n\tfor (auto& i : arr)cin >> i; return in;\n}\n\n/////////////////////////////////////////////////////\n\n#define maxn 200020\n#define maxlog 30\n\nlong long N,K,Q;\nll X[maxn];\nll R[maxn][maxlog],L[maxn][maxlog];\nll rsum[maxn][maxlog],lsum[maxn][maxlog];\n\nsigned main(void){\n  cin >> N >> K;\n  for (long long i = 1; i <= N; i++) {\n    cin >> X[i];\n  }\n  \n  // k steps right from x,left from x.\n  {\n    X[0] = -(1LL<<55);\n    X[N+1] = (1LL << 55);\n    // 1steps\n    long long l = 1,r = 2;\n    for(;l <= N;l++){\n      for(;r <= N+1;r++){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          R[l][0] = r;\n          break;\n        }\n      }\n    }\n    r = N,l = N-1;\n    for(;r >= 1;r--){\n      for(;l >= 0;l--){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          L[r][0] = l;\n          break;\n        }\n      }\n    }\n    R[N+1][0] = N+1;\n    L[0][0] = 0;\n    // set doubling.\n    for(long long j = 1;j < maxlog;j++){\n      for(long long i = 0;i <= N+1;i++){\n        R[i][j] = R[R[i][j-1]][j-1];\n        L[i][j] = L[L[i][j-1]][j-1];\n      }\n    }\n  }\n  \n  // init distances.\n  {\n    for(long long i = 1;i <= N;i++){\n      rsum[i][0] = R[i][0];\n      lsum[i][0] = L[i][0];\n    }\n    for(long long i = 1;i <= N;i++){\n      for(long long j = 1;j < maxlog;j++){\n        rsum[i][j] = rsum[i][j-1] + rsum[R[i][j-1]][j-1];\n        lsum[i][j] = lsum[i][j-1] + lsum[L[i][j-1]][j-1];\n      }\n    }\n  }\n  cin >> Q;\n  for (long long i = 0; i < Q; i++) {\n    long long l,r;cin >> l >> r;\n    long long low = 0,high = N;\n    while(low + 1 < high){\n      long long mid = (low + high) / 2;\n      long long tmp = l;\n      for(long long j = 0;j < maxlog;j++){\n        if(mid >> j & 1){\n          tmp = R[tmp][j];\n        }\n      }\n      //debug2(mid,tmp);\n      if(tmp <= r){\n        low = mid;\n      }else{\n        high = mid;\n      }\n    }\n    ll sr = l,sl = r;\n    { // calc sr.\n      long long tmp = l;\n      for(long long j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sr += rsum[tmp][j];\n          tmp = R[tmp][j];\n        }\n      }\n    }\n    { // calc sl.\n      long long tmp = r;\n      for(long long j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sl += lsum[tmp][j];\n          tmp = L[tmp][j];\n        }\n      }\n    }\n    cout << sl - sr + (low + 1) << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(x) cerr << #x << \" == \" << (x) << '\\n';\n#define all(X) (X).begin(), (X).end()\n#define sz(X) (int)X.size()\n\nusing ll = long long;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\n\nint main()\n{ _\n    int n, k; cin >> n >> k;\n    vector x(n, 0);\n    for (int i = 0; i < n; ++i) cin >> x[i];\n\n    int logn = 32 - __builtin_clz(n);\n    vector gol(n, vector(logn, -1)), gor(n, vector(logn, n));\n    vector suml(n, vector(logn, 0LL)), sumr(n, vector(logn, 0LL));\n\n    auto findright = [&](int i)\n    {\n        int j = i;\n        for (int z = n; z; z >>= 1)\n            while (j + z < n && x[j + z] < x[i] + k) j += z;\n        return j + 1;\n    };\n\n    auto findleft = [&](int i)\n    {\n        int j = i;\n        for (int z = n; z; z >>= 1)\n            while (j - z >= 0 && x[j - z] > x[i] - k) j -= z;\n        return j - 1;\n    };\n\n    for (int i = n - 2; i >= 0; --i)\n        if ((gor[i][0] = findright(i)) < n)\n        {\n            sumr[i][0] = gor[i][0];\n            for (int z = 1; z < logn && gor[i][z - 1] < n; ++z)\n            {\n                gor[i][z] = gor[gor[i][z - 1]][z - 1];\n                sumr[i][z] = sumr[i][z - 1] + sumr[gor[i][z - 1]][z - 1];\n            }\n        }\n\n    for (int i = 1; i < n; ++i)\n        if ((gol[i][0] = findleft(i)) >= 0)\n        {\n            suml[i][0] = gol[i][0];\n            for (int z = 1; z < logn && gol[i][z - 1] >= 0; ++z)\n            {\n                gol[i][z] = gol[gol[i][z - 1]][z - 1];\n                suml[i][z] = suml[i][z - 1] + suml[gol[i][z - 1]][z - 1];\n            }\n        }\n\n    int q; cin >> q;\n    while (q--)\n    {\n        int l, r; cin >> l >> r; --l, --r;\n        int m = 1;\n        ll a = l;\n        for (int z = logn - 1, i = l; z >= 0; --z)\n            if (gor[i][z] <= r)\n            {\n                m += 1 << z;\n                a += sumr[i][z];\n                i = gor[i][z];\n            }\n        ll b = r;\n        for (int z = logn - 1, i = r; z >= 0; --z)\n            if (gol[i][z] >= l)\n            {\n                b += suml[i][z];\n                i = gol[i][z];\n            }\n        ll ans = b - a + m;\n        cout << ans << endl;\n    }\n\n    exit(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define y0 y12\n#define y1 y22\n#define INF 987654321\n#define PI 3.141592653589793238462643383279502884\n#define fup(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))\n#define fdn(i,a,b,c) for(int (i)=(a);(i)>=(b);(i)-=(c))\n#define MEM0(a) memset((a),0,sizeof(a));\n#define MEM_1(a) memset((a),-1,sizeof(a));\n#define ALL(a) a.begin(),a.end()\n#define SYNC ios_base::sync_with_stdio(false);cin.tie(0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ld, ld> Pd;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<db> Vd;\ntypedef vector<Pi> VPi;\ntypedef vector<Pll> VPll;\ntypedef vector<Pd> VPd;\ntypedef tuple<int, int, int> iii;\ntypedef tuple<int, int, int, int> iiii;\ntypedef tuple<ll, ll, ll> LLL;\ntypedef vector<iii> Viii;\ntypedef vector<LLL> VLLL;\ntypedef complex<double> base;\nconst int MOD = 1000000007;\nll POW(ll a, ll b, ll MMM = MOD) { ll ret = 1; for (; b; b >>= 1, a = (a*a) % MMM)if (b & 1)ret = (ret*a) % MMM; return ret; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\nll lcm(ll a, ll b) { if (a == 0 || b == 0)return a + b; return a*(b / gcd(a, b)); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1 }, dy[] = { 1,0,-1,0,1,-1,1,-1 };\nint ddx[] = { -1,-2,1,-2,2,-1,2,1 }, ddy[] = { -2,-1,-2,1,-1,2,1,2 };\n\nint a[200001],ne[200001][18],pr[200001][18];\nll Ls[200001][18],Rs[200001][18];\nint main() {\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfup(i,1,n,1)scanf(\"%d\",a+i);\n\tint t=1;\n\tfup(i,1,n,1){\n\t\twhile(t<=n && a[t]-a[i]<k)t++;\n\t\tne[i][0]=t;\n\t}\n\tt=n;\n\tfdn(i,n,1,1){\n\t\twhile(t>=0 && a[i]-a[t]<k)t--;\n\t\tpr[i][0]=t;\n\t}\n\tfup(j,0,16,1){\n\t\tfup(i,1,n,1){\n\t\t\tif(ne[i][j]<=n)ne[i][j+1]=ne[ne[i][j]][j];\n\t\t\tif(pr[i][j]>0)pr[i][j+1]=pr[pr[i][j]][j];\n\t\t}\n\t}\n\tfup(i,1,n,1){\n\t\tLs[i][0]=-(i-1);\n\t\tRs[i][0]=i;\n\t}\n\tfup(j,0,16,1){\n\t\tfup(i,1,n,1){\n\t\t\tif(ne[i][j]<=n)Ls[i][j+1]=Ls[i][j]+Ls[ne[i][j]][j];\n\t\t\tif(pr[i][j]>0)Rs[i][j+1]=Rs[i][j]+Rs[pr[i][j]][j];\n\t\t}\n\t}\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tint now=l;\n\t\tint cnt=0;\n\t\tfdn(j,17,0,1){\n\t\t\tif(ne[now][j]>0 && ne[now][j]<=r){\n\t\t\t\tcnt+=1<<j;\n\t\t\t\tnow=ne[now][j];\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tll ans=0;\n\t\tfdn(j,17,0,1){\n\t\t\tif(cnt&(1<<j)){\n\t\t\t\tans+=Ls[l][j]+Rs[r][j];\n\t\t\t\tl=ne[l][j],r=pr[r][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n#include<random>\n\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size() + (from == to)));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tif (d[j][i] != INF && d[i][k] != INF)chmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tvector<int> in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<int, vector<int>, greater<int>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tint n;\npublic:\n\tUnionFind(int size) : data(size, -1), n(size) { }\n\tbool merge(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tn -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint num() {//集合の数を返す\n\t\treturn n;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id, vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) {\n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll l[20][202020];\nll r[20][202020];\nll dp1[20][202020];\nll dp2[20][202020];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\n\tll n, k;\n\tcin >> n >> k;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tREP(i, n) l[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n\tREP(i, n) r[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\tREP(i, 19)REP(j, n)l[i + 1][j] = l[i][min(n - 1, l[i][j])];\n\tREP(i, 19)REP(j, n)r[i + 1][j] = r[i][max(0LL,r[i][j])];\n\tREP(i, n)dp1[0][i] = l[0][i];\n\tREP(i, n)dp2[0][i] = r[0][i];\n\tREP(i, 19)REP(j, n)dp1[i + 1][j] = dp1[i][j] + dp1[i][l[i][j]];\n\tREP(i, 19)REP(j, n)dp2[i + 1][j] = dp2[i][j] + dp2[i][r[i][j]];\n\tll q;\n\tcin >> q;\n\twhile (q--) {\n\t\tll L, R;\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tll ans = 1;\n\t\tll now = L;\n\t\tll x = L, y = R - 1;\n\t\tfor (int i = 19; i >= 0; i--) if (l[i][now] < R)ans += 1LL << i, x += dp1[i][now], now = l[i][now];\n\t\tnow = R - 1;\n\t\tfor (int i = 19; i >= 0; i--)if (r[i][now] >= L)y += dp2[i][now], now = r[i][now];\n\t\tcout << y - x +ans<< \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005, M = 21, inf = (int)2e9;\n\nint n, k, q, x[N];\nint fa1[N][M], fa2[N][M], Log2[N];\nlong long val1[N][M], val2[N][M];\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n\n\tx[0] = -inf, x[n + 1] = inf;\n\tfa1[n + 1][0] = n + 1, fa2[0][0] = 0;\n\tval1[n + 1][0] = 0, val2[0][0] = 0;\n\tLog2[1] = 0;\n\tfor (int i = 2; i <= n; i++) Log2[i] = Log2[i >> 1] + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfa1[i][0] = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tfa2[i][0] = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\tval1[i][0] = i, val2[i][0] = i + 1;\n\t}\n\tfor (int i = 1; i <= Log2[n]; i++) {\n\t\tfor (int j = 1; j <= n + 1; j++) {\n\t\t\tfa1[j][i] = fa1[fa1[j][i - 1]][i - 1];\n\t\t\tval1[j][i] = val1[j][i - 1] + val1[fa1[j][i - 1]][i - 1];\n\t\t}\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfa2[j][i] = fa2[fa2[j][i - 1]][i - 1];\n\t\t\tval2[j][i] = val2[j][i - 1] + val2[fa2[j][i - 1]][i - 1];\n\t\t}\n\t}\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tint l, r, L, R;\n\t\tlong long ans = 0;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tL = l, R = r;\n\t\tfor (int j = Log2[n - l + 1]; j >= 0; j--) {\n\t\t\tif (fa1[L][j] <= r) ans -= val1[L][j], L = fa1[L][j];\n\t\t}\n\t\tans -= val1[L][0];\n\t\tfor (int j = Log2[r]; j >= 0; j--) {\n\t\t\tif (fa2[R][j] >= l) ans += val2[R][j], R = fa2[R][j];\n\t\t}\n\t\tans += val2[R][0];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<atcoder/all>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt k;\n\nstruct Val{\n    Int nxt;\n    Int sum;\n    Val():nxt(0), sum(0){}\n};\n\nstruct calculator{\n    Int n;\n    vector<Int> nums;\n    vector<vector<Val>> nxts;\n    calculator(vector<Int> nums):nums(nums), n(nums.size()), nxts(n, vector<Val>(30)){\n        for(Int l = 0, r = 0;l < n;l++){\n            while(r < n && nums[r] < nums[l] + k)r++;\n            nxts[l][0].nxt = r;\n            nxts[l][0].sum = r;\n        }\n        for(Int h = 1;h < 30;h++){\n            for(Int i = 0;i < n;i++){\n                nxts[i][h] = nxts[i][h-1];\n                Int nxt_ind = nxts[i][h].nxt;\n                if(nxt_ind != n){\n                    nxts[i][h].nxt = nxts[nxt_ind][h-1].nxt;\n                    nxts[i][h].sum += nxts[nxt_ind][h-1].sum;\n                }\n            }\n        }\n    }\n\n    Int go(Int l, Int cnt){\n        for(Int h = 30;h >= 0;h--){\n            if(cnt < (1 << h))continue;\n            l = nxts[l][h].nxt;\n            if(l == n)return n;\n            cnt -= (1 << h);\n        }\n        return l;\n    }\n\n    Int sum(Int l, Int cnt){\n        Int ans = l;        \n        for(Int h = 30;h >= 0;h--){\n            if(cnt < (1 << h))continue;\n            ans += nxts[l][h].sum;\n            l = nxts[l][h].nxt;\n            cnt -= (1 << h);\n        }        return ans;\n    }\n    \n};\n\nint main(){\n    Int n, q;\n    cin >> n >> k;\n    vector<Int> X(n), Y(n);\n    for(Int i = 0;i < n;i++){\n        cin >> X[i];\n        Y[n-i-1] = MOD - X[i];\n    }\n\n    calculator x(X), y(Y);\n    \n    cin >> q;\n    for(Int i = 0;i < q;i++){\n        Int l, r;\n        cin >> l >> r;l--,r--;\n        Int bottom = 0, top = n;\n        while(top - bottom > 1){\n            Int mid = (top + bottom) / 2;\n            if(x.go(l, mid) <= r)bottom = mid;\n            else top = mid;\n        }\n        Int cnt = bottom + 1;\n        cout << ((n-1) * cnt - y.sum(n-r-1, cnt-1)) -  x.sum(l, cnt-1) +  cnt << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  vector<int> x(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  vector<vector<int>> to_lef(32 - __builtin_clz(n)), to_rig(32 - __builtin_clz(n));\n  vector<vector<long long>> sum_lef(32 - __builtin_clz(n)), sum_rig(32 - __builtin_clz(n));\n  for (int i = 0, j = -1; i < n; ++i) {\n    while (j + 1 < n && x[i] - x[j + 1] >= k) ++j;\n    to_lef[0].push_back(j); \n    sum_lef[0].push_back(i);\n  }\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < n && x[j] - x[i] < k) ++j;\n    to_rig[0].push_back(j);\n    sum_rig[0].push_back(i-1);\n  }\n  for (int i = 0; i + 1 < (int)to_lef.size(); ++i) {\n    to_lef[i+1].resize(n);\n    sum_lef[i+1].resize(n);\n    for (int j = 0; j < n; ++j) {\n      int now = to_lef[i][j];\n      long long sum = sum_lef[i][j];\n      if (now != -1) {\n        sum += sum_lef[i][now];\n        now = to_lef[i][now];\n      }\n      to_lef[i+1][j] = now;\n      sum_lef[i+1][j] = sum;\n    }\n  }\n  for (int i = 0; i + 1 < (int)to_rig.size(); ++i) {\n    to_rig[i+1].resize(n);\n    sum_rig[i+1].resize(n);\n    for (int j = 0; j < n; ++j) {\n      int now = to_rig[i][j];\n      long long sum = sum_rig[i][j];\n      if (now < n) {\n        sum += sum_rig[i][now];\n        now = to_rig[i][now];\n      }\n      to_rig[i+1][j] = now;\n      sum_rig[i+1][j] = sum;\n    }\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    --l, --r;\n    long long ans = 0;\n    int now = r;\n    for (int i = (int) to_lef.size()-1; i >= 0; --i) {\n      if (to_lef[i][now] >= l) {\n        ans += sum_lef[i][now];\n        now = to_lef[i][now];\n      }\n    }\n    ans += now;\n    now = l;\n    for (int i = (int) to_rig.size()-1; i >= 0; --i) {\n      if (to_rig[i][now] <= r) {\n        ans -= sum_rig[i][now];\n        now = to_rig[i][now];\n      }\n    }\n    ans -= now - 1;\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL K;\nLL X[200011];\n\nconst int LOG = 18;\nint Right[LOG][200011];\nint RightCnt[LOG][200011];\nLL RightSum[LOG][200011];\n\nint Left[LOG][200011];\nint LeftCnt[LOG][200011];\nLL LeftSum[LOG][200011];\n\nvoid MAIN() {\n    scanf(\"%d%lld\", &N, &K);\n    REP (i, N) scanf(\"%lld\", X+i);\n\n    for (int i=0, j=0; i<N; i++) {\n\twhile (j < N && X[j] - X[i] < K) j++;\n\tRight[0][i] = j;\n\tRightCnt[0][i] = j - i;\n\tRightSum[0][i] = j - i;\n    }\n\n    Right[0][N] = N;\n    REP (t, LOG-1) {\n\tREP (i, N+1) {\n\t    int s = Right[t][i];\n\t    Right[t+1][i] = Right[t][s];\n\t    RightCnt[t+1][i] = RightCnt[t][i] + RightCnt[t][s];\n\t    RightSum[t+1][i] = RightSum[t][i] + RightSum[t][s] + (RightCnt[t][s] << t);\n\t}\n    }\n\n    for (int i=N-1, j=N-1; i>=0; i--) {\n\twhile (j >= 0 && X[i] - X[j] < K) j--;\n\tLeft[0][i] = j;\n\tLeftCnt[0][i] = i - j;\n\tLeftSum[0][i] = i - j;\n    }\n    REP (t, LOG-1) {\n\tREP (i, N) {\n\t    int s = Left[t][i];\n\t    if (s == -1) {\n\t\tLeft[t+1][i] = -1;\n\t\tLeftCnt[t+1][i] = LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][i];\n\t    } else {\n\t\tLeft[t+1][i] = Left[t][s];\n\t\tLeftCnt[t+1][i] = LeftCnt[t][s] + LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][s] + LeftSum[t][i] + (LeftCnt[t][i] << t);\n\t    }\n\t}\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n    REP ($, Q) {\n\tint L, R;\n\tscanf(\"%d%d\", &L, &R);\n\tL--;\n\n\tLL ans = 0;\n\t{\n\t    int cur = L;\n\t    LL mult = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Right[t][cur];\n\t\tif (s != N && s <= R) {\n\t\t    sum += RightSum[t][cur] + RightCnt[t][cur] * mult;\n\t\t    mult += 1LL<<t;\n\t\t    cur = s;\n\t\t}\n\t    }\n\t    sum += (R - cur) * (mult + 1);\n\n\t    ans += sum;\n\t}\n\n\t{\n\t    int cur = R-1;\n\t    LL cnt = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Left[t][cur];\n\t\tif (L <= s) {\n\t\t    sum += LeftSum[t][cur] + cnt * (1LL<<t);\n\t\t    cnt += LeftCnt[t][cur];\n\t\t    cur = s;\n\t\t}\n\t    }\n\n\t    ans -= sum;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n#include <atcoder/mincostflow>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\ntypedef pair<ll, bool> Pb;\ntypedef pair<ll, vector<ll>> Pd;\n\nconst ll INF = 3e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll, vector<ll>, greater<ll> > pqls;\npriority_queue <P, vector<P>, greater<P> > pqps;\n//small priority queue\n//top pop\n\nll dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nll dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};\n//↓,→,↑,←\n\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n#undef endl\n#endif\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)();\n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> mat;\n\nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll m = mod) {ll x = 1; while (b) {while (!(b & 1)) {(a *= a) %= m; b >>= 1;}(x *= a) %= m; b--;} return x;}\nvec readvec(ll read) { vec res(read); for (int i = 0; i < read; i++) { cin >> res[i]; } return res;}\nvoid YES(bool cond) { if (cond) { p(\"YES\");} else { p(\"NO\");} return;}\nvoid Yes(bool cond) { if (cond) { p(\"Yes\");} else { p(\"No\");} return;}\nvoid line() { p(\"--------------------\"); return;}\n\n/*\nll fact[fact_table + 5], rfact[fact_table + 5];\n\nvoid c3_init() {\n    fact[0] = rfact[0] = 1;\n    for (ll i = 1; i <= fact_table; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table], mod - 2, mod);\n    for (ll i = fact_table; i >= 1; i--) {\n        rfact[i - 1] = rfact[i] * i;\n        rfact[i - 1] %= mod;\n    }\n    return;\n}\nll c3(ll n, ll r) {\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n - r]) % mod;\n}\n*/\n\nstruct Timer {\n    int64_t start; const int64_t CYCLES_PER_SEC = 2800000000;\n    Timer() { reset(); }\n    void reset() { start = getCycle(); }\n    inline double get() { return (double)(getCycle() - start) / CYCLES_PER_SEC; }\n    inline int64_t getCycle() {\n        uint32_t low, high; __asm__ volatile (\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n        return ((int64_t)low) | ((int64_t)high << 32);\n    }\n};\n\nbool multicase = false;\n\nll n, k;\nll x[200005], toright[200005][65], toleft[200005][65];\nll torightvalue[200005][65], toleftvalue[200005][65];\n\nvoid precalc() {\n    set<P> st;\n    for (int i = 1; i <= n; i++) {\n        st.insert(P(x[i], i));\n    }\n\n    // 番兵\n    st.insert(P(INF, INF));\n    st.insert(P(-INF, -INF));\n\n    for (int i = 1; i <= n; i++) {\n        ll right = (*st.lower_bound(P(x[i] + k, -INF))).second;\n        toright[i][0] = right;\n        torightvalue[i][0] = (right != INF) ? i : i;\n\n        auto ite = st.lower_bound(P(x[i] - k + 1, -INF));\n        ite --;\n        ll left = (*ite).second;\n        toleft[i][0] = left;\n        toleftvalue[i][0] = (left != -INF) ? i + 1: i + 1;\n    }\n\n\n    for (int j = 1; j <= n; j++) {\n        for (int i = 0; i < 60; i++) {\n\n            if (toright[j][i] == INF) {\n                toright[j][i + 1] = INF;\n            } else {\n                toright[j][i + 1] = toright[toright[j][i]][i];\n                torightvalue[j][i + 1] = torightvalue[j][i] + torightvalue[toright[j][i]][i];\n            }\n\n            if (toleft[j][i] == -INF) {\n                toleft[j][i + 1] = -INF;\n            } else {\n                toleft[j][i + 1] = toleft[toleft[j][i]][i];\n                toleftvalue[j][i + 1] = toleftvalue[j][i] + toleftvalue[toleft[j][i]][i];\n            }\n        }\n    }\n\n\n}\n\nvoid solve() {\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n    precalc();\n    ll q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        ll l, r;\n        cin >> l >> r;\n        ll il = l, ir = r;\n        ll haba = 59;\n        ll ans = 0;\n        while (true) {\n            // haba進んでも大丈夫なら進む\n            if (toleft[r][haba] >= il && toright[l][haba] <= ir) {\n                ans += toleftvalue[r][haba] - torightvalue[l][haba];\n                l = toright[l][haba];\n                r = toleft[r][haba];\n            } else {\n                if (haba == 0) {\n                    break;\n                } else {\n                    haba --;\n                }\n            }\n        }\n        /*\n        p(ans);\n        pe(l);p(r);\n        pe(toleftvalue[r][0]);\n        p(torightvalue[l][0]);\n        */\n        ans += toleftvalue[r][0] - torightvalue[l][0];\n        p(ans);\n    }\n\n    return;\n}\n\nint main() {\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    ll q, testcase = 1;\n    if (multicase) {\n        cin >> q;\n    } else {\n        q = 1;\n    }\n    while (q--) {\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n\n    // solve();\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define send {ios_base::sync_with_stdio(false);}\n#define help {cin.tie(NULL); cout.tie(NULL);}\n#define f first\n#define s second\n#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}\ntypedef long long ll;\ntypedef long double lld;\ntypedef unsigned long long ull;\n \ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n\tcout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n\tcin >> p.first;\n\treturn cin >> p.second;\n}\n \nmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n// mt19937 rng(61378913);\n/* usage - just do rng() */\n \nvoid usaco(string filename) {\n  // #pragma message(\"be careful, freopen may be wrong\")\n\tfreopen((filename + \".in\").c_str(), \"r\", stdin);\n\tfreopen((filename + \".out\").c_str(), \"w\", stdout);\n}\n\n#include <atcoder/all>\nusing namespace atcoder;\n \nconst lld pi = 3.14159265358979323846;\n// const ll mod = 1000000007;\n// const ll mod = 998244353;\n// ll mod;\n \nstruct lca_lift {\n  const int lg = 24;\n  int n;\n  vector<int> depth;\n  vector<vector<int> > edges;\n  vector<vector<int> > lift;\n  vector<vector<ll> > sum;\n  \n  void init(int sz) {\n    n = sz;\n    depth = vector<int>(n);\n    edges = vector<vector<int> >(n, vector<int>());\n    sum = vector<vector<ll> >(n, vector<ll>(lg, 0));\n    lift = vector<vector<int> >(n, vector<int>(lg, -1));\n  }\n\n  void edge(int a, int b) {\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n\n  void init_lift(int v = 0) {\n    depth[v] = 0;\n    dfs(v, -1);\n  }\n\n  void dfs(int v, int par) {\n    lift[v][0] = par;\n\tsum[v][0] = v;\n\n    for (int i = 1; i < lg; i++) {\n      if (lift[v][i - 1] == -1) {\n\t\t  lift[v][i] = -1;\n\t\t  sum[v][i] = 0;\n\t  } else {\n\t\t  lift[v][i] = lift[lift[v][i - 1]][i - 1];\n\t\t  sum[v][i] = sum[v][i - 1] + sum[lift[v][i - 1]][i - 1];\n\t  }\n    }\n\n    for (int x: edges[v]) {\n      if (x != par) {\n        depth[x] = depth[v] + 1;\n        dfs(x, v);\n      }\n    }\n  }\n\n  int get_min(int v, int r) {\n\tint d = 0;\n    for (int i = lg - 1; i >= 0; i--) {\n      if (lift[v][i] != -1 && lift[v][i] <= r) {\n        v = lift[v][i];\n        d += (1 << i);\n      }\n    }\n    return d;\n  }\n  \n  ll get_sum(int v, int k) {\n\tll s = 0;\n\t// cout << sum << '\\n';\n    for (int i = lg - 1; i >= 0; i--) {\n\t\t// cout << v << \" \" << i << \" \" << s << \" \" << k << \" \" << lift[v][i] << \" \" << sum[v][i] << endl;\n      if ((1 << i) <= k) {\n\t\t  // cout << \"WHAT \" << v << \" \" << i << \" \" << s << \" \" << k << \" \" << lift[v][i] << \" \" << sum[v][i] << endl;\n\t\ts += sum[v][i];\n        v = lift[v][i];\n        k -= (1 << i);\n\t\t// cout << \"WHAT \" << v << \" \" << i << \" \" << s << \" \" << k << \" \" << lift[v][i] << \" \" << sum[v][i] << endl;\n      }\n    }\n    return s;\n  }\n};\n\nll n, m, k, q, l, r, x, y, z;\nconst ll template_array_size = 1e6 + 1531;\nll a[template_array_size];\nll b[template_array_size];\nll c[template_array_size];\nstring s, t;\nll ans = 0;\n\nll par[200005];\nlca_lift le, ri; // le - to the left, edges going right\n\nvoid solve(int tc = 0) {\n\tcin >> n >> k;\n\t\n\tfor (ll i = 0; i < n; i++) cin >> a[i];\n\t\n\tle.init(n);\n\tri.init(n);\n\t\n\tfor (ll i = 0; i < n; i++) par[i] = -1;\n\t\n\tll lpt = 0;\n\tfor (ll i = 0; i < n; i++) {\n\t\twhile (lpt < n && a[lpt] - a[i] < k) ++lpt;\n\t\t\n\t\tif (lpt < n) {\n\t\t\tpar[i] = lpt;\n\t\t\tle.edge(i, lpt);\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tif (par[i] == -1) {\n\t\t\tle.init_lift(i);\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) par[i] = -1;\n\t\n\tll rpt = n - 1;\n\tfor (ll i = n - 1; i >= 0; i--) {\n\t\twhile (rpt >= 0 && a[i] - a[rpt] < k) --rpt;\n\t\t\n\t\tif (rpt >= 0) {\n\t\t\tpar[i] = rpt;\n\t\t\tri.edge(i, rpt);\n\t\t\t// cout << i << \" \" << rpt << '\\n';\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tif (par[i] == -1) {\n\t\t\tri.init_lift(i);\n\t\t}\n\t}\n\t\n\tcin >> q;\n\t\n\tfor (ll i = 0; i < q; i++) {\n\t\tcin >> l >> r;\n\t\t--l; --r;\n\t\t\n\t\tll d = le.get_min(l, r) + 1;\n\t\t\t\t\n\t\tll s1 = le.get_sum(l, d);\n\t\tll s2 = ri.get_sum(r, d);\n\t\t\n\t\t// cout << d << \" \" << s1 << \" \" << s2 << '\\n';\n\t\t\n\t\tcout << s2 - s1 + d << '\\n';\n\t}\n}\n \nint main() {\n\t#ifdef galen_colin_local\n\t\tauto begin = std::chrono::high_resolution_clock::now();\n\t#endif\n\t\n\tsend help\n \n\t#ifndef galen_colin_local\n\t\t// usaco(\"moop\");\n\t#endif\n\t\n\t// usaco(\"cowland\");\n\t\n\t// freopen(\"tc.cpp\", \"r\", stdin);\n \n\t\n\t\n\tint tc = 1;\n\t// cin >> tc;\n\tfor (int t = 0; t < tc; t++) solve(t);\n\t\n\t#ifdef galen_colin_local\n\t\tauto end = std::chrono::high_resolution_clock::now();\n\t\tcout << setprecision(4) << fixed;\n\t\t// cout << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;\n\t#endif\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\n#define F first\n#define S second\n#define RE register\n#define random(x) (rand()%x)\n#define LOG(a,b) (log(a)/log(b))\n#define N 200005\n#define mod 1000000007\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3fll\nint n,lgn,q,k,x[N],lp[22][N],rp[22][N];\nll lsz[22][N],rsz[22][N];\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tlgn=log2(n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",x+i);\n\t}\n\tfor(int i=0;i<=lgn;++i) rp[i][n+1]=n+1;\n\tfor(int i=1;i<=n;++i){\n\t\tlp[0][i]=lower_bound(x+1,x+n+1,x[i]-k+1)-x-1;\n\t\tlsz[0][i]=lp[0][i];\n\t\t//printf(\"(%d:%d,%lld) \",0,lp[0][i],lsz[0][i]);\n\t\tfor(int j=1;j<=lgn;++j){\n\t\t\tlp[j][i]=lp[j-1][lp[j-1][i]];\n\t\t\tlsz[j][i]=lsz[j-1][i]+lsz[j-1][lp[j-1][i]];\n\t\t\t//printf(\"(%d:%d,%lld) \",j,lp[j][i],lsz[j][i]);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tfor(int i=n;i;--i){\n\t\trp[0][i]=lower_bound(x+1,x+n+1,x[i]+k)-x;\n\t\trsz[0][i]=rp[0][i];\n\t\tfor(int j=1;j<=lgn;++j){\n\t\t\trp[j][i]=rp[j-1][rp[j-1][i]];\n\t\t\trsz[j][i]=rsz[j-1][i]+rsz[j-1][rp[j-1][i]];\n\t\t\t//printf(\"(%d:%d,%lld) \",j,rp[j][i],rsz[j][i]);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tscanf(\"%d\",&q);\n\tint ql,qr,p,cntl=1,cntr=1;\n\tll ansl=0,ansr=0;\n\tfor(int i=1;i<=q;++i){\n\t\tscanf(\"%d%d\",&ql,&qr);\n\t\tp=ql;ansl=ql;cntl=1;\n\t\tfor(int j=lgn;j>=0;--j){\n\t\t\tif(rp[j][p]<=qr){\n\t\t\t\tcntl+=(1<<j);\n\t\t\t\tansl+=rsz[j][p];\n\t\t\t\tp=rp[j][p];\n\t\t\t}\n\t\t\t//printf(\"%d:%d %d\\n\",j,p,ansl);\n\t\t}\n\t\tp=qr;ansr=qr;cntr=1;\n\t\tfor(int j=lgn;j>=0;--j){\n\t\t\tif(lp[j][p]>=ql){\n\t\t\t\tcntr+=(1<<j);\n\t\t\t\tansr+=lsz[j][p];\n\t\t\t\tp=lp[j][p];\n\t\t\t}\n\t\t\t//printf(\"%d:%d %d\\n\",j,p,ansr);\n\t\t}\n\t\t//printf(\"%d %d\\n\",cntl,cntr);\n\t\tassert(cntl==cntr);\n\t\tprintf(\"%lld\\n\",ansr-ansl+cntl);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#include <atcoder/all>\n#define popcount __builtin_popcount\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; ll k;\n    cin>>n>>k;\n    int x[200020];\n    for(int i=0; i<n; i++){\n        cin>>x[i];\n    }\n    int nx[20][200020], nxr[20][200020];\n    ll sl[20][200020], sr[20][200020];\n    nx[0][n]=n;\n    nxr[0][0]=0;\n    for(int i=0; i<n; i++){\n        nx[0][i]=lower_bound(x, x+n, x[i]+k)-x;\n        sl[0][i]=nx[0][i];\n        nxr[0][i+1]=upper_bound(x, x+n, x[i]-k)-x;\n        sr[0][i+1]=nxr[0][i+1];\n    }\n    for(int i=1; i<20; i++){\n        for(int j=0; j<=n; j++){\n            nx[i][j]=nx[i-1][nx[i-1][j]];\n            sl[i][j]=sl[i-1][j]+sl[i-1][nx[i-1][j]];\n            nxr[i][j]=nxr[i-1][nxr[i-1][j]];\n            sr[i][j]=sr[i-1][j]+sr[i-1][nxr[i-1][j]];\n        }\n    }\n    int q; cin>>q;\n    while(q--){\n        int l, r; cin>>l>>r;\n        l--; r--;\n        if(l==r){\n            cout<<1<<endl;\n            continue;\n        }\n        ll suml=0, sumr=0;\n        int c=0;\n        int l1=l;\n        for(int i=19; i>=0; i--){\n            if(nx[i][l1]<=r){\n                c+=(1<<i);\n                suml+=sl[i][l1];\n                l1=nx[i][l1];\n            }\n        }\n        int r1=r+1;\n        for(int i=19; i>=0; i--){\n            if(nxr[i][r1]>=l+1){\n                sumr+=sr[i][r1];\n                r1=nxr[i][r1];\n            }\n        }\n        cout<<sumr-suml+r+1-l<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nint n,k,l,r,nxt[20][200005],pre[20][200005],q,x[200005],gl,gr;\nll sump[20][200005],sumn[20][200005],ans0,ans1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tnxt[0][n+1]=n+1;\n\tpre[0][n+1]=n;\n\tpre[0][0]=0;\n\tnxt[0][0]=1;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&x[i]);\n\tx[0]=-1e9;x[n+1]=2e9;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpre[0][i]=upper_bound(x+1,x+n+1,x[i]-k)-x-1;\n\t\tnxt[0][i]=lower_bound(x+1,x+n+1,x[i]+k)-x;\n\t\tsump[0][i]=pre[0][i];\n\t\tsumn[0][i]=nxt[0][i];\n\t}\n\tfor(int i=1;i<20;i++)\n\t{\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t{\n\t\t\tpre[i][j]=pre[i-1][pre[i-1][j]];\n\t\t\tsump[i][j]=sump[i-1][j]+sump[i-1][pre[i-1][j]];\n\t\t\tnxt[i][j]=nxt[i-1][nxt[i-1][j]];\n\t\t\tsumn[i][j]=sumn[i-1][j]+sumn[i-1][nxt[i-1][j]];\n\t\t\t//printf(\"%d %d %d\\n\",i,j,nxt[i][j]);\n\t\t}\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tgl=l;gr=r;\n\t\tans0=0;ans1=r-l;\n\t\tfor(int i=19;i>=0;i--)\n\t\t{\n\t\t\t//printf(\"%d %d %d\\n\",i,nxt[i][gl],r);\n\t\t\tif(nxt[i][gl]<=r)\n\t\t\t{\n\t\t\t\tans0+=(1<<i);\n\t\t\t\tans1-=sumn[i][gl];\n\t\t\t\tans1+=sump[i][gr];\n\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,gl,gr,sumn[i][gl],sumn[i][gr]);\n\t\t\t\tgl=nxt[i][gl];\n\t\t\t\tgr=pre[i][gr];\n\t\t\t}\n\t\t}\n\t\tans1+=ans0+1;\n\t\tprintf(\"%lld\\n\",ans1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL K;\nLL X[200011];\n\nconst int LOG = 18;\nint Right[LOG][200011];\nLL RightCnt[LOG][200011];\nLL RightSum[LOG][200011];\n\nint Left[LOG][200011];\nLL LeftCnt[LOG][200011];\nLL LeftSum[LOG][200011];\n\nvoid MAIN() {\n    scanf(\"%d%lld\", &N, &K);\n    REP (i, N) scanf(\"%lld\", X+i);\n\n    for (int i=0, j=0; i<N; i++) {\n\twhile (j < N && X[j] - X[i] < K) j++;\n\tRight[0][i] = j;\n\tRightCnt[0][i] = j - i;\n\tRightSum[0][i] = j - i;\n    }\n\n    Right[0][N] = N;\n    REP (t, LOG-1) {\n\tREP (i, N+1) {\n\t    int s = Right[t][i];\n\t    Right[t+1][i] = Right[t][s];\n\t    RightCnt[t+1][i] = RightCnt[t][i] + RightCnt[t][s];\n\t    RightSum[t+1][i] = RightSum[t][i] + RightSum[t][s] + (RightCnt[t][s] << t);\n\t}\n    }\n\n    for (int i=N-1, j=N-1; i>=0; i--) {\n\twhile (j >= 0 && X[i] - X[j] < K) j--;\n\tLeft[0][i] = j;\n\tLeftCnt[0][i] = i - j;\n\tLeftSum[0][i] = i - j;\n    }\n    REP (t, LOG-1) {\n\tREP (i, N) {\n\t    int s = Left[t][i];\n\t    if (s == -1) {\n\t\tLeft[t+1][i] = -1;\n\t\tLeftCnt[t+1][i] = LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][i];\n\t    } else {\n\t\tLeft[t+1][i] = Left[t][s];\n\t\tLeftCnt[t+1][i] = LeftCnt[t][s] + LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][s] + LeftSum[t][i] + (LeftCnt[t][i] << t);\n\t    }\n\t}\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n    REP ($, Q) {\n\tint L, R;\n\tscanf(\"%d%d\", &L, &R);\n\tL--;\n\n\tLL ans = 0;\n\t{\n\t    int cur = L;\n\t    LL mult = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Right[t][cur];\n\t\tif (s != N && s <= R) {\n\t\t    sum += RightSum[t][cur] + RightCnt[t][cur] * mult;\n\t\t    mult += 1LL<<t;\n\t\t    cur = s;\n\t\t}\n\t    }\n\t    sum += (R - cur) * (mult + 1);\n\n\t    ans += sum;\n\t}\n\n\t{\n\t    int cur = R-1;\n\t    LL cnt = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Left[t][cur];\n\t\tif (L <= s) {\n\t\t    sum += LeftSum[t][cur] + cnt * (1LL<<t);\n\t\t    cnt += LeftCnt[t][cur];\n\t\t    cur = s;\n\t\t}\n\t    }\n\n\t    ans -= sum;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 N, K;\n\tcin >> N >> K;\n\tvector<int64> X(N+1), X2(N+1);\n\tREP(i, N) {\n\t  cin >> X[i];\n\t  X2[N-i-1] = -X[i];\n\t}\n\tX[N] = X2[N] = INF_LL;\n\tint64 Q;\n\tcin >> Q;\n\n\tauto tor = make_v<int64>(N+1, 20), suml = make_v<int64>(N+1, 20);\n\tfill_v<int64>(tor, N);\n  fill_v<int64>(suml, 0);\n  auto tol = make_v<int64>(N+1, 20), sumr = make_v<int64>(N+1, 20);\n  fill_v<int64>(tol, N);\n  fill_v<int64>(sumr, 0);\n  REP(i, N) {\n    tor[i][0] = lower_bound(all(X), X[i] + K)- X.begin();\n    tol[i][0] = lower_bound(all(X2), X2[i] + K) -X2.begin();\n    suml[i][0] = lower_bound(all(X), X[i] + K)- X.begin();\n    sumr[i][0] = N - (tol[i][0]) - 1;\n  }\n  REP(i, 19) {\n    REP(j, N) {\n      tor[j][i + 1] = tor[tor[j][i]][i];\n      tol[j][i + 1] = tol[tol[j][i]][i];\n      suml[j][i + 1] = suml[j][i] + suml[tor[j][i]][i];\n      sumr[j][i + 1] = sumr[j][i] + sumr[tol[j][i]][i];\n    }\n  }\n\n  REP(_, Q) {\n    int64 L, R, L2, R2;\n    cin >> L >> R; L--; R--;\n    L2 = N-L-1; R2 = N-R-1;\n    int64 res = 0;\n    int64 ret = 1, ret2 = 1, nowl = L, nowl2 = R2, sumll = L, sumrr = R;\n    for (int64 i = 19; i >= 0; i--) {\n      if (tor[nowl][i] <= R) {\n        ret += 1 << i;\n        sumll += suml[nowl][i];\n        nowl = tor[nowl][i];\n      }\n      if (tol[nowl2][i] <= L2) {\n        ret2 += 1 << i;\n        sumrr += sumr[nowl2][i];\n        nowl2 = tol[nowl2][i];\n      }\n    }\n    chmax(res, ret);\n    chmax(res, ret2);\n    cout << sumrr - sumll + res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = (int) 2e5 + 7;\nconst int K = 18;\nint n;\nint dif;\nint q;\nint a[N];\nint u[K][N];\n\nint compute(int x, int lim)\n{\n    int sol = 1;\n    for (int k = K - 1; k >= 0; k--)\n    {\n        if (u[k][x] <= lim)\n        {\n            sol += (1 << k);\n            x = u[k][x];\n        }\n    }\n    return sol;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> dif;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    a[n + 1] = a[n] + dif;\n    int j = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        while (a[j] - a[i] < dif)\n        {\n            j++;\n        }\n        u[0][i] = j;\n    }\n    for (int k = 1; k < K; k++)\n    {\n        for (int i = 1; i <= n; i++)\n        {\n            if (u[k - 1][i] == n + 1)\n            {\n                u[k][i] = n + 1;\n            }\n            else\n            {\n                u[k][i] = u[k - 1][u[k - 1][i]];\n            }\n        }\n    }\n    cin >> q;\n    while (q--)\n    {\n        int l, r, best = 0, sol = 0;\n        cin >> l >> r;\n        best = compute(l, r);\n        for (int i = l; i <= r; i++)\n        {\n            if (compute(l, i) + compute(i, r) - 1 == best)\n            {\n                sol++;\n            }\n        }\n        cout << sol << \"\\n\";\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//引进常用的头文件并使用std名字空间;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//用于减少代码量的宏;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl(x) while (x)\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//调试相关的宏;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"第\"<<__LINE__<<\"行\\t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//常用数据类型;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char *cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int, int> pii;\ntypedef pr<lli, lli> pll;\ntypedef pr<db, db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int, int> mii;\ntypedef map<str, int> msi;\ntypedef map<char, int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//常用常量:int的最大值;lli的最大值;db的误差相关常数;欧拉常数;圆周率;移动向量;取模使用的除数;\nint oo = (~0u) >> 1;\nlli ooll = (~0ull) >> 1;\ndb inf = 1e+10;\ndb eps = 1e-10;\ndb gam = 0.5772156649015328606;\ndb pi = acos(-1.0);\nint dx[] = { 1, 0, -1, 0, 1, -1, -1, 1, 0 };\nint dy[] = { 0, 1, 0, -1, 1, 1, -1, -1, 0 };\nint MOD = 1000000007;\n\n//常用函数:最大最小值更新;数学相关函数;输入和输出;树状数组;并查集;可合并堆;\ntemplate<typename type> inline bool cmax(type &a, const type &b) {\n\trtn a < b ? a = b, true : false;\n}\ntemplate<typename type> inline bool cmin(type &a, const type &b) {\n\trtn b < a ? a = b, true : false;\n}\ntemplate<typename type> inline type sqr(const type &x) {\n\trtn x * x;\n}\ntemplate<typename type> inline type mod(const type &x) {\n\trtn x % MOD;\n}\ninline int sgn(const db &x) {\n\trtn (x > +eps) - (x < -eps);\n}\ninline int dbcmp(const db &a, const db &b) {\n\trtn sgn(a - b);\n}\ntemplate<typename type> inline pr<type, type> operator-(\n\t\tconst pr<type, type> &x) {\n\trtn mp(-x.x, -x.y);\n}\ntemplate<typename type> inline pr<type, type> operator+(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn mp(a.x + b.x, a.y + b.y);\n}\ntemplate<typename type> inline pr<type, type> operator-(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn mp(a.x - b.x, a.y - b.y);\n}\ntemplate<typename type> inline pr<type, type> operator*(const pr<type, type> &a,\n\t\tconst type &b) {\n\trtn mp(a.x * b, a.y * b);\n}\ntemplate<typename type> inline pr<type, type> operator/(const pr<type, type> &a,\n\t\tconst type &b) {\n\trtn mp(a.x / b, a.y / b);\n}\ntemplate<typename type> inline pr<type, type>& operator-=(pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a = a - b;\n}\ntemplate<typename type> inline pr<type, type>& operator+=(pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a = a + b;\n}\ntemplate<typename type> inline pr<type, type>& operator*=(pr<type, type> &a,\n\t\tconst type &b) {\n\trtn a = a * b;\n}\ntemplate<typename type> inline pr<type, type>& operator/=(pr<type, type> &a,\n\t\tconst type &b) {\n\trtn a = a / b;\n}\ntemplate<typename type> inline type cross(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a.x * b.y - a.y * b.x;\n}\ntemplate<typename type> inline type dot(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a.x * b.x + a.y * b.y;\n}\ntemplate<typename type> inline type gcd(type a, type b) {\n\tif (b)\n\t\twhl((a %= b) && (b %= a));\n\trtn a + b;\n}\ntemplate<typename type> inline type lcm(type a, type b) {\n\trtn a * b / gcd(a, b);\n}\ninline lli bin_pow(lli x, lli y) {\n\tlli z = 1;\n\twhl(y) {\n\t\tif (y & 1)\n\t\t\tz = mod(z * x);\n\t\tx = mod(sqr(x)), y >>= 1;\n\t}\n\trtn z;\n}\ntemplate<typename istream, typename first_type, typename second_type> inline istream& operator>>(\n\t\tistream &cin, pr<first_type, second_type> &x) {\n\trtn cin >> x.x >> x.y;\n}\ntemplate<typename ostream, typename first_type, typename second_type> inline ostream& operator<<(\n\t\tostream &cout, const pr<first_type, second_type> &x) {\n\trtn cout << x.x << \" \" << x.y;\n}\ntemplate<typename istream, typename type> inline istream& operator>>(\n\t\tistream &cin, vec<type> &x) {\n\trep(i,sz(x))\n\t\tcin >> x[i];\n\trtn cin;\n}\ntemplate<typename ostream, typename type> inline ostream& operator<<(\n\t\tostream &cout, const vec<type> &x) {\n\trep(i,sz(x))\n\t\tcout << x[i] << (i + 1 == sz(x) ? \"\" : \" \");\n\trtn cout;\n}\ninline ostream& pdb(int prcs, db x) {\n\trtn cout << setprecision(prcs) << fixed << (sgn(x) ? (x) : 0);\n}\ntemplate<typename type> inline void bit_inc(vec<type> &st, int x, type inc) {\n\twhl(x<sz(st))\n\t\tst[x] += inc, x |= x + 1;\n}\ntemplate<typename type> inline type bit_sum(const vec<type> &st, int x) {\n\ttype s = 0;\n\twhl(x>=0)\n\t\ts += st[x], x = (x & (x + 1)) - 1;\n\trtn s;\n}\ntemplate<typename type> inline type bit_kth(const vec<type> &st, int k) {\n\tint x = 0, y = 0, z = 0;\n\twhl((1<<(++y))<=sz(st));\n\trrep(i,y)\n\t{\n\t\tif ((x += 1 << i) > sz(st) || z + st[x - 1] > k)\n\t\t\tx -= 1 << i;\n\t\telse\n\t\t\tz += st[x - 1];\n\t}\n\trtn x;\n}\ninline void make_set(vi &st) {\n\trep(i,sz(st))\n\t\tst[i] = i;\n}\ninline int find_set(vi &st, int x) {\n\tint y = x, z;\n\twhl(y!=st[y])\n\t\ty = st[y];\n\twhl(x!=st[x])\n\t\tz = st[x], st[x] = y, x = z;\n\trtn y;\n}\ninline bool union_set(vi &st, int a, int b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ? st[a] = b, true : false;\n}\ninline void make_set(vpii &st) {\n\trep(i,sz(st))\n\t\tst[i] = mp(i, 1);\n}\ninline int find_set(vpii &st, int x) {\n\tint y = x, z;\n\twhl(y!=st[y].x)\n\t\ty = st[y].x;\n\twhl(x!=st[x].x)\n\t\tz = st[x].x, st[x].x = y, x = z;\n\trtn y;\n}\ninline bool union_set(vpii &st, int a, int b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ?\n\t\t\t(st[a].y > st[b].y ? st[a].x = b, st[a].y += st[b].y : st[b].x = a, st[b].y +=\n\t\t\t\t\tst[a].y), true :\n\t\t\tfalse;\n}\ntemplate<typename type> inline void merge(type &a, type &b) {\n\tif (sz(a) < sz(b))\n\t\tswap(a, b);\n\twhl(sz(b))\n\t\ta.ins(*b.begin()), b.ers(b.begin());\n}\n\n//初始化;\nstruct Initializer {\n#ifndef DEBUG\n\tInitializer() {\n\t\tios::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t\tcout.tie(0);\n\t}\n#else\n\t~Initializer() {\n\t\truntime();\n\t}\n#endif\n} initializer;\n\n//非标准;\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx ::rope<char> rope;\ntemplate<typename key, typename value> class ext_map: public __gnu_pbds::tree<\n\t\tkey, value, less<key>, __gnu_pbds ::rb_tree_tag,\n\t\t__gnu_pbds ::tree_order_statistics_node_update> {\n};\ntemplate<typename key> class ext_set: public __gnu_pbds::tree<key,\n\t\t__gnu_pbds ::null_type, less<key>, __gnu_pbds ::rb_tree_tag,\n\t\t__gnu_pbds ::tree_order_statistics_node_update> {\n};\n\ninline pii find_set(map<pii, pii> &st, pii x) {\n\tif (!st.count(x)) {\n\t\trtn st[x] = x;\n\t} else if (st[x] == x) {\n\t\trtn x;\n\t} else {\n\t\trtn st[x] = find_set(st, st[x]);\n\t}\n}\ninline bool union_set(map<pii, pii> &st, pii a, pii b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ? st[a] = b, true : false;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tvi x(n + 1);\n\tft(i,1,n)\n\t\tcin >> x[i];\n\n\tvvi pre(20, vi(n + 1)), suf(20, vi(n + 1));\n\tauto index = [&](vvi &pre, vi &x) {\n\t\tint j = 0;\n\t\tft(i,1,n)\n\t\t{\n\t\t\twhile (abs(x[i] - x[j + 1]) >= k) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tpre[0][i] = j;\n\t\t\trepf(j,1,20)\n\t\t\t{\n\t\t\t\tpre[j][i] = pre[j - 1][pre[j - 1][i]];\n\t\t\t}\n\t\t}\n\t};\n\tindex(pre, x);\n\treverse(x.begin() + 1, x.end());\n\tindex(suf, x);\n\tint q;\n\tcin >> q;\n\trep(i,q)\n\t{\n\t\tauto get = [](vvi &pre, int l, int r) {\n\t\t\tint ans = 0;\n\t\t\trrep(i,20)\n\t\t\t{\n\t\t\t\tif (pre[i][r] >= l) {\n\t\t\t\t\tans += 1 << i;\n\t\t\t\t\tr = pre[i][r];\n\t\t\t\t}\n\t\t\t}\n\t\t\trtn ans;\n\t\t};\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint s = get(pre, l, r), ans = 0;\n\t\tprt(s);\n\t\tvi lst;\n\t\tft(x,l,r)\n\t\t{\n\t\t\tif (get(pre, l, x) + get(suf, n - r + 1, n - x + 1) == s) {\n\t\t\t\tans++;\n\t\t\t\tlst.pb(x);\n\t\t\t}\n\t\t}\n//\t\tcout << lst << endl;\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n{By GWj\n*/\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define fastio ios::sync_with_stdio(false)\n#define R(a) cin>>a\n#define R2(a,b) cin>>a>>b\n#define check_min(a,b) a=min(a,b)\n#define check_max(a,b) a=max(a,b)\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\n/*}\n*/\nint n,k,x[200000+20],q,f[200000+20][19],ff[200000+20][19];\nLL s[200000+20][19],ss[200000+20][19];\nLL solve(int l,int r){\n\tint can=0;\n\tint now=l;\n\trl(i,18,0)\n\t\tif(f[now][i]<=r) now=f[now][i],can|=1<<i;\n\tif(can==0) return r-l+1;\n\tLL one,two;\n\tone=two=0;\n\tnow=l;\n\trl(i,18,0)\n\t\tif((can>>i)&1){\n\t\t\tone+=s[now][i];\n\t\t\tnow=f[now][i];\t\n\t\t}\n\tnow=r;\n\trl(i,18,0)\n\t\tif((can>>i)&1){\n\t\t\ttwo+=ss[now][i];\n\t\t\tnow=ff[now][i];\n\t\t}\n\tone+=l;\n\ttwo+=r;\n\treturn two-one+can+1;\n}\nint main(){\n\tfastio;\n\tR2(n,k);\n\trb(i,1,n)\n\t\tR(x[i]);\n\trb(i,1,n+1)\n\t\tfill(f[i],f[i]+19,n+1);\n\tint is=n+1;\n\trl(i,n,1){\n\t\twhile(x[is-1]-x[i]>=k){\n\t\t\tis--;\n\t\t}\n\t\tf[i][0]=is;\n\t\ts[i][0]=is;\n\t}\n\tis=0;\n\trb(i,1,n){\n\t\twhile(x[i]-x[is+1]>=k){\n\t\t\tis++;\n\t\t}\n\t\tff[i][0]=is;\n\t\tss[i][0]=is;\n\t}\n\trb(i,1,18)\n\t\trb(j,1,n)\n\t\t\tf[j][i]=f[f[j][i-1]][i-1],ff[j][i]=ff[ff[j][i-1]][i-1],s[j][i]=s[f[j][i-1]][i-1]+s[j][i-1],ss[j][i]=ss[ff[j][i-1]][i-1]+ss[j][i-1];\n\tR(q);\n\twhile(q--){\n\t\tint l,r;\n\t\tR2(l,r);\n\t\tcout<<solve(l,r)<<endl;\n\t}\n\treturn 0;\n}\n/** 程序框架：\n  * f_{i,j}=f_{f_{i,j-1},j-1}\\\\\n  * s_{i,j}=s_{i,j-1}+s_{f_{i,j-1},j-1}\n  * \n  * \n  *\n  **/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\nll n, k;\nconst int D = 18;\n\nstruct Db {\n    vector<vector<ll>> d, s;\n    Db(vector<ll> x) {\n        d.resize(n+1, vector<ll>(D, n));\n        s.resize(n+1, vector<ll>(D, 0));\n        int jj = n;\n        rrep(i, n) {\n            while (x[i]+k<=x[jj-1]) jj--;\n            d[i][0] = jj;\n            s[i][0] = jj;\n        }\n        rep(j, D) {\n            if (j==0) continue;\n            rep(i, n) {\n                d[i][j] = d[d[i][j-1]][j-1];\n                s[i][j] = s[i][j-1] + s[d[i][j-1]][j-1];\n            }\n        }\n        //debug(d[0][0]);\n    }\n    ll cnt = 0;\n    ll get(int l, int r) {\n        ll res = l;\n        cnt = 1;\n        rrep(i, D) {\n            ll now = 1<<i;\n            if (d[l][i]>r) continue;\n            res += s[l][i];\n            l = d[l][i];\n            cnt += now;\n            //debug(res);\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    \n    cin >> n >> k;\n    vector<ll> x(n);\n    rep(i, n) cin >> x[i];\n    Db db1(x);\n    \n    vector<ll> y(n);\n    rep(i, n) {\n        y[i] = -x[n-1-i];\n    }\n    \n    Db db2(y);\n    \n    ll q;\n    cin >> q;\n    rep(qi, q) {\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n        ll sum1 = db1.get(l, r);\n        //debug(sum1);\n        ll ans = db1.cnt;\n        //debug(db1.cnt);\n        ll sum2 = db2.get(n-1-r, n-1-l);\n        //debug(sum2);\n        //debug(db2.cnt);\n        sum2 = db2.cnt*(n-1) - sum2;\n        ans += (sum2-sum1);\n        pr(ans);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005];\nint r1[19][200005],r2[19][200005];\nint l1[19][200005],l2[19][200005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n,k,q;\t\n\tread(n,k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tint nex=n+1;\n\tfor(int i=n;i;--i){\n\t\twhile(a[nex-1]-a[i]>=k){\n\t\t\t--nex;\n\t\t}\t\n\t\tr1[0][i]=nex;\n\t\tr2[0][i]=i;\n\t}\n\tfor(int i=0;i<=18;++i)r1[i][n+1]=n+1;\n\tnex=0;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(a[i]-a[nex+1]>=k){\n\t\t\t++nex;\n\t\t}\t\n\t\tl1[0][i]=nex;\n\t\tl2[0][i]=i;\n\t}\n\tfor(int i=1;i<=18;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tr1[i][j]=r1[i-1][r1[i-1][j]];\n\t\t\tl1[i][j]=l1[i-1][l1[i-1][j]];\n\t\t\tr2[i][j]=r2[i-1][j]+r2[i-1][r1[i-1][j]];\n\t\t\tl2[i][j]=l2[i-1][j]+l2[i-1][l1[i-1][j]];\n\t\t}\t\n\t}\n\tread(q);\n\tfor(;q;--q){\n\t\tint l,r;\t\n\t\tread(l,r);\n\t\tint s=0;\n\t\tfor(int i=18;~i;--i)if(r1[i][l]<=r){\n\t\t\ts+=(1<<i);\n\t\t\ts-=r2[i][l];\n\t\t\ts+=l2[i][r];\n\t\t\tl=r1[i][l];\n\t\t\tr=l1[i][r];\n\t\t}\n\t\ts+=r-l+1;\n\t\t\n\t\twrite(s,'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//@formatter:off\n#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < int(n); ++i)\n#define rrep(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = int(s); i < int(n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vp vector<P>\n#define vvp vector<vector<P>>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class S,class T> istream& operator>>(istream &is,pair<S,T> &p) { return is >> p.first >> p.second; }\ntemplate<class S,class T> ostream& operator<<(ostream &os,const pair<S,T> &p) { return os<<'{'<<p.first<<\",\"<<p.second<<'}'; }\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) { for(T &t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) { os<<'[';rep(i,v.size())os<<v[i]<<(i==int(v.size()-1)?\"\":\",\"); return os<<']'; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << '\\n'; }\ntemplate<class T> bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n//@formatter:on\n\nint to[30][200010];\nll sum[30][200010];\n\nint rev_to[30][200010];\nll rev_sum[30][200010];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    vi x(n);\n    cin >> x;\n    rep(i, n) {\n        auto it = lower_bound(all(x), x[i] + k);\n        to[0][i] = it - x.begin();\n        it = upper_bound(all(x), x[i] - k);\n        rev_to[0][i] = it - x.begin() - 1;\n        if (rev_to[0][i] == -1) rev_to[0][i] = n;\n        sum[0][i] = rev_sum[0][i] = i;\n    }\n    to[0][n] = n;\n    rev_to[0][n] = n;\n    rep(i, 29) {\n        rep(j, n+1) {\n            to[i + 1][j] = to[i][to[i][j]];\n            rev_to[i + 1][j] = rev_to[i][rev_to[i][j]];\n            sum[i + 1][j] = sum[i][j] + sum[i][to[i][j]];\n            rev_sum[i + 1][j] = rev_sum[i][j] + rev_sum[i][rev_to[i][j]];\n        }\n    }\n    auto calc_to = [&](int st, int len) {\n        rep(k, 30) {\n            if (len >> k & 1) {\n                st = to[k][st];\n            }\n        }\n        return st;\n    };\n    auto calc_sum = [&](bool rev, int st, int len) {\n        ll res = 0;\n        rep(k, 30) {\n            if (len >> k & 1) {\n                if (rev) {\n                    res += rev_sum[k][st];\n                    st = rev_to[k][st];\n                } else {\n                    res += sum[k][st];\n                    st = to[k][st];\n                }\n            }\n        }\n        return res;\n    };\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        r--;\n        int ok = 0, ng = 1 << 20;\n        auto f = [&](int x) -> bool {\n            return calc_to(l, x) <= r;\n        };\n        while (abs(ok - ng) > 1) {\n            int mid = (ng + ok) / 2;\n            if (f(mid)) ok = mid;\n            else ng = mid;\n        }\n        ll ans = calc_sum(true, r, ng) - calc_sum(false, l, ng) + ng;\n        cout << ans << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nconst int _ = 2e5 + 7; int tor[_][20] , tol[_][20]; ll sumr[_][20] , suml[_][20]; int N , K , Q , X[_];\n\nint main(){\n\tios::sync_with_stdio(0); cin >> N >> K; for(int i = 1 ; i <= N ; ++i) cin >> X[i];\n\tX[0] = -1e9; X[N + 1] = 2e9; for(int j = 0 ; j < 20 ; ++j) tor[N + 1][j] = N + 1;\n\tfor(int pos = N + 1 , i = N ; i ; --i){\n\t\twhile(X[pos - 1] - X[i] >= K){--pos;} tor[i][0] = pos; sumr[i][0] = pos - 1;\n\t\tfor(int j = 1 ; j < 20 ; ++j){tor[i][j] = tor[tor[i][j - 1]][j - 1]; sumr[i][j] = sumr[i][j - 1] + sumr[tor[i][j - 1]][j - 1];}\n\t}\n\tfor(int pos = 0 , i = 1 ; i <= N ; ++i){\n\t\twhile(X[i] - X[pos + 1] >= K){++pos;} tol[i][0] = pos; suml[i][0] = pos;\n\t\tfor(int j = 1 ; j < 20 ; ++j){tol[i][j] = tol[tol[i][j - 1]][j - 1]; suml[i][j] = suml[i][j - 1] + suml[tol[i][j - 1]][j - 1];}\n\t}\n\n\tfor(cin >> Q ; Q ; --Q){\n\t\tint L , R; cin >> L >> R; ll ans = R - L + 1;\n\t\tfor(int t = R , fl = 19 ; ~fl ; --fl) if(tol[t][fl] >= L){ans += suml[t][fl]; t = tol[t][fl];}\n\t\tfor(int t = L , fl = 19 ; ~fl ; --fl) if(tor[t][fl] <= R){ans -= sumr[t][fl]; t = tor[t][fl];}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  vector<int> x(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x[i]);\n  }\n  vector<vector<int>> to_lef(32 - __builtin_clz(n)), to_rig(32 - __builtin_clz(n));\n  vector<vector<int>> sum_lef(32 - __builtin_clz(n)), sum_rig(32 - __builtin_clz(n));\n  for (int i = 0, j = -1; i < n; ++i) {\n    while (j + 1 < n && x[i] - x[j + 1] >= k) ++j;\n    to_lef[0].push_back(j); \n    sum_lef[0].push_back(i);\n  }\n  for (int i = 0, j = 0; i < n; ++i) {\n    while (j < n && x[j] - x[i] < k) ++j;\n    to_rig[0].push_back(j);\n    sum_rig[0].push_back(i-1);\n  }\n  for (int i = 0; i + 1 < (int)to_lef.size(); ++i) {\n    to_lef[i+1].resize(n);\n    sum_lef[i+1].resize(n);\n    for (int j = 0; j < n; ++j) {\n      int now = to_lef[i][j];\n      int sum = sum_lef[i][j];\n      if (now != -1) {\n        sum += sum_lef[i][now];\n        now = to_lef[i][now];\n      }\n      to_lef[i+1][j] = now;\n      sum_lef[i+1][j] = sum;\n    }\n  }\n  for (int i = 0; i + 1 < (int)to_rig.size(); ++i) {\n    to_rig[i+1].resize(n);\n    sum_rig[i+1].resize(n);\n    for (int j = 0; j < n; ++j) {\n      int now = to_rig[i][j];\n      int sum = sum_rig[i][j];\n      if (now < n) {\n        sum += sum_rig[i][now];\n        now = to_rig[i][now];\n      }\n      to_rig[i+1][j] = now;\n      sum_rig[i+1][j] = sum;\n    }\n  }\n  int q;\n  scanf(\"%d\", &q);\n  while (q--) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    --l, --r;\n    long long ans = 0;\n    int now = r;\n    for (int i = (int) to_lef.size()-1; i >= 0; --i) {\n      if (to_lef[i][now] >= l) {\n        ans += sum_lef[i][now];\n        now = to_lef[i][now];\n      }\n    }\n    ans += now;\n    now = l;\n    for (int i = (int) to_rig.size()-1; i >= 0; --i) {\n      if (to_rig[i][now] <= r) {\n        ans -= sum_rig[i][now];\n        now = to_rig[i][now];\n      }\n    }\n    ans -= now - 1;\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n\n#include \"atcoder/convolution.hpp\"\n#include \"atcoder/dsu.hpp\"\n#include \"atcoder/fenwicktree.hpp\"\n#include \"atcoder/lazysegtree.hpp\"\n#include \"atcoder/math.hpp\"\n#include \"atcoder/maxflow.hpp\"\n#include \"atcoder/mincostflow.hpp\"\n#include \"atcoder/modint.hpp\"\n#include \"atcoder/scc.hpp\"\n#include \"atcoder/segtree.hpp\"\n#include \"atcoder/string.hpp\"\n#include \"atcoder/twosat.hpp\"\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\nusing namespace atcoder;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvector<int> g[N];\nbool is_root[N];\nint height[N];\nint up[N][18];\nll sum[N][18];\n\nvoid dfs(int u, int par, int h, vector<int> &w) {\n    fill(up[u], up[u] + 18, -1);\n    height[u] = h;\n    sum[u][0] = w[u];\n    up[u][0] = par;\n    for (int p = 1; (1 << p) <= h + 1; p++) {\n        up[u][p] = up[up[u][p - 1]][p - 1];\n        sum[u][p] = sum[u][p - 1] + sum[up[u][p - 1]][p - 1];\n    }\n    for (int v : g[u]) {\n        dfs(v, u, h + 1, w);\n    }\n}\n\nint get_cnt(int u, int v) {\n    int res = 0;\n    repb(i, 17, -1) {\n        if (up[u][i] >= v) {\n            res += (1 << i);\n            u = up[u][i];\n        }\n    }\n    return res + 1;\n}\n\nll get_sum(int u, int k) {\n    ll res = 0;\n    repb(i, 17, -1) {\n        if ((k >> i) & 1) {\n            res += sum[u][i];\n            u = up[u][i];\n        }\n    }\n    return res;\n}\n\nvector<ll> solve(int n, int k, vector<int> a, vector<int> w, vector<pair<int, int> > Q) {\n    rep(i, 0, n) {\n        g[i].clear();\n        is_root[i] = false;\n    }\n    rep(i, 0, n) {\n        int pos = upper_bound(a.begin(), a.end(), a[i] - k) - a.begin() - 1;\n        if (pos >= 0) {\n            g[pos].push_back(i);\n        } else {\n            is_root[i] = true;\n        }\n    }\n    rep(i, 0, n) {\n        if (is_root[i]) {\n            dfs(i, -1, 0, w);\n        }\n    }\n    vector<ll> res(sz(Q), 0);\n    rep(q, 0, sz(Q)) {\n        int l = Q[q].fi, r = Q[q].se;\n        int cnt = get_cnt(r, l);\n        res[q] = get_sum(r, cnt);\n    }\n    return res;\n}\n\nint main()\n{\n    //freopen(\"circus.in\", \"r\", stdin);\n    //freopen(\"circus.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    rep(i, 0, n) {\n        cin >> a[i];\n    }\n    int q;\n    cin >> q;\n    vector<pair<int, int> > Q(q);\n    rep(i, 0, q) {\n        int l, r;\n        cin >> l >> r; l--; r--;\n        Q[i] = {l, r};\n    }\n\n    vector<int> w(n, 0);\n    rep(i, 0, n) {\n        w[i] = i + 1;\n    }\n\n    vector<ll> res1 = solve(n, k, a, w, Q);\n\n    rep(i, 0, n) {\n        w[n - i - 1] = -i;\n        a[i] = -a[i];\n    }\n    reverse(a.begin(), a.end());\n    rep(i, 0, q) {\n        Q[i] = {n - Q[i].se - 1, n - Q[i].fi - 1};\n    }\n\n    vector<ll> res2 = solve(n, k, a, w, Q);\n\n    rep(i, 0, q) {\n        cout << res1[i] + res2[i] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\n//---------------------------------------------------------------------------------------------------\nint getRight(int L, int R) {\n\tint cu = R;\n\tint tot = 0;\n\twhile (L <= cu) {\n\t\ttot += cu;\n\t\tcu = toLeft[cu];\n\t}\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cu = L;\n\tint tot = 0;\n\twhile (cu <= R) {\n\t\ttot += cu;\n\t\tcu = toRight[cu];\n\t}\n\treturn tot;\n}\nint getTot(int L, int R) {\n\tint cu = L;\n\tint tot = 0;\n\twhile (cu <= R) {\n\t\ttot++;\n\t\tcu = toRight[cu];\n\t}\n\treturn tot;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\t\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tint ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define range2(i,a,b) ((a)<=(i) && (i)<=(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid solve(){\n  int N,K;\n  cin >> N >> K;\n\n  vector<int> a(N);\n  REP(i,N) cin >> a[i];\n\n  mat L(30,vec(N)), R = L, Lsum = L, Rsum = L;\n  REP(i,N){\n    L[0][i] = lower_bound(a.begin(),a.end(),a[i]+K) - a.begin();\n    R[0][i] = upper_bound(a.begin(),a.end(),a[i]-K) - a.begin() - 1;\n    Lsum[0][i] = Rsum[0][i] = i;\n  }\n\n  REP(i,29){\n    REP(j,N){\n      if(L[i][j]==N) L[i+1][j] = N, Lsum[i+1][j] = Lsum[i][j];\n      else L[i+1][j] = L[i][L[i][j]], Lsum[i+1][j] = Lsum[i][j]+Lsum[i][L[i][j]];\n\n      if(R[i][j]==-1) R[i+1][j] = -1, Rsum[i+1][j] = Rsum[i][j];\n      else R[i+1][j] = R[i][R[i][j]], Rsum[i+1][j] = Rsum[i][j]+Rsum[i][R[i][j]];\n    }\n  }\n  \n  int Q; cin >> Q;\n  REP(_,Q){\n    int l,r;\n    cin >> l >> r; l--; r--;\n    int now = l, mx = 1, sum = 0;\n    RREP(i,30){\n      if(L[i][now] <= r) mx += (1<<i), sum += Lsum[i][now], now = L[i][now];\n    }\n    sum += now;\n    now = r; \n    RREP(i,30){\n      if(R[i][now] >= l) sum -= Rsum[i][now], now = R[i][now];\n    }\n    sum -= now;\n    cout << abs(sum) + mx << endl;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n)                       _range(i, 0, n)\n#define _range(i, a, b)                  for (int i = int(a); i < int(b); ++i)\n#define rep(...)                         _overload(__VA_ARGS__, _range, _rep, )(__VA_ARGS__)\n\n#define _rrep(i, n)      _rrange(i, n, 0)\n#define _rrange(i, a, b) for (int i = int(a) - 1; i >= int(b); --i)\n#define rrep(...)        _overload(__VA_ARGS__, _rrange, _rrep, )(__VA_ARGS__)\n\nusing ll = long long;\nusing namespace std;\n\nconst int limit = 200010;\nint nxt[18][limit];\nll nsum[18][limit];\n\nint prv[18][limit];\nll psum[18][limit];\n\n\nint main(void) {\n    ll n, d;\n    cin >> n >> d;\n    vector<int> x(n);\n    rep(i, n) cin >> x[i];\n\n    {\n        int pos = 0;\n        rep(i, n) {\n            while (pos < n and x[pos] - x[i] < d) {\n                pos++;\n            }\n            nxt[0][i] = pos;\n            nsum[0][i] += i;\n        }\n    }\n\n    {\n        int pos = n - 1;\n        rrep(i, n) {\n            while (pos >= 0 and x[i] - x[pos] < d) {\n                pos--;\n            }\n            prv[0][i] = pos;\n            psum[0][i] += i;\n        }\n    }\n\n    rep(k, 1, 18) {\n        rep(i, n) {\n            nxt[k][i]  = (nxt[k - 1][i] == n) ? n : nxt[k - 1][nxt[k - 1][i]];\n            nsum[k][i] = (nxt[k - 1][i] == n)\n                             ? nsum[k - 1][i]\n                             : nsum[k - 1][nxt[k - 1][i]] + nsum[k - 1][i];\n\n            prv[k][i]  = (prv[k - 1][i] == -1) ? -1 : prv[k - 1][prv[k - 1][i]];\n            psum[k][i] = (prv[k - 1][i] == -1)\n                             ? psum[k - 1][i]\n                             : psum[k - 1][prv[k - 1][i]] + psum[k - 1][i];\n        }\n    }\n\n    int q;\n    cin >> q;\n\n    rep(loop, q) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n\n        ll num  = 1LL;\n        int cur = l;\n        rrep(k, 18) {\n            if (nxt[k][cur] <= r) {\n                cur = nxt[k][cur];\n                num += 1 << k;\n            }\n        }\n\n        ll ans = num;\n\n        int cl = l;\n        int cr = r;\n        rrep(k, 18) {\n            if (num >> k & 1) {\n                ans -= nsum[k][cl];\n                cl = nxt[k][cl];\n                ans += psum[k][cr];\n                cr = prv[k][cr];\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace atcoder;\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 N, K;\n\tcin >> N >> K;\n\tvector<int64> X(N+1), X2(N+1);\n\tREP(i, N) {\n\t  cin >> X[i];\n\t  X2[N-i-1] = -X[i];\n\t}\n\tX[N] = X2[N] = INF_LL;\n\tint64 Q;\n\tcin >> Q;\n\n\tauto tor = make_v<int>(N+1, 20), suml = make_v<int>(N+1, 20);\n\tfill_v<int>(tor, N);\n  fill_v<int>(suml, 0);\n  auto tol = make_v<int>(N+1, 20), sumr = make_v<int>(N+1, 20);\n  fill_v<int>(tol, N);\n  fill_v<int>(sumr, 0);\n  REP(i, N) {\n    tor[i][0] = lower_bound(all(X), X[i] + K)- X.begin();\n    tol[i][0] = lower_bound(all(X2), X2[i] + K) -X2.begin();\n    suml[i][0] = lower_bound(all(X), X[i] + K)- X.begin();\n    sumr[i][0] = N - (tol[i][0]) - 1;\n  }\n  REP(i, 19) {\n    REP(j, N) {\n      tor[j][i + 1] = tor[tor[j][i]][i];\n      tol[j][i + 1] = tol[tol[j][i]][i];\n      suml[j][i + 1] = suml[j][i] + suml[tor[j][i]][i];\n      sumr[j][i + 1] = sumr[j][i] + sumr[tol[j][i]][i];\n    }\n  }\n\n  REP(_, Q) {\n    int64 L, R, L2, R2;\n    cin >> L >> R; L--; R--;\n    L2 = N-L-1; R2 = N-R-1;\n    int64 res = 0;\n    int64 ret = 1, ret2 = 1, nowl = L, nowl2 = R2, sumll = L, sumrr = R;\n    for (int64 i = 19; i >= 0; i--) {\n      if (tor[nowl][i] <= R) {\n        ret += 1 << i;\n        sumll += suml[nowl][i];\n        nowl = tor[nowl][i];\n      }\n      if (tol[nowl2][i] <= L2) {\n        ret2 += 1 << i;\n        sumrr += sumr[nowl2][i];\n        nowl2 = tol[nowl2][i];\n      }\n    }\n    chmax(res, ret);\n    chmax(res, ret2);\n    cout << sumrr - sumll + res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0xccccccc;\nconst ll LINF = 0xcccccccccccccccLL;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\n#define N 200100\n#define LO 20\n\n//head\n\nint n, k;\nint x[N];\nint q;\npair<int, ll> ne[N][LO], pr[N][LO];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  rep(i, n) cin >> x[i];\n  int j = 0, l = n-1;\n  rep(i, n) {\n    while(j != n and x[j] < x[i]+k) j++;\n    ne[i][0] = {j, j};\n    int i_ = n-1-i;\n    while(l != -1 and x[l] > x[i_]-k) l--;\n    pr[i_][0] = {l, l};\n  }\n  rep(j, LO-1) rep(i, n) {\n    ne[i][j+1] = (ne[i][j].first == n?(pair<int, ll>){n, -1}:(pair<int, ll>){ne[ne[i][j].first][j].first, ne[i][j].second+ne[ne[i][j].first][j].second});\n    pr[i][j+1] = (pr[i][j].first == -1?(pair<int, ll>){-1, -1}:(pair<int, ll>){pr[pr[i][j].first][j].first, pr[i][j].second+pr[pr[i][j].first][j].second});\n  }\n  cin >> q;\n  while(q--) {\n    int l, r;\n    cin >> l >> r;\n    l--; r--;\n    ll ze = l;\n    int now = l;\n    int cnt = 1;\n    int i = LO-1;\n    for(; i >= 0; i--) if(ne[now][i].first <= r) {\n      ze += ne[now][i].second;\n      now = ne[now][i].first;\n      cnt += 1<<i;\n    }\n    now = r;\n    ll us = r;\n    i = LO-1;\n    for(; i >= 0; i--) if(pr[now][i].first >= l) {\n      us += pr[now][i].second;\n      now = pr[now][i].first;\n    }\n    //cout << P(us, ze) << ' ' << cnt << '\\n';\n    cout << us-ze+cnt << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<ll, ll, ll>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n// ============ template finished ============\nconst int DBSIZE = 4;\n\n// pair<nextIndex, sum of indexes>\nvector<vector<pll>> dubling(vector<ll> X, int K) {\n    const int N = X.size();\n    vector<pll> next(N);\n    rep(i, N) {\n        int tgt = X[i] + K;\n        int idx = lower_bound(X.begin(), X.end(), tgt) - X.begin();\n        next[i] = { idx, i };\n    }\n    vector<vector<pll>> db(DBSIZE, vector<pll>(N, { N, 0 }));\n    db[0] = next;\n    REP(row, 1, DBSIZE) {\n        rep(col, N) {\n            auto[now, all] = db[row - 1][col];\n            if (now == N)continue;\n            auto[now2, all2] = db[row - 1][now];\n            db[row][col] = { now2, all + all2 };\n        }\n    }\n    return db;\n}\n\nvector<vector<pll>> dubling_rev(vector<ll>X, int K) {\n    const int N = X.size();\n    vector<pll> next(N);\n    rep(i, N) {\n        int tgt = X[i] - K;\n        int idx = upper_bound(X.begin(), X.end(), tgt) - X.begin() - 1;\n        next[i] = { idx, i };\n    }\n    vector<vector<pll>> db(DBSIZE, vector<pll>(N, { -1, 0 }));\n    db[0] = next;\n    REP(row, 1, DBSIZE) {\n        rep(col, N) {\n            auto[now, all] = db[row - 1][col];\n            if (now == -1)continue;\n            auto[now2, all2] = db[row - 1][now];\n            db[row][col] = { now2, all + all2 };\n        }\n    }\n    return db;\n}\n\nint pow2(int num) {\n    return 1 << num;\n}\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    vector<ll> X(N);\n    rep(i, N)cin >> X[i];\n    auto db = dubling(X, K);\n    auto dbrev = dubling_rev(X, K);\n\n    int Q;\n    cin >> Q;\n    rep(_, Q) {\n        int L, R;\n        cin >> L >> R;\n        L--;\n        R--;\n\n        ll res = 0;\n        ll totalStep = 1;\n        ll now = L;\n        for (int step = DBSIZE - 1; step >= 0; --step) {\n            if (R < db[step][now].first)continue;\n            totalStep += pow2(step);\n            res -= db[step][now].second;\n            now = db[step][now].first;\n        }\n        res -= now;\n        now = R;\n        for (int step = DBSIZE - 1; step >= 0; --step) {\n            if (dbrev[step][now].first < L)continue;\n            res += dbrev[step][now].second;\n            now = dbrev[step][now].first;\n        }\n        res += now;\n        cout << res + totalStep << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nLL readint(){\n\tchar c=getchar();\n\tLL ret=0ll;\n\tbool neg=0;\n\twhile(!(c>='0' && c<='9')){\n\t\tif(c=='-') neg=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10ll+(LL)(c-'0');\n\t\tc=getchar();\n\t}\n\treturn neg?-ret:ret;\n}\nvoid putint(LL v){\n\tif(v<0){\n\t\tputchar('-');\n\t\tv=-v;\n\t}\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10ll) putint(v/10ll);\n\tputchar('0'+(v%10ll));\n}\nint n,D,x[200005],q;\nstruct tree{\n\tint fa[20][200005],val[200005],sum[200005];\n\ttree(){\n\t\tmemset(fa,-1,sizeof(fa));\n\t\tmemset(val,0,sizeof(val));\n\t}\n\tvoid prec(bool rev){\n\t\tint i,j,k;\n\t\tfor(i=1;i<20;++i){\n\t\t\tfor(j=0;j<n;++j){\n\t\t\t\tif(~fa[i-1][j])\n\t\t\t\t\tfa[i][j]=fa[i-1][fa[i-1][j]];\n\t\t\t\telse\n\t\t\t\t\tfa[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tif(rev){\n\t\t\tfor(i=n-1;i>=0;--i){\n\t\t\t\tsum[i]=val[i]+(~fa[0][i]?sum[fa[0][i]]:0);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<n;++i){\n\t\t\t\tsum[i]=val[i]+(~fa[0][i]?sum[fa[0][i]]:0);\n\t\t\t}\n\t\t}\n\t}\n\tint qry(int v,int tv){\n//\t\tprintf(\"qry %d %d\\n\",v,tv);\n\t\tint ret=sum[v],i;\n\t\tfor(i=19;i>=0;--i){\n\t\t\tif(~fa[i][v] && val[fa[i][v]]>=tv)\n\t\t\t\tv=fa[i][v];\n\t\t}\n//\t\tprintf(\"got to %d\\n\",v);\n\t\treturn ret-(~fa[0][v]?sum[fa[0][v]]:0);\n\t}\n}R2L,L2R;\nint main(){\n\tint i,j,k;\n\tn=readint();D=readint();\n\tfor(i=0;i<n;++i) x[i]=readint();\n\tfor(i=0;i<n;++i) R2L.val[i]=i,L2R.val[i]=-i+1;\n\tfor(i=j=0;i<n;++i){\n\t\twhile(x[i]-x[j]>=D) ++j;\n\t\tR2L.fa[0][i]=j-1;\n\t}\n\tfor(i=j=n-1;i>=0;--i){\n\t\twhile(x[j]-x[i]>=D) --j;\n\t\tL2R.fa[0][i]=(j==n-1?-1:j+1);\n\t}\n\tR2L.prec(0);\n\tL2R.prec(1);\n\tq=readint();\n\twhile(q--){\n\t\tint l=readint()-1,r=readint()-1;\n\t\tprintf(\"%d\\n\",R2L.qry(r,l)+L2R.qry(l,-r+1));\n\t}\n\treturn 0;\n}\n/*\n * 代码框架\n * 1. 实现树结构体，自行设置父亲、权值，支持定位祖先并求权值和\n * 2. 向左走->下标，向右走->下标相反数\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nll binary_search(\n    ll lo, ll hi, function<bool(ll)> is_ok,\n    bool maximize\n){\n    while(lo < hi){\n        if(maximize){\n            const ll mid = (lo + hi + 1) / 2;\n            if(is_ok(mid)){\n                lo = mid;\n            }else{\n                hi = mid - 1;\n            }\n        }else{\n            ll mid = (lo + hi - 1) / 2;\n            if(is_ok(mid)){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }\n        }\n    }\n    return lo;\n}\n\ntemplate<typename S, S op(S, S)>\nstruct Doubling {\n    vector<vector<S>> v;\n\n    Doubling(const vector<S>& step1, ll p){\n        const auto n = step1.size();\n        v.resize(p);\n        v.at(0) = step1;\n        for(ll i = 1; i < p; ++i){\n            v.at(i).resize(n);\n            for(ll j = 0; j < n; ++j){\n                const auto& x = v.at(i - 1).at(j);\n                const auto& y = v.at(i - 1).at(x.index);\n                v.at(i).at(j) = op(x, y);\n            }\n        }\n    }\n\n    S query(S init, ll nstep){\n        S ret = init;\n        REP(i, v.size()){\n            if((nstep >> i) & 1){\n                ret = op(ret, v.at(i).at(ret.index));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct S { ll index_sum, is_ok, index; };\nS op(S x, S y){\n    return S{\n        x.index_sum + y.index_sum,\n        y.is_ok,\n        y.index\n    };\n}\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(n);\n    REP(i, n){ cin >> x.at(i); }\n\n    vector<S> l2r_1step(n), r2l_1step(n);\n    REP(i, n){\n        const auto xi = x.at(i);\n        // to right\n        ll ridx = lower_bound(ALL(x), xi + k) - x.begin();\n        if(ridx >= x.size()){\n            l2r_1step.at(i) = S{0, false, i};\n        }else{\n            l2r_1step.at(i) = S{ridx, true, ridx};\n        }\n\n        // to left\n        ll lidx = upper_bound(ALL(x), xi - k) - x.begin();\n        lidx--;\n        if(lidx < 0){\n            r2l_1step.at(i) = S{0, false, i};\n        }else{\n            r2l_1step.at(i) = S{lidx, true, lidx};\n        }\n    }\n\n    Doubling<S, op> d_l2r(l2r_1step, 35), d_r2l(r2l_1step, 35);\n\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n\n        // cerr << \"i=\" << i << \", l=\" << l << \", r=\" << r << endl;\n\n        const ll num = ::binary_search(\n            0, n,\n            [&](ll m) -> bool {\n                const auto tmp = d_l2r.query(S{l, true, l}, m);\n                return tmp.is_ok && x.at(tmp.index) <= x.at(r);\n            },\n            true\n        );\n        // cerr << \"  num=\" << num << endl;\n\n        const S l2r = d_l2r.query(S{l, true, l}, num);\n        const S r2l = d_r2l.query(S{r, true, r}, num);\n        // cerr << \"  l2r={\" << l2r.index_sum << \", \" << l2r.is_ok << \", \" << l2r.index << \"}\" << endl;\n        // cerr << \"  r2l={\" << r2l.index_sum << \", \" << r2l.is_ok << \", \" << r2l.index << \"}\" << endl;\n        assert(l2r.is_ok && x.at(l2r.index) <= x.at(r));\n        assert(r2l.is_ok && x.at(r2l.index) >= x.at(l));\n\n        cout << r2l.index_sum - l2r.index_sum + num + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){x>y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0';\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=200005,MAXK=19;\n\nint n,K,a[MAXN],l[MAXN][MAXK],r[MAXN][MAXK];\nll sl[MAXN][MAXK],sr[MAXN][MAXK];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tint Q,u,v;\n\treadint(n),readint(K);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\ta[0]=a[1]-K,a[n+1]=a[n]+K;\n\tfor(int i=1;i<=n;++i)\n\t\tl[i][0]=upper_bound(a,a+n+2,a[i]-K)-a-1,\n\t\tsl[i][0]=(l[i][0]<=n?l[i][0]:0),\n\t\tr[i][0]=lower_bound(a,a+n+2,a[i]+K)-a,\n\t\tsr[i][0]=(r[i][0]<=n?r[i][0]:0);\n\tfor(int j=0;j<MAXK;++j)r[n+1][j]=n+1;\n\tfor(int j=1;j<MAXK;++j)\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tl[i][j]=l[l[i][j-1]][j-1],r[i][j]=r[r[i][j-1]][j-1],\n\t\t\tsl[i][j]=sl[i][j-1]+sl[l[i][j-1]][j-1],sr[i][j]=sr[i][j-1]+sr[r[i][j-1]][j-1];\n\treadint(Q);\n\twhile(Q--)\n\t{\n\t\treadint(u),readint(v);\n\t\tll su=u,sv=v;\n\t\tfor(int i=u,j=MAXK-1;j>=0;--j)\n\t\t\tif(r[i][j]<=v)su+=sr[i][j],i=r[i][j];\n\t\tfor(int i=v,j=MAXK-1;j>=0;--j)\n\t\t\tif(l[i][j]>=u)sv+=sl[i][j]+(1<<j),i=l[i][j];\n\t\tprintf(\"%lld\\n\",sv-su+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, k, Q;\nllint x[200005];\nllint pred[19][200005], succ[19][200005];\nllint pred2[19][200005], succ2[19][200005];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\tx[0] = -inf, x[n+1] = inf;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint p = lower_bound(x, x+n+2, x[i]+k) - x;\n\t\tsucc[0][i] = p;\n\t\tp = upper_bound(x, x+n+2, x[i]-k) - x - 1;\n\t\tpred[0][i] = p;\n\t}\n\tsucc[0][n+1] = n+1;\n\t\n\tfor(int i = 1; i < 19; i++){\n\t\tfor(int j = 1; j <= n+1; j++){\n\t\t\tpred[i][j] = pred[i-1][pred[i-1][j]];\n\t\t\tsucc[i][j] = succ[i-1][succ[i-1][j]];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tsucc2[0][i] = succ[0][i]-1;\n\t\tpred2[0][i] = pred[0][i];\n\t}\n\tfor(int i = 1; i < 19; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tpred2[i][j] = pred2[i-1][j] + pred2[i-1][pred[i-1][j]];\n\t\t\tsucc2[i][j] = succ2[i-1][j] + succ2[i-1][succ[i-1][j]];\n\t\t}\n\t}\n\t\n\t/*for(int i = 1; i <= n; i++) cout << succ[0][i] << \" \"; cout << endl;\n\tfor(int i = 1; i <= n; i++) cout << pred[0][i] << \" \"; cout << endl;\n\t\n\tfor(int i = 1; i <= n; i++) cout << succ2[0][i] << \" \"; cout << endl;\n\tfor(int i = 1; i <= n; i++) cout << pred2[0][i] << \" \"; cout << endl;*/\n\t\n\tcin >> Q;\n\tllint L, R;\n\tfor(int q = 1; q <= Q; q++){\n\t\tcin >> L >> R;\n\t\t\n\t\tllint ans = R-L+1, v = L;\n\t\tfor(int i = 18; i >= 0; i--){\n\t\t\t//cout << succ[i][v] << \" \" << R << endl;\n\t\t\tif(succ[i][v] <= R){\n\t\t\t\tans -= succ2[i][v];\n\t\t\t\tv = succ[i][v];\n\t\t\t}\n\t\t\t///cout << v << \" \" << ans << endl;\n\t\t}\n\t\tv = R;\n\t\tfor(int i = 18; i >= 0; i--){\n\t\t\tif(pred[i][v] >= L){\n\t\t\t\tans += pred2[i][v];\n\t\t\t\tv = pred[i][v];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////////////////////////////\n////////////        AUTHOR : LYNMISAKURA        ////////////////////\n////////////////////////////////////////////////////////////////////\n#include <bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> bool chmax(T& a,T b){ if(a < b){ a = b; return true; }else return false; }\ntemplate<class T> bool chmin(T& a,T b){ if(a > b){ a = b; return true; }else return false; }\n \nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing Pi = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vpi = vector<Pi>;\nusing vpl = vector<Pl>;\n \n#define debug(arr) cout << #arr << \" = \" << arr << '\\n'\n#define debug2(a,b) cout << \"[\" << #a << \",\" << #b << \"] = \" << \"[\" << a << \",\" << b << \"]\" << '\\n'\ntemplate<class T> ostream &operator << (ostream& out, const vector<T>& arr) {\n\tcout << \"{\"; for (int i = 0; i < arr.size(); i++)cout << (!i ? \"\" : \", \") << arr[i]; cout << \"}\";\n\treturn out;\n}\ntemplate<class T> ostream &operator << (ostream& out, const vector<vector<T> >& arr) {\n\tcout << \"{\\n\"; for (auto& vec : arr)cout << \"  \" << vec << \",\\n\"; cout << \"}\";\n\treturn out;\n}\ntemplate<class S,class T> ostream &operator << (ostream& out, const pair<S,T>& p){\n  cout << \"{\" << p.first << \",\" << p.second << \"}\" << '\\n';\n  return out;\n}\ntemplate<class T> istream &operator >> (istream& in, vector<T>& arr) {\n\tfor (auto& i : arr)cin >> i; return in;\n}\n\n\n#define maxn 200020\n#define maxlog 30\nconst ll INF = (1LL << 55);\nint N,K,Q;\nll X[maxn];\nint R[maxn][maxlog],L[maxn][maxlog];\nll RSum[maxn][maxlog],LSum[maxn][maxlog];\nint get_l(int x,int k){\n  int tmp = x;\n  for(int i = 0;i < maxlog;i++){\n    if(k >> i & 1){\n      tmp = L[tmp][i];\n    }\n  }\n  return tmp;\n}\nint get_r(int x,int k){\n  int tmp = x;\n  for(int i = 0;i < maxlog;i++){\n    if(k >> i & 1){\n      tmp = R[tmp][i];\n    }\n  }\n  return tmp;\n}\nll get_ls(int x,int k){\n  int tmp = x;\n  ll res = x;\n  for(int i = 0;i < maxlog;i++){\n    if(k >> i & 1){\n      res += LSum[tmp][i];\n      tmp = L[tmp][i];\n    }\n  }\n  return res;\n}\nll get_rs(int x,int k){\n  int tmp = x;\n  ll res = x;\n  for(int i = 0;i < maxlog;i++){\n    if(k >> i & 1){\n      res += RSum[tmp][i];\n      tmp = R[tmp][i];\n    }\n  }\n  return res;\n}\nvoid init(){\n  R[0][0] = 1;\n  R[N+1][0] = N+1;\n  L[N+1][0] = N;\n  L[0][0] = 0;\n  int l = 1,r = 2;\n  for(;l <= N;l++){\n    for(;r <= N+1;r++){\n      if(X[l] + K <= X[r]){\n        R[l][0] = r;\n        break;\n      }\n    }\n  }\n  for(int i = 1;i < maxlog;i++){\n    for(int j = 0;j <= N+1;j++){\n      R[j][i] = R[R[j][i-1]][i-1];\n    }\n  }\n  l = N-1,r = N;\n  for(;r >= 1;r--){\n    for(;l >= 0;l--){\n      if(X[l] + K <= X[r]){\n        L[r][0] = l;\n        break;\n      }\n    }\n  }\n  for(int i = 1;i < maxlog;i++){\n    for(int j = 0;j <= N+1;j++){\n      L[j][i] = L[L[j][i-1]][i-1];\n    }\n  }\n  for(int i = 1;i <= N;i++){\n    RSum[i][0] = R[i][0];\n    LSum[i][0] = L[i][0];\n  }\n  for(int i = 1;i < maxlog;i++){\n    for(int j = 1;j <= N;j++){\n      RSum[j][i] = RSum[j][i-1] + RSum[R[j][i-1]][i-1];\n      LSum[j][i] = LSum[j][i-1] + LSum[L[j][i-1]][i-1];\n    }\n  }\n}\n\nll query(int l,int r){\n  \n  int low = 0,high = N;\n  while(low + 1 < high){\n    int mid = (low + high)/2;\n    if(get_r(l,mid) <= r){\n      low = mid;\n    }else high = mid;\n  }\n  \n  int step = low;\n  //cout << get_ls(r,step) << ' ' << get_rs(l,step) << endl;\n  return get_ls(r,step) - get_rs(l,step) + step + 1;\n  \n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  cin >> N >> K;\n  for(int i = 0;i <= N+1;i++){\n    if(i == 0) X[i] = -INF;\n    else if(i <= N) cin >> X[i];\n    else X[i] = INF;\n  }\n  \n  init();\n   \n  cin >> Q;\n  for(int i = 0;i < Q;i++){\n    int l,r;cin >> l >> r;\n    cout << query(l,r) << '\\n';\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1234567890\n#define ll long long\n\nint N, K, Q;\nint X[200201];\nint L[20][101001], R[20][100101];\nll LS[20][100101], RS[20][100101];\n// LS[i][j] : j를 포함해서 만나는 2^i개의 정점의 번호 합\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &K);\n\tfor(int i=1; i<=N; i++)\n\t\tscanf(\"%d\", &X[i]);\n\n\t// L[] 채우기\n\tmap<int, int> m;\n\tfor(int i=1; i<=N; i++)\n\t{\n\t\tm[X[i]] = i;\n\t\tauto it = m.upper_bound(X[i]-K);\n\t\tif (it == m.begin()) continue;\n\t\t\n\t\tit = prev(it);\n\t\tL[0][i] = it->second;\n\t}\n\n\tm.clear();\n\tfor(int i=N; i>=1; i--)\n\t{\n\t\tm[X[i]] = i;\n\t\tauto it = m.lower_bound(X[i]+K);\n\t\tif (it == m.end()) continue;\n\n\t\tR[0][i] = it->second;\n\t}\n\n\tfor(int i=1; i<=N; i++)\n\t\tLS[0][i] = RS[0][i] = i;\n\n\tfor(int i=1; i<20; i++)\n\t\tfor(int j=1; j<=N; j++)\n\t\t{\n\t\t\tL[i][j] = L[i-1][L[i-1][j]];\n\t\t\tR[i][j] = R[i-1][R[i-1][j]];\n\t\t\tLS[i][j] = LS[i-1][j] + LS[i-1][L[i-1][j]];\n\t\t\tRS[i][j] = RS[i-1][j] + RS[i-1][R[i-1][j]];\n\t\t}\n\n\tscanf(\"%d\", &Q);\n\twhile(Q--)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tll ls = 0, rs = 0, cnt = 0;\n\n\t\tint n = r;\n\t\tfor(int i=19; i>=0; i--)\n\t\t\tif (L[i][n] != 0 && l <= L[i][n])\n\t\t\t\trs += LS[i][n], n = L[i][n], cnt += (1<<i);\n\t\trs += LS[0][n]; cnt++;\n\n\t\tn = l;\n\t\tfor(int i=19; i>=0; i--)\n\t\t\tif (R[i][n] != 0 && R[i][n] <= r)\n\t\t\t\tls += RS[i][n], n = R[i][n];\n\t\tls += RS[0][n];\n\n\t\t//printf(\"%lld, %lld, %lld : \", rs, ls, cnt);\n\t\tprintf(\"%lld\\n\", rs-ls+cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntemplate<class T> bool chmin(T& a,T b){if(a>b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a<b) {a = b; return true;} return false;}\n#define all(x) (x).begin(),(x).end()\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\n\nint main(){\n    int N,K;\n    cin >> N >> K;\n    vec<int> X(N);\n    for(auto& x:X) cin >> x;\n    int M = 20;\n    vvec<int> left(M,vec<int>(N,-1)),left_val = left;\n    vvec<int> right(M,vec<int>(N,N)),right_val = right;\n    for(int i=0;i<N;i++){\n        int id = lower_bound(all(X),X[i]+K)-X.begin();\n        right[0][i] = id;\n        right_val[0][i] = id;\n        id = upper_bound(all(X),X[i]-K)-X.begin();\n        id--;\n        left[0][i] = id;\n        left_val[0][i] = id;\n    }\n    for(int k=0;k+1<M;k++) for(int i=0;i<N;i++){\n        int ne = right[k][i];\n        if(ne!=N){\n            right[k+1][i] = right[k][ne];\n            right_val[k+1][i] = right_val[k][i]+right_val[k][ne];\n        }\n        ne = left[k][i];\n        if(ne!=-1){\n            left[k+1][i] = left[k][ne];\n            left_val[k+1][i] = left_val[k][i]+left_val[k][ne];\n        }\n    }\n\n    auto solve = [&](int l,int r){\n        ll a = l;\n        int now = l;\n        int cnt = 1;\n        for(int k=M-1;k>=0;k--){\n            if(right[k][now]<=r){\n                cnt += 1<<k;\n                a += right_val[k][now];\n                now = right[k][now];\n            }\n        }\n        ll b = r;\n        now = r;\n        for(int k=M-1;k>=0;k--){\n            if(left[k][now]>=l){\n                b += left_val[k][now];\n                now = left[k][now];\n            }\n        }\n        cout << b-a+cnt << \"\\n\";\n    };\n\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int l,r;\n        cin >> l >> r;\n        solve(l-1,r-1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define REP(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> bool chmax(T& a,T b){ if(a < b){ a = b; return true; }else return false; }\ntemplate<class T> bool chmin(T& a,T b){ if(a > b){ a = b; return true; }else return false; }\n \nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing Pi = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vpi = vector<Pi>;\nusing vpl = vector<Pl>;\n \n#define debug(arr) cout << #arr << \" = \" << arr << '\\n'\n#define debug2(a,b) cout << \"[\" << #a << \",\" << #b << \"] = \" << \"[\" << a << \",\" << b << \"]\" << '\\n'\ntemplate<class T> ostream &operator << (ostream& out, const vector<T>& arr) {\n\tcout << \"{\"; for (int i = 0; i < arr.size(); i++)cout << (!i ? \"\" : \", \") << arr[i]; cout << \"}\";\n\treturn out;\n}\ntemplate<class T> ostream &operator << (ostream& out, const vector<vector<T> >& arr) {\n\tcout << \"{\\n\"; for (auto& vec : arr)cout << \"  \" << vec << \",\\n\"; cout << \"}\";\n\treturn out;\n}\ntemplate<class S,class T> ostream &operator << (ostream& out, const pair<S,T>& p){\n  cout << \"{\" << p.first << \",\" << p.second << \"}\" << '\\n';\n  return out;\n}\ntemplate<class T> istream &operator >> (istream& in, vector<T>& arr) {\n\tfor (auto& i : arr)cin >> i; return in;\n}\n\n/////////////////////////////////////////////////////\n\n#define maxn 200020\n#define maxlog 30\n\nint N,K,Q;\nll X[maxn];\nll R[maxn][maxlog],L[maxn][maxlog];\nll rsum[maxn][maxlog],lsum[maxn][maxlog];\n\nint main(void){\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) {\n    cin >> X[i];\n  }\n  \n  // k steps right from x,left from x.\n  {\n    X[0] = -INT_MAX;\n    X[N+1] = INT_MAX;\n    // 1steps\n    int l = 1,r = 2;\n    for(;l <= N;l++){\n      for(;r <= N+1;r++){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          R[l][0] = r;\n          break;\n        }\n      }\n    }\n    r = N,l = N-1;\n    for(;r >= 1;r--){\n      for(;l >= 0;l--){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          L[r][0] = l;\n          break;\n        }\n      }\n    }\n    R[N+1][0] = N+1;\n    L[0][0] = 0;\n    // set doubling.\n    for(int j = 1;j < maxlog;j++){\n      for(int i = 0;i <= N+1;i++){\n        R[i][j] = R[R[i][j-1]][j-1];\n        L[i][j] = L[L[i][j-1]][j-1];\n      }\n    }\n  }\n  \n  // init distances.\n  {\n    for(int i = 1;i <= N;i++){\n      rsum[i][0] = R[i][0];\n      lsum[i][0] = L[i][0];\n    }\n    for(int i = 1;i <= N;i++){\n      for(int j = 1;j < maxlog;j++){\n        rsum[i][j] = rsum[i][j-1] + rsum[R[i][j-1]][j-1];\n        lsum[i][j] = lsum[i][j-1] + lsum[L[i][j-1]][j-1];\n      }\n    }\n  }\n  cin >> Q;\n  for (int i = 0; i < Q; i++) {\n    int l,r;cin >> l >> r;\n    int low = 0,high = N;\n    while(low + 1 < high){\n      int mid = (low + high) / 2;\n      int tmp = l;\n      for(int j = 0;j < maxlog;j++){\n        if(mid >> j & 1){\n          tmp = R[tmp][j];\n        }\n      }\n      //debug2(mid,tmp);\n      if(tmp <= r){\n        low = mid;\n      }else{\n        high = mid;\n      }\n    }\n    ll sr = l,sl = r;\n    { // calc sr.\n      int tmp = l;\n      for(int j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sr += rsum[tmp][j];\n          tmp = R[tmp][j];\n        }\n      }\n    }\n    { // calc sl.\n      int tmp = r;\n      for(int j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sl += lsum[tmp][j];\n          tmp = L[tmp][j];\n        }\n      }\n    }\n    cout << sl - sr + (low + 1) << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass DKeepDistances {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, k; cin >> n >> k;\n      vector<int> x(n);\n      rep(i, n) {\n        cin >> x[i];\n      }\n\n      vector<vector<int>> next(20, vector<int>(n, n));\n      vector<vector<int>> dp(20, vector<int>(n, 0));\n      int j=1;\n      for(int i=0; i<n; i++) {\n        while(j < n && x[j] - x[i] < k) {\n          j++;\n        }\n        next[0][i] = j;\n        dp[0][i] = j;\n      }\n\n      vector<vector<int>> next2(20, vector<int>(n, -1));\n      vector<vector<int>> dp2(20, vector<int>(n, 0));\n      j=n-2;\n      for(int i=n-1; i>=0; i--) {\n        while(j >= 0 && x[i] - x[j] < k) {\n          j--;\n        }\n        next2[0][i] = j;\n        dp2[0][i] = j;\n      }\n\n      for(int r=1; r<20; r++) {\n        for(int i=0; i<n; i++) {\n          if (next[r-1][i] == n) {\n            next[r][i] = n;\n          } else {\n            next[r][i] = next[r-1][next[r-1][i]];\n            dp[r][i] = dp[r-1][i] + dp[r-1][next[r-1][i]];\n          }\n        }\n      }\n\n      for(int r=1; r<20; r++) {\n        for(int i=0; i<n; i++) {\n          if (next2[r-1][i] == -1) {\n            next2[r][i] = -1;\n          } else {\n            next2[r][i] = next2[r-1][next2[r-1][i]];\n            dp2[r][i] = dp2[r-1][i] + dp2[r-1][next2[r-1][i]];\n          }\n        }\n      }\n\n      int q; cin >> q;\n      rep(_, q) {\n        int l, r; cin >> l >> r;\n        l--; r--;\n        ll lcnt = l;\n        int now = l;\n        int cnt = 1;\n        for(int p=19; p>=0; p--) {\n          if (next[p][now] <= r) {\n            lcnt += dp[p][now];\n            now = next[p][now];\n            cnt += (1<<p);\n          }\n        }\n        debug(_, lcnt);\n        now = r;\n        ll rcnt = r;\n        for(int p=19; p>=0; p--) {\n          if (next2[p][now] >= l) {\n            rcnt += dp2[p][now];\n            now = next2[p][now];\n          }\n        }\n        debug(_, rcnt);\n        cout << rcnt-lcnt+cnt << '\\n';\n      }\n    }\n};\n\nsigned main() {\n  DKeepDistances solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\ninline int my_getchar_unlocked(){\n  static char buf[1048576];\n  static int s = 1048576;\n  static int e = 1048576;\n  if(s == e && e == 1048576){\n    e = fread_unlocked(buf, 1, 1048576, stdin);\n    s = 0;\n  }\n  if(s == e){\n    return EOF;\n  }\n  return buf[s++];\n}\ninline void rd(int &x){\n  int k;\n  int m=0;\n  x=0;\n  for(;;){\n    k = my_getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = my_getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline int rd_int(void){\n  int x;\n  rd(x);\n  return x;\n}\nstruct MY_WRITER{\n  char buf[1048576];\n  int s;\n  int e;\n  MY_WRITER(){\n    s = 0;\n    e = 1048576;\n  }\n  ~MY_WRITER(){\n    if(s){\n      fwrite_unlocked(buf, 1, s, stdout);\n    }\n  }\n}\n;\nMY_WRITER MY_WRITER_VAR;\nvoid my_putchar_unlocked(int a){\n  if(MY_WRITER_VAR.s == MY_WRITER_VAR.e){\n    fwrite_unlocked(MY_WRITER_VAR.buf, 1, MY_WRITER_VAR.s, stdout);\n    MY_WRITER_VAR.s = 0;\n  }\n  MY_WRITER_VAR.buf[MY_WRITER_VAR.s++] = a;\n}\ninline void wt_L(char a){\n  my_putchar_unlocked(a);\n}\ninline void wt_L(long long x){\n  int s=0;\n  int m=0;\n  char f[20];\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    my_putchar_unlocked('-');\n  }\n  while(s--){\n    my_putchar_unlocked(f[s]+'0');\n  }\n}\nint N;\nint K;\nint X[200000];\nint L;\nint R;\nint go[20][200000];\nlong long gos[20][200000];\nint bk[20][200000];\nlong long bks[20][200000];\nint main(){\n  int jbtyPBGc;\n  int i;\n  int j;\n  int k;\n  int mx;\n  long long s1;\n  long long s2;\n  rd(N);\n  rd(K);\n  {\n    int Lj4PdHRW;\n    for(Lj4PdHRW=(0);Lj4PdHRW<(N);Lj4PdHRW++){\n      rd(X[Lj4PdHRW]);\n    }\n  }\n  j = 0;\n  for(i=(0);i<(N);i++){\n    while(j < N && X[j] < X[i]+K){\n      j++;\n    }\n    go[0][i] = j;\n    gos[0][i] = j;\n  }\n  j = N-1;\n  for(i=(N)-1;i>=(0);i--){\n    while(j >= 0 && X[j] > X[i]-K){\n      j--;\n    }\n    bk[0][i] = j;\n    bks[0][i] = j;\n  }\n  for(k=(1);k<(20);k++){\n    for(i=(0);i<(N);i++){\n      j = go[k-1][i];\n      if(j==N){\n        go[k][i] = N;\n        continue;\n      }\n      go[k][i] = go[k-1][j];\n      gos[k][i] = gos[k-1][j] + gos[k-1][i];\n    }\n  }\n  for(k=(1);k<(20);k++){\n    for(i=(0);i<(N);i++){\n      j = bk[k-1][i];\n      if(j==-1){\n        bk[k][i] = -1;\n        continue;\n      }\n      bk[k][i] = bk[k-1][j];\n      bks[k][i] = bks[k-1][j] + bks[k-1][i];\n    }\n  }\n  int ZIeRIny5 = rd_int();\n  for(jbtyPBGc=(0);jbtyPBGc<(ZIeRIny5);jbtyPBGc++){\n    rd(L);L += (-1);\n    rd(R);R += (-1);\n    mx = 0;\n    k = L;\n    s1 = L;\n    for(i=19;i>=0;i--){\n      if(go[i][k] <= R){\n        s1 += gos[i][k];\n        k = go[i][k];\n        mx += (1<<i);\n      }\n    }\n    k = R;\n    s2 = R;\n    for(i=19;i>=0;i--){\n      if(bk[i][k] >= L){\n        s2 += bks[i][k];\n        k = bk[i][k];\n      }\n    }\n    wt_L(s2-s1+mx+1);\n    wt_L('\\n');\n  }\n  return 0;\n}\n// cLay varsion 20200920-1\n\n// --- original code ---\n// int N, K, X[2d5], L, R;\n// int go[20][2d5]; ll gos[20][2d5];\n// int bk[20][2d5]; ll bks[20][2d5];\n// {\n//   int i, j, k, mx;\n//   ll s1, s2;\n//   rd(N,K,X(N));\n// \n//   j = 0;\n//   rep(i,N){\n//     while(j < N && X[j] < X[i]+K) j++;\n//     go[0][i] = j;\n//     gos[0][i] = j;\n//   }\n//   j = N-1;\n//   rrep(i,N){\n//     while(j >= 0 && X[j] > X[i]-K) j--;\n//     bk[0][i] = j;\n//     bks[0][i] = j;\n//   }\n// \n//   rep(k,1,20) rep(i,N){\n//     j = go[k-1][i];\n//     if(j==N) go[k][i] = N, continue;\n//     go[k][i] = go[k-1][j];\n//     gos[k][i] = gos[k-1][j] + gos[k-1][i];\n//   }\n// \n//   rep(k,1,20) rep(i,N){\n//     j = bk[k-1][i];\n//     if(j==-1) bk[k][i] = -1, continue;\n//     bk[k][i] = bk[k-1][j];\n//     bks[k][i] = bks[k-1][j] + bks[k-1][i];\n//   }\n// \n//   REP(rd_int()){\n//     rd(L--,R--);\n// \n//     mx = 0;\n// \n//     k = L;\n//     s1 = L;\n//     for(i=19;i>=0;i--) if(go[i][k] <= R) s1 += gos[i][k], k = go[i][k], mx += (1<<i);\n// \n//     k = R;\n//     s2 = R;\n//     for(i=19;i>=0;i--) if(bk[i][k] >= L) s2 += bks[i][k], k = bk[i][k];\n// \n//     wt(s2-s1+mx+1);\n//   }\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\ntemplate<typename T>\nstruct lazy_Segment_tree{\n    int N;\n    vector<T> node,lazy;\n    T INF;\n    vector<bool> flag;\n    lazy_Segment_tree(vector<T> X,T Y):INF(Y){\n        N=1;\n        while(X.size()>N) N*=2;\n        node.resize(2*N-1,Y);\n        lazy.resize(2*N-1);\n        flag.resize(2*N-1);\n        rep(i,0,X.size()) node[i+N-1]=X[i];\n        per(i,N-2,0) node[i]=compare(node[i*2+1],node[i*2+2]);\n    }\n    T compare(T X,T Y){\n        return std::max(X,Y);\n    }\n    T plus(T X,int l,int r){\n        return X;\n    }\n    void eval(int now,int l,int r){\n        if(flag[now]){\n            if(r-l>1){\n                flag[now*2+1]=flag[now*2+2]=1;\n                lazy[now*2+1]=lazy[now*2+2]=lazy[now];\n            }\n            node[now]=lazy[now];\n            flag[now]=0;\n        }\n    }\n    void update(int a,int b,T add,int now=0,int l=0,int r=-1){\n        if(r<0) r=N;\n        eval(now,l,r);\n        if(b<=l||r<=a) return;\n        if(a<=l&&r<=b){\n            lazy[now]=add;\n            flag[now]=1;\n            eval(now,l,r);\n        }\n        else{\n            update(a,b,add,now*2+1,l,(r+l)/2);\n            update(a,b,add,now*2+2,(r+l)/2,r);\n            node[now]=compare(node[now*2+1],node[now*2+2]);\n        }\n    }\n    T Query(int a,int b,int now=0,int l=0,int r=-1){\n        if(r<0) r=N;\n        eval(now,l,r);\n        if(b<=l||r<=a) return INF;\n        if(a<=l&&r<=b) return node[now];\n        return compare(Query(a,b,now*2+1,l,(r+l)/2),Query(a,b,now*2+2,(r+l)/2,r));\n    }\n    int lower_bound(T val,int now=0,int l=0,int r=-1){\n        if(r<0){\n            r=N;\n        }\n        eval(now,l,r);\n        if(node[now]<=val) return r;\n        if(r-l<=1){\n            if(node[now]<=val) return r;\n            return l;\n        }\n        int ml=lower_bound(val,now*2+1,l,(l+r)/2);\n        if(ml==(l+r)/2) return lower_bound(val,now*2+2,(l+r)/2,r);\n        else return ml;\n    }\n};\nstruct Strongly_Connected_Components{\n    ll N,M;\n    vii edge,revedge;\n    vi ind;\n    Strongly_Connected_Components(vii E):edge(E){\n        N=edge.size();\n        M=0;\n        ind.resize(N);\n        rep(i,0,N){\n            M+=edge[i].size();\n            for(auto p:edge[i]) revedge[p].pb(i);\n        }\n        vi num(N,-1);\n        ll cnt=0;\n        rep(i,0,N){\n            if(num[i]==-1) dfs(num,i,cnt);\n        }\n        vi mem(N);\n        rep(i,0,N) mem[num[i]]=i;\n        \n    }\n    void dfs(vi &num,ll now,ll &cnt){\n        for(auto p:edge[now]){\n            if(num[p]==-1) dfs(num,p,cnt);\n        }\n        num[now]=cnt++;\n    }\n};\nstruct Tree{\n    int N;\n    vii dp;\n    vi dist;\n    Tree(vii edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nvoid dec(std::map<ll,ll> &mem,ll X){\n    mem[X]--;\n    if(mem[X]==0) mem.erase(X);\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::random_device rnd;\n    std::mt19937 mt(rnd());\n    ll N,K; cin>>N>>K;\n    vi X(N);\n    rep(i,0,N) cin>>X[i];\n    ll Q; cin>>Q;\n    vii mem(N);\n    vi ans(Q);\n    vi L(Q),R(Q);\n    rep(i,0,Q){\n        cin>>L[i]>>R[i];\n        L[i]--;\n        R[i]--;\n        mem[R[i]].pb(i);\n    }\n    vi a(N,-inf);\n    lazy_Segment_tree<ll> seg(a,-inf);\n    Binary_indexed_tree bit(N+1);\n    ll left=0;\n    rep(i,0,N){\n        ll Y=X[i]-K;\n        ll right=i+1;\n        if(seg.Query(0,i+1)<=X[i]-K){\n            bit.add(1,1);\n            bit.add(i+2,-1);\n            seg.update(0,i+1,X[i]);\n            left=i+1;\n        }\n        else{\n            left--;\n            while(left+1<right){\n                ll mid=(left+right)/2;\n                if(seg.Query(left,mid)<=Y) left=mid;\n                else right=mid;\n            }\n            if(right==i+1){\n                ll right2=seg.lower_bound(Y);\n                seg.update(0,right2,X[i]);\n                seg.update(left,right,X[i]);\n                bit.add(1,1);\n                bit.add(right2+1,-1);\n                bit.add(left+1,1);\n                bit.add(right+1,-1);\n                left=right2;\n            }\n            else{\n                bit.add(left+1,1);\n                bit.add(right+1,-1);\n                seg.update(left,right,X[i]);\n                if(seg.Query(i,i+1)!=X[i]){\n                    bit.add(i+1,1);\n                    bit.add(i+2,-1);\n                    seg.update(i,i+1,X[i]);\n                }\n                left=right;\n            }\n        }\n        for(auto p:mem[i]){\n            ans[p]=bit.sum(L[p]+1);\n        }\n    }\n    rep(i,0,Q) cout<<ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 200005, LG = 20;\nint n, k, a[MX], q;\nint pi[MX][LG], pd[MX][LG];\nll si[MX][LG], sd[MX][LG];\nint li[MX], ld[MX];\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> k;\n\tforn (i, n) cin >> a[i];\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint j = lower_bound(a, a + n, a[i] + k) - a;\n\t\t\n\t\tif (j == n) {\n\t\t\tpi[i][0] = -1;\n\t\t\tli[i] = 0;\n\t\t} else {\n\t\t\tpi[i][0] = j;\n\t\t\tli[i] = li[j] + 1;\n\t\t}\n\n\t\tsi[i][0] = i;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = upper_bound(a, a + n, a[i] - k) - a;\n\t\tj--;\n\n\t\tif (j < 0) {\n\t\t\tpd[i][0] = -1;\n\t\t\tld[i] = 0;\n\t\t} else {\n\t\t\tpd[i][0] = j;\n\t\t\tld[i] = ld[j] + 1;\n\t\t}\n\n\t\tsd[i][0] = i;\n\t}\n\n\tfor (int j = 1; j < LG; j++)\n\t\tforn (i, n) {\n\t\t\tif (pi[i][j - 1] != -1) {\n\t\t\t\tpi[i][j] = pi[pi[i][j - 1]][j - 1];\n\t\t\t\tsi[i][j] = si[i][j - 1] + si[pi[i][j - 1]][j - 1];\n\t\t\t} else {\n\t\t\t\tpi[i][j] = -1;\n\t\t\t}\n\n\t\t\tif (pd[i][j - 1] != -1) {\n\t\t\t\tpd[i][j] = pd[pd[i][j - 1]][j - 1];\n\t\t\t\tsd[i][j] = sd[i][j - 1] + sd[pd[i][j - 1]][j - 1];\n\t\t\t} else {\n\t\t\t\tpd[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\tcin >> q;\n\twhile (q--) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--, r--;\n\n\t\tll sup = 0, to = l, cn = 1;\n\n\t\tfor (int j = LG - 1; j >= 0; j--)\n\t\t\tif (pi[to][j] != -1 && pi[to][j] <= r) {\n\t\t\t\tsup += si[to][j];\n\t\t\t\tto = pi[to][j];\n\n\t\t\t\tcn += 1 << j;\n\t\t\t}\n\n\t\tsup += to;\n\n\t\tll sdn = 0; to = r;\n\n\t\tfor (int j = LG - 1; j >= 0; j--)\n\t\t\tif (pd[to][j] != -1 && pd[to][j] >= l) {\n\t\t\t\tsdn += sd[to][j];\n\t\t\t\tto = pd[to][j];\n\t\t\t}\n\n\t\tsdn += to;\n\n\t\tcout << sdn - sup + cn << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\ntypedef array<ll, 2> ary;\npair<vvl, vvl> calc(ll n, ll k, vector<ll>& a){\n  vvl nxt = VV(n, 30, n, ll);\n  vvl s = VV(n, 30, 0, ll);\n  for(int i=0;i<30;i++){\n    if(i==0){\n      for(int j=0;j<n;j++){\n        auto idx = lower_bound(all(a), a[j]+k) - a.begin();//k先のidx\n        if(j==n-1) idx = n;\n        nxt[j][0] = idx;\n        if(idx!=n) s[j][0] = idx;\n      }\n    }else{\n      for(int j=0;j<n;j++){\n        nxt[j][i] = (nxt[j][i-1]==n?n:nxt[nxt[j][i-1]][i-1]);\n        s[j][i] = s[j][i-1] + (nxt[j][i-1]==n?0:s[nxt[j][i-1]][i-1]);\n      }\n    }\n  }\n  return {nxt, s};\n}\n\nint main(){\n  ll n, k;scanf(\"%lld %lld\", &n, &k);\n  vll a(n);\n  re(i, n) scanf(\"%lld\", &a[i]);\n  vll b = a;\n  reverse(all(b));\n  for(int i=0;i<n;i++) b[i] = -b[i];\n  vvl nxt, nxt2, s, s2;\n  auto tmp = calc(n, k, a);\n  nxt = tmp.first;\n  s = tmp.second;\n  tmp = calc(n, k, b);\n  nxt2 = tmp.first;\n  s2 = tmp.second;\n  auto f = [&](ll l, ll r){//操作回数\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt[now]), r) - nxt[now].begin() - 1;\n      if(a[nxt[now][idx]]-a[now] < k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s[now][idx];\n      now = nxt[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n  auto g = [&](ll l, ll r){\n    l = n - 1 - l, r = n - 1 - r;\n    swap(l, r);\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt2[now]), r) - nxt2[now].begin() - 1;\n      if(b[nxt2[now][idx]]-b[now]<k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s2[now][idx];\n      now = nxt2[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n  ll q;scanf(\"%lld\", &q);\n  for(int i=0;i<q;i++){\n    ll x, y;scanf(\"%lld %lld\", &x, &y);\n    x--, y--;\n    auto h = f(x, y);\n    auto u = g(x, y);\n    ll cnt = h[0] + 1;\n    cnt += u[1] - h[1];\n    u[1] = (n-1)*u[0] - u[1];\n    ll ret = u[0] + u[1] - h[1];\n    printf(\"%lld\\n\", ret);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[200010];\nint f1[200010][18], f2[200010][18];\nlong long s1[200010][18], s2[200010][18];\n\nint main () {\n\tint n, k; scanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tint pos = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (pos <= n && a[pos] - a[i] < k) pos++;\n\t\tf1[i][0] = s1[i][0] = pos;\n\t}\n\tf1[n + 1][0] = s1[n + 1][0] = n + 1;\n\tpos = n;\n\tfor (int i = n; i >= 1; i--) {\n\t\twhile (pos >= 1 && a[i] - a[pos] < k) pos--;\n\t\tf2[i][0] = s2[i][0] = pos;\n\t}\n\tf2[0][0] = s2[0][0] = 0;\n\tfor (int j = 1; j < 18; j++) {\n\t\tfor (int i = 0; i <= n + 1; i++) {\n\t\t\tf1[i][j] = f1[f1[i][j - 1]][j - 1];\n\t\t\ts1[i][j] = s1[i][j - 1] + s1[f1[i][j - 1]][j - 1];\n\t\t\tf2[i][j] = f2[f2[i][j - 1]][j - 1];\n\t\t\ts2[i][j] = s2[i][j - 1] + s2[f2[i][j - 1]][j - 1];\n\t\t}\n\t}\n\tint q; scanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tint now = l; long long ss1 = l; int c1 = 1;\n\t\tfor (int i = 17; i >= 0; i--) {\n\t\t\tif (f1[now][i] <= r) ss1 += s1[now][i], now = f1[now][i], c1 += 1 << i;\n\t\t}\n\t\tnow = r; long long ss2 = r; int c2 = 1;\n\t\tfor (int i = 17; i >= 0; i--) {\n\t\t\tif (f2[now][i] >= l) ss2 += s2[now][i], now = f2[now][i], c2 += 1 << i;\n\t\t}\n\t\tassert(c1 == c2);\n\t\tprintf(\"%lld\\n\", ss2 - ss1 + c1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<ll, ll, ll>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n// ============ template finished ============\nconst int DBSIZE = 4;\n\n// pair<nextIndex, sum of indexes>\nvector<vector<pll>> dubling(vector<ll> X, int K) {\n    const int N = X.size();\n    vector<pll> next(N);\n    rep(i, N) {\n        int tgt = X[i] + K;\n        int idx = lower_bound(X.begin(), X.end(), tgt) - X.begin();\n        next[i] = { idx, i + 1 };\n    }\n    vector<vector<pll>> db(DBSIZE, vector<pll>(N, { N, 0 }));\n    db[0] = next;\n    REP(row, 1, DBSIZE) {\n        rep(col, N) {\n            auto[now, all] = db[row - 1][col];\n            if (now == N)continue;\n            auto[now2, all2] = db[row - 1][now];\n            db[row][col] = { now2, all + all2 };\n        }\n    }\n    return db;\n}\n\nvector<vector<pll>> dubling_rev(vector<ll>X, int K) {\n    const int N = X.size();\n    vector<pll> next(N);\n    rep(i, N) {\n        int tgt = X[i] - K;\n        int idx = upper_bound(X.begin(), X.end(), tgt) - X.begin() - 1;\n        next[i] = { idx, i + 1 };\n    }\n    vector<vector<pll>> db(DBSIZE, vector<pll>(N, { -1, 0 }));\n    db[0] = next;\n    REP(row, 1, DBSIZE) {\n        rep(col, N) {\n            auto[now, all] = db[row - 1][col];\n            if (now == -1)continue;\n            auto[now2, all2] = db[row - 1][now];\n            db[row][col] = { now2, all + all2 };\n        }\n    }\n    return db;\n}\n\nint pow2(int num) {\n    return 1 << num;\n}\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    vector<ll> X(N);\n    rep(i, N)cin >> X[i];\n    auto db = dubling(X, K);\n    auto dbrev = dubling_rev(X, K);\n\n    int Q;\n    cin >> Q;\n    rep(_, Q) {\n        int L, R;\n        cin >> L >> R;\n        L--;\n        R--;\n\n        ll res = 0;\n        ll totalStep = 1;\n        ll now = L;\n        for (int step = DBSIZE - 1; step >= 0; --step) {\n            if (R < db[step][now].first)continue;\n            totalStep += pow2(step);\n            res -= db[step][now].second;\n            now = db[step][now].first;\n        }\n        res -= now + 1;\n        now = R;\n        for (int step = DBSIZE - 1; step >= 0; --step) {\n            if (dbrev[step][now].first < L)continue;\n            res += dbrev[step][now].second;\n            now = dbrev[step][now].first;\n        }\n        res += now + 1;\n        cout << res + totalStep << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\ntypedef pair<ll, bool> Pb;\ntypedef pair<ll, vector<ll>> Pd;\n\nconst ll INF = 3e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll, vector<ll>, greater<ll> > pqls;\npriority_queue <P, vector<P>, greater<P> > pqps;\n//small priority queue\n//top pop\n\nll dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nll dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};\n//↓,→,↑,←\n\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n#undef endl\n#endif\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)();\n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> mat;\n\nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll m = mod) {ll x = 1; while (b) {while (!(b & 1)) {(a *= a) %= m; b >>= 1;}(x *= a) %= m; b--;} return x;}\nvec readvec(ll read) { vec res(read); for (int i = 0; i < read; i++) { cin >> res[i]; } return res;}\nvoid YES(bool cond) { if (cond) { p(\"YES\");} else { p(\"NO\");} return;}\nvoid Yes(bool cond) { if (cond) { p(\"Yes\");} else { p(\"No\");} return;}\nvoid line() { p(\"--------------------\"); return;}\n\n/*\nll fact[fact_table + 5], rfact[fact_table + 5];\n\nvoid c3_init() {\n    fact[0] = rfact[0] = 1;\n    for (ll i = 1; i <= fact_table; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table], mod - 2, mod);\n    for (ll i = fact_table; i >= 1; i--) {\n        rfact[i - 1] = rfact[i] * i;\n        rfact[i - 1] %= mod;\n    }\n    return;\n}\nll c3(ll n, ll r) {\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n - r]) % mod;\n}\n*/\n\nstruct Timer {\n    int64_t start; const int64_t CYCLES_PER_SEC = 2800000000;\n    Timer() { reset(); }\n    void reset() { start = getCycle(); }\n    inline double get() { return (double)(getCycle() - start) / CYCLES_PER_SEC; }\n    inline int64_t getCycle() {\n        uint32_t low, high; __asm__ volatile (\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n        return ((int64_t)low) | ((int64_t)high << 32);\n    }\n};\n\nbool multicase = false;\n\nll n, k;\nll x[200005], toright[200005][65], toleft[200005][65];\nll torightvalue[200005][65], toleftvalue[200005][65];\n\nvoid precalc() {\n    set<P> st;\n    for (int i = 1; i <= n; i++) {\n        st.insert(P(x[i], i));\n    }\n\n    // 番兵\n    st.insert(P(INF, INF));\n    st.insert(P(-INF, -INF));\n\n    for (int i = 1; i <= n; i++) {\n        ll right = (*st.lower_bound(P(x[i] + k, -INF))).second;\n        toright[i][0] = right;\n        torightvalue[i][0] = (right != INF) ? i : i;\n\n        auto ite = st.lower_bound(P(x[i] - k + 1, -INF));\n        ite --;\n        ll left = (*ite).second;\n        toleft[i][0] = left;\n        toleftvalue[i][0] = (left != -INF) ? i + 1 : i + 1;\n    }\n\n\n\n\n    for (int i = 0; i < 60; i++) {\n        for (int j = 1; j <= n; j++) {\n\n            if (toright[j][i] == INF) {\n                toright[j][i + 1] = INF;\n            } else {\n                toright[j][i + 1] = toright[toright[j][i]][i];\n                torightvalue[j][i + 1] = torightvalue[j][i] + torightvalue[toright[j][i]][i];\n            }\n\n            if (toleft[j][i] == -INF) {\n                toleft[j][i + 1] = -INF;\n            } else {\n                toleft[j][i + 1] = toleft[toleft[j][i]][i];\n                toleftvalue[j][i + 1] = toleftvalue[j][i] + toleftvalue[toleft[j][i]][i];\n            }\n        }\n    }\n    /*\n    for (int j = 1; j <= 20; j++) {\n        p(j);\n        for (int i = 1; i <= n; i++) {\n            pe(toleft[i][j]);\n            p(toright[i][j]);\n        }\n    }\n\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 20; j++) {\n            pe(toleft[i][j]);\n            p(toright[i][j]);\n        }\n    }\n    */\n\n}\n\nvoid solve() {\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n    precalc();\n    ll q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        ll l, r;\n        cin >> l >> r;\n        ll il = l, ir = r;\n        ll haba = 59;\n        ll ans = 0;\n        ll sum1 = 0, sum2 = 0;\n        while (true) {\n            // haba進んでも大丈夫なら進む\n            if (toleft[r][haba] >= il && toright[l][haba] <= ir) {\n                ans += toleftvalue[r][haba] - torightvalue[l][haba];\n                sum1 += toleftvalue[r][haba];\n                sum2 += torightvalue[l][haba];\n                l = toright[l][haba];\n                r = toleft[r][haba];\n            } else {\n                if (haba == 0) {\n                    break;\n                } else {\n                    haba --;\n                }\n            }\n        }\n        /*\n        p(ans);\n        pe(l);p(r);\n        pe(toleftvalue[r][0]);\n        p(torightvalue[l][0]);\n        */\n        ans += toleftvalue[r][0] - torightvalue[l][0];\n        p(ans);\n    }\n\n    return;\n}\n\nint main() {\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    ll q, testcase = 1;\n    if (multicase) {\n        cin >> q;\n    } else {\n        q = 1;\n    }\n    while (q--) {\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n\n    // solve();\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\nint n, k;\nint l, r;\nint a[200200];\nint pre_pos[22][200200], suf_pos[22][200200];\nint q;\nll pre_sum[22][200200], suf_sum[22][200200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> k;\n\trep(i, n) cin >> a[i];\n\tr = 0;\n\tfor(int i = 0; i < n; i++){\n\t\twhile(r < n && a[r] - a[i] < k) r++;\n\t\tsuf_pos[0][i] = r;\n\t\tsuf_sum[0][i] = i;\n\t}\n\tl = n-1;\n\tfor(int i = n-1; i >= 0; i--){\n\t\twhile(l >= 0 && a[i] - a[l] < k) l--;\n\t\tpre_pos[0][i] = l;\n\t\tpre_sum[0][i] = i;\n\t}\n\tfor(int i = 0; i < 20; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tpre_pos[i + 1][j] = (pre_pos[i][j] < 0) ? -1 : pre_pos[i][pre_pos[i][j]];\n\t\t\tpre_sum[i + 1][j] = (pre_pos[i][j] < 0) ? pre_sum[i][j] : (ll)(pre_sum[i][j] + pre_sum[i][pre_pos[i][j]]);\n\t\t\tsuf_pos[i + 1][j] = (suf_pos[i][j] >= n) ? n : suf_pos[i][suf_pos[i][j]];\n\t\t\tsuf_sum[i + 1][j] = (suf_pos[i][j] >= n) ? suf_sum[i][j] : (ll)(suf_sum[i][j] + suf_sum[i][suf_pos[i][j]]);\n\t\t}\n\t}\n\tcin >> q;\n\twhile(q--){\n\t\tcin >> l >> r;\n\t\tl--, r--;\n\t\tint nl = l, nr = r;\n\t\tint l_ans = 1, r_ans = 1; \n\t\tll l_sum = 0, r_sum = 0;\n\t\tfor(int i = 20; i >= 0; i--){\n\t\t\tif(suf_pos[i][nl] <= r){\n\t\t\t\tl_ans += (1 << i);\n\t\t\t\tl_sum += suf_sum[i][nl];\n\t\t\t\tnl = suf_pos[i][nl];\n\t\t\t}\n\t\t}\n\t\tl_sum += nl;\n\t\tfor(int i = 20; i >= 0; i--){\n\t\t\tif(pre_pos[i][nr] >= l){\n\t\t\t\tr_ans += (1 << i);\n\t\t\t\tr_sum += pre_sum[i][nr];\n\t\t\t\tnr = pre_pos[i][nr];\n\t\t\t}\n\t\t}\n\t\tr_sum += nr;\n\t\tassert(l_ans == r_ans);\n\t\tcout << r_sum - l_sum + l_ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long llo;\n#define mp make_pair\n#define pb push_back\n#define a first \n#define b second\n#define endl '\\n' \n\nllo n,k;\nllo q;\nllo it[200001];\npair<llo,llo> ss[200001][20];\npair<llo,llo> tt[200001][20];\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcin>>n>>k;\n\tfor(llo i=0;i<n;i++){\n\t\tcin>>it[i];\n\t}\n\tfor(llo i=n-1;i>=0;i--){\n\t\tif(it[n-1]<it[i]+k){\n\t\t\tss[i][0]={-1,0};\n\t\t}\n\t\telse{\n\t\t\tllo xx=ss[i+1][0].a;\n\t\t\tif(xx==-1){\n\t\t\t\txx=n-1;\n\t\t\t}\n\t\t\tfor(llo j=xx;j>=i;j--){\n\t\t\t\tif(it[j]<it[i]+k){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tss[i][0]={j,j};\n\t\t\t}\n\t\t}\n\t}\n\tfor(llo i=0;i<n;i++){\n\t\tif(it[0]>it[i]-k){\n\t\t\ttt[i][0]={-1,0};\n\t\t}\n\t\telse{\n\t\t\tllo xx=tt[i-1][0].a;\n\t\t\tif(xx==-1){\n\t\t\t\txx=0;\n\t\t\t}\n\t\t\tfor(llo j=xx;j<=i;j++){\n\t\t\t\tif(it[j]>it[i]-k){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttt[i][0]={j,j};\n\t\t\t}\n\t\t}\n\t}\n\tfor(llo j=1;j<20;j++){\n\t\tfor(llo i=0;i<n;i++){\n\t\t\tif(ss[i][j-1].a==-1){\n\t\t\t\tss[i][j]={-1,0};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tss[i][j]={ss[ss[i][j-1].a][j-1].a,-1};\n\t\t\tif(ss[i][j].a==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tss[i][j].b=ss[i][j-1].b+ss[ss[i][j-1].a][j-1].b;\n\t\t}\n\t}\n\tfor(llo j=1;j<20;j++){\n\t\tfor(llo i=0;i<n;i++){\n\t\t\tif(tt[i][j-1].a==-1){\n\t\t\t\ttt[i][j]={-1,0};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttt[i][j]={tt[tt[i][j-1].a][j-1].a,-1};\n\t\t\tif(tt[i][j].a==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttt[i][j].b=tt[i][j-1].b+tt[tt[i][j-1].a][j-1].b;\n\t\t}\n\t}\n\t/*for(llo i=0;i<n;i++){\n\t\tcout<<ss[i][0].a<<\":\";\n\t}\n\tcout<<endl;\n\tfor(llo i=0;i<n;i++){\n\t\tcout<<tt[i][0].a<<\":\";\n\t}\n\tcout<<endl;\n*/\n\n\tcin>>q;\n\twhile(q--){\n\t\tllo aa,bb;\n\t\tcin>>aa>>bb;\n\t\taa--;\n\t\tbb--;\n\t\tllo x=1;\n\t\tllo su=aa;\n\t\tllo cur=aa;\n\t\tfor(llo j=19;j>=0;j--){\n\t\t\tif(ss[cur][j].a==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ss[cur][j].a<=bb){\n\t\t\t\tx+=(1<<j);\n\t\t\t\t//cout<<j<<\":\";\n\t\t\t\tsu+=ss[cur][j].b;\n\t\t\t\tcur=ss[cur][j].a;\n\t\t\t}\n\t\t}\n\t\t//cout<<endl;\n\t\tllo su2=bb;\n\t\tcur=bb;\n\t\tfor(llo j=19;j>=0;j--){\n\t\t\tif(tt[cur][j].a==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(tt[cur][j].a>=aa){\n\t\t\t\tsu2+=tt[cur][j].b;\n\t\t\t\tcur=tt[cur][j].a;\n\t\t\t}\n\t\t}\n\t\tcout<<(su2-su+x)<<endl;\n\t\t\n\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <atcoder/all>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace atcoder;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000000;\nconst int K = 20;\n//const int mod = 998244353;\n\nusing mint = modint998244353;\n\nmint p[N], s[N];\npair <int, int> l[N][K], r[N][K];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n, k;\n    cin >> n >> k;\n    vector <int> x(n + 2);\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    x[0] = -2e9;\n    x[n + 1] = 2e9;\n    for (int i = 1; i <= n; i++){\n        int v = (int)(lower_bound(x.begin(), x.end(), k + x[i]) - x.begin());\n        r[0][i] = {v, -v};\n        v = (int)(upper_bound(x.begin(), x.end(), -k + x[i]) - x.begin());\n        l[0][i] = {v - 1, v - 1};\n    }\n    r[0][n + 1] = {n + 1, 0};\n    for (int i = 1; i < K; i++){\n        for (int j = 1; j <= n + 1; j++){\n            auto y = r[i - 1][j];\n            r[i][j].F = r[i - 1][y.F].F;\n            r[i][j].S = r[i - 1][y.F].S + y.S;\n            y = l[i - 1][j];\n            l[i][j].F = l[i - 1][y.F].F;\n            l[i][j].S = l[i - 1][y.F].S + y.S;\n        }\n    }\n    int q;\n    cin >> q;\n    while(q--){\n        int ls, rs;\n        cin >> ls >> rs;\n        int ans = rs - ls;\n        int v = ls;\n        int z = 1;\n        for (int i = K - 1; i >= 0; i--){\n            if (x[r[i][v].F] <= x[rs]){\n                z += (1 << i);\n                ans += r[i][v].S;\n                v = r[i][v].F;\n            }\n        }\n        v = rs;\n        int f = 1;\n        for (int i = K - 1; i >= 0; i--){\n            if (x[l[i][v].F] >=  x[ls]){\n                f += (1 << i);\n                ans += l[i][v].S;\n                v = l[i][v].F;\n            }\n        }\n        ans += z;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct BIT {\n\t\tint dt[1 << 18];\n\t\tvoid inline add(int a, int x) {\n\t\t\twhile(a < (1 << 18)) {\n\t\t\t\tdt[a] += x;\n\t\t\t\ta += a & -a;\n\t\t\t}\n\t\t}\n\t\tint inline sum(int a) {\n\t\t\tint res = 0;\n\t\t\twhile(a) {\n\t\t\t\tres += dt[a];\n\t\t\t\ta -= a & -a;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} bit;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18], tag;\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) bit.add(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (tag ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tint inline sum(int a, int b) {\n\t\tint res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += bit.sum(dfn[a]) - bit.sum(dfn[rt] - 1);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0); tl.tag = 1;\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%d\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\n#define int long long\nsigned main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi ans(Q);\n    vi L(Q), R(Q);\n    rep(i, Q) cin >> L[i] >> R[i];\n    rep(_, 2)\n    {\n        vv(int, nxt, 20, n + 1, n);\n        vv(int, cnt, 20, n + 1);\n        rep(i, n)\n        {\n            nxt[0][i] = lb(a, a[i] + k);\n            cnt[0][i] = nxt[0][i] - i;\n        }\n        rep(i, 19)\n        {\n            rep(j, n)\n            {\n                nxt[i + 1][j] = nxt[i][nxt[i][j]];\n                cnt[i + 1][j] = cnt[i][nxt[i][j]] + (1LL << i) * (nxt[i][j] - j) + cnt[i][j];\n            }\n        }\n        rep(ii, Q)\n        {\n            int l = L[ii], r = R[ii];\n            if (_)\n            {\n                swap(l, r);\n                l = n - l, r = n + 1 - r;\n            }\n            else\n                l--;\n            int d = r - l;\n            int m = 0;\n            int now = l;\n            rep3(i, 19, 0)\n            {\n                if (nxt[i][now] < r)\n                    m += 1 << i, now = nxt[i][now];\n            }\n            if (_)\n                ans[ii] += d * (m + 1);\n            now = l;\n            ll rem = 1;\n            rep(i, 20)\n            {\n                if (m & 1 << i)\n                    rem += 1 << i, ans[ii] -= cnt[i][now] + (now - l) * rem, now = nxt[i][now];\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T> vi iota(vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nint main() {\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi l(Q), r(Q);\n    rep(i, Q) cin >> l[i] >> r[i];\n    vll ans(Q);\n    rep(_, 2) {\n        vv(int, nxt, 20, n + 1, n);\n        vv(ll, sum, 20, n + 1);\n        rep(i, n) {\n            nxt[0][i] = lb(a, a[i] + k);\n            sum[0][i] = nxt[0][i];\n        }\n        rep(i, 19) { rep(j, n) nxt[i + 1][j] = nxt[i][nxt[i][j]], sum[i + 1][j] = sum[i][j] + sum[i][nxt[i][j]]; }\n        rep(i, Q) {\n            ll m = 0;\n            int L = l[i], R = r[i];\n            if(_) {\n                swap(L, R);\n                R = n + 1 - R, L = n - L;\n            } else\n                L--;\n            int now = L;\n            rep3(j, 19, 0) {\n                if(nxt[j][now] < R) now = nxt[j][now], m += 1 << j;\n            }\n            ans[i] += (m + 1) * R;\n            ans[i] -= L;\n            if(_) ans[i] -= (m + 1) * (R - L);\n            now = L;\n            rep(j, 20) {\n                if(m & 1 << j) ans[i] -= sum[j][now], now = nxt[j][now];\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nll binary_search(\n    ll lo, ll hi, function<bool(ll)> is_ok,\n    bool maximize\n){\n    while(lo < hi){\n        if(maximize){\n            const ll mid = (lo + hi + 1) / 2;\n            if(is_ok(mid)){\n                lo = mid;\n            }else{\n                hi = mid - 1;\n            }\n        }else{\n            ll mid = (lo + hi - 1) / 2;\n            if(is_ok(mid)){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }\n        }\n    }\n    return lo;\n}\n\ntemplate<typename S, S op(S, S)>\nstruct Doubling {\n    vector<vector<S>> v;\n\n    Doubling(const vector<S>& step1, ll p){\n        const auto n = step1.size();\n        v.resize(p);\n        v.at(0) = step1;\n        for(ll i = 1; i < p; ++i){\n            v.at(i).resize(n);\n            for(ll j = 0; j < n; ++j){\n                const auto& x = v.at(i - 1).at(j);\n                const auto& y = v.at(i - 1).at(x.index);\n                v.at(i).at(j) = op(x, y);\n            }\n        }\n    }\n\n    S query(S init, ll nstep){\n        S ret = init;\n        REP(i, v.size()){\n            if((nstep >> i) & 1){\n                ret = op(ret, v.at(i).at(ret.index));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct S { ll index_sum, is_ok, index; };\nS op(S x, S y){\n    return S{\n        x.index_sum + y.index_sum,\n        y.is_ok,\n        y.index\n    };\n}\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(n);\n    REP(i, n){ cin >> x.at(i); }\n\n    vector<S> l2r_1step(n), r2l_1step(n);\n    REP(i, n){\n        const auto xi = x.at(i);\n        // to right\n        ll ridx = lower_bound(ALL(x), xi + k) - x.begin();\n        if(ridx >= x.size()){\n            l2r_1step.at(i) = S{0, false, i};\n        }else{\n            l2r_1step.at(i) = S{ridx, true, ridx};\n        }\n\n        // to left\n        ll lidx = upper_bound(ALL(x), xi - k) - x.begin();\n        lidx--;\n        if(lidx < 0){\n            r2l_1step.at(i) = S{0, false, i};\n        }else{\n            r2l_1step.at(i) = S{lidx, true, lidx};\n        }\n    }\n\n    Doubling<S, op> d_l2r(l2r_1step, 30), d_r2l(r2l_1step, 30);\n\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n\n        // cerr << \"i=\" << i << \", l=\" << l << \", r=\" << r << endl;\n\n        const ll num = ::binary_search(\n            0, (x.at(r) - x.at(l)) / k + 1,\n            [&](ll m) -> bool {\n                const auto tmp = d_l2r.query(S{l, true, l}, m);\n                return tmp.is_ok && x.at(tmp.index) <= x.at(r);\n            },\n            true\n        );\n        // cerr << \"  num=\" << num << endl;\n\n        const S l2r = d_l2r.query(S{l, true, l}, num);\n        const S r2l = d_r2l.query(S{r, true, r}, num);\n        // cerr << \"  l2r={\" << l2r.index_sum << \", \" << l2r.is_ok << \", \" << l2r.index << \"}\" << endl;\n        // cerr << \"  r2l={\" << r2l.index_sum << \", \" << r2l.is_ok << \", \" << r2l.index << \"}\" << endl;\n        assert(l2r.is_ok && x.at(l2r.index) <= x.at(r));\n        assert(r2l.is_ok && x.at(r2l.index) >= x.at(l));\n\n        cout << r2l.index_sum - l2r.index_sum + num + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)\n#define mk make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define IT iterator \n#define vi vector<int>\n#define TP template<class o>\n#define SZ(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nconst int N=2e5+10,size=1<<20,mod=998244353,inf=2e9;\n\n//char buf[size],*p1=buf,*p2=buf;\ntemplate<class o> void qr(o &x) {\n    char c=gc; x=0; int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n    while(isdigit(c)) x=x*10+c-'0',c=gc;\n    x*=f;\n}\ntemplate<class o> void qw(o x) {\n    if(x/10) qw(x/10);\n    putchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n    if(x<0)x=-x,putchar('-');\n    qw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n    if(x<0)x=-x,putchar('-');\n    qw(x); putchar('\\n');\n}\n\nint n,m,q,lg,x[N],r[N][20],l[N][20];\nll sl[N][20],sr[N][20];\n\nint main() {\n    qr(n); qr(m);\n    for(int i=1;i<=n;i++) qr(x[i]);\n    for(int i=1;i<=n;i++) {\n        r[i][0]=r[i-1][0];\n        while(r[i][0]<=n&&x[r[i][0]]-x[i]<m) r[i][0]++;\n        sr[i][0]=r[i][0]-1;\n    }\n    l[n+1][0]=n;\n    for(int i=n;i;i--) {\n        l[i][0]=l[i+1][0];\n        while(l[i][0]&&x[i]-x[l[i][0]]<m) l[i][0]--;\n        sl[i][0]=l[i][0];\n    }\n    for(int i=0;i<20;i++) r[n+1][i]=n+1;\n    for(int j=1;(1<<j)<=n;j++,lg++)\n        for(int i=1;i<=n;i++) {\n            l[i][j]=l[l[i][j-1]][j-1];\n            sl[i][j]=sl[i][j-1]+sl[l[i][j-1]][j-1];\n            r[i][j]=r[r[i][j-1]][j-1];\n            sr[i][j]=sr[i][j-1]+sr[r[i][j-1]][j-1];\n        }\n    qr(q); while(q--) {\n        int L,R; qr(L); qr(R); ll ans=0;\n        ans -= L-1;\n        for(int v=L,i=lg;i>=0;i--)\n            if(r[v][i]<=R) \n\t\t\t\tans -= sr[v][i],v=r[v][i];\n        ans += R; \n        for(int v=R,i=lg;i>=0;i--)\n            if(l[v][i]>=L) \n\t\t\t\tans += sl[v][i],v=l[v][i];\n        pr2(ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Package: StandardCodeLibrary.Core\n * */\n//引进常用的头文件并使用std名字空间;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//用于减少代码量的宏;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl(x) while (x)\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//调试相关的宏;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(\"OLE\");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,\"r\",stdin)\n#define output(out) freopen(out,\"w\",stdout)\n#else\n#define prt(x) cerr<<\"第\"<<__LINE__<<\"行\\t: \"<<#x\"\\t=\"<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<\"assert(\"#s\")\"<<endl;whl(0)\n#define runtime() cerr<<\"Used: \"<<db(clock())/CLOCKS_PER_SEC<<\"s\"<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//常用数据类型;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char *cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int, int> pii;\ntypedef pr<lli, lli> pll;\ntypedef pr<db, db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int, int> mii;\ntypedef map<str, int> msi;\ntypedef map<char, int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//常用常量:int的最大值;lli的最大值;db的误差相关常数;欧拉常数;圆周率;移动向量;取模使用的除数;\nint oo = (~0u) >> 1;\nlli ooll = (~0ull) >> 1;\ndb inf = 1e+10;\ndb eps = 1e-10;\ndb gam = 0.5772156649015328606;\ndb pi = acos(-1.0);\nint dx[] = { 1, 0, -1, 0, 1, -1, -1, 1, 0 };\nint dy[] = { 0, 1, 0, -1, 1, 1, -1, -1, 0 };\nint MOD = 1000000007;\n\n//常用函数:最大最小值更新;数学相关函数;输入和输出;树状数组;并查集;可合并堆;\ntemplate<typename type> inline bool cmax(type &a, const type &b) {\n\trtn a < b ? a = b, true : false;\n}\ntemplate<typename type> inline bool cmin(type &a, const type &b) {\n\trtn b < a ? a = b, true : false;\n}\ntemplate<typename type> inline type sqr(const type &x) {\n\trtn x * x;\n}\ntemplate<typename type> inline type mod(const type &x) {\n\trtn x % MOD;\n}\ninline int sgn(const db &x) {\n\trtn (x > +eps) - (x < -eps);\n}\ninline int dbcmp(const db &a, const db &b) {\n\trtn sgn(a - b);\n}\ntemplate<typename type> inline pr<type, type> operator-(\n\t\tconst pr<type, type> &x) {\n\trtn mp(-x.x, -x.y);\n}\ntemplate<typename type> inline pr<type, type> operator+(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn mp(a.x + b.x, a.y + b.y);\n}\ntemplate<typename type> inline pr<type, type> operator-(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn mp(a.x - b.x, a.y - b.y);\n}\ntemplate<typename type> inline pr<type, type> operator*(const pr<type, type> &a,\n\t\tconst type &b) {\n\trtn mp(a.x * b, a.y * b);\n}\ntemplate<typename type> inline pr<type, type> operator/(const pr<type, type> &a,\n\t\tconst type &b) {\n\trtn mp(a.x / b, a.y / b);\n}\ntemplate<typename type> inline pr<type, type>& operator-=(pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a = a - b;\n}\ntemplate<typename type> inline pr<type, type>& operator+=(pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a = a + b;\n}\ntemplate<typename type> inline pr<type, type>& operator*=(pr<type, type> &a,\n\t\tconst type &b) {\n\trtn a = a * b;\n}\ntemplate<typename type> inline pr<type, type>& operator/=(pr<type, type> &a,\n\t\tconst type &b) {\n\trtn a = a / b;\n}\ntemplate<typename type> inline type cross(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a.x * b.y - a.y * b.x;\n}\ntemplate<typename type> inline type dot(const pr<type, type> &a,\n\t\tconst pr<type, type> &b) {\n\trtn a.x * b.x + a.y * b.y;\n}\ntemplate<typename type> inline type gcd(type a, type b) {\n\tif (b)\n\t\twhl((a %= b) && (b %= a));\n\trtn a + b;\n}\ntemplate<typename type> inline type lcm(type a, type b) {\n\trtn a * b / gcd(a, b);\n}\ninline lli bin_pow(lli x, lli y) {\n\tlli z = 1;\n\twhl(y) {\n\t\tif (y & 1)\n\t\t\tz = mod(z * x);\n\t\tx = mod(sqr(x)), y >>= 1;\n\t}\n\trtn z;\n}\ntemplate<typename istream, typename first_type, typename second_type> inline istream& operator>>(\n\t\tistream &cin, pr<first_type, second_type> &x) {\n\trtn cin >> x.x >> x.y;\n}\ntemplate<typename ostream, typename first_type, typename second_type> inline ostream& operator<<(\n\t\tostream &cout, const pr<first_type, second_type> &x) {\n\trtn cout << x.x << \" \" << x.y;\n}\ntemplate<typename istream, typename type> inline istream& operator>>(\n\t\tistream &cin, vec<type> &x) {\n\trep(i,sz(x))\n\t\tcin >> x[i];\n\trtn cin;\n}\ntemplate<typename ostream, typename type> inline ostream& operator<<(\n\t\tostream &cout, const vec<type> &x) {\n\trep(i,sz(x))\n\t\tcout << x[i] << (i + 1 == sz(x) ? \"\" : \" \");\n\trtn cout;\n}\ninline ostream& pdb(int prcs, db x) {\n\trtn cout << setprecision(prcs) << fixed << (sgn(x) ? (x) : 0);\n}\ntemplate<typename type> inline void bit_inc(vec<type> &st, int x, type inc) {\n\twhl(x<sz(st))\n\t\tst[x] += inc, x |= x + 1;\n}\ntemplate<typename type> inline type bit_sum(const vec<type> &st, int x) {\n\ttype s = 0;\n\twhl(x>=0)\n\t\ts += st[x], x = (x & (x + 1)) - 1;\n\trtn s;\n}\ntemplate<typename type> inline type bit_kth(const vec<type> &st, int k) {\n\tint x = 0, y = 0, z = 0;\n\twhl((1<<(++y))<=sz(st));\n\trrep(i,y)\n\t{\n\t\tif ((x += 1 << i) > sz(st) || z + st[x - 1] > k)\n\t\t\tx -= 1 << i;\n\t\telse\n\t\t\tz += st[x - 1];\n\t}\n\trtn x;\n}\ninline void make_set(vi &st) {\n\trep(i,sz(st))\n\t\tst[i] = i;\n}\ninline int find_set(vi &st, int x) {\n\tint y = x, z;\n\twhl(y!=st[y])\n\t\ty = st[y];\n\twhl(x!=st[x])\n\t\tz = st[x], st[x] = y, x = z;\n\trtn y;\n}\ninline bool union_set(vi &st, int a, int b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ? st[a] = b, true : false;\n}\ninline void make_set(vpii &st) {\n\trep(i,sz(st))\n\t\tst[i] = mp(i, 1);\n}\ninline int find_set(vpii &st, int x) {\n\tint y = x, z;\n\twhl(y!=st[y].x)\n\t\ty = st[y].x;\n\twhl(x!=st[x].x)\n\t\tz = st[x].x, st[x].x = y, x = z;\n\trtn y;\n}\ninline bool union_set(vpii &st, int a, int b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ?\n\t\t\t(st[a].y > st[b].y ? st[a].x = b, st[a].y += st[b].y : st[b].x = a, st[b].y +=\n\t\t\t\t\tst[a].y), true :\n\t\t\tfalse;\n}\ntemplate<typename type> inline void merge(type &a, type &b) {\n\tif (sz(a) < sz(b))\n\t\tswap(a, b);\n\twhl(sz(b))\n\t\ta.ins(*b.begin()), b.ers(b.begin());\n}\n\n//初始化;\nstruct Initializer {\n#ifndef DEBUG\n\tInitializer() {\n\t\tios::sync_with_stdio(false);\n\t\tcin.tie(0);\n\t\tcout.tie(0);\n\t}\n#else\n\t~Initializer() {\n\t\truntime();\n\t}\n#endif\n} initializer;\n\n//非标准;\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx ::rope<char> rope;\ntemplate<typename key, typename value> class ext_map: public __gnu_pbds::tree<\n\t\tkey, value, less<key>, __gnu_pbds ::rb_tree_tag,\n\t\t__gnu_pbds ::tree_order_statistics_node_update> {\n};\ntemplate<typename key> class ext_set: public __gnu_pbds::tree<key,\n\t\t__gnu_pbds ::null_type, less<key>, __gnu_pbds ::rb_tree_tag,\n\t\t__gnu_pbds ::tree_order_statistics_node_update> {\n};\n\ninline pii find_set(map<pii, pii> &st, pii x) {\n\tif (!st.count(x)) {\n\t\trtn st[x] = x;\n\t} else if (st[x] == x) {\n\t\trtn x;\n\t} else {\n\t\trtn st[x] = find_set(st, st[x]);\n\t}\n}\ninline bool union_set(map<pii, pii> &st, pii a, pii b) {\n\ta = find_set(st, a), b = find_set(st, b);\n\trtn a != b ? st[a] = b, true : false;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tvi x(n + 1);\n\tft(i,1,n)\n\t\tcin >> x[i];\n\n\tvvi pre(20, vi(n + 1)), suf(20, vi(n + 1));\n\tvvi pres(20, vi(n + 1)), sufs(20, vi(n + 1));\n\tauto index = [&](vvi &pre, vvi &pres, vi &x) {\n\t\tint j = 0;\n\t\tft(i,1,n)\n\t\t{\n\t\t\twhile (abs(x[i] - x[j + 1]) >= k) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tpre[0][i] = j;\n\t\t\tpres[0][i] = i;\n\t\t\trepf(j,1,20)\n\t\t\t{\n\t\t\t\tpre[j][i] = pre[j - 1][pre[j - 1][i]];\n\t\t\t\tpres[j][i] = pres[j - 1][i] + pres[j - 1][pre[j - 1][i]];\n\t\t\t}\n\t\t}\n\t};\n\tindex(pre, pres, x);\n\treverse(x.begin() + 1, x.end());\n\tindex(suf, sufs, x);\n\tint q;\n\tcin >> q;\n\trep(i,q)\n\t{\n\t\tauto get = [](vvi &pre, vvi &pres, int l, int r) {\n\t\t\tint cnt = 0, sum = 0;\n\t\t\trrep(i,20)\n\t\t\t{\n\t\t\t\tif (pre[i][r] >= l) {\n\t\t\t\t\tcnt += 1 << i;\n\t\t\t\t\tsum += pres[i][r];\n\t\t\t\t\tr = pre[i][r];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r >= l) {\n\t\t\t\tcnt++;\n\t\t\t\tsum += pres[0][r];\n\t\t\t}\n\t\t\trtn mp(cnt, sum);\n\t\t};\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint s = get(pre, pres, l, r).x;\n//\t\tprt(get(pre, pres, l, r));\n//\t\tprt(get(suf, sufs, n - r + 1, n - l + 1));\n\t\tint ans = get(pre, pres, l, r).y\n\t\t\t\t- ((n + 1) * s - get(suf, sufs, n - r + 1, n - l + 1).y) + s;\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<long long int>v(N + 2);\n\tfor (int i = 1; i <= N; i++)cin >> v[i];\n\tv[0] = -MOD * MOD;\n\tv.back() = MOD * MOD;\n\tcin >> T;\n\tN += 2;\n\tvector<vector<long long int>>ord_tapi(N, vector<long long int>(20, -1));\n\tvector<vector<long long int>>ord_sum(N, vector<long long int>(20));\n\tvector<vector<long long int>>rev_tapi(N, vector<long long int>(20, -1));\n\tvector<vector<long long int>>rev_sum(N, vector<long long int>(20));\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\twhile (cnt != -1 && v[cnt] - v[i] < K) {\n\t\t\tcnt++;\n\t\t\tif (cnt == N) {\n\t\t\t\tcnt = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tord_tapi[i][0] = cnt;\n\t\tord_sum[i][0] = i;\n\t}\n\tfor (int j = 1; j < 20; j++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (ord_tapi[i][j - 1] == -1)continue;\n\t\t\tord_tapi[i][j] = ord_tapi[ord_tapi[i][j - 1]][j - 1];\n\t\t\tord_sum[i][j] = ord_sum[i][j - 1] + ord_sum[ord_tapi[i][j - 1]][j - 1];\n\t\t}\n\t}\n\tcnt = N - 1;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\twhile (cnt != -1 && v[i] - v[cnt] < K) {\n\t\t\tcnt--;\n\t\t\tif (cnt == -1) {\n\t\t\t\tcnt = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trev_tapi[i][0] = cnt;\n\t\trev_sum[i][0] = i;\n\t}\n\tfor (int j = 1; j < 20; j++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (rev_tapi[i][j - 1] == -1)continue;\n\t\t\trev_tapi[i][j] = rev_tapi[rev_tapi[i][j - 1]][j - 1];\n\t\t\trev_sum[i][j] = rev_sum[i][j - 1] + rev_sum[rev_tapi[i][j - 1]][j - 1];\n\t\t}\n\t}\n\twhile (T--) {\n\t\tcin >> L >> R;\n\t\tlong long int ans = 0;\n\t\tint num = 0;\n\t\tint p = L;\n\t\tfor (int cnt = 19; cnt >= 0; cnt--) {\n\t\t\tif ((ord_tapi[p][cnt] != -1 && ord_tapi[p][cnt] <= R)) {\n\t\t\t\tnum |= 1 << cnt;\n\t\t\t\tans -= ord_sum[p][cnt];\n\t\t\t\tp = ord_tapi[p][cnt];\n\t\t\t}\n\t\t}\n\t\tans -= ord_sum[p][0];\n\t//\tcout << num << endl;\n\t//\tcout << ans << endl;\n\t\tnum = 0;\n\t\tp = R;\n\t\tfor (int cnt = 19; cnt >= 0; cnt--) {\n\t\t\tif ((rev_tapi[p][cnt] != -1 && rev_tapi[p][cnt] >= L)) {\n\t\t\t\tnum |= 1 << cnt;\n\t\t\t\tans += rev_sum[p][cnt];\n\t\t\t\tp = rev_tapi[p][cnt];\n\t\t\t}\n\t\t}\n\t\tans += rev_sum[p][0];\n\t\tcout << ans + num + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint n, k;\nint a[N];\nint t1[N][20];\nint t2[N][20];\nlong long s1[N][20];\nlong long s2[N][20];\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> k;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        for(int i = 1, j = 0, h = 1; i <= n; i++){\n                while(a[i] - a[j + 1] >= k){\n                        j += 1;\n                }\n                while(h <= n && a[h] - a[i] < k){\n                        h += 1;\n                }\n                t1[i][0] = s1[i][0] = j;\n                t2[i][0] = s2[i][0] = h;\n        }\n        t2[n + 1][0] = n + 1;\n        for(int i = 1; i < 20; i++){\n                for(int j = 0; j <= n + 1; j++){\n                        t1[j][i] = t1[t1[j][i - 1]][i - 1];\n                        t2[j][i] = t2[t2[j][i - 1]][i - 1];\n                        s1[j][i] = s1[j][i - 1] + s1[t1[j][i - 1]][i - 1];\n                        s2[j][i] = s2[j][i - 1] + s2[t2[j][i - 1]][i - 1];\n                }\n        }\n        int q;\n        cin >> q;\n        while(q--){\n                int l, r;\n                cin >> l >> r;\n                int x = l, y = r;\n                long long res = r - l + 1;\n                for(int i = 19; i >= 0; i--){\n                        if(t2[x][i] <= r){\n                                assert(t1[y][i] >= l);\n                                res -= s2[x][i];\n                                res += s1[y][i];\n                                res += (1 << i);\n                                x = t2[x][i];\n                                y = t1[y][i];\n                        }\n                }\n                cout << res << \"\\n\";\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nconst int LOGN = 18;\nint n, K, a[N], pa1[LOGN][N], pa2[LOGN][N];\nlong long sum1[LOGN][N], sum2[LOGN][N];\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1, j = 1; i <= n; i++) {\n\t\twhile (j <= n && a[j] - a[i] < K) j++;\n\t\tpa1[0][i] = j;\n\t\tsum1[0][i] = j;\n\t}\n\tfor (int i = 0; i < LOGN; i++) pa1[i][n + 1] = n + 1;\n\tfor (int i = 1; i < LOGN; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tpa1[i][j] = pa1[i - 1][pa1[i - 1][j]];\n\t\t\tsum1[i][j] = sum1[i - 1][j] + sum1[i - 1][pa1[i - 1][j]];\n\t\t}\n\tfor (int i = n, j = n; i >= 1; i--) {\n\t\twhile (j > 0 && a[i] - a[j] < K) j--;\n\t\tpa2[0][i] = j;\n\t\tsum2[0][i] = j;\n\t}\n\tfor (int i = 0; i < LOGN; i++) pa2[i][0] = 0;\n\tfor (int i = 1; i < LOGN; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tpa2[i][j] = pa2[i - 1][pa2[i - 1][j]];\n\t\t\tsum2[i][j] = sum2[i - 1][j] + sum2[i - 1][pa2[i - 1][j]];\n\t\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tint u = l;\n\t\tlong long s1 = l;\n\t\tint cnt = 1;\n\t\tfor (int i = LOGN - 1; i >= 0; i--) if (pa1[i][u] <= r) {\n\t\t\tcnt += (1 << i);\n\t\t\ts1 += sum1[i][u];\n\t\t\tu = pa1[i][u];\n\t\t}\n\t\tu = r;\n\t\tlong long s2 = r;\n\t\tfor (int i = LOGN - 1; i >= 0; i--) if (pa2[i][u] >= l) {\n\t\t\ts2 += sum2[i][u];\n\t\t\tu = pa2[i][u];\n\t\t}\n\t\tprintf(\"%lld\\n\", s2 - s1 + cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[18][201010], toL[18][201010];\nint totR[18][201010], totL[18][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 17, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 18) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 18) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 18) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 18) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 18) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toR[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 18) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 18) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define CPP17\n#include <limits>\n#include <initializer_list>\n#include <utility>\n#include <bitset>\n#include <tuple>\n#include <type_traits>\n#include <functional>\n#include <string>\n#include <array>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <iterator>\n#include <algorithm>\n#include <complex>\n#include <random>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <regex>\n#include <cassert>\n#include <cstddef>\n#ifdef CPP17\n#include <variant>\n#endif\n\n#define endl codeforces\n\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\n\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\nusing size_type = ssize_t;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\ntemplate <typename T, std::size_t Head, std::size_t... Tail> \nstruct multi_dim_array { using type = std::array<typename multi_dim_array<T, Tail...>::type, Head>; };\n\ntemplate <typename T, std::size_t Head> \nstruct multi_dim_array<T, Head> { using type = std::array<T, Head>; };\n\ntemplate <typename T, std::size_t... Args> using mdarray = typename multi_dim_array<T, Args...>::type;\n\n#ifdef CPP17\ntemplate <typename T, typename F, typename... Args> \nvoid fill_seq(T &t, F f, Args... args) { \n    if constexpr (std::is_invocable<F, Args...>::value) { \n        t = f(args...); \n    } else { \n        for (size_type i = 0; i < t.size(); i++) fill_seq(t[i], f, args..., i); \n    } \n}\n#endif\n\ntemplate <typename T> vec<T> make_v(size_type sz) { return vec<T>(sz); }\n\ntemplate <typename T, typename... Tail> \nauto make_v(size_type hs, Tail&&... ts) { \n    auto v = std::move(make_v<T>(std::forward<Tail>(ts)...)); \n    return vec<decltype(v)>(hs, v); \n}\n\nnamespace init__ { \nstruct InitIO { \n    InitIO() { \n        std::cin.tie(nullptr); \n        std::ios_base::sync_with_stdio(false); \n        std::cout << std::fixed << std::setprecision(30); \n    } \n} init_io; \n}\ntemplate <typename T>\nT ceil_pow2(T bound) {\n    T ret = 1;\n    while (ret < bound) ret *= 2;\n    return ret;\n}\ntemplate <typename T>\nT ceil_div(T a, T b) { return a / b + !!(a % b); }\n#define CPP17\n\n\nint main() {\n    ll n, k;\n    std::cin >> n >> k;\n    vec<ll> xv(n + 2);\n    const ll inf = 5e15;\n    for (ll i = 1; i <= n; i++) std::cin >> xv[i];\n    xv[0] = -inf - 10;\n    xv[n + 1] = inf + 10;\n\n    auto fdp = make_v<ll>(20, n + 2);\n    fill_seq(fdp, [&](ll k, ll i) { return i; });\n    auto fsum = fdp;\n    auto bdp = fdp;\n    auto bsum = fsum;\n\n    {\n        for (ll i = 1; i <= n; i++) {\n            auto ite = std::lower_bound(ALL(xv), xv[i] + k);\n            ll idx = std::distance(xv.begin(), ite);\n            fdp[0][i] = idx;\n            fsum[0][i] = i;\n        }\n        for (ll k = 0; k + 1 < 20; k++) for (ll i = 0; i < n + 2; i++) {\n            ll nxt = fdp[k][i];\n            fdp[k + 1][i] = fdp[k][nxt];\n            fsum[k + 1][i] = fsum[k][i] + fsum[k][nxt];\n        }\n    }\n    {\n        for (ll i = 1; i <= n; i++) {\n            auto ite = std::upper_bound(ALL(xv), xv[i] - k) - 1;\n            ll idx = std::distance(xv.begin(), ite);\n            bdp[0][i] = idx;\n            bsum[0][i] = i + 1;\n        }\n        for (ll k = 0; k + 1 < 20; k++) for (ll i = 0; i < n + 2; i++) {\n            ll nxt = bdp[k][i];\n            if (nxt == i) continue;\n            bdp[k + 1][i] = bdp[k][nxt];\n            bsum[k + 1][i] = bsum[k][i] + bsum[k][nxt];\n        }\n    }\n\n    ll q;\n    std::cin >> q;\n    vec<pll> qv(q);\n    for (auto &[ l, r ] : qv) std::cin >> l >> r;\n    xv.front() = 0;\n    xv.back() = 0;\n\n    // [l, r]\n    auto go = [&](ll cur, ll l, ll r, const vvec<ll> &dp, const vvec<ll> &sum) {\n        ll ret = 0;\n        for (ll k = 20 - 1; 0 <= k; k--) {\n            ll nxt = dp[k][cur];\n            if (!(l <= nxt && nxt <= r)) continue;\n            ret += sum[k][cur];\n            cur = dp[k][cur];\n        }\n        return pll(ret, cur);\n    };\n\n    for (auto [ l, r ] : qv) {\n        auto [ sum1, n1 ] = go(l, l, r, fdp, fsum);\n        auto [ sum2, n2 ] = go(r, l, r, bdp, bsum);\n        if (1 <= n1 && n1 <= n) sum1 += n1;\n        if (1 <= n2 && n2 <= n) sum2 += n2 + 1;\n        std::cout << sum2 - sum1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\n\nsigned main(){\n    LL(n,k);\n    VEC(ll,x,n);\n    vv(ll,next1,20,n+1,n);\n    vv(ll,s1,20,n+1,0);\n    vv(ll,next2,20,n+1);\n    vv(ll,s2,20,n+1,0);\n    auto p=x.begin();\n    rep(n){\n        const ll a=x[i];\n        while(p!=x.end()&&*p-a<k)p++;\n        next1[0][i]=p-x.begin();\n        s1[0][i]=i;\n    }\n    p=x.end();\n    rrep(n){\n        const ll a=x[i];\n        while(p!=x.begin()&&a-*prev(p)<k)p--;\n        next2[0][i+1]=p-x.begin();\n        s2[0][i+1]=i+1;\n    }\n    rep(19){\n        rep(j,n+1){\n            next1[i+1][j]=next1[i][next1[i][j]];\n            s1[i+1][j]=s1[i][j]+s1[i][next1[i][j]];\n            next2[i+1][j]=next2[i][next2[i][j]];\n            s2[i+1][j]=s2[i][j]+s2[i][next2[i][j]];\n        }\n    }\n    LL(q);\n    rep(q){\n        LL(l,r);\n        l--;\n        ll cnt=0,at=l;\n        rrep(20)if(next1[i][at]<r){\n            at=next1[i][at];\n            cnt|=1<<i;\n        }\n        cnt++;\n        ll ans=0;\n        rep(20)if(cnt>>i&1){\n            ans-=s1[i][l];\n            l=next1[i][l];\n        }\n        rep(20)if(cnt>>i&1){\n            ans+=s2[i][r];\n            r=next2[i][r];\n        }\n        out(ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate <typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate <typename V, typename T> void ndfill(V &x, const T &val) { x = val; }\ntemplate <typename V, typename T> void ndfill(vector<V> &vec, const T &val) { for (auto &v : vec) ndfill(v, val); }\ntemplate <typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate <typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate <typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate <typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate <typename T> vector<T> srtunq(vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }\n#if __cplusplus >= 201703L\ntemplate <typename... T> istream &operator>>(istream &is, tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <typename... T> ostream &operator<<(ostream &os, const tuple<T...> &tpl) { std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os; }\n#endif\ntemplate <typename T> ostream &operator<<(ostream &os, const deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << '(' << pa.first << ',' << pa.second << ')'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\n#ifdef HITONANODE_LOCAL\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl\n#else\n#define dbg(x)\n#endif\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    vector<int> X(N);\n    cin >> X;\n    vector<int> prv(N), nxt(N);\n    REP(i, N) nxt[i] = lower_bound(ALL(X), X[i] + K) - X.begin();\n    REP(i, N) prv[i] = upper_bound(ALL(X), X[i] - K) - X.begin() - 1;\n\n    REP(i, N) if (prv[i] < 0) prv[i] = N;\n\n    constexpr int D = 20;\n    vector<vector<int>> dnxt(D, vector<int>(N + 1, N));\n    vector<vector<lint>> sumnxt(D, vector<lint>(N + 1));\n    vector<vector<int>> dprv(D, vector<int>(N + 1, N));\n    vector<vector<lint>> sumprv(D, vector<lint>(N + 1));\n    dnxt[0] = nxt;\n    dprv[0] = prv;\n    REP(i, N + 1)\n    {\n        sumnxt[0][i] = N - i; // dnxt[0][i];\n        sumprv[0][i] = N - i; // dprv[0][i];\n    }\n    REP(d, D - 1)\n    {\n        REP(i, N)\n        {\n            dnxt[d + 1][i] = dnxt[d][dnxt[d][i]], sumnxt[d + 1][i] = sumnxt[d][i] + sumnxt[d][dnxt[d][i]];\n            dprv[d + 1][i] = dprv[d][dprv[d][i]], sumprv[d + 1][i] = sumprv[d][i] + sumprv[d][dprv[d][i]];\n        }\n    }\n\n    dbg(dnxt[0]);\n    dbg(dnxt[1]);\n    dbg(dnxt[2]);\n    dbg(sumnxt[0]);\n    dbg(sumnxt[1]);\n    dbg(sumnxt[2]);\n    dbg(sumprv[0]);\n    dbg(sumprv[1]);\n    dbg(sumprv[2]);\n    int Q;\n    cin >> Q;\n    while (Q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        int now = l, nowinv = r;\n        int step = 0;\n\n        IREP(d, D)\n        {\n            if (dnxt[d][now] <= r)\n            {\n                step += 1 << d;\n                now = dnxt[d][now];\n            }\n        }\n        step++;\n\n        now = l, nowinv = r;\n        lint ret1 = 0, ret2 = 0;\n        IREP(d, D) if ((step >> d) & 1)\n        {\n                ret1 += sumnxt[d][now];\n                ret2 += sumprv[d][nowinv];\n                now = dnxt[d][now];\n                nowinv = dprv[d][nowinv];\n        }\n        cout << ret1 - ret2 + step << '\\n';\n        dbg(step);\n        dbg(ret1);\n        dbg(ret2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem : D - Keep Distances\n// Contest : AtCoder - ACL Contest 1\n// URL : https://atcoder.jp/contests/acl1/tasks/acl1_d\n// Memory Limit : 1024 MB\n// Time Limit : 3000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#pragma GCC optimize(\"Ofast,-funroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int Maxn = 2e5 + 5;\nconstexpr int LOG = 20;\n\nint n, K, q;\nint a[Maxn];\nint pre[Maxn][LOG];\nint suf[Maxn][LOG];\nint64_t pre_sum[Maxn][LOG];\nint64_t suf_sum[Maxn][LOG];\n\nint main() {\n\n  scanf(\"%d %d\", &n, &K);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    pre[i][0] = upper_bound(a + 1, a + n + 1, a[i] - K) - a - 1;\n    suf[i][0] = lower_bound(a + 1, a + n + 1, a[i] + K) - a;\n    pre_sum[i][0] = (pre[i][0] >= 1 ? pre[i][0] : 0);\n    suf_sum[i][0] = (suf[i][0] <= n ? suf[i][0] : 0);\n  }\n  for (int j = 1; j < LOG; ++j) {\n    for (int i = 1; i <= n; ++i) {\n      pre_sum[i][j] = pre_sum[i][j - 1];\n      suf_sum[i][j] = suf_sum[i][j - 1];\n      if (pre[i][j - 1] >= 1) {\n        pre[i][j] = pre[pre[i][j - 1]][j - 1];\n        pre_sum[i][j] += pre_sum[pre[i][j - 1]][j - 1];\n      }\n      else {\n        pre[i][j] = 0;\n      }\n      if (suf[i][j - 1] <= n) {\n        suf[i][j] = suf[suf[i][j - 1]][j - 1];\n        suf_sum[i][j] += suf_sum[suf[i][j - 1]][j - 1];\n      }\n      else {\n        suf[i][j] = n + 1;\n      }\n    }\n  }\n  \n  scanf(\"%d\", &q);\n  while (q--) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    int64_t left_sum = 0;\n    int64_t right_sum = 0;\n    int len = 1;\n    {\n      int lg = LOG - 1, pos = r;\n      while (lg >= 0) {\n        if (pre[pos][lg] >= l) {\n          left_sum += pre_sum[pos][lg];\n          pos = pre[pos][lg];\n          len += (1 << lg);\n        }\n        --lg;\n      }\n    }\n    {\n      int lg = LOG - 1, pos = l;\n      while (lg >= 0) {\n        if (suf[pos][lg] <= r) {\n          right_sum += suf_sum[pos][lg];\n          pos = suf[pos][lg];\n        }\n        --lg;\n      }\n    }\n    printf(\"%lld\\n\", left_sum - right_sum + len + r - l);\n  }\n  \n  return 0;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct Segtree {\n\t\tll dt[1 << 20];\n\t\tvoid inline change(int to, int x, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl == nr) return void(dt[now] = x);\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\tif(m >= to) change(to, x, now << 1, nl, m);\n\t\t\telse change(to, x, now << 1 | 1, m + 1, nr);\n\t\t\tdt[now] = dt[now << 1] + dt[now << 1 | 1];\n\t\t}\n\t\tll inline sum(int l, int r, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl >= l && nr <= r) return dt[now];\n\t\t\tif(nl > r || nr < l) return 0;\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\treturn sum(l, r, now << 1, nl, m) + sum(l, r, now << 1 | 1, m + 1, nr);\n\t\t}\n\t} seg;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18];\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) seg.change(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (a > b ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tll inline sum(int a, int b) {\n\t\tll res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += seg.sum(dfn[rt], dfn[a]);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0);\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%lld\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <utility>\n#include <fstream>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { a = abs(a), b = abs(b); while (b > 0) { tie(a, b) = make_pair(b, a % b); } return a; }\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353;\nconstexpr int MAX = 5000000;\n\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tll n, X; cin >> n >> X;\n\tconst int N = 32;\n\tvector<ll> x(n); for (int i = 0; i < n; i++) cin >> x[i];\n\tvector<vector<int>> lfto(N, vector<int>(n + 1, n)), rgto(N, vector<int>(n + 1, -1));\n\tvector<vector<ll>> lfsm(N, vector<ll>(n + 1)), rgsm(N, vector<ll>(n + 1));\n\tvector<vector<ll>> lfcn(N, vector<ll>(n + 1)), rgcn(N, vector<ll>(n + 1));\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (cur < n and x[cur] - x[i] < X) cur++;\n\t\t\tlfto[0][i] = cur, lfsm[0][i] = cur, lfcn[0][i] = 1;\n\t\t}\n\t}\n\t{\n\t\tint cur = n - 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\twhile (cur >= 0 and x[i] - x[cur] < X) cur--;\n\t\t\trgto[0][i] = cur, rgsm[0][i] = cur;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tlfto[i][j] = lfto[i - 1][lfto[i - 1][j]];\n\t\t\tif (rgto[i - 1][j] >= 0) rgto[i][j] = rgto[i - 1][rgto[i - 1][j]];\n\t\t\telse rgto[i][j] = -1;\n\t\t\tlfsm[i][j] = lfsm[i - 1][j] + lfsm[i - 1][lfto[i - 1][j]];\n\t\t\tif (rgto[i - 1][j] >= 0) rgsm[i][j] = rgsm[i - 1][j] + rgsm[i - 1][rgto[i - 1][j]];\n\t\t\tlfcn[i][j] = lfcn[i - 1][j] + lfcn[i - 1][lfto[i - 1][j]];\n\t\t}\n\t}\n\tint kkt; cin >> kkt;\n\twhile (kkt--) {\n\t\tint l, r; cin >> l >> r;\n\t\tl--; r--;\n\t\tll lf = 0;\n\t\tll rg = 0;\n\t\tll cnt = 1;\n\t\t{\n\t\t\tint cur = l;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tif (lfto[i][cur] <= r) {\n\t\t\t\t\tlf += lfsm[i][cur];\n\t\t\t\t\tcnt += lfcn[i][cur];\n\t\t\t\t\tcur = lfto[i][cur];\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t{\n\t\t\tint cur = r;\n\t\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\t\tif (rgto[i][cur] >= l) {\n\t\t\t\t\trg += rgsm[i][cur];\n\t\t\t\t\tcur = rgto[i][cur];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlf += l;\n\t\trg += r;\n\t\t//cout << lf << \" \" << rg << \" \"<< cnt<<endl;\n\t\tcout << rg - lf + cnt << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incII(i, l, r) for(LL i = (l)    ; i <= (r); i++)\n#define incIX(i, l, r) for(LL i = (l)    ; i <  (r); i++)\n#define incXI(i, l, r) for(LL i = (l) + 1; i <= (r); i++)\n#define incXX(i, l, r) for(LL i = (l) + 1; i <  (r); i++)\n#define decII(i, l, r) for(LL i = (r)    ; i >= (l); i--)\n#define decIX(i, l, r) for(LL i = (r) - 1; i >= (l); i--)\n#define decXI(i, l, r) for(LL i = (r)    ; i >  (l); i--)\n#define decXX(i, l, r) for(LL i = (r) - 1; i >  (l); i--)\n#define inc(i, n)  incIX(i, 0, n)\n#define dec(i, n)  decIX(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\nauto inII = [](auto x, auto l, auto r) { return (l <= x && x <= r); };\nauto inIX = [](auto x, auto l, auto r) { return (l <= x && x <  r); };\nauto inXI = [](auto x, auto l, auto r) { return (l <  x && x <= r); };\nauto inXX = [](auto x, auto l, auto r) { return (l <  x && x <  r); };\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define RV(c) reverse(ALL(c))\n#define SC static_cast\n#define SI(c) SC<int>(c.size())\n#define SL(c) SC<LL >(c.size())\n#define RF(e, c) for(auto & e: c)\n#define SF(c, ...) for(auto & [__VA_ARGS__]: c)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\nauto * IS = & cin;\nauto * OS = & cout;\narray<string, 3> SEQ = { \"\", \" \", \"\" };\n// input\ntemplate<typename T> T in() { T a; (* IS) >> a; return a; }\n// input: tuple\ntemplate<typename U, int I> void tin_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void tin_(U & t) { (* IS) >> get<I>(t); tin_<U, I + 1, B ...>(t); }\ntemplate<typename ... T> auto tin() { tuple<T ...> t; tin_<tuple<T ...>, 0, T ...>(t); return t; }\n// input: array\ntemplate<typename T, int N> auto ain() { array<T, N> a; inc(i, N) { (* IS) >> a[i]; } return a; }\n// input: multi-dimensional vector\ntemplate<typename T> T vin() { T v; (* IS) >> v; return v; }\ntemplate<typename T, typename N, typename ... M> auto vin(N n, M ... m) {\n\tvector<decltype(vin<T, M ...>(m ...))> v(n); inc(i, n) { v[i] = vin<T, M ...>(m ...); } return v;\n}\n// input: multi-column (tuple<vector>)\ntemplate<typename U, int I> void colin_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void colin_(U & t) {\n\tget<I>(t).PB(in<A>()); colin_<U, I + 1, B ...>(t);\n}\ntemplate<typename ... T> auto colin(int n) {\n\ttuple<vector<T> ...> t; inc(i, n) { colin_<tuple<vector<T> ...>, 0, T ...>(t); } return t;\n}\n// output\nvoid out_([[maybe_unused]] string s) { }\ntemplate<typename A> void out_([[maybe_unused]] string s, A && a) { (* OS) << a; }\ntemplate<typename A, typename ... B> void out_(string s, A && a, B && ... b) { (* OS) << a << s; out_(s, b ...); }\nauto outF = [](auto x, auto y, auto z, auto ... a) { (* OS) << x; out_(y, a ...); (* OS) << z << flush; };\nauto out  = [](auto ... a) { outF(\"\", \" \" , \"\\n\", a ...); };\nauto outS = [](auto ... a) { outF(\"\", \" \" , \" \" , a ...); };\nauto outL = [](auto ... a) { outF(\"\", \"\\n\", \"\\n\", a ...); };\nauto outN = [](auto ... a) { outF(\"\", \"\"  , \"\"  , a ...); };\n// output: multi-dimensional vector\ntemplate<typename T> ostream & operator<<(ostream & os, vector<T> const & v) {\n\tos << SEQ[0]; inc(i, SI(v)) { os << (i == 0 ? \"\" : SEQ[1]) << v[i]; } return (os << SEQ[2]);\n}\ntemplate<typename T> void vout_(T && v) { (* OS) << v; }\ntemplate<typename T, typename A, typename ... B> void vout_(T && v, A a, B ... b) {\n\tinc(i, SI(v)) { (* OS) << (i == 0 ? \"\" : a); vout_(v[i], b ...); }\n}\ntemplate<typename T, typename A, typename ... B> void vout (T && v, A a, B ... b) { vout_(v, a, b ...); (* OS) << a << flush; }\ntemplate<typename T, typename A, typename ... B> void voutN(T && v, A a, B ... b) { vout_(v, a, b ...); (* OS)      << flush; }\n\n// ---- ----\n\n// make vector\ntemplate<typename T> T MV(T v) { return v; }\ntemplate<typename T, typename ... U> auto MV(T v, int a, U ... b) { return vector<decltype(MV(v, b ...))>(a, MV(v, b ...)); }\n\n#define LB(v, x) (lower_bound(ALL(v), x) - v.begin())\n#define UB(v, x) (upper_bound(ALL(v), x) - v.begin())\n\nint main() {\n\tauto [n, k] = tin<int, int>();\n\tvector<int> x(n + 2);\n\tinc1(i, n) { cin >> x[i]; }\n\tx.FR = x[1] - k;\n\tx.BA = x[n] + k;\n\tvector<array<LL, 3>> L(n + 2), R(n + 2);\n\tL[n + 1] = { -1, n + 1, 0 };\n\tdec1(i, n) {\n\t\tLL e = LB(x, x[i] + k);\n\t\tLL c = L[e][0] + 1;\n\t\tL[i] = { c, e, (e - i) * c };\n\t}\n\tR[0] = { -1, 0, 0 };\n\tinc1(i, n) {\n\t\tLL e = UB(x, x[i] - k) - 1;\n\t\tLL c = R[e][0] + 1;\n\t\tR[i] = { c, e, (i - e) * c };\n\t}\n\t\n\tconst int B = 18;\n\tauto pl = MV<pair<int, LL>>({ 0, 0 }, n + 2, B);\n\tauto pr = MV<pair<int, LL>>({ 0, 0 }, n + 2, B);\n\tinc(k, B) {\n\tinc1(i, n + 1) {\n\t\tif(k == 0) { pl[i][k] = { L[i][1], L[i][2] }; }\n\t\telse {\n\t\t\tpl[i][k].FI = pl[pl[i][k - 1].FI][k - 1].FI;\n\t\t\tpl[i][k].SE = pl[pl[i][k - 1].FI][k - 1].SE + pl[i][k - 1].SE;\n\t\t}\n\t}\n\t}\n\tinc(k, B) {\n\tinc(i, n + 1) {\n\t\tif(k == 0) { pr[i][k] = { R[i][1], R[i][2] }; }\n\t\telse {\n\t\t\tpr[i][k].FI = pr[pr[i][k - 1].FI][k - 1].FI;\n\t\t\tpr[i][k].SE = pr[pr[i][k - 1].FI][k - 1].SE + pr[i][k - 1].SE;\n\t\t}\n\t}\n\t}\n\t\n\tauto sl = [&](int l, int r) {\n\t\tint v = l;\n\t\tLL s = 0;\n\t\tdec(k, B) {\n\t\t\tif(pl[v][k].FI <= r) {\n\t\t\t\ts += pl[v][k].SE;\n\t\t\t\tv  = pl[v][k].FI;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\ts += (r - v + 1) * L[v][0];\n\t\treturn s;\n\t};\n\tauto sr = [&](int l, int r) {\n\t\tint v = r;\n\t\tLL s = 0;\n\t\tdec(k, B) {\n\t\t\tif(pr[v][k].FI >= l) {\n\t\t\t\ts += pr[v][k].SE;\n\t\t\t\tv  = pr[v][k].FI;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\ts += (v - l + 1) * R[v][0];\n\t\treturn s;\n\t};\n\t\n\tauto Q = in<int>();\n\tinc(q, Q) {\n\t\tauto [l, r] = tin<LL, LL>();\n\t\tout((r - l + 1) * (L[l][0] + R[l][0] + 1) - (sl(l, r) + sr(l, r)));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL K;\nLL X[200011];\n\nconst int LOG = 18;\nint Right[LOG][200011];\nint RightCnt[LOG][200011];\nLL RightSum[LOG][200011];\n\nint Left[LOG][200011];\nint LeftCnt[LOG][200011];\nLL LeftSum[LOG][200011];\n\nvoid MAIN() {\n    scanf(\"%d%lld\", &N, &K);\n    REP (i, N) scanf(\"%lld\", X+i);\n\n    for (int i=0, j=0; i<N; i++) {\n\twhile (j < N && X[j] - X[i] < K) j++;\n\tRight[0][i] = j;\n\tRightCnt[0][i] = j - i;\n\tRightSum[0][i] = j - i;\n    }\n\n    Right[0][N] = N;\n    REP (t, LOG-1) {\n\tREP (i, N+1) {\n\t    int s = Right[t][i];\n\t    Right[t+1][i] = Right[t][s];\n\t    RightCnt[t+1][i] = RightCnt[t][i] + RightCnt[t][s];\n\t    RightSum[t+1][i] = RightSum[t][i] + RightSum[t][s] + (RightCnt[t][s] << t);\n\t}\n    }\n\n    for (int i=N-1, j=N-1; i>=0; i--) {\n\twhile (j >= 0 && X[i] - X[j] < K) j--;\n\tLeft[0][i] = j;\n\tLeftCnt[0][i] = i - j;\n\tLeftSum[0][i] = i - j;\n    }\n    REP (t, LOG-1) {\n\tREP (i, N) {\n\t    int s = Left[t][i];\n\t    if (s == -1) {\n\t\tLeft[t+1][i] = -1;\n\t\tLeftCnt[t+1][i] = LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][i];\n\t    } else {\n\t\tLeft[t+1][i] = Left[t][s];\n\t\tLeftCnt[t+1][i] = LeftCnt[t][s] + LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][s] + LeftSum[t][i] + (LeftCnt[t][i] << t);\n\t    }\n\t}\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n    REP ($, Q) {\n\tint L, R;\n\tscanf(\"%d%d\", &L, &R);\n\tL--;\n\n\tLL ans = 0;\n\t{\n\t    int cur = L;\n\t    int mult = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Right[t][cur];\n\t\tif (s != N && s <= R) {\n\t\t    sum += RightSum[t][cur] + RightCnt[t][cur] * mult;\n\t\t    mult += 1<<t;\n\t\t    cur = s;\n\t\t}\n\t    }\n\t    sum += (R - cur) * (mult + 1);\n\n\t    ans += sum;\n\t}\n\n\t{\n\t    int cur = R-1;\n\t    LL cnt = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Left[t][cur];\n\t\tif (L <= s) {\n\t\t    sum += LeftSum[t][cur] + cnt * (1LL<<t);\n\t\t    cnt += LeftCnt[t][cur];\n\t\t    cur = s;\n\t\t}\n\t    }\n\n\t    ans -= sum;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Gene template< class\n#define Rics printer& operator,\nGene c> struct rge{c b, e;};\nGene c> rge<c> range(c i, c j){ return {i, j};}\nstruct printer{\n    ~printer(){cerr<<endl;}\n    Gene c >Rics(c x){ cerr<<boolalpha<<x; return *this;}\n    Rics(string x){cerr<<x;return *this;}\n    Gene c, class d >Rics(pair<c, d> x){ return *this,\"(\",x.first,\", \",x.second,\")\";}\n    Gene ... d, Gene ...> class c >Rics(c<d...> x){ return *this, range(begin(x), end(x));}\n    Gene c >Rics(rge<c> x){\n        *this,\"[\"; for(auto it = x.b; it != x.e; ++it)\n            *this,(it==x.b?\"\":\", \"),*it; return *this,\"]\";}\n};\n#define debug() cerr<<\"LINE \"<<__LINE__<<\" >> \", printer()\n#define dbg(x) \"[\",#x,\": \",(x),\"] \"\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint my_rand(int l, int r) {\n    return uniform_int_distribution<int>(l, r) (rng);\n}\n\nconst int N = 2e5+100;\nconst int LOG = 20;\n\nint a[N];\nint nxt[N][LOG], prv[N][LOG];\nlong long nxt_sum[N][LOG], prv_sum[N][LOG];\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, K;\n    cin >> n >> K;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n\n    for(int i = 1; i <= n; i++) {\n        if(a[n]-a[i] < K) nxt[i][0] = -1;\n        else {\n            int lo = i+1, hi = n;\n            while(hi > lo) {\n                int mid = lo+hi>>1;\n                if(a[mid]-a[i] >= K) hi = mid;\n                else lo = mid+1;\n            }\n            nxt[i][0] = lo;\n        }\n        nxt_sum[i][0] = i;\n    }\n    for(int i = 1; i <= n; i++) {\n        if(a[i]-a[1] < K) prv[i][0] = -1;\n        else {\n            int lo = 1, hi = i-1;\n            while(hi > lo) {\n                int mid = (lo+hi+1)>>1;\n                if(a[i]-a[mid] >= K) lo = mid;\n                else hi = mid-1;\n            }\n            prv[i][0] = lo;\n        }\n        prv_sum[i][0] = i;\n    }\n\n    for(int k = 1; k < LOG; k++) {\n        for(int i = 1; i <= n; i++) {\n            if(nxt[i][k-1] == -1) nxt[i][k] = -1;\n            else {\n                nxt[i][k] = nxt[nxt[i][k-1]][k-1];\n                nxt_sum[i][k] = nxt_sum[i][k-1] + nxt_sum[nxt[i][k-1]][k-1];\n            }\n\n            if(prv[i][k-1] == -1) prv[i][k] = -1;\n            else {\n                prv[i][k] = prv[prv[i][k-1]][k-1];\n                prv_sum[i][k] = prv_sum[i][k-1] + prv_sum[prv[i][k-1]][k-1];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    while(q--) {\n        int l, r;\n        cin >> l >> r;\n        int m = 1;\n        int cur = l;\n        for(int k = LOG-1; k >= 0; k--) {\n            if(nxt[cur][k] != -1 && nxt[cur][k] <= r) {\n                cur = nxt[cur][k];\n                m += (1<<k);\n            }\n        }\n        int curl = l, curr = r;\n        long long lsum = 0, rsum = 0;\n        for(int k = LOG-1; k >= 0; k--) {\n            if((m >> k) & 1) {\n                lsum += nxt_sum[curl][k];\n                rsum += prv_sum[curr][k];\n                curl = nxt[curl][k];\n                curr = prv[curr][k];\n            }\n        }\n        long long ans = rsum - lsum + m;\n        cout << ans << \"\\n\";\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n\n#ifdef _MSC_VER\n#include <intrin.h>\n\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include<atcoder/all>\n\n\nusing namespace std;\nusing namespace atcoder;\n\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\nusing ll = long long;\n#define print(x) cout << (x) << endl\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n//using ll = __int128_t;\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << \" \\n\"[i==(int)v.size()-1]\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 300010;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\n\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\nvoid Yes(bool cond) { cout << (cond ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool cond) { cout << (cond ? \"YES\" : \"NO\") << '\\n'; }\n\nint tol[30][100010], tor[30][100010];\nint suml[30][100010], sumr[30][100010];\nvoid solve() {\n\tint N, K; cin >> N >> K;\n\tvector<int>X(N);\n\tREP(i, N)cin >> X[i];\n\ttor[0][N - 1] = N;\n\ttol[0][0] = -1;\n\n\tREP(i, N) {\n\t\tint x = X[i];\n\t\t{\n\t\t\tauto itr = lb(X, x + K);\n\t\t\tif (itr == X.end()) {\n\t\t\t\ttor[0][i] = N;\n\t\t\t}\n\t\t\telse tor[0][i] = itr - X.begin();\n\t\t}\n\t\t{\n\t\t\tauto itr = ub(X, x - K);\n\t\t\tif (itr == X.begin())tol[0][i] = -1;\n\t\t\telse tol[0][i] = itr - X.begin() - 1;\n\t\t}\n\t}\n\tREP(k, 25) {\n\t\tREP(i, N) {\n\t\t\t{\n\t\t\t\tint nxt = tor[k][i];\n\t\t\t\tif (nxt == N)tor[k + 1][i] = N;\n\t\t\t\telse tor[k + 1][i] = tor[k][nxt];\n\t\t\t}\n\t\t\t{\n\t\t\t\tint nxt = tol[k][i];\n\t\t\t\tif (nxt == -1)tol[k + 1][i] = -1;\n\t\t\t\telse tol[k + 1][i] = tol[k][nxt];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct BIT {\n\t\tint dt[1 << 18];\n\t\tvoid inline add(int a, int x) {\n\t\t\twhile(a < (1 << 18)) {\n\t\t\t\tdt[a] += x;\n\t\t\t\ta += a & -a;\n\t\t\t}\n\t\t}\n\t\tint inline sum(int a) {\n\t\t\tint res = 0;\n\t\t\twhile(a) {\n\t\t\t\tres += dt[a];\n\t\t\t\ta -= a & -a;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} bit;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(!son[now] || sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18], tag;\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) bit.add(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (tag ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tint inline sum(int a, int b) {\n\t\tint res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += bit.sum(dfn[a]) - bit.sum(dfn[rt] - 1);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0); tl.tag = 1;\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%d\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2020/09/20.\n//\n\n#include <bits/stdc++.h>\n//#include <atcoder/all>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing mti = vector<vector<int>>;\nusing vl = vector<ll>;\nusing mtl = vector<vector<ll>>;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\ntemplate<typename T>\nusing heap = priority_queue<T, vector<T>, function<bool(const T, const T)>>;\n\nint main() {\n    //CFS;\n    int n, k;\n    cin >> n >> k;\n    vl a(n + 2);\n    a[0] = -LINF, a[n + 1] = LINF;\n    repl(i, 1, n + 1) cin >> a[i];\n    int lg = 0;\n    int tmp = 1;\n    while (tmp < n + 2) tmp *= 2, lg++;\n    mti fl(lg, vi(n + 2)), fr(lg, vi(n + 2));\n    mtl sl(lg, vl(n + 2)), sr(lg, vl(n + 2));\n    fl[0][0] = fr[0][0] = 0;\n    fl[0][n + 1] = fr[0][n + 1] = n + 1;\n    sl[0][0] = sr[0][0] = 0;\n    sl[0][n + 1] = sr[0][n + 1] = 0;\n    repl(i, 1, n + 1) {\n        fl[0][i] = lower_bound(all(a), a[i] + k) - a.begin();\n        fr[0][i] = upper_bound(all(a), a[i] - k) - a.begin() - 1;\n        sl[0][i] = i;\n        sr[0][i] = i + 1;\n    }\n    repl(t, 1, lg) {\n        fl[t][0] = fr[t][0] = 0;\n        fl[t][n + 1] = fr[t][n + 1] = n + 1;\n        sl[t][0] = sr[t][0] = 0;\n        sl[t][n + 1] = sr[t][n + 1] = 0;\n        repl(i, 1, n + 1) {\n            fl[t][i] = fl[t - 1][fl[t - 1][i]];\n            fr[t][i] = fr[t - 1][fr[t - 1][i]];\n            sl[t][i] = sl[t - 1][i] + sl[t - 1][fl[t - 1][i]];\n            sr[t][i] = sr[t - 1][i] + sr[t - 1][fr[t - 1][i]];\n        }\n    }\n    int q;\n    cin >> q;\n    rep(t, q) {\n        int l, r;\n        cin >> l >> r;\n        int tl = l, tr = r;\n        ll sum = 0;\n        per(i, lg) {\n            if (fl[i][tl] <= r) {\n                sum -= sl[i][tl];\n                tl = fl[i][tl];\n            }\n            if (fr[i][tr] >= l) {\n                sum += sr[i][tr];\n                tr = fr[i][tr];\n            }\n        }\n        sum -= tl;\n        sum += tr+1;\n        cout << sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct BIT {\n\t\tint dt[1 << 18];\n\t\tvoid inline add(int a, int x) {\n\t\t\twhile(a < (1 << 18)) {\n\t\t\t\tdt[a] += x;\n\t\t\t\ta += a & -a;\n\t\t\t}\n\t\t}\n\t\tint inline sum(int a) {\n\t\t\tint res = 0;\n\t\t\twhile(a) {\n\t\t\t\tres += dt[a];\n\t\t\t\ta -= a & -a;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t} bit;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(!son[now] || sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18], tag;\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) bit.add(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (tag ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tint inline sum(int a, int b) {\n\t\tint res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += bit.sum(dfn[a]) - bit.sum(dfn[rt] - 1);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0); tl.tag = 1;\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%d\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n// const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  vector< int > X(N);\n  cin >> X;\n\n  vector< int > nxt(N);\n  {\n    int ptr = 0;\n    for(int i = 0; i < N; i++) {\n      while(ptr < N && X[ptr] - X[i] < K) ++ptr;\n      nxt[i] = ptr;\n    }\n  }\n  vector< int > pre(N);\n  {\n    int ptr = N - 1;\n    for(int i = N - 1; i >= 0; i--) {\n      while(ptr >= 0 && X[i] - X[ptr] < K) --ptr;\n      pre[i] = ptr;\n    }\n  }\n\n  auto latte = make_v< int >(20, N);\n  auto latteS = make_v< int64 >(20, N);\n  for(int i = 0; i < N; i++) {\n    latte[0][i] = nxt[i];\n    latteS[0][i] = nxt[i];\n  }\n  for(int i = 0; i + 1 < 20; i++) {\n    for(int j = 0; j < N; j++) {\n      if(latte[i][j] == N) {\n        latte[i + 1][j] = N;\n        latteS[i + 1][j] = latteS[i][j];\n      } else {\n        latte[i + 1][j] = latte[i][latte[i][j]];\n        latteS[i + 1][j] = latteS[i][j] + latteS[i][latte[i][j]];\n      }\n    }\n  }\n\n  auto malta = make_v< int >(20, N);\n  auto maltaS = make_v< int64 >(20, N);\n  for(int i = 0; i < N; i++) {\n    malta[0][i] = pre[i];\n    maltaS[0][i] = pre[i] + 1;\n  }\n  for(int i = 0; i + 1 < 20; i++) {\n    for(int j = 0; j < N; j++) {\n      if(malta[i][j] == -1) {\n        malta[i + 1][j] = -1;\n        maltaS[i + 1][j] = latteS[i][j];\n      } else {\n        malta[i + 1][j] = malta[i][malta[i][j]];\n        maltaS[i + 1][j] = maltaS[i][j] + maltaS[i][malta[i][j]];\n      }\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  while(Q--) {\n    int l, r;\n    cin >> l >> r;\n    --l, --r;\n    int64 sum = 0;\n    {\n      int k = l;\n      sum -= l;\n      for(int i = 19; i >= 0; i--) {\n        if(latte[i][k] <= r) {\n          sum -= latteS[i][k];\n          k = latte[i][k];\n        }\n      }\n    }\n\n    {\n      int k = r;\n      sum += r + 1;\n      for(int i = 19; i >= 0; i--) {\n        if(malta[i][k] >= l) {\n          sum += maltaS[i][k];\n          k = malta[i][k];\n        }\n      }\n    }\n\n    cout << sum << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 2020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    for(auto itr = a.begin(); itr != a.end(); itr++){\n\t\tcout << *itr << \" \";\n\t}\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){\n\tcout << \"debug: \" << a << \" \" << b << \"\\n\";\n}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << \"debug: \" << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {cout << \"#\" << \"\\n\";}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nll Lpos[20][202020], Lsum[20][202020];\nll Rpos[20][202020], Rsum[20][202020];\n\nint main(){\n    ll n,k; cin >> n >> k;\n    vl x(n); rep(i,n) cin >> x[i];\n    rep(i,n){\n        Lpos[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n        Rpos[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\t\tLsum[0][i] = Rsum[0][i] = i;\n    }\n\tLpos[0][n] = n;\n\trep(i,19){\n\t\trep(j,n){\n\t\t\tLpos[i+1][j] = Lpos[i][Lpos[i][j]];\n\t\t\tLsum[i+1][j] = Lsum[i][j] + Lsum[i][Lpos[i][j]];\n\t\t\tif(Rpos[i][j] != -1) Rpos[i+1][j] = Rpos[i][Rpos[i][j]];\n\t\t\telse Rpos[i+1][j] = -1;\n\t\t\tRsum[i+1][j] = Rsum[i][j];\n\t\t\tif(Rpos[i][j] >= 0){\n\t\t\t\tRsum[i+1][j] += Rsum[i][Rpos[i][j]];\n\t\t\t}\n\t\t}\n\t\tLpos[i+1][n] = n;\n\t}\n\tint q; cin >> q;\n\twhile(q--){\n\t\tll l,r; cin >> l >> r; l--; r--;\n\t\tll pos = l;\n\t\tll ls = 0, rs = 0;\n\t\tfor(int i=19; i>=0; i--){\n\t\t\tif(Lpos[i][pos] <= r){\n\t\t\t\tls += Lsum[i][pos];\n\t\t\t\tpos = Lpos[i][pos];\n\t\t\t}\n\t\t}\n\t\tls += pos;\n\t\tpos = r;\n\t\tfor(int i=19; i>=0; i--){\n\t\t\tif(Rpos[i][pos] >= l){\n\t\t\t\trs += Rsum[i][pos] + (1<<i);\n\t\t\t\tpos = Rpos[i][pos];\n\t\t\t}\n\t\t}\n\t\trs += pos + 1;\n\t\tcout << rs - ls << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[19][201010], toL[19][201010];\nint totR[19][201010], totL[19][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 18, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 19) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 19) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toR[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 19) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int N = 200005;\nint lgn;\nint n, k;\n\nstruct max_good_set {\n  int a[N], nxt[N][20];\n  ll sum[N][20];\n  void init() {\n    int p = 0;\n    for (int i = 0; i < n; ++i) {\n      while (abs(a[p] - a[i]) < k && p < n) ++p;\n      nxt[i][0] = p;\n      sum[i][0] = i;\n    }\n    for (int i = 0; i <= lgn; ++i)\n      nxt[n][i] = n, sum[n][i] = 0;\n    for (int j = 1; j <= lgn; ++j)\n      for (int i = 0; i < n; ++i) {\n        nxt[i][j] = nxt[nxt[i][j - 1]][j - 1];\n        sum[i][j] = sum[i][j - 1] + sum[nxt[i][j - 1]][j - 1];\n      }\n  }\n  pair<ll, int> query(int l, int r) {\n    int p = l, c = 1;\n    ll s = 0;\n    for (int i = lgn; i >= 0; --i)\n      if (nxt[p][i] <= r) {\n        s += sum[p][i];\n        c += 1 << i;\n        p = nxt[p][i];\n      }\n    assert(p <= r);\n    return {s + p, c};\n  }\n}a, b;\n\nint main() {\n  read(n, k);\n  lgn = log2(n);\n  for (int i = 0; i < n; ++i)\n    read(a.a[i]);\n  reverse_copy(a.a, a.a + n, b.a);\n  a.init(); b.init();\n  int q;\n  read(q);\n  while (q--) {\n    int l, r;\n    read(l, r);\n    --l; --r;\n    auto A = a.query(l, r), B = b.query(n - 1 - r, n - 1 - l);\n    B.first = 1LL * (n - 1) * B.second - B.first;\n    write(B.first - A.first + A.second), endl();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nconst int N = 200000;\n\nint canL[N], canR[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll n, k;\n    cin >> n >> k;\n    vector<int> x(n + 1);\n    forn(i, n) cin >> x[i + 1];\n    vector<vector<ll> > goR(20, vector<ll>(n + 2));\n    vector<vector<ll> > goL(20, vector<ll>(n + 2));\n    vector<vector<ll> > summR(20, vector<ll>(n + 2));\n    vector<vector<ll> > summL(20, vector<ll>(n + 2));\n    for (int i = 1, j = 1; i <= n; i++)\n    {\n        while (j <= n && x[j] - x[i] < k)\n        {\n            j++;\n        }\n        goR[0][i] = j;\n    }\n    goR[0][0] = 1;\n    goR[0][n + 1] = n + 1;\n    summR[0] = goR[0];\n    for (int i = n, j = n; i >= 1; i--)\n    {\n        while (j >= 1 && x[i] - x[j] < k)\n        {\n            j--;\n        }\n        goL[0][i] = j;\n    }\n    goL[0][0] = 0;\n    goL[0][n + 1] = n;\n    summL[0] = goL[0];\n    for (int j = 1; j < 20; j++)\n    {\n        for (int i = 0; i <= n + 1; i++)\n        {\n            goR[j][i] = goR[j - 1][goR[j - 1][i]];\n            goL[j][i] = goL[j - 1][goL[j - 1][i]];\n            summR[j][i] = summR[j - 1][i] + summR[j - 1][goR[j - 1][i]];\n            summL[j][i] = summL[j - 1][i] + summL[j - 1][goL[j - 1][i]];\n        }\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        int sz = 1;\n        int w = l;\n        for (int j = 19; j >= 0; j--)\n        {\n            int nxt = goR[j][w];\n            if (nxt <= r)\n            {\n                w = nxt;\n                sz += (1 << j);\n            }\n        }\n        ll ans = 0;\n        {\n            ll w = r;\n            ll si = r;\n            for (int j = 19; j >= 0; j--)\n            {\n                ll go = goL[j][w];\n                if (l <= go)\n                {\n                    si += summL[j][w];\n                    w = go;\n                }\n            }\n            ans += si;\n        }\n        {\n            ll w = l;\n            ll si = l;\n            for (int j = 19; j >= 0; j--)\n            {\n                ll go = goR[j][w];\n                if (go <= r)\n                {\n                    si += summR[j][w];\n                    w = go;\n                }\n            }\n            ans -= si;\n        }\n        cout << sz + ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n#include <atcoder/mincostflow>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\ntypedef pair<ll, bool> Pb;\ntypedef pair<ll, vector<ll>> Pd;\n\nconst ll INF = 3e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll, vector<ll>, greater<ll> > pqls;\npriority_queue <P, vector<P>, greater<P> > pqps;\n//small priority queue\n//top pop\n\nll dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nll dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};\n//↓,→,↑,←\n\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n#undef endl\n#endif\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)();\n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> mat;\n\nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll m = mod) {ll x = 1; while (b) {while (!(b & 1)) {(a *= a) %= m; b >>= 1;}(x *= a) %= m; b--;} return x;}\nvec readvec(ll read) { vec res(read); for (int i = 0; i < read; i++) { cin >> res[i]; } return res;}\nvoid YES(bool cond) { if (cond) { p(\"YES\");} else { p(\"NO\");} return;}\nvoid Yes(bool cond) { if (cond) { p(\"Yes\");} else { p(\"No\");} return;}\nvoid line() { p(\"--------------------\"); return;}\n\n/*\nll fact[fact_table + 5], rfact[fact_table + 5];\n\nvoid c3_init() {\n    fact[0] = rfact[0] = 1;\n    for (ll i = 1; i <= fact_table; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table], mod - 2, mod);\n    for (ll i = fact_table; i >= 1; i--) {\n        rfact[i - 1] = rfact[i] * i;\n        rfact[i - 1] %= mod;\n    }\n    return;\n}\nll c3(ll n, ll r) {\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n - r]) % mod;\n}\n*/\n\nstruct Timer {\n    int64_t start; const int64_t CYCLES_PER_SEC = 2800000000;\n    Timer() { reset(); }\n    void reset() { start = getCycle(); }\n    inline double get() { return (double)(getCycle() - start) / CYCLES_PER_SEC; }\n    inline int64_t getCycle() {\n        uint32_t low, high; __asm__ volatile (\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n        return ((int64_t)low) | ((int64_t)high << 32);\n    }\n};\n\nbool multicase = false;\n\nll n, k;\nll x[200005], toright[200005][65], toleft[200005][65];\nll torightvalue[200005][65], toleftvalue[200005][65];\n\nvoid precalc() {\n    set<P> st;\n    for (int i = 1; i <= n; i++) {\n        st.insert(P(x[i], i));\n    }\n\n    // 番兵\n    st.insert(P(INF, INF));\n    st.insert(P(-INF, -INF));\n\n    for (int i = 1; i <= n; i++) {\n        ll right = (*st.lower_bound(P(x[i] + k, -INF))).second;\n        toright[i][0] = right;\n        torightvalue[i][0] = (right != INF) ? i : i;\n\n        auto ite = st.lower_bound(P(x[i] - k + 1, -INF));\n        ite --;\n        ll left = (*ite).second;\n        toleft[i][0] = left;\n        toleftvalue[i][0] = (left != -INF) ? i + 1: i + 1;\n    }\n\n    for(int i=1;i<=n;i++){\n        pe(toleft[i][0]);\n        p(toright[i][0]);\n    }\n\n\n\n    for (int j = 1; j <= n; j++) {\n        for (int i = 0; i < 60; i++) {\n\n            if (toright[j][i] == INF) {\n                toright[j][i + 1] = INF;\n            } else {\n                toright[j][i + 1] = toright[toright[j][i]][i];\n                torightvalue[j][i + 1] = torightvalue[j][i] + torightvalue[toright[j][i]][i];\n            }\n\n            if (toleft[j][i] == -INF) {\n                toleft[j][i + 1] = -INF;\n            } else {\n                toleft[j][i + 1] = toleft[toleft[j][i]][i];\n                toleftvalue[j][i + 1] = toleftvalue[j][i] + toleftvalue[toleft[j][i]][i];\n            }\n        }\n    }\n\n    for(int i=1;i<=n;i++){\n        pe(toleftvalue[i][0]);\n        p(torightvalue[i][0]);\n    }\n\n}\n\nvoid solve() {\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n    precalc();\n    ll q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        ll l, r;\n        cin >> l >> r;\n        ll il = l, ir = r;\n        ll haba = 59;\n        ll ans = 0;\n        while (true) {\n            // haba進んでも大丈夫なら進む\n            if (toleft[r][haba] >= il && toright[l][haba] <= ir) {\n                ans += toleftvalue[r][haba] - torightvalue[l][haba];\n                l = toright[l][haba];\n                r = toleft[r][haba];\n            } else {\n                if (haba == 0) {\n                    break;\n                } else {\n                    haba --;\n                }\n            }\n        }\n        /*\n        p(ans);\n        pe(l);p(r);\n        pe(toleftvalue[r][0]);\n        p(torightvalue[l][0]);\n        */\n        ans += toleftvalue[r][0] - torightvalue[l][0];\n        p(ans);\n    }\n\n    return;\n}\n\nint main() {\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    ll q, testcase = 1;\n    if (multicase) {\n        cin >> q;\n    } else {\n        q = 1;\n    }\n    while (q--) {\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n\n    // solve();\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 200222, inf = 1000111222;\nconst int max_lev = 18;\n\nint n, k, q, a[max_n];\nint nxt[2][max_n][max_lev];\nlong long sum[2][max_n][max_lev];\n\nvoid calc_nxt(int tp) {\n    nxt[tp][n][0] = n;\n    for (int i = n - 1; i >= 0; --i) {\n        nxt[tp][i][0] = nxt[tp][i + 1][0];\n        sum[tp][i][0] = i;\n        if (tp) {\n            sum[tp][i][0] = n - i;\n        }\n        while (a[nxt[tp][i][0] - 1] - a[i] >= k) {\n            --nxt[tp][i][0];\n        }\n    }\n    for (int lev = 1; lev < max_lev; ++lev) {\n        for (int i = 0; i <= n; ++i) {\n            nxt[tp][i][lev] = nxt[tp][nxt[tp][i][lev - 1]][lev - 1];\n            sum[tp][i][lev] = sum[tp][i][lev - 1] + sum[tp][nxt[tp][i][lev - 1]][lev - 1];\n        }\n    }\n}\n\nvoid rev() {\n    reverse(a, a + n);\n    for (int i = 0; i < n; ++i) {\n        a[i] *= -1;\n    }\n}\n\nlong long get_sum(int tp, int pos, int r) {\n    long long res = 0;\n    for (int i = max_lev - 1; i >= 0; --i) {\n        if (nxt[tp][pos][i] <= r) {\n            res += sum[tp][pos][i];\n            pos = nxt[tp][pos][i];\n        }\n    }\n    res += sum[tp][pos][0];\n    return res;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n    calc_nxt(0);\n    rev();\n    calc_nxt(1);\n    rev();\n    scanf(\"%d\", &q);\n    while (q--) {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        --l;\n        --r;\n        long long s1 = get_sum(0, l, r);\n        long long s2 = get_sum(1, n - r - 1, n - l - 1);\n        //cout << s1 << \" \" << s2 << \": \";\n        int ans = s2 - s1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n    vector<vector<int>> ld(20, vector<int>(n));\n    vector<vector<int>> rd(20, vector<int>(n));\n    vector<vector<long long>> ls(20, vector<long long>(n));\n    vector<vector<long long>> rs(20, vector<long long>(n));\n    for (int i = 0; i < n; i++) {\n        ld[0][i] = upper_bound(x.begin(), x.end(), x[i] - k) - x.begin() - 1;\n        rd[0][i] = lower_bound(x.begin(), x.end(), x[i] + k) - x.begin();\n        ls[0][i] = ld[0][i];\n        rs[0][i] = rd[0][i];\n    }\n    for (int i = 1; i < 20; i++) {\n        for (int j = 0; j < n; j++) {\n            ld[i][j] = (ld[i - 1][j] == -1 ? -1 : ld[i - 1][ld[i - 1][j]]);\n            rd[i][j] = (rd[i - 1][j] == n ? n : rd[i - 1][rd[i - 1][j]]);\n            ls[i][j] = (ld[i - 1][j] == -1 ? 0 : ls[i - 1][j] + ls[i - 1][ld[i - 1][j]]);\n            rs[i][j] = (rd[i - 1][j] == n ? 0 : rs[i - 1][j] + rs[i - 1][rd[i - 1][j]]);\n        }\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        if (l == r) {\n            cout << 1 << '\\n';\n            continue;\n        }\n        l--, r--;\n        long long ans = r - l + 1;\n        int pl = l, pr = r;\n        for (int i = 19; i >= 0; i--) {\n            if (rd[i][pl] <= r) {\n                ans -= rs[i][pl];\n                pl = rd[i][pl];\n                ans += 1 << i;\n            }\n            if (ld[i][pr] >= l) {\n                ans += ls[i][pr];\n                pr = ld[i][pr];\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n//#pragma GCC target(\"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4\", \"avx\")\n\n#ifdef __APPLE__\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_map>\n# include <unordered_set>\n# include <thread>\n#else\n# include <bits/stdc++.h>\n#endif\n\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n\n#define all(a) a.begin(),a.end()\n#define len(a) (int)(a.size())\n#define mp make_pair\n#define pb push_back\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 2e5+10, inf = 1000111222;\nconst int max_log=20;\n\nint x[max_n];\npii prec_L[max_n][max_log];\npii prec_R[max_n][max_log];\n\nint next_L[max_n];\nint next_R[max_n];\n\nint main() {\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n,k;\n    cin>>n>>k;\n    for (int i=0;i<n;i++){\n        cin>>x[i];\n    }\n\n    auto precalc=[&]()\n    {\n        next_L[0]=0;\n        for (int i=0;i<n;i++){\n            if (i){\n                next_L[i]=next_L[i-1];\n            }\n            while (next_L[i]<n && x[next_L[i]]-x[i]<k){\n                next_L[i]++;\n            }\n//            cout<<\"next_L[\"<<i<<\"] :: \"<<next_L[i]<<\"\\n\";\n        }\n\n        next_R[n-1]=n-1;\n        for (int i=n-1;i>=0;i--){\n            if (i+1!=n){\n                next_R[i]=next_R[i+1];\n            }\n            while (next_R[i]>=0 && x[i]-x[next_R[i]]<k){\n                next_R[i]--;\n            }\n//            cout<<\"next_R[\"<<i<<\"] :: \"<<next_R[i]<<\"\\n\";\n        }\n\n        for (int j=0;j<max_log;j++){\n            if (j==0){\n                for (int i=0;i<n;i++){\n                    prec_L[i][j]=mp(next_L[i],i);\n                }\n            }\n            else{\n                for (int i=0;i<n;i++){\n                    int to = prec_L[i][j-1].fir;\n                    if (to<n){\n                        prec_L[i][j] = prec_L[to][j-1];\n                        prec_L[i][j].sec += prec_L[i][j-1].sec;\n                    }\n                    else{\n                        prec_L[i][j] = prec_L[i][j-1];\n                    }\n                }\n            }\n        }\n        for (int j=0;j<max_log;j++){\n            if (j==0){\n                for (int i=0;i<n;i++){\n                    prec_R[i][j]=mp(next_R[i],i);\n                }\n            }\n            else{\n                for (int i=0;i<n;i++){\n                    int to = prec_R[i][j-1].fir;\n                    if (to>=0){\n                        prec_R[i][j] = prec_R[to][j-1];\n                        prec_R[i][j].sec += prec_R[i][j-1].sec;\n                    }\n                    else{\n                        prec_R[i][j] = prec_R[i][j-1];\n                    }\n                }\n            }\n        }\n    };\n\n    auto get_naive_ans_L=[&](int l,int r)\n    {\n        pii res=mp(1,0);\n        int cur=l;\n        for (int j=max_log-1;j>=0;j--){\n            if (prec_L[cur][j].fir<=r){\n                res.fir+=(1ll<<j);\n                res.sec+=prec_L[cur][j].sec;\n                cur=prec_L[cur][j].fir;\n            }\n        }\n        res.sec+=cur;\n        return res;\n    };\n\n    auto get_naive_ans_R=[&](int l,int r)\n    {\n        pii res=mp(1,0);\n        int cur=r;\n        for (int j=max_log-1;j>=0;j--){\n            if (prec_R[cur][j].fir>=l){\n                res.fir+=(1ll<<j);\n                res.sec+=prec_R[cur][j].sec;\n                cur=prec_R[cur][j].fir;\n            }\n        }\n        res.sec+=cur;\n        return res;\n    };\n\n    auto get_ans=[&](int l,int r)\n    {\n        pii ans_L=get_naive_ans_L(l,r);\n        pii ans_R=get_naive_ans_R(l,r);\n//        cerr<<l<<\" \"<<r<<\" :: \"<<\"(\"<<ans_L.fir<<\",\"<<ans_L.sec<<\"), \"<<\"(\"<<ans_R.fir<<\",\"<<ans_R.sec<<\")\"<<\"\\n\";\n        assert(ans_L.fir == ans_R.fir);\n\n        return ans_L.fir + (ans_R.sec-ans_L.sec);\n    };\n\n    precalc();\n    int q;\n    cin>>q;\n    while (q--){\n        int l,r;\n        cin>>l>>r;\n        l--;\n        r--;\n        cout<<get_ans(l,r)<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/dsu>\nusing namespace std;\nusing namespace atcoder;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf (INT_MAX/2-100)\n#define infl (LLONG_MAX/3)\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n\nll n,k,q,x[200005],l[20][200005],ls[20][200005],r[20][200005],rs[20][200005];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>k;\n\trep(i,n)cin>>x[i];\n\tint p=0;\n\trep(i,n){\n\t\twhile(p<n&&x[p]<x[i]+k)p++;\n\t\tl[0][i]=p;\n\t\tls[0][i]=i;\n\t}\n\tp=n-1;\n\trrep(i,n){\n\t\twhile(p>=0&&x[p]>x[i]-k)p--;\n\t\tr[0][i]=p;\n\t\trs[0][i]=i+1;\n\t}\n\trep(i,19){\n\t\trep(j,n){\n\t\t\tif(l[i][j]==n){\n\t\t\t\tl[i+1][j]=n;\n\t\t\t\tls[i+1][j]=ls[i][j];\n\t\t\t}else{\n\t\t\t\tl[i+1][j]=l[i][l[i][j]];\n\t\t\t\tls[i+1][j]=ls[i][j]+ls[i][l[i][j]];\n\t\t\t}\n\t\t\tif(r[i][j]==-1){\n\t\t\t\tr[i+1][j]=-1;\n\t\t\t\trs[i+1][j]=rs[i][j];\n\t\t\t}else{\n\t\t\t\tr[i+1][j]=r[i][r[i][j]];\n\t\t\t\trs[i+1][j]=rs[i][j]+rs[i][r[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tll a,b,ans=0;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tll s=a,t=b;\n\t\tfor(int i=19;i>=0;i--){\n\t\t\tif(l[i][s]<=b){\n\t\t\t\tans-=ls[i][s];\n\t\t\t\ts=l[i][s];\n\t\t\t}\n\t\t\tif(r[i][t]>=a){\n\t\t\t\tans+=rs[i][t];\n\t\t\t\tt=r[i][t];\n\t\t\t}\n\t\t}\n\t\tans-=ls[0][s];\n\t\tans+=rs[0][t];\n\t\tprint(ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20;\nint n, k, q;\nint x[maxn], l[maxn], r[maxn], w[maxn];\nint res[maxn];\nstruct dsu {\n\tvector<int> p;\n\tvector<int> r, rtop;\n\tdsu(int n) : p(n), r(n, 1) { iota(all(p), 0); rtop = p; }\n\tint par(int v) {\n\t\treturn p[v] == v ? v : p[v] = par(p[v]);\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = par(u), v = par(v);\n\t\tif(u == v) return;\n\t\tint rr = rtop[u];\n\t\tif(r[u] < r[v]) swap(u, v);\n\t\tp[v] = u;\n\t\tr[u] += r[v];\n\t\trtop[u] = rr;\n\t}\n};\nll d[maxn], s[maxn];\nint par[maxn];\nvector<int> g[maxn], p[maxn];\nvoid dfs(int v) {\n\td[v] += w[v];\n\ts[v] += 1;\n\tfor(auto &i : g[v]) {\n\t\td[i] = d[v];\n\t\ts[i] = s[v];\n\t\tpar[i] = v;\n\t\tdfs(i);\n\t}\n}\nvector<ll> solve() {\n\tmemset(d, 0, sizeof d);\n\tmemset(s, 0, sizeof s);\n\tfor(int i = 0; i < maxn; i++) g[i].clear(), p[i].clear();\n\tvector<ll> ans(q);\n\tmemset(par, -1, sizeof par);\n\tfor(int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(x, x+n, x[i]+k)-x;\n\t\tif(it < n) g[it].push_back(i), par[i] = it;\n\t}\n\tfor(int i = 0; i < n; i++) if(par[i] == -1) dfs(i);\n\tfor(int i = 0; i < q; i++) {\n\t\tp[r[i]].push_back(i);\n\t}\n\tdsu f(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(auto j : g[i]) f.unite(i, j);\n\t\tfor(auto &qid : p[i]) {\n\t\t\tint x = l[qid];\n\t\t\tres[qid] = s[x];\n\t\t\tans[qid] = d[x];\n\t\t\tint y = par[f.rtop[f.par(x)]];\n\t\t\tif(y != -1) {\n\t\t\t\tres[qid] -= s[y];\n\t\t\t\tans[qid] -= d[y];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> x[i], w[i] = i;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++)\n\t\tcin >> l[i] >> r[i], l[i]--, r[i]--;\n\tauto a = solve();\n\tfor(int i = 0; i < n; i++) {\n\t\tx[i] *= -1;\n\t\tl[i] = n-1-l[i];\n\t\tr[i] = n-1-r[i];\n\t\tswap(l[i], r[i]);\n\t}\n\treverse(x, x+n);\n\treverse(w, w+n);\n\tauto b = solve();\n\tfor(int i = 0; i < q; i++) cout << b[i] - a[i] + res[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#define mp make_pair\n#define pb push_back\n#define pll pair<LL,LL>\n#define pii pair<int,int>\n#define y second\n#define x first\n#define LL long long \n#define sqr(x) ((x)*(x))\n#define pi acosl(-1)\n#define MEM(x) memset(x,0,sizeof(x))\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nLL gor[200005][20];\nLL valr[200005][20];\nLL gol[200005][20];\nLL vall[2000005][20];\nvoid solve(){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int x[200005];\n    for(int i = 1;i<=n;i++){\n        scanf(\"%d\",&x[i]);\n    }\n    for(int i = 0;i<20;i++){\n        gor[n+1][i]=n+1;\n        gol[0][i]=0;\n    }\n    int now=0;\n    for(int i = 1;i<=n;i++){\n        while(now!=n+1&&x[now]-x[i]<k){\n            now++;\n        }\n        gor[i][0]=now;\n        valr[i][0]=i;\n    }\n    now=n;\n    for(int i =n;i>=1;i--){\n        while(now!=0&&x[i]-x[now]<k){\n            now--;\n        }\n        gol[i][0]=now;\n        vall[i][0]=i;\n    }\n    for(int i = 1;i<20;i++){\n        for(int j = 1;j<=n;j++){\n            gol[j][i]=gol[gol[j][i-1]][i-1];\n            vall[j][i]=vall[j][i-1]+vall[gol[j][i-1]][i-1];\n            gor[j][i]=gor[gor[j][i-1]][i-1];\n            valr[j][i]=valr[j][i-1]+valr[gor[j][i-1]][i-1];\n         //   printf(\"%d %d %lld %lld %lld %lld\\n\",i,j,gol[j][i],vall[j][i],gor[j][i],valr[j][i]);\n        }\n    }\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n        int l,r;\n        scanf(\"%d %d\",&l,&r);\n        LL ans=0;\n        int now=r;\n        for(int i = 19;i>=0;i--){\n            if(gol[now][i]>=l){\n                ans+=vall[now][i]+(1<<i);\n                now=gol[now][i];\n                 //printf(\"%lld %d %d\\n\",now,ans,i);\n            }\n        }\n        ans+=now+1;\n      //  printf(\"%lld\\n\",ans);\n        now=l;\n        for(int i = 19;i>=0;i--){\n            if(gor[now][i]<=r){\n                ans-=valr[now][i];\n               // printf(\"%d %d\\n\",i,valr[now][i]);\n                now=gor[now][i];\n            }\n        }\n        ans-=now;\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n    int t=1;\n    //scanf(\"%d\",&t);\n    while(t--){\n        solve();\n    }\n}\n/*\n1 6 6\n2 7 4\n3 5 2\n4 3 1\n5 2 5\n6 4 0\n7 1 3\n*/\n/*\n100\n5\n5 4\n4 2\n4 2 3\n5 4 2 3 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incII(i, l, r) for(LL i = (l)    ; i <= (r); i++)\n#define incIX(i, l, r) for(LL i = (l)    ; i <  (r); i++)\n#define incXI(i, l, r) for(LL i = (l) + 1; i <= (r); i++)\n#define incXX(i, l, r) for(LL i = (l) + 1; i <  (r); i++)\n#define decII(i, l, r) for(LL i = (r)    ; i >= (l); i--)\n#define decIX(i, l, r) for(LL i = (r) - 1; i >= (l); i--)\n#define decXI(i, l, r) for(LL i = (r)    ; i >  (l); i--)\n#define decXX(i, l, r) for(LL i = (r) - 1; i >  (l); i--)\n#define inc(i, n)  incIX(i, 0, n)\n#define dec(i, n)  decIX(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\nauto inII = [](auto x, auto l, auto r) { return (l <= x && x <= r); };\nauto inIX = [](auto x, auto l, auto r) { return (l <= x && x <  r); };\nauto inXI = [](auto x, auto l, auto r) { return (l <  x && x <= r); };\nauto inXX = [](auto x, auto l, auto r) { return (l <  x && x <  r); };\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define RV(c) reverse(ALL(c))\n#define SC static_cast\n#define SI(c) SC<int>(c.size())\n#define SL(c) SC<LL >(c.size())\n#define RF(e, c) for(auto & e: c)\n#define SF(c, ...) for(auto & [__VA_ARGS__]: c)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\nauto * IS = & cin;\nauto * OS = & cout;\narray<string, 3> SEQ = { \"\", \" \", \"\" };\n// input\ntemplate<typename T> T in() { T a; (* IS) >> a; return a; }\n// input: tuple\ntemplate<typename U, int I> void tin_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void tin_(U & t) { (* IS) >> get<I>(t); tin_<U, I + 1, B ...>(t); }\ntemplate<typename ... T> auto tin() { tuple<T ...> t; tin_<tuple<T ...>, 0, T ...>(t); return t; }\n// input: array\ntemplate<typename T, int N> auto ain() { array<T, N> a; inc(i, N) { (* IS) >> a[i]; } return a; }\n// input: multi-dimensional vector\ntemplate<typename T> T vin() { T v; (* IS) >> v; return v; }\ntemplate<typename T, typename N, typename ... M> auto vin(N n, M ... m) {\n\tvector<decltype(vin<T, M ...>(m ...))> v(n); inc(i, n) { v[i] = vin<T, M ...>(m ...); } return v;\n}\n// input: multi-column (tuple<vector>)\ntemplate<typename U, int I> void colin_([[maybe_unused]] U & t) { }\ntemplate<typename U, int I, typename A, typename ... B> void colin_(U & t) {\n\tget<I>(t).PB(in<A>()); colin_<U, I + 1, B ...>(t);\n}\ntemplate<typename ... T> auto colin(int n) {\n\ttuple<vector<T> ...> t; inc(i, n) { colin_<tuple<vector<T> ...>, 0, T ...>(t); } return t;\n}\n// output\nvoid out_([[maybe_unused]] string s) { }\ntemplate<typename A> void out_([[maybe_unused]] string s, A && a) { (* OS) << a; }\ntemplate<typename A, typename ... B> void out_(string s, A && a, B && ... b) { (* OS) << a << s; out_(s, b ...); }\nauto outF = [](auto x, auto y, auto z, auto ... a) { (* OS) << x; out_(y, a ...); (* OS) << z << flush; };\nauto out  = [](auto ... a) { outF(\"\", \" \" , \"\\n\", a ...); };\nauto outS = [](auto ... a) { outF(\"\", \" \" , \" \" , a ...); };\nauto outL = [](auto ... a) { outF(\"\", \"\\n\", \"\\n\", a ...); };\nauto outN = [](auto ... a) { outF(\"\", \"\"  , \"\"  , a ...); };\n// output: multi-dimensional vector\ntemplate<typename T> ostream & operator<<(ostream & os, vector<T> const & v) {\n\tos << SEQ[0]; inc(i, SI(v)) { os << (i == 0 ? \"\" : SEQ[1]) << v[i]; } return (os << SEQ[2]);\n}\ntemplate<typename T> void vout_(T && v) { (* OS) << v; }\ntemplate<typename T, typename A, typename ... B> void vout_(T && v, A a, B ... b) {\n\tinc(i, SI(v)) { (* OS) << (i == 0 ? \"\" : a); vout_(v[i], b ...); }\n}\ntemplate<typename T, typename A, typename ... B> void vout (T && v, A a, B ... b) { vout_(v, a, b ...); (* OS) << a << flush; }\ntemplate<typename T, typename A, typename ... B> void voutN(T && v, A a, B ... b) { vout_(v, a, b ...); (* OS)      << flush; }\n\n// ---- ----\n\n// make vector\ntemplate<typename T> T MV(T v) { return v; }\ntemplate<typename T, typename ... U> auto MV(T v, int a, U ... b) { return vector<decltype(MV(v, b ...))>(a, MV(v, b ...)); }\n\n#define LB(v, x) (lower_bound(ALL(v), x) - v.begin())\n#define UB(v, x) (upper_bound(ALL(v), x) - v.begin())\n\nauto mo = [](auto a, auto b) { assert(b != 0); a %= b; if(a < 0) { a += abs(b); } return a; };\n\nint main() {\n\tauto [n, k] = tin<int, int>();\n\tvector<int> x(n + 2);\n\tinc1(i, n) { cin >> x[i]; }\n\tx.FR = x[1] - k;\n\tx.BA = x[n] + k;\n\tvector<array<LL, 3>> L(n + 2), R(n + 2);\n\tL[n + 1] = { -1, n + 1, 0 };\n\tdec1(i, n) {\n\t\tLL e = LB(x, x[i] + k);\n\t\tLL c = L[e][0] + 1;\n\t\tL[i] = { c, e, (e - i) * c };\n\t}\n\tR[0] = { -1, 0, 0 };\n\tinc1(i, n) {\n\t\tLL e = UB(x, x[i] - k) - 1;\n\t\tLL c = R[e][0] + 1;\n\t\tR[i] = { c, e, (i - e) * c };\n\t}\n\t\n\tconst int B = 18;\n\tauto pl = MV<pair<int, LL>>({ 0, 0 }, n + 2, B);\n\tauto pr = MV<pair<int, LL>>({ 0, 0 }, n + 2, B);\n\tinc(k, B) {\n\tinc1(i, n + 1) {\n\t\tif(k == 0) { pl[i][k] = { L[i][1], L[i][2] }; }\n\t\telse {\n\t\t\tpl[i][k].FI = pl[pl[i][k - 1].FI][k - 1].FI;\n\t\t\tpl[i][k].SE = pl[pl[i][k - 1].FI][k - 1].SE + pl[i][k - 1].SE;\n\t\t}\n\t}\n\t}\n\tinc(k, B) {\n\tinc(i, n + 1) {\n\t\tif(k == 0) { pr[i][k] = { R[i][1], R[i][2] }; }\n\t\telse {\n\t\t\tpr[i][k].FI = pr[pr[i][k - 1].FI][k - 1].FI;\n\t\t\tpr[i][k].SE = pr[pr[i][k - 1].FI][k - 1].SE + pr[i][k - 1].SE;\n\t\t}\n\t}\n\t}\n\t\n\tauto sl = [&](int l, int r) {\n\t\tint v = l;\n\t\tLL s = 0;\n\t\tdec(k, B) {\n\t\t\tif(pl[v][k].FI <= r) {\n\t\t\t\ts += pl[v][k].SE;\n\t\t\t\tv  = pl[v][k].FI;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\ts += (r - v + 1) * L[v][0];\n\t\treturn s;\n\t};\n\tauto sr = [&](int l, int r) {\n\t\tint v = r;\n\t\tLL s = 0;\n\t\tdec(k, B) {\n\t\t\tif(pr[v][k].FI >= l) {\n\t\t\t\ts += pr[v][k].SE;\n\t\t\t\tv  = pr[v][k].FI;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\ts += (v - l + 1) * R[v][0];\n\t\treturn s;\n\t};\n\t\n\tauto Q = in<int>();\n\tinc(q, Q) {\n\t\tauto [l, r] = tin<LL, LL>();\n\t\tLL sum = sl(l, r) + sr(l, r);\n\t\tLL len = r - l + 1;\n\t\tLL ans = - sum % len;\n\t\tif(ans <= 0) { ans += len; }\n\t\tout(ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntemplate<class T> bool chmin(T& a,T b){if(a>b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a<b) {a = b; return true;} return false;}\n#define all(x) (x).begin(),(x).end()\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\n\nint main(){\n    int N,K;\n    cin >> N >> K;\n    vec<int> X(N);\n    for(auto& x:X) cin >> x;\n    int M = 18;\n    vvec<ll> left(M,vec<ll>(N,-1)),left_val = left;\n    vvec<ll> right(M,vec<ll>(N,N)),right_val = right;\n    for(int i=0;i<N;i++){\n        int id = lower_bound(all(X),X[i]+K)-X.begin();\n        right[0][i] = id;\n        right_val[0][i] = id;\n        id = upper_bound(all(X),X[i]-K)-X.begin();\n        id--;\n        left[0][i] = id;\n        left_val[0][i] = id;\n    }\n    for(int k=0;k+1<M;k++) for(int i=0;i<N;i++){\n        int ne = right[k][i];\n        if(ne!=N){\n            right[k+1][i] = right[k][ne];\n            right_val[k+1][i] = right_val[k][i]+right_val[k][ne];\n        }\n        ne = left[k][i];\n        if(ne!=-1){\n            left[k+1][i] = left[k][ne];\n            left_val[k+1][i] = left_val[k][i]+left_val[k][ne];\n        }\n    }\n\n    auto solve = [&](int l,int r){\n        ll a = l;\n        int now = l;\n        int cnt = 1;\n        for(int k=M-1;k>=0;k--){\n            if(right[k][now]<=r){\n                cnt += 1<<k;\n                a += right_val[k][now];\n                now = right[k][now];\n            }\n        }\n        ll b = r;\n        now = r;\n        for(int k=M-1;k>=0;k--){\n            if(left[k][now]>=l){\n                b += left_val[k][now];\n                now = left[k][now];\n            }\n        }\n        cout << b-a+cnt << \"\\n\";\n    };\n\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int l,r;\n        cin >> l >> r;\n        solve(l-1,r-1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct Segtree {\n\t\tll dt[1 << 20];\n\t\tvoid inline change(int to, int x, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl == nr) return void(dt[now] = x);\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\tif(m >= to) change(to, x, now << 1, nl, m);\n\t\t\telse change(to, x, now << 1 | 1, m + 1, nr);\n\t\t\tdt[now] = dt[now << 1] + dt[now << 1 | 1];\n\t\t}\n\t\tll inline sum(int l, int r, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl >= l && nr <= r) return dt[now];\n\t\t\tif(nl > r || nr < l) return 0;\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\treturn sum(l, r, now << 1, nl, m) + sum(l, r, now << 1 | 1, m + 1, nr);\n\t\t}\n\t} seg;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18], tag;\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) seg.change(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (tag ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tll inline sum(int a, int b) {\n\t\tll res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += seg.sum(dfn[rt], dfn[a]);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0); tl.tag = 1;\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tassert(ans == res.first); int pl = res.second;\n\t\tprintf(\"%lld\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n#include<random>\n\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\n\n\nll l[20][202020];\nll r[20][202020];\nll dp1[20][202020];\nll dp2[20][202020];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\n\tll n, k;\n\tcin >> n >> k;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tREP(i, n)dp1[0][i] = l[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n\tREP(i, n)dp2[0][i] = r[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\tREP(i, 19)REP(j, n)l[i + 1][j] = l[i][min(n - 1, l[i][j])];\n\tREP(i, 19)REP(j, n)r[i + 1][j] = r[i][max(0LL, r[i][j])];\n\tREP(i, 19)REP(j, n)dp1[i + 1][j] = dp1[i][j] + dp1[i][l[i][j]];\n\tREP(i, 19)REP(j, n)dp2[i + 1][j] = dp2[i][j] + dp2[i][r[i][j]];\n\tll q;\n\tcin >> q;\n\twhile (q--) {\n\t\tll L, R;\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tll ans = R - L;\n\t\tll x = L, y = R - 1;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (l[i][x] < R)ans += (1LL << i) - dp1[i][x], x = l[i][x];\n\t\t\tif (r[i][y] >= L)ans += dp2[i][y], y = r[i][y];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<18;\nint n, k, q;\nint x[maxn], l[maxn], r[maxn], w[maxn];\nint res[maxn];\nstruct dsu {\n\tvector<int> p;\n\tvector<int> r, rtop;\n\tdsu(int n) : p(n), r(n, 1) { iota(all(p), 0); rtop = p; }\n\tint par(int v) {\n\t\treturn p[v] == v ? v : p[v] = par(p[v]);\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = par(u), v = par(v);\n\t\tif(u == v) return;\n\t\tint rr = rtop[u];\n\t\tif(r[u] < r[v]) swap(u, v);\n\t\tp[v] = u;\n\t\tr[u] += r[v];\n\t\trtop[u] = rr;\n\t}\n};\nstruct solver {\nll d[maxn], s[maxn];\nint par[maxn];\nvector<int> g[maxn], p[maxn];\nvoid dfs(int v) {\n\td[v] += w[v];\n\ts[v] += 1;\n\tfor(auto &i : g[v]) {\n\t\td[i] = d[v];\n\t\ts[i] = s[v];\n\t\tpar[i] = v;\n\t\tdfs(i);\n\t}\n}\nvector<ll> solve() {\n\tvector<ll> ans(q);\n\tfor(int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(x, x+n, x[i]+k)-x;\n\t\tif(it < n) g[it].push_back(i);\n\t}\n\tmemset(par, -1, sizeof par);\n\tfor(int i = 0; i < n; i++) if(par[i] == -1) dfs(i);\n\tfor(int i = 0; i < q; i++) {\n\t\tp[r[i]].push_back(i);\n\t}\n\tdsu f(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(auto j : g[i]) f.unite(i, j);\n\t\tfor(auto &qid : p[i]) {\n\t\t\tint x = l[qid];\n\t\t\tres[qid] = s[x];\n\t\t\tans[qid] = d[x];\n\t\t\tint y = par[f.rtop[f.par(x)]];\n\t\t\tif(y != -1) {\n\t\t\t\tres[qid] -= s[y];\n\t\t\t\tans[qid] -= d[y];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n};\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> x[i], w[i] = i;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++)\n\t\tcin >> l[i] >> r[i], l[i]--, r[i]--;\n\tsolver A;\n\tauto a = A.solve();\n\tfor(int i = 0; i < n; i++) {\n\t\tx[i] *= -1;\n\t\tl[i] = n-1-l[i];\n\t\tr[i] = n-1-r[i];\n\t\tswap(l[i], r[i]);\n\t}\n\treverse(x, x+n);\n\treverse(w, w+n);\n\tsolver B;\n\tauto b = B.solve();\n\tfor(int i = 0; i < q; i++) cout << b[i] - a[i] + res[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nint n,m,q,i,j,a[200005],l[200005][19],r[200005][19];\nlong long f[200005][19],g[200005][19];\nint main(){\n\tcin>>n>>m;\n\trep(i,n){\n\t\tcin>>a[i];\n\t}\n\tr[n+1][0]=n+1;\n\tl[n+1][0]=n+1;\n\trep(i,n){\n\t\tr[i][0]=max(i,r[i-1][0]);\n\t\twhile(r[i][0]<=n&&a[r[i][0]]-a[i]<m) r[i][0]++;\n\t}\n\tfor(i=n;i>=1;i--){\n\t\tl[i][0]=min(i,l[i+1][0]);\n\t\twhile(l[i][0]>=1&&a[i]-a[l[i][0]]<m) l[i][0]--;\n\t}\n\trep(j,18)rep(i,n+1){\n\t\tl[i][j]=l[l[i][j-1]][j-1];\n\t\tr[i][j]=r[r[i][j-1]][j-1];\n\t}\n\trep(i,n){\n\t\tf[i][0]=l[i][0];\n\t\tg[i][0]=r[i][0];\n\t}\n\trep(j,18)rep(i,n){\n\t\tf[i][j]=f[i][j-1]+f[l[i][j-1]][j-1];\n\t\tg[i][j]=g[i][j-1]+g[r[i][j-1]][j-1];\n\t}\n\tcin>>q;\n\twhile(q--)\n\t{\n\t\tint x,y,xx,yy;cin>>x>>y;xx=x;yy=y;\n\t\tlong long ans=y-x+1;\n\t\tfor(i=18;i>=0;i--){\n\t\t\tif(r[x][i]<=yy){\n\t\t\t\tans+=(1<<i);\n\t\t\t\tans-=g[x][i];\n\t\t\t\tx=r[x][i];\n\t\t\t}\n\t\t\tif(l[y][i]>=xx){\n\t\t\t\tans+=f[y][i];\n\t\t\t\ty=l[y][i];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nint main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi ans(Q);\n    vi L(Q), R(Q);\n    rep(i, Q) cin >> L[i] >> R[i];\n    rep(_, 2)\n    {\n        vv(int, nxt, 20, n + 1, n);\n        vv(int, cnt, 20, n + 1);\n        rep(i, n)\n        {\n            nxt[0][i] = lb(a, a[i] + k);\n            cnt[0][i] = nxt[0][i] - i;\n        }\n        rep(i, 19)\n        {\n            rep(j, n)\n            {\n                nxt[i + 1][j] = nxt[i][nxt[i][j]];\n                cnt[i + 1][j] = cnt[i][nxt[i][j]] + (1LL << i) * (nxt[i][j] - j) + cnt[i][j];\n            }\n        }\n        rep(ii, Q)\n        {\n            int l = L[ii], r = R[ii];\n            if (_)\n            {\n                swap(l, r);\n                l = n - l, r = n + 1 - r;\n            }\n            else\n                l--;\n            int d = r - l;\n            int m = 0;\n            int now = l;\n            rep3(i, 19, 0)\n            {\n                if (nxt[i][now] < r)\n                    m += 1 << i, now = nxt[i][now];\n            }\n            if (_)\n                ans[ii] += d * (m + 1);\n            now = l;\n            ll res = m;\n            rep(i, 20)\n            {\n                if (m & 1 << i)\n                    ans[ii] -= cnt[i][now] + (now - l) * res, res -= 1 << i, now = nxt[i][now];\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nconst char newl = '\\n';\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\ntemplate<typename T=Int>\nvector<T> read(size_t n){\n  vector<T> ts(n);\n  for(size_t i=0;i<n;i++) cin>>ts[i];\n  return ts;\n}\n\n//INSERT ABOVE HERE\nconst Int LOG = 20;\nconst Int MAX = 2e5+10;\nInt nx[LOG][MAX]={};\nInt sm_nx[LOG][MAX]={};\n\nInt pr[LOG][MAX]={};\nInt sm_pr[LOG][MAX]={};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n,k;\n  cin>>n>>k;\n  auto xs=read(n);\n  xs.emplace(xs.begin(),-k);\n  xs.emplace_back(Int(xs.back())+k);\n\n  for(Int i=1;i<=n;i++){\n    nx[0][i]=lower_bound(xs.begin(),xs.end(),xs[i]+k)-xs.begin();\n    pr[0][i]=--upper_bound(xs.begin(),xs.end(),xs[i]-k)-xs.begin();\n    sm_nx[0][i]=i;\n    sm_pr[0][i]=i+1;\n  }\n\n  nx[0][n+1]=n+1;\n  pr[0][0]=0;\n\n  for(Int k=0;k+1<LOG;k++){\n    for(Int i=0;i<=n+1;i++){\n      nx[k+1][i]=nx[k][nx[k][i]];\n      pr[k+1][i]=pr[k][pr[k][i]];\n      sm_nx[k+1][i]=sm_nx[k][i]+sm_nx[k][nx[k][i]];\n      sm_pr[k+1][i]=sm_pr[k][i]+sm_pr[k][pr[k][i]];\n    }\n  }\n\n  Int q;\n  cin>>q;\n  for(Int i=0;i<q;i++){\n    Int l,r;\n    cin>>l>>r;\n    // [l, r]\n    Int p=l,q=r;\n    Int ans=0;\n    // cout<<l<<newl;\n    // cout<<r<<newl;\n    for(Int k=LOG-1;k>=0;k--){\n      if(nx[k][p]<=r){\n        ans-=sm_nx[k][p];\n        p=nx[k][p];\n        // cout<<p<<newl;\n      }\n      if(pr[k][q]>=l){\n        ans+=sm_pr[k][q];\n        q=pr[k][q];\n        // cout<<q<<newl;\n      }\n    }\n    // cout<<\":\";\n    ans-=p;\n    ans+=q+1;\n    cout<<ans<<newl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[19][201010], toL[19][201010];\nint totR[19][201010], totL[19][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 18, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 19) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 19) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 19) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\n\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec X(N); cin >> X;\n    int Q; cin >> Q;\n\n    vector<v_Pii> next(20, v_Pii(N, Pii(N, 0))), prev(20, v_Pii(N, Pii(-1, 0)));\n    REP(i, N){\n        int j = Lower_bound(X, X[i] + K);\n        if(j < N) next[0][i] = Pii(j, j);\n        int k = Upper_bound(X, X[i] - K) - 1;\n        if(k >= 0) prev[0][i] = Pii(k, k);\n    }\n    FOR(t, 1, 20){\n        REP(i, N) if(next[t - 1][i].fi < N){\n            int v = next[t - 1][next[t - 1][i].fi].fi;\n            int cost = next[t - 1][i].se + next[t - 1][next[t - 1][i].fi].se;\n            next[t][i] = Pii(v, cost);\n        }\n        REP(i, N) if(prev[t - 1][i].fi >= 0){\n            int v = prev[t - 1][prev[t - 1][i].fi].fi;\n            int cost = prev[t - 1][i].se + prev[t - 1][prev[t - 1][i].fi].se;\n        }\n    }\n    //mdebug(next); mdebug(prev);\n\n    vec ans(Q);\n    REP(q, Q){\n        int L, R; cin >> L >> R;\n        L--; R--;\n\n        int nl = 1, cl = L;\n        int now = L;\n        while(next[0][now].fi <= R){\n            IREP(t, 20) if(next[t][now].fi <= R){\n                nl += bit(t);\n                cl += next[t][now].se;\n                now = next[t][now].fi;\n                break;\n            }\n        }\n        int nr = 1, cr = R;\n        now = R;\n        while(prev[0][now].fi >= L){\n            IREP(t, 20) if(prev[t][now].fi >= L){\n                nr += bit(t);\n                cr += prev[t][now].se;\n                now = prev[t][now].fi;\n                break;\n            }\n        }\n        ans[q] = cr - cl + nl;\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 2020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    for(auto itr = a.begin(); itr != a.end(); itr++){\n\t\tcout << *itr << \" \";\n\t}\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){\n\tcout << \"debug: \" << a << \" \" << b << \"\\n\";\n}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << \"debug: \" << a << \" \" << b << \" \" << c << \"\\n\";\n}\nvoid mark() {cout << \"#\" << \"\\n\";}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nint Lpos[20][202020], Lsum[20][202020];\nint Rpos[20][202020], Rsum[20][202020];\n\nint main(){\n    ll n,k; cin >> n >> k;\n    vl x(n); rep(i,n) cin >> x[i];\n    rep(i,n){\n        Lpos[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n        Rpos[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\t\tLsum[0][i] = Rsum[0][i] = i;\n    }\n\tLpos[0][n] = n;\n\trep(i,19){\n\t\trep(j,n){\n\t\t\tLpos[i+1][j] = Lpos[i][Lpos[i][j]];\n\t\t\tLsum[i+1][j] = Lsum[i][j] + Lsum[i][Lpos[i][j]];\n\t\t\tif(Rpos[i][j] != -1) Rpos[i+1][j] = Rpos[i][Rpos[i][j]];\n\t\t\telse Rpos[i+1][j] = -1;\n\t\t\tRsum[i+1][j] = Rsum[i][j];\n\t\t\tif(Rpos[i][j] >= 0){\n\t\t\t\tRsum[i+1][j] += Rsum[i][Rpos[i][j]];\n\t\t\t}\n\t\t}\n\t\tLpos[i+1][n] = n;\n\t}\n\tint q; cin >> q;\n\twhile(q--){\n\t\tll l,r; cin >> l >> r; l--; r--;\n\t\tll pos = l;\n\t\tll ls = 0, rs = 0;\n\t\tfor(int i=19; i>=0; i--){\n\t\t\tif(Lpos[i][pos] <= r){\n\t\t\t\tls += Lsum[i][pos];\n\t\t\t\tpos = Lpos[i][pos];\n\t\t\t}\n\t\t}\n\t\tls += pos;\n\t\tpos = r;\n\t\tfor(int i=19; i>=0; i--){\n\t\t\tif(Rpos[i][pos] >= l){\n\t\t\t\trs += Rsum[i][pos] + (1<<i);\n\t\t\t\tpos = Rpos[i][pos];\n\t\t\t}\n\t\t}\n\t\trs += pos + 1;\n\t\tcout << rs - ls << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <atcoder/all>\nusing namespace atcoder;\n#define rep(i,n) for (long long i = 0; i < (n); ++i)\nusing ll = long long;\nusing P = pair<ll,ll>;\nusing vec = vector<ll>;\nusing vecp = vector<P>;\nusing mat = vector<vec>;\nusing matp = vector<vecp>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define all(v) v.begin(), v.end()\n\nint main(){\n  ll N,K,Q;\n  cin >> N >> K;\n  matp A(N,vecp(20,P(0,0))),C(N,vecp(20,P(N,0)));\n  vec B(N);\n  rep(i,N){\n    cin >> B.at(i);\n  }\n  rep(i,N){\n    auto a=lower_bound(all(B),B.at(i)+K);\n    if(a!=B.end()){\n      A.at(i).at(0)=P((ll)(a-B.begin()),(ll)(a-B.begin()));\n    }\n    auto b=upper_bound(all(B),B.at(N-1-i)-K);\n    if(b!=B.begin()){\n      C.at(N-1-i).at(0)=P((ll)(b-B.begin())-1,(ll)(b-B.begin())-1);\n    }\n  }\n  rep(i,19){\n    rep(j,N){\n      if(A.at(j).at(i).first!=0){\n        A.at(j).at(i+1).first=A.at(A.at(j).at(i).first).at(i).first;\n        A.at(j).at(i+1).second=A.at(A.at(j).at(i).first).at(i).second+A.at(j).at(i).second;\n      }\n      if(C.at(j).at(i).first!=N){\n        C.at(j).at(i+1).first=C.at(C.at(j).at(i).first).at(i).first;\n        C.at(j).at(i+1).second=C.at(C.at(j).at(i).first).at(i).second+C.at(j).at(i).second;\n      }\n    }\n  }\n  cin >> Q;\n  rep(i,Q){\n    ll l,r,ans=0,L=0,R=0,a;\n    cin >> l >> r;\n    l--;\n    r--;\n    a=l;\n    L+=l;\n    R+=r;\n    rep(j,20){\n      if(A.at(l).at(19-j).first!=0&&A.at(l).at(19-j).first<=r){\n        if(A.at(l).at(19-j).first==r){\n          L+=A.at(l).at(19-j).second;\n          ans+=(ll)pow(2,19-j);\n          break;\n        }else{\n          L+=A.at(l).at(19-j).second;\n          ans+=(ll)pow(2,19-j);\n          l=A.at(l).at(19-j).first;\n        }\n      }\n    }\n    l=a;\n    rep(j,20){\n      if(C.at(r).at(19-j).first!=N&&C.at(r).at(19-j).first>=l){\n        if(C.at(r).at(19-j).first==l){\n          R+=C.at(r).at(19-j).second;\n          break;\n        }else{\n          R+=C.at(r).at(19-j).second;\n          r=C.at(r).at(19-j).first;\n        }\n      }\n    }\n    cout << ans+R-L+1 << endl;\n  }\n  \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n#include <bits/c++config.h>\n//#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n\n#define PI acos(-1)\n\n#define rep(i, a, b) for (int i=a; i<b; ++i)\n#define per(i, a, b) for (int i=b-1; i>=a; --i)\n#define REP(i, a, b) for (int i=a; i<=b; ++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\n\ntypedef std::vector<int> vi;\ntypedef std::vector<long long> vll;\ntypedef std::vector<double> vd;\ntypedef std::vector<long double> vld;\ntypedef std::vector<string> vs;\ntypedef std::pair<int,int> pii;\ntypedef std::queue<int> qi;\n\nint n, frst, scnd;\nmap<int, int> tble;\n\nint main() {\n\tstd::ios::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL);\n\tcin >> n;\n\trep(i, 0, n) {\n\t\tcin >> frst >> scnd;\n\t\ttble[frst] = scnd;\n\t}\n//\tfor (auto u : tble)\n//\t\tcout << u.first << ' ' << u.second << endl;\n\tREP(i, 1, n) {\n\t\tint cnt = 1;\n\t\tREP(j, 1, n) {\n\t\t\tif ( (i < j && tble[i] < tble[j]) || (i > j && tble[i] > tble[j]) ) {\n//\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\n#define int long long\nsigned main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi ans(Q);\n    vi L(Q), R(Q);\n    rep(i, Q) cin >> L[i] >> R[i];\n    rep(_, 2)\n    {\n        vv(int, nxt, 20, n + 1, n);\n        vv(int, cnt, 20, n + 1);\n        rep(i, n)\n        {\n            nxt[0][i] = lb(a, a[i] + k);\n            cnt[0][i] = nxt[0][i] - i;\n        }\n        rep(i, 19)\n        {\n            rep(j, n)\n            {\n                nxt[i + 1][j] = nxt[i][nxt[i][j]];\n                cnt[i + 1][j] = cnt[i][nxt[i][j]] + (1LL << i) * (nxt[i][j] - j) + cnt[i][j];\n            }\n        }\n        rep(ii, Q)\n        {\n            int l = L[ii], r = R[ii];\n            if (_)\n            {\n                swap(l, r);\n                l = n - l, r = n + 1 - r;\n            }\n            else\n                l--;\n            int d = r - l;\n            int m = 0;\n            int now = l;\n            rep3(i, 19, 0)\n            {\n                if (nxt[i][now] < r)\n                    m += 1 << i, now = nxt[i][now];\n            }\n            if (_)\n                ans[ii] += d * (m + 1);\n            now = l;\n            ll rem = 0;\n            rep(i, 20)\n            {\n                if (m & 1 << i)\n                {\n                    ans[ii] -= cnt[i][now] + (now - l) * (m - rem), rem += 1 << i, now = nxt[i][now];\n                }\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <chrono>\n//#pragma GCC optimize(\"Ofast\")\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\n\nusing ll = long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\n\nll N,M,H,W,Q,K,A,B;\nstring S;\ntypedef pair<ll, ll> P;\nconst ll INF = (1LL<<60);\n\nll solve(int l, int r,mat &dv, mat &dvr, mat &dsum, mat &dsumr){\n    ll res(r - l);\n    int nowl(l), nowr(r), len(1);\n    Rrep(i, 18){\n        if(dv[i][nowl] <= r){\n            res -= dsum[i][nowl];\n            nowl = dv[i][nowl];\n            len += 1<<i;\n        }\n        if(dvr[i][nowr] >= l){\n            res += dsumr[i][nowr];\n            nowr = dvr[i][nowr];\n        }\n    }\n    return res + len;\n}\n\nint main() {\n    cin>>N>>K;\n    N += 2;\n    vec x(N), x_rev(N);\n    mat dbl(18, vec(N)), dbl_rev(18, vec(N)), dbl_sum(18, vec(N, 0)), dbl_rev_sum(18, vec(N, 0));\n    reps(i, 1, N - 1) cin>>x[i];\n    x[0] = -INF; x[N - 1] = INF;\n    copy(x.rbegin(), x.rend(), x_rev.begin());\n    rep(i, N) x_rev[i] = - x_rev[i];\n    //reps(i, 1, N - 1) cout<<x_rev[i]<<\" \\n\"[i == N - 2];\n    rep(i, N) {\n        dbl[0][i] = dbl_sum[0][i] = min(N - 1, (ll)(lower_bound(ALL(x), x[i] + K) - x.begin()));\n        dbl_rev[0][i] = dbl_rev_sum[0][i] = N - 1 - min(N - 1, (ll)(lower_bound(ALL(x_rev), x_rev[N - 1 - i] + K) - x_rev.begin()));\n        //cout<<dbl_rev[0][i]<<\" \\n\"[i == N - 1];\n    }\n    reps(i, 1, 18) {\n        rep(v, N) {\n            dbl[i][v] = dbl[i-1][dbl[i-1][v]];\n            dbl_rev[i][v] = dbl_rev[i-1][dbl_rev[i-1][v]];\n            dbl_sum[i][v] = dbl_sum[i-1][v] + dbl_sum[i-1][dbl[i-1][v]];\n            dbl_rev_sum[i][v] = dbl_rev_sum[i-1][v] + dbl_rev_sum[i-1][dbl_rev[i-1][v]];\n        }\n    }\n    cin>>Q;\n    rep(_, Q){\n        int l, r; cin>>l>>r;\n        cout<<solve(l, r, dbl, dbl_rev, dbl_sum, dbl_rev_sum)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n    f = 0; _T fu = 1; char c = getchar();\n    while (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n    while (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n    f *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x < 10) putchar(x + 48);\n    else print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n    print(x); putchar(t);\n}\n\nconst int N = 2e5 + 5;\n\nll suml[N][20], sumr[N][20];\nint a[N], l[N][20], r[N][20];\nint n, k, q;\n\nint main() {\n    read(n); read(k);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    for (int i = 1; i <= n; i++) {\n        l[i][0] = upper_bound(a + 1, a + n + 1, a[i] - k) - a - 1;\n        r[i][0] = lower_bound(a + 1, a + n + 1, a[i] + k) - a;\n        suml[i][0] = i; sumr[i][0] = i - 1;\n    }\n    r[n + 1][0] = n + 1;\n    for (int j = 1; j <= 19; j++) {\n        for (int i = 0; i <= n + 1; i++) {\n            l[i][j] = l[l[i][j - 1]][j - 1];\n            suml[i][j] = suml[i][j - 1] + suml[l[i][j - 1]][j - 1];\n            r[i][j] = r[r[i][j - 1]][j - 1];\n            sumr[i][j] = sumr[i][j - 1] + sumr[r[i][j - 1]][j - 1];\n        }\n    }\n    read(q);\n    while (q--) {\n        int L, R; read(L); read(R);\n        ll sumL = 0, sumR = 0;\n        int nowL = L, nowR = R;\n        for (int j = 19; j >= 0; j--) {\n            if (r[nowL][j] <= R) {\n                sumL += sumr[nowL][j];\n                nowL = r[nowL][j];\n            }\n            if (l[nowR][j] >= L) {\n                sumR += suml[nowR][j];\n                nowR = l[nowR][j];\n            }\n        }\n        print(sumR - sumL + nowR - nowL + 1, '\\n');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<atcoder/all>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt k;\n\nstruct Val{\n    Int nxt;\n    Int sum;\n    Val():nxt(0), sum(0){}\n};\n\nstruct calculator{\n    Int n;\n    Int nums[220000];\n    Val nxts[220000][20];\n    void calc(){\n        for(Int l = 0, r = 0;l < n;l++){\n            while(r < n && nums[r] < nums[l] + k)r++;\n            nxts[l][0].nxt = r;\n            nxts[l][0].sum = r;\n        }\n        for(Int h = 1;h < 20;h++){\n            for(Int i = 0;i < n;i++){\n                nxts[i][h] = nxts[i][h-1];\n                Int nxt_ind = nxts[i][h].nxt;\n                if(nxt_ind != n){\n                    nxts[i][h].nxt = nxts[nxt_ind][h-1].nxt;\n                    nxts[i][h].sum += nxts[nxt_ind][h-1].sum;\n                }\n            }\n        }\n    }\n\n    Int go(Int l, Int cnt){\n        for(Int h = 19;h >= 0;h--){\n            if(cnt < (1 << h))continue;\n            l = nxts[l][h].nxt;\n            if(l == n)return n;\n            cnt -= (1 << h);\n        }\n        return l;\n    }\n\n    Int sum(Int l, Int cnt){\n        Int ans = l;        \n        for(Int h = 19;h >= 0;h--){\n            if(cnt < (1 << h))continue;\n            ans += nxts[l][h].sum;\n            l = nxts[l][h].nxt;\n            cnt -= (1 << h);\n        }\n        return ans;\n    }\n    \n} X, Y;\n\nint main(){\n    Int n, q;\n    cin >> n >> k;\n    for(Int i = 0;i < n;i++){\n        cin >> X.nums[i];\n        Y.nums[n-i-1] = MOD - X.nums[i];\n    }\n    X.n = Y.n = n;\n    X.calc();\n    Y.calc();\n    \n    cin >> q;\n    for(Int i = 0;i < q;i++){\n        Int l, r;\n        cin >> l >> r;l--,r--;\n        Int bottom = 0, top = n;\n        while(top - bottom > 1){\n            Int mid = (top + bottom) / 2;\n            if(X.go(l, mid) <= r)bottom = mid;\n            else top = mid;\n        }\n        Int cnt = bottom + 1;\n        cout << ((n-1) * cnt - Y.sum(n-r-1, cnt-1)) -  X.sum(l, cnt-1) +  cnt << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nconst int L = 20;\nconst int maxn = 200010;\n\nint nxtl[L][maxn], nxtr[L][maxn];\nll suml[L][maxn], sumr[L][maxn];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int N, K;\n    cin >> N >> K;\n    V<int> X(N);\n    rep(i, N) cin >> X[i];\n\n    memset(nxtr, -1, sizeof(nxtr));\n\n    int p = 0, q = 0;\n\n    rep(i, N) {\n        chmax(p, i);\n\n        while (p < N && X[p] < X[i] + K) ++p;\n        while (q < i && X[q + 1] <= X[i] - K) ++q;\n        if (p < N) {\n            nxtr[0][i] = p;\n            sumr[0][i] = p;\n        }\n        if (X[q] - X[i] <= K) {\n            nxtl[0][i] = q;\n            suml[0][i] = q;\n        }\n    }\n\n    rep(i, L - 1) {\n        rep(j, N) {\n            if (nxtr[i][j] == -1) {\n                nxtr[i + 1][j] = -1;\n            } else {\n                nxtr[i + 1][j] = nxtr[i][nxtr[i][j]];\n                sumr[i + 1][j] = sumr[i][j] + sumr[i][nxtr[i][j]];\n            }\n            if (nxtl[i][j] == -1) {\n                nxtl[i + 1][j] = -1;\n            } else {\n                nxtl[i + 1][j] = nxtl[i][nxtl[i][j]];\n                suml[i + 1][j] = suml[i][j] + suml[i][nxtl[i][j]];\n            }\n        }\n    }\n\n    int Q;\n    cin >> Q;\n\n    rep(i, Q) {\n        int l, r;\n        cin >> l >> r;\n        --l, --r;\n        int p = l, q = r;\n        ll sr = l, sl = r;\n        int cnt = 0;\n        per(j, L) {\n            if (nxtr[j][p] != -1 && nxtr[j][p] <= r) {\n                sr += sumr[j][p];\n                p = nxtr[j][p];\n                sl += suml[j][q];\n                q = nxtl[j][q];\n                cnt |= 1 << j;\n            }\n        }\n        cnt++;\n        cout << sl - sr + cnt << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll X[202020];\nint Q;\nint L,R;\nint le[21][202020];\nint ri[21][202020];\nll LS[21][202020];\nll RS[21][202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>X[i+1];\n\tX[0]=-1LL<<60;\n\tX[N+1]=1LL<<60;\n\tfor(i=1;i<=N;i++) {\n\t\tri[0][i]=lower_bound(X,X+N+2,X[i]+K)-X;\n\t\tle[0][i]=lower_bound(X,X+N+2,X[i]-K+1)-X-1;\n\t\tLS[0][i]=le[0][i];\n\t\tRS[0][i]=ri[0][i];\n\t}\n\t\n\tle[0][0]=0;\n\tri[0][N+1]=N+1;\n\tFOR(j,20) {\n\t\tfor(i=0;i<=N+1;i++) {\n\t\t\tle[j+1][i]=le[j][le[j][i]];\n\t\t\tri[j+1][i]=ri[j][ri[j][i]];\n\t\t\tLS[j+1][i]=LS[j][i]+LS[j][le[j][i]];\n\t\t\tRS[j+1][i]=RS[j][i]+RS[j][ri[j][i]];\n\t\t}\n\t}\n\t\n\t\n\tcin>>Q;\n\tFOR(i,Q) {\n\t\tcin>>L>>R;\n\t\tll dif=R-L+1;\n\t\tx=L,y=R;\n\t\tfor(j=19;j>=0;j--) {\n\t\t\tif(ri[j][x]<=R) {\n\t\t\t\tdif+=LS[j][y]-RS[j][x]+(1<<j);\n\t\t\t\tx=ri[j][x];\n\t\t\t\ty=le[j][y];\n\t\t\t}\n\t\t}\n\t\tcout<<dif<<endl;\n\t}\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n//#pragma GCC target(\"avx,avx2\")\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n\n//# include <x86intrin.h>\n# include <bits/stdc++.h>\n\n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate<typename T> using ordered_set = tree <T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid setIO(string s = \"\") {\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9; \nconst int N = 6e5+5;                                         \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n \nint rnd (int l, int r) {\n\treturn uniform_int_distribution<int> (l, r)(gen);\n}\n\nint ans[N];\nint d[N];\nint same[N];\nint from[N];\nint x[N];\nint parCnt[N];\nint n, k;\nstruct BinLift {\n\tint up[18][N];\n\tint f(int x, int lim) {\n\t\tint res = 1;\n\t\tfor (int i = 17; ~i; --i) {\n\t\t\t//cout << up[i][x] << ' ' << x << '\\n';\n\t\t\tif(up[i][x] > lim && x > lim) {\n\t\t\t\tx = up[i][x];\n\t\t\t\tres += (1<<i);\n\t\t\t}\n\t\t\t\n\t\t\tif(up[i][x] < lim && x < lim) {\n\t\t\t\tx = up[i][x];\n\t\t\t\tres += (1<<i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\n\t\treturn res;\n\t}\n\n\tint climb (int x, int k) {\n\t\tfor (int i = 17; ~i; --i) if(k&(1<<i))\n\t\t\tx = up[i][x];\n\t\treturn x;\n\t}\n\tvoid build() {\n\t\tfor (int j = 1; j < 18; ++j) {\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tif(up[j][i-1] == n+1) up[j][i] = n+1;\n\t\t\t\telse up[j][i] = up[j-1][up[j-1][i]];\n\t\t\t}\n\t\t}\n\t}\n} A, B;\n\nint main () {\n\tSpeedForce;\n\t\n\tcin >> n >> k;\n\tint j = 0;\n\tfrom[0] = -1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> x[i];\n\t\twhile(x[i] - x[j+1] >= k) ++j;\n\t\tfrom[i] = j;\n\t\td[i] = d[j] + 1;\n\t\tans[i] = ans[j] + same[j];\n\t\tif(d[i] == d[i-1]) same[i] = same[i-1];\n\t\t++same[i];\n\t\tif(from[i] == from[i-1])\n\t\t\tparCnt[i] = parCnt[i-1];\n\t\t++parCnt[i];\n\t//\tcout << \"here: \"<< i << ' ' << j << ' ' << ans[j] << ' ' << same[j] << '\\n';\n\t\t\n\t\tA.up[0][i] = j;\n\t}\n\t//exit(0);\n\t\n\tj = n+1;\n\t\n\tfor (int i = n; i >= 1; --i) {\n\t\twhile(x[j-1] - x[i] >= k) --j;\n\t\tB.up[0][i] = j;\n\t}\n\t\n\tA.build();\n\tB.build();\n\t\n\tint q;\n\tcin >> q;\n\t\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint now = A.f(r, l-1);\n\t\t\n\t\tint cl = lb(x+l, x+n+1, x[r]-k+1)-x-1, cr = r;\n\t\twhile(cl + 1 < cr) {\n\t\t\tint md = (cl+cr)>>1;\n\t\t\tif(A.f(md, l-1) == now)\n\t\t\t\tcr = md;\n\t\t\telse\n\t\t\t\tcl = md;\n\t\t}\n\t\tint res = r - cl;\n\t\tif(now == 1) {\n\t\t\tcout << res << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tif(now == 2) {\n\t\t\tcout << res + from[r] - l + 1 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tint par = A.climb(r, now-2);\n\t\tres += from[par]-l+1;\n\t\t\n\t\tcl = from[par], cr = par;\n\t\twhile(cl + 1 < cr) {\n\t\t\tint md = (cl+cr)>>1;\n\t\t\tif(from[md] >= l)\n\t\t\t\tcr = md;\n\t\t\telse\n\t\t\t\tcl = md;\n\t\t}\n\t\tres += par-cl;\n\t\t\n\t\tcout << res << '\\n';\n\t}\n\t\n\treturn Accepted;\n}\n\n// B...a\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[200005];\nint r1[19][200005],r2[19][200005];\nint l1[19][200005],l2[19][200005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n,k,q;\t\n\tread(n,k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tint nex=n+1;\n\tfor(int i=n;i;--i){\n\t\twhile(a[nex-1]-a[i]>=k){\n\t\t\t--nex;\n\t\t}\t\n\t\tr1[0][i]=nex;\n\t\tr2[0][i]=i;\n\t}\n\tfor(int i=0;i<=18;++i)r1[i][n+1]=n+1;\n\tnex=0;\n\tfor(int i=1;i<=n;++i){\n\t\twhile(a[i]-a[nex+1]>=k){\n\t\t\t++nex;\n\t\t}\t\n\t\tl1[0][i]=nex;\n\t\tl2[0][i]=i;\n\t}\n\tfor(int i=1;i<=18;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tr1[i][j]=r1[i-1][r1[i-1][j]];\n\t\t\tl1[i][j]=l1[i-1][l1[i-1][j]];\n\t\t\tr2[i][j]=r2[i-1][j]+r2[i-1][r1[i-1][j]];\n\t\t\tl2[i][j]=l2[i-1][j]+l2[i-1][l1[i-1][j]];\n\t\t}\t\n\t}\n\tread(q);\n\tfor(;q;--q){\n\t\tint l,r;\t\n\t\tread(l,r);\n\t\tint s=0;\n\t\tint xr=r;\n\t\tfor(int i=18;~i;--i)if(r1[i][l]<=xr){\n\t\t\ts+=(1<<i);\n\t\t\ts-=r2[i][l];\n\t\t\ts+=l2[i][r];\n\t\t\tl=r1[i][l];\n\t\t\tr=l1[i][r];\n\t\t}\n\t\ts+=r-l+1;\n\t\t\n\t\twrite(s,'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n#define cauto const auto\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\ntemplate<class A,class B> pair<A,B> operator+(const pair<A,B> &p,const pair<A,B> &q){ return {p.X+q.X,p.Y+q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator+=(pair<A,B> &p,const pair<C,D> &q){ p.X+=q.X; p.Y+=q.Y; return p;}\ntemplate<class A,class B> pair<A,B> operator-(const pair<A,B> &p,const pair<A,B> &q){ return {p.X-q.X,p.Y-q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator-=(pair<A,B> &p,const pair<C,D> &q){ p.X-=q.X; p.Y-=q.Y; return p;}\ntemplate<class A,class B> istream& operator>>(istream &is, pair<A,B> &p){ is>>p.X>>p.Y; return is;}\ntemplate<class T=ll> T read(){ T re; cin>>re; return move(re);}\ntemplate<class T=ll> T read(const T &dec){ T re; cin>>re; return re-dec;}\ntemplate<class T=ll> vector<T> readV(const int sz){ vector<T> re(sz); for(auto &x:re) x=read<T>(); return move(re);}\ntemplate<class T=ll> vector<T> readV(const int sz, const T &dec){ vector<T> re(sz); for(auto &x:re) x=read<T>(dec); return move(re);}\nvv<int> readG(const int &n,const int &m){ vv<int> g(n); rep(_,m){ cauto a=read<int>(1),b=read<int>(1); g[a].pb(b); g[b].pb(a);} return move(g);}\nvv<int> readG(const int &n){ return readG(n,n-1);}\nconst ll MOD=1e9+7; //998244353\n\npll toR[212345][22];\npll toL[212345][22];\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tcauto n=read();\n\tcauto t=read();\n\tcauto xs=readV(n);\n\tcauto q=read();\n\tcauto qs=readV<pii>(q,{1,1});\n\tvector<ll> sum(n+1);\n\trep(i,n){\n\t\tcauto r=lower_bound(all(xs),xs[i]+t)-xs.begin();\n\t\tcauto l=upper_bound(all(xs),xs[i]-t)-xs.begin()-1;\n\t\tout(i,l,r,1);\n\t\ttoR[i][0]={r,r};\n\t\ttoL[i][0]={l,l+1};\n\t}\n\trep(d,20)rep(v,n){\n\t\tif(cauto [w,s]=toR[v][d]; w<n){\n\t\t\ttoR[v][d+1]=toR[w][d];\n\t\t\ttoR[v][d+1].Y+=s;\n\t\t}else{\n\t\t\ttoR[v][d+1]={n,s};\n\t\t}\n\t\tif(cauto [w,s]=toL[v][d]; w>=0){\n\t\t\ttoL[v][d+1]=toL[w][d];\n\t\t\ttoL[v][d+1].Y+=s;\n\t\t}else{\n\t\t\ttoL[v][d+1]={-1,s};\n\t\t}\n\t}\n\tfor(cauto [l,r]:qs){\n\t\tout(l,r,1);\n\t\tll re=r-(l-1);\n\t\t{\n\t\t\tll cur=l;\n\t\t\trrep(d,20)if(cauto [v,s]=toR[cur][d]; v<=r){\n\t\t\t\tout(d,cur,v,s,1);\n\t\t\t\tcur=v;\n\t\t\t\tre-=s;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tll cur=r;\n\t\t\trrep(d,20)if(cauto [v,s]=toL[cur][d]; v>=l){\n\t\t\t\tout(d,cur,v,s,1);\n\t\t\t\tcur=v;\n\t\t\t\tre+=s;\n\t\t\t}\n\t\t}\n\t\tcout<<re NL;\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL K;\nLL X[200011];\n\nconst int LOG = 18;\nint Right[LOG][200011];\nint RightCnt[LOG][200011];\nLL RightSum[LOG][200011];\n\nint Left[LOG][200011];\nint LeftCnt[LOG][200011];\nLL LeftSum[LOG][200011];\n\nvoid MAIN() {\n    scanf(\"%d%lld\", &N, &K);\n    REP (i, N) scanf(\"%lld\", X+i);\n\n    for (int i=0, j=0; i<N; i++) {\n\twhile (j < N && X[j] - X[i] < K) j++;\n\tRight[0][i] = j;\n\tRightCnt[0][i] = j - i;\n\tRightSum[0][i] = j - i;\n    }\n\n    Right[0][N] = N;\n    REP (t, LOG-1) {\n\tREP (i, N+1) {\n\t    int s = Right[t][i];\n\t    Right[t+1][i] = Right[t][s];\n\t    RightCnt[t+1][i] = RightCnt[t][i] + RightCnt[t][s];\n\t    RightSum[t+1][i] = RightSum[t][i] + RightSum[t][s] + (RightCnt[t][s] << t);\n\t}\n    }\n\n    for (int i=N-1, j=N-1; i>=0; i--) {\n\twhile (j >= 0 && X[i] - X[j] < K) j--;\n\tLeft[0][i] = j;\n\tLeftCnt[0][i] = i - j;\n\tLeftSum[0][i] = i - j;\n    }\n    REP (t, LOG-1) {\n\tREP (i, N) {\n\t    int s = Left[t][i];\n\t    if (s == -1) {\n\t\tLeft[t+1][i] = -1;\n\t\tLeftCnt[t+1][i] = LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][i];\n\t    } else {\n\t\tLeft[t+1][i] = Left[t][s];\n\t\tLeftCnt[t+1][i] = LeftCnt[t][s] + LeftCnt[t][i];\n\t\tLeftSum[t+1][i] = LeftSum[t][s] + LeftSum[t][i] + (LeftCnt[t][i] << t);\n\t    }\n\t}\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n    REP ($, Q) {\n\tint L, R;\n\tscanf(\"%d%d\", &L, &R);\n\tL--;\n\n\tLL ans = 0;\n\t{\n\t    int cur = L;\n\t    int mult = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Right[t][cur];\n\t\tif (s <= R) {\n\t\t    sum += RightSum[t][cur] + RightCnt[t][cur] * mult;\n\t\t    mult += 1<<t;\n\t\t    cur = s;\n\t\t}\n\t    }\n\t    sum += (R - cur) * (mult + 1);\n\n\t    ans += sum;\n\t}\n\n\t{\n\t    int cur = R-1;\n\t    LL cnt = 0;\n\t    LL sum = 0;\n\t    for (int t=LOG; t--;) {\n\t\tint s = Left[t][cur];\n\t\tif (L <= s) {\n\t\t    sum += LeftSum[t][cur] + cnt * (1LL<<t);\n\t\t    cnt += LeftCnt[t][cur];\n\t\t    cur = s;\n\t\t}\n\t    }\n\n\t    ans -= sum;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n// #define endl '\\n'\n\nvector<int> zf(string s) {\n    int n = (int)s.size();\n    vector<int> z(n);\n    int l = 0, r = 0;\n    z[0] = 0;\n    for (int i = 1; i < n; i++) {\n        if (i <= r)\n            z[i] = min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[i+z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] - 1 > r) {\n            l = i; r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n\nvector<int> pf(string s) {\n    int n = (int)s.size();\n    vector<int> p(n);\n    p[0] = 0;\n    for (int i = 1; i < n; i++) {\n        p[i] = p[i - 1];\n        while (p[i] && s[p[i]] != s[i]) {\n            p[i] = p[p[i] - 1];\n        }\n        if (s[p[i]] == s[i]) p[i]++;\n    }\n    return p;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k; cin >> n >> k;\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n    vector<int> nx(n), pr(n);\n    for (int i = 0; i < n; i++) {\n        int nxv = x[i] + k;\n        nx[i] = lower_bound(x.begin(), x.end(), nxv) - x.begin();\n        int prv = x[i] - k;\n        pr[i] = upper_bound(x.begin(), x.end(), prv) - x.begin() - 1;\n        // cout << i << \"   \" << nx[i] << \" \" << pr[i] << endl;\n    }\n    int lg = 18;\n    vector<vector<int>> lup(lg, vector<int>(n)), ldw(lg, vector<int>(n)), vup(lg, vector<int>(n)), vdw(lg, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        lup[0][i] = nx[i];\n        if (lup[0][i] != n) {\n            vup[0][i] = nx[i] - 1;\n        }\n        ldw[0][i] = pr[i];\n        if (ldw[0][i] != -1) {\n            vdw[0][i] = pr[i];\n        }\n    }\n    for (int i = 1; i < lg; i++) {\n        // cout << i << \" : \";\n        for (int j = 0; j < n; j++) {\n            // cout << \"(\" << lup[i - 1][j] << \", \" << vup[i - 1][j] << \")  \";\n            if (lup[i - 1][j] == n) {\n                lup[i][j] = n;\n                continue;\n            }\n            lup[i][j] = lup[i - 1][lup[i - 1][j]];\n            vup[i][j] = vup[i - 1][lup[i - 1][j]] + vup[i - 1][j];\n        }\n    // cout << \";   \";\n        for (int j = 0; j < n; j++) {\n            // cout << \"(\" << ldw[i - 1][j] << \", \" << vdw[i - 1][j] << \")  \";\n            if (ldw[i - 1][j] == -1) {\n                ldw[i][j] = -1;\n                continue;\n            }\n            ldw[i][j] = ldw[i - 1][ldw[i - 1][j]];\n            vdw[i][j] = vdw[i - 1][ldw[i - 1][j]] + vdw[i - 1][j];\n        }\n        // cout << endl;\n    }\n    int q; cin >> q;\n    while (q--) {\n        int l, r; cin >> l >> r; l--; r--;\n        int val = -l + 1;\n        int pos = l;\n        for (int i = lg - 1; i >= 0; i--) {\n            if (lup[i][pos] <= r) {\n                val -= vup[i][pos];\n                pos = lup[i][pos];\n                // cout << \"(\" << i << \", \" <<  pos << \"); \";\n            }\n        }\n        // cout << endl;\n        val += r;\n        pos = r;\n        for (int i = lg - 1; i >= 0; i--) {\n            if (ldw[i][pos] >= l) {\n                val += vdw[i][pos];\n                pos = ldw[i][pos];\n                // cout << \"(\" << i << \", \" <<  pos << \"); \";\n            }\n        }\n        // cout << endl;\n        cout << val << endl;\n\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint a[N];\nint n, d;\nll b[LOG][N][2];\nll c[LOG][N][2];\n\nll solveL(int l, int r) {\n\tll ans = 0;\n\tint len = 0;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (b[k][l][0] <= r) {\n\t\t\tlen += 1 << k;\n\t\t\tans += b[k][l][1];\n\t\t\tl = b[k][l][0];\n\t\t}\n\t}\n//\teprintf(\"len = %d\\n\", len + 1);\n\treturn ans + l;\n}\nll solveR(int l, int r) {\n\tll ans = 0;\n\tint len = 0;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (c[k][r][0] >= l) {\n\t\t\tlen += 1 << k;\n\t\t\tans += c[k][r][1];\n\t\t\tr = c[k][r][0];\n\t\t}\n\t}\n//\teprintf(\"len = %d\\n\", len + 1);\n\treturn ans + r + 1;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &d);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\n\tint p = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile(p <= n && a[p] - a[i] < d) p++;\n\t\t//eprintf(\"%d %d\\n\", i, p);\n\t\tb[0][i][0] = p;\n\t\tb[0][i][1] = i;\n\t}\n\tb[0][n + 1][0] = n + 1;\n\n\tfor (int k = 0; k < LOG - 1; k++) {\n\t\tfor (int i = 1; i <= n + 1; i++) {\n\t\t\tint v = b[k][i][0];\n\t\t\tb[k + 1][i][0] = b[k][v][0];\n\t\t\tb[k + 1][i][1] = b[k][i][1] + b[k][v][1];\n\t\t}\n\t}\n\n\tp = n;\n\tfor (int i = n; i >= 1; i--) {\n\t\twhile(p > 0 && a[i] - a[p] < d) p--;\n\t\t//eprintf(\"%d %d\\n\", i, p);\n\t\tc[0][i][0] = p;\n\t\tc[0][i][1] = i + 1;\n\t}\n\tc[0][0][0] = 0;\n\n\tfor (int k = 0; k < LOG - 1; k++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint v = c[k][i][0];\n\t\t\tc[k + 1][i][0] = c[k][v][0];\n\t\t\tc[k + 1][i][1] = c[k][i][1] + c[k][v][1];\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tprintf(\"%lld\\n\", solveR(l, r) - solveL(l, r));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nconst int LOGN = 17;\nint n, K, a[N], pa1[LOGN][N], pa2[LOGN][N];\nlong long sum1[LOGN][N], sum2[LOGN][N];\nint main() {\n\tscanf(\"%d%d\", &n, &K);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1, j = 1; i <= n; i++) {\n\t\twhile (j <= n && a[j] - a[i] < K) j++;\n\t\tpa1[0][i] = j;\n\t\tsum1[0][i] = j;\n\t}\n\tfor (int i = 0; i < LOGN; i++) pa1[i][n + 1] = n + 1;\n\tfor (int i = 1; i < LOGN; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tpa1[i][j] = pa1[i - 1][pa1[i - 1][j]];\n\t\t\tsum1[i][j] = sum1[i - 1][j] + sum1[i - 1][pa1[i - 1][j]];\n\t\t}\n\tfor (int i = n, j = n; i >= 1; i--) {\n\t\twhile (j > 0 && a[i] - a[j] < K) j--;\n\t\tpa2[0][i] = j;\n\t\tsum2[0][i] = j;\n\t}\n\tfor (int i = 0; i < LOGN; i++) pa2[i][0] = 0;\n\tfor (int i = 1; i < LOGN; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tpa2[i][j] = pa2[i - 1][pa2[i - 1][j]];\n\t\t\tsum2[i][j] = sum2[i - 1][j] + sum2[i - 1][pa2[i - 1][j]];\n\t\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tint u = l;\n\t\tlong long s1 = l;\n\t\tint cnt = 1;\n\t\tfor (int i = LOGN - 1; i >= 0; i--) if (pa1[i][u] <= r) {\n\t\t\tcnt += (1 << i);\n\t\t\ts1 += sum1[i][u];\n\t\t\tu = pa1[i][u];\n\t\t}\n\t\tu = r;\n\t\tlong long s2 = r;\n\t\tfor (int i = LOGN - 1; i >= 0; i--) if (pa2[i][u] >= l) {\n\t\t\ts2 += sum2[i][u];\n\t\t\tu = pa2[i][u];\n\t\t}\n\t\tprintf(\"%lld\\n\", s2 - s1 + cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#ifdef BIZON\n\t#define rr(x) cerr << \"\\e[1;38;5;172m\" << #x << \"\\e[0m = \" << (x) << endl;\n#else\n\t#define rr(x)\n\t#define endl '\\n'\n#endif\n#define ALL(c) begin(c), end(c)\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nint __; \n#define in (cin>>__, (int)__)\n\n\nint main(){\n\tif(auto f=\"in.txt\"; fopen(f,\"r\") && freopen(f,\"r\",stdin));\n\tios::sync_with_stdio(0);cin.tie(0);//cout.precision(9);cout<<fixed;\n\t\n\t\n\tint n = in, D = in;\n\t\n\tvector<int> x(n);\n\tfor(auto &_ : x) cin>>_;\n\t\n\tconstexpr int L = 18;\n\tvector<array<pair<int,ll>,L>> pl(n), pr(n);\n\t\n\tfor(int i=n-1, j = n; i>=0; --i){\n\t\twhile(j-1>i && abs(x[j-1]-x[i])>=D) --j;\n\t\tpr[i][0] = {j, 0};\n\t\tfor(int l=1;l<L;++l){\n\t\t\tint k = pr[i][l-1].first;\n\t\t\tif(k==n) pr[i][l] = pr[i][l-1];\n\t\t\telse pr[i][l] = {pr[k][l-1].first, pr[k][l-1].second + pr[i][l-1].second + k};\n\t\t}\n\t}\n\t\n\tfor(int i=0, j = -1; i<n; ++i){\n\t\twhile(j+1<i && abs(x[j+1]-x[i])>=D) ++j;\n\t\tpl[i][0] = {j, 0};\n\t\tfor(int l=1;l<L;++l){\n\t\t\tint k = pl[i][l-1].first;\n\t\t\tif(k==-1) pl[i][l] = pl[i][l-1];\n\t\t\telse pl[i][l] = {pl[k][l-1].first, pl[k][l-1].second + pl[i][l-1].second + k};\n\t\t}\n\t}\n\t\n\t\n\tint m = in;\n\twhile(m--){\n\t\tint l = in-1, r = in-1;\n\t\t\n\t\tint fr = l, cr = 1;\n\t\tll sr = 0;\n\t\tfor(int k=L-1; k>=0; --k) if(pr[fr][k].first<=r) \n\t\t\tsr+=fr+pr[fr][k].second, fr = pr[fr][k].first, cr+=1<<k;\n\t\tsr+=fr;\n\t\t\n\t\t\n\t\tint fl = r, cl = 1;\n\t\tll sl = 0;\n\t\tfor(int k=L-1; k>=0; --k) if(pl[fl][k].first>=l) \n\t\t\tsl+=fl+pl[fl][k].second, fl = pl[fl][k].first, cl+=1<<k;\n\t\tsl+=fl;\n\t\t\n\t\t//cout<<cl<<' '<<cr<<endl;\n\t\tassert(cl==cr);\n\t\t\n\t\tll res = cl + sl - sr;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, k, q;\nvector<long long> x, rx;\nvector<vector<long long>> memo, rmemo, sum, rsum;\n\nint main() {\n  cin >> n >> k;\n  x.resize(n);\n  for (auto &p : x) cin >> p;\n  rx = x;\n  reverse(rx.begin(), rx.end());\n  for (auto &p : rx) p = -p;\n  auto calcmemo = [](vector<long long> &v) {\n    vector<vector<long long>> res(30, vector<long long>(n + 1, n));\n    for (int i = 0; i < n; ++i)\n      res[0][i] = lower_bound(v.begin(), v.end(), v[i] + k) - v.begin();\n    for (int i = 1; i < 30; ++i)\n      for (int j = 0; j < n; ++j) res[i][j] = res[i - 1][res[i - 1][j]];\n    return res;\n  };\n  auto calcsum = [](vector<vector<long long>> &v, bool reversed = 0) {\n    vector<vector<long long>> res(30, vector<long long>(n + 1, 0));\n    if (reversed)\n      for (int i = 1; i <= n; ++i) res[0][i] = v[0][i];\n    else\n      for (int i = 0; i < n; ++i) res[0][i] = v[0][i] * (v[0][i] != n);\n    for (int i = 1; i < 30; ++i)\n      for (int j = 0; j <= n; ++j)\n        res[i][j] = res[i - 1][j] + res[i - 1][v[i - 1][j]];\n    return res;\n  };\n  memo = calcmemo(x);\n  rmemo = calcmemo(rx);\n  for (auto &v : rmemo) {\n    reverse(v.begin(), v.end());\n    for (auto &p : v) p = n - p;\n  }\n  sum = calcsum(memo);\n  rsum = calcsum(rmemo, 1);\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    long long x, y, z, now = 0;\n    cin >> x >> y;\n    --x;\n    // x\n    z = x;\n    for (int j = 29; j >= 0; --j)\n      if (memo[j][z] < y) {\n        now -= sum[j][z];\n        z = memo[j][z];\n      }\n    // y\n    z = y;\n    for (int j = 29; j >= 0; --j)\n      if (x < rmemo[j][z]) {\n        now += rsum[j][z];\n        z = rmemo[j][z];\n      }\n    cout << now + y - x << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass DKeepDistances {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, k; cin >> n >> k;\n      vector<int> x(n);\n      rep(i, n) {\n        cin >> x[i];\n      }\n\n      vector<vector<int>> next(20, vector<int>(n, n));\n      vector<vector<ll>> dp(20, vector<ll>(n, 0));\n      int j=1;\n      for(int i=0; i<n; i++) {\n        while(j < n && x[j] - x[i] < k) {\n          j++;\n        }\n        next[0][i] = j;\n        dp[0][i] = j;\n      }\n\n      vector<vector<int>> next2(20, vector<int>(n, -1));\n      vector<vector<ll>> dp2(20, vector<ll>(n, 0));\n      j=n-2;\n      for(int i=n-1; i>=0; i--) {\n        while(j >= 0 && x[i] - x[j] < k) {\n          j--;\n        }\n        next2[0][i] = j;\n        dp2[0][i] = j;\n      }\n\n      for(int r=1; r<20; r++) {\n        for(int i=0; i<n; i++) {\n          if (next[r-1][i] == n) {\n            next[r][i] = n;\n          } else {\n            next[r][i] = next[r-1][next[r-1][i]];\n            dp[r][i] = dp[r-1][i] + dp[r-1][next[r-1][i]];\n          }\n        }\n      }\n\n      for(int r=1; r<20; r++) {\n        for(int i=0; i<n; i++) {\n          if (next2[r-1][i] == -1) {\n            next2[r][i] = -1;\n          } else {\n            next2[r][i] = next2[r-1][next2[r-1][i]];\n            dp2[r][i] = dp2[r-1][i] + dp2[r-1][next2[r-1][i]];\n          }\n        }\n      }\n\n      int q; cin >> q;\n      rep(_, q) {\n        int l, r; cin >> l >> r;\n        l--; r--;\n        ll lcnt = l;\n        int now = l;\n        int cnt = 1;\n        for(int p=19; p>=0; p--) {\n          if (next[p][now] <= r) {\n            lcnt += dp[p][now];\n            now = next[p][now];\n            cnt += (1<<p);\n          }\n        }\n        //debug(_, lcnt);\n        now = r;\n        ll rcnt = r;\n        for(int p=19; p>=0; p--) {\n          if (next2[p][now] >= l) {\n            rcnt += dp2[p][now];\n            now = next2[p][now];\n          }\n        }\n        //debug(_, rcnt);\n        cout << rcnt-lcnt+cnt << '\\n';\n      }\n    }\n};\n\nsigned main() {\n  DKeepDistances solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint n,k,fa[20][N],q,i,l[N],r[N],x[N],j;\nlong long ans[N],faf[20][N];\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x[i]);\n\tscanf(\"%d\",&q);\n\tfor(i=1;i<=q;++i)\n\t\tscanf(\"%d %d\",&l[i],&r[i]);\n\tx[0]=-k-1;\n\tx[n+1]=x[n]+k+1;\n\tfor(i=n;i>=1;--i)\n\t{\n\t\tfa[0][i]=upper_bound(x+1,x+1+n,x[i]-k)-x-1;\n\t\tfaf[0][i]=i;\n\t}\n\tfor(i=1;i<20;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tfa[i][j]=fa[i-1][fa[i-1][j]];\n\t\t\tfaf[i][j]=faf[i-1][j]+faf[i-1][fa[i-1][j]];\n\t\t}\n\tfor(i=1;i<=q;++i)\n\t{\n\t\tint p=r[i];\n\t\tfor(j=19;j>=0;--j)\n\t\t\tif(fa[j][p]>=l[i])\n\t\t\t{\n\t\t\t\tans[i]+=faf[j][p];\n\t\t\t\tp=fa[j][p];\n\t\t\t}\n\t\tans[i]+=faf[0][p];\n\t}\n\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfa[0][i]=lower_bound(x+1,x+2+n,x[i]+k)-x;\n\t\tfaf[0][i]=i-1;\n\t}\n\tfa[0][n+1]=n+1;\n\tfor(i=1;i<20;++i)\n\t\tfor(j=1;j<=n+1;++j)\n\t\t{\n\t\t\tfa[i][j]=fa[i-1][fa[i-1][j]];\n\t\t\tfaf[i][j]=faf[i-1][j]+faf[i-1][fa[i-1][j]];\n\t\t}\n\tfor(i=1;i<=q;++i)\n\t{\n\t\tint p=l[i];\n\t\tfor(j=19;j>=0;--j)\n\t\t\tif(fa[j][p]<=r[i])\n\t\t\t{\n\t\t\t\tans[i]-=faf[j][p];\n\t\t\t\tp=fa[j][p];\n\t\t\t}\n\t\tans[i]-=faf[0][p];\n\t}\n\tfor(i=1;i<=q;++i)\n\t\tprintf(\"%lld\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntemplate<class T> bool chmin(T& a,T b){if(a>b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a<b) {a = b; return true;} return false;}\n#define all(x) (x).begin(),(x).end()\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\n\nint main(){\n    int N,K;\n    cin >> N >> K;\n    vec<int> X(N);\n    for(auto& x:X) cin >> x;\n    int M = 20;\n    vvec<ll> left(M,vec<ll>(N,-1)),left_val = left;\n    vvec<ll> right(M,vec<ll>(N,N)),right_val = right;\n    for(int i=0;i<N;i++){\n        int id = lower_bound(all(X),X[i]+K)-X.begin();\n        right[0][i] = id;\n        right_val[0][i] = id;\n        id = upper_bound(all(X),X[i]-K)-X.begin();\n        id--;\n        left[0][i] = id;\n        left_val[0][i] = id;\n    }\n    for(int k=0;k+1<M;k++) for(int i=0;i<N;i++){\n        int ne = right[k][i];\n        if(ne!=N){\n            right[k+1][i] = right[k][ne];\n            right_val[k+1][i] = right_val[k][i]+right_val[k][ne];\n        }\n        ne = left[k][i];\n        if(ne!=-1){\n            left[k+1][i] = left[k][ne];\n            left_val[k+1][i] = left_val[k][i]+left_val[k][ne];\n        }\n    }\n\n    auto solve = [&](int l,int r){\n        ll a = l;\n        int now = l;\n        int cnt = 1;\n        for(int k=M-1;k>=0;k--){\n            if(right[k][now]<=r){\n                cnt += 1<<k;\n                a += right_val[k][now];\n                now = right[k][now];\n            }\n        }\n        ll b = r;\n        now = r;\n        for(int k=M-1;k>=0;k--){\n            if(left[k][now]>=l){\n                b += left_val[k][now];\n                now = left[k][now];\n            }\n        }\n        cout << b-a+cnt << \"\\n\";\n    };\n\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int l,r;\n        cin >> l >> r;\n        solve(l-1,r-1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n#define pb push_back\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, n) for (int i = 0; i < (int)(n); ++ i)\n\nconst int mxn = 2e5 + 5;\nint n, K, q;\nint x[mxn];\nint l[mxn], r[mxn];\nint idl[mxn], idr[mxn];\nint mx[mxn];\nll sum[mxn];\nint jmp[mxn][20];\nll s[mxn][20];\n\nbool cmpl(int a, int b) {\n\treturn l[a] > l[b];\n}\n\nbool cmpr(int a, int b) {\n\treturn r[a] < r[b];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &K);\n\trep(i, n) scanf(\"%d\", &x[i]);\n\tscanf(\"%d\", &q);\n\trep(i, q) {\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t\t-- l[i], -- r[i];\n\t\tidl[i] = idr[i] = i;\n\t}\n\tsort(idl, idl + q, cmpl);\n\tsort(idr, idr + q, cmpr);\n\tint i = 0;\n\trep(R, n) {\n\t\tjmp[R][0] = upper_bound(x, x + n, x[R] - K) - x - 1;\n\t\ts[R][0] = R + 1;\n\t\tfor (int j = 1; j < 20; ++ j) {\n\t\t\tjmp[R][j] = jmp[R][j - 1] == -1 ? -1 : jmp[jmp[R][j - 1]][j - 1];\n\t\t\ts[R][j] = s[R][j - 1] + (jmp[R][j - 1] == -1 ? 0 : s[jmp[R][j - 1]][j - 1]);\n\t\t}\n\t\twhile (i < q && r[idr[i]] == R) {\n\t\t\tint L = l[idr[i]];\n\t\t\tint cnt = 1, cur = R;\n\t\t\tfor (int j = 20 - 1; ~j; -- j) {\n\t\t\t\tif (jmp[cur][j] >= L) {\n\t\t\t\t\tcnt += 1 << j;\n\t\t\t\t\tcur = jmp[cur][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx[idr[i]] = cnt;\n\t\t\t++ i;\n\t\t}\n\t}\n\ti = 0;\n\trep(R, n) {\n\t\twhile (i < q && r[idr[i]] == R) {\n\t\t\tint L = l[idr[i]];\n\t\t\tll &S = sum[idr[i]];\n\t\t\tint cur = R;\n\t\t\tfor (int j = 20 - 1; ~j; -- j) {\n\t\t\t\tif (jmp[cur][j] >= L) {\n\t\t\t\t\tS += s[cur][j];\n\t\t\t\t\tcur = jmp[cur][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tS += cur + 1;\n\t\t\tS -= 1LL * mx[idr[i]] * L;\n\t\t\t++ i;\n\t\t}\n\t}\n\ti = 0;\n\tfor (int L = n - 1; ~L; -- L) {\n\t\tjmp[L][0] = lower_bound(x, x + n, x[L] + K) - x;\n\t\ts[L][0] = L - 1;\n\t\tfor (int j = 1; j < 20; ++ j) {\n\t\t\tjmp[L][j] = jmp[L][j - 1] == n ? n : jmp[jmp[L][j - 1]][j - 1];\n\t\t\ts[L][j] = s[L][j - 1] + (jmp[L][j - 1] == n ? 0 : s[jmp[L][j - 1]][j - 1]);\n\t\t}\n\t\twhile (i < q && l[idl[i]] == L) {\n\t\t\tint R = r[idl[i]];\n\t\t\tll &S = sum[idl[i]];\n\t\t\tint cur = L;\n\t\t\tfor (int j = 20 - 1; ~j; -- j) {\n\t\t\t\tif (jmp[cur][j] <= R) {\n\t\t\t\t\tS -= s[cur][j];\n\t\t\t\t\tcur = jmp[cur][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tS -= cur - 1;\n\t\t\tS += 1LL * mx[idl[i]] * R;\n\t\t\t++ i;\n\t\t}\n\t}\n\trep(i, q) {\n\t\tll ans = sum[i] - (r[i] - l[i] + 1) - 1LL * (mx[i] - 1) * (r[i] - l[i] + 1);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nll binary_search(\n    ll lo, ll hi, function<bool(ll)> is_ok,\n    bool maximize\n){\n    while(lo < hi){\n        if(maximize){\n            const ll mid = (lo + hi + 1) / 2;\n            if(is_ok(mid)){\n                lo = mid;\n            }else{\n                hi = mid - 1;\n            }\n        }else{\n            ll mid = (lo + hi - 1) / 2;\n            if(is_ok(mid)){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }\n        }\n    }\n    return lo;\n}\n\ntemplate<typename S, S op(S, S)>\nstruct Doubling {\n    vector<vector<S>> v;\n\n    Doubling(const vector<S>& step1, ll p){\n        const auto n = step1.size();\n        v.resize(p);\n        v.at(0) = step1;\n        for(ll i = 1; i < p; ++i){\n            v.at(i).resize(n);\n            for(ll j = 0; j < n; ++j){\n                const auto& x = v.at(i - 1).at(j);\n                const auto& y = v.at(i - 1).at(x.index);\n                v.at(i).at(j) = op(x, y);\n            }\n        }\n    }\n\n    S query(S init, ll nstep){\n        S ret = init;\n        REP(i, v.size()){\n            if((nstep >> i) & 1){\n                ret = op(ret, v.at(i).at(ret.index));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct S { ll index_sum, is_ok, index; };\nS op(S x, S y){\n    return S{\n        x.index_sum + y.index_sum,\n        y.is_ok,\n        y.index\n    };\n}\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(n);\n    REP(i, n){ cin >> x.at(i); }\n\n    vector<S> l2r_1step(n), r2l_1step(n);\n    REP(i, n){\n        const auto xi = x.at(i);\n        // to right\n        ll ridx = lower_bound(ALL(x), xi + k) - x.begin();\n        if(ridx >= x.size()){\n            l2r_1step.at(i) = S{0, false, i};\n        }else{\n            l2r_1step.at(i) = S{ridx, true, ridx};\n        }\n\n        // to left\n        ll lidx = upper_bound(ALL(x), xi - k) - x.begin();\n        lidx--;\n        if(lidx < 0){\n            r2l_1step.at(i) = S{0, false, i};\n        }else{\n            r2l_1step.at(i) = S{lidx, true, lidx};\n        }\n    }\n\n    Doubling<S, op> d_l2r(l2r_1step, 30), d_r2l(r2l_1step, 30);\n\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n\n        // cerr << \"i=\" << i << \", l=\" << l << \", r=\" << r << endl;\n\n        const ll num = ::binary_search(\n            0, (x.at(r) - x.at(l)) / k,\n            [&](ll m) -> bool {\n                const auto tmp = d_l2r.query(S{l, true, l}, m);\n                return tmp.is_ok && x.at(tmp.index) <= x.at(r);\n            },\n            true\n        );\n        // cerr << \"  num=\" << num << endl;\n\n        const S l2r = d_l2r.query(S{l, true, l}, num);\n        const S r2l = d_r2l.query(S{r, true, r}, num);\n        // cerr << \"  l2r={\" << l2r.index_sum << \", \" << l2r.is_ok << \", \" << l2r.index << \"}\" << endl;\n        // cerr << \"  r2l={\" << r2l.index_sum << \", \" << r2l.is_ok << \", \" << r2l.index << \"}\" << endl;\n        assert(l2r.is_ok && x.at(l2r.index) <= x.at(r));\n        assert(r2l.is_ok && x.at(r2l.index) >= x.at(l));\n\n        cout << r2l.index_sum - l2r.index_sum + num + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define REP(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n\ntemplate<class T> bool chmax(T& a,T b){ if(a < b){ a = b; return true; }else return false; }\ntemplate<class T> bool chmin(T& a,T b){ if(a > b){ a = b; return true; }else return false; }\n \nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing Pi = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vpi = vector<Pi>;\nusing vpl = vector<Pl>;\n \n#define debug(arr) cout << #arr << \" = \" << arr << '\\n'\n#define debug2(a,b) cout << \"[\" << #a << \",\" << #b << \"] = \" << \"[\" << a << \",\" << b << \"]\" << '\\n'\ntemplate<class T> ostream &operator << (ostream& out, const vector<T>& arr) {\n\tcout << \"{\"; for (int i = 0; i < arr.size(); i++)cout << (!i ? \"\" : \", \") << arr[i]; cout << \"}\";\n\treturn out;\n}\ntemplate<class T> ostream &operator << (ostream& out, const vector<vector<T> >& arr) {\n\tcout << \"{\\n\"; for (auto& vec : arr)cout << \"  \" << vec << \",\\n\"; cout << \"}\";\n\treturn out;\n}\ntemplate<class S,class T> ostream &operator << (ostream& out, const pair<S,T>& p){\n  cout << \"{\" << p.first << \",\" << p.second << \"}\" << '\\n';\n  return out;\n}\ntemplate<class T> istream &operator >> (istream& in, vector<T>& arr) {\n\tfor (auto& i : arr)cin >> i; return in;\n}\n\n/////////////////////////////////////////////////////\n\n#define maxn 200020\n#define maxlog 50\n\nlong long N,K,Q;\nll X[maxn];\nll R[maxn][maxlog],L[maxn][maxlog];\nll rsum[maxn][maxlog],lsum[maxn][maxlog];\n\nsigned main(void){\n  cin >> N >> K;\n  for (long long i = 1; i <= N; i++) {\n    cin >> X[i];\n  }\n  \n  // k steps right from x,left from x.\n  {\n    X[0] = -(1LL<<55);\n    X[N+1] = (1LL << 55);\n    // 1steps\n    long long l = 1,r = 2;\n    for(;l <= N;l++){\n      for(;r <= N+1;r++){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          R[l][0] = r;\n          break;\n        }\n      }\n    }\n    r = N,l = N-1;\n    for(;r >= 1;r--){\n      for(;l >= 0;l--){\n        //cout << l << ' ' << r << ' ' << (X[r] - (X[l]+K)) << endl;\n        if(X[l] + K <= X[r]){\n          L[r][0] = l;\n          break;\n        }\n      }\n    }\n    R[N+1][0] = N+1;\n    L[0][0] = 0;\n    // set doubling.\n    for(long long j = 1;j < maxlog;j++){\n      for(long long i = 0;i <= N+1;i++){\n        R[i][j] = R[R[i][j-1]][j-1];\n        L[i][j] = L[L[i][j-1]][j-1];\n      }\n    }\n  }\n  \n  // init distances.\n  {\n    for(long long i = 1;i <= N;i++){\n      rsum[i][0] = R[i][0];\n      lsum[i][0] = L[i][0];\n    }\n    for(long long i = 1;i <= N;i++){\n      for(long long j = 1;j < maxlog;j++){\n        rsum[i][j] = rsum[i][j-1] + rsum[R[i][j-1]][j-1];\n        lsum[i][j] = lsum[i][j-1] + lsum[L[i][j-1]][j-1];\n      }\n    }\n  }\n  cin >> Q;\n  for (long long i = 0; i < Q; i++) {\n    long long l,r;cin >> l >> r;\n    long long low = 0,high = N;\n    while(low + 1 < high){\n      long long mid = (low + high) / 2;\n      long long tmp = l;\n      for(long long j = 0;j < maxlog;j++){\n        if(mid >> j & 1){\n          tmp = R[tmp][j];\n        }\n      }\n      //debug2(mid,tmp);\n      if(tmp <= r){\n        low = mid;\n      }else{\n        high = mid;\n      }\n    }\n    ll sr = l,sl = r;\n    { // calc sr.\n      long long tmp = l;\n      for(long long j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sr += rsum[tmp][j];\n          tmp = R[tmp][j];\n        }\n      }\n    }\n    { // calc sl.\n      long long tmp = r;\n      for(long long j = 0;j < maxlog;j++){\n        if(low >> j & 1){\n          sl += lsum[tmp][j];\n          tmp = L[tmp][j];\n        }\n      }\n    }\n    cout << sl - sr + (low + 1) << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem : D - Keep Distances\n// Contest : AtCoder - ACL Contest 1\n// URL : https://atcoder.jp/contests/acl1/tasks/acl1_d\n// Memory Limit : 1024 MB\n// Time Limit : 3000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int Maxn = 2e5 + 5;\nconstexpr int LOG = 20;\n\nint n, K, q;\nint a[Maxn];\nint pre[Maxn][LOG];\nint suf[Maxn][LOG];\nint64_t pre_sum[Maxn][LOG];\nint64_t suf_sum[Maxn][LOG];\n\nint main() {\n\n  scanf(\"%d %d\", &n, &K);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    pre[i][0] = upper_bound(a + 1, a + n + 1, a[i] - K) - a - 1;\n    suf[i][0] = lower_bound(a + 1, a + n + 1, a[i] + K) - a;\n    pre_sum[i][0] = (pre[i][0] >= 1 ? pre[i][0] : 0);\n    suf_sum[i][0] = (suf[i][0] <= n ? suf[i][0] : 0);\n  }\n  for (int j = 1; j < LOG; ++j) {\n    for (int i = 1; i <= n; ++i) {\n      pre_sum[i][j] = pre_sum[i][j - 1];\n      suf_sum[i][j] = suf_sum[i][j - 1];\n      if (pre[i][j - 1] >= 1) {\n        pre[i][j] = pre[pre[i][j - 1]][j - 1];\n        pre_sum[i][j] += pre_sum[pre[i][j - 1]][j - 1];\n      }\n      else {\n        pre[i][j] = 0;\n      }\n      if (suf[i][j - 1] <= n) {\n        suf[i][j] = suf[suf[i][j - 1]][j - 1];\n        suf_sum[i][j] += suf_sum[suf[i][j - 1]][j - 1];\n      }\n      else {\n        suf[i][j] = n + 1;\n      }\n    }\n  }\n  \n  scanf(\"%d\", &q);\n  while (q--) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    int64_t left_sum = 0;\n    int64_t right_sum = 0;\n    int len = 1;\n    {\n      int lg = LOG - 1, pos = r;\n      while (lg >= 0) {\n        if (pre[pos][lg] >= l) {\n          left_sum += pre_sum[pos][lg];\n          pos = pre[pos][lg];\n          len += (1 << lg);\n        }\n        --lg;\n      }\n    }\n    {\n      int lg = LOG - 1, pos = l;\n      while (lg >= 0) {\n        if (suf[pos][lg] <= r) {\n          right_sum += suf_sum[pos][lg];\n          pos = suf[pos][lg];\n        }\n        --lg;\n      }\n    }\n    printf(\"%lld\\n\", left_sum - right_sum + len + r - l);\n  }\n  \n  return 0;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N,K;\nint X[2<<17];\nint dL[20][2<<17],dLs[20][2<<17];\nint dR[20][2<<17],dRs[20][2<<17];\nint Q;\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>X[i];\n\tint l=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\twhile(l<N&&X[l]<X[i]+K)l++;\n\t\tdL[0][i]=l;\n\t\tdLs[0][i]=i;\n\t}\n\tint r=N-1;\n\tfor(int i=N;i--;)\n\t{\n\t\twhile(r>=0&&X[r]>X[i]-K)r--;\n\t\tdR[0][i]=r;\n\t\tdRs[0][i]=i;\n\t}\n\tfor(int k=0;k<19;k++)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(dL[k][i]==N)\n\t\t\t{\n\t\t\t\tdL[k+1][i]=N;\n\t\t\t\tdLs[k+1][i]=dLs[k][i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdL[k+1][i]=dL[k][dL[k][i]];\n\t\t\t\tdLs[k+1][i]=dLs[k][i]+dLs[k][dL[k][i]];\n\t\t\t}\n\t\t\tif(dR[k][i]==-1)\n\t\t\t{\n\t\t\t\tdR[k+1][i]=-1;\n\t\t\t\tdRs[k+1][i]=dRs[k][i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdR[k+1][i]=dR[k][dR[k][i]];\n\t\t\t\tdRs[k+1][i]=dRs[k][i]+dRs[k][dR[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\tcin>>Q;\n\tfor(;Q--;)\n\t{\n\t\tint L,R;cin>>L>>R;\n\t\tL--;\n\t\tint cnt=1,now=L;\n\t\tint ans=0;\n\t\tfor(int k=20;k--;)\n\t\t{\n\t\t\tif(dL[k][now]<R)\n\t\t\t{\n\t\t\t\tcnt+=1<<k;\n\t\t\t\tans-=dLs[k][now];\n\t\t\t\tnow=dL[k][now];\n\t\t\t}\n\t\t}\n\t\tans-=now;\n\t\tnow=R-1;\n\t\tfor(int k=20;k--;)\n\t\t{\n\t\t\tif(dR[k][now]>=L)\n\t\t\t{\n\t\t\t\tans+=dRs[k][now];\n\t\t\t\tnow=dR[k][now];\n\t\t\t}\n\t\t}\n\t\tans+=now;\n\t\tcout<<ans+cnt<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst double pi = acos(-1.0);\nconst double EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    int X[N];\n    rep(i, N) cin >> X[i];\n    int nl[N][20], nr[N][20];\n    ll sl[N][20], sr[N][20];\n    int ptr = 0;\n    rep(i, N){\n        while(ptr < N && X[ptr] < X[i]+K) ptr++;\n        nl[i][0] = ptr, sl[i][0] = i;\n    }\n    ptr = N-1;\n    rep3(i, N-1, 0){\n        while(ptr >= 0 && X[ptr] > X[i]-K) ptr--;\n        nr[i][0] = ptr, sr[i][0] = i+1;\n    }\n    rep2(j, 1, 19){\n        rep(i, N){\n            if(nl[i][j-1] == N){\n                nl[i][j] = N;\n                sl[i][j] = sl[i][j-1];\n            }\n            else{\n                nl[i][j] = nl[nl[i][j-1]][j-1];\n                sl[i][j] = sl[i][j-1]+sl[nl[i][j-1]][j-1];\n            }\n        }\n        rep(i, N){\n            if(nr[i][j-1] == -1){\n                nr[i][j] = -1;\n                sr[i][j] = sr[i][j-1];\n            }\n            else{\n                nr[i][j] = nr[nr[i][j-1]][j-1];\n                sr[i][j] = sr[i][j-1]+sr[nr[i][j-1]][j-1];\n            }\n        }\n    }\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int l, r; cin >> l >> r; l--, r--;\n        ll suml = 0, sumr = 0;\n        int pl = l, pr = r;\n        rep3(i, 19, 0){\n            if(nl[pl][i] <= r){\n                suml += sl[pl][i], pl = nl[pl][i];\n            }\n        }\n        suml += pl;\n        rep3(i, 19, 0){\n            if(nr[pr][i] >= l){\n                sumr += sr[pr][i], pr = nr[pr][i];\n            }\n        }\n        sumr += pr+1;\n        cout << sumr-suml << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\n#define int long long\nsigned main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi ans(Q);\n    vi L(Q), R(Q);\n    rep(i, Q) cin >> L[i] >> R[i];\n    rep(_, 2)\n    {\n        vv(int, nxt, 20, n + 1, n);\n        vv(int, cnt, 20, n + 1);\n        rep(i, n)\n        {\n            nxt[0][i] = lb(a, a[i] + k);\n            cnt[0][i] = nxt[0][i] - i;\n        }\n        rep(i, 19)\n        {\n            rep(j, n)\n            {\n                nxt[i + 1][j] = nxt[i][nxt[i][j]];\n                cnt[i + 1][j] = cnt[i][nxt[i][j]] + (1LL << i) * (nxt[i][j] - j) + cnt[i][j];\n            }\n        }\n        rep(ii, Q)\n        {\n            int l = L[ii], r = R[ii];\n            if (_)\n            {\n                swap(l, r);\n                l = n - l, r = n + 1 - r;\n            }\n            else\n                l--;\n            int d = r - l;\n            int m = 0;\n            int now = l;\n            rep3(i, 19, 0)\n            {\n                if (nxt[i][now] < r)\n                    m += 1 << i, now = nxt[i][now];\n            }\n            if (_)\n                ans[ii] += d * (m + 1);\n            now = l;\n            ll res = m;\n            rep(i, 20)\n            {\n                if (m & 1 << i)\n                    ans[ii] -= cnt[i][now] + (now - l) * res, res -= 1 << i, now = nxt[i][now];\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define PB push_back\n#define MP make_pair\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int maxn = 2e5 + 5;\nconst int logn = 20;\n\nint n, k, q;\nint a[maxn];\nint r[maxn][logn], l[maxn][logn];\nll lsum[maxn][logn], rsum[maxn][logn];\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tFOR(i, 0, n)\n\t\tscanf(\"%d\", a + i);\n\t\t\n\tfor(int i = 0, j = 0; i < n; ++i){\n\t\tfor(; j < n && a[j] < a[i] + k; ++j);\n\t\tr[i][0] = j;\n\t\trsum[i][0] = j;\n\t}\n\tfor(int i = n - 1, j = n - 1; i >= 0; --i){\n\t\tfor(; j >= 0 && a[j] > a[i] - k; --j);\n\t\tl[i][0] = j;\n\t\tlsum[i][0] = j;\n\t}\n\t\n\tFOR(j, 1, logn) FOR(i, 0, n){\n\t\tl[i][j] = l[i][j - 1] == -1 ? -1 : l[l[i][j - 1]][j - 1];\n\t\tr[i][j] = r[i][j - 1] == n ? n : r[r[i][j - 1]][j - 1];\n\t\tlsum[i][j] = l[i][j - 1] == -1 ? lsum[i][j - 1] : lsum[i][j - 1] + lsum[l[i][j - 1]][j - 1];\n\t\trsum[i][j] = r[i][j - 1] == n ? rsum[i][j - 1] : rsum[i][j - 1] + rsum[r[i][j - 1]][j - 1]; \n\t}\n\t\n\tscanf(\"%d\", &q);\n\tFOR(i, 0, q){\n\t\tint x, y, len = 0;\n\t\tll sumx = 0, sumy = 0;\n\t\tscanf(\"%d%d\", &x, &y); --x; --y;\n\t\tint a = x, b = y;\n\t\tfor(int i = logn - 1; i >= 0; --i){\n\t\t\tif(r[a][i] <= y){\n\t\t\t\tsumx += rsum[a][i];\n\t\t\t\ta = r[a][i];\n\t\t\t\tlen += 1 << i;\n\t\t\t}\n\t\t\tif(l[b][i] >= x){\n\t\t\t\tsumy += lsum[b][i];\n\t\t\t\tb = l[b][i];\n\t\t\t}\n\t\t}\n\t\tsumy += y;\n\t\tsumx += x;\n\t\t++len;\n\t\tprintf(\"%lld\\n\", sumy - sumx + len);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n//#pragma GCC target(\"avx,avx2\")\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n\n//# include <x86intrin.h>\n# include <bits/stdc++.h>\n\n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate<typename T> using ordered_set = tree <T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid setIO(string s = \"\") {\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9; \nconst int N = 6e5+5;                                         \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n \nint rnd (int l, int r) {\n\treturn uniform_int_distribution<int> (l, r)(gen);\n}\n\nint ans[N];\nint d[N];\nint same[N];\nint from[N];\nint x[N];\nint parCnt[N];\nint n, k;\nstruct BinLift {\n\tint up[18][N];\n\tll sum[18][N];\n\tint f(int x, int lim) {\n\t\tint res = 1;\n\t\tfor (int i = 17; ~i; --i) {\n\t\t\t//cout << up[i][x] << ' ' << x << '\\n';\n\t\t\tif(up[i][x] > lim && x > lim) {\n\t\t\t\tx = up[i][x];\n\t\t\t\tres += (1<<i);\n\t\t\t}\n\t\t}\n\t\n\t\treturn res;\n\t}\n\t\n\tll get (int x, int k) {\n\t\tll res = 0;\n\t\tfor (int i = 17; ~i; --i) if(k&(1<<i))\n\t\t\tres += sum[i][x], x = up[i][x];\n\t\treturn res;\n\t}\n\n\tint climb (int x, int k) {\n\t\tfor (int i = 17; ~i; --i) if(k&(1<<i))\n\t\t\tx = up[i][x];\n\t\treturn x;\n\t}\n\tvoid build() {\n\t\tfor (int j = 1; j < 18; ++j) {\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tint vv = up[j-1][i];\n\t\t\t\tif(vv == n+1) up[j][i] = n+1, sum[j][i] = sum[j][i-1];\n\t\t\t\telse {\n\t\t\t\t\tsum[j][i] = sum[j-1][i] + sum[j-1][vv];\n\t\t\t\t\tup[j][i] = up[j-1][vv];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} A, B;\n\nint main () {\n\tSpeedForce;\n\t\n\tcin >> n >> k;\n\tint j = 0;\n\tfrom[0] = -1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> x[i];\n\t\twhile(x[i] - x[j+1] >= k) ++j;\n\t\tfrom[i] = j;\n\t\td[i] = d[j] + 1;\n\t\tans[i] = ans[j] + same[j];\n\t\tif(d[i] == d[i-1]) same[i] = same[i-1];\n\t\t++same[i];\n\t\tif(from[i] == from[i-1])\n\t\t\tparCnt[i] = parCnt[i-1];\n\t\t++parCnt[i];\n\t\tA.sum[0][i] = i;\n\t\tA.up[0][i] = j;\n\t}\n\t\n\tj = n+1;\n\t\n\tfor (int i = n; i >= 1; --i) {\n\t\twhile(x[j-1] - x[i] >= k) --j;\n\t\tB.up[0][i] = j;\n\t\tB.sum[0][i] = i;\n\t}\n\t\n\tA.build();\n\tB.build();\n\t\n\tint q;\n\tcin >> q;\n\t\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint now = A.f(r, l-1);\n\t\t//cout << now << ' ';\n\t\t//cout << A.get(r, now) << ' ' << B.get(l, now) << '\\n';\n\t\tint res = A.get(r, now)-B.get(l, now) + now;\n\t\t\n\t\tcout << res << '\\n';\n\t}\n\t\n\treturn Accepted;\n}\n\n// B...a\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n #include<atcoder/all>\nusing namespace atcoder;\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[400100];\n                int inv[400010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n  \n\n\nint dp1[30][200020];\nint wa1[30][200020];\n\nint dp2[30][200020];\n\n\nint wa2[30][200020];\n\nvoid solve(){\nint n,k;\n\tcin>>n>>k;\n\tvector<int> ve(n);\n\t\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint g=lower_bound(ve.begin(),ve.end(),ve[i]+k)-ve.begin();\n\t\tdp1[0][i]=g;\n\t\twa1[0][i]=0;\n\t\tif(g<n)wa1[0][i]=g;\n\t//\tcout<<g<<endl;\n\t}\n\tfor(int i=1;i<30;i++)for(int j=0;j<n;j++){\n\t\tif(dp1[i-1][j]==n || dp1[i-1][dp1[i-1][j]]==n)dp1[i][j]=n,wa1[i][j]=-1;\n\t\telse {\n\t\t\tdp1[i][j]=dp1[i-1][dp1[i-1][j]];\n\t\t\twa1[i][j]=wa1[i-1][dp1[i-1][j]]+wa1[i-1][j];\n\t\t//\tcout<<i<<\" \"<<j<<\" \"<<dp1[i][j]<<endl;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\t\tint g=upper_bound(ve.begin(),ve.end(),ve[i]-k)-ve.begin();\n\t\tg--;\n\t\tdp2[0][i]=g;\n\t\twa2[0][i]=0;\n\t\tif(g>=0)wa2[0][i]=g;\n\t}\n\t\n\tfor(int i=1;i<30;i++)for(int j=0;j<n;j++){\n\t\tif(dp2[i-1][j]==-1 || dp2[i-1][dp2[i-1][j]]==n)dp2[i][j]=-1,wa2[i][j]=-1;\n\t\telse{\n\t\t\tdp2[i][j]=dp2[i-1][dp2[i-1][j]];\n\t\t\twa2[i][j]=wa2[i-1][dp2[i-1][j]]+wa2[i-1][j];\n\n\t\t}\n\t}\n\t\n\t\n\tint q;\n\tcin>>q;\n\t\n\tfor(int er=0;er<q;er++){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tl--,r--;\n\t\tint ima=l;\n\t\tint ko=0;\n\t\tint W1=l;\n\t\t\n\t\tfor(int i=29;i>=0;i--)if(dp1[i][ima]<=r){\n\t\t\tko+=(1ll<<i);\n\t\t\tW1+=wa1[i][ima];\n\t\t\tima=dp1[i][ima];\n\t\t\t\n\t\t}\n\t//\tcout<<ko<<endl;\n\t\tima=r;\n\t\tint W2=r;\n\t\tfor(int i=29;i>=0;i--)if(dp2[i][ima]>=l){\n\t\t//\tko+=(1ll<<i);\n\t\t\tW2+=wa2[i][ima];\n\t\t\tima=dp2[i][ima];\n\t\t\t\n\t\t}\n\t//\tcout<<W1<<\" \"<<W2<<endl;\n\t\tcout<<W2-W1+ko+1<<endl;\n\t}\n\n}\n\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\nint n=1;\n//\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tsolve();\n\n\t}\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#include<atcoder/all>\nusing namespace atcoder;\n\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nusing mint = modint998244353;\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\n\nint main() {\n\tll N, K;\n\tcin >> N >> K;\n\tvll x(N + 1);\n\trepn(i, N)cin >> x[i];\n\n\tvll ri(N + 2);\n\tvll lef(N + 2);\n\tri[0]=lef[0] = 0;\n\tri[N + 1]=lef[N+1] = N + 1;\n\trepn(i, N) {\n\t\tauto itr = lower_bound(++x.begin(), x.end(), x[i] + K);\n\t\tri[i] = distance(x.begin(), itr);\n\t\tauto itr2 = upper_bound(++x.begin(), x.end(), x[i] - K);\n\t\tlef[i] = distance(x.begin(), itr2) - 1;\n\n\t\t//cout << lef[i] << ri[i] << endl;\n\t}\n\n\tll P = 25;\n\tvvll dri(N + 2, vll(P, 0)), dlef(N + 2, vll(P, 0));\n\trep(i, N+2) {\n\t\tdri[i][0] = ri[i];\n\t\tdlef[i][0] = lef[i];\n\t}\n\trepn(j, P - 1) {\n\t\t//cout << j << endl;\n\t\trep(i, N+2) {\n\t\t\tdri[i][j] = dri[dri[i][j - 1]][j - 1];\n\t\t\tdlef[i][j] = dlef[dlef[i][j - 1]][j - 1];\n\t\t\t//cout << i << j << dri[i][j] << dlef[i][j] << endl;\n\t\t}\n\t}\n\n\tvvll gri(N + 1), glef(N + 1);\n\trepn(i, N) {\n\t\tif (ri[i] <= N) { gri[ri[i]].push_back(i); }\n\t\tif (lef[i] > 0) { glef[lef[i]].push_back(i); }\n\t}\n\t\n\tvll ruiri(N + 2,0), ruilef(N + 2,0);\n\trepn(i, N) {\n\t\truilef[i] = i + ruilef[lef[i]];\n\t\t\n\t\t//cout << i << \" \" << ruilef[i] << endl;\n\t}\n\tfor (ll i = N; i >= 1; i--) {\n\t\truiri[i] = i + ruiri[ri[i]];\n\t\t\n\t\t//cout << i << \" \" << ruiri[i] << endl;\n\t}\n\n\tll Q;\n\tcin >> Q;\n\trepn(q, Q) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\t\n\t\tll cnt = 0;\n\t\tll giriri = l;\n\t\tfor (ll j = P - 1; j >= 0; j--) {\n\t\t\tif (dri[giriri][j] <= r) {\n\t\t\t\tgiriri = dri[giriri][j];\n\t\t\t\tcnt += 1ull << j;\n\t\t\t}\n\t\t}\n\n\t\t//cout << giriri << cnt << endl;\n\n\t\tll girilef = r;\n\t\tfor (ll j = P - 1; j >= 0; j--) {\n\t\t\tif (dlef[girilef][j] >= l) {\n\t\t\t\tgirilef = dlef[girilef][j];\n\t\t\t}\n\t\t}\n\n\t\t//cout << girilef << endl;\n\n\t\tll ans = cnt+1;\n\t\tans += ruilef[r] - ruilef[girilef] + girilef;\n\t\tans -= ruiri[l] - ruiri[giriri] + giriri;\n\t\tcout << ans << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\n \n// hloya template v26\n \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n \n#include <bits/stdc++.h>\nusing namespace std;\n \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define sqr(x) ((x) * (x))\n \n#define ull unsigned long long\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n \nvoid bad(string mes = \"NO\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n \nmt19937_64 mt_rand(\n    chrono::system_clock::now().time_since_epoch().count()\n);\n \ntemplate<typename T1, typename T2> inline bool upmax(T1& a, T2 b) { return (a < b ? (a = b, true) : false); }\ntemplate<typename T1, typename T2> inline bool upmin(T1& a, T2 b) { return (b < a ? (a = b, true) : false); }\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n \ntemplate<typename T>\nT gcd (T a, T b) { while (b) { a %= b; swap (a, b); } return a; }\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = (int)3e5 + 3, base = 998244353;\nconst ll llinf = 2e18 + 5;\nconst int mod = 200003;\n\nint binpow (int a, int n) {\n    int res = 1;\n    while (n) {\n        if (n & 1)\n            res = 1ll * res * a % mod;\n        a = 1ll * a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// ll solve(ll n) {\n//     for (ll p = 1; p <= (ll)8e7; p++) {\n//         __int128 a = (__int128)2 * p * n;\n//         ll x = (sqrt(4 * a + 1) - 1) / 2;\n\n//         if ((__int128)x * (x + 1) / 2 % n == 0) {\n//             return x;\n//         }\n//     }\n//     throw;\n// }\n\n\nint nxt[maxn][20];\nint prv[maxn][20];\nll pn[maxn];\nll pp[maxn];\n\nint getprev(int i, int j) {\n    if (i != -1) {\n        return prv[i][j];\n    }\n    return -1;\n}\n\nint getnext(int i, int j) {\n    if (i != -1) {\n        return nxt[i][j];\n    }\n    return -1;\n}\n\nint main() {\n    // files1;\n    fast_io;\n\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> x(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        int real_prev = upper_bound(all(x), x[i] - k) - x.begin();\n        real_prev--;\n\n        prv[i][0] = real_prev;\n        for (int j = 1; j < 20; j++) {\n            prv[i][j] = getprev(prv[i][j - 1], j - 1);\n        }\n        pp[i] = i + 1;\n        if (prv[i][0] != -1) {\n            pp[i] += pp[prv[i][0]];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        int real_next = lower_bound(all(x), x[i] + k) - x.begin();\n        if (real_next == x.size()) {\n            real_next = -1;\n        }\n        nxt[i][0] = real_next;\n        for (int j = 1; j < 20; j++) {\n            nxt[i][j] = getnext(nxt[i][j - 1], j - 1);\n        }\n        pn[i] = -i;\n        if (nxt[i][0] != -1) {\n            pn[i] += pn[nxt[i][0]];\n        }\n    }\n\n    int q;\n    cin >> q;\n\n    auto evalleft = [&](int l, int r) {\n        int oldl = l;\n        for (int j = 19; j >= 0; j--) {\n            if (nxt[l][j] != -1 && nxt[l][j] <= r) {\n                l = nxt[l][j];\n            }\n        }\n        // sum from l to oldl\n        ll sum = pn[oldl];\n        l = nxt[l][0];\n        if (l != -1) {\n            sum -= pn[l];\n        }\n        return sum;\n    };\n\n\n    auto evalright = [&](int l, int r) {\n        int oldr = r;\n        for (int j = 19; j >= 0; j--) {\n            if (prv[r][j] != -1 && prv[r][j] >= l) {\n                r = prv[r][j];\n            }\n        }\n        ll sum = pp[oldr];\n        r = prv[r][0];\n        if (r != -1) {\n            sum -= pp[r];\n        }\n        return sum;\n    };\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n\n        ll sum1 = evalleft(l, r);\n        ll sum2 = evalright(l, r);\n\n        cout << sum1 + sum2 << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[19][201010], toL[19][201010];\nint totR[19][201010], totL[19][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 18, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 19) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 19) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 19) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n#include <atcoder/mincostflow>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> T;\ntypedef pair<long double , ll> Ps;\ntypedef pair<ll, bool> Pb;\ntypedef pair<ll, vector<ll>> Pd;\n\nconst ll INF = 3e18;\nconst ll fact_table = 3200008;\nlong double Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll, vector<ll>, greater<ll> > pqls;\npriority_queue <P, vector<P>, greater<P> > pqps;\n//small priority queue\n//top pop\n\nll dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nll dy[8] = {0, 1, 0, -1, 1, -1, -1, 1};\n//↓,→,↑,←\n\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n#undef endl\n#endif\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)();\n#define pc(x) cout << x << \",\";\n#define rep(i, n) for (ll i = 0; i < (n); i ++)\n\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> mat;\n\nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n\nll mypow(ll a, ll b, ll m = mod) {ll x = 1; while (b) {while (!(b & 1)) {(a *= a) %= m; b >>= 1;}(x *= a) %= m; b--;} return x;}\nvec readvec(ll read) { vec res(read); for (int i = 0; i < read; i++) { cin >> res[i]; } return res;}\nvoid YES(bool cond) { if (cond) { p(\"YES\");} else { p(\"NO\");} return;}\nvoid Yes(bool cond) { if (cond) { p(\"Yes\");} else { p(\"No\");} return;}\nvoid line() { p(\"--------------------\"); return;}\n\n/*\nll fact[fact_table + 5], rfact[fact_table + 5];\n\nvoid c3_init() {\n    fact[0] = rfact[0] = 1;\n    for (ll i = 1; i <= fact_table; i++) {\n        fact[i] = (fact[i - 1] * i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table], mod - 2, mod);\n    for (ll i = fact_table; i >= 1; i--) {\n        rfact[i - 1] = rfact[i] * i;\n        rfact[i - 1] %= mod;\n    }\n    return;\n}\nll c3(ll n, ll r) {\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n - r]) % mod;\n}\n*/\n\nstruct Timer {\n    int64_t start; const int64_t CYCLES_PER_SEC = 2800000000;\n    Timer() { reset(); }\n    void reset() { start = getCycle(); }\n    inline double get() { return (double)(getCycle() - start) / CYCLES_PER_SEC; }\n    inline int64_t getCycle() {\n        uint32_t low, high; __asm__ volatile (\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n        return ((int64_t)low) | ((int64_t)high << 32);\n    }\n};\n\nbool multicase = false;\n\nll n, k;\nll x[200005], toright[200005][65], toleft[200005][65];\nll torightvalue[200005][65], toleftvalue[200005][65];\n\nvoid precalc() {\n    set<P> st;\n    for (int i = 1; i <= n; i++) {\n        st.insert(P(x[i], i));\n    }\n\n    // 番兵\n    st.insert(P(INF, INF));\n    st.insert(P(-INF, -INF));\n\n    for (int i = 1; i <= n; i++) {\n        ll right = (*st.lower_bound(P(x[i] + k, -INF))).second;\n        toright[i][0] = right;\n        torightvalue[i][0] = (right != INF) ? i : i;\n\n        auto ite = st.lower_bound(P(x[i] - k + 1, -INF));\n        ite --;\n        ll left = (*ite).second;\n        toleft[i][0] = left;\n        toleftvalue[i][0] = (left != -INF) ? i + 1: i + 1;\n        if (left == -INF) toleft[i][0] = -INF;\n    }\n\n    for (int j = 1; j <= n; j++) {\n        for (int i = 0; i < 60; i++) {\n\n            if (toright[j][i] == INF) {\n                toright[j][i + 1] = INF;\n            } else {\n                toright[j][i + 1] = toright[toright[j][i]][i];\n                torightvalue[j][i + 1] = torightvalue[j][i] + torightvalue[toright[j][i]][i];\n            }\n\n            if (toleft[j][i] == -INF) {\n                toleft[j][i + 1] = -INF;\n            } else {\n                toleft[j][i + 1] = toleft[toleft[j][i]][i];\n                toleftvalue[j][i + 1] = toleftvalue[j][i] + toleftvalue[toleft[j][i]][i];\n            }\n        }\n    }\n\n}\n\nvoid solve() {\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i];\n    }\n    precalc();\n    ll q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        ll l, r;\n        cin >> l >> r;\n        ll il = l, ir = r;\n        ll haba = 60;\n        ll ans = 0;\n        while (true) {\n            // haba進んでも大丈夫なら進む\n            if (toleft[r][haba] >= il && toright[l][haba] <= ir) {\n                ans += toleftvalue[r][haba] - torightvalue[l][haba];\n                l = toright[l][haba];\n                r = toleft[r][haba];\n            } else {\n                if (haba == 0) {\n                    break;\n                } else {\n                    haba --;\n                }\n            }\n        }\n        /*\n        p(ans);\n        pe(l);p(r);\n        pe(toleftvalue[r][0]);\n        p(torightvalue[l][0]);\n        */\n        ans += toleftvalue[r][0] - torightvalue[l][0];\n        p(ans);\n    }\n\n    return;\n}\n\nint main() {\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    ll q, testcase = 1;\n    if (multicase) {\n        cin >> q;\n    } else {\n        q = 1;\n    }\n    while (q--) {\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n\n    // solve();\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cerr<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\nint getInt(){int x;scanf(\"%d\",&x);return x;}\ntemplate<typename T>istream& operator>>(istream&i,v(T)&v){rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v){stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const v(T)&v){if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v){return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v){return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>bool mins(T& x,const T&y){if(x>y){x=y;return true;}else return false;}\ntemplate<typename T>bool maxs(T& x,const T&y){if(x<y){x=y;return true;}else return false;}\ntemplate<typename T>ll suma(const v(T)&a){ll res(0);for(auto&&x:a)res+=x;return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\nconst int D = 18;\ntypedef v(vl) vvl;\n\n\nint n,K;\n\nstruct Db {\n  vvi d; vvl s;\n  Db(vi x):d(D,vi(n+1,n)),s(D,vl(n+1,0)) {\n    int j = n;\n    drep(i,n) {\n      while (x[i]+K <= x[j-1]) --j;\n      d[0][i] = j;\n      s[0][i] = j;\n    }\n    rep(i,D-1) {\n      rep(j,n) {\n        d[i+1][j] = d[i][d[i][j]];\n        s[i+1][j] = s[i][j]+s[i][d[i][j]];\n      }\n    }\n  }\n  int cnt;\n  ll get(int l, int r) {\n    int j = l;\n    ll res = l;\n    cnt = 1;\n    int w = 1<<D;\n    drep(i,D) {\n      w >>= 1;\n      if (d[i][j] > r) continue;\n      res += s[i][j];\n      j = d[i][j];\n      cnt += w;\n    }\n    return res;\n  }\n};\n\nint main() {\n  scanf(\"%d%d\",&n,&K);\n  vi x(n);\n  cin>>x;\n\n  Db dl(x);\n  reverse(rng(x));\n  rep(i,n) x[i] = -x[i];\n  Db dr(x);\n\n  int q;\n  scanf(\"%d\",&q);\n  rep(qi,q) {\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    --l; --r;\n    ll xr = dr.get(n-1-r,n-1-l);\n    xr = dr.cnt*ll(n-1) - xr;\n    ll ans = xr - dl.get(l,r) + dl.cnt;\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nint main() {\n    const int INF = 1e9;\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> x(n);\n    set<pair<int, int>> pos;\n    for (int i = 0; i < n; i++) {\n        cin >> x[i];\n        pos.emplace(x[i], i);\n    }\n    int d = 0;\n    while ((1 << d) < n) {\n        d++;\n    }\n    vector<vector<int>> fgo(n, vector<int>(d + 1, INF));\n    vector<vector<ll>> fsum(n, vector<ll>(d + 1, -1));\n    vector<vector<int>> bgo(n, vector<int>(d + 1, -INF));\n    vector<vector<ll>> bsum(n, vector<ll>(d + 1, -1));\n    for (int i = 0; i < n; i++) {\n        auto it = pos.lower_bound({x[i] + k, -INF});\n        if (it != pos.end()) {\n            fgo[i][0] = (*it).second;\n            fsum[i][0] = (*it).second;\n        }\n        it = pos.lower_bound({x[i] - k, INF});\n        if (it != pos.begin()) {\n            it = prev(it);\n            bgo[i][0] = (*it).second;\n            bsum[i][0] = (*it).second;\n        }\n    }\n    for (int i = 0; i <= d; i++) {\n        for(int j = 0; j < n; j++) {\n            if (!(fgo[j][i] == INF || fgo[fgo[j][i]][i] == INF)) {\n                fgo[j][i + 1] = fgo[fgo[j][i]][i];\n                fsum[j][i + 1] = fsum[j][i] + fsum[fgo[j][i]][i];\n            }\n            if (!(bgo[j][i] == -INF || bgo[bgo[j][i]][i] == -INF)) {\n                bgo[j][i + 1] = bgo[bgo[j][i]][i];\n                bsum[j][i + 1] = bsum[j][i] + bsum[bgo[j][i]][i];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        int fcur = l;\n        int bcur = r;\n        ll ftot = l;\n        ll btot = r;\n        int tot = 1;\n        for (int i = d; i >= 0; i--) {\n            if (fgo[fcur][i] <= r) {\n                ftot += fsum[fcur][i];\n                tot += (1 << i);\n                fcur = fgo[fcur][i];\n            }\n            if (bgo[bcur][i] >= l) {\n                btot += bsum[bcur][i];\n                bcur = bgo[bcur][i];\n            }\n        }\n        cout << btot - ftot + tot << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;i<(int)(n);i++)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef vector<int> Array;\n\nint l[20][202020];\nint r[20][202020];\nint dp1[20][202020];\nint dp2[20][202020];\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tREP(i, n)dp1[0][i] = l[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n\tREP(i, n)dp2[0][i] = r[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\tREP(i, 19)REP(j, n)l[i + 1][j] = l[i][min(n - 1, l[i][j])];\n\tREP(i, 19)REP(j, n)r[i + 1][j] = r[i][max(0, r[i][j])];\n\tREP(i, 19)REP(j, n)dp1[i + 1][j] = dp1[i][j] + dp1[i][l[i][j]];\n\tREP(i, 19)REP(j, n)dp2[i + 1][j] = dp2[i][j] + dp2[i][r[i][j]];\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint L, R;\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tint ans = R - L;\n\t\tint x = L, y = R - 1;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (l[i][x] < R)ans += (1 << i) - dp1[i][x], x = l[i][x];\n\t\t\tif (r[i][y] >= L)ans += dp2[i][y], y = r[i][y];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nll X[202020];\nint Q;\nint L,R;\nint le[21][202020];\nint ri[21][202020];\nint LS[21][202020];\nint RS[21][202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>X[i+1];\n\tX[0]=-1LL<<60;\n\tX[N+1]=1LL<<60;\n\tfor(i=1;i<=N;i++) {\n\t\tri[0][i]=lower_bound(X,X+N+2,X[i]+K)-X;\n\t\tle[0][i]=lower_bound(X,X+N+2,X[i]-K+1)-X-1;\n\t\tLS[0][i]=le[0][i];\n\t\tRS[0][i]=ri[0][i];\n\t}\n\t\n\tle[0][0]=0;\n\tri[0][N+1]=N+1;\n\tFOR(j,20) {\n\t\tfor(i=0;i<=N+1;i++) {\n\t\t\tle[j+1][i]=le[j][le[j][i]];\n\t\t\tri[j+1][i]=ri[j][ri[j][i]];\n\t\t\tLS[j+1][i]=LS[j][i]+LS[j][le[j][i]];\n\t\t\tRS[j+1][i]=RS[j][i]+RS[j][ri[j][i]];\n\t\t}\n\t}\n\t\n\t\n\tcin>>Q;\n\tFOR(i,Q) {\n\t\tcin>>L>>R;\n\t\tll dif=R-L+1;\n\t\tx=L,y=R;\n\t\tfor(j=19;j>=0;j--) {\n\t\t\tif(ri[j][x]<=R) {\n\t\t\t\tdif+=LS[j][y]-RS[j][x]+(1<<j);\n\t\t\t\tx=ri[j][x];\n\t\t\t\ty=le[j][y];\n\t\t\t}\n\t\t}\n\t\tcout<<dif<<endl;\n\t}\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)\n * Author: alireza_kaviani\n * Time: 2020-09-20 18:09:52\n**/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\n#define all(x)                      (x).begin(),(x).end()\n#define Sort(x)                     sort(all((x)))\n#define X                           first\n#define Y                           second\n#define sep                         ' '\n#define endl                        '\\n'\n#define SZ(x)                       ll(x.size())\n\nll poww(ll a, ll b, ll md) {\n    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));\n}\n\nconst ll MAXN = 2e5 + 10;\nconst ll LOG = 22;\nconst ll INF = 8e18;\nconst ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;\n\nint n , k , q , A[MAXN];\nll nxt[LOG][MAXN] , prv[LOG][MAXN] , nxts[LOG][MAXN] , prvs[LOG][MAXN];\n\nint main() {\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n\tcin >> n >> k;\n\tfor(int i = 1 ; i <= n ; i++)\tcin >> A[i];\n\tfor(int i = 1 , ptr = 1 ; i <= n ; i++){\n\t\twhile(ptr <= n && A[ptr] < A[i] + k)\tptr++;\n\t\tnxt[0][i] = ptr;\n\t\tnxts[0][i] = i + ptr;\n//\t\tcout << i << sep << ptr << endl;\n\t}\n\tfor(int i = n , ptr = n ; i >= 0 ; i--){\n\t\twhile(ptr >= 1 && A[ptr] > A[i] - k)\tptr--;\n\t\tprv[0][i] = ptr;\n\t\tprvs[0][i] = i + ptr;\n//\t\tcout << i << sep << ptr << endl;\n\t}\n\tnxt[0][n + 1] = n + 1;\n\tfor(int i = 1 ; i < LOG ; i++){\n\t\tfor(int j = 0 ; j < MAXN ; j++){\n\t\t\tprv[i][j] = prv[i - 1][prv[i - 1][j]];\n\t\t\tprvs[i][j] = prvs[i - 1][j] + prvs[i - 1][prv[i - 1][j]] - prv[i - 1][j];\n\t\t\tnxt[i][j] = nxt[i - 1][nxt[i - 1][j]];\n\t\t\tnxts[i][j] = nxts[i - 1][j] + nxts[i - 1][nxt[i - 1][j]] - nxt[i - 1][j];\n\t\t\tif(1 <= j && j <= n){\n//\t\t\t\tcout << i << sep << j << sep << nxt[i][j] << sep << prv[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcin >> q;\n\twhile(q--){\n\t\tint L , R , x;\n\t\tcin >> L >> R;\n\t\tll ans = R - L + 1;\n\t\tx = L;\n\t\tfor(int i = LOG - 1 ; i >= 0 ; i--){\n//\t\t\tcout << L << sep << nxt[i][L] << endl;\n\t\t\tif(nxt[i][L] <= R){\n\t\t\t\tans += L - nxts[i][L];\n\t\t\t\tL = nxt[i][L];\n//\t\t\t\tcout << L << sep << ans << endl;\n\t\t\t}\n\t\t}\n//\t\tcout << endl;\n\t\tL = x;\n\t\tfor(int i = LOG - 1 ; i >= 0 ; i--){\n\t\t\tif(prv[i][R] >= L){\n\t\t\t\tans += prvs[i][R] - R;\n\t\t\t\tR = prv[i][R];\n\t\t\t\tans += (1 << i);\n//\t\t\t\tcout << R << sep << ans << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nll binary_search(\n    ll lo, ll hi, function<bool(ll)> is_ok,\n    bool maximize\n){\n    while(lo < hi){\n        if(maximize){\n            const ll mid = (lo + hi + 1) / 2;\n            if(is_ok(mid)){\n                lo = mid;\n            }else{\n                hi = mid - 1;\n            }\n        }else{\n            ll mid = (lo + hi - 1) / 2;\n            if(is_ok(mid)){\n                hi = mid;\n            }else{\n                lo = mid + 1;\n            }\n        }\n    }\n    return lo;\n}\n\ntemplate<typename S, S op(S, S)>\nstruct Doubling {\n    vector<vector<S>> v;\n\n    Doubling(const vector<S>& step1, ll p){\n        const auto n = step1.size();\n        v.resize(p);\n        v.at(0) = step1;\n        for(ll i = 1; i < p; ++i){\n            v.at(i).resize(n);\n            for(ll j = 0; j < n; ++j){\n                const auto& x = v.at(i - 1).at(j);\n                const auto& y = v.at(i - 1).at(x.index);\n                v.at(i).at(j) = op(x, y);\n            }\n        }\n    }\n\n    S query(S init, ll nstep){\n        S ret = init;\n        REP(i, v.size()){\n            if((nstep >> i) & 1){\n                ret = op(ret, v.at(i).at(ret.index));\n            }\n        }\n        return ret;\n    }\n};\n\nstruct S { ll index_sum, is_ok, index; };\nS op(S x, S y){\n    return S{\n        x.index_sum + y.index_sum,\n        y.is_ok,\n        y.index\n    };\n}\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(n);\n    REP(i, n){ cin >> x.at(i); }\n\n    vector<S> l2r_1step(n), r2l_1step(n);\n    REP(i, n){\n        const auto xi = x.at(i);\n        // to right\n        ll ridx = lower_bound(ALL(x), xi + k) - x.begin();\n        if(ridx >= x.size()){\n            l2r_1step.at(i) = S{0, false, i};\n        }else{\n            l2r_1step.at(i) = S{ridx, true, ridx};\n        }\n\n        // to left\n        ll lidx = upper_bound(ALL(x), xi - k) - x.begin();\n        lidx--;\n        if(lidx < 0){\n            r2l_1step.at(i) = S{0, false, i};\n        }else{\n            r2l_1step.at(i) = S{lidx, true, lidx};\n        }\n    }\n\n    Doubling<S, op> d_l2r(l2r_1step, 30), d_r2l(r2l_1step, 30);\n\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n\n        // cerr << \"i=\" << i << \", l=\" << l << \", r=\" << r << endl;\n\n        const ll num = ::binary_search(\n            0, n,\n            [&](ll m) -> bool {\n                const auto tmp = d_l2r.query(S{l, true, l}, m);\n                return tmp.is_ok && x.at(tmp.index) <= x.at(r);\n            },\n            true\n        );\n        // cerr << \"  num=\" << num << endl;\n\n        const S l2r = d_l2r.query(S{l, true, l}, num);\n        const S r2l = d_r2l.query(S{r, true, r}, num);\n        // cerr << \"  l2r={\" << l2r.index_sum << \", \" << l2r.is_ok << \", \" << l2r.index << \"}\" << endl;\n        // cerr << \"  r2l={\" << r2l.index_sum << \", \" << r2l.is_ok << \", \" << r2l.index << \"}\" << endl;\n        assert(l2r.is_ok && x.at(l2r.index) <= x.at(r));\n        assert(r2l.is_ok && x.at(r2l.index) >= x.at(l));\n\n        cout << r2l.index_sum - l2r.index_sum + num + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\n#define int long long\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,k,q,a[200010],st1[21][200010],st2[21][200010],st3[21][200010],st4[21][200010];\nint nxt[200010],pre[200010];\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tint pos=lower_bound(a+1,a+n+1,a[i]+k)-a;\n\t\tif(pos>n) pos=-1;\n\t\tnxt[i]=pos;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint pos=upper_bound(a+1,a+n+1,a[i]-k)-a-1;\n\t\tif(pos<1) pos=-1;\n\t\tpre[i]=pos;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tst1[0][i]=i;st2[0][i]=i;\n\t\tst3[0][i]=i;st4[0][i]=i;\n\t}\n\tfor(int i=1;i<=20;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(st1[i-1][j]==-1||nxt[st1[i-1][j]]==-1) st1[i][j]=-1;\n\t\t\telse{\n\t\t\t\tst1[i][j]=st1[i-1][nxt[st1[i-1][j]]];\n\t\t\t\tif(st1[i][j]!=-1){\n\t\t\t\t\tst3[i][j]=st3[i-1][j]+st3[i-1][nxt[st1[i-1][j]]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=20;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(st2[i-1][j]==-1||pre[st2[i-1][j]]==-1) st2[i][j]=-1;\n\t\t\telse{\n\t\t\t\tst2[i][j]=st2[i-1][pre[st2[i-1][j]]];\n\t\t\t\tif(st2[i][j]!=-1){\n\t\t\t\t\tst4[i][j]=st4[i-1][j]+st4[i-1][pre[st2[i-1][j]]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tint l,r;cin>>l>>r;\n\t\tint len=0,now=l;\n\t\tfor(int i=20;i>=0;i--){\n\t\t\tif(now!=-1&&st1[i][now]!=-1&&st1[i][now]<=r){\n\t\t\t\tnow=nxt[st1[i][now]];\n\t\t\t\tlen+=(1<<i);\n\t\t\t}\n\t\t}\n\t\tint sum1=0,sum2=0;\n\t\tnow=l;\n\t\tfor(int i=20;i>=0;i--){\n\t\t\tif(now!=-1&&st1[i][now]!=-1&&st1[i][now]<=r){\n\t\t\t\tsum1+=st3[i][now];\n\t\t\t\tnow=nxt[st1[i][now]];\n\t\t\t}\n\t\t}\n\t\tnow=r;\n\t\tfor(int i=20;i>=0;i--){\n\t\t\tif(now!=-1&&st2[i][now]!=-1&&st2[i][now]>=l){\n\t\t\t\tsum2+=st4[i][now];\n\t\t\t\tnow=pre[st2[i][now]];\n\t\t\t}\n\t\t}\n\t\tcout<<sum2-sum1+len<<'\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace atcoder;\n\nconstexpr int N = 2e5;\n\nint fl[N][20], fr[N][20];\nint64_t sl[N][20], sr[N][20];\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::memset(fl, -1, sizeof(fl));\n    std::memset(fr, -1, sizeof(fr));\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> x(n);\n    for (int i = 0; i < n; ++i)\n        std::cin >> x[i];\n    \n    for (int i = n - 1, j = i; x[i] - x[0] >= k; --i) {\n        while (x[i] - x[j] < k)\n            --j;\n        fl[i][0] = j;\n        sl[i][0] = j;\n    }\n    for (int i = 0, j = 0; x[n - 1] - x[i] >= k; ++i) {\n        while (x[j] - x[i] < k)\n            ++j;\n        fr[i][0] = j;\n        sr[i][0] = -j;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < 20; ++j) {\n            int p = fl[i][j - 1];\n            if (p == -1)\n                break;\n            fl[i][j] = fl[p][j - 1];\n            sl[i][j] = sl[i][j - 1] + sl[p][j - 1];\n        }\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = 1; j < 20; ++j) {\n            int p = fr[i][j - 1];\n            if (p == -1)\n                break;\n            fr[i][j] = fr[p][j - 1];\n            sr[i][j] = sr[i][j - 1] + sr[p][j - 1];\n        }\n    }\n    \n    int q;\n    std::cin >> q;\n    while (q--) {\n        int l, r;\n        std::cin >> l >> r;\n        --l;\n        --r;\n        int x = l, t = 1;\n        int64_t ans = 0;\n        for (int i = 19; i >= 0; --i) {\n            if (fr[x][i] != -1 && fr[x][i] <= r) {\n                ans += sr[x][i];\n                x = fr[x][i];\n                t += 1 << i;\n            }\n        }\n        ans += 1ll * (r + 1) * t - l;\n        x = r;\n        for (int i = 19; i >= 0; --i) {\n            if (fl[x][i] != -1 && fl[x][i] >= l) {\n                ans += sl[x][i];\n                x = fl[x][i];\n            }\n        }\n        ans += r - 1ll * (l - 1) * t;\n        ans -= 1ll * t * (r - l + 1);\n        std::cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <atcoder/all>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace atcoder;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000000;\nconst int K = 20;\n//const int mod = 998244353;\n\nusing mint = modint998244353;\n\nmint p[N], s[N];\npair <int, int> l[K][N], r[K][N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n, k;\n    cin >> n >> k;\n    vector <int> x(n + 2);\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    x[0] = -2e9;\n    x[n + 1] = 2e9;\n    for (int i = 1; i <= n; i++){\n        int v = (int)(lower_bound(x.begin(), x.end(), k + x[i]) - x.begin());\n        r[0][i] = {v, -v};\n        v = (int)(upper_bound(x.begin(), x.end(), -k + x[i]) - x.begin());\n        l[0][i] = {v - 1, v - 1};\n    }\n    r[0][n + 1] = {n + 1, 0};\n    for (int i = 1; i < K; i++){\n        for (int j = 1; j <= n + 1; j++){\n            auto y = r[i - 1][j];\n            r[i][j].F = r[i - 1][y.F].F;\n            r[i][j].S = r[i - 1][y.F].S + y.S;\n            y = l[i - 1][j];\n            l[i][j].F = l[i - 1][y.F].F;\n            l[i][j].S = l[i - 1][y.F].S + y.S;\n        }\n    }\n    int q;\n    cin >> q;\n    while(q--){\n        int ls, rs;\n        cin >> ls >> rs;\n        int ans = rs - ls;\n        int v = ls;\n        int z = 1;\n        for (int i = K - 1; i >= 0; i--){\n            if (x[r[i][v].F] <= x[rs]){\n                z += (1 << i);\n                ans += r[i][v].S;\n                v = r[i][v].F;\n            }\n        }\n        v = rs;\n        int f = 1;\n        for (int i = K - 1; i >= 0; i--){\n            if (x[l[i][v].F] >=  x[ls]){\n                f += (1 << i);\n                ans += l[i][v].S;\n                v = l[i][v].F;\n            }\n        }\n        ans += z;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\n\n// #LIB#\n\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\n#define double long double\n#define rep(i, n) for (long long i = 0; i < (n); ++i)\n#define repr(i, a, b) for (auto i = (a); i < (b); ++i)\n#define itr(x, c) for (auto&& x : (c))\n#define updatemax(t, v) ((t) = std::max((t), (v)))\n#define updatemin(t, v) ((t) = std::min((t), (v)))\n#ifdef ONLINE_JUDGE\n#define endl _endl\nconst char _endl = (cin.tie(0), cout.tie(0), ios::sync_with_stdio(0), cout.precision(16), '\\n');\n#endif\n\nint main() {\n  ll n, k, q;\n  cin >> n >> k;\n  vector<ll> x(n);\n  rep(i, n) cin >> x[i];\n  const ll PM = 24;\n  vector<vector<ll>> x_l(n + 1, vector<ll>(PM, 0)), x_r(n + 1, vector<ll>(PM, n));\n  vector<vector<ll>> x_ls(n + 1, vector<ll>(PM)), x_rs(n + 1, vector<ll>(PM));\n  rep(i, n) {\n    x_l[i + 1][0] = upper_bound(x.begin(), x.end(), x[i] - k) - x.begin();\n    x_r[i][0] = lower_bound(x.begin(), x.end(), x[i] + k) - x.begin();\n    x_ls[i + 1][0] = i;\n    x_rs[i][0] = i;\n  }\n  rep(i, PM - 1) {\n    rep(j, n + 1) {\n      x_l[j][i + 1] = x_l[x_l[j][i]][i];\n      x_r[j][i + 1] = x_r[x_r[j][i]][i];\n      x_ls[j][i + 1] = x_ls[j][i] + x_ls[x_l[j][i]][i];\n      x_rs[j][i + 1] = x_rs[j][i] + x_rs[x_r[j][i]][i];\n    }\n  }\n  auto D = [](const vector<vector<ll>>& v, const vector<vector<ll>>& vs, int p, int n) {\n    ll sum = 0;\n    int i = 0;\n    while (n > 0) {\n      if (n & 1) {\n        sum += vs[p][i];\n        p = v[p][i];\n      }\n      n >>= 1;\n      ++i;\n    }\n    return pair(p, sum);\n  };\n  cin >> q;\n  rep(qi, q) {\n    ll l, r;\n    cin >> l >> r;\n    --l;\n    ll low = 0, high = n;\n    while (high - low > 1) {\n      ll middle = (low + high) / 2;\n      bool cond = D(x_r, x_rs, l, middle).first < r;\n      (cond ? low : high) = middle;\n    }\n    ll len = low + 1;\n    ll sumR = D(x_r, x_rs, l, len).second;\n    ll sumL = D(x_l, x_ls, r, len).second;\n    cout << sumL - sumR + len << endl;\n  }\n  // rep(i, n) cout << x_rs[i][0] << \" \";\n  // cout << endl;\n  // rep(i, n) cout << x_rs[i][1] << \" \";\n  // cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\ntypedef array<ll, 2> ary;\npair<vvl, vvl> calc(ll n, ll k, vector<ll>& a){\n  vvl nxt = VV(n, 30, -1, ll);\n  vvl s = VV(n, 30, 0, ll);\n  for(int i=0;i<30;i++){\n    if(i==0){\n      for(int j=0;j<n;j++){\n        auto idx = lower_bound(all(a), a[j]+k) - a.begin();//k先のidx\n        if(j==n-1) idx = n;\n        nxt[j][0] = idx;\n        if(idx!=n) s[j][0] = idx;\n      }\n    }else{\n      for(int j=0;j<n;j++){\n        nxt[j][i] = (nxt[j][i-1]==n?n:nxt[nxt[j][i-1]][i-1]);\n        s[j][i] = s[j][i-1] + (nxt[j][i-1]==n?0:s[nxt[j][i-1]][i-1]);\n      }\n    }\n  }\n  return {nxt, s};\n}\n\nint main(){\n  ll n, k;scanf(\"%lld %lld\", &n, &k);\n  vll a(n);\n  re(i, n) scanf(\"%lld\", &a[i]);\n  vll b = a;\n  reverse(all(b));\n  ll INF = 100000000000;\n  for(int i=0;i<n;i++) b[i] = INF - b[i];\n\n  vvl nxt, nxt2, s, s2;\n  auto tmp = calc(n, k, a);\n  nxt = tmp.first;\n  s = tmp.second;\n  tmp = calc(n, k, b);\n  nxt2 = tmp.first;\n  s2 = tmp.second;\n\n  auto f = [&](ll l, ll r){//操作回数\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt[now]), r) - nxt[now].begin() - 1;\n      if(a[nxt[now][idx]] - a[now] < k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s[now][idx];\n      now = nxt[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n\n  auto g = [&](ll l, ll r){\n    l = n - 1 - l, r = n - 1 - r;\n    swap(l, r);\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt2[now]), r) - nxt2[now].begin() - 1;\n      if(b[nxt2[now][idx]] - b[now] < k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s2[now][idx];\n      now = nxt2[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n\n  ll q;std::cin >> q;\n  for(int i=0;i<q;i++){\n    ll x, y;scanf(\"%lld %lld\", &x, &y);\n    x--, y--;\n    auto h = f(x, y);\n    auto u = g(x, y);\n    ll cnt = h[0] + 1;\n    cnt += u[1] - h[1];\n    u[1] = (n-1)*u[0] - u[1];\n    ll ret = u[0] + u[1] - h[1];\n    printf(\"%lld\\n\", ret);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nconst int N = 200000;\n\nint canL[N], canR[N];\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll n, k;\n    cin >> n >> k;\n    vector<int> x(n + 1);\n    forn(i, n) cin >> x[i + 1];\n    vector<vector<int> > goR(20, vector<int>(n + 2));\n    vector<vector<int> > goL(20, vector<int>(n + 2));\n    for (int i = 1, j = 1; i <= n; i++)\n    {\n        while (j <= n && x[j] - x[i] < k)\n        {\n            j++;\n        }\n        goR[0][i] = j;\n    }\n    goR[0][0] = 1;\n    goR[0][n + 1] = n + 1;\n    for (int i = n, j = n; i >= 1; i--)\n    {\n        while (j >= 1 && x[i] - x[j] < k)\n        {\n            j--;\n        }\n        goL[0][i] = j;\n    }\n    goL[0][0] = 0;\n    goL[0][n + 1] = n;\n    for (int j = 1; j < 20; j++)\n    {\n        for (int i = 0; i <= n + 1; i++)\n        {\n            goR[j][i] = goR[j - 1][goR[j - 1][i]];\n            goL[j][i] = goL[j - 1][goL[j - 1][i]];\n        }\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int l, r;\n        cin >> l >> r;\n        int sz = 1;\n        int w = l;\n        for (int j = 19; j >= 0; j--)\n        {\n            int nxt = goR[j][w];\n            if (nxt <= r)\n            {\n                w = nxt;\n                sz += (1 << j);\n            }\n        }\n        //cout << \"Size of good set = \" << sz << \"\\n\";\n        int ans = 0;\n        for (int i = l; i <= r; i++)\n        {\n            canL[i] = 0;\n            int pr = goL[0][i];\n            if (pr < l) continue;\n            canL[i] = canL[pr] + 1;\n        }\n        for (int i = r; i >= l; i--)\n        {\n            canR[i] = 0;\n            int nx = goR[0][i];\n            if (nx > r) continue;\n            canR[i] = canR[nx] + 1;\n        }\n        for (int i = l; i <= r; i++)\n        {\n            if (canL[i] + canR[i] + 1 == sz)\n                ans++;\n        }\n        cout << ans << \"\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\nll n, k;\nconst int D = 18;\n\nstruct Db {\n    vector<vector<ll>> d, s;\n    Db(vector<ll> x) {\n        d.resize(n+1, vector<ll>(D, n));\n        s.resize(n+1, vector<ll>(D, 0));\n        int jj = n;\n        rrep(i, n) {\n            while (x[i]+k<=x[jj-1]) jj--;\n            d[i][0] = jj;\n            s[i][0] = jj;\n        }\n        rep(j, D) {\n            if (j==0) continue;\n            rep(i, n) {\n                d[i][j] = d[d[i][j-1]][j-1];\n                s[i][j] = s[i][j-1] + s[d[i][j-1]][j-1];\n            }\n        }\n        //debug(d[0][0]);\n    }\n    ll cnt = 0;\n    ll get(int l, int r) {\n        ll res = l;\n        cnt = 1;\n        rrep(i, D) {\n            ll now = 1<<i;\n            if (d[l][i]>r) continue;\n            res += s[l][i];\n            l = d[l][i];\n            cnt += now;\n            //debug(res);\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    \n    cin >> n >> k;\n    vector<ll> x(n);\n    rep(i, n) cin >> x[i];\n    Db db1(x);\n    \n    vector<ll> y(n);\n    rep(i, n) {\n        y[i] = -x[n-1-i];\n    }\n    \n    Db db2(y);\n    \n    ll q;\n    cin >> q;\n    rep(qi, q) {\n        ll l, r;\n        cin >> l >> r;\n        l--; r--;\n        ll sum1 = db1.get(l, r);\n        //debug(sum1);\n        ll ans = db1.cnt;\n        //debug(db1.cnt);\n        ll sum2 = db2.get(n-1-r, n-1-l);\n        //debug(sum2);\n        //debug(db2.cnt);\n        sum2 = db2.cnt*(n-1) - sum2;\n        ans += (sum2-sum1);\n        pr(ans);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#include <atcoder/all>\n#define popcount __builtin_popcount\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; ll k;\n    cin>>n>>k;\n    int x[200020];\n    for(int i=0; i<n; i++){\n        cin>>x[i];\n    }\n    int nx[20][200020], nxr[20][200020];\n    ll sl[20][200020], sr[20][200020];\n    nx[0][n]=n;\n    nxr[0][0]=0;\n    for(int i=0; i<n; i++){\n        nx[0][i]=lower_bound(x, x+n, x[i]+k)-x;\n        sl[0][i]=nx[0][i];\n        nxr[0][i+1]=upper_bound(x, x+n, x[i]-k)-x;\n        sr[0][i+1]=nxr[0][i+1];\n    }\n    for(int i=1; i<20; i++){\n        for(int j=0; j<=n; j++){\n            nx[i][j]=nx[i-1][nx[i-1][j]];\n            sl[i][j]=sl[i-1][j]+sl[i-1][nx[i-1][j]];\n            nxr[i][j]=nxr[i-1][nxr[i-1][j]];\n            sr[i][j]=sr[i-1][j]+sr[i-1][nxr[i-1][j]];\n        }\n    }\n    int q; cin>>q;\n    while(q--){\n        int l, r; cin>>l>>r;\n        l--; r--;\n        if(l==r){\n            cout<<1<<endl;\n            continue;\n        }\n        ll suml=0, sumr=0;\n        int c=0;\n        int l1=l;\n        for(int i=19; i>=0; i--){\n            if(nx[i][l1]<=r){\n                c+=(1<<i);\n                suml+=sl[i][l1];\n                l1=nx[i][l1];\n            }\n        }\n        int r1=r+1;\n        for(int i=19; i>=0; i--){\n            if(nxr[i][r1]>=l){\n                sumr+=sr[i][r1];\n                r1=nxr[i][r1];\n            }\n        }\n        cout<<sumr-suml+r+1-l<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\nusing namespace std;\n\ntypedef long long int ll;\nconstexpr int kN = int(2E5 + 10), LOGN = 20, kInf = int(2E9 + 10);\n\nint x[kN], nxtl[kN][LOGN], nxtr[kN][LOGN];\nll pl[kN][LOGN], pr[kN][LOGN];\n\nint main() {\n\tint n, k, q, l, r, nl, nr;\n\tll ans;\n\tqueue<int> qu;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &x[i]);\n\tx[0] = -kInf, x[++n] = kInf;\n\tfor (int i = 0; i <= n; i++) {\n\t\twhile (!qu.empty()) {\n\t\t\tif (x[i] - x[qu.front()] >= k) {\n\t\t\t\tnxtl[qu.front()][0] = i;\n\t\t\t\tqu.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tqu.push(i);\n\t}\n\twhile (!qu.empty()) {\n\t\tnxtl[qu.front()][0] = n;\n\t\tqu.pop();\n\t}\n\n\tfor (int i = n; i >= 0; i--) {\n\t\twhile (!qu.empty()) {\n\t\t\tif (x[qu.front()] - x[i] >= k) {\n\t\t\t\tnxtr[qu.front()][0] = i;\n\t\t\t\tqu.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tqu.push(i);\n\t}\n\twhile (!qu.empty()) {\n\t\tnxtr[qu.front()][0] = 0;\n\t\tqu.pop();\n\t}\n\n\tfor (int i = 1; i < LOGN; i++) for (int j = 0; j <= n; j++) nxtl[j][i] = nxtl[nxtl[j][i - 1]][i - 1];\n\tfor (int i = 1; i < LOGN; i++) for (int j = 0; j <= n; j++) nxtr[j][i] = nxtr[nxtr[j][i - 1]][i - 1];\n\tfor (int i = 0; i <= n; i++) pl[i][0] = nxtl[i][0];\n\tfor (int i = 0; i <= n; i++) pr[i][0] = nxtr[i][0];\n\tfor (int i = 0; i <= n; i++) if (pl[i][0] == n) pl[i][0] = 0;\n\n\n\tfor (int i = 1; i < LOGN; i++) for (int j = 0; j <= n; j++) pl[j][i] = pl[j][i - 1] + pl[nxtl[j][i - 1]][i - 1];\n\tfor (int i = 1; i < LOGN; i++) for (int j = 0; j <= n; j++) pr[j][i] = pr[j][i - 1] + pr[nxtr[j][i - 1]][i - 1];\n\tscanf(\"%d\", &q);\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tnl = l, nr = r;\n\t\tans = r - l + 1;\n\t\tfor (int j = LOGN - 1; j >= 0; j--) {\n\t\t\tif (nxtl[l][j] <= r) {\n\t\t\t\tans -= pl[l][j];\n\t\t\t\tl = nxtl[l][j];\n\t\t\t\tans += 1 << j;\n\t\t\t}\n\t\t}\n\t\tl = nl, r = nr;\n\t\tfor (int j = LOGN - 1; j >= 0; j--) {\n\t\t\tif (nxtr[r][j] >= l) {\n\t\t\t\tans += pr[r][j];\n\t\t\t\tr = nxtr[r][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\n#define int long long\nsigned main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    INT(Q);\n    vi ans(Q);\n    vi L(Q), R(Q);\n    rep(i, Q) cin >> L[i] >> R[i];\n    rep(_, 2)\n    {\n        vv(int, nxt, 20, n + 1, n);\n        vv(int, cnt, 20, n + 1);\n        rep(i, n)\n        {\n            nxt[0][i] = lb(a, a[i] + k);\n            cnt[0][i] = nxt[0][i];\n        }\n        rep(i, 19)\n        {\n            rep(j, n)\n            {\n                nxt[i + 1][j] = nxt[i][nxt[i][j]];\n                cnt[i + 1][j] = cnt[i][nxt[i][j]] + cnt[i][j];\n            }\n        }\n        rep(ii, Q)\n        {\n            int l = L[ii], r = R[ii];\n            if (_)\n            {\n                swap(l, r);\n                l = n - l, r = n + 1 - r;\n            }\n            else\n                l--;\n            int d = r - l;\n            int m = 0;\n            int now = l;\n            rep3(i, 19, 0)\n            {\n                if (nxt[i][now] < r)\n                    m += 1 << i, now = nxt[i][now];\n            }\n            ans[ii] += (r - 1) * (m + 1);\n            now = l;\n            ll rem = 0;\n            rep(i, 20)\n            {\n                if (m & 1 << i)\n                {\n                    ans[ii] -= cnt[i][now], now = nxt[i][now];\n                }\n            }\n        }\n        reverse(all(a));\n        rep(i, n) a[i] = -a[i];\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\n#define rrep(i, n) for(ll i = n - 1; i > -1; i--)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define fi first\n#define se second\ntemplate <class X> void print(X x) { cout << x << endl; }\n#define in(A, n)                                                                                                       \\\n    rep(i, n) {                                                                                                        \\\n        cin >> f;                                                                                                      \\\n        A.push_back(f);                                                                                                \\\n    }\n\nvoid print(vl x) {\n    for(ll i : x) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\nconst ll INF = (1LL << 61) - 1;\nconst ll MOD = 1000000007 /*998244353*/;\nconst ll MAX_N = 500010;\nll a, b, c, d, e, f, h, x, y, z, p, q, n, t, r, k, w, l, ans, i, j, u, v, m;\nll codeforces = 1;\nstring S, T;\nvector<vl> g(MAX_N);\nvl A, B, C;\nll NEXT[MAX_N][20], NEXT2[MAX_N][20];\nvoid input() {\n    cin >> n >> k;\n    rep(i, n) {\n        cin >> x;\n        A.pb(x);\n    }\n    cin >> q;\n}\nvoid solve() {\n    rep(i, n) {\n        a = lower_bound(all(A), A[i] + k) - A.begin();\n        B.pb(a);\n    }\n    rep(i, n) {\n        a = upper_bound(all(A), A[i] - k) - A.begin() - 1;\n        C.pb(a);\n    }\n\n    rep(i, 20) {\n        if(i == 0) {\n            rep(j, n) { NEXT[j][i] = B[j]; }\n        } else {\n            rep(j, n) {\n                if(NEXT[j][i - 1] == n)\n                    NEXT[j][i] = n;\n                else\n                    NEXT[j][i] = NEXT[NEXT[j][i - 1]][i - 1];\n            }\n        }\n    }\n\n    rep(i, 20) {\n        if(i == 0) {\n            rep(j, n) { NEXT2[j][i] = C[j]; }\n        } else {\n            rep(j, n) {\n                if(NEXT2[j][i - 1] == -1)\n                    NEXT2[j][i] = -1;\n                else\n                    NEXT2[j][i] = NEXT2[NEXT2[j][i - 1]][i - 1];\n            }\n        }\n    }\n\n    vl cost1(n + 1, 0), cost2(n + 1, 0);\n\n    for(ll i = n; i > -1; i--) {\n        if(i == n)\n            cost1[i] = 0;\n        else {\n            cost1[i] = cost1[NEXT[i][0]] + i;\n        }\n    }\n\n    for(ll i = -1; i < n; i++) {\n        if(i == -1)\n            cost2[i + 1] = 0;\n        else {\n            cost2[i + 1] = cost2[C[i] + 1] + i;\n        }\n    }\n\n    rep(i, q) {\n        cin >> l >> r;\n        l--;\n        r--;\n        a = 0;\n        t = l;\n        p = r;\n        rrep(i, 20) {\n            if(NEXT[t][i] <= r) {\n                a += 1 << i;\n                t = NEXT[t][i];\n                p = NEXT2[p][i];\n            }\n        }\n        t = B[t];\n        p = C[p];\n\n        print(a - (cost1[l] - cost1[t]) + (cost2[r + 1] - cost2[p + 1]) + 1);\n    }\n}\nint main() {\n    // cout<<fixed<<setprecision(15);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    input();\n    while(codeforces--) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n, k;\n\nstruct Tree {\n\tstruct Segtree {\n\t\tll dt[1 << 20];\n\t\tvoid inline change(int to, int x, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl == nr) return void(dt[now] = x);\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\tif(m >= to) change(to, x, now << 1, nl, m);\n\t\t\telse change(to, x, now << 1 | 1, m + 1, nr);\n\t\t\tdt[now] = dt[now << 1] + dt[now << 1 | 1];\n\t\t}\n\t\tll inline sum(int l, int r, int now = 1, int nl = 1, int nr = n + 5) {\n\t\t\tif(nl >= l && nr <= r) return dt[now];\n\t\t\tif(nl > r || nr < l) return 0;\n\t\t\tint m = (nl + nr) >> 1;\n\t\t\treturn sum(l, r, now << 1, nl, m) + sum(l, r, now << 1 | 1, m + 1, nr);\n\t\t}\n\t} seg;\n\n\tvector<int> nei[1 << 18];\n\tvoid inline link(int a, int b) {\n\t\tnei[a].pub(b);\n\t}\n\n\tint fa[20][1 << 18], lvl[1 << 18], sz[1 << 18], son[1 << 18];\n\tvoid inline predfs(int now) {\n\t\tsz[now] = 1;\n\t\tcont(i, 19) fa[i][now] = fa[i - 1][fa[i - 1][now]];\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tlvl[to] = lvl[now] + 1;\n\t\t\tfa[0][to] = now;\n\t\t\tpredfs(to);\n\t\t\tsz[now] += sz[to];\n\t\t\tif(sz[to] > sz[son[now]]) son[now] = to;\n\t\t}\n\t}\n\n\tint dfn[1 << 18], tmc;\n\tint ro[1 << 18];\n\tvoid inline dfss(int now, int rt) {\n\t\tdfn[now] = ++tmc; ro[now] = rt;\n\t\tif(son[now]) dfss(son[now], rt);\n\t\tloop(i, SZ(nei[now])) {\n\t\t\tint to = nei[now][i];\n\t\t\tif(to == son[now]) continue;\n\t\t\tdfss(to, to);\n\t\t}\n\t}\n\n\tvoid inline init() {\n\t\tcont(i, n) seg.change(dfn[i], i);\n\t}\n\n\tpair<int, int> inline find(int a, int b) {\n\t\tint lvl = 0;\n\t\trange(i, 19, 0, -1) if(fa[i][a] && (a > b ? fa[i][a] >= b : fa[i][a] <= b)) {\n\t\t\tlvl += 1 << i;\n\t\t\ta = fa[i][a];\n\t\t}\n\t\treturn mak(lvl, a);\n\t}\n\n\tll inline sum(int a, int b) {\n\t\tll res = 0;\n\t\twhile(1) {\n\t\t\tint rt = ro[a];\n\t\t\tbool en = 0;\n\t\t\tif(lvl[rt] <= lvl[b]) {\n\t\t\t\ten = 1;\n\t\t\t\trt = b;\n\t\t\t}\n\t\t\tres += seg.sum(dfn[rt], dfn[a]);\n\t\t\tif(en) break;\n\t\t\ta = fa[0][rt];\n\t\t}\n\t\treturn res;\n\t}\n} tl, tr;\n\nint x[1 << 18];\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tcont(i, n) scanf(\"%d\", x + i);\n\tcont(i, n) {\n\t\tint pos = upper_bound(x + 1, x + n + 1, x[i] - k) - x - 1;\n\t\ttl.link(pos, i);\n\t\tpos = lower_bound(x + 1, x + n + 1, x[i] + k) - x;\n\t\tif(pos == n + 1) pos = 0;\n\t\ttr.link(pos, i);\n\t}\n\ttl.predfs(0); tr.predfs(0);\n\ttl.dfss(0, 0); tr.dfss(0, 0);\n\ttl.init(); tr.init();\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tpair<int, int> res = tl.find(r, l);\n\t\tint ans = res.first, pr = res.second;\n\t\tres = tr.find(l, r);\n\t\tint pl = res.second;\n\t\tprintf(\"%lld\\n\", tl.sum(r, pr) - tr.sum(l, pl) + ans + 1);\n\t}\n\treturn 0;\n}\n\n/* 程序实现思路：\n * 1. 构建一棵左链树和右链树，左链树中每个节点的父亲节点在序列中为第一个能接在这个点左边的点，右同理\n * 2. 倍增，求出每棵树上每个节点的 2^i 层祖先\n * 3. 对两棵树分别进行 HLD，并用线段树维护每条链上的下标和\n * 4. 对于每个询问，先找到答案长度，将右树上对应链的下标和减去左树上对应链的下标和加上长度即为答案\n * 5. 总时间复杂度 O(k log^2 n)\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1234567890\n#define ll long long\n\nint N, K, Q;\nint X[200201];\nint L[20][200201], R[20][200201]; //\nll LS[20][200201], RS[20][200201]; //\n// LS[i][j] : j를 포함해서 만나는 2^i개의 정점의 번호 합\n\nint main()\n{\n\tscanf(\"%d %d\", &N, &K);\n\tfor(int i=1; i<=N; i++)\n\t\tscanf(\"%d\", &X[i]);\n\n\t// L[] 채우기\n\tmap<int, int> m;\n\tfor(int i=1; i<=N; i++)\n\t{\n\t\tm[X[i]] = i;\n\t\tauto it = m.upper_bound(X[i]-K);\n\t\tif (it == m.begin()) continue;\n\t\t\n\t\tit = prev(it);\n\t\tL[0][i] = it->second;\n\t}\n\n\tm.clear();\n\tfor(int i=N; i>=1; i--)\n\t{\n\t\tm[X[i]] = i;\n\t\tauto it = m.lower_bound(X[i]+K);\n\t\tif (it == m.end()) continue;\n\n\t\tR[0][i] = it->second;\n\t}\n\n\tfor(int i=1; i<=N; i++)\n\t\tLS[0][i] = RS[0][i] = i;\n\n\tfor(int i=1; i<20; i++)\n\t\tfor(int j=1; j<=N; j++)\n\t\t{\n\t\t\tL[i][j] = L[i-1][L[i-1][j]];\n\t\t\tR[i][j] = R[i-1][R[i-1][j]];\n\t\t\tLS[i][j] = LS[i-1][j] + LS[i-1][L[i-1][j]];\n\t\t\tRS[i][j] = RS[i-1][j] + RS[i-1][R[i-1][j]];\n\t\t}\n\n\tscanf(\"%d\", &Q);\n\twhile(Q--)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tll ls = 0, rs = 0, cnt = 0;\n\n\t\tint n = r;\n\t\tfor(int i=19; i>=0; i--)\n\t\t\tif (L[i][n] != 0 && l <= L[i][n])\n\t\t\t\trs += LS[i][n], n = L[i][n], cnt += (1<<i);\n\t\trs += LS[0][n]; cnt++;\n\n\t\tn = l;\n\t\tfor(int i=19; i>=0; i--)\n\t\t\tif (R[i][n] != 0 && R[i][n] <= r)\n\t\t\t\tls += RS[i][n], n = R[i][n];\n\t\tls += RS[0][n];\n\n\t\t//printf(\"%lld, %lld, %lld : \", rs, ls, cnt);\n\t\tprintf(\"%lld\\n\", rs-ls+cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\n\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec X(N); cin >> X;\n    int Q; cin >> Q;\n\n    vector<v_Pii> next(18, v_Pii(N, Pii(N, 0))), prev(18, v_Pii(N, Pii(-1, 0)));\n    REP(i, N){\n        int j = Lower_bound(X, X[i] + K);\n        if(j < N) next[0][i] = Pii(j, j);\n        int k = Upper_bound(X, X[i] - K) - 1;\n        if(k >= 0) prev[0][i] = Pii(k, k);\n    }\n    FOR(t, 1, 18){\n        REP(i, N) if(next[t - 1][i].fi < N){\n            int v = next[t - 1][next[t - 1][i].fi].fi;\n            int cost = next[t - 1][i].se + next[t - 1][next[t - 1][i].fi].se;\n            next[t][i] = Pii(v, cost);\n        }\n        REP(i, N) if(prev[t - 1][i].fi >= 0){\n            int v = prev[t - 1][prev[t - 1][i].fi].fi;\n            int cost = prev[t - 1][i].se + prev[t - 1][prev[t - 1][i].fi].se;\n            prev[t][i] = Pii(v, cost);\n        }\n    }\n    //mdebug(next); mdebug(prev);\n\n    vec ans(Q);\n    REP(q, Q){\n        int L, R; cin >> L >> R;\n        L--; R--;\n\n        int nl = 1, cl = L;\n        int now = L;\n        IREP(t, 18) if(next[t][now].fi <= R){\n            nl += bit(t);\n            cl += next[t][now].se;\n            now = next[t][now].fi;\n        }\n\n        int nr = 1, cr = R;\n        now = R;\n        IREP(t, 18) if(prev[t][now].fi >= L){\n            nr += bit(t);\n            cr += prev[t][now].se;\n            now = prev[t][now].fi;\n        }\n        ans[q] = cr - cl + nl;\n    }\n    REP(i, Q) cout << ans[i] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<18;\nint n, k, q;\nint x[maxn], l[maxn], r[maxn], w[maxn];\nint res[maxn];\nstruct dsu {\n\tvector<int> p;\n\tdsu(int n) : p(n) { iota(all(p), 0); }\n\tint par(int v) {\n\t\treturn p[v] == v ? v : p[v] = par(p[v]);\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = par(u), v = par(v);\n\t\tp[v] = u;\n\t}\n};\nstruct solver {\nll d[maxn], s[maxn];\nint par[maxn];\nvector<int> g[maxn], p[maxn];\nvoid dfs(int v) {\n\td[v] += w[v];\n\ts[v] += 1;\n\tfor(auto &i : g[v]) {\n\t\td[i] = d[v];\n\t\ts[i] = s[v];\n\t\tpar[i] = v;\n\t\tdfs(i);\n\t}\n}\nvector<ll> solve() {\n\tvector<ll> ans(q);\n\tfor(int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(x, x+n, x[i]+k)-x;\n\t\tif(it < n) g[it].push_back(i);\n\t}\n\tmemset(par, -1, sizeof par);\n\tfor(int i = 0; i < n; i++) if(par[i] == -1) dfs(i);\n\tfor(int i = 0; i < q; i++) {\n\t\tp[r[i]].push_back(i);\n\t}\n\tdsu f(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(auto j : g[i]) f.unite(i, j);\n\t\tfor(auto &qid : p[i]) {\n\t\t\tint x = l[qid];\n\t\t\tres[qid] = s[x];\n\t\t\tans[qid] = d[x];\n\t\t\tint y = par[f.par(x)];\n\t\t\tif(y != -1) {\n\t\t\t\tres[qid] -= s[y];\n\t\t\t\tans[qid] -= d[y];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n};\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> x[i], w[i] = i;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++)\n\t\tcin >> l[i] >> r[i], l[i]--, r[i]--;\n\tsolver A;\n\tauto a = A.solve();\n\tfor(int i = 0; i < n; i++) {\n\t\tx[i] *= -1;\n\t\tl[i] = n-1-l[i];\n\t\tr[i] = n-1-r[i];\n\t\tswap(l[i], r[i]);\n\t}\n\treverse(x, x+n);\n\treverse(w, w+n);\n\tsolver B;\n\tauto b = B.solve();\n\tfor(int i = 0; i < q; i++) cout << b[i] - a[i] + res[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<mint>> mul(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n\tint i, j, k;\n\tmint t;\n\tint n = a.size(), m = b[0].size(), l = a[0].size();\n\tvector<vector<mint>> c(n,vector<mint>(m));\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < l; k++)\n\t\t\t\tt += a[i][k] * b[k][j];\n\t\t\tc[i][j] = t;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<mint>> mat_pow(vector<vector<mint>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<mint>> ans(k, vector<mint>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x);\n\t\tx = mul(x, x);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nll nl[200010][20], nr[200010][20], sr[200010][20], sl[200010][20];\nint main()\n{\n\tll n, k, x[222222], q;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[0] = -1e9;\n\tx[n + 1] = 2e9;\n\tll l, r;\n\tr = 1;\n\tfor (int i = 1; i <= n;i++){\n\t\twhile(x[r]-x[i]<k)\n\t\t\tr++;\n\t\tnr[i][0] = r;\n\t\tsr[i][0] = i;\n\t}\n\tnr[0][0] = 0;\n\tnr[n + 1][0] = n + 1;\n\tl = n;\n\tfor (int i = n; i >= 1; i--){\n\t\twhile (x[i] - x[l] < k)\n\t\t\tl--;\n\t\tnl[i][0] = l;\n\t\tsl[i][0] = i;\n\t}\n\tnl[0][0] = 0;\n\tnl[n + 1][0] = n + 1;\n\trep(j, 19) rep(i, n + 2) nr[i][j + 1] = nr[nr[i][j]][j], nl[i][j + 1] = nl[nl[i][j]][j], sr[i][j+1]=sr[i][j]+sr[nr[i][j]][j], sl[i][j+1]=sl[i][j]+sl[nl[i][j]][j];\n\tcin >> q;\n\trep(i,q){\n\t\tll L, R;\n\t\tcin >> L >> R;\n\t\tll ok = 0, ng = n;\n\t\twhile(ng-ok>1){\n\t\t\tll mid = (ok + ng) / 2;\n\t\t\tll now = L;\n\t\t\trep(j, 20) if ((mid >> j) & 1) now = nr[now][j];\n\t\t\tif(R < now)\n\t\t\t\tng = mid;\n\t\t\telse\n\t\t\t\tok = mid;\n\t\t}\n\t\tll now = L, sumr = 0, suml = 0;\n\t\trep(j, 20) if ((ok >> j) & 1) sumr += sr[now][j], now = nr[now][j];\n\t\tsumr += now;\n\t\tnow = R;\n\t\trep(j, 20) if ((ok >> j) & 1) suml += sl[now][j], now = nl[now][j];\n\t\tsuml += now;\n\t\tcout << suml - sumr + ok + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr double EPS = 1e-8;\nconstexpr int MOD = 1000000007;\n// constexpr int MOD = 998244353;\nconstexpr int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconstexpr int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint main() {\n  constexpr int X = 18;\n  int n, k; cin >> n >> k;\n  vector<int> x(n); REP(i, n) cin >> x[i];\n  vector dpl(X, vector(n, -1)), dpr(X, vector(n, -1));\n  vector suml(X, vector(n, -1LL)), sumr(X, vector(n, -1LL));\n  int right = 0;\n  REP(i, n) {\n    while (right < n && x[right] - x[i] < k) ++right;\n    if (right < n) dpl[0][i] = suml[0][i] = right;\n  }\n  REP(i, X - 1) REP(j, n) {\n    if (dpl[i][j] != -1) {\n      dpl[i + 1][j] = dpl[i][dpl[i][j]];\n      suml[i + 1][j] = suml[i][j] + suml[i][dpl[i][j]];\n    }\n  }\n  int left = n - 1;\n  for (int i = n - 1; i >= 0; --i) {\n    while (left >= 0 && x[i] - x[left] < k) --left;\n    if (left >= 0) dpr[0][i] = sumr[0][i] = left;\n  }\n  REP(i, X - 1) REP(j, n) {\n    if (dpr[i][j] != -1) {\n      dpr[i + 1][j] = dpr[i][dpr[i][j]];\n      sumr[i + 1][j] = sumr[i][j] + sumr[i][dpr[i][j]];\n    }\n  }\n  int q; cin >> q;\n  while (q--) {\n    int l, r; cin >> l >> r; --l; --r;\n    int lb = 0, ub = r - l + 1;\n    while (ub - lb > 1) {\n      int mid = (lb + ub) / 2;\n      int pos = l;\n      REP(i, X) {\n        if ((mid >> i & 1) && pos != -1) pos = dpl[i][pos];\n      }\n      (pos != -1 && pos <= r ? lb : ub) = mid;\n    }\n    ll ans = lb + 1 + r - l;\n    int pos = l;\n    REP(i, X) {\n      if (lb >> i & 1) {\n        ans -= suml[i][pos];\n        pos = dpl[i][pos];\n      }\n    }\n    pos = r;\n    REP(i, X) {\n      if (lb >> i & 1) {\n        ans += sumr[i][pos];\n        pos = dpr[i][pos];\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 200100;\nconst int MAXL = 20;\nLL X[MAXN];\nint aft[MAXN][MAXL];\nint bef[MAXN][MAXL];\n\nLL sum_aft[MAXN][MAXL];\nLL sum_bef[MAXN][MAXL];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int N;\n    LL K;\n    cin >> N >> K;\n    for (int i = 1; i <= N; i++) cin >> X[i];\n    aft[N][0] = N+1;\n    for (int i = N-1; i >= 0; i--) {\n        aft[i][0] = aft[i+1][0];\n        while (X[aft[i][0]-1] >= X[i] + K) aft[i][0]--;\n    }\n    bef[1][0] = 0;\n    for (int i = 2; i <= N; i++) {\n        bef[i][0] = bef[i-1][0];\n        while (X[bef[i][0]+1] + K <= X[i]) bef[i][0]++;\n    }\n    for (int l = 0; l < MAXL; l++) aft[N+1][l] = N+1, bef[0][l] = 0;\n    for (int l = 1; l < MAXL; l++) {\n        for (int i = 1; i <= N; i++) {\n            aft[i][l] = aft[aft[i][l-1]][l-1];\n            bef[i][l] = bef[bef[i][l-1]][l-1];\n        }\n    }\n    for (int i = 1; i <= N; i++) sum_bef[i][0] = i, sum_aft[i][0] = i;\n    for (int l = 1; l < MAXL; l++) {\n        for (int i = 1; i <= N; i++) {\n            sum_bef[i][l] = sum_bef[i][l-1] + sum_bef[bef[i][l-1]][l-1];\n            sum_aft[i][l] = sum_aft[i][l-1] + sum_aft[aft[i][l-1]][l-1];\n        }\n    }\n\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int a, b;\n        cin >> a >> b;\n        int len = 1;\n        int x = a;\n        for (int l = MAXL-1; l >= 0; l--) {\n            if (aft[x][l] <= b) {\n                x = aft[x][l];\n                len += 1<<l;\n            }\n        }\n        LL sum_a = 0;\n        x = a;\n        for (int l = MAXL-1; l >= 0; l--) {\n            if (len & (1<<l)) {\n                sum_a += sum_aft[x][l];\n                x = aft[x][l];\n            }\n        }\n\n        LL sum_b = 0;\n        x = b;\n        for (int l = MAXL-1; l >= 0; l--) {\n            if (len & (1<<l)) {\n                sum_b += sum_bef[x][l];\n                x = bef[x][l];\n            }\n        }\n        \n        cout << len + sum_b - sum_a << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<mint>> mul(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n\tint i, j, k;\n\tmint t;\n\tint n = a.size(), m = b[0].size(), l = a[0].size();\n\tvector<vector<mint>> c(n,vector<mint>(m));\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < l; k++)\n\t\t\t\tt += a[i][k] * b[k][j];\n\t\t\tc[i][j] = t;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<mint>> mat_pow(vector<vector<mint>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<mint>> ans(k, vector<mint>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x);\n\t\tx = mul(x, x);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nll nl[200010][20], nr[200010][20], sr[200010][20], sl[200010][20];\nint main()\n{\n\tll n, k, x[222222], q;\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[0] = -1e9;\n\tx[n + 1] = 2e9;\n\tll l, r;\n\tr = 1;\n\tfor (int i = 1; i <= n;i++){\n\t\twhile(x[r]-x[i]<k)\n\t\t\tr++;\n\t\tnr[i][0] = r;\n\t\tsr[i][0] = i;\n\t}\n\tnr[0][0] = 0;\n\tnr[n + 1][0] = n + 1;\n\tl = n;\n\tfor (int i = n; i >= 1; i--){\n\t\twhile (x[i] - x[l] < k)\n\t\t\tl--;\n\t\tnl[i][0] = l;\n\t\tsl[i][0] = i;\n\t}\n\tnl[0][0] = 0;\n\tnl[n + 1][0] = n + 1;\n\trep(j, 19) rep(i, n + 2) nr[i][j + 1] = nr[nr[i][j]][j], nl[i][j + 1] = nl[nl[i][j]][j], sr[i][j+1]=sr[i][j]+sr[nr[i][j]][j], sl[i][j+1]=sl[i][j]+sl[nl[i][j]][j];\n\tcin >> q;\n\trep(i,q){\n\t\tll L, R;\n\t\tcin >> L >> R;\n\t\tll t = 0, m = 19, now = L;\n\t\tfor (; m >= 0;m--){\n\t\t\tif(nr[now][m]<=R){\n\t\t\t\tt += (1 << m);\n\t\t\t\tnow = nr[now][m];\n\t\t\t}\n\t\t}\n\t\tll sumr = 0, suml = 0;\n\t\tnow = L;\n\t\trep(j, 20) if ((t >> j) & 1) sumr += sr[now][j], now = nr[now][j];\n\t\tsumr += now;\n\t\tnow = R;\n\t\trep(j, 20) if ((t >> j) & 1) suml += sl[now][j], now = nl[now][j];\n\t\tsuml += now;\n\t\tcout << suml - sumr + t + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n */\n/*\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\nusing mint = modint998244353;\n//using mint = modint1000000007;\n//using mint=modint;\n//using mint=static_modint<100>;\n//////////////////////////\n\nll n,k;\nll N=19;\nvector<vector<ll>>db1(vl v){\n    vector<vector<ll>>r(N);\n    rep(i,0,N-1){\n        r[i].resize(n);\n        if(i==0){\n            ll pos=0;\n            rep(j,0,n-1){\n                while(pos<=n-1){\n                    if(v[pos]-v[j]>=k){\n                        break;\n                    }else{\n                        pos++;\n                    }\n                }\n                r[i][j]=pos;\n            }\n        }else{\n            rep(j,0,n-1){\n                if(r[i-1][j]==n)r[i][j]=n;\n                else r[i][j]=r[i-1][r[i-1][j]];\n            }\n        }\n    }\n    return r;\n}\nvector<vl>db2(vector<vl>v){\n    vector<vector<ll>>r(N);\n    rep(i,0,N-1){\n        r[i].resize(n);\n        if(i==0){\n            rep(j,0,n-1){\n                r[i][j]=v[i][j];\n            }\n        }else{\n            rep(j,0,n-1)r[i][j]=r[i-1][j]+r[i-1][v[i-1][j]];\n        }\n    }\n    return r;\n}\n\nint main(){fastio\n    cin>>n>>k;\n    vl x(n);rep(i,0,n-1)cin>>x[i];\n    vector<vector<ll>>a=db1(x);\n    /*\n    rep(i,0,4){\n        rep(j,0,n-1)cout<<a[i][j]<<\" \";cout<<endl;\n    }cout<<endl;*/\n    vl y(n);rep(i,0,n-1)y[i]=-x[i];\n    reverse(all(y));\n    vector<vl>b=db1(y);\n    \n    \n    vector<vl>sa=db2(a);\n    rep(i,0,N-1){\n        //reverse(all(b[i]));\n        rep(j,0,n-1)b[i][j]=n-b[i][j]-1;\n    }\n    \n    rep(j,0,N-1){\n        reverse(all(b[j]));\n    }\n    /*rep(i,0,4){\n        rep(j,0,n-1)cout<<b[i][j]<<\" \";cout<<endl;\n    }cout<<endl;*/\n    vector<vl>sb(N);\n    rep(i,0,N-1){\n        sb[i].resize(n);\n        if(i==0){\n            rep(j,0,n-1)sb[i][j]=b[i][j];\n        }else{\n            rrep(j,n-1,0){\n                sb[i][j]=sb[i-1][j]+sb[i-1][b[i-1][j]];\n            }\n        }\n    }\n    \n    /*\n    rep(i,0,4){\n        rep(j,0,n-1){\n            cout<<sa[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;\n    rep(i,0,4){\n        rep(j,0,n-1){\n            cout<<sb[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;\n     */\n    ll q;cin>>q;\n    while(q--){\n        ll l,r;cin>>l>>r;\n        l--;r--;\n        ll sz=0;\n        ll pos=l;\n        ll p1=l,p2=r;\n        while(pos<=r){\n            ll pre=pos;\n            rrep(j,N-1,0){\n                if(a[j][pos]<=r){\n                    sz+=1ll<<j;\n                    p1+=sa[j][pos];\n                    pos=a[j][pos];\n                    break;\n                }\n            }\n            if(pos==pre)break;\n        }\n        pos=r;\n        while(pos>=l){\n            ll pre=pos;\n            rrep(j,N-1,0){\n                if(b[j][pos]>=l){\n                    p2+=sb[j][pos];\n                    pos=b[j][pos];\n                    break;\n                }\n            }\n            if(pos==pre)break;\n        }\n       // cout<<sz+1<<\" \"<<p1<<\" \"<<p2<<endl;\n        cout<<p2-p1+sz+1<<endl;\n    }\n    \n    return 0;\n}\n/*\n 15 220492538\n  4452279 12864090 23146757 31318558 133073771 141315707 263239555 350278176 401243954 418305779 450172439 560311491 625900495 626194585 891960194\n  5\n  4 12\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<string, int> psi;\ntypedef pair<char, int> pci;\ntypedef pair<int, char> pic;\nconst int MOD = 1e9 + 7;\nconst long double PI = 3.141592653589793238462643383279502884197;\n\nll fac[1] = {1}, inv[1] = {1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll mp(ll a,ll b){ll ret=1;while(b){if(b&1)ret=ret*a%MOD;a=a*a%MOD;b>>=1;}return ret;}\nll cmb(ll r, ll c) {return (c>r||c<0) ? 0:fac[r] * inv[c] % MOD * inv[r - c] % MOD;}\n\nint vec[200002];\nint lspa[200002][18];\nll lsum[200002][18];\n\nint rspa[200002][18];\nll rsum[200002][18];\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    for (int i = 0; i < 18; i++) lspa[n+1][i] = n + 1;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &vec[i]);\n\n    for (int i = 1; i <= n; i++) {\n        int ne = lower_bound(vec + 1, vec + n + 1, vec[i] + k) - vec;\n        lspa[i][0] = ne;\n        lsum[i][0] = ne-1;\n\n        ne = upper_bound(vec + 1, vec + n + 1, vec[i] - k) - vec - 1;\n        rspa[i][0] = ne;\n        rsum[i][0] = ne;    // 얘는 더하고 l은 빠진다.\n    }\n\n    for (int j = 1; j < 18; j++) {\n        for (int i = 0; i <= n + 1; i++) {\n            lspa[i][j] = lspa[lspa[i][j-1]][j-1];\n            lsum[i][j] = lsum[i][j-1] + lsum[lspa[i][j-1]][j-1];\n            rspa[i][j] = rspa[rspa[i][j-1]][j-1];\n            rsum[i][j] = rsum[i][j-1] + rsum[rspa[i][j-1]][j-1];\n        }\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int le, ri;\n        scanf(\"%d %d\", &le, &ri);\n\n        int now = le;\n        ll ans = ri - le + 1;\n        // printf(\"%lld\\n\", ans);\n        for (int j = 17; j >= 0; j--)\n            if (lspa[now][j] <= ri) {\n                // printf(\"%d %d %d : pass\\n\", now, j, lspa[now][j]);\n                ans -= lsum[now][j];\n                now = lspa[now][j];\n            }\n        // printf(\"%lld\\n\", ans);\n\n        now = ri;\n        for (int j = 17; j >= 0; j--)\n            if (rspa[now][j] >= le) {\n                ans += rsum[now][j];\n                now = rspa[now][j];\n            }\n        printf(\"%lld\\n\", ans);\n    }\n}\n\n\n// author: rdd6584\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef vector<ll> Array;\n\nll l[20][202020];\nll r[20][202020];\nll dp1[20][202020];\nll dp2[20][202020];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, k;\n\tcin >> n >> k;\n\tArray x(n);\n\tREP(i, n)cin >> x[i];\n\tREP(i, n)dp1[0][i] = l[0][i] = lower_bound(all(x), x[i] + k) - x.begin();\n\tREP(i, n)dp2[0][i] = r[0][i] = upper_bound(all(x), x[i] - k) - x.begin() - 1;\n\tREP(i, 19)REP(j, n)l[i + 1][j] = l[i][min(n - 1, l[i][j])];\n\tREP(i, 19)REP(j, n)r[i + 1][j] = r[i][max(0LL, r[i][j])];\n\tREP(i, 19)REP(j, n)dp1[i + 1][j] = dp1[i][j] + dp1[i][l[i][j]];\n\tREP(i, 19)REP(j, n)dp2[i + 1][j] = dp2[i][j] + dp2[i][r[i][j]];\n\tll q;\n\tcin >> q;\n\twhile (q--) {\n\t\tll L, R;\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tll ans = R - L;\n\t\tll x = L, y = R - 1;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (l[i][x] < R)ans += (1LL << i) - dp1[i][x], x = l[i][x];\n\t\t\tif (r[i][y] >= L)ans += dp2[i][y], y = r[i][y];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename T, typename F>\nstruct Doubling\n{\n  const ll LOG = 21;\n  vector<vector<int>> nxt;\n  vector<vector<T>> sum;\n  F f;\n  T iden;\n  Doubling(int sz, T iden,F &f):iden(iden),f(f)\n  { \n    nxt.assign(LOG, vector< int >(sz, -1));\n    sum.assign(LOG, vector< T >(sz, iden));\n  }\n\n  void set_next(int k, int x){\n    nxt[0][k] = x;\n  }\n  void set_val(int k, T x){\n    sum[0][k] = x;\n  }\n  void build()\n  {\n    for(ll k = 0; k + 1 < LOG; k++) {\n      for(ll i = 0; i < nxt[k].size(); i++) {\n        if(nxt[k][i] == -1) nxt[k + 1][i] = -1;\n        else{\n          nxt[k + 1][i] = nxt[k][nxt[k][i]];\n          sum[k + 1][i] = f(sum[k][i],sum[k][nxt[k][i]]);\n        }\n      }\n    }\n  }\n  ll query(int k, ll t)//t個進んだ時のsum\n  {\n    T ret = iden;\n    for(ll i = LOG - 1; i >= 0; i--) {\n      if((t >> i) & 1){\n        ret = f(ret, sum[i][k]);\n        k = nxt[i][k];\n      }\n    }\n    return ret;\n  }\n  ll query1(ll k, ll t)//tにたどり着く最小手数を求める\n  {\n    ll ret = 1;\n    ll ret2=0;\n    for(ll i = LOG - 1; i >= 0; i--){\n      //cout<<i spa k spa nxt[i][k]<<endl;\n      if(nxt[i][k] != -1 && nxt[i][k] <= t){\n        ret += 1 << i;\n        ret2+=sum[i][k];\n        k = nxt[i][k];\n        //cout<<i spa k spa ret2 spa sum[i][k]<<endl;\n      }\n    }\n    ret2+=sum[0][k];\n    //cout<<ret<<endl;\n    return ret2;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,k;cin>>n>>k;\n  vector<ll>x(n);\n  rep(i,0,n)cin>>x[i];\n  auto xr=x;\n  reverse(ALL(xr));\n  rep(i,0,n)xr[i]*=-1;\n  //debug(xr,n);\n  auto f=[&](ll x,ll y){\n    return x+y;\n  };\n  Doubling<ll,decltype(f)>d(n+1,0,f),dr(n+1,0,f);\n  rep(i,0,n){\n    ll idx1=lower_bound(ALL(x),x[i]+k)-x.begin();\n    ll idx2=lower_bound(ALL(xr),xr[i]+k)-xr.begin();\n    //cout<<i spa idx1 spa idx2<<endl;\n    d.set_next(i,idx1);\n    dr.set_next(i,idx2);\n    d.set_val(i,i);\n    dr.set_val(i,n-i);\n  }\n  d.set_next(n,n);\n  dr.set_next(n,n);\n  d.build();\n  dr.build();\n  ll q;cin>>q;\n  while(q--){\n    ll l,r;cin>>l>>r;l--;r--;\n    ll kl=d.query1(l,r);\n    ll kr=dr.query1(n-r-1,n-l-1);\n    //cout<<kl spa kr spa kr-kl<<endl;\n    cout<<kr-kl<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = (int) 2e5 + 7;\nconst int K = 18;\nint n;\nint dif;\nint q;\nint a[N];\nint u[K][N];\nll f[K][N];\nint u2[K][N];\nll f2[K][N];\n\nll compute1(int x, int lim)\n{\n    ll sol = x - 1;\n    for (int k = K - 1; k >= 0; k--)\n    {\n        if (u[k][x] <= lim)\n        {\n            sol += f[k][x] - (1 << k);\n            x = u[k][x];\n        }\n    }\n    return sol;\n}\n\nll compute2(int x, int lim)\n{\n    ll sol = x;\n    for (int k = K - 1; k >= 0; k--)\n    {\n        if (lim <= u2[k][x])\n        {\n            sol += f2[k][x];\n            x = u2[k][x];\n        }\n    }\n    return sol;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n\n    cin >> n >> dif;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    a[n + 1] = a[n] + dif;\n    int j = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        while (a[j] - a[i] < dif)\n        {\n            j++;\n        }\n        u[0][i] = j;\n        f[0][i] = j;\n    }\n    a[0] = a[1] - dif;\n    j = n;\n    for (int i = n; i >= 1; i--)\n    {\n        while (a[i] - a[j] < dif)\n        {\n            j--;\n        }\n        u2[0][i] = j;\n        f2[0][i] = j;\n    }\n    for (int k = 1; k < K; k++)\n    {\n        for (int i = 1; i <= n; i++)\n        {\n            if (u[k - 1][i] == n + 1)\n            {\n                u[k][i] = n + 1;\n            }\n            else\n            {\n                f[k][i] = f[k - 1][i] + f[k - 1][u[k - 1][i]];\n                u[k][i] = u[k - 1][u[k - 1][i]];\n            }\n            /// boooo\n            if (u2[k - 1][i] == 0)\n            {\n                u2[k][i] = 0;\n            }\n            else\n            {\n                f2[k][i] = f2[k - 1][i] + f2[k - 1][u2[k - 1][i]];\n                u2[k][i] = u2[k - 1][u2[k - 1][i]];\n            }\n        }\n    }\n    cin >> q;\n    while (q--)\n    {\n        int l, r, best = 0, sol = 0;\n        cin >> l >> r;\n        cout << compute2(r, l) - compute1(l, r) << \"\\n\";\n    }\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b) do { cout << \"[\"; for (int count = (a);count < (b);++count) cout << ary[count] << ((b)-1 == count ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& os,const pair<T1,T2>& a) {os << \"(\" << a.first << \", \" << a.second << \")\";return os;}\n\nconst char newl = '\\n';\n\nint main() {\n    int n,k,q;\n    cin >> n >> k;\n    vector<int> x(n);\n    for (int i = 0;i < n;++i) cin >> x[i];\n    vector<int> edge1(n),edge2(n,-1);\n    vector<vector<pair<int,ll>>> anc1(n),anc2(n);\n    for (int i = 0;i < n;++i) edge1[i] = lower_bound(x.begin(),x.end(),x[i]+k)-x.begin();\n    for (int i = 0;i < n;++i) if (edge1[i] < n) edge2[edge1[i]] = i;\n    for (int i = 1;i < n;++i) edge2[i] = max(edge2[i],edge2[i-1]);\n    for (int i = 0;i < n;++i) if (edge1[i] < n) anc1[i].push_back({edge1[i],edge1[i]});\n    for (int i = 0;i < n;++i) if (edge2[i] >= 0) anc2[i].push_back({edge2[i],edge2[i]+1});\n    for (int i = 0;i < 20;++i) {\n        for (int j = 0;j < n;++j) {\n            if (anc1[j].size() < i+1 || anc1[anc1[j][i].first].size() < i+1) continue;\n            anc1[j].push_back(anc1[anc1[j][i].first][i]);\n            anc1[j].back().second += anc1[j][i].second;\n        }\n    }\n    for (int i = 0;i < 20;++i) {\n        for (int j = 0;j < n;++j) {\n            if (anc2[j].size() < i+1 || anc2[anc2[j][i].first].size() < i+1) continue;\n            anc2[j].push_back(anc2[anc2[j][i].first][i]);\n            anc2[j].back().second += anc2[j][i].second;\n        }\n    }\n    cin >> q;\n    while (q--) {\n        int l,r;\n        cin >> l >> r;\n        l--;r--;\n        ll ans = r+1-l;\n        int i = l,j = anc1[l].size();\n        while (j) {\n            j--;\n            if (anc1[i].size() < j+1 || anc1[i][j].first > r) continue;\n            ans -= anc1[i][j].second;\n            i = anc1[i][j].first;\n        }\n        i = r,j = anc2[r].size();\n        while (j) {\n            j--;\n            if (anc2[i].size() < j+1 || anc2[i][j].first < l) continue;\n            ans += anc2[i][j].second;\n            i = anc2[i][j].first;\n        }\n        cout << ans << newl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[19][201010], toL[19][201010];\nint totR[19][201010], totL[19][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 18, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cu = L;\n\tint tot = 0;\n\twhile (cu <= R) {\n\t\ttot += cu;\n\t\tcu = toRight[cu];\n\t}\n\treturn tot;\n}\n/*\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}*/\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 19) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 19) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toR[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 19) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n读题不规范，爆零两行泪。\n数据不清空，爆零两行泪。\n多测不读完，爆零两行泪。\n边界不特判，爆零两行泪。\n贪心不证明，爆零两行泪。\nD P 顺序错，爆零两行泪。\n大小少等号，爆零两行泪。\n变量不统一，爆零两行泪。\n越界不判断，爆零两行泪。\n调试不注释，爆零两行泪。\n溢出不 l l，爆零两行泪。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200000,LOG_N=20;\nint n,m,qu;\nint a[N+1];\nint rit[N+1],lft[N+1];\nint rit_to[N+1][LOG_N],rit_sum[N+1][LOG_N],lft_to[N+1][LOG_N],lft_sum[N+1][LOG_N];\nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tint now=1;\n\tfor(int i=1;i<=n;i++){\n\t\twhile(now<=n&&a[now]-a[i]<m)now++;\n\t\trit[i]=now;\n\t}\n\trit[n+1]=n+1;\n\tfor(int i=n+1;i;i--){\n\t\trit_to[i][0]=rit[i],rit_sum[i][0]=-rit[i]+1;\n\t\tfor(int j=1;j<LOG_N;j++)\n\t\t\trit_to[i][j]=rit_to[rit_to[i][j-1]][j-1],\n\t\t\trit_sum[i][j]=rit_sum[i][j-1]+rit_sum[rit_to[i][j-1]][j-1];\n\t}\n\tnow=n;\n\tfor(int i=n;i;i--){\n\t\twhile(now&&a[i]-a[now]<m)now--;\n\t\tlft[i]=now;\n\t}\n\tlft[0]=0;\n\tfor(int i=0;i<=n;i++){\n\t\tlft_to[i][0]=lft[i],lft_sum[i][0]=lft[i];\n\t\tfor(int j=1;j<LOG_N;j++)\n\t\t\tlft_to[i][j]=lft_to[lft_to[i][j-1]][j-1],\n\t\t\tlft_sum[i][j]=lft_sum[i][j-1]+lft_sum[lft_to[i][j-1]][j-1];\n\t}\n\tcin>>qu;\n\twhile(qu--){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tint ans=0;\n\t\tnow=l;\n\t\tans+=-now+1;\n\t\tfor(int i=LOG_N-1;~i;i--)if(rit_to[now][i]<=r)ans+=rit_sum[now][i],now=rit_to[now][i];\n\t\tnow=r;\n\t\tans+=now;\n\t\tfor(int i=LOG_N-1;~i;i--)if(lft_to[now][i]>=l)ans+=lft_sum[now][i],now=lft_to[now][i];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; using namespace atcoder;\nvoid _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan0\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K, X[201010];\nint Q;\n//---------------------------------------------------------------------------------------------------\nint toRight[201010], toLeft[201010];\nint toR[19][201010], toL[19][201010];\nint totR[19][201010], totL[19][201010];\n//---------------------------------------------------------------------------------------------------\nint getTot(int L, int R) {\n\tint res = 1;\n\tint cu = L;\n\trrep(p, 18, 0) {\n\t\tif (toR[p][cu] <= R) {\n\t\t\tres += 1 << p;\n\t\t\tcu = toR[p][cu];\n\t\t}\n\t}\n\treturn res;\n}\nint getRight(int L, int R) {\n\tint cu = R;\n\tint tot = 0;\n\twhile (L <= cu) {\n\t\ttot += cu;\n\t\tcu = toLeft[cu];\n\t}\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cu = L;\n\tint tot = 0;\n\twhile (cu <= R) {\n\t\ttot += cu;\n\t\tcu = toRight[cu];\n\t}\n\treturn tot;\n}\n/*\nint getRight(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = R; cnt--;\n\tint cu = R;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totL[p][cu];\n\t\tcu = toL[p][cu];\n\t}\n\n\treturn tot;\n}\nint getLeft(int L, int R) {\n\tint cnt = getTot(L, R);\n\n\tll tot = L; cnt--;\n\tint cu = L;\n\trep(p, 0, 19) if (cnt & (1 << p)) {\n\t\ttot += totR[p][cu];\n\t\tcu = toR[p][cu];\n\t}\n\n\treturn tot;\n}*/\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> K;\n\trep(i, 0, N) cin >> X[i];\n\tcin >> Q;\n\n\trep(i, 0, N) toRight[i] = lower_bound(X, X + N, X[i] + K) - X;\n\trep(i, 0, N) {\n\t\tint id = upper_bound(X, X + N, X[i] - K) - X;\n\t\ttoLeft[i] = id - 1;\n\t}\n\n\trep(p, 0, 19) toR[p][N] = N;\n\trep(i, 0, N) toR[0][i] = toRight[i];\n\trep(p, 1, 19) rep(i, 0, N) toR[p][i] = toR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) toL[0][i] = toLeft[i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) toL[p][i] = -1;\n\t\telse toL[p][i] = toR[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(i, 0, N) totR[0][i] = toR[0][i];\n\trep(p, 1, 19) rep(i, 0, N) totR[p][i] = totR[p - 1][i] + totR[p - 1][toR[p - 1][i]];\n\n\trep(i, 0, N) totL[0][i] = toL[0][i];\n\trep(p, 1, 19) rep(i, 0, N) {\n\t\tif (toL[p - 1][i] < 0) totL[p][i] = totL[p - 1][i];\n\t\telse totL[p][i] = totL[p - 1][i] + totL[p - 1][toL[p - 1][i]];\n\t}\n\n\trep(q, 0, Q) {\n\t\tint L, R; cin >> L >> R;\n\t\tL--; R--;\n\t\tll ans = getRight(L, R) - getLeft(L, R) + getTot(L, R);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\ntypedef array<ll, 2> ary;\npair<vvl, vvl> calc(ll n, ll k, vector<ll>& a){\n  vvl nxt = VV(n, 30, -1, ll);\n  vvl s = VV(n, 30, 0, ll);\n  for(int i=0;i<30;i++){\n    if(i==0){\n      for(int j=0;j<n;j++){\n        auto idx = lower_bound(all(a), a[j]+k) - a.begin();//k先のidx\n        if(j==n-1) idx = n;\n        nxt[j][0] = idx;\n        if(idx!=n) s[j][0] = idx;\n      }\n    }else{\n      for(int j=0;j<n;j++){\n        nxt[j][i] = (nxt[j][i-1]==n?n:nxt[nxt[j][i-1]][i-1]);\n        s[j][i] = s[j][i-1] + (nxt[j][i-1]==n?0:s[nxt[j][i-1]][i-1]);\n      }\n    }\n  }\n  return {nxt, s};\n}\n\nint main(){\n  ll n, k;scanf(\"%lld %lld\", &n, &k);\n  vll a(n);\n  re(i, n) scanf(\"%lld\", &a[i]);\n  vll b = a;\n  reverse(all(b));\n  for(int i=0;i<n;i++) b[i] = -b[i];\n  vvl nxt, nxt2, s, s2;\n  auto tmp = calc(n, k, a);\n  nxt = tmp.first;\n  s = tmp.second;\n  tmp = calc(n, k, b);\n  nxt2 = tmp.first;\n  s2 = tmp.second;\n  auto f = [&](ll l, ll r){//操作回数\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt[now]), r) - nxt[now].begin() - 1;\n      if(idx==-1||idx==n||nxt[now][idx]==n||a[nxt[now][idx]]-a[now] < k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s[now][idx];\n      now = nxt[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n\n  auto g = [&](ll l, ll r){\n    l = n - 1 - l, r = n - 1 - r;\n    swap(l, r);\n    ll cnt = 0;\n    ll S = 0;\n    ll now = l;\n    while(now<r){\n      auto idx = upper_bound(all(nxt2[now]), r) - nxt2[now].begin() - 1;\n      if(idx==-1||idx==n||nxt2[now][idx]==n||b[nxt2[now][idx]]-b[now]<k) break;//もう移動できない\n      cnt += (1<<idx);\n      S += s2[now][idx];\n      now = nxt2[now][idx];\n    }\n    return ary{cnt+1, S+l};\n  };\n\n  ll q;scanf(\"%lld\", &q);\n  for(int i=0;i<q;i++){\n    ll x, y;scanf(\"%lld %lld\", &x, &y);\n    x--, y--;\n    auto h = f(x, y);\n    auto u = g(x, y);\n    ll cnt = h[0] + 1;\n    cnt += u[1] - h[1];\n    u[1] = (n-1)*u[0] - u[1];\n    ll ret = u[0] + u[1] - h[1];\n    printf(\"%lld\\n\", ret);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\", \"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\n\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec X(N); cin >> X;\n    int Q; cin >> Q;\n\n    vector<v_Pii> next(18, v_Pii(N, Pii(N, 0))), prev(18, v_Pii(N, Pii(-1, 0)));\n    REP(i, N){\n        int j = Lower_bound(X, X[i] + K);\n        if(j < N) next[0][i] = Pii(j, j);\n        int k = Upper_bound(X, X[i] - K) - 1;\n        if(k >= 0) prev[0][i] = Pii(k, k);\n    }\n    FOR(t, 1, 18){\n        REP(i, N) if(next[t - 1][i].fi < N){\n            int v = next[t - 1][next[t - 1][i].fi].fi;\n            int cost = next[t - 1][i].se + next[t - 1][next[t - 1][i].fi].se;\n            next[t][i] = Pii(v, cost);\n        }\n        REP(i, N) if(prev[t - 1][i].fi >= 0){\n            int v = prev[t - 1][prev[t - 1][i].fi].fi;\n            int cost = prev[t - 1][i].se + prev[t - 1][prev[t - 1][i].fi].se;\n        }\n    }\n    //mdebug(next); mdebug(prev);\n\n    vec ans(Q);\n    REP(q, Q){\n        int L, R; cin >> L >> R;\n        L--; R--;\n\n        int nl = 1, cl = L;\n        int now = L;\n        while(next[0][now].fi <= R){\n            IREP(t, 18) if(next[t][now].fi <= R){\n                nl += bit(t);\n                cl += next[t][now].se;\n                now = next[t][now].fi;\n                break;\n            }\n        }\n        int nr = 1, cr = R;\n        now = R;\n        while(prev[0][now].fi >= L){\n            IREP(t, 18) if(prev[t][now].fi >= L){\n                nr += bit(t);\n                cr += prev[t][now].se;\n                now = prev[t][now].fi;\n                break;\n            }\n        }\n        ans[q] = cr - cl + nl;\n    }\n    REP(i, Q) cout << ans[i] << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n */\n/*\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\nusing mint = modint998244353;\n//using mint = modint1000000007;\n//using mint=modint;\n//using mint=static_modint<100>;\n//////////////////////////\n\nll n,k;\nll N=19;\nvector<vector<ll>>db1(vl v){\n    vector<vector<ll>>r(N);\n    rep(i,0,N-1){\n        r[i].resize(n);\n        if(i==0){\n            ll pos=0;\n            rep(j,0,n-1){\n                while(pos<=n-1){\n                    if(v[pos]-v[j]>=k){\n                        break;\n                    }else{\n                        pos++;\n                    }\n                }\n                r[i][j]=pos;\n            }\n        }else{\n            rep(j,0,n-1){\n                if(r[i-1][j]==n)r[i][j]=n;\n                else r[i][j]=r[i-1][r[i-1][j]];\n            }\n        }\n    }\n    return r;\n}\nvector<vl>db2(vector<vl>v){\n    vector<vector<ll>>r(N);\n    rep(i,0,N-1){\n        r[i].resize(n);\n        if(i==0){\n            rep(j,0,n-1){\n                r[i][j]=v[i][j];\n            }\n        }else{\n            rep(j,0,n-1)r[i][j]=r[i-1][j]+r[i-1][v[i-1][j]];\n        }\n    }\n    return r;\n}\n\nint main(){fastio\n    cin>>n>>k;\n    vl x(n);rep(i,0,n-1)cin>>x[i];\n    vector<vector<ll>>a=db1(x);\n    rep(i,0,4){\n        rep(j,0,n-1)cout<<a[i][j]<<\" \";cout<<endl;\n    }cout<<endl;\n    vl y(n);rep(i,0,n-1)y[i]=-x[i];\n    reverse(all(y));\n    vector<vl>b=db1(y);\n    rep(i,0,N-1){\n        //reverse(all(b[i]));\n        rep(j,0,n-1)b[i][j]=n-b[i][j]-1;\n    }\n    \n    \n    vector<vl>sa=db2(a),sb=db2(b);\n    \n    rep(j,0,N-1){\n        reverse(all(b[j]));\n        reverse(all(sb[j]));\n    }\n    \n    rep(i,0,4){\n        rep(j,0,n-1)cout<<b[i][j]<<\" \";cout<<endl;\n    }cout<<endl;\n    rep(i,0,4){\n        rep(j,0,n-1){\n            cout<<sa[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;\n    rep(i,0,4){\n        rep(j,0,n-1){\n            cout<<sb[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;\n    ll q;cin>>q;\n    while(q--){\n        ll l,r;cin>>l>>r;\n        l--;r--;\n        ll sz=0;\n        ll pos=l;\n        ll p1=l,p2=r;\n        while(pos<=r){\n            ll pre=pos;\n            rrep(j,N-1,0){\n                if(a[j][pos]<=r){\n                    sz+=1ll<<j;\n                    p1+=sa[j][pos];\n                    pos=a[j][pos];\n                    break;\n                }\n            }\n            if(pos==pre)break;\n        }\n        pos=r;\n        while(pos>=l){\n            ll pre=pos;\n            rrep(j,N-1,0){\n                if(b[j][pos]>=l){\n                    p2+=sb[j][pos];\n                    pos=b[j][pos];\n                    break;\n                }\n            }\n            if(pos==pre)break;\n        }\n        cout<<sz<<\" \"<<p1<<\" \"<<p2<<endl;\n        cout<<p2-p1+sz<<endl;\n    }\n    \n    return 0;\n}\n/*\n 11 3\n 1 2 4 5 6 7 9 12 13 15 17\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<18;\nint n, k, q;\nint x[maxn], l[maxn], r[maxn], w[maxn];\nint res[maxn];\nstruct dsu {\n\tvector<int> p;\n\tvector<int> r, rtop;\n\tdsu(int n) : p(n), r(n, 1) { iota(all(p), 0); rtop = p; }\n\tint par(int v) {\n\t\treturn p[v] == v ? v : p[v] = par(p[v]);\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = par(u), v = par(v);\n\t\tif(u == v) return;\n\t\tint rr = rtop[u];\n\t\tif(r[u] < r[v]) swap(u, v);\n\t\tp[v] = u;\n\t\tr[u] += r[v];\n\t\trtop[u] = rr;\n\t}\n};\nll d[maxn], s[maxn];\nint par[maxn];\nvector<int> g[maxn], p[maxn];\nvoid dfs(int v) {\n\td[v] += w[v];\n\ts[v] += 1;\n\tfor(auto &i : g[v]) {\n\t\td[i] = d[v];\n\t\ts[i] = s[v];\n\t\tpar[i] = v;\n\t\tdfs(i);\n\t}\n}\nvector<ll> solve() {\n\tmemset(d, 0, sizeof d);\n\tmemset(s, 0, sizeof s);\n\tfor(int i = 0; i < maxn; i++) g[i].clear(), p[i].clear();\n\tvector<ll> ans(q);\n\tfor(int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(x, x+n, x[i]+k)-x;\n\t\tif(it < n) g[it].push_back(i);\n\t}\n\tmemset(par, -1, sizeof par);\n\tfor(int i = 0; i < n; i++) if(par[i] == -1) dfs(i);\n\tfor(int i = 0; i < q; i++) {\n\t\tp[r[i]].push_back(i);\n\t}\n\tdsu f(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(auto j : g[i]) f.unite(i, j);\n\t\tfor(auto &qid : p[i]) {\n\t\t\tint x = l[qid];\n\t\t\tres[qid] = s[x];\n\t\t\tans[qid] = d[x];\n\t\t\tint y = par[f.rtop[f.par(x)]];\n\t\t\tif(y != -1) {\n\t\t\t\tres[qid] -= s[y];\n\t\t\t\tans[qid] -= d[y];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> x[i], w[i] = i;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++)\n\t\tcin >> l[i] >> r[i], l[i]--, r[i]--;\n\tauto a = solve();\n\tfor(int i = 0; i < n; i++) {\n\t\tx[i] *= -1;\n\t\tl[i] = n-1-l[i];\n\t\tr[i] = n-1-r[i];\n\t\tswap(l[i], r[i]);\n\t}\n\treverse(x, x+n);\n\treverse(w, w+n);\n\tauto b = solve();\n\tfor(int i = 0; i < q; i++) cout << b[i] - a[i] + res[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment (linker, \"/STACK:526000000\")\n#include \"bits/stdc++.h\"\n\n/*\nAtCoder Compressed STL, licensed under public domain (cc0)\nDownload Compressed: https://gist.github.com/yosupo06/ddd51afb727600fd95d9d8ad6c3c80c9\nbased on AtCoder STL,\nDownload: https://img.atcoder.jp/practice2/ac-library.zip\n*/\n\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tint ceil_pow2(int n) {\n\t\t\tint x = 0;\n\t\t\twhile ((1U << x) < (unsigned int)(n)) x++;\n\t\t\treturn x;\n\t\t}\n\n\t\tint bsf(unsigned int n) {\n#ifdef _MSC_VER\n\t\t\tunsigned long index;\n\t\t\t_BitScanForward(&index, n);\n\t\t\treturn index;\n#else\n\t\t\treturn __builtin_ctz(n);\n#endif\n\t\t}\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tconstexpr long long safe_mod(long long x, long long m) {\n\t\t\tx %= m;\n\t\t\tif (x < 0) x += m;\n\t\t\treturn x;\n\t\t}\n\n\t\tstruct barrett {\n\t\t\tunsigned int _m;\n\t\t\tunsigned long long im;\n\n\t\t\tbarrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n\t\t\tunsigned int umod() const { return _m; }\n\n\t\t\tunsigned int mul(unsigned int a, unsigned int b) const {\n\n\t\t\t\tunsigned long long z = a;\n\t\t\t\tz *= b;\n#ifdef _MSC_VER\n\t\t\t\tunsigned long long x;\n\t\t\t\t_umul128(z, im, &x);\n#else\n\t\t\t\tunsigned long long x =\n\t\t\t\t\t(unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n\t\t\t\tunsigned int v = (unsigned int)(z - x * _m);\n\t\t\t\tif (_m <= v) v += _m;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t};\n\n\t\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n\t\t\tif (m == 1) return 0;\n\t\t\tunsigned int _m = (unsigned int)(m);\n\t\t\tunsigned long long r = 1;\n\t\t\tunsigned long long y = safe_mod(x, m);\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r = (r * y) % _m;\n\t\t\t\ty = (y * y) % _m;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tconstexpr bool is_prime_constexpr(int n) {\n\t\t\tif (n <= 1) return false;\n\t\t\tif (n == 2 || n == 7 || n == 61) return true;\n\t\t\tif (n % 2 == 0) return false;\n\t\t\tlong long d = n - 1;\n\t\t\twhile (d % 2 == 0) d /= 2;\n\t\t\tint v[3] = { 2,7,61 };\n\t\t\tfor (long long a : v) {\n\t\t\t\tlong long t = d;\n\t\t\t\tlong long y = pow_mod_constexpr(a, t, n);\n\t\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {\n\t\t\t\t\ty = y * y % n;\n\t\t\t\t\tt <<= 1;\n\t\t\t\t}\n\t\t\t\tif (y != n - 1 && t % 2 == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\ttemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n\t\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n\t\t\ta = safe_mod(a, b);\n\t\t\tif (a == 0) return { b, 0 };\n\n\t\t\tlong long s = b, t = a;\n\t\t\tlong long m0 = 0, m1 = 1;\n\n\t\t\twhile (t) {\n\t\t\t\tlong long u = s / t;\n\t\t\t\ts -= t * u;\n\t\t\t\tm0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n\n\t\t\t\tauto tmp = s;\n\t\t\t\ts = t;\n\t\t\t\tt = tmp;\n\t\t\t\ttmp = m0;\n\t\t\t\tm0 = m1;\n\t\t\t\tm1 = tmp;\n\t\t\t}\n\t\t\tif (m0 < 0) m0 += b / s;\n\t\t\treturn { s, m0 };\n\t\t}\n\n\t\tconstexpr int primitive_root_constexpr(int m) {\n\t\t\tif (m == 2) return 1;\n\t\t\tif (m == 167772161) return 3;\n\t\t\tif (m == 469762049) return 3;\n\t\t\tif (m == 754974721) return 11;\n\t\t\tif (m == 998244353) return 3;\n\t\t\tint divs[20] = {};\n\t\t\tdivs[0] = 2;\n\t\t\tint cnt = 1;\n\t\t\tint x = (m - 1) / 2;\n\t\t\twhile (x % 2 == 0) x /= 2;\n\t\t\tfor (int i = 3; (long long)(i)*i <= x; i += 2) {\n\t\t\t\tif (x % i == 0) {\n\t\t\t\t\tdivs[cnt++] = i;\n\t\t\t\t\twhile (x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 1) {\n\t\t\t\tdivs[cnt++] = x;\n\t\t\t}\n\t\t\tfor (int g = 2;; g++) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\t\tif (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return g;\n\t\t\t}\n\t\t}\n\t\ttemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n#ifndef _MSC_VER\n\t\ttemplate <class T>\n\t\tusing is_signed_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value ||\n\t\t\tstd::is_same<T, __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value ||\n\t\t\tstd::is_same<T, unsigned __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing make_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value,\n\t\t\t__uint128_t,\n\t\t\tunsigned __int128>;\n\n\t\ttemplate <class T>\n\t\tusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n\t\t\tis_signed_int128<T>::value ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int = typename std::conditional<(is_integral<T>::value&&\n\t\t\tstd::is_signed<T>::value) ||\n\t\t\tis_signed_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<(is_integral<T>::value&&\n\t\t\t\tstd::is_unsigned<T>::value) ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<\n\t\t\tis_signed_int128<T>::value,\n\t\t\tmake_unsigned_int128<T>,\n\t\t\ttypename std::conditional<std::is_signed<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type>::type;\n\n#else\n\n\t\ttemplate <class T> using is_integral = typename std::is_integral<T>;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&& std::is_signed<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&&\n\t\t\tstd::is_unsigned<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type;\n\n#endif\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\n\t\ttemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstruct modint_base {};\n\t\tstruct static_modint_base : modint_base {};\n\n\t\ttemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\n\t\ttemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n\t}  // namespace internal\n\n\ttemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n\tstruct static_modint : internal::static_modint_base {\n\t\tusing mint = static_modint;\n\n\tpublic:\n\t\tstatic constexpr int mod() { return m; }\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tstatic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(umod()));\n\t\t\tif (x < 0) x += umod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % umod());\n\t\t}\n\t\tstatic_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v -= rhs._v;\n\t\t\tif (_v >= umod()) _v += umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\tunsigned long long z = _v;\n\t\t\tz *= rhs._v;\n\t\t\t_v = (unsigned int)(z % umod());\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tif (prime) {\n\t\t\t\tassert(_v);\n\t\t\t\treturn pow(umod() - 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto eg = internal::inv_gcd(_v, m);\n\t\t\t\tassert(eg.first == 1);\n\t\t\t\treturn eg.second;\n\t\t\t}\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic constexpr unsigned int umod() { return m; }\n\t\tstatic constexpr bool prime = internal::is_prime<m>;\n\t};\n\n\ttemplate <int id> struct dynamic_modint : internal::modint_base {\n\t\tusing mint = dynamic_modint;\n\n\tpublic:\n\t\tstatic int mod() { return (int)(bt.umod()); }\n\t\tstatic void set_mod(int m) {\n\t\t\tassert(1 <= m);\n\t\t\tbt = internal::barrett(m);\n\t\t}\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tdynamic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(mod()));\n\t\t\tif (x < 0) x += mod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % mod());\n\t\t}\n\t\tdynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v += mod() - rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\t_v = bt.mul(_v, rhs._v);\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tauto eg = internal::inv_gcd(_v, mod());\n\t\t\tassert(eg.first == 1);\n\t\t\treturn eg.second;\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic internal::barrett bt;\n\t\tstatic unsigned int umod() { return bt.umod(); }\n\t};\n\ttemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\n\tusing modint998244353 = static_modint<998244353>;\n\tusing modint1000000007 = static_modint<1000000007>;\n\tusing modint = dynamic_modint<-1>;\n\n\tnamespace internal {\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\n\t\ttemplate <class> struct is_dynamic_modint : public std::false_type {};\n\t\ttemplate <int id>\n\t\tstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\n\t\ttemplate <class T>\n\t\tusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_e[i] = es[i] * now;\n\t\t\t\t\tnow *= ies[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ph = 1; ph <= h; ph++) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p] * now;\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] = l - r;\n\t\t\t\t\t}\n\t\t\t\t\tnow *= sum_e[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly_inv(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_ie[i] = ies[i] * now;\n\t\t\t\t\tnow *= es[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int ph = h; ph >= 1; ph--) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint inow = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p];\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] =\n\t\t\t\t\t\t\t(unsigned long long)(mint::mod() + l.val() - r.val()) *\n\t\t\t\t\t\t\tinow.val();\n\t\t\t\t\t}\n\t\t\t\t\tinow *= sum_ie[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}  // namespace internal\n\n\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\tstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\t\tif (std::min(n, m) <= 60) {\n\t\t\tif (n < m) {\n\t\t\t\tstd::swap(n, m);\n\t\t\t\tstd::swap(a, b);\n\t\t\t}\n\t\t\tstd::vector<mint> ans(n + m - 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tans[i + j] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tint z = 1 << internal::ceil_pow2(n + m - 1);\n\t\ta.resize(z);\n\t\tinternal::butterfly(a);\n\t\tb.resize(z);\n\t\tinternal::butterfly(b);\n\t\tfor (int i = 0; i < z; i++) {\n\t\t\ta[i] *= b[i];\n\t\t}\n\t\tinternal::butterfly_inv(a);\n\t\ta.resize(n + m - 1);\n\t\tmint iz = mint(z).inv();\n\t\tfor (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n\t\treturn a;\n\t}\n\n\ttemplate <unsigned int mod = 998244353,\n\t\tclass T,\n\t\tstd::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n\t\tstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tusing mint = static_modint<mod>;\n\t\tstd::vector<mint> a2(n), b2(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta2[i] = mint(a[i]);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tb2[i] = mint(b[i]);\n\t\t}\n\t\tauto c2 = convolution(move(a2), move(b2));\n\t\tstd::vector<T> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tc[i] = c2[i].val();\n\t\t}\n\t\treturn c;\n\t}\n\n\tstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n\t\tconst std::vector<long long>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tstatic constexpr unsigned long long MOD1 = 754974721;  // 2^24\n\t\tstatic constexpr unsigned long long MOD2 = 167772161;  // 2^25\n\t\tstatic constexpr unsigned long long MOD3 = 469762049;  // 2^26\n\t\tstatic constexpr unsigned long long M2M3 = MOD2 * MOD3;\n\t\tstatic constexpr unsigned long long M1M3 = MOD1 * MOD3;\n\t\tstatic constexpr unsigned long long M1M2 = MOD1 * MOD2;\n\t\tstatic constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n\t\tstatic constexpr unsigned long long i1 =\n\t\t\tinternal::inv_gcd(MOD2 * MOD3, MOD1).second;\n\t\tstatic constexpr unsigned long long i2 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD3, MOD2).second;\n\t\tstatic constexpr unsigned long long i3 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n\t\tauto c1 = convolution<MOD1>(a, b);\n\t\tauto c2 = convolution<MOD2>(a, b);\n\t\tauto c3 = convolution<MOD3>(a, b);\n\n\t\tstd::vector<long long> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tunsigned long long x = 0;\n\t\t\tx += (c1[i] * i1) % MOD1 * M2M3;\n\t\t\tx += (c2[i] * i2) % MOD2 * M1M3;\n\t\t\tx += (c3[i] * i3) % MOD3 * M1M2;\n\t\t\tlong long diff =\n\t\t\t\tc1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n\t\t\tif (diff < 0) diff += MOD1;\n\t\t\tstatic constexpr unsigned long long offset[5] = {\n\t\t\t\t0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 };\n\t\t\tx -= offset[diff % 5];\n\t\t\tc[i] = x;\n\t\t}\n\n\t\treturn c;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct dsu {\n\tpublic:\n\t\tdsu() : _n(0) {}\n\t\tdsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n\t\tint merge(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\tint x = leader(a), y = leader(b);\n\t\t\tif (x == y) return x;\n\t\t\tif (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n\t\t\tparent_or_size[x] += parent_or_size[y];\n\t\t\tparent_or_size[y] = x;\n\t\t\treturn x;\n\t\t}\n\n\t\tbool same(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\treturn leader(a) == leader(b);\n\t\t}\n\n\t\tint leader(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tif (parent_or_size[a] < 0) return a;\n\t\t\treturn parent_or_size[a] = leader(parent_or_size[a]);\n\t\t}\n\n\t\tint size(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\treturn -parent_or_size[leader(a)];\n\t\t}\n\n\t\tstd::vector<std::vector<int>> groups() {\n\t\t\tstd::vector<int> leader_buf(_n), group_size(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tleader_buf[i] = leader(i);\n\t\t\t\tgroup_size[leader_buf[i]]++;\n\t\t\t}\n\t\t\tstd::vector<std::vector<int>> result(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[i].reserve(group_size[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[leader_buf[i]].push_back(i);\n\t\t\t}\n\t\t\tresult.erase(\n\t\t\t\tstd::remove_if(result.begin(), result.end(),\n\t\t\t\t\t[&](const std::vector<int>& v) { return v.empty(); }),\n\t\t\t\tresult.end());\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<int> parent_or_size;\n\t};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class T> struct fenwick_tree {\n\t\tusing U = internal::to_unsigned_t<T>;\n\n\tpublic:\n\t\tfenwick_tree() : _n(0) {}\n\t\tfenwick_tree(int n) : _n(n), data(n) {}\n\n\t\tvoid add(int p, T x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp++;\n\t\t\twhile (p <= _n) {\n\t\t\t\tdata[p - 1] += U(x);\n\t\t\t\tp += p & -p;\n\t\t\t}\n\t\t}\n\n\t\tT sum(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\treturn sum(r) - sum(l);\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<U> data;\n\n\t\tU sum(int r) {\n\t\t\tU s = 0;\n\t\t\twhile (r > 0) {\n\t\t\t\ts += data[r - 1];\n\t\t\t\tr -= r & -r;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\n\ttemplate <class S,\n\t\tS(*op)(S, S),\n\t\tS(*e)(),\n\t\tclass F,\n\t\tS(*mapping)(F, S),\n\t\tF(*composition)(F, F),\n\t\tF(*id)()>\n\t\tstruct lazy_segtree {\n\t\tpublic:\n\t\t\tlazy_segtree() : lazy_segtree(0) {}\n\t\t\tlazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n\t\t\tlazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\t\tsize = 1 << log;\n\t\t\t\td = std::vector<S>(2 * size, e());\n\t\t\t\tlz = std::vector<F>(size, id());\n\t\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\t\tupdate(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set(int p, S x) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = x;\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\n\t\t\tS get(int p) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\treturn d[p];\n\t\t\t}\n\n\t\t\tS prod(int l, int r) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return e();\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push(r >> i);\n\t\t\t\t}\n\n\t\t\t\tS sml = e(), smr = e();\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\t\tl >>= 1;\n\t\t\t\t\tr >>= 1;\n\t\t\t\t}\n\n\t\t\t\treturn op(sml, smr);\n\t\t\t}\n\n\t\t\tS all_prod() { return d[1]; }\n\n\t\t\tvoid apply(int p, F f) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = mapping(f, d[p]);\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\t\t\tvoid apply(int l, int r, F f) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return;\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tint l2 = l, r2 = r;\n\t\t\t\t\twhile (l < r) {\n\t\t\t\t\t\tif (l & 1) all_apply(l++, f);\n\t\t\t\t\t\tif (r & 1) all_apply(--r, f);\n\t\t\t\t\t\tl >>= 1;\n\t\t\t\t\t\tr >>= 1;\n\t\t\t\t\t}\n\t\t\t\t\tl = l2;\n\t\t\t\t\tr = r2;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i <= log; i++) {\n\t\t\t\t\tif (((l >> i) << i) != l) update(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int max_right(int l) {\n\t\t\t\treturn max_right(l, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int max_right(int l, G g) {\n\t\t\t\tassert(0 <= l && l <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (l == _n) return _n;\n\t\t\t\tl += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(l >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\t\tif (!g(op(sm, d[l]))) {\n\t\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\t\tif (g(op(sm, d[l]))) {\n\t\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn l - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\tl++;\n\t\t\t\t} while ((l & -l) != l);\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int min_left(int r) {\n\t\t\t\treturn min_left(r, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int min_left(int r, G g) {\n\t\t\t\tassert(0 <= r && r <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (r == 0) return 0;\n\t\t\t\tr += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\tr--;\n\t\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\t\tif (!g(op(d[r], sm))) {\n\t\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\t\tif (g(op(d[r], sm))) {\n\t\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t} while ((r & -r) != r);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n, size, log;\n\t\t\tstd::vector<S> d;\n\t\t\tstd::vector<F> lz;\n\n\t\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t\t\tvoid all_apply(int k, F f) {\n\t\t\t\td[k] = mapping(f, d[k]);\n\t\t\t\tif (k < size) lz[k] = composition(f, lz[k]);\n\t\t\t}\n\t\t\tvoid push(int k) {\n\t\t\t\tall_apply(2 * k, lz[k]);\n\t\t\t\tall_apply(2 * k + 1, lz[k]);\n\t\t\t\tlz[k] = id();\n\t\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\n\tlong long pow_mod(long long x, long long n, int m) {\n\t\tassert(0 <= n && 1 <= m);\n\t\tif (m == 1) return 0;\n\t\tinternal::barrett bt((unsigned int)(m));\n\t\tunsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n\t\twhile (n) {\n\t\t\tif (n & 1) r = bt.mul(r, y);\n\t\t\ty = bt.mul(y, y);\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\n\tlong long inv_mod(long long x, long long m) {\n\t\tassert(1 <= m);\n\t\tauto z = internal::inv_gcd(x, m);\n\t\tassert(z.first == 1);\n\t\treturn z.second;\n\t}\n\n\tstd::pair<long long, long long> crt(const std::vector<long long>& r,\n\t\tconst std::vector<long long>& m) {\n\t\tassert(r.size() == m.size());\n\t\tint n = int(r.size());\n\t\tlong long r0 = 0, m0 = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(1 <= m[i]);\n\t\t\tlong long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n\t\t\tif (m0 < m1) {\n\t\t\t\tstd::swap(r0, r1);\n\t\t\t\tstd::swap(m0, m1);\n\t\t\t}\n\t\t\tif (m0 % m1 == 0) {\n\t\t\t\tif (r0 % m1 != r1) return { 0, 0 };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tlong long g, im;\n\t\t\tstd::tie(g, im) = internal::inv_gcd(m0, m1);\n\n\t\t\tlong long u1 = (m1 / g);\n\t\t\tif ((r1 - r0) % g) return { 0, 0 };\n\n\t\t\tlong long x = (r1 - r0) / g % u1 * im % u1;\n\n\t\t\tr0 += x * m0;\n\t\t\tm0 *= u1;  // -> lcm(m0, m1)\n\t\t\tif (r0 < 0) r0 += m0;\n\t\t}\n\t\treturn { r0, m0 };\n\t}\n\n\tlong long floor_sum(long long n, long long m, long long a, long long b) {\n\t\tlong long ans = 0;\n\t\tif (a >= m) {\n\t\t\tans += (n - 1) * n * (a / m) / 2;\n\t\t\ta %= m;\n\t\t}\n\t\tif (b >= m) {\n\t\t\tans += n * (b / m);\n\t\t\tb %= m;\n\t\t}\n\n\t\tlong long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n\t\tif (y_max == 0) return ans;\n\t\tans += (n - (x_max + a - 1) / a) * y_max;\n\t\tans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n\t\treturn ans;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class T> struct simple_queue {\n\t\t\tstd::vector<T> payload;\n\t\t\tint pos = 0;\n\t\t\tvoid reserve(int n) { payload.reserve(n); }\n\t\t\tint size() const { return int(payload.size()) - pos; }\n\t\t\tbool empty() const { return pos == int(payload.size()); }\n\t\t\tvoid push(const T& t) { payload.push_back(t); }\n\t\t\tT& front() { return payload[pos]; }\n\t\t\tvoid clear() {\n\t\t\t\tpayload.clear();\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\tvoid pop() { pos++; }\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap> struct mf_graph {\n\tpublic:\n\t\tmf_graph() : _n(0) {}\n\t\tmf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tassert(0 <= cap);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0 });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{ pos[i].first, _e.to, _e.cap + _re.cap, _re.cap };\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult.push_back(get_edge(i));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid change_edge(int i, Cap new_cap, Cap new_flow) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tassert(0 <= new_flow && new_flow <= new_cap);\n\t\t\tauto& _e = g[pos[i].first][pos[i].second];\n\t\t\tauto& _re = g[_e.to][_e.rev];\n\t\t\t_e.cap = new_cap - new_flow;\n\t\t\t_re.cap = new_flow;\n\t\t}\n\n\t\tCap flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tCap flow(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\n\t\t\tstd::vector<int> level(_n), iter(_n);\n\t\t\tinternal::simple_queue<int> que;\n\n\t\t\tauto bfs = [&]() {\n\t\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\t\tlevel[s] = 0;\n\t\t\t\tque.clear();\n\t\t\t\tque.push(s);\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tfor (auto e : g[v]) {\n\t\t\t\t\t\tif (e.cap == 0 || level[e.to] >= 0) continue;\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tif (e.to == t) return;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tauto dfs = [&](auto self, int v, Cap up) {\n\t\t\t\tif (v == s) return up;\n\t\t\t\tCap res = 0;\n\t\t\t\tint level_v = level[v];\n\t\t\t\tfor (int& i = iter[v]; i < int(g[v].size()); i++) {\n\t\t\t\t\t_edge& e = g[v][i];\n\t\t\t\t\tif (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n\t\t\t\t\tCap d =\n\t\t\t\t\t\tself(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n\t\t\t\t\tif (d <= 0) continue;\n\t\t\t\t\tg[v][i].cap += d;\n\t\t\t\t\tg[e.to][e.rev].cap -= d;\n\t\t\t\t\tres += d;\n\t\t\t\t\tif (res == up) break;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t};\n\n\t\t\tCap flow = 0;\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tbfs();\n\t\t\t\tif (level[t] == -1) break;\n\t\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\t\twhile (flow < flow_limit) {\n\t\t\t\t\tCap f = dfs(dfs, t, flow_limit - flow);\n\t\t\t\t\tif (!f) break;\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tstd::vector<bool> min_cut(int s) {\n\t\t\tstd::vector<bool> visited(_n);\n\t\t\tinternal::simple_queue<int> que;\n\t\t\tque.push(s);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint p = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tvisited[p] = true;\n\t\t\t\tfor (auto e : g[p]) {\n\t\t\t\t\tif (e.cap && !visited[e.to]) {\n\t\t\t\t\t\tvisited[e.to] = true;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn visited;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t};\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap, class Cost> struct mcf_graph {\n\tpublic:\n\t\tmcf_graph() {}\n\t\tmcf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap, Cost cost) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap, cost });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0, -cost });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t\tCost cost;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{\n\t\t\t\tpos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n\t\t\t};\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result(m);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult[i] = get_edge(i);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tstd::pair<Cap, Cost> flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n\t\t\treturn slope(s, t, flow_limit).back();\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n\t\t\treturn slope(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\t\t\tassert(s != t);\n\t\t\tstd::vector<Cost> dual(_n, 0), dist(_n);\n\t\t\tstd::vector<int> pv(_n), pe(_n);\n\t\t\tstd::vector<bool> vis(_n);\n\t\t\tauto dual_ref = [&]() {\n\t\t\t\tstd::fill(dist.begin(), dist.end(),\n\t\t\t\t\tstd::numeric_limits<Cost>::max());\n\t\t\t\tstd::fill(pv.begin(), pv.end(), -1);\n\t\t\t\tstd::fill(pe.begin(), pe.end(), -1);\n\t\t\t\tstd::fill(vis.begin(), vis.end(), false);\n\t\t\t\tstruct Q {\n\t\t\t\t\tCost key;\n\t\t\t\t\tint to;\n\t\t\t\t\tbool operator<(Q r) const { return key > r.key; }\n\t\t\t\t};\n\t\t\t\tstd::priority_queue<Q> que;\n\t\t\t\tdist[s] = 0;\n\t\t\t\tque.push(Q{ 0, s });\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.top().to;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (vis[v]) continue;\n\t\t\t\t\tvis[v] = true;\n\t\t\t\t\tif (v == t) break;\n\t\t\t\t\tfor (int i = 0; i < int(g[v].size()); i++) {\n\t\t\t\t\t\tauto e = g[v][i];\n\t\t\t\t\t\tif (vis[e.to] || !e.cap) continue;\n\t\t\t\t\t\tCost cost = e.cost - dual[e.to] + dual[v];\n\t\t\t\t\t\tif (dist[e.to] - dist[v] > cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + cost;\n\t\t\t\t\t\t\tpv[e.to] = v;\n\t\t\t\t\t\t\tpe[e.to] = i;\n\t\t\t\t\t\t\tque.push(Q{ dist[e.to], e.to });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!vis[t]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (int v = 0; v < _n; v++) {\n\t\t\t\t\tif (!vis[v]) continue;\n\t\t\t\t\tdual[v] -= dist[t] - dist[v];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\t\tCap flow = 0;\n\t\t\tCost cost = 0, prev_cost = -1;\n\t\t\tstd::vector<std::pair<Cap, Cost>> result;\n\t\t\tresult.push_back({ flow, cost });\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tif (!dual_ref()) break;\n\t\t\t\tCap c = flow_limit - flow;\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tc = std::min(c, g[pv[v]][pe[v]].cap);\n\t\t\t\t}\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tauto& e = g[pv[v]][pe[v]];\n\t\t\t\t\te.cap -= c;\n\t\t\t\t\tg[v][e.rev].cap += c;\n\t\t\t\t}\n\t\t\t\tCost d = -dual[s];\n\t\t\t\tflow += c;\n\t\t\t\tcost += c * d;\n\t\t\t\tif (prev_cost == d) {\n\t\t\t\t\tresult.pop_back();\n\t\t\t\t}\n\t\t\t\tresult.push_back({ flow, cost });\n\t\t\t\tprev_cost = cost;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t\tCost cost;\n\t\t};\n\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n\tnamespace internal {\n\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges)\n\t\t\t\t: start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() { return _n; }\n\n\t\t\tvoid add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn { group_num, ids };\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct scc_graph {\n\tpublic:\n\t\tscc_graph() : internal(0) {}\n\t\tscc_graph(int n) : internal(n) {}\n\n\t\tvoid add_edge(int from, int to) {\n\t\t\tint n = internal.num_vertices();\n\t\t\tassert(0 <= from && from < n);\n\t\t\tassert(0 <= to && to < n);\n\t\t\tinternal.add_edge(from, to);\n\t\t}\n\n\t\tstd::vector<std::vector<int>> scc() { return internal.scc(); }\n\n\tprivate:\n\t\tinternal::scc_graph internal;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class S, S(*op)(S, S), S(*e)()> struct segtree {\n\tpublic:\n\t\tsegtree() : segtree(0) {}\n\t\tsegtree(int n) : segtree(std::vector<S>(n, e())) {}\n\t\tsegtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\tsize = 1 << log;\n\t\t\td = std::vector<S>(2 * size, e());\n\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\tupdate(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid set(int p, S x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp += size;\n\t\t\td[p] = x;\n\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t}\n\n\t\tS get(int p) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\treturn d[p + size];\n\t\t}\n\n\t\tS prod(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\tS sml = e(), smr = e();\n\t\t\tl += size;\n\t\t\tr += size;\n\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\treturn op(sml, smr);\n\t\t}\n\n\t\tS all_prod() { return d[1]; }\n\n\t\ttemplate <bool (*f)(S)> int max_right(int l) {\n\t\t\treturn max_right(l, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int max_right(int l, F f) {\n\t\t\tassert(0 <= l && l <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (l == _n) return _n;\n\t\t\tl += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\tif (!f(op(sm, d[l]))) {\n\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\tif (f(op(sm, d[l]))) {\n\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn l - size;\n\t\t\t\t}\n\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\tl++;\n\t\t\t} while ((l & -l) != l);\n\t\t\treturn _n;\n\t\t}\n\n\t\ttemplate <bool (*f)(S)> int min_left(int r) {\n\t\t\treturn min_left(r, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int min_left(int r, F f) {\n\t\t\tassert(0 <= r && r <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (r == 0) return 0;\n\t\t\tr += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\tr--;\n\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\tif (!f(op(d[r], sm))) {\n\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\tif (f(op(d[r], sm))) {\n\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t}\n\t\t\t\tsm = op(d[r], sm);\n\t\t\t} while ((r & -r) != r);\n\t\t\treturn 0;\n\t\t}\n\n\tprivate:\n\t\tint _n, size, log;\n\t\tstd::vector<S> d;\n\n\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstd::vector<int> sa_naive(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tstd::sort(sa.begin(), sa.end(), [&](int l, int r) {\n\t\t\t\tif (l == r) return false;\n\t\t\t\twhile (l < n && r < n) {\n\t\t\t\t\tif (s[l] != s[r]) return s[l] < s[r];\n\t\t\t\t\tl++;\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\treturn l == n;\n\t\t\t\t});\n\t\t\treturn sa;\n\t\t}\n\n\t\tstd::vector<int> sa_doubling(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n), rnk = s, tmp(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tfor (int k = 1; k < n; k *= 2) {\n\t\t\t\tauto cmp = [&](int x, int y) {\n\t\t\t\t\tif (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n\t\t\t\t\tint rx = x + k < n ? rnk[x + k] : -1;\n\t\t\t\t\tint ry = y + k < n ? rnk[y + k] : -1;\n\t\t\t\t\treturn rx < ry;\n\t\t\t\t};\n\t\t\t\tstd::sort(sa.begin(), sa.end(), cmp);\n\t\t\t\ttmp[sa[0]] = 0;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tstd::swap(tmp, rnk);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\ttemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n\t\tstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n\t\t\tint n = int(s.size());\n\t\t\tif (n == 0) return {};\n\t\t\tif (n == 1) return { 0 };\n\t\t\tif (n == 2) {\n\t\t\t\tif (s[0] < s[1]) {\n\t\t\t\t\treturn { 0, 1 };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn { 1, 0 };\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n < THRESHOLD_NAIVE) {\n\t\t\t\treturn sa_naive(s);\n\t\t\t}\n\t\t\tif (n < THRESHOLD_DOUBLING) {\n\t\t\t\treturn sa_doubling(s);\n\t\t\t}\n\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::vector<bool> ls(n);\n\t\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\t\tls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n\t\t\t}\n\t\t\tstd::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!ls[i]) {\n\t\t\t\t\tsum_s[s[i]]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum_l[s[i] + 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= upper; i++) {\n\t\t\t\tsum_s[i] += sum_l[i];\n\t\t\t\tif (i < upper) sum_l[i + 1] += sum_s[i];\n\t\t\t}\n\n\t\t\tauto induce = [&](const std::vector<int>& lms) {\n\t\t\t\tstd::fill(sa.begin(), sa.end(), -1);\n\t\t\t\tstd::vector<int> buf(upper + 1);\n\t\t\t\tstd::copy(sum_s.begin(), sum_s.end(), buf.begin());\n\t\t\t\tfor (auto d : lms) {\n\t\t\t\t\tif (d == n) continue;\n\t\t\t\t\tsa[buf[s[d]]++] = d;\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tsa[buf[s[n - 1]]++] = n - 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && !ls[v - 1]) {\n\t\t\t\t\t\tsa[buf[s[v - 1]]++] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && ls[v - 1]) {\n\t\t\t\t\t\tsa[--buf[s[v - 1] + 1]] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstd::vector<int> lms_map(n + 1, -1);\n\t\t\tint m = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms_map[i] = m++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::vector<int> lms;\n\t\t\tlms.reserve(m);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinduce(lms);\n\n\t\t\tif (m) {\n\t\t\t\tstd::vector<int> sorted_lms;\n\t\t\t\tsorted_lms.reserve(m);\n\t\t\t\tfor (int v : sa) {\n\t\t\t\t\tif (lms_map[v] != -1) sorted_lms.push_back(v);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> rec_s(m);\n\t\t\t\tint rec_upper = 0;\n\t\t\t\trec_s[lms_map[sorted_lms[0]]] = 0;\n\t\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];\n\t\t\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n\t\t\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n\t\t\t\t\tbool same = true;\n\t\t\t\t\tif (end_l - l != end_r - r) {\n\t\t\t\t\t\tsame = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twhile (l < end_l) {\n\t\t\t\t\t\t\tif (s[l] != s[r]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (l == n || s[l] != s[r]) same = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!same) rec_upper++;\n\t\t\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_upper;\n\t\t\t\t}\n\n\t\t\t\tauto rec_sa =\n\t\t\t\t\tsa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tsorted_lms[i] = lms[rec_sa[i]];\n\t\t\t\t}\n\t\t\t\tinduce(sorted_lms);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t}  // namespace internal\n\n\tstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n\t\tassert(0 <= upper);\n\t\tfor (int d : s) {\n\t\t\tassert(0 <= d && d <= upper);\n\t\t}\n\t\tauto sa = internal::sa_is(s, upper);\n\t\treturn sa;\n\t}\n\n\ttemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> idx(n);\n\t\tiota(idx.begin(), idx.end(), 0);\n\t\tsort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n\t\tstd::vector<int> s2(n);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i && s[idx[i - 1]] != s[idx[i]]) now++;\n\t\t\ts2[idx[i]] = now;\n\t\t}\n\t\treturn internal::sa_is(s2, now);\n\t}\n\n\tstd::vector<int> suffix_array(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn internal::sa_is(s2, 255);\n\t}\n\n\ttemplate <class T>\n\tstd::vector<int> lcp_array(const std::vector<T>& s,\n\t\tconst std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tassert(n >= 1);\n\t\tstd::vector<int> rnk(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\trnk[sa[i]] = i;\n\t\t}\n\t\tstd::vector<int> lcp(n - 1);\n\t\tint h = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (h > 0) h--;\n\t\t\tif (rnk[i] == 0) continue;\n\t\t\tint j = sa[rnk[i] - 1];\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rnk[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n\n\tstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn lcp_array(s2, sa);\n\t}\n\n\ttemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tif (n == 0) return {};\n\t\tstd::vector<int> z(n);\n\t\tz[0] = 0;\n\t\tfor (int i = 1, j = 0; i < n; i++) {\n\t\t\tint& k = z[i];\n\t\t\tk = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n\t\t\twhile (i + k < n && s[k] == s[i + k]) k++;\n\t\t\tif (j + z[j] < i + z[i]) j = i;\n\t\t}\n\t\tz[0] = n;\n\t\treturn z;\n\t}\n\n\tstd::vector<int> z_algorithm(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn z_algorithm(s2);\n\t}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct two_sat {\n\tpublic:\n\t\ttwo_sat() : _n(0), scc(0) {}\n\t\ttwo_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n\t\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\t\tassert(0 <= i && i < _n);\n\t\t\tassert(0 <= j && j < _n);\n\t\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t\t}\n\t\tbool satisfiable() {\n\t\t\tauto id = scc.scc_ids().second;\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tif (id[2 * i] == id[2 * i + 1]) return false;\n\t\t\t\t_answer[i] = id[2 * i] < id[2 * i + 1];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tstd::vector<bool> answer() { return _answer; }\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<bool> _answer;\n\t\tinternal::scc_graph scc;\n\t};\n\n}  // namespace atcoder\n\n/*\nend of AtCoder STL\n*/\n\n#define int ll\nusing namespace std;\nusing namespace atcoder;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n};\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n#define int ll\nint doubling[2][60][300000];\nint dp[2][300000];\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\tREP(i, n) {\n\t\tauto x = lower_bound(ALL(inputs), inputs[i] + k);\n\t\tdoubling[0][0][i] = x - inputs.begin();\n\t\tinputs[i] *= -1;\n\t}\n\tdoubling[0][0][n] = n;\n\treverse(ALL(inputs));\n\tREP(i, n) {\n\t\tauto x = lower_bound(ALL(inputs), inputs[i] + k);\n\t\tdoubling[1][0][n - i - 1] = (n - 1) - (x - inputs.begin());\n\t}\n\tREP(tea, 2) {\n\t\tfor (int i = 1; i < 60;++i) {\n\t\t\tREP(j, n+1) {\n\t\t\t\tif (doubling[tea][i - 1][j] == -1) {\n\t\t\t\t\tdoubling[tea][i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoubling[tea][i][j] = doubling[tea][i - 1][doubling[tea][i - 1][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tdp[0][i] += i;\n\t\tdp[0][i] += dp[0][doubling[0][0][i]];\n\t}\n\tREP(i, n) {\n\t\tdp[1][i] += i;\n\t\tif (doubling[1][0][i] != -1) {\n\t\t\tdp[1][i] += dp[1][doubling[1][0][i]];\n\t\t}\n\t}\n\tint query;\n\tcin >> query;\n\tREP(i, query) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tint ans = 1;\n\t\tint now = l;\n\t\tint now_R = r;\n\t\tfor (int q = 20; q >= 0; --q) {\n\t\t\tif (doubling[0][q][now] <= r) {\n\t\t\t\tans += (1 << q);\n\t\t\t\tnow = doubling[0][q][now];\n\t\t\t}\n\t\t\tif (doubling[1][q][now_R] >= l) {\n\t\t\t\tnow_R = doubling[1][q][now_R];\n\t\t\t}\n\t\t}\n\t\tans += dp[1][r];\n\t\tans -= dp[1][now_R] - now_R;\n\t\tans -= dp[0][l];\n\t\tans += dp[0][now] - now;\n\t\tcout << ans << endl;\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tint t = 1;\n\t//cin >> t;\n\tREP(tea, t) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<20;\nint n, k, q;\nint x[maxn], l[maxn], r[maxn], w[maxn];\nint res[maxn];\nstruct dsu {\n\tvector<int> p;\n\tvector<int> r, rtop;\n\tdsu(int n) : p(n), r(n, 1) { iota(all(p), 0); rtop = p; }\n\tint par(int v) {\n\t\treturn p[v] == v ? v : p[v] = par(p[v]);\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = par(u), v = par(v);\n\t\tif(u == v) return;\n\t\tint rr = rtop[u];\n\t\tif(r[u] < r[v]) swap(u, v);\n\t\tp[v] = u;\n\t\tr[u] += r[v];\n\t\trtop[u] = rr;\n\t}\n};\nll d[maxn], s[maxn];\nint par[maxn];\nvector<int> g[maxn], p[maxn];\nvoid dfs(int v) {\n\td[v] += w[v];\n\ts[v] += 1;\n\tfor(auto &i : g[v]) {\n\t\td[i] = d[v];\n\t\ts[i] = s[v];\n\t\tpar[i] = v;\n\t\tdfs(i);\n\t}\n}\nvector<ll> solve() {\n\tmemset(d, 0, sizeof d);\n\tmemset(s, 0, sizeof s);\n\tfor(int i = 0; i < maxn; i++) g[i].clear(), p[i].clear();\n\tvector<ll> ans(q);\n\tfor(int i = 0; i < n; i++) {\n\t\tauto it = lower_bound(x, x+n, x[i]+k)-x;\n\t\tif(it < n) g[it].push_back(i), par[i] = it;\n\t}\n\tmemset(par, -1, sizeof par);\n\tfor(int i = 0; i < n; i++) if(par[i] == -1) dfs(i);\n\tfor(int i = 0; i < q; i++) {\n\t\tp[r[i]].push_back(i);\n\t}\n\tdsu f(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(auto j : g[i]) f.unite(i, j);\n\t\tfor(auto &qid : p[i]) {\n\t\t\tint x = l[qid];\n\t\t\tres[qid] = s[x];\n\t\t\tans[qid] = d[x];\n\t\t\tint y = par[f.rtop[f.par(x)]];\n\t\t\tif(y != -1) {\n\t\t\t\tres[qid] -= s[y];\n\t\t\t\tans[qid] -= d[y];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> x[i], w[i] = i;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++)\n\t\tcin >> l[i] >> r[i], l[i]--, r[i]--;\n\tauto a = solve();\n\tfor(int i = 0; i < n; i++) {\n\t\tx[i] *= -1;\n\t\tl[i] = n-1-l[i];\n\t\tr[i] = n-1-r[i];\n\t\tswap(l[i], r[i]);\n\t}\n\treverse(x, x+n);\n\treverse(w, w+n);\n\tauto b = solve();\n\tfor(int i = 0; i < q; i++) cout << b[i] - a[i] + res[i] << '\\n';\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n  int a, b;\n  int sum = 0;\n\n  cout << \"Enter two numbers: \" << endl;\n\n  cin >> a >> b;\n  sum = a + b;\n\n  cout << \"The sum of two numbers is: \" << sum << endl;\n\n  if (sum < 5)\n  {\n    for (int i = 0; sum <= 10; i++)\n    {\n      cout << \"Happy Coding \" << sum++ << endl;\n    }\n  }\n\n  else\n  {\n    cout << \"Please enter the numbers in range!\" << endl;\n  }\n\n  cout << \"Happy Coding!\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DKeepDistances solver = new DKeepDistances();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DKeepDistances {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] x = new int[n];\n            in.populate(x);\n\n            int[][] pre = new int[20][n];\n            int[][] post = new int[20][n];\n            long[][] preSum = new long[20][n];\n            long[][] postSum = new long[20][n];\n\n            Deque<Integer> dq = new ArrayDeque<>(n);\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                while (!dq.isEmpty() && x[i] - x[dq.peekFirst()] >= k) {\n                    post[0][dq.removeFirst()] = i;\n                }\n                dq.addLast(i);\n            }\n            while (!dq.isEmpty()) {\n                post[0][dq.removeFirst()] = n;\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                while (!dq.isEmpty() && x[dq.peekFirst()] - x[i] >= k) {\n                    pre[0][dq.removeFirst()] = i;\n                }\n                dq.addLast(i);\n            }\n            while (!dq.isEmpty()) {\n                pre[0][dq.removeFirst()] = -1;\n            }\n            for (int i = 0; i < n; i++) {\n                if (pre[0][i] >= 0) {\n                    preSum[0][i] += pre[0][i];\n                }\n                if (post[0][i] < n) {\n                    postSum[0][i] += post[0][i];\n                }\n            }\n\n            for (int i = 0; i + 1 < 20; i++) {\n                for (int j = 0; j < n; j++) {\n                    pre[i + 1][j] = pre[i][j] == -1 ? -1 : pre[i][pre[i][j]];\n                    post[i + 1][j] = post[i][j] == n ? n : post[i][post[i][j]];\n                    preSum[i + 1][j] = pre[i][j] == -1 ? preSum[i][j] :\n                            preSum[i][j] + preSum[i][pre[i][j]];\n                    postSum[i + 1][j] = post[i][j] == n ? postSum[i][j] :\n                            postSum[i][j] + postSum[i][post[i][j]];\n                }\n            }\n\n\n            int q = in.readInt();\n\n            for (int i = 0; i < q; i++) {\n                int l = in.readInt() - 1;\n                int r = in.readInt() - 1;\n\n                int lr = l;\n                long sumLR = l;\n                int size = 1;\n                for (int j = 20 - 1; j >= 0; j--) {\n                    if (post[j][lr] <= r) {\n                        size += 1 << j;\n                        sumLR += postSum[j][lr];\n                        lr = post[j][lr];\n                        continue;\n                    }\n                }\n\n                int rl = r;\n                long sumRL = r;\n                for (int j = 20 - 1; j >= 0; j--) {\n                    if (pre[j][rl] >= l) {\n                        sumRL += preSum[j][rl];\n                        rl = pre[j][rl];\n                        continue;\n                    }\n                }\n\n                long ans = sumRL - sumLR + size;\n                out.println(ans);\n            }\n\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongPredicate;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExtendedScanner sc = new ExtendedScanner();\n        FastPrintStream pw = new FastPrintStream();\n        solve(sc, pw);\n        sc.close();\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(ExtendedScanner sc, FastPrintStream pw) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] x = sc.ints(n);\n        int[] next = new int[n + 1];\n        int[] prev = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            int l = i, r = n;\n            while (r - l > 1) {\n                int m = (l + r) >> 1;\n                if (x[m] < x[i] + k) l = m;\n                else r = m;\n            }\n            next[i] = r;\n            l = -1; r = i;\n            while (r - l > 1) {\n                int m = (l + r) >> 1;\n                if (x[m] <= x[i] - k) l = m;\n                else r = m;\n            }\n            prev[i] = l;\n        }\n        next[n] = n;\n        Doubling nd = new Doubling(next, n);\n        // Doubling pd = new Doubling(prev, n);\n        int q = sc.nextInt();\n        while (q --> 0) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt();\n            int s = 0, t = r - l;\n            while (t - s > 1) {\n                int m = (s + t) >> 1;\n                if (nd.query(l, m) >= r) {\n                    t = m;\n                } else {\n                    s = m;\n                }\n            }\n            int ans = 0;\n            for (int i = l; i < r; i++) {\n                int cnt = -1;\n                int cur = i;\n                while (cur < r) {\n                    cur = next[cur];\n                    cnt++;\n                }\n                cur = i;\n                while (cur >= l) {\n                    cur = prev[cur];\n                    cnt++;\n                }\n                if (cnt == t) {\n                    ans++;\n                }\n            }\n            pw.println(ans);\n        }\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass FastScanner implements AutoCloseable {\n    private final java.io.InputStream in;\n    private final byte[] buf = new byte[2048];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(java.io.InputStream in) {\n        this.in = in;\n    }\n\n    public FastScanner() {\n        this(System.in);\n    }\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {\n            buflen = in.read(buf);\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n        return buflen > 0;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buf[ptr++] : -1;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !(32 < buf[ptr] && buf[ptr] < 127)) ptr++;\n        return hasNextByte();\n    }\n\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        for (int b = readByte(); 32 < b && b < 127; b = readByte()) {\n            sb.appendCodePoint(b);\n        }\n        return sb;\n    }\n\n    public String next() {\n        return nextSequence().toString();\n    }\n\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n\n    public char nextChar() {\n        if (!hasNextByte()) throw new java.util.NoSuchElementException();\n        return (char) readByte();\n    }\n\n    public char[] nextChars() {\n        StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (32 < b && b < 127 && i < len) {\n            s[i++] = (char) b; b = readByte();\n        }\n        if (i != len) {\n            throw new java.util.NoSuchElementException(\n                String.format(\"Next token has smaller length than expected.\", len)\n            );\n        }\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new java.util.NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n = n * 10 + b - '0';\n            } else if (b == -1 || !(32 < b && b < 127)) {\n                return minus ? -n : n;\n            } else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        return Math.toIntExact(nextLong());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    public void close() {\n        try {\n            in.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends FastScanner {\n    public ExtendedScanner() {super();}\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass FastPrintStream implements AutoCloseable {\n    private static final int BUF_SIZE = 1 << 15;\n    private final byte[] buf = new byte[BUF_SIZE];\n    private int ptr = 0;\n    private final java.lang.reflect.Field strField;\n    private final java.nio.charset.CharsetEncoder encoder;\n\n    private java.io.OutputStream out;\n\n    public FastPrintStream(java.io.OutputStream out) {\n        this.out = out;\n        java.lang.reflect.Field f;\n        try {\n            f = java.lang.String.class.getDeclaredField(\"value\");\n            f.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e) {\n            f = null;\n        }\n        this.strField = f;\n        this.encoder = java.nio.charset.StandardCharsets.US_ASCII.newEncoder();\n    }\n\n    public FastPrintStream(java.io.File file) throws java.io.IOException {\n        this(new java.io.FileOutputStream(file));\n    }\n\n    public FastPrintStream(java.lang.String filename) throws java.io.IOException {\n        this(new java.io.File(filename));\n    }\n\n    public FastPrintStream() {\n        this(System.out);\n        try {\n            java.lang.reflect.Field f = java.io.PrintStream.class.getDeclaredField(\"autoFlush\");\n            f.setAccessible(true);\n            f.set(System.out, false);\n        } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException e) {\n            // ignore\n        }\n    }\n\n    public FastPrintStream println() {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) '\\n';\n        return this;\n    }\n\n    public FastPrintStream println(java.lang.Object o) {\n        return print(o).println();\n    }\n\n    public FastPrintStream println(java.lang.String s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char[] s) {\n        return print(s).println();\n    }\n\n    public FastPrintStream println(char c) {\n        return print(c).println();\n    }\n\n    public FastPrintStream println(int x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(long x) {\n        return print(x).println();\n    }\n\n    public FastPrintStream println(double d, int precision) {\n        return print(d, precision).println();\n    }\n\n    private FastPrintStream print(byte[] bytes) {\n        int n = bytes.length;\n        if (ptr + n > BUF_SIZE) {\n            internalFlush();\n            try {\n                out.write(bytes);\n            } catch (java.io.IOException e) {\n                throw new RuntimeException();\n            }\n        } else {\n            System.arraycopy(bytes, 0, buf, ptr, n);\n            ptr += n;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(java.lang.Object o) {\n        return print(o.toString());\n    }\n\n    public FastPrintStream print(java.lang.String s) {\n        if (strField == null) {\n            return print(s.getBytes());\n        } else {\n            try {\n                Object value = strField.get(s);\n                if (value instanceof byte[]) {\n                    return print((byte[]) value);\n                } else {\n                    return print((char[]) value);\n                }\n            } catch (IllegalAccessException e) {\n                return print(s.getBytes());\n            }\n        }\n    }\n\n    public FastPrintStream print(char[] s) {\n        try {\n            return print(encoder.encode(java.nio.CharBuffer.wrap(s)).array());\n        } catch (java.nio.charset.CharacterCodingException e) {\n            byte[] bytes = new byte[s.length];\n            for (int i = 0; i < s.length; i++) {\n                bytes[i] = (byte) s[i];\n            }\n            return print(bytes);\n        }\n    }\n\n    public FastPrintStream print(char c) {\n        if (ptr == BUF_SIZE) internalFlush();\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public FastPrintStream print(int x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(long x) {\n        if (x == 0) {\n            if (ptr == BUF_SIZE) internalFlush();\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = len(x);\n        if (ptr + d > BUF_SIZE) internalFlush();\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr += d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        return this;\n    }\n\n    public FastPrintStream print(double d, int precision) {\n        if (d < 0) {\n            print('-');\n            d = -d;\n        }\n        d += Math.pow(10, -precision) / 2;\n        print((long) d).print('.');\n        d -= (long) d;\n        for(int i = 0; i < precision; i++){\n            d *= 10;\n            print((int) d);\n            d -= (int) d;\n        }\n        return this;\n    }\n\n    private void internalFlush() {\n        try {\n            out.write(buf, 0, ptr);\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            out.close();\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static int len(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n\n    private static int len(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\n@FunctionalInterface\ninterface IntBiPredicate {\n    static final int INT_BIT = 32;\n    static final long MASK = 0xffff_ffffl;\n    public boolean test(int x, int y);\n    default public IntPredicate curry(final int x) {return y -> test(x, y);}\n    default public LongPredicate toLongPredicate() {return l -> test((int) (l >>> INT_BIT), (int) (l & MASK));}\n    default public IntBiPredicate negate() {return (x, y) -> !test(x, y);}\n    default public IntBiPredicate and(final IntBiPredicate other) {return (x, y) -> test(x, y) && other.test(x, y);}\n    default public IntBiPredicate or(final IntBiPredicate other) {return (x, y) -> test(x, y) || other.test(x, y);}\n    default public IntBiPredicate xor(final IntBiPredicate other) {return (x, y) -> test(x, y) ^ other.test(x, y);}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class Longs {\n    private Longs(){}\n    public static long max(long a, long b) {\n        return Math.max(a, b);\n    }\n    public static long max(long a, long b, long c) {\n        return Math.max(Math.max(a, b), c);\n    }\n    public static long max(long a, long b, long c, long d) {\n        return Math.max(Math.max(Math.max(a, b), c), d);\n    }\n    public static long max(long a, long b, long c, long d, long e) {\n        return Math.max(Math.max(Math.max(Math.max(a, b), c), d), e);\n    }\n    public static long max(long a, long b, long c, long d, long e, long f) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f);\n    }\n    public static long max(long a, long b, long c, long d, long e, long f, long g) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g);\n    }\n    public static long max(long a, long b, long c, long d, long e, long f, long g, long h) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g), h);\n    }\n    public static long max(long a, long... vals) {\n        long ret = a; for (long e : vals) ret = Math.max(ret, e);\n        return ret;\n    }\n    public static long min(long a, long b) {\n        return Math.min(a, b);\n    }\n    public static long min(long a, long b, long c) {\n        return Math.min(Math.min(a, b), c);\n    }\n    public static long min(long a, long b, long c, long d) {\n        return Math.min(Math.min(Math.min(a, b), c), d);\n    }\n    public static long min(long a, long b, long c, long d, long e) {\n        return Math.min(Math.min(Math.min(Math.min(a, b), c), d), e);\n    }\n    public static long min(long a, long b, long c, long d, long e, long f) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f);\n    }\n    public static long min(long a, long b, long c, long d, long e, long f, long g) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g);\n    }\n    public static long min(long a, long b, long c, long d, long e, long f, long g, long h) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g), h);\n    }\n    public static long min(long a, long... vals) {\n        long ret = a; for (long e : vals) ret = Math.min(ret, e);\n        return ret;\n    }\n    public static long fold(final LongBinaryOperator func, final long... a) {\n        long ret = a[0]; for (int i = 1; i < a.length; i++) ret = func.applyAsLong(ret, a[i]);\n        return ret;\n    }\n    public static boolean isPowerOfTwo(final long n) {return n != 0 && (-n & n) == n;}\n    public static int ceilExponent(final long n) {return 63 - Long.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);}\n    public static int floorExponent(final long n) {return 63 - Long.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);}\n    public static int ceilExponent(final long n, final int base) {\n        if (base == 2) return ceilExponent(n);\n        int i = 0;\n        long m = 1;\n        while (m < n) {\n            i++;\n            final long r = m * base;\n            if ((m | base) >> 31 != 0 && r / base != m) break;\n            m = r;\n        }\n        return i;\n    }\n    /**\n     * Caluculate the ceil of a/b. Returns the smallest integer greater than or\n     * equal to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the smallest integer greater than or equal to a/b\n     */\n    public static long cld(final long a, final long b) {\n        if (a > 0 && b > 0) return (a + b - 1) / b;\n        if (a < 0 && b < 0) return (a + b + 1) / b;\n        return a / b;\n    }\n\n    /**\n     * Caluculate the floor of a/b. Returns the largest integer less than or equal\n     * to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the largest integer less than or equal to a/b\n     */\n    public static long fld(final long a, final long b) {\n        if (a <= 0 && b > 0) return (a - b + 1) / b;\n        if (a > 0 && b <= 0) return (a - b - 1) / b;\n        return a / b;\n    }\n    public static String join(final String sep, final long... a) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class Doubling {\n    private final int[][] doubling;\n    private final int height;\n    private final int n;\n    public Doubling(final int[] a, final long maxStep) {\n        this.n = a.length;\n        this.height = Longs.ceilExponent(maxStep) + 2;\n        this.doubling = new int[height][n];\n        build(a);\n    }\n    public int getHeight() {return height;}\n    public int query(int i, long step) {\n        int h = height - 1;\n        while (step > 0) {\n            if ((step & (1l << h)) != 0) {\n                i = doubling[h][i];\n                step ^= 1l << h;\n            }\n            h--;\n        }\n        return i;\n    }\n    public int stepWhile(int i, final IntPredicate p) {\n        int h = height - 1;\n        while (h >= 0) {\n            if (p.test(doubling[h][i])) i = doubling[h][i];\n            h--;\n        }\n        return i;\n    }\n    public int stepUntil(final int i, final IntPredicate p) {return p.test(i) ? i : doubling[0][stepWhile(i, p.negate())];}\n    public int[] biStep(final int u, final int v, final int exponent) {\n        final int us = doubling[exponent][u];\n        final int vs = doubling[exponent][v];\n        return new int[]{us, vs};\n    }\n    private long biStep(final long uv, final int exponent) {\n        final int u = (int) (uv >>> 32);\n        final int v = (int) (uv & 0xffff_ffffl);\n        return (long) doubling[exponent][u] << 32 | doubling[exponent][v];\n    }\n    public int[] biStepWhile(final int u, final int v, final IntBiPredicate p) {\n        final long ret = biStepWhile((long) u << 32 | v, p.toLongPredicate());\n        return new int[]{(int) (ret >> 32), (int) (ret & 0xffff_ffffl)};\n    }\n    private long biStepWhile(long uv, final LongPredicate p) {\n        int h = height - 1;\n        while (h >= 0) {\n            final long step = biStep(uv, h);\n            if (p.test(step)) {\n                uv = step;\n            }\n            h--;\n        }\n        return uv;\n    }\n    public int[] biStepUntil(final int u, final int v, final IntBiPredicate p) {\n        final long ret = biStepUntil((long) u << 32 | v, p.toLongPredicate());\n        return new int[]{(int) (ret >> 32), (int) (ret & 0xffff_ffffl)};\n    }\n    private long biStepUntil(final long uv, final LongPredicate p) {return p.test(uv) ? uv : biStep(biStepWhile(uv, p.negate()), 0);}\n    public int[] parallelStep(final int[] a, final int exponent) {\n        final int[] ret = a.clone();\n        for (int i = 0; i < a.length; i++) ret[i] = doubling[exponent][a[i]];\n        return ret;\n    }\n    private void build(final int[] a) {\n        doubling[0] = a;\n        for (int h = 1; h < height; h++) for (int i = 0; i < n; i++) doubling[h][i] = doubling[h - 1][doubling[h - 1][i]];\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tint[] x = na(n);\n\n\t\tint[] f = new int[n+1];\n\t\tint j = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile (j < n && x[j] < x[i] + K)j++;\n\t\t\tf[i] = j;\n\t\t}\n\t\tf[n] = -1;\n\n\t\tint[] rf = new int[n+1];\n\t\tj = n-1;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\twhile (j >= 0 && x[j] > x[i] - K)j--;\n\t\t\trf[i] = j == -1 ? n : j;\n\t\t}\n\t\trf[n] = -1;\n\n\t\tlong[] dp = new long[n+1];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tdp[i] = dp[f[i]] + i;\n\t\t}\n\t\tint[][] spar = logstepParents(f);\n\n\t\tlong[] rdp = new long[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\trdp[i] = rdp[rf[i]] + i;\n\t\t}\n\t\tint[][] rspar = logstepParents(rf);\n\n\t\tint Q = ni();\n\t\tfor(int z = 0;z < Q;z++){\n\t\t\tint L = ni()-1, R = ni()-1;\n\t\t\tint y = L;\n\t\t\tint up = 0;\n\t\t\tfor(int d = spar.length-1;d >= 0;d--){\n\t\t\t\tint an = spar[d][y];\n\t\t\t\tif(an == -1)continue;\n\t\t\t\tif(an > R)continue;\n\t\t\t\ty = an;\n\t\t\t\tup |= 1<<d;\n\t\t\t}\n\t\t\tint len = up + 1;\n\n\t\t\tlong ans = (rdp[R] - rdp[ancestor(R, len, rspar)]) -\n\t\t\t\t\t(dp[L] - dp[ancestor(L, len, spar)]) + len;\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tpublic static int[][] logstepParents(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpars[j][i] = pars[j-1][i] == -1 ? -1 : pars[j-1][pars[j-1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\tpublic static int ancestor(int a, int m, int[][] spar) {\n\t\tfor(;m > 0 && a != -1;m &= m-1)a = spar[Integer.numberOfTrailingZeros(m)][a];\n\t\treturn a;\n\t}\n\n\n\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\n\n\tpublic static int[][] parents(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][]{par, q, depth};\n\t}\n\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 28); // 256 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n, k;\n        sc.Multi(out n, out k);\n        var x = sc.IntArr;\n        var next = new int[20][];\n        var nextidxsum = new long[20][];\n        {\n            next[0] = new int[n];\n            nextidxsum[0] = new long[n];\n            for (int i = 0, j = 0; i < n; i++)\n            {\n                while (j < n && x[j] - x[i] < k) ++j;\n                next[0][i] = j;\n                nextidxsum[0][i] = j;\n            }\n        }\n        for (int i = 1; i < 20; i++)\n        {\n            next[i] = new int[n];\n            nextidxsum[i] = new long[n];\n            for (int j = 0; j < n; j++)\n            {\n                next[i][j] = next[i - 1][j] == n ? n : next[i - 1][next[i - 1][j]];\n                nextidxsum[i][j] = next[i - 1][j] == n ? LM : nextidxsum[i - 1][j] + nextidxsum[i - 1][next[i - 1][j]];\n            }\n        }\n\n        var prev = new int[20][];\n        var previdxsum = new long[20][];\n        {\n            prev[0] = new int[n];\n            previdxsum[0] = new long[n];\n            for (int i = n - 1, j = n - 1; i >= 0; i--)\n            {\n                while (j >= 0 && x[i] - x[j] < k) --j;\n                prev[0][i] = j;\n                previdxsum[0][i] = j;\n            }\n        }\n        for (int i = 1; i < 20; i++)\n        {\n            prev[i] = new int[n];\n            previdxsum[i] = new long[n];\n            for (int j = 0; j < n; j++)\n            {\n                prev[i][j] = prev[i - 1][j] == -1 ? -1 : prev[i - 1][prev[i - 1][j]];\n                previdxsum[i][j] = prev[i - 1][j] == -1 ? LM : previdxsum[i - 1][j] + previdxsum[i - 1][prev[i - 1][j]];\n            }\n        }\n        int q = sc.Int;\n        for (int _ = 0; _ < q; _++)\n        {\n            int l, r;\n            sc.Multi(out l, out r);\n            --l;\n            --r;\n            int p = l;\n            int c = 0;\n            for (int i = 20 - 1; i >= 0 ; i--)\n            {\n                if (next[i][p] <= r) {\n                    c += 1 << i;\n                    p = next[i][p];\n                }\n            }\n            long lsum = l;\n            p = l;\n            for (int i = 20 - 1; i >= 0 ; i--)\n            {\n                if (((c >> i) & 1) == 1) {\n                    lsum += nextidxsum[i][p];\n                    p = next[i][p];\n                }\n            }\n            long rsum = r;\n            p = r;\n            for (int i = 20 - 1; i >= 0 ; i--)\n            {\n                if (((c >> i) & 1) == 1) {\n                    rsum += previdxsum[i][p];\n                    p = prev[i][p];\n                }\n            }\n            Prt(rsum - lsum + c + 1);\n        }\n\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static IEnumerable<P> adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]));\n    public static IEnumerable<P> adjacents(int i, int j, int h, int w)\n        => adjacents(i, j).Where(p => inside(p.v1, p.v2, h, w));\n    public static IEnumerable<P> adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static IEnumerable<P> adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static IEnumerable<int> all_subset(this int p) {\n        for (int i = 0; ; i = i - p & p) {\n            yield return i;\n            if (i == p) break;\n        }\n    }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.SelectMany(x => x));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => ReadLine.Trim();\n    public string ReadLine => sr.ReadLine();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing CompLib.Util;\nusing System.Threading;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    int N, K;\n    int[] X;\n\n    // iから2^j個後ろ\n    List<int>[] Next, Prev;\n\n    // iから2^j個後ろまでの和(半開区間)\n    List<long>[] FSum, BSum;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        N = sc.NextInt();\n        K = sc.NextInt();\n        X = sc.IntArray();\n\n        Next = new List<int>[N];\n        FSum = new List<long>[N];\n        for (int i = N - 1; i >= 0; i--)\n        {\n            int ok = N;\n            int ng = i;\n            while (ok - ng > 1)\n            {\n                int mid = (ok + ng) / 2;\n                if (X[i] + K <= X[mid]) ok = mid;\n                else ng = mid;\n            }\n            Next[i] = new List<int>();\n            FSum[i] = new List<long>();\n            Next[i].Add(ok);\n            FSum[i].Add(i);\n            int p = 0;\n            while (Next[i][p] < N && p < Next[Next[i][p]].Count)\n            {\n                Next[i].Add(Next[Next[i][p]][p]);\n                FSum[i].Add(FSum[i][p] + FSum[Next[i][p]][p]);\n                p++;\n            }\n        }\n\n        Prev = new List<int>[N];\n        BSum = new List<long>[N];\n        for (int i = 0; i < N; i++)\n        {\n            int ok = -1;\n            int ng = i;\n            while (ng - ok > 1)\n            {\n                int mid = (ok + ng) / 2;\n                if (X[mid] + K <= X[i]) ok = mid;\n                else ng = mid;\n            }\n            Prev[i] = new List<int>();\n            BSum[i] = new List<long>();\n            Prev[i].Add(ok);\n            BSum[i].Add(i);\n            int p = 0;\n            while (Prev[i][p] >= 0 && p < Prev[Prev[i][p]].Count)\n            {\n                Prev[i].Add(Prev[Prev[i][p]][p]);\n                BSum[i].Add(BSum[i][p] + BSum[Prev[i][p]][p]);\n                p++;\n            }\n        }\n\n        int q = sc.NextInt();\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        for (int t = 0; t < q; t++)\n        {\n            int l = sc.NextInt() - 1;\n            int r = sc.NextInt();\n\n            long front = 0;\n            int m = 0;\n            int cur = l;\n            while (Next[cur][0] < r)\n            {\n                for (int i = Next[cur].Count - 1; i >= 0; i--)\n                {\n                    if (Next[cur][i] < r)\n                    {\n                        m += 1 << i;\n                        front += FSum[cur][i];\n                        cur = Next[cur][i];\n                        break;\n                    }\n                }\n            }\n            front += FSum[cur][0];\n            m++;\n\n            long back = 0;\n            cur = r - 1;\n            while (Prev[cur][0] >= l)\n            {\n                for (int i = Prev[cur].Count - 1; i >= 0; i--)\n                {\n                    if (Prev[cur][i] >= l)\n                    {\n                        back += BSum[cur][i];\n                        cur = Prev[cur][i];\n                        break;\n                    }\n                }\n            }\n            back += BSum[cur][0];\n\n\n            // Console.WriteLine($\"{front} {back}\");\n            Console.WriteLine(back - front + m);\n\n        }\n\n        Console.Out.Flush();\n\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n    // public static void Main(string[] args) => new Thread(new Program().Solve, 1 << 27).Start();\n}\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\n\nn,k = map(int,readline().split())\nvs = list(map(int,readline().split()))\n\nL=18\nxid=[0]*(n*L)\nxsum=[0]*(n*L)\nyid=[0]*(n*L)\nysum=[0]*(n*L)\n\nj=n\nfor i in reversed(range(n)):\n\twhile i<j and vs[i]+k<=vs[j-1]:\n\t\tj-=1\n\txid[i*L+0]=j\n\txsum[i*L+0]=j\n\tfor lv in range(1,L):\n\t\ta=xid[i*L+lv-1]\n\t\tif a==n:\n\t\t\txid[i*L+lv]=n\n\t\telse:\n\t\t\txid[i*L+lv]=xid[a*L+lv-1]\n\t\t\txsum[i*L+lv]=xsum[i*L+lv-1]+xsum[a*L+lv-1]\n\nj=-1\nfor i in range(n):\n\twhile j<i and vs[j+1]+k<=vs[i]:\n\t\tj+=1\n\tyid[i*L+0]=j\n\tysum[i*L+0]=j\n\tfor lv in range(1,L):\n\t\ta=yid[i*L+lv-1]\n\t\tif a==-1:\n\t\t\tyid[i*L+lv]=-1\n\t\telse:\n\t\t\tyid[i*L+lv]=yid[a*L+lv-1]\n\t\t\tysum[i*L+lv]=ysum[i*L+lv-1]+ysum[a*L+lv-1]\n\nq=int(readline())\nfor tmp in range(q):\n\tl,r=map(int,readline().split())\n\tl-=1\n\tr-=1\n\tans=0\n\t\n\ti=l\n\tans-=i\n\tfor lv in reversed(range(L)):\n\t\tif xid[i*L+lv]<=r:\n\t\t\tans-=xsum[i*L+lv]\n\t\t\ti=xid[i*L+lv]\n\t\n\ti=r\n\tans+=i+1\n\tfor lv in reversed(range(L)):\n\t\tif yid[i*L+lv]>=l:\n\t\t\tans+=ysum[i*L+lv]+(1<<lv)\n\t\t\ti=yid[i*L+lv]\n\t\n\tprint(ans)\n\t\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nINF = 10**18+3\n\nN, K = map(int, input().split())\nX = list(map(int, readline().split())) + [INF]\n\nleft = [None]*N\nr = 0\n\nfor i in range(N):\n    while r < N and X[r+1] - X[i] < K:\n        r += 1\n    left[i] = (r, i)\nleft = [left]\nnb = N.bit_length()\nfor _ in range(nb):\n    res = [None]*N\n    for idx in range(N):\n        r, i = left[-1][idx]\n        if r >= N-1:\n            res[idx] = (N, None)\n        else:\n            r1, i1 = left[-1][r+1]\n            if r1 == N:\n                res[idx] = (N, None)\n            else:    \n                res[idx] = (r1, i+i1)\n    left.append(res)\n\nright = [None]*N\nl = N-1\n\nfor i in range(N-1, -1, -1):\n    while 0 < l and X[i] - X[l-1] < K:\n        l -= 1\n    right[i] = (l, i)\nright = [right]\nfor _ in range(nb):\n    res = [None]*N\n    for idx in range(N):\n        l, i = right[-1][idx]\n        if l <= 0:\n            res[idx] = (-1, None)\n        else:\n            l1, i1 = right[-1][l-1]\n            if l1 == -1:\n                res[idx] = (-1, None)\n            else:    \n                res[idx] = (l1, i+i1)\n    right.append(res)\n\n\nQ = int(readline())\nAns = [None]*Q\nfor qu in range(Q):\n    l, r = map(int, readline().split())\n    l -= 1\n\n    vn = l\n    li = 0\n    ml = 0\n    for j in range(nb-1, -1, -1):\n        vf, ix = left[j][vn]\n        if vf < r:\n            vn = vf+1\n            li += ix\n            ml += 1<<j\n        if vn >= r:\n            break\n    if vn < r:\n        ml += 1\n        li += vn\n        \n    \n    \n    l -= 1\n    r -= 1\n    vn = r\n    ri = 0\n    mr = 0\n    for j in range(nb-1, -1, -1):\n        vf, ix = right[j][vn]\n        if l < vf:\n            vn = vf-1\n            ri += ix\n            mr += 1<<j\n        if vn <= l:\n            break\n    if l < vn:\n        mr += 1\n        ri += vn\n        \n    Ans[qu] = ri-li + ml\n\nprint('\\n'.join(map(str, Ans)))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nK = 20\n\n@njit((i8[:],i8), cache=True)\ndef build_sp(X, D):\n    INF = 1<<60\n    N = len(X)\n    X = np.append(X, INF)\n    sp = np.empty((K,N+1), np.int64)\n    sp_sum = np.empty((K,N+1), np.int64)\n    sp[0] = np.searchsorted(X, X + D)\n    sp[0,-1] = N\n    sp_sum[0] = sp[0] # 移動先の座標の和\n    for k in range(1, K):\n        for n in range(N+1):\n            to = sp[k-1,n]\n            sp[k][n] = sp[k-1][to]\n            sp_sum[k][n] = sp_sum[k-1,n] + sp_sum[k-1,to]\n    return sp, sp_sum\n\n@njit((i8[:,:],i8[:,:],i8,i8), cache=True)\ndef largest_set(sp, sp_sum, l, r):\n    # 要素数と座標の和\n    ret = [1,l]\n    for k in range(K-1, -1, -1):\n        # 2^k 進めるなら進む\n        if sp[k,l] <= r:\n            ret[0] += 1<<k\n            ret[1] += sp_sum[k,l]\n            l = sp[k,l]\n    return ret\n\n@njit((i8[:],i8,i8[:]), cache=True)\ndef main(X, D, LR):\n    N = len(X)\n    spl, spl_sum = build_sp(X, D)\n    spr, spr_sum = build_sp(-X[::-1], D)\n    for i in range(0, len(LR), 2):\n        l, r = LR[i:i+2]\n        l, r = l-1, r-1\n        cl, sl = largest_set(spl, spl_sum, l,r)\n        cr, sr = largest_set(spr, spr_sum, N-1-r, N-1-l)\n        sr = (N-1)*cr-sr\n        print(cl + sr - sl)\n\nN, D = map(int, readline().split())\nX = np.array(readline().split(), np.int64)\nQ = int(readline())\nLR = np.array(read().split(), np.int64)\n\nmain(X,D,LR)"
  },
  {
    "language": "Rust",
    "code": "// template {{{\n#![allow(clippy::many_single_char_names)]\n\n#[allow(dead_code)]\nmod ngtio {\n    use ::std::collections::VecDeque;\n\n    pub struct Buffer {\n        buf: VecDeque<String>,\n    }\n\n    impl Buffer {\n        pub fn new() -> Self {\n            Self {\n                buf: VecDeque::new(),\n            }\n        }\n\n        fn load(&mut self) {\n            while self.buf.is_empty() {\n                let mut s = String::new();\n                let length = ::std::io::stdin().read_line(&mut s).unwrap();\n                if length == 0 {\n                    break;\n                }\n                self.buf.extend(s.split_whitespace().map(|s| s.to_owned()));\n            }\n        }\n\n        pub fn string(&mut self) -> String {\n            self.load();\n            self.buf\n                .pop_front()\n                .unwrap_or_else(|| panic!(\"入力が終了したのですが。\"))\n        }\n\n        pub fn string_char_vec(&mut self) -> Vec<char> {\n            let s = self.string();\n            s.chars().collect::<Vec<_>>()\n        }\n\n        pub fn string_char_vec_trusted_len(&mut self, len: usize) -> Vec<char> {\n            let s = self.string();\n            let s = s.chars().collect::<Vec<_>>();\n            assert_eq!(s.len(), len, \"あら、思ったのと長さ違いますね……\");\n            s\n        }\n\n        pub fn char(&mut self) -> char {\n            let string = self.string();\n            let mut chars = string.chars();\n            let res = chars.next().unwrap();\n            assert!(\n                chars.next().is_none(),\n                \"char で受け取りたいのも山々なのですが、さては 2 文字以上ありますね？\"\n            );\n            res\n        }\n\n        pub fn read<T: ::std::str::FromStr>(&mut self) -> T\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            self.string()\n                .parse::<T>()\n                .expect(\"Failed to parse the input.\")\n        }\n\n        pub fn read_vec<T: ::std::str::FromStr>(&mut self, len: usize) -> Vec<T>\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            (0..len).map(|_| self.read::<T>()).collect()\n        }\n    }\n\n    macro_rules! define_primitive_reader {\n        ($($ty:tt,)*) => {\n            impl Buffer {\n                $(\n#[inline]\n                    pub fn $ty(&mut self) -> $ty {\n                        self.read::<$ty>()\n                    }\n                )*\n            }\n        }\n    }\n\n    define_primitive_reader! {\n        u8, u16, u32, u64, usize,\n        i8, i16, i32, i64, isize,\n    }\n\n    impl Default for Buffer {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::{collections, iter, mem, ops};\n// }}}\n\nuse type_traits::{wrappers::Add, Assoc};\n\n#[derive(Debug, Clone, PartialEq)]\nstruct Doubling<T: Assoc> {\n    table: Vec<Vec<(usize, T)>>,\n}\nimpl<T: Assoc> Doubling<T> {\n    fn new(a: &[(usize, T)]) -> Self {\n        let mut table = vec![a.to_vec()];\n        for _ in 0..a.len().next_power_of_two().trailing_zeros() {\n            let prv = table.last().unwrap();\n            let mut crr = prv.clone();\n            for i in 0..a.len() {\n                let j = prv[i].0;\n                crr[i] = (prv[j].0, prv[i].1.clone().op(prv[j].1.clone()));\n            }\n            table.push(crr);\n        }\n        Self { table }\n    }\n    // (距離, 終着点, 累積)\n    fn find(\n        &self,\n        start: usize,\n        init: T,\n        mut pred: impl FnMut(usize, &T) -> bool,\n    ) -> (usize, usize, T) {\n        if !pred(start, &init) {\n            let mut d = 0;\n            let mut i = start;\n            let mut value = init;\n            let mut k = 1usize << (self.table.len() - 1);\n\n            for row in self.table.iter().rev() {\n                let next_i = row[i].0;\n                let next_value = value.clone().op(row[i].1.clone());\n                if !pred(next_i, &next_value) {\n                    i = next_i;\n                    value = next_value;\n                    d += k;\n                }\n                k /= 2;\n            }\n            assert!(!pred(i, &value));\n            (\n                d,\n                self.table[0][i].0,\n                value.clone().op(self.table[0][i].1.clone()),\n            )\n        } else {\n            (0, start, init)\n        }\n    }\n}\n\nfn main() {\n    let mut buf = ngtio::Buffer::new();\n    let n = buf.usize();\n    let k = buf.i64();\n    let a = iter::once(std::i64::MIN / 2)\n        .chain(iter::repeat_with(|| buf.i64()).take(n))\n        .chain(iter::once(std::i64::MAX / 2))\n        .collect::<Vec<_>>();\n    let n = a.len();\n\n    let prev = {\n        let mut prev = vec![(0, Add(0)); n];\n        let mut i = n - 1;\n        for j in (1..n).rev() {\n            while a[j] - a[i] < k {\n                i -= 1;\n            }\n            prev[j] = (i, Add(j));\n        }\n        Doubling::new(&prev)\n    };\n    let next = {\n        let mut next = vec![(n - 1, Add(0)); n];\n        let mut j = 0;\n        for i in 0..n - 1 {\n            while a[j] - a[i] < k {\n                j += 1;\n            }\n            next[i] = (j, Add(i));\n        }\n        Doubling::new(&next)\n    };\n\n    for _ in 0..buf.usize() {\n        let l = buf.usize();\n        let r = buf.usize();\n        let (d0, _, Add(min)) = next.find(l, Add(0), |i, _| r < i);\n        let (d1, _, Add(max)) = prev.find(r, Add(0), |i, _| i < l);\n        assert_eq!(d0, d1);\n        let ans = d0 + max - min + 1;\n        println!(\"{}\", ans);\n    }\n}\n// type_traits {{{\n#[allow(dead_code)]\nmod type_traits {\n    #![warn(missing_docs)]\n\n    use std::{cmp, fmt, ops};\n\n    mod primitive {\n        use super::{One, Zero};\n\n        macro_rules! int {\n            ($($T:ty,)*) => {\n                $(\n                    impl Zero for $T {\n                        fn zero() -> $T {\n                            0\n                        }\n                        fn times(self, n: u64) -> $T {\n                            self * n as $T\n                        }\n                        fn times_assign(&mut self, n: u64) {\n                            *self *= n as $T\n                        }\n                        fn from_u64(n: u64) -> $T {\n                            n as $T\n                        }\n                    }\n                    impl One for $T {\n                        fn one() -> $T {\n                            1\n                        }\n                    }\n                )*\n            }\n        }\n\n        int! {\n            u8, u16, u32, u64, u128, usize,\n            i8, i16, i32, i64, i128, isize,\n        }\n    }\n\n    pub mod wrappers {\n        use super::{Assoc, Element, Identity, One, Zero};\n        use std::ops;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Add<T>(pub T);\n        impl<T> Assoc for Add<T>\n        where\n            T: ops::Add<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Add(self.0 + rhs.0)\n            }\n        }\n        impl<T> Identity for Add<T>\n        where\n            T: Zero,\n        {\n            fn identity() -> Self {\n                Add(T::zero())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Mul<T>(pub T);\n\n        impl<T> Assoc for Mul<T>\n        where\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Mul(self.0 * rhs.0)\n            }\n        }\n        impl<T> Identity for Mul<T>\n        where\n            T: One,\n        {\n            fn identity() -> Self {\n                Mul(T::one())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Affine<T> {\n            pub a: T,\n            pub b: T,\n        }\n\n        impl<T> Assoc for Affine<T>\n        where\n            T: ops::Add<Output = T> + Element,\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Self {\n                    a: self.a.clone() * rhs.a,\n                    b: self.b + self.a * rhs.b,\n                }\n            }\n        }\n        impl<T> Identity for Affine<T>\n        where\n            T: Zero + One,\n        {\n            fn identity() -> Self {\n                Self {\n                    a: T::one(),\n                    b: T::zero(),\n                }\n            }\n        }\n\n        #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Cat(pub String);\n\n        impl Assoc for Cat {\n            fn op(self, rhs: Self) -> Self {\n                Cat(self.0.chars().chain(rhs.0.chars()).collect())\n            }\n        }\n        impl Identity for Cat {\n            fn identity() -> Self {\n                Cat(String::new())\n            }\n        }\n    }\n\n    pub trait Element: Sized + Clone + PartialEq + fmt::Debug {}\n    impl<T: Sized + Clone + PartialEq + fmt::Debug> Element for T {}\n\n    pub trait Assoc: Element {\n        fn op(self, rhs: Self) -> Self;\n\n        fn op_from_left(&mut self, left: &Self) {\n            *self = Self::op(left.clone(), self.clone());\n        }\n\n        fn op_from_right(&mut self, right: &Self) {\n            *self = Self::op(self.clone(), right.clone());\n        }\n    }\n\n    pub trait Identity: Assoc {\n        fn identity() -> Self;\n    }\n\n    pub trait Zero: ops::Add<Output = Self> + ops::AddAssign + Element {\n        fn zero() -> Self;\n\n        fn is_zero(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::zero()\n        }\n\n        fn times(self, n: u64) -> Self;\n\n        fn times_assign(&mut self, n: u64);\n\n        fn from_u64(x: u64) -> Self;\n    }\n\n    pub trait One: ops::Mul<Output = Self> + ops::MulAssign + Element {\n        fn one() -> Self;\n\n        fn is_one(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::one()\n        }\n    }\n\n    pub trait Ring: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign {}\n    impl<T: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign> Ring for T {}\n\n    #[macro_export]\n    macro_rules! define_constant {\n        ($(#[$attr:meta])? $vis:vis type $wrapper_type:ident: $value_type:ty = $value:expr;) => {\n            $(#[$attr])?\n            #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n            $vis struct $wrapper_type {}\n\n            impl Constant for $wrapper_type {\n                type Output = $value_type;\n                const VALUE: Self::Output = $value;\n            }\n        };\n    }\n\n    pub trait Constant: Copy {\n        type Output: Copy;\n\n        const VALUE: Self::Output;\n    }\n}\n// }}}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::marker::*;\nuse proconio::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::Bound::*;\n\n// 左から貪欲に取っていけばサイズは分かる\n// ダブリングでよい集合のサイズがlogで分かる\n// Kは固定\n// ダブリングじゃなくてセグ木でも可能 -> 嘘\n//\n// 和集合のサイズ?\n// Q=1なら各要素の直近の右、左で最大サイズ作れるかで含まれるかが分かる\n// 毎回これするのは無理\n// 極大...というとアレだが各点から貪欲に構成した良い集合のサイズは最大か最大-1\n// うーん\n//\n// 左から貪欲した点、右から貪欲した点で適切な範囲の点が答え\n// ダブリングに和を持たせる？\n\n#[fastout]\nfn run() {\n    input! {\n        n: usize,\n        k: i64,\n        mut x: [i64; n],\n        q: usize,\n        ask: [(usize, usize); q],\n    }\n    let inf = 10i64.pow(10);\n    x.insert(0, -inf);\n    x.push(inf);\n    let x = x;\n    let mut right = vec![(n + 1, n + 1); n + 2];\n    {\n        let mut r = 0;\n        for i in 1..=n {\n            while x[r] - x[i] < k {\n                r += 1;\n            }\n            right[i] = (r, i);\n        }\n//        println!(\"{:?}\", right);\n    }\n    let mut left = vec![(0, 0); n + 2];\n    {\n        let mut l = n + 1;\n        for i in (1..=n).rev() {\n            while x[i] - x[l] < k {\n                l -= 1;\n            }\n            left[i] = (l, i);\n        }\n//        println!(\"{:?}\", left);\n    }\n    let mut memo_r = vec![];\n    while right.iter().any(|p| p.0 < n + 1) {\n        let mut next = right.clone();\n        for (next, &(a, b)) in next.iter_mut().zip(right.iter()) {\n            let (x, y) = right[a];\n            *next = (x, y + b);\n        }\n        memo_r.push(right);\n        right = next;\n    }\n    memo_r.push(right);\n    let right = memo_r;\n    let mut memo_l = vec![];\n    while left.iter().any(|p| p.0 > 0) {\n        let mut next = left.clone();\n        for (next, &(a, b)) in next.iter_mut().zip(left.iter()) {\n            let (x, y) = left[a];\n            *next = (x, y + b);\n        }\n        memo_l.push(left);\n        left = next;\n    }\n    memo_l.push(left);\n    let left = memo_l;\n    for (l, r) in ask {\n        let mut cnt = 0;\n        let mut sum = 0;\n        let mut pos = r;\n        /*\n        for (i, x) in left.iter().enumerate().rev() {\n            if x[pos].0 >= l {\n                cnt += 1 << i;\n                sum += x[pos].1;\n                pos = x[pos].0;\n            }\n        }\n        */\n        while left[0][pos].0 >= l {\n            cnt += 1;\n            sum += left[0][pos].1;\n            pos = left[0][pos].0;\n        }\n        sum += pos;\n        cnt += 1;\n        let mut pos = l;\n        /*\n        for (i, x) in right.iter().enumerate().rev() {\n            if x[pos].0 <= r {\n                sum -= x[pos].1;\n                pos = x[pos].0;\n            }\n        }\n        */\n        while right[0][pos].0 <= r {\n            sum -= right[0][pos].1;\n            pos = right[0][pos].0;\n        }\n        sum -= pos;\n        let ans = sum + cnt;\n        println!(\"{}\", ans);\n        //        println!(\"{} {} {}\", sum, cnt, ans);\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } );\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String );\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B );\n    iter_scan_tuple_impl !(A B C );\n    iter_scan_tuple_impl !(A B C D );\n    iter_scan_tuple_impl !(A B C D E );\n    iter_scan_tuple_impl !(A B C D E F );\n    iter_scan_tuple_impl !(A B C D E F G );\n    iter_scan_tuple_impl !(A B C D E F G H );\n    iter_scan_tuple_impl !(A B C D E F G H I );\n    iter_scan_tuple_impl !(A B C D E F G H I J );\n    iter_scan_tuple_impl !(A B C D E F G H I J K );\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let k = scan!();\n    let x = scan!([usize; n]);\n    let q = scan!();\n    let lr = scan!([(marker::Usize1, usize)]).take(q);\n    const M: usize = 18;\n    let mut lt = vec![vec![(n, 0); n + 1]; M + 1];\n    {\n        let mut s = 0;\n        for i in 0..n {\n            while s < n && x[s] - x[i] < k {\n                s += 1;\n            }\n            if s < n {\n                lt[0][i] = (s, i + 1);\n            }\n        }\n        for d in 0..M {\n            for i in 0..n {\n                let (j, a) = lt[d][i];\n                if j == n {\n                    break;\n                }\n                let (k, b) = lt[d][j];\n                lt[d + 1][i] = (k, a + b);\n            }\n        }\n    }\n    let mut rt = vec![vec![(0, 0); n + 1]; M + 1];\n    {\n        let mut s = n;\n        for i in (1..=n).rev() {\n            while s > 0 && x[i - 1] - x[s - 1] < k {\n                s -= 1;\n            }\n            if s > 0 {\n                rt[0][i] = (s, i + 1);\n            }\n        }\n        for d in 0..M {\n            for i in (1..=n).rev() {\n                let (j, a) = rt[d][i];\n                if j == 0 {\n                    break;\n                }\n                let (k, b) = rt[d][j];\n                rt[d + 1][i] = (k, a + b);\n            }\n        }\n    }\n    for (l, r) in lr {\n        let mut ans = 0isize;\n        {\n            let mut s = l;\n            for d in (0..=M).rev() {\n                let (i, a) = lt[d][s];\n                if i < r {\n                    ans -= a as isize;\n                    s = i;\n                }\n            }\n            ans -= s as isize;\n        }\n        {\n            let mut t = r;\n            for d in (0..=M).rev() {\n                let (i, a) = rt[d][t];\n                if l < i {\n                    ans += a as isize;\n                    t = i;\n                }\n            }\n            ans += t as isize;\n        }\n        println!(\"{}\", ans);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::marker::*;\nuse proconio::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::Bound::*;\n\n// 左から貪欲に取っていけばサイズは分かる\n// ダブリングでよい集合のサイズがlogで分かる\n// Kは固定\n// ダブリングじゃなくてセグ木でも可能 -> 嘘\n//\n// 和集合のサイズ?\n// Q=1なら各要素の直近の右、左で最大サイズ作れるかで含まれるかが分かる\n// 毎回これするのは無理\n// 極大...というとアレだが各点から貪欲に構成した良い集合のサイズは最大か最大-1\n// うーん\n//\n// 左から貪欲した点、右から貪欲した点で適切な範囲の点が答え\n// ダブリングに和を持たせる？\n\n#[fastout]\nfn run() {\n    input! {\n        n: usize,\n        k: i64,\n        mut x: [i64; n],\n        q: usize,\n        ask: [(usize, usize); q],\n    }\n    let inf = 10i64.pow(10);\n    x.insert(0, -inf);\n    x.push(inf);\n    let x = x;\n    let mut right = vec![(n + 1, n + 1); n + 2];\n    {\n        let mut r = 0;\n        for i in 1..=n {\n            while x[r] - x[i] < k {\n                r += 1;\n            }\n            right[i] = (r, i);\n        }\n//        println!(\"{:?}\", right);\n    }\n    let mut left = vec![(0, 0); n + 2];\n    {\n        let mut l = n + 1;\n        for i in (1..=n).rev() {\n            while x[i] - x[l] < k {\n                l -= 1;\n            }\n            left[i] = (l, i);\n        }\n//        println!(\"{:?}\", left);\n    }\n    let mut memo_r = vec![];\n    while right.iter().any(|p| p.0 < n + 1) {\n        let mut next = right.clone();\n        for (next, &(a, b)) in next.iter_mut().zip(right.iter()) {\n            let (x, y) = right[a];\n            *next = (x, y + b);\n        }\n        memo_r.push(right);\n        right = next;\n    }\n    memo_r.push(right);\n    let right = memo_r;\n    let mut memo_l = vec![];\n    while left.iter().any(|p| p.0 > 0) {\n        let mut next = left.clone();\n        for (next, &(a, b)) in next.iter_mut().zip(left.iter()) {\n            let (x, y) = left[a];\n            *next = (x, y + b);\n        }\n        memo_l.push(left);\n        left = next;\n    }\n    memo_l.push(left);\n    let left = memo_l;\n    for (l, r) in ask {\n        let mut cnt = 0;\n        let mut sum = 0;\n        let mut pos = r;\n        for (i, x) in left.iter().enumerate().rev() {\n            if x[pos].0 >= l {\n                cnt += 1 << i;\n                sum += x[pos].1;\n                pos = x[pos].0;\n            }\n        }\n        while left[0][pos].0 >= l {\n            cnt += 1;\n            sum += left[0][pos].1;\n            pos = left[0][pos].0;\n        }\n        sum += pos;\n        cnt += 1;\n        let mut pos = l;\n        for (i, x) in right.iter().enumerate().rev() {\n            if x[pos].0 <= r {\n                sum -= x[pos].1;\n                pos = x[pos].0;\n            }\n        }\n        while right[0][pos].0 <= r {\n            sum -= right[0][pos].1;\n            pos = right[0][pos].0;\n        }\n        sum -= pos;\n        let ans = sum + cnt;\n        println!(\"{}\", ans);\n        //        println!(\"{} {} {}\", sum, cnt, ans);\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } );\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String );\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B );\n    iter_scan_tuple_impl !(A B C );\n    iter_scan_tuple_impl !(A B C D );\n    iter_scan_tuple_impl !(A B C D E );\n    iter_scan_tuple_impl !(A B C D E F );\n    iter_scan_tuple_impl !(A B C D E F G );\n    iter_scan_tuple_impl !(A B C D E F G H );\n    iter_scan_tuple_impl !(A B C D E F G H I );\n    iter_scan_tuple_impl !(A B C D E F G H I J );\n    iter_scan_tuple_impl !(A B C D E F G H I J K );\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let k = scan!();\n    let x = scan!([usize; n]);\n    let q = scan!();\n    let lr = scan!([(marker::Usize1, usize)]).take(q);\n    let mut lt = vec![vec![(n, 0); n + 1]; 20];\n    {\n        let mut s = 0;\n        for i in 0..n {\n            while s < n && x[s] - x[i] < k {\n                s += 1;\n            }\n            if s < n {\n                lt[0][i] = (s, i + 1);\n            }\n        }\n        for d in 0..19 {\n            for i in 0..n {\n                let (j, a) = lt[d][i];\n                let (k, b) = lt[d][j];\n                lt[d + 1][i] = (k, a + b);\n            }\n        }\n    }\n    let mut rt = vec![vec![(0, 0); n + 1]; 20];\n    {\n        let mut s = n;\n        for i in (1..=n).rev() {\n            while s > 0 && x[i - 1] - x[s - 1] < k {\n                s -= 1;\n            }\n            if s > 0 {\n                rt[0][i] = (s, i + 1);\n            }\n        }\n        for d in 0..19 {\n            for i in 1..=n {\n                let (j, a) = rt[d][i];\n                let (k, b) = rt[d][j];\n                rt[d + 1][i] = (k, a + b);\n            }\n        }\n    }\n    for (l, r) in lr {\n        let mut ans = 0isize;\n        {\n            let mut s = l;\n            for d in (0..20).rev() {\n                let (i, a) = lt[d][s];\n                if i < r {\n                    ans -= a as isize;\n                    s = i;\n                }\n            }\n            ans -= s as isize;\n        }\n        {\n            let mut t = r;\n            for d in (0..20).rev() {\n                let (i, a) = rt[d][t];\n                if l < i {\n                    ans += a as isize;\n                    t = i;\n                }\n            }\n            ans += t as isize;\n        }\n        println!(\"{}\", ans);\n    }\n}\n"
  }
]