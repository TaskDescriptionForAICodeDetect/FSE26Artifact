[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint points[MAX_N];\nint N, K;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint solve_query(int L, int R) {\n    int good_set[MAX_N];\n    int good_set_size = 0;\n    int last_point = -1000000001;\n\n    for (int i = L; i <= R; i++) {\n        if (points[i] - last_point >= K) {\n            good_set[good_set_size++] = points[i];\n            last_point = points[i];\n        }\n    }\n\n    return good_set_size;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &points[i]);\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n\n    while (Q--) {\n        int L, R;\n        scanf(\"%d %d\", &L, &R);\n        printf(\"%d\\n\", solve_query(L, R));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K, Q;\n    scanf(\"%d %d %d\", &N, &K, &Q);\n    \n    int *X = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    \n    while (Q--) {\n        int L, R;\n        scanf(\"%d %d\", &L, &R);\n        \n        int count = 0;\n        int last = -1e9 - 10;\n        \n        for (int i = L; i <= R; i++) {\n            if (X[i] - last >= K) {\n                count++;\n                last = X[i];\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    \n    free(X);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, K, Q;\n    cin >> N >> K >> Q;\n    vector<int> X(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> X[i];\n    }\n\n    vector<vector<int>> dp(N + 2, vector<int>(N + 2, 0));\n    for (int l = 1; l <= N; ++l) {\n        int last = -1e9 - 10;\n        int cnt = 0;\n        for (int r = l; r <= N; ++r) {\n            if (X[r] - last >= K) {\n                ++cnt;\n                last = X[r];\n            }\n            dp[l][r] = cnt;\n        }\n    }\n\n    vector<vector<int>> union_size(N + 2, vector<int>(N + 2, 0));\n    for (int l = N; l >= 1; --l) {\n        for (int r = l; r <= N; ++r) {\n            if (l == r) {\n                union_size[l][r] = 1;\n            } else {\n                union_size[l][r] = union_size[l + 1][r] + union_size[l][r - 1] - union_size[l + 1][r - 1];\n                if (dp[l][r] != dp[l + 1][r] && dp[l][r] != dp[l][r - 1]) {\n                    union_size[l][r] += 1;\n                }\n            }\n        }\n    }\n\n    while (Q--) {\n        int L, R;\n        cin >> L >> R;\n        cout << union_size[L][R] << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int Q = scanner.nextInt();\n        int[] X = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            X[i] = scanner.nextInt();\n        }\n\n        int[][] dp = new int[N + 2][N + 2];\n        for (int len = 1; len <= N; len++) {\n            for (int l = 1; l + len - 1 <= N; l++) {\n                int r = l + len - 1;\n                if (len == 1) {\n                    dp[l][r] = 1;\n                } else {\n                    int max = Math.max(dp[l + 1][r], dp[l][r - 1]);\n                    if (X[r] - X[l] >= K) {\n                        max = Math.max(max, dp[l + 1][r - 1] + 2);\n                    }\n                    dp[l][r] = max;\n                }\n            }\n        }\n\n        for (int q = 0; q < Q; q++) {\n            int L = scanner.nextInt();\n            int R = scanner.nextInt();\n            System.out.println(dp[L][R]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:24:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int[] X = new int[N];\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            X[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        int K = Integer.parseInt(br.readLine());\n        int Q = Integer.parseInt(br.readLine());\n        \n        for (int q = 0; q < Q; q++) {\n            st = new StringTokenizer(br.readLine());\n            int L = Integer.parseInt(st.nextToken()) - 1;\n            int R = Integer.parseInt(st.nextToken()) - 1;\n            \n            bw.write(findMaxGoodSetSize(X, L, R, K) + \"\\n\");\n        }\n        \n        bw.flush();\n        bw.close();\n        br.close();\n    }\n    \n    private static int findMaxGoodSetSize(int[] X, int L, int R, int K) {\n        int[] subarray = Arrays.copyOfRange(X, L, R + 1);\n        return findMaxSizeSet(subarray, K);\n    }\n    \n    private static int findMaxSizeSet(int[] arr, int K) {\n        if (arr.length == 0) return 0;\n        \n        Arrays.sort(arr);\n        List<Integer> goodSet = new ArrayList<>();\n        goodSet.add(arr[0]);\n        \n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] - goodSet.get(goodSet.size() - 1) >= K) {\n                goodSet.add(arr[i]);\n            }\n        }\n        \n        return goodSet.size();\n    }\n}",
    "timestamp": "2025-08-05 22:24:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N, K, Q;\n    cin >> N >> K >> Q;\n    \n    vector<int> X(N + 1);\n    for (int i = 1; i <= N; i++) {\n        cin >> X[i];\n    }\n    \n    while (Q--) {\n        int L, R;\n        cin >> L >> R;\n        \n        vector<int> points(X.begin() + L, X.begin() + R + 1);\n        vector<bool> used(points.size(), false);\n        int maxSize = 0;\n        \n        for (int i = 0; i < points.size(); i++) {\n            if (!used[i]) {\n                used[i] = true;\n                maxSize++;\n                \n                for (int j = i + 1; j < points.size(); j++) {\n                    if (!used[j] && points[j] - points[i] >= K) {\n                        used[j] = true;\n                    }\n                }\n            }\n        }\n        \n        cout << maxSize << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_max_good_set_size(N, coordinates, K, queries):\n    result = []\n    \n    for L, R in queries:\n        count = 1\n        last_position = coordinates[L-1]\n        \n        for i in range(L, R):\n            if coordinates[i] - last_position >= K:\n                count += 1\n                last_position = coordinates[i]\n        \n        result.append(count)\n        \n    return result\n\n# Example usage:\nN = 5\ncoordinates = [1, 3, 5, 7, 9]\nK = 2\nqueries = [(1, 3), (2, 5), (1, 5)]\n\nprint(find_max_good_set_size(N, coordinates, K, queries))\n# Expected output: [2, 3, 5]",
    "timestamp": "2025-08-13 10:26:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GoodSetProblem {\n\n    public static int findMaxGoodSetSize(int[] points, int l, int r, int k) {\n        int maxSize = 0;\n        int last = points[l];\n        maxSize++;\n        for (int i = l + 1; i <= r; i++) {\n            if (points[i] - last >= k) {\n                maxSize++;\n                last = points[i];\n            }\n        }\n        return maxSize;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt(); // number of points\n        int[] points = new int[n];\n        for (int i = 0; i < n; i++) {\n            points[i] = scanner.nextInt();\n        }\n\n        int k = scanner.nextInt(); // integer K\n        int q = scanner.nextInt(); // number of queries\n\n        for (int i = 0; i < q; i++) {\n            int l = scanner.nextInt() - 1; // L_i\n            int r = scanner.nextInt() - 1; // R_i\n            int maxSize = findMaxGoodSetSize(points, l, r, k);\n            System.out.println(maxSize);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:26:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint maxGoodSetSize(int *X, int L, int R, int K) {\n    int size = 0, lastChosen = X[L];\n    for (int i = L; i <= R; i++) {\n        if (i == L || X[i] - lastChosen >= K) {\n            size++;\n            lastChosen = X[i];\n        }\n    }\n    return size;\n}\n\nint main() {\n    int N, K, Q;\n    \n    // Read input values: N, K, then points\n    scanf(\"%d %d\", &N, &K);\n    int X[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    \n    // Read number of queries\n    scanf(\"%d\", &Q);\n    for (int q = 0; q < Q; q++) {\n        int L, R;\n        scanf(\"%d %d\", &L, &R);\n        L--; // Convert to zero-based index\n        R--; // Convert to zero-based index\n        \n        int size = maxGoodSetSize(X, L, R, K);\n        printf(\"%d\\n\", size);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:26:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points_with_distance(N, X, K, Q, queries):\n    result = []\n    \n    for L, R in queries:\n        # Extract points in the range [L, R]\n        points = X[L-1:R]\n        \n        # Greedy algorithm to select maximum points with distance >= K\n        selected = []\n        \n        if points:\n            selected.append(points[0])\n            \n            for point in points[1:]:\n                if point - selected[-1] >= K:\n                    selected.append(point)\n        \n        result.append(len(selected))\n    \n    return result\n\n# Input reading\nN = int(input())\nX = list(map(int, input().split()))\nK = int(input())\nQ = int(input())\n\nqueries = []\nfor _ in range(Q):\n    L, R = map(int, input().split())\n    queries.append((L, R))\n\n# Solve and print results\noutput = max_points_with_distance(N, X, K, Q, queries)\nfor val in output:\n    print(val)",
    "timestamp": "2025-08-13 10:26:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, K, Q = map(int, input[ptr:ptr+3])\n    ptr +=3\n    X = list(map(int, input[ptr:ptr+N]))\n    ptr +=N\n    \n    # Precompute for each query the union of all maximal sets\n    # The union is simply the set of all points that can be part of any maximal set\n    # For a given interval [L, R], the union is the points selected by the greedy approach\n    # plus any points that could replace any selected point in some maximal set.\n    # However, the union of all maximal sets is actually the same as the greedy selection.\n    # Because any point not in the greedy selection cannot be in any maximal set.\n    # So the answer is the size of the greedy selection.\n    \n    # Precompute for each L and R, the size of the greedy selection\n    # The greedy selection is to pick the first possible, then next >= current + K, etc.\n    # To answer queries quickly, we can precompute a DP table.\n    \n    # Precompute next array: next[i] is the smallest j > i such that X[j] >= X[i] + K\n    next_pos = [0]*N\n    j = 0\n    for i in range(N):\n        while j < N and X[j] - X[i] < K:\n            j +=1\n        if j < N:\n            next_pos[i] = j\n        else:\n            next_pos[i] = N  # indicates no next\n    \n    # Precompute binary lifting tables for the next_pos array\n    LOG = 20\n    up = [[0]*N for _ in range(LOG)]\n    up[0] = next_pos.copy()\n    for k in range(1, LOG):\n        for i in range(N):\n            if up[k-1][i] < N:\n                up[k][i] = up[k-1][up[k-1][i]]\n            else:\n                up[k][i] = N\n    \n    # Function to compute the size of the greedy set for [L, R] (0-based)\n    def query_size(L, R):\n        res = 0\n        current = L\n        for k in range(LOG-1, -1, -1):\n            if up[k][current] <= R:\n                res += (1 << k)\n                current = up[k][current]\n        if current <= R:\n            res +=1\n        return res\n    \n    # Process queries\n    output = []\n    for _ in range(Q):\n        L, R = map(int, input[ptr:ptr+2])\n        ptr +=2\n        L -=1  # convert to 0-based\n        R -=1\n        output.append(query_size(L, R))\n    \n    print('\\n'.join(map(str, output)))\n\nsolve()",
    "timestamp": "2025-08-13 10:27:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint maxGoodSetSize(const vector<int>& X, int L, int R, int K) {\n    int count = 1;\n    int lastChosen = X[L];\n    for (int i = L + 1; i <= R; ++i) {\n        if (X[i] - lastChosen >= K) {\n            count++;\n            lastChosen = X[i];\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N, Q, K;\n    cin >> N >> Q >> K;\n    vector<int> X(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i];\n    }\n    \n    while (Q--) {\n        int L, R;\n        cin >> L >> R;\n        --L; --R; // zero-index adjustment\n        cout << maxGoodSetSize(X, L, R, K) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:59:02"
  }
]