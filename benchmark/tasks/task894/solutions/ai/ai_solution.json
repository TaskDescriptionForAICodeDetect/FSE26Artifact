[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n\n#define MAX_N 100005\n#define MAX_COORD 100000000\n\ntypedef struct {\n    int x, y;\n} Intersection;\n\ntypedef struct {\n    int street, avenue;\n} Fountain;\n\nFountain fountains[MAX_N];\nint fountain_count = 0;\nint fountain_street[MAX_COORD] = {0};\nint fountain_avenue[MAX_COORD] = {0};\n\nlong long manhattan_distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) * 100LL + abs(y1 - y2) * 100LL;\n}\n\nlong long solve_route(int x1, int y1, int x2, int y2) {\n    if (x1 == x2 && y1 == y2) return 0;\n\n    long long direct_path = manhattan_distance(x1, y1, x2, y2);\n\n    if (fountain_street[y1] == 0 && fountain_street[y2] == 0 &&\n        fountain_avenue[x1] == 0 && fountain_avenue[x2] == 0) {\n        return direct_path;\n    }\n\n    long long min_path = LLONG_MAX;\n\n    for (int i = 0; i < fountain_count; i++) {\n        for (int j = 0; j < fountain_count; j++) {\n            if (i == j) continue;\n\n            Fountain f1 = fountains[i];\n            Fountain f2 = fountains[j];\n\n            long long path1 = manhattan_distance(x1, y1, f1.avenue, f1.street) +\n                              manhattan_distance(f1.avenue, f1.street, f2.avenue, f2.street) +\n                              manhattan_distance(f2.avenue, f2.street, x2, y2);\n\n            min_path = fmin(min_path, path1);\n        }\n    }\n\n    return fmin(direct_path, min_path);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        fountains[fountain_count].avenue = x;\n        fountains[fountain_count].street = y;\n        fountain_street[y] = 1;\n        fountain_avenue[x] = 1;\n        fountain_count++;\n    }\n\n    while (Q--) {\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        printf(\"%lld\\n\", solve_route(x1, y1, x2, y2));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    Point *pointA = (Point *)a;\n    Point *pointB = (Point *)b;\n    return (pointA->x - pointB->x);\n}\n\nint compareY(const void *a, const void *b) {\n    Point *pointA = (Point *)a;\n    Point *pointB = (Point *)b;\n    return (pointA->y - pointB->y);\n}\n\nint lowerBoundX(Point *fountains, int N, int x) {\n    int left = 0, right = N;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (fountains[mid].x < x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n\nint lowerBoundY(Point *fountains, int N, int y) {\n    int left = 0, right = N;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (fountains[mid].y < y) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nlong long calculateDistance(int x1, int y1, int x2, int y2) {\n    return (long long)abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point *fountains = malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &fountains[i].x, &fountains[i].y);\n    }\n\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\n    Point *sortedX = malloc(N * sizeof(Point));\n    Point *sortedY = malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        sortedX[i] = fountains[i];\n        sortedY[i] = fountains[i];\n    }\n    qsort(sortedX, N, sizeof(Point), compareX);\n    qsort(sortedY, N, sizeof(Point), compareY);\n\n    long long directDistance = calculateDistance(x1, y1, x2, y2) * 100LL;\n\n    long long minDistance = directDistance;\n\n    int idxX1 = lowerBoundX(sortedX, N, x1);\n    int idxX2 = lowerBoundX(sortedX, N, x2);\n    int idxY1 = lowerBoundY(sortedY, N, y1);\n    int idxY2 = lowerBoundY(sortedY, N, y2);\n\n    for (int i = -1; i <= 0; i++) {\n        if (idxX1 + i >= 0 && idxX1 + i < N) {\n            int fx = sortedX[idxX1 + i].x;\n            int fy = sortedX[idxX1 + i].y;\n            for (int j = -1; j <= 0; j++) {\n                if (idxY2 + j >= 0 && idxY2 + j < N) {\n                    int tx = sortedY[idxY2 + j].x;\n                    int ty = sortedY[idxY2 + j].y;\n                    long long d = calculateDistance(x1, y1, fx, fy) * 100LL + \n                                  calculateDistance(fx, fy, tx, ty) * 100LL + \n                                  calculateDistance(tx, ty, x2, y2) * 100LL;\n                    minDistance = min(minDistance, d);\n                }\n            }\n        }\n    }\n\n    for (int i = -1; i <= 0; i++) {\n        if (idxY1 + i >= 0 && idxY1 + i < N) {\n            int fx = sortedY[idxY1 + i].x;\n            int fy = sortedY[idxY1 + i].y;\n            for (int j = -1; j <= 0; j++) {\n                if (idxX2 + j >= 0 && idxX2 + j < N) {\n                    int tx = sortedX[idxX2 + j].x;\n                    int ty = sortedX[idxX2 + j].y;\n                    long long d = calculateDistance(x1, y1, fx, fy) * 100LL + \n                                  calculateDistance(fx, fy, tx, ty) * 100LL + \n                                  calculateDistance(tx, ty, x2, y2) * 100LL;\n                    minDistance = min(minDistance, d);\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", minDistance);\n\n    free(fountains);\n    free(sortedX);\n    free(sortedY);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i] >> Y[i];\n    }\n\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    vector<int> x_coords = {x1, x2};\n    vector<int> y_coords = {y1, y2};\n    for (int x : X) x_coords.push_back(x);\n    for (int y : Y) y_coords.push_back(y);\n\n    sort(x_coords.begin(), x_coords.end());\n    x_coords.erase(unique(x_coords.begin(), x_coords.end()), x_coords.end());\n    sort(y_coords.begin(), y_coords.end());\n    y_coords.erase(unique(y_coords.begin(), y_coords.end()), y_coords.end());\n\n    int x1_pos = lower_bound(x_coords.begin(), x_coords.end(), x1) - x_coords.begin();\n    int x2_pos = lower_bound(x_coords.begin(), x_coords.end(), x2) - x_coords.begin();\n    int y1_pos = lower_bound(y_coords.begin(), y_coords.end(), y1) - y_coords.begin();\n    int y2_pos = lower_bound(y_coords.begin(), y_coords.end(), y2) - y_coords.begin();\n\n    int m = x_coords.size();\n    int n = y_coords.size();\n    vector<vector<long long>> dist(m, vector<long long>(n, LLONG_MAX));\n    dist[x1_pos][y1_pos] = 0;\n\n    vector<pair<int, int>> queue = {{x1_pos, y1_pos}};\n    for (size_t i = 0; i < queue.size(); ++i) {\n        int cx = queue[i].first;\n        int cy = queue[i].second;\n        long long current_dist = dist[cx][cy];\n\n        // Check adjacent cells\n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                if (dx * dy != 0) continue; // Only horizontal or vertical moves\n                int nx = cx + dx;\n                int ny = cy + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                    long long new_dist = current_dist;\n                    if (dx != 0) {\n                        new_dist += abs(x_coords[nx] - x_coords[cx]) * 100LL;\n                    } else {\n                        new_dist += abs(y_coords[ny] - y_coords[cy]) * 100LL;\n                    }\n                    if (new_dist < dist[nx][ny]) {\n                        dist[nx][ny] = new_dist;\n                        queue.emplace_back(nx, ny);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dist[x2_pos][y2_pos] << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class NevermoreCity {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] X = new int[N];\n        int[] Y = new int[N];\n        for (int i = 0; i < N; i++) {\n            X[i] = scanner.nextInt();\n            Y[i] = scanner.nextInt();\n        }\n        int x1 = scanner.nextInt();\n        int y1 = scanner.nextInt();\n        int x2 = scanner.nextInt();\n        int y2 = scanner.nextInt();\n\n        // Manhattan distance without fountains\n        long directDistance = 100L * (Math.abs(x1 - x2) + Math.abs(y1 - y2));\n\n        // Find closest fountain to (x1, y1) and (x2, y2)\n        long minDist1 = Long.MAX_VALUE;\n        long minDist2 = Long.MAX_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            long dist1 = 100L * (Math.abs(x1 - X[i]) + Math.abs(y1 - Y[i]));\n            long dist2 = 100L * (Math.abs(x2 - X[i]) + Math.abs(y2 - Y[i]));\n            if (dist1 < minDist1) {\n                minDist1 = dist1;\n            }\n            if (dist2 < minDist2) {\n                minDist2 = dist2;\n            }\n        }\n\n        long fountainDistance = minDist1 + minDist2;\n\n        long result = Math.min(directDistance, fountainDistance);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:16:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class NevermoreRouting {\n    static final int MAX = 100_000_000;\n    static final int DIST = 100;\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    static class Fountain {\n        int avenue, street;\n        Fountain(int avenue, int street) {\n            this.avenue = avenue;\n            this.street = street;\n        }\n    }\n    \n    public static long shortestDistance(int x1, int y1, int x2, int y2, List<Fountain> fountains) {\n        Set<Point> fountainSet = new HashSet<>();\n        for (Fountain f : fountains) {\n            fountainSet.add(new Point(f.avenue, f.street));\n        }\n        \n        // Direct path\n        long directPath = Math.abs(x1 - x2) * DIST + Math.abs(y1 - y2) * DIST;\n        \n        // Check paths via fountains\n        long minPath = directPath;\n        \n        for (Fountain f1 : fountains) {\n            for (Fountain f2 : fountains) {\n                if (f1 != f2) {\n                    // Path: start -> f1 -> f2 -> end\n                    long path1 = Math.abs(x1 - f1.avenue) * DIST + Math.abs(y1 - f1.street) * DIST;\n                    long path2 = Math.abs(f1.avenue - f2.avenue) * DIST + Math.abs(f1.street - f2.street) * DIST;\n                    long path3 = Math.abs(f2.avenue - x2) * DIST + Math.abs(f2.street - y2) * DIST;\n                    \n                    minPath = Math.min(minPath, path1 + path2 + path3);\n                }\n            }\n        }\n        \n        return minPath;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        List<Fountain> fountains = new ArrayList<>();\n        fountains.add(new Fountain(10, 20));\n        fountains.add(new Fountain(30, 40));\n        \n        long result = shortestDistance(0, 0, 50, 50, fountains);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:17:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_N = 1e5 + 5;\n\nstruct Fountain {\n    int x, y;\n    bool operator<(const Fountain& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\nset<Fountain> fountains;\n\nll manhattan_dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) * 100LL + abs(y1 - y2) * 100LL;\n}\n\nll solve(int x1, int y1, int x2, int y2) {\n    // Direct path\n    ll direct_dist = manhattan_dist(x1, y1, x2, y2);\n    \n    // Check if path can be optimized via fountains\n    ll min_dist = direct_dist;\n    \n    for (const auto& f1 : fountains) {\n        // If fountain on source street/avenue\n        if ((f1.x == x1 || f1.y == y1) && (f1.x == x2 || f1.y == y2)) {\n            ll path1 = manhattan_dist(x1, y1, f1.x, f1.y);\n            ll path2 = manhattan_dist(f1.x, f1.y, x2, y2);\n            min_dist = min(min_dist, path1 + path2);\n        }\n        \n        for (const auto& f2 : fountains) {\n            if (f1.x == f2.x || f1.y == f2.y) continue;\n            \n            // Check if fountain-fountain path is valid\n            ll path1 = manhattan_dist(x1, y1, f1.x, f1.y);\n            ll path2 = manhattan_dist(f1.x, f1.y, f2.x, f2.y);\n            ll path3 = manhattan_dist(f2.x, f2.y, x2, y2);\n            min_dist = min(min_dist, path1 + path2 + path3);\n        }\n    }\n    \n    return min_dist;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int N;\n    cin >> N;\n    \n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        fountains.insert({x, y});\n    }\n    \n    int Q;\n    cin >> Q;\n    \n    while (Q--) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shortest_distance(x1, y1, x2, y2, fountains):\n    def distance_between_points(a, b, c, d):\n        return abs(a - c) + abs(b - d)\n\n    direct_distance = distance_between_points(x1, y1, x2, y2) * 100\n\n    min_distance = direct_distance\n    for fx, fy in fountains:\n        if (x1 != fx and y1 != fy) and (x2 != fx and y2 != fy):\n            distance_via_fountain = (\n                distance_between_points(x1, y1, fx, fy)\n                + distance_between_points(fx, fy, x2, y2)\n            ) * 100\n            min_distance = min(min_distance, distance_via_fountain)\n\n    return min_distance\n\n# Example usage:\nx1, y1 = 0, 0\nx2, y2 = 100, 100\nfountains = [(50, 50), (60, 60)]\nresult = shortest_distance(x1, y1, x2, y2, fountains)\nprint(result)",
    "timestamp": "2025-08-13 14:21:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class NevermoreCity {\n\n    static class Point {\n        int x, y;\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static int shortestDistance(Point start, Point end, List<Point> fountains) {\n        Set<Integer> avenuesWithFountains = new HashSet<>();\n        Set<Integer> streetsWithFountains = new HashSet<>();\n        \n        for (Point fountain : fountains) {\n            avenuesWithFountains.add(fountain.x);\n            streetsWithFountains.add(fountain.y);\n        }\n        \n        int dx = Math.abs(start.x - end.x);\n        int dy = Math.abs(start.y - end.y);\n\n        if (dx == 0 || dy == 0) {\n            return 100 * (dx + dy);\n        }\n\n        boolean startAvenueHasFountain = avenuesWithFountains.contains(start.x);\n        boolean endAvenueHasFountain = avenuesWithFountains.contains(end.x);\n        boolean startStreetHasFountain = streetsWithFountains.contains(start.y);\n        boolean endStreetHasFountain = streetsWithFountains.contains(end.y);\n\n        int directTravel = 100 * (dx + dy);\n        int xTravelWithFountain = startAvenueHasFountain || endAvenueHasFountain ? directTravel + 200 : directTravel;\n        int yTravelWithFountain = startStreetHasFountain || endStreetHasFountain ? directTravel + 200 : directTravel;\n\n        return Math.min(xTravelWithFountain, yTravelWithFountain);\n    }\n\n    public static void main(String[] args) {\n        List<Point> fountains = Arrays.asList(new Point(3, 2), new Point(5, 5));\n        Point start = new Point(0, 0);\n        Point end = new Point(7, 8);\n        System.out.println(shortestDistance(start, end, fountains)); // Output will depend on fountain locations\n    }\n}",
    "timestamp": "2025-08-13 14:21:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_FOUNTAINS 100000\n\ntypedef struct {\n    int x, y;\n} Fountain;\n\nFountain fountains[MAX_FOUNTAINS];\nint n;\n\nint cmpX(const void *a, const void *b) {\n    return ((Fountain*)a)->x - ((Fountain*)b)->x;\n}\n\nint cmpY(const void *a, const void *b) {\n    return ((Fountain*)a)->y - ((Fountain*)b)->y;\n}\n\nint abs(int x) {\n    return x < 0 ? -x : x;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculateDistance(int x1, int y1, int x2, int y2) {\n    return (abs(x2 - x1) + abs(y2 - y1)) * 100;\n}\n\nint main() {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d\", &x1, &y1);\n    scanf(\"%d %d\", &x2, &y2);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &fountains[i].x, &fountains[i].y);\n    }\n\n    int directDist = calculateDistance(x1, y1, x2, y2);\n\n    qsort(fountains, n, sizeof(Fountain), cmpX);\n    int closestX1 = INT_MAX, closestX2 = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        int dist1 = calculateDistance(x1, y1, fountains[i].x, fountains[i].y);\n        int dist2 = calculateDistance(x2, y2, fountains[i].x, fountains[i].y);\n        if (dist1 < closestX1) closestX1 = dist1;\n        if (dist2 < closestX2) closestX2 = dist2;\n    }\n\n    qsort(fountains, n, sizeof(Fountain), cmpY);\n    int closestY1 = INT_MAX, closestY2 = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        int dist1 = calculateDistance(x1, y1, fountains[i].x, fountains[i].y);\n        int dist2 = calculateDistance(x2, y2, fountains[i].x, fountains[i].y);\n        if (dist1 < closestY1) closestY1 = dist1;\n        if (dist2 < closestY2) closestY2 = dist2;\n    }\n\n    int result = directDist;\n    if (n > 0) {\n        result = min(result, closestX1 + closestX2);\n        result = min(result, closestY1 + closestY2);\n    }\n\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:21:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = numeric_limits<ll>::max();\nconst ll DIST_MOVE = 100;\n\nint main() {\n    int N;\n    cin >> N;\n\n    set<int> fountainStreets; // X\n    set<int> fountainAvenues; // Y\n    vector<pii> fountains(N);\n\n    for (int i = 0; i < N; i++) {\n        int X_i, Y_i;\n        cin >> X_i >> Y_i;\n        fountains[i] = {X_i, Y_i};\n        fountainStreets.insert(Y_i);\n        fountainAvenues.insert(X_i);\n    }\n\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    ll minDistance = abs(x1 - x2) * DIST_MOVE + abs(y1 - y2) * DIST_MOVE;\n\n    // Check nearest fountain on the same street y1\n    auto itX = fountainAvenues.lower_bound(x1);\n    if (itX != fountainAvenues.end()) {\n        int x = *itX;\n        ll currentDist = abs(x1 - x) * DIST_MOVE + DIST_MOVE + abs(x - x2) * DIST_MOVE + abs(y1 - y2) * DIST_MOVE;\n        minDistance = min(minDistance, currentDist);\n    }\n    if (itX != fountainAvenues.begin()) {\n        itX--;\n        int x = *itX;\n        ll currentDist = abs(x1 - x) * DIST_MOVE + DIST_MOVE + abs(x - x2) * DIST_MOVE + abs(y1 - y2) * DIST_MOVE;\n        minDistance = min(minDistance, currentDist);\n    }\n\n    // Check nearest fountain on the same avenue x1\n    auto itY = fountainStreets.lower_bound(y1);\n    if (itY != fountainStreets.end()) {\n        int y = *itY;\n        ll currentDist = abs(y1 - y) * DIST_MOVE + DIST_MOVE + abs(y - y2) * DIST_MOVE + abs(x1 - x2) * DIST_MOVE;\n        minDistance = min(minDistance, currentDist);\n    }\n    if (itY != fountainStreets.begin()) {\n        itY--;\n        int y = *itY;\n        ll currentDist = abs(y1 - y) * DIST_MOVE + DIST_MOVE + abs(y - y2) * DIST_MOVE + abs(x1 - x2) * DIST_MOVE;\n        minDistance = min(minDistance, currentDist);\n    }\n    \n    cout << minDistance << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:21:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shortest_path(x1, y1, x2, y2, fountains):\n    # Direct distance without fountains\n    direct_dist = abs(x1 - x2) * 100 + abs(y1 - y2) * 100\n    \n    # Check if fountain path can help\n    min_dist = direct_dist\n    \n    for fx, fy in fountains:\n        # Paths via single fountain\n        if fx == x1 or fx == x2 or fy == y1 or fy == y2:\n            path1 = abs(x1 - fx) * 100 + abs(y1 - fy) * 100\n            path2 = abs(x2 - fx) * 100 + abs(y2 - fy) * 100\n            min_dist = min(min_dist, path1 + path2)\n    \n    return min_dist\n\ndef main():\n    N = int(input())\n    fountains = []\n    \n    for _ in range(N):\n        x, y = map(int, input().split())\n        fountains.append((x, y))\n    \n    Q = int(input())\n    \n    for _ in range(Q):\n        x1, y1, x2, y2 = map(int, input().split())\n        print(shortest_path(x1, y1, x2, y2, fountains))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 14:21:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    x1, y1, x2, y2 = map(int, input[ptr:ptr+4])\n    ptr +=4\n    \n    fountains_x = []\n    fountains_y = []\n    x_to_y = {}\n    y_to_x = {}\n    \n    for _ in range(N):\n        x, y = map(int, input[ptr:ptr+2])\n        ptr +=2\n        fountains_x.append(x)\n        fountains_y.append(y)\n        x_to_y[x] = y\n        y_to_x[y] = x\n    \n    fountains_x.sort()\n    fountains_y.sort()\n    \n    def get_min_distance(a, b, c):\n        # a and b are coordinates, c is sorted list\n        if not c:\n            return abs(a - b) * 100\n        idx = bisect.bisect_left(c, a)\n        candidates = []\n        if idx > 0:\n            candidates.append(c[idx-1])\n        if idx < len(c):\n            candidates.append(c[idx])\n        min_dist = abs(a - b) * 100\n        for cand in candidates:\n            dist = abs(a - cand) * 100 + abs(b - cand) * 100 + 10\n            if dist < min_dist:\n                min_dist = dist\n        return min_dist\n    \n    # Case 1: Direct path without fountains\n    direct_distance = (abs(x1 - x2) + abs(y1 - y2)) * 100\n    \n    # Case 2: Use fountain in x direction\n    min_x_path = float('inf')\n    if fountains_x:\n        idx_x1 = bisect.bisect_left(fountains_x, x1)\n        candidates_x = []\n        if idx_x1 > 0:\n            candidates_x.append(fountains_x[idx_x1 - 1])\n        if idx_x1 < len(fountains_x):\n            candidates_x.append(fountains_x[idx_x1])\n        for x in candidates_x:\n            y = x_to_y[x]\n            dist = abs(x1 - x) * 100 + abs(y2 - y) * 100 + 10\n            if dist < min_x_path:\n                min_x_path = dist\n    \n    # Case 3: Use fountain in y direction\n    min_y_path = float('inf')\n    if fountains_y:\n        idx_y1 = bisect.bisect_left(fountains_y, y1)\n        candidates_y = []\n        if idx_y1 > 0:\n            candidates_y.append(fountains_y[idx_y1 - 1])\n        if idx_y1 < len(fountains_y):\n            candidates_y.append(fountains_y[idx_y1])\n        for y in candidates_y:\n            x = y_to_x[y]\n            dist = abs(y1 - y) * 100 + abs(x2 - x) * 100 + 10\n            if dist < min_y_path:\n                min_y_path = dist\n    \n    # Case 4: Use two fountains\n    min_two_fountains = float('inf')\n    if fountains_x and fountains_y:\n        # Find x in fountains_x and y in fountains_y\n        # Choose x near x1 or x2, y near y1 or y2\n        # But for simplicity, check all possible x and y in candidates\n        candidates_x_for_two = []\n        idx_x1 = bisect.bisect_left(fountains_x, x1)\n        if idx_x1 > 0:\n            candidates_x_for_two.append(fountains_x[idx_x1 - 1])\n        if idx_x1 < len(fountains_x):\n            candidates_x_for_two.append(fountains_x[idx_x1])\n        idx_x2 = bisect.bisect_left(fountains_x, x2)\n        if idx_x2 > 0:\n            candidates_x_for_two.append(fountains_x[idx_x2 - 1])\n        if idx_x2 < len(fountains_x):\n            candidates_x_for_two.append(fountains_x[idx_x2])\n        \n        candidates_y_for_two = []\n        idx_y1 = bisect.bisect_left(fountains_y, y1)\n        if idx_y1 > 0:\n            candidates_y_for_two.append(fountains_y[idx_y1 - 1])\n        if idx_y1 < len(fountains_y):\n            candidates_y_for_two.append(fountains_y[idx_y1])\n        idx_y2 = bisect.bisect_left(fountains_y, y2)\n        if idx_y2 > 0:\n            candidates_y_for_two.append(fountains_y[idx_y2 - 1])\n        if idx_y2 < len(fountains_y):\n            candidates_y_for_two.append(fountains_y[idx_y2])\n        \n        for x in candidates_x_for_two:\n            for y in candidates_y_for_two:\n                dist = abs(x1 - x) * 100 + abs(y1 - y) * 100 + abs(x2 - x) * 100 + abs(y2 - y) * 100 + 20\n                if dist < min_two_fountains:\n                    min_two_fountains = dist\n    \n    min_distance = min(direct_distance, min_x_path, min_y_path, min_two_fountains)\n    print(min_distance)\n\nsolve()",
    "timestamp": "2025-08-13 14:22:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findShortestDistance(x1, y1, x2, y2, fountains) {\n    const streetDistance = Math.abs(y2 - y1) * 100;\n    const avenueDistance = Math.abs(x2 - x1) * 100;\n\n    const directDistance = streetDistance + avenueDistance;\n    let shortestDistance = directDistance;\n\n    for (const [fountainX, fountainY] of fountains) {\n        if (fountainX !== x1 && fountainX !== x2 && fountainY !== y1 && fountainY !== y2) {\n            const viaFountainDistance = \n                Math.abs(y1 - fountainY) * 100 + \n                Math.abs(x1 - fountainX) * 100 +\n                Math.abs(y2 - fountainY) * 100 + \n                Math.abs(x2 - fountainX) * 100;\n            shortestDistance = Math.min(shortestDistance, viaFountainDistance);\n        }\n    }\n\n    return shortestDistance;\n}",
    "timestamp": "2025-08-13 14:22:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestDistance(x1, y1, x2, y2, fountains) {\n    const fountainSet = new Set(fountains.map(f => `${f[0]},${f[1]}`));\n    \n    // Direct Manhattan distance\n    let directDistance = Math.abs(x1 - x2) * 100 + Math.abs(y1 - y2) * 100;\n    \n    // Try all possible routes through fountains\n    let minDistance = directDistance;\n    \n    for (let fx of fountains) {\n        for (let fy of fountains) {\n            if (fx[0] === fy[0] && fx[1] === fy[1]) continue;\n            \n            // Distance to first fountain\n            let d1 = Math.abs(x1 - fx[0]) * 100 + Math.abs(y1 - fx[1]) * 100;\n            \n            // Distance between fountains\n            let dfountain = Math.abs(fx[0] - fy[0]) * 100 + Math.abs(fx[1] - fy[1]) * 100;\n            \n            // Distance from second fountain to destination\n            let d2 = Math.abs(fy[0] - x2) * 100 + Math.abs(fy[1] - y2) * 100;\n            \n            minDistance = Math.min(minDistance, d1 + dfountain + d2);\n        }\n    }\n    \n    return minDistance;\n}",
    "timestamp": "2025-08-13 14:22:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestDistance(N, fountains, x1, y1, x2, y2) {\n    const MAX = 1e8 * 100;\n    let minDist = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    \n    // Process fountains in x and y directions\n    const xFountains = [];\n    const yFountains = [];\n    for (const [x, y] of fountains) {\n        xFountains.push(x);\n        yFountains.push(y);\n    }\n    xFountains.sort((a, b) => a - b);\n    yFountains.sort((a, b) => a - b);\n    \n    // Binary search for closest x fountain\n    const closestX = findClosest(xFountains, x1, x2);\n    for (const x of closestX) {\n        const dist = Math.abs(x1 - x) + Math.abs(x2 - x) + 200;\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    }\n    \n    // Binary search for closest y fountain\n    const closestY = findClosest(yFountains, y1, y2);\n    for (const y of closestY) {\n        const dist = Math.abs(y1 - y) + Math.abs(y2 - y) + 200;\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    }\n    \n    // Check all fountains as intermediate points\n    for (const [x, y] of fountains) {\n        const dist = Math.abs(x1 - x) + Math.abs(y1 - y) + Math.abs(x2 - x) + Math.abs(y2 - y) + 200;\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    }\n    \n    return minDist * 100;\n}\n\nfunction findClosest(arr, a, b) {\n    const result = new Set();\n    const lower = Math.min(a, b);\n    const upper = Math.max(a, b);\n    \n    let left = 0;\n    let right = arr.length - 1;\n    let best = -1;\n    \n    // Find the largest x <= lower\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] <= lower) {\n            best = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    if (best !== -1) {\n        result.add(arr[best]);\n    }\n    \n    // Find the smallest x >= upper\n    left = 0;\n    right = arr.length - 1;\n    best = -1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] >= upper) {\n            best = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (best !== -1) {\n        result.add(arr[best]);\n    }\n    \n    // Find the closest x between lower and upper\n    left = 0;\n    right = arr.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] >= lower && arr[mid] <= upper) {\n            result.add(arr[mid]);\n            break;\n        } else if (arr[mid] < lower) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return Array.from(result);\n}",
    "timestamp": "2025-08-13 14:23:11"
  }
]